|	INLEIDING TT-DIGGER v 4.x
|	TT-Digger v4.x is een superset op ST-Digger.
|	Het kan alles wat ST_Digger kan, EN MEER!
|	Zoals de naam al suggereert is het programma nu geschikt om code
|	toegespitst op de hardware van de TT en de Falcon te analyseren.
|	Het programma is nu volledig resolutie onafhankelijk.
|	Het is getest op TT grootbeeld, vele resoluties die mogelijk zijn
|	met een NOVA videokaart & natuurlijk nog steeds de goede oude ST
|	(o.a. via een scart kabel verbonden met een Televisie toestel.)
|
|	In de tekst die volgt is alles wat betrekking heeft op de wijzigingen
|	c.q. aanvullingen gemarkeerd met een | in de kantlijn.
|
|	Waar ST-Digger vermeld wordt leest men TT-Digger v4.x
|
|							H. Robbers
|							Te Amsterdam

INLEIDING ST-DIGGER v 3.x, TT-DIGGER v 4.x

ST-Digger is een programma dat bedoeld is om te "graven" in 
bestaande software, bijvoorbeeld het TOS-ROM. De codes in het ROM 
of in een file kunnen worden vertaald naar assembler-taal, 
hexadecimale getallen of ASCII tekst. De assembler-taal (met 
symbolische labels) maakt het mogelijk het programma te wijzigen 
en opnieuw te assembleren. Het ROM kan uiteraard niet worden 
gewijzigd, maar vormt wel een zeer interessant studie-object.

|	Deze handleiding geeft geen uitleg over de (MC68K serie)
assemblertaal zelf. Hiervoor wordt verwezen naar de diverse leerboeken. 
Voor de meest nauwkeurige informatie over deze machinetaal is het 
handig het "MOTOROLA M68000 16/32-BIT MICROPROCESSOR PROGRAMMER'S 
REFERENCE MANUAL" (Prentice-Hall,Inc, ISBN 0-13-566795-X) bij de 
hand te hebben. Dit engelstalige boek is echter niet iets voor 
beginners.
| TT-Digger v4 is gebaseerd op de boeken:
|     MC68030 Enhanced 32-bit Microprocessors Manual 3d edition
|             Prentice Hall  ISBN 0-13-566423-3
|     MC68000 family Programmers reference maunal
|             Mororola  ISBN 1-13-723289-6
|     MC68881/MC68882 Floating-point Coprocessor User's Manual
|             Prentice Hall  ISBN 0-13-566936-7
| Wie inmiddels gevorderd is tot TTD v.4 zal met deze boeken geen enkele
|  moeite hebben.

ST-Digger werkt met de Engelse taal, aangezien dit het beste 
aansluit bij het jargon van de assemblertaal. 
Bij voldoende belangstelling is ook een Nederlandse en een 
Duitse versie uitgebracht.
| Zie UPDATE.TXT

Alle getallen worden in hexadecimale vorm ingevoerd en 
weergegeven. Dit blijkt op den duur de meest handige vorm te zijn 
voor het werken in machinetaal. Voor degenen die er nog niet aan 
gewend zijn is het aan te raden om niet te proberen exact met 
hexadecimale getallen te rekenen. Dat kan  beter aan de computer 
worden overlaten. Het is wel zinvol een tabel met enige 
"sleutelwaarden" bij de hand te hebben om een idee te krijgen van 
de grootte van hexadecimale getallen.

|   TT-Digger werkt naar keuze met decimale of hexadecimale weergave.
|     Ik ben opgegroeid met een octale computer (ICL 1900 serie, 24-bits).
|     Het is onzin om adressen anders dan decimaal weer te geven.
|        En een disassembler WEET wat een adres is.
|     Octaal en Hexadecimaal zijn nuttig in 2 gevallen:
|     1: Je hebt geen flauw idee wat voor verzameling bits je onder handen
|     hebt. Met Octaal & Hex kan je de afzonderlijke bits in een compacte
|     vorm zichtbaar maken.
|     2: Je weet wat je hebt, maar je programma kent geen algemene methode
|     om dit geformatteerd weer te geven; Codes, bitpatronen in delen van
|     computer woorden, etcetera (#immediate operands van instructies).
|        Men noemt dit wel Post-mortem info.
|     Helaas heeft TT-Digger nog niet de mogelijkheid om de weergave van
|     afzonderlijke operands per stuk te beinvloeden.
|     In een verre toekomst wordt dit wellicht ooit gerealiseerd.
|     De bedoeling is dat het programma nog steeds op kleine ST's blijft
|     draaien.
|     Waar in een voorbeeld $xxxx vermeld is kan ook dddd (decimaal)
|     gelezen worden.

ST-Digger is voor het grootste deel geschreven in GFA-Basic, 
aangevuld met assemblercode voor tijdrovende onderdelen zoals 
label-generatie, het zoeken naar labels en de schermuitvoer.


FEATURES
.    Betrouwbare universele disassembler.

.    Volledig menu- en muisgestuurd programma.

|.   Volledig GEM conform

.    Uitvoer naar beeldscherm, printer of file.

.    Voledige controle van de toelaatbaarheid van de adersseringmodi.

.    Supersnelle generatie van labels.

.    De labelgenerator werkt ook bij zeer grote programma's.

.    De labelgeneratie houdt rekening met relocatie-informatie.

.    ook labels bij schermweergave.

.    Interactief (met de muis) volgen van sprongen en verwijzingen.

.    Bijhouden van een "current directory" en diverse defaults.

| .    Terugbladeren (UNDO) tot 256 stappen terug.

.    Detectie van niet-beschikbaarheid van de printer.

.    Goede samenwerking met accessoires.

.    Snelle decodering van instructies.

.    Supersnel zoeken van hexadecimale codes, teksten of relatieve 
     verwijzingen.
|       Alle verwijzingen.

.    Vermelding van header-informatie in commentaar aan  het begin 
     van de listing.

.    Onderscheid tussen labels in TEXT, DATA en BSS segmenten.

.    Overzichtelijke markering van onvoorwaardelijke sprongen.

.    Commentaar bij GEMDOS, BIOS, XBIOS, Line_A en Line-F aanroepen.

.    Toegang tot de CARTRIDGE-poort.

.    Toegang tot disksectoren (ook harddisk en ramdisk).

.    Testen van "uitvoerbare" bootsectoren (bootvirus).

.    Testen van correcte programmastructuur (linkvirus).

.    Aan te passen an diverse assemblers (GST, HiSoft, GfA, MCC,
|    MAS, PASM etc.).

.    Ook labels in het BSS-segment.

.    Markeren van data in het TEXT-segment.

.    Afzonderlijk markeren van DC.B, DC.W en DC.L data.

.    Data-markeringen werken ook door in de label-generatie.

.    Bewaren van data-markeringen in een indexfile.

.    Verwerken van de eventuele SymbolTable in labels.

.    Volledige decodering van DRI-objectfiles, inclusief externe
     verwijzingen en "equates".

| .  Volledig decoderen van Pure_C objectfiles, inclusief 'module' labels.


DE MENUBALK

Desk

Hier bevinden zich de gebruikelijke copyright-informatie en de 
eventuele accessoires. Via "About ST-Digger" wordt het ook het 
serienummer zichtbaar.

Input

De keuzemogelijkheden zijn File, Disk Sectors, RAM, TOS,
Cartridge, Load Index en Quit.

...  File...
     Haal een file in het geheugen. Omwille van de snelheid van 
     verwerking wordt de gehele file in het geheugen geladen. De 
     werkelijke plaats in het geheugen is niet van belang aangezien 
     alle adressen ten opzichte van het begin van de file worden 
     gegeven. Uitvoerbare programma's (bijv. .APP, .ACC, .PRG, 
     .TOS, .GTP of .TTP) of DRI/Pure-C objectmodules (.O) worden speciaal
     behandeld. Extreem grote files (of te weinig beschikbaar 
     geheugen door RAMdisks o.i.d.) kunnen leiden tot de fout "Out
     of memory".

     Na aanklikken van FILE... komt eerst een "Drive Selector" op 
     het scherm. Hiermee wordt de drive (A..P) gekozen. 
     Niet beschikbare drives worden "licht" weergegeven. (Als CANCEL 
     wordt gekozen en er bevindt zich nog een vorige file in het 
     geheugen, dan wordt naar deze file overgeschakeld.). N.B.: De
     drive-selector wordt onderdrukt bij TOS 1.4 en hoger.

     Vervolgens verschijnt de bekende "File Selector". Deze kan 
     alleen worden verlaten door het kiezen van een bestaande 
     file (of via CANCEL, de vorige file is dan echter al wel 
     gewist).

     Hierna wordt de file in het geheugen geladen. Als de file 
     een geschikte programma-header heeft (PRG, TOS, TTP, APP, 
     ACC files) dan wordt de relocatie-informatie verwerkt. Als 
     het geen programma-file is dan wordt gevraagd wat het 
     veronderstelde startadres van de file is (bijvoorbeeld 
     $FC0000 voor een "dump" van het ROM). Dit adres moet in 
     hexadecimale vorm worden gegeven.

|    Als gekozen is voor decimale getallen in decimaal.
|    Wil men dan toch HEX ingeven, dan met '$' vooraf.
|    Dit geldt voor alle soortgelijke gevallen verder in deze beschrijving.

     Als een programma of een module nog extra informatie bevat 
     na de relokatietabel, dan wordt de keuze geboden tussen het
     bekijken (Show) van deze extra informatie - misschien een 
     linkvirus - of het negeren van deze informatie (Ignore).
|    Pure_C files kunnen DEBUG info bevatten, dit wordt herkend.

...  Disk Sectors...
     Haal een aaneengesloten reeks van disksectoren in het geheugen. 
     Dit kan handig zijn bij het bestuderen van bootvirussen.
     Bij deze opdracht wordt gecontroleerd of de bootsector 
     uitvoerbaar is. 

...  RAM...

     Geeft toegang tot (een gedeelte van) het RAM. De mogelijkheid 
     voor het genereren van labels maakt het nodig een "range" op 
     te geven. De adressen van het begin en het einde van de range 
     moeten in hexadecimale vorm worden gegeven. De "default"-waarden
     hebben betrekking op de TPA (Transient Program Area).

     Als een range wordt opgegeven die veel groter is dan het 
     werkelijke beschikbare geheugen, dan kan de fout "Out of 
     memory" optreden.

     De opgegeven range is niet van invloed als alleen een 
     hexadecimaal + ASCII weergave wordt gevraagd. In dat geval 
     kan het gehele gebied van $0 - $3FFFFF worden onderzocht.

     De informatie in het RAM kan veranderen tijdens de loop 
     van het programma, zodat soms vreemde resultaten ontstaan 
     bij het zoeken en bij de label-productie.

...  TOS

     Geeft toegang tot "The Operating System". Dit is gewoonlijk
     het geheugengebied $FC0000 - $FEFFFF ($E00000 - $E3FFFF voor
|    de STE, TT & Falcon; TOS'sen met versie >= 2.06).

...  Cartridge
     Geeft toegang tor de Cartridge-poort. Dit is het geheugengebied
     $FA0000 - $FBFFFF.

...  Load Index...
     Lees de file met de markeringen van data-gebieden (zie het
     hoofdstuk over het markeren van data-gebieden). Deze file kan 
     worden aangemaakt met "Save Index".  Een indexfile geeft alleen 
     zinvolle resultaten in combinatie met het bijbehorende
     gedisassembleerde programma. 

...  Quit... (Q)

     Verlaat het programma. Dit kan ook door middel van een klik in
     de zogenaamde "close-box" van het venster. Voor de zekerheid
     wordt eerst nog nagevraagd of het echt de bedoeling is om te 
     stoppen.
     


Options

     (De weergave van de informatie wordt bepaald door de gekozen 
     opties. De ingeschakelde opties worden gemerkt met een 
     "vinkje".)

...  Opcodes (F1)
     Laat alleen de gedisassembleerde instructies zien.
     
...  HEX/ASC (F2)
     Laat alleen de hexadecimaal- en ASCII-codes zien.
     Alleen codes tussen 32 en 126 worden in de ASCII vorm 
     weergegeven. De overige codes zijn zo specifiek voor de 
     ATARI-ST, dat de meeste printers hiervan geen correcte 
     weergave geven. Deze codes worden daarom vervangen door 
     spaties.  Maar zie UPDATE.TXT

...  Opc+HEX/ASC (F3)
     Laat instructies samen met HEX-codes en ASCII-codes zien.

...  Standard (F4)
     Laat uitsluitend adressen zien (dus geen labels of symbolen).
     Elke instructie wordt voorafgegaan door een adres. Deze
     vorm is niet geschikt als invoer voor een assembler.

...  Labels (F5)
     Laat  labels zien en laat bij uitvoerbare programma's en 
     objectmodules de indeling in segmenten zien. De uitvoer kan
     zonder meer door een assembles worden verwerkt.

     Bij de eerste inschakeling kan het enkele seconden duren 
     voordat alle labels zijn gevonden.

|       Op de TT met cache en TT-Digger in TT-ram duurt het genereren
|       van de labels van TOS 3.06 met volledige 68030/68881 instructie-
|       set iets meer dan 1 hele seconde.

     De labels bestaan uit een letter (R voor gewone labels in 
     het TEXT-segment, T voor labels in het DATA-segment, U voor
     labels in het BSS-segment of X voor labels in als data 
     gemarkeerde gedeeltes in het TEXT-segment) gevolgd door
     het hexadecimale adres. Alle labels zijn evenlang en 
     vallen niet samen met opcodes (door de keuze van de eerste 
     letter!), zodat vervanging door meer betekenisvolle namen, 
     met behulp van een editor, eenvoudig mogelijk is.

     Adressen die beneden de TEXT-sectie vallen worden 
     aangegeven in de vorm R000-$xxx. Adressen boven de BSS-sectie
     worden aangeduid in de vorm R000+$xxx.

...  Symbols (F6)
     Laat zoveel mogelijk de symbolen uit de symbooltabel zien
     in plaats van de labels. (N.B.: uitvoerbare programma's
     bevatten alleen een symbooltabel als dit via een insructie aan 
     de linker is opgegeven. De meeste commercieel verkrijgbare 
|    programma's bevatten geen symbooltabel.). Bij DRI/Pure_C
     modules worden ook alle!"equate"-, "xdef"-, "xref"- en
     "comm"-directieven getoond.

     Vaste adressen waarnaar wordt verwezen vanuit een TOS-programma
     worden niet aangeduid met labels. Als het geen TOS-programma
     is, maar ROM, RAM of een file zonder programma-header, dan
     worden absolute adressen binnen de programma-range wel met 
     labels aangegeven.

...  File-Info (F7)
     geeft informatie over de behandelde file.

...  Symbol Table (F8)
     Laat de symbooltabel zien. N.B.: soms kan op deze plaats
     andere informatie staan.

...  DATA Range... (F9)
     Wijzig het begin van het DATA-segment. Dit kan nuttig zijn 
     als de oorspronkeleijke informatie niet correct is (Helaas
     bestaan er compilers en/of linkers die de segmentindeling
     niet goed invullen). De wijziging wordt overigens niet in 
     de file opgeslagen!


Find

In het "Find" menu bevinden zich de mogelijkheden om door het
geheugen of door een file te "navigeren".

...  Next Page (N) of (pijl omlaag)

     Laat de volgende bladzijde zien. Als de uitvoer naar de 
     printer is ingeschakeld, dan wordt deze bladzijde ook 
     afgedrukt.

| ...  Same Page (=)

     Laat de huidige bladzijde zien (nuttig na File Info e.d.).
     Deze bladzijde wordt dan echter niet afgedrukt. 
     Gebruik daarvoor "Print Page" in het "Output" menu.

...  Prev. Page (P) of (pijl omhoog)

     Laat het voorgaande gedeelte zien. Er vindt geen uitvoer 
     naar de printer plaats.

     Als de optie "Opcodes" is ingeschakeld, dan zal geen 
     volledige bladzijde worden teruggesprongen, maar slechts 22 
     tot 44 bytes. Het is mogelijk dat het disassembleren midden 
     in een lange instructie start, zodat de eerste instructies 
     niet correct worden weergegeven. Bij ingeschakelde labels
     (of symbolen) wordt zoveel mogelijk getracht te beginnen bij een 
     label.
|       Het aantal terug te springen bytes wordt afgeleid van de hoogte van
|       het window.
     Bij echt terugbladeren kan meestal beter gebruik worden
     gemaakt van "Undo".
 
...  Address... (A)

     Ga naar een opgegeven adres. Als de uitvoer naar 
     de printer is ingeschakeld, dan wordt de bladzijde ook 
     afgedrukt.

...  HEX code... (H)

     Zoek een combinatie van bytes, opgegeven in hexadecimale
     notatie. Als niets wordt opgegeven, dan wordt verder gezocht
     met een vroegere opgave. De gevonden code wordt op de eerste
     positie  van hetscherm weergegeve. Dit zal vaak geen geldige 
     instructie opleveren.

     N.B.: in tegenstelling tot versie 2 van ST-Digger wordt nu
     ook op oneven adressen gezocht.

...  TEXT... (T)

     Zoek een ASCII-tekst. Alls niets wordt opgegeven dan wordt
     gezocht met een vroegere opgave.

...  Reference... (R) of (V)

     Zoek een "relatieve" verwijzing. Hiermee kan zeer snel de
     plaats worden gevonden waar een label of adres wordt gebruikt. 
     Labels moeten worden opgegeven in de hexadecimale vorm (met of
     zonder voorafgaande R, T, U of X). In deze versie van ST-Digger
     kan niet worden gezocht naar symbolische labels.
|    Maar zie UPDATE.TXT

     Het zoeken begint bij het begin van de huidige bladzijde, maar
     gaat eventueel verder vanaf het begin van de range, zodat de 
     gehele range wordt doorzocht. De zoeksnelheid is zo hoog, dat is 
     afgezien van een onderbreek-mogelijkheid.

     Relatieve verwijzingen (type Bcc, DBcc, dd(PC), d(PC,Rn)) 
     worden altijd op de eerste regel van het scherm weergegeven. 
     Dit kan echter niet worden gegarandeerd voor absolute 
     verwijzingen. Een absolute verwijzing wordt twee bytes vanaf 
     het begin van het scherm geplaatst. Het begin van het scherm 
     valt dan bij gecompliceerde instructies (bijv. MOVE) niet 
     altijd samen met het begin van de instructie!

     Als een relocateerbare PRG-file (b.v. .PRG .TOS .TTP .ACC 
     .APP .O) wordt onderzocht, dan worden alleen relatieve en 
     relocateerbare adressen gevonden. In de andere gevallen 
     worden ook absolute adressen gevonden.

     Soms wordt een imitatie-label gevonden doordat een gedeelte 
     van een instructie of gegevensreeks lijkt op een geldige 
     instructie. Dit treedt vooral op als het programma en de 
     gegevens niet van elkaar zijn gescheiden. Dit geeft geen 
     problemen zolang niet naar dat label wordt verwezen.

|    In TTD is het bedieningsgemak van het zoeken naar verwijzingen
|    sterk verbeterd. 
|    Als aanvulling op click op een label of verwijzing is er nu
|    CNTRL click. Als het een label of verwijzing is wordt ernaar gezocht
|    als boven.
|    Een gevonden verwijzing wordt ongeveer in het midden van het venster
|    gezet met een kader er omheen. Dit plaatst de verwijzing in zijn
|    context. TTD reageert met 'ping' als de verwijzing niet gevonden wordt.
|    <CNTRL V> of <CNTRL R> zoekt naar de volgende.


Output

Met dit menu kan de assemblercode en de HEX-ASCII dump naar de 
diverse uitvoerapparaten worden gedirigeerd. De informatie-
displays (File_Info, DEBUG_Info) worden echter alleen op het 
scherm weergegeven.)

...  Print Page

     Druk de huidige pagina af op de printer. Deze mogelijkheid
     is handig bij het onderzoeken van gedeeltes van een programma.

...  Printer
     Schakelt het "meelopen" van de printer in of uit. Als de
     printer niet online staat wordt een waarschuwing gegeven. 
     In dat geval kan worden gekozen tussen opnieuw proberen
     (RETRY), afbreken (CANCEL) of negeren van de offline status 
     (Ignore). Dit  laatste kan nuttig zijn als de printer niet 
     via de parallelpoort is aangesloten.

...  File...

     Schrijf de gedisassembleerde informatie naar een file. Om 
     ruimte te sparen wordt zoveel mogelijk gebruik gemaakt van
     tab's. Er wordt niet met bladzijden gewerkt, maar er kan 
     een range worden opgegeven.

     Eerst wordt gevraagd of de uitvoermode correct is. Als 
     dit niet het geval is (CANCEL) moet dit eerst via het 
     OPTIONS-menu worden gecorrigeerd.

|    Output met optie F3 en labels: TTD plaatst een ';' voor de
|    hex/ascii info. Maakt er zodoende commentaar van.

     Daarna komen de "Drive-selector" en de "File-selector". De 
     voorgestelde "extensie" (ASM, ASX, HEX) is afhankelijk van 
     de gekozen mode. De voorgestelde file-naam is afgeleid van 
     de naam van de laatst ingelezen file.

     Als een bestaande file wordt gekozen, dan wordt gevraagd of 
     deze mag worden overschreven. Vervolgens kan de uit te 
     voeren "range" worden opgegeven. De "default"-waarden worden 
     verkregen door alleen <return> te geven.

     Daarna start de uitvoer. Er wordt aangegeven hoever een en 
     ander is gevorderd. De uitvoer kan worden onderbroken door 
     het aanslaan van een willekeurige toets. Een "Alert-box" 
     biedt dan de keuze tot afbreken (Abort) of doorgaan 
     (Continue).

     Zorg dat eventuele "write-protect" tabs zijn verwijderd en 
     zorg voor voldoende ruimte op de drive. Bedenk dat de uit te 
     voeren file vele malen groter is dan de invoerfile (ca 8x 
     voor labels+opcode, ca. 24x voor labels+opcode+Hex+ASCII, 
     4.5x voor Hex+ASCII). Het (in 1 keer) naar een file 
     disassembleren van het ROM is alleen voor bezitters van een 
     harddisk weggelegd.

...  Save Index...
     Sla de gegevens over de indeling in data-gebieden op in
     een file (Zie load index). Deze file is in het ASCII-formaat,
     maar de informatie is vrijwel alleen door een computer te 
     interpreteren.

|    Nieuwe menu titel:
MACHINES

...  MC68030    (F11)
     herken 68020 addressing modes.
     herken instructies tot en met de MC68030. 
     bij wijzigen en F5/F6 optie automatisch genereren van labels.

...  MC68881/2  (F12)
     herken hardware floating point instruction set (Line_F)
     bij wijzigen en F5/F6 optie automatisch genereren van labels.

...  inhibited  (F13)
     Mogelijk toekomstige ontwikkeling.

...  decimal    (F14)
     switch tussen decimal & hex.
     scherm wordt hertekend.

     Als het evident is dat hex zinvoller is wordt hex gebruikt:
     met name TOS ROM adressen en 'absolute word' en negatief.

...  opword Xoooo (F15)
     switch opcode representatie.
     scherm wordt hertekend.

     Dit is heel mooi: Als opcodes & hex/ascii (F3) gekozen is,
     worden de eerste 2 bytes (meestal het operation word) als volgt
     weergegeven:
     B15 - B12		de groep: hexadecimaal.
     B11 - B0       de rest:  in vier groepen van 3 bits, ieder in octaal
                              (0-7).
                    Nu kan men snel een instructie waarvan men denkt dat hij
                    gedisassembleerd had moeten worden in de boeken opzoeken.
                    Bijna alle instructies zijn opgebouwd uit groepen van 3
                    bits immers.
|


TOETSENBORD

|   Men kan nu een selectie maken.
|   Zet de muis in het label veld en druk S of E.
|   X maakt de selectie weer ongedaan
|
|   Selecteren is handig voor het markeren van bijvoorbeeld grote
|   lappen text. Als er een selectie op staat, werken W, L, B en C
|   - de markerings opdrachten - op het hele geselecteerde gebied,
|   over labels heen en over oude markeringen heen.
|   Druk daarna op F5 resp F6 en de labels verdwijnen als sneeuw
|   voor de warme augustuszon.

De meeste toetscommando's zijn (tussen haakjes) te vinden bij de
     menu-items. Daarnaast zijn ook de pijltjestoetsen te gebruiken.

    F1-F9    Instellen van weergave-opties
|   F11-F15  idem

    Q        Quit
    N        Next Page (ook <pijl omlaag>, <return> of <enter>)
|   =        Same Page
    P        Prev. Page (ook <pijl omhoog>)
    A        (Find) Address
    H        (Find) Hex Code
    R        (Find) Reference               of V
|   ^R       (Find) Next reference          of ^V
|   S        markeer Start van selectie
|   E        markeer Einde van selectie
|   X        maak selectie ongedaan

Daarnaast zijn er nog extra mogelijkheden:

    <pijl links>  Een of twee bytes terug (naar een even adres).
    <pijl rechts> Een of twee bytes vooruit (naar een even adres). 
    <ClrHome>     Spring naar het begin van de range.
    <Shift-ClrHome>  Spring naar het einde (Vanaf versie 3.0C)  
|   <Undo>        Blader terug. Hiermee kan tot 256 stappen worden
                  teruggebladerd
|   <Shift pijl links>   Maak begin selectie zichtbaar
|   <Shift pijl rechts>  Maak einde selectie zichtbaar

MUISBESTURING

De muis wordt op de gebruikelijke wijze benut voor de keuze uit 
de menu's en voor de "drive-selector" en "file-selector".

De muis maakt het ook mogelijk op snelle wijze naar adressen te 
springen:
-    Als ergens op het scherm een "label" of een adres binnen de 
     "range" wordt getoond, dan kan naar dat adres worden 
     gesprongen door op dit label of adres te "klikken" (werkt 
     ook vanuit het File-Info display).
-    Als (in het Opcode display of het Hex+ASCII display) in de 
     linker 7 posities van een regel wordt geklikt, dan wordt 
     deze regel de nieuwe bovenzijde van de bladzijde.
-    Als in het Hex+ASCII display op een Hex-code of ASCII-code 
     wordt geklikt, dan wordt het adres hiervan het start-adres 
     van de pagina. Op deze wijze kan zonder rekenenen het juiste 
     adres van een Hex-code of ASCII-tekst worden bepaald. 

MARKEREN VAN DATA-GEBIEDEN

(niet toepasbaar bij de optie "Standard")

ST Digger versie 3 kan onderscheid maken tussen machinecode-
instructies, byte-data (dc.b), woord-data (dc.w) en langwoord-data
(dc.l). het markeren van deze gebieden geschiedt door middel van
anwijzen met de muis (in de linker acht posities van het scherm) 
in combinatie met het aanslaan van een lettertoets:

c: markeer 2 bytes als machinecode
b: markeertwee bytes als byte-data
   (bytes in de range $20 - $7E worden als tekst weergegeven)
w: markeer 2 bytes als woord-data
l: markeer 4 bytes als langwoord-data

<shift>
Bovenstaande toetsaanslagen kunnen gecombineerd worden met de shift-
toets. In dat geval wordt het markeren automatisch herhaald tot aan 
het eerstvolgende label.

<control>
De toetsaanslagen kunnen ook worden gecombineerd met de control-toets.
In dat geval wordt het markeren automatisch herhaald tot een markering
wordt gevonden die afwijkt van de oorspronkelijke markering aan het
begin van de range. Op deze wijze kunnen snel grote gebieden worden
gemarkeerd door eerst de laatste bytes van een gebied te markeren
(zonder control-toets) en daarna vanaf het begin van het gebied te 
markeren met de control-toets. Deze methode lijkt wat omslachtig, maar 
werkt in de praktijk goed. Per ongeluk wissen van eerdere markeringen
kom op deze wijze zo veel mogelijk worden voorkomen.

|   Met selectie op:
|   Geen <shift> of ,control> nodig.
|	Alles wat geselecteerd is wordt gemarkeerd, ook bestaande markeringen.
|	Alleen datgene wat in relocatie informatie vermeld staat als
|	'absolute long reference' blijft ongewijzigd. Deze informatie is zo
|   hard, daar blijven we vanaf.
|	'Met selectie' is een combinatie van het beste van shift & control.

|   Als er een selectie actief is, maar deze is buiten beeld geraakt, kan
|   men aan de muiswijzer zien dat er een selectie is. De muiswijzer vormt
|   een vet kruis.
|   Denk aan  shift<--  en shift-->  om snel het begin resp eind van de
|   selectie terug te toveren.
|      NOTA MAXIMA BENE:
|   Bij switchen van F1/F3 naar F2 blijven de begin & eind
|   markeringen ongewijzigd. Altijd wordt een hele regel geinverteerd
|   weergegevn. bij F2 kan de werkelijke hoeveelheid bytes kleiner zijn dan
|   op een regel staat.
|   Omgekeerd daarentegen wanneer geselecteerd is in F2 mode (hele regels),
|   zal dit bij F1/F3 mode blijven kloppen, misschien teveel dan de bedoeling
|   was, doch dat is gemakkelijk met 'S' en 'E' aan te passen.

N.B. Het is niet mogelijk om machinecode te markeren in het data-segment.
Als dit toch nodig is dan kan het begin van het data-segment worden 
aangepast via de menu-optie "DATA range".

De labelgeneratie houdt rekening met de data-markeringen. Om tijd te
sparen wordt de labelgeneratie echter niet automatisch gestart tijdens
het markeren. Ondanks de zeer hoge snelheid zou dit toch te veel tijd 
kosten. Na het markeren moet de menu-optie "Labels" (of de toets F5)
worden gekozen voor het opnieuw genereren van labels. Als er een 
symbooltabel bestaat kan ook de menu-optie "Symbols" (of de toets F6)
worden gekozen.

Vergeet niet om de markeringsarbied op te slaan in een index-file.
(vanaf versie 3.0C wordt u hieraan herinnerd). Als voorbeeld van de
mogelijkheden zijn de index-files voor TOS 1.0, TOS 1.4 en TOS 1.6
opgenomen (de officiele UK-versies). Er wordt geen garantie gegeven
voor de correctheid of de volledigheid van deze index-files.

|   CONFIGURATIE-FILE

|   Bij het starten van TT-Digger wordt in de "folder", van waaruit wordt
|   gestart, gezocht naar een file "TTD_4.CFG". De tekst in deze file wordt
|   dan (eenmalig) ingelezen en bewaard. ST-Digger kan worden aangepast
|   aan diverse assemblers door de file TTD_4.CFG te wijzigen.

|   Indeling voor de TTD_4.CFG file:

|   syntax:  keyword,characterstring
|   nil staat voor werkelijke empty string
|   De volgorde doet er niet meer toe. De eerste 3 ch's van keyword zijn
|   significant. De checks zijn niet erg streng. Vooral de komma niet vergeten.
|   0 is hetzelfde als 'false' of 'FALSE', al het andere is 'true'
|   Onbekende keywords worden simpelweg overgeslagen. (Zo kan je nog eens wat
|   afschaffen)

|   keyword,default   korte omschrijving

|   r15,false     PASM: r0 t/m r15 zijn registers; true: L0 t/m L15
|   title,nil     titelregel voor uitvoer naar disk
|   text,;TEXT    directief voor TEXT-sectie (bijv. TEXT, .text of secton TEXT)
|   data,;DATA    directief voor DATA-sectie (bijv. DATA, .data of section DATA)
|   bss,;BSS      directief voor BSS-sectie ((bijv. BSS, .bss of section BSS
|   xdef,xdef     directief voor export (xdef, export of .globl)
|   xref,xref     directief voor import (xref, import of .globl)
                  nil: suppress listing van externals in 'defines' gedeelte
|   common,comm   directief voor common (bijv. .comm)
|   mod,.module   directief voor Pure_C 'modules'
                  nil: suppress 'module'
|   sbr,.b        extensie voor 8  bit branches (.b of .s)
|   wbr,nil       extensie voor 16 bit branches (.w)
|   lbr,.l        extensie voor 32 bit branches (.l)   | NIEUW!! 68030 |
|   wabs,.w       extensie voor "absolute word" (bijv. .w)
|   labs,nil      extensie voor "absolute long" (bijv. .l)
|   wordsize,false
|   lsep,:        scheidingsteken na label
|   illegal,nil   aanduiding voor illegal instructie
|   ext,.S        extensie voor filenaam met assembler output
|   wordop,nil
|   vslider,0     implementeer verticale slider in window
|   hslider,0     implementeer horizontale slider in window
                  Wie beide sliders opgeeft krijgt ook sizer,fuller & mover
                  (cosmetisch).
                  Vroeger paste alles altijd in 80 bytes.
                  Nu met full extended addressing modes (maximaal 4 namen bij
                  een move) en lange namen bij Pure_C, kan de gedisassembleerde
                  text te lang worden. Als hslider niet is opgegeven geeft
                  TT-Digger eenmalig een alert. De te lange regels worden
                  voorzien van 2 pijltjes (als bij GFA). Output naar disc gaat
                  wel goed. Geeft men horizontale slider op, nu ja, dan kan
                  men natuurlijk gewoon sliden.
                  Ze nemen natuurlijk wel ruimte in, deze features zijn dan
                  ook voornamelijk bedoeld voor grotere schermen.
|   sizer,0       implementeer sizer fuller & mover in window
|   fast,true     gebruik ingebouwde code voor snelle text (false: VDI)
|                     van belang voor video kaarten.
|                 Overigens bekijkt TTD zelf of het gebruik van deze code kan.
|                 Wie over snelle VDI beschikt gebruikt false; het beeld wordt
|                 aanzienlijk rustiger door intelligentere opbouw.
|   language,uk   of nl of brd
|   vis,.................................  als STD_3
|   hex,$         Favoriete teken voor hexadecimal representatie
|   m30,false     herken 68030 addressing modes en instructies
|   m81,false     herken 68881/2 instructies  (Line_F)
|   dec,false     waar van toepassing decimaal ipv hex (geen voorloopnullen!)
|   xoo,false     Zie onder MACHINES
|   width,-1      initiele breedte in ch's van s'vensters werkgebied -1 = max
|   height,-1     initiele hoogte      "            "          "        "
|   end           Alleen hierna kan commentaar meegegven worden

De file TTD_4.CFG moet in dezelfde folder staan als TTD_4.PRG. Als
de file TTD_4.CFG ontbreekt of niet kan worden gevonden, dan worden de
defaults gebruikt.

N.B. Sommige assemblers hebben geen equivalent voor de directieven
TEXT, DATA, BSS of COMM. De public domain assembler JAS.TTP
o.a. te vinden op de Sozobon diskette) kent ze wel allemaal.

Inhoud bijgeleverde config file. Toegespitst op PASM en eigen smaak.

r15,true
text,.text
data,.data
bss,.bss
mod,.module
sbranch,.b
wbranch,.w
lbranch,.l
wabs,.w
wor,0
ill,illegal
ext,.S
fast,vditext
languahe,uk
xref,
xdef,.globl
common,.comm
vslider,true
hslider,true
sizer,true
hexa,$
m30,1
m81,1
dec,1
xoo,0
end

OPTREDEN VAN FOUTEN

De meest voorkomende fouten (Out of memory, Drive full) worden 
apart afgehandeld. Bij andere fouten wordt een nummer opgegeven 
(GFA-Basic foutnummer).

In de meeste gevallen kan worden gekozen tussen hernieuwd starten 
van het programma of afbreken. Als afbreken wordt gekozen, dan 
wordt alsnog een melding van de aard van de fout gegeven.

Als er onverklaarbare fouten optreden dan wordt verzocht deze 
fouten te melden, bij voorkeur met uitgebreide rapportage over de 
omstandigheden.


WERKEN MET DE DISASSEMBLER

Algemeen

Het disassembleren gaat het beste bij programma's waarin de 
machinecode instructies en de gegevens niet door elkaar staan. 
Sprongtabellen zijn echter een bekend voorbeeld van gegevens 
tussen de instructies in. Sprongtabellen met relocateerbare 
absolute adressen worden altijd correct behandeld door ST-Digger. 
Sprongtabellen met relatieve adressen geven op twee manieren 
problemen:
- De adressen waar naartoe wordt gesprongen worden niet herkend.
- De sprongtabel kan schijnbare machinecode instructies bevatten.

Gegevens die ten onrechte worden gedisassembleerd als machinecode 
instructies moeten met de hand worden gewijzigd in "DC directives".
Dit is zeker noodzakelijk als deze machinecode instructies naar 
labels verwijzen Zie het hoofdstuk over markeren van data-gebieden).
Reeksen gegevens zijn vaak makkelijk te herkennen door 
"DC directives" en merkwaardige instructies zoals "ORI.B #$0000,D0".

Een ander probleem is de adressering van het type "$xxxx(An)", 
waarbij "An" door het programma op een vaste waarde wordt gezet. 
Dit gebeurt onder andere in gecompileerde GFA-Basic programma's. 
Ook adressering van het type xxx(PC,Dn) kan soms zorgen voor
problemen. Bij wijiging van een programma (of bij toepassing
van optimaliserende assemblers) zullen dan (met de hand) extra
labels moeten worden toegevoegd. In vele gevallen is het nodig om 
te beschikken over een goed edit-programma met uitgebreide
zoekfaciliteiten.

Opnieuw assembleren

De uitvoer van ST-Digger kan  rechtstreeks dienen als invoer voor 
een assembler, als een optie "labels" of "symbols" wordt gekozen.

Als de machinecode-instructies en gegevens door elkaar worden 
gebruikt, dan kan de disassembler dit niet altijd goed uit elkaar 
houden. Gebieden met gegevens zijn dikwijls wel te herkennen door 
het optreden van DC.W en DC.W "directives" (define constant) 
tussen (veelal vreemde) instructie-reeksen. Als deze instructie-
reeksen geen labels bevatten, dan geeft dit meestal geen 
problemen (zie echter het volgende punt). Het wordt aangeraden 
alle instructies die in feite gegevens zijn te vervangen door 
DC.W en DC.L "directives". (zie het hoofdstuk over markeren van
data-gebieden). Labels op merkwaardige plaatsen (soms 
middenin instructies, aangegeven met EQU *-xxx) kunnen 
aanwijzingen zijn voor het optreden van gegevens tussen de 
|   instructies in. Gebruik <CNTRL click> om de bron te vinden. 
Labels middenin instructies kunnen ook het gevolg zijn van 
zichzelf wijzigende programma's (een uiterst dubieuze program-
meertechniek!).

"Slimme" assemblers

De assembler-codes zoals deze door ST-Digger worden afgegeven 
zijn volledig eenduidig. In theorie zou na het assembleren weer 
precies hetzelfde programma moeten ontstaan. In de praktijk 
blijkt dat een aantal assemblers tracht de code te optimaliseren 
(absolute adressering vervangen door "program-counter"-relatieve 
adressering, MOVE.L #0,Dn vervangen door MOVEQ #0,Dn etc.). Dit 
heeft als gevolg dat niet hetzelfde programma ontstaat. Als de 
programma-sectie uitsluitend instructies bevat en geen adres-
sering via sprongtabellen o.i.d. plaatsvindt, is dit geen enkel 
probleem. Anders is een (flinke) hoeveelheid "handwerk" nodig om 
een en ander correct te laten verlopen.

"Domme" assemblers

Andere assemblers kennen soms niet alle nuances van de volledige 
instructieset van de MC68000. Een van bekendste voorbeelden is 
het niet herkennen van MOVEA. Dit vergt dus de nodige aanpas-
singen met de editor. Overigens blijkt ook een van de superslimme 
assemblers sommige instructies, zoals "BTST Dn,dd(PC)" etc., niet 
te kennen?!

Patchen

Een van de mogelijkheden voor het aanbrengen van kleine correc-
ties in een programma bestaat uit het (met een file-editor o.i.d) 
wijzigen van een aantal bytes (patchen). Door gebruik van ST-
Digger is precies bekend via welke punten een stuk programma 
wordt bereikt. Ook kan worden nagegaan waar vandaan er naartoe 
wordt gesprongen. "Patchen" is dus zeer eenvoudig en betrouwbaar 
mogelijk. Alleen als er in het te patchen gebied relocateerbare 
verwijzingen voorkomen (duidelijk zichtbaar met ST-Digger) die 
worden verschoven, want dan moet de relocatie-tabel worden 
aangepast. Dit is verre van eenvoudig, maar de resultaten kunnen 
achteraf wel simpel worden gecontroleerd. 

Vergeet niet bij programma-files (.PRG .ACC .TOS etc.) 
rekening te houden met de lengte van de program-header (28 
bytes)!

DRI-OBJECTFILES
Veel compilers en assemblers leveren een module in object-formaat af.
Deze modules moeten nog met behulp van een "linker" worden omgezet in
een werkend programma. Bij deze omzetting worden ook meestal nog
modules uit bibliotheken "meegelinkt2. Voor de structuur van de object-
files bestaan (helaas) diverse mogelijjheden (DRI, GST, TDI). Het DRI-
formaat lijkt toch de overhand te krijgen. ST Digger v3 kan het DRI-
formaat (.O) herkennen en decoderen. Files in object-formaat zijn
bijzonder interessant omdat diverse externe verwijzingen met naam en al
worden getoond (Optie Symbols).

|   TTD_4 kan ook Pure_C object files verwerken.

Modules uit de bibliotheken van de diverse compilers kunnen op
eenvoudige wijze worden onderzocht. De modules moeten dan wel 
afzonderlijk uit bibliotheken worden gehaald. Bij de meeste compilers
wordt een programma geleverd waarmee dit mogelijk is. Een dergelijk
programma (AR.TTP) is ook op de Sozobon-diskette (PD B 63) te vinden.

|   Er is geen verschil tussen Pure_C objectfiles en Pure_C libraries.
|   Wie heeft ooit niet eens een belangrijke functienaam verkeerd gespeld,
|   verbazingwekkend klein werd het programma plotseling.

Ook de GfA-Basic-compiler levert modules  in eensoort DRI-object-
formaat af. Deze (gecomprimeerde) files moeten echter eerst met behulp
van  het programma UNPACK.GA worden omgezet in het standaardformaat.
De versies tot en met 3.50 van de GfA-Basic-compiler vertonen een
klein foutje waardoor een ongecomprimeerde file een overschot
van nul-bytes aan het eind vertoont. Hopelijk wordt dit in latere
versies gecorrigeerd.

De DRI-objectfiles bevatten gewoonlijk een symbooltabel. Programma's
kunnen soms ook een symbooltabel bevatten. In dat geval kan de optie
"Symbls" worden gekozen. Labels waarvan de naam bekend is worden dan 
weergegeven met deze naam. Het kan zelfs voorkomen dat diverse
namen naar een zelfde label verwijzen. Deze namen worden zoveel
mogelijk op het scherm getoond. Onder aan het scherm kunnen soms
namen wegvallen. Bij het schrijven naar een file worden altijd alle
namen opgenomen.

N.B.: De extensie .O is geen absolute garantie dat het om een DRI-
objectfile gaat.
|   Bijvoorbeeld Turbo C (versie 2) & Pure C genereren normaal
|   objectfiles met de extensie .O met een afwijkend formaat. Turbo C & Pure C
|   kunnen echterwel DRI-objectmodules afleveren.
|   TT-Digger kan nu ook het Pure_C formaat verwerken.

ACHTERGRONDEN

Adresseringsmogelijkheden en variabele lengte van instructies

|   De MC68000 family microprocessors heeft een gigantische set
|   basisinstructies en veel van deze instructies hebben een

De MC68000 microprocessor heeft een betrekkelijk kleine set 
basisinstructies, maar veel van deze basisinstructies hebben een 
uitgebreid scala aan variaties van adresseringsmogelijkheden. Bij 
deze adresseringsmogelijheden geldt een aantal beperkingen, 
waarvan de meeste gebaseerd zijn het principe van scheiding van 
programma en gegevens. Zo is het nooit toegestaan rechtstreeks 
via "program-counter" relatieve adressering (dd(PC), d(PC,Rn) en 
"immediate") gegevens in het geheugen te wijzigen. Verder mag in 
een aantal gevallen alleen naar even adressen worden verwezen 
(sprongen, woord (.W) en langwoord (.L) instructies. ST-Digger 
voert een rigoreuze controle uit van al deze beperkingen, zodat 
uitsluitend geldige instructies worden gegenereerd.

De diverse adresseringsmogelijheden hebben ook tot gevolg dat 
|   niet alle instructies evenlang zijn (2 tot 22 bytes per 
instructie). Als het disassembleren op een willekeurig adres 
begint, dan is er een grote kans dat midden in een instructie 
wordt gestart. Door de rigoreuze controles door ST-Digger zal dit 
effect meestal niet doorwerken in volgende instructies. Ook wordt 
door deze controles de kans verminderd dat gegevens ten onrechte 
voor instructies worden aangezien.

Methodes voor Label-herkenning

Een van de methodes voor het genereren van labels bestaat uit het 
volledig disassembleren van een programma en het bijhouden van 
adressen waar naar wordt verwezen. Dit is een trage methode met 
het risico dat labels worden gemist als sommige instructies 
worden gemaskeerd doordat instructies en gegevens door elkaar 
heen staan.

Een andere methode bestaat uit het woord voor woord (16 bit) 
nagaan of dit een mogelijk begin is van een instructie met 
"program-counter" relatieve verwijzing. Als dit het geval is dan 
wordt verder gecontroleerd of het een geldige verwijzing is 
(toelaatbare adres-mode voor de instructie, even adres bij 
programmasprong of bij woord (.W) en langwoord (.L) instructies). 
Deze methode kan zeer snel werken. Soms worden valse labels 
gevonden, maar dat is ook met de eerste methode niet te 
vermijden. ST-Digger past de tweede methode toe.

Bij relocateerbare programma's geven ook de veranderbare absolute 
verwijzingen aanleiding tot labels. In de andere gevallen 
(bijv. ROM of RAM) leveren absolute verwijzingen die in de 
opgegeven programma-range vallen, labels op. Dit laatste 
geeft wel kans op het ten onrechte gebruiken van een label.


SLOTWOORD

Dit programma is uit de praktijk geboren. De oervorm (op een 
Sinclair QL) is ontstaan in een tijd dat disassemblers voor de 
MC68000 microprocessor nog niet (of nauwelijks) verkrijgbaar 
waren. Tijdens de ontwikkeling zijn diverse keuzes gemaakt ten 
aanzien van faciliteiten, layout en dergelijke. Uiteraard zijn 
deze keuzes tot nu toe in hoofdzaak gedaan aan de hand van de 
persoonlijke inzichten van de auteur (dit geeft in elk geval 
tenminste 1 tevreden gebruiker). In versie 3 is dankbaar gebruik
gemaakt van de op- en aanmerkingen van diverse gebruikers.

Opmerkingen en suggesties voor verbeteringen of aanvullingen 
worden gaarne tegemoetgezien door de auteur. Ervaringen bij het 
gebruik kunnen eventueel een basis vormen voor bijdragen in het 
ST-blad.

De auteur van ST-Digger is er van overtuigd dat dit programma aan 
hoge eisen voldoet. Toepassing van dit programma blijft echter 
geheel voor eigen risico van de gebruiker. Gewaarschuwd wordt dat 
het soms niet is toegestaan software te disassembleren en/of te 
modificeren.

Het feit dat dit programma voor een lage prijs wordt verkocht 
betekent niet dat het tot het "Public-Domain" behoort. 
Ondersteuning zal uitsluitend plaatsvinden voor geregistreerde 
legale gebruikers.

september 1996 :
|   Inmiddels is het programma WEL PD geworden.
|   Dit betekent dat de auteurs overtuigd blijven van de goede werking
|   van het programma, doch geen enkele verantwoordelijkheid kunnen nemen
|   voor fouten die zich wellicht nog kunnen voordoen.
|   Vooral niet waar het betreft het publiceren van illegaal verkregen
|   'reversed engineered' producten van derden.
|   TT-Digger is voor leergierigen en nieuwsgierigen en voor diegenen die
|   denken fouten te kunnen verbeteren in software van derden van het
|   gebruiken waarvan men gerechtigd is.

|   Wie een fout vindt in TT-Digger kan zich schriftelijk wenden tot

                                                               Henk Robbers.
                                                               Borneolaan 448
                                                               1019 KN  A'dam

|     Stuur de objectfile die men dacht te kunnen disassembleren mee!!


P.S.  Het ligt in het verschiet om het hele programma te ver-C'en.
      Hoe lang dit duurt, en of het ooit gereed komt, kan ik niet zeggen.
      Ik wil allen maar zeggen dat ik werkelijk geinteresseerd ben in voor-
      komende fouten.
