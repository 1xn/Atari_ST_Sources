
                 DOCUMENTATION, CONCEPT ET UTILISATION
                   DE LA LIBRAIRIE DE FONCTIONS BIG.
                 "BIG IS GEM" version 1.05 du 16/06/93

  (Pour respecter la num‚rotation, imprimez avec 63 lignes par page)

       1. Pr‚sentation                                           3
         1.a Pourquoi BIG ?                                      3
         1.b Que font ces routines ?                             3
           1.b.1 Le travail sur les formulaires et les menus     3
           1.b.2 Le travail sur les fenˆtres                     4
         1.c Les outils n‚cessaires                              4
         1.d Les explications                                    4
       2. Visite guid‚e : BIGdemo                                5
         2.a Le premier formulaire                               5
         2.b Un formulaire plus complet                          5
         2.c Une boŒte d'alerte                                  7
         2.d Un premier formulaire en fenˆtre                    7
         2.e Un autre formulaire en fenˆtre                      8
         2.f Un menu hi‚rarchique                                8
         2.g La fenˆtre de texte                                 9
         2.h La fenˆtre d'image                                  9
         2.i Une fenˆtre graphique                              10
         2.j Une fenˆtre avec un menu d‚roulant                 10
         2.k Un pop-up libre                                    11
         2.l Gestion du timer                                   11
         2.m Fin de la visite                                   11
       3. Les nouveaux types d'objets                           13
         3.a Les attributs                                      14
         3.b Dessine-moi un bouton                              15
         3.c Les menus pop-up                                   16
         3.d Les boutons s‚lectables                            17
         3.e Les ‚ditables ‚tendus                              18
         3.f D‚placer le formulaire                             18
         3.g Du texte graphique                                 18
         3.h Les menus hi‚rarchiques                            19
         3.i Les raccourcis clavier                             20
       4. Le travail avec les fenˆtres                          21
         4.a Concept des fenˆtres BIG                           21
         4.b La structure Window                                22
       5. Les fonctions de BIG                                  26
         5.a G‚n‚ralit‚s                                        26
           5.a.1 Les ‚v‚nements                                 26
           5.a.2 Le ressource int‚gr‚                           27
           5.a.3 Les variables globales                         27
           5.a.4 Les d‚finitions                                28
         5.b Les fonctions programmeur                          29
           5.b.1 Les fonctions d'initialisation                 29
             initial()                                          29
             end()                                              30
           5.b.2 Les fonctions de gestion des formulaires       31
             formm_draw()                                       31
             formm_undraw()                                     31
             formf_draw()                                       31
             formf_undraw()                                     31
             create_hierm()                                     31
             dialog()                                           32
             free_popup()                                       33
             get_bkgr()                                         33
             put_bkgr()                                         33
             big_alert()                                        33
             get_string()                                       34
             parent()                                           34
             bak_rsc()                                          34
             res_rsc()                                          35
           5.b.3 Les fonctions de champs ‚ditables              35
             set_text()                                         35
             get_text()                                         35
           5.b.4 Les fonctions diverses                         35
             path()                                             35
             exist()                                            35
             set_palette()                                      36
             timer()                                            36
             trim()                                             36
             send_mesag()                                       36
             selector()                                         36
             extension()                                        37
           5.b.5 Les fonctions de fenˆtres                      37
             formw_draw()                                       37
             open_window()                                      38
             find_index()                                       40
             find_window()                                      40
             zone_work()                                        40
             height_sliders()                                   40
             draw_object()                                      40
             print_page()                                       40
             closed()                                           41
             fulled()                                           41
             sized()                                            41
             moved()                                            42
       6. Le source de BIGdemo                                  43
         6.a Le ressource                                       43
         6.b Le source                                          45
           6.b.1 La fonction main()                             45
           6.b.2 La gestion des formulaires                     48
           6.b.3 Les formulaires en fenˆtre                     48
           6.b.4 La fenˆtre texte                               49
           6.b.5 La fenˆtre image                               50
           6.b.6 La fenˆtre graphique                           50
       7. ParamŠtres et pointeurs sur fonctions                 52
       8. Travail avec un ressource int‚gr‚                     53
       9. Epilogue                                              54
         9.a Historique                                         54
         9.b Pour me contacter                                  54





















1. Pr‚sentation
  1.a Pourquoi BIG ?
  Vous connaissez les programmes GNU ? GNU signifie "Gnu is Not Unix", 
avec  r‚f‚rence r‚cursive.  De mˆme,  MINT,  le systŠme  multitƒche  … 
l'origine du multiTOS du Falcon signifie "Mint Is Not Tos".
  Et  bien,  BIG signifie "Big Is Gem" !  Ces routines sont  garanties 
100 %  pur  GEM,  ce  qui assure une  compatibilit‚  avec  toutes  les 
machines de la gamme et toutes les r‚solutions (y compris le TT et  le 
Falcon,  leurs  r‚solutions et le MultiTOS).  Elles sont le  fruit  de 
plusieurs  ann‚es de programmation sous GEM,  et grƒce …  l'exp‚rience 
accumul‚e,  je pense qu'elles r‚pondent parfaitement aux besoins  d'un 
d‚veloppeur d‚sireux de cr‚er des logiciels esth‚tiques (‡a compte) et 
d'utilisation simple.
  La  librairie est plac‚e dans le Domaine Public.  Vous  pouvez  donc 
(c'est  mˆme  conseill‚) la distribuer librement autour  de  vous,  la 
placer en t‚l‚chargement sur un serveur ou une BBS, la faire connaŒtre 
par  catalogue,  etc,  … condition que le pack complet  soit  propos‚, 
c'est-…-dire les fichiers suivants :
  BIG.H        Le fichier header … inclure aux d‚veloppements
  BIG.LIB      La librairie … linker avec le programme
  BIG.TXT      La pr‚sente documentation
  BIGDEMO.PRG  Le programme de d‚mo et d'exemple
  BIGDEMO.RSC  Le fichier ressource de la d‚mo
  BIGDEMO.H    Le fichier des d‚finitions du ressource
  BIGDEMO.HRD  Le fichier contenant les noms d'objets du ressource
  BIGDEMO.RSH  Le  fichier d‚crivant le ressource de la d‚mo  si  l'on 
               d‚sire l'int‚grer
  BIGDEMO.C    Le source de la d‚mo
  BIGDEMO.PRJ  Le fichier projet pour Pure C
  Vous  pouvez  obtenir  le  source complet des  routines  BIG  en  me 
contactant … l'adresse indiqu‚e … la fin de ce manuel. Je vous demande 
la somme de 100 F ($ 17) pour les frais de disquette,  d'exp‚dition... 
et pour faire si possible un petit b‚n‚fice.
  L'utilisation  de  BIG dans des logiciels destin‚s au  commerce  est 
libre.  Toutefois,  les dons sont accept‚s.  Reportez-vous au chapitre 
9.b pour me contacter.

  1.b Que font ces routines ?
  Elles  permettent de g‚rer les appels les plus courants …  l'AES  en 
quelques  appels  de fonctions,  que l'application travaille  avec  un 
ressource externe ou int‚gr‚.  On peut r‚partir ces fonctions en  deux 
groupes :  celles qui travaillent sur les formulaires et les menus, et 
celles qui travaillent sur les fenˆtres.  Mais la frontiŠre entre  ces 
deux   groupes  est  floue  puisqu'il  est  possible  de  placer   des 
formulaires ou des menus dans des fenˆtres !

  1.b.1 Le travail sur les formulaires et les menus
  BIG  offrent la possibilit‚ de d‚finir des objets d'un look  nouveau 
(mais qui tend … se r‚pandre), des formulaires d‚pla‡ables sur l'‚cran 
ou  plac‚s  dans des fenˆtres,  une gestion de boutons  pop-up  et  de 
boutons  d'aide en ligne,  des menus hi‚rarchiques,  des menus  pop-up 
librement  plac‚s sur l'‚cran,  etc.  Les raccourcis clavier dans  les 
menus  et  les  formulaires sont g‚r‚s  automatiquement  par  BIG.  La 
gestion   du  curseur  dans  les  champs  ‚ditables   est   agr‚ment‚e 
d'‚quivalents clavier et il est possible de cr‚er des champs  capables 
de contenir plus de texte que la largeur du champ le permet (le  texte 
d‚file).   Les  boŒtes  d'alerte  peuvent  ˆtre  d‚plac‚es  comme   un 
formulaire. De plus, il est possible de lier des objets ou des options 
de menus … des fonctions,  de telle sorte qu'il suffit des les cliquer 
pour appeler la fonction correspondante.  Nous entrons presque dans le 
domaine  de la programmation objet !  BIG peut travailler  aussi  bien 
avec  un  fichier RSC classique qu'avec  un  ressource  int‚gr‚.  Nous 
verrons comment lorsque nous traiterons des appels des fonctions.

  1.b.2 Le travail sur les fenˆtres
  Un  jeu  de fonctions est consacr‚ aux fenˆtres afin  de  simplifier 
leur programmation.  La possibilit‚ de placer des formulaires dans des 
fenˆtres est entiŠrement prise en charge. Il est ‚galement possible de 
placer  des  menus d‚roulants dans les fenˆtres (avec  ou  sans  menus 
hi‚rarchiques). Les fenˆtres contenant des images sont g‚r‚es par BIG. 
En ce qui concerne les fenˆtres de texte (ou d'autre type de donn‚es), 
le  programmeur  aura seulement … ‚crire la routine  d'affichage  (qui 
d‚pend  fortement  de  la maniŠre dont les donn‚es  sont  charg‚es  en 
m‚moire).  BIG se charge du reste.  Enfin,  il est possible de d‚finir 
pour chaque fenˆtre la forme que prendra le curseur de la souris quand 
il entrera dans la zone de travail,  et d'indiquer si la fenˆtre  peut 
ˆtre   manipul‚e  …  partir  d'‚quivalents   clavier.   Cette   quasi-
automatisation  du  travail  sur les fenˆtres est sans  doute  un  des 
points  les  plus  attrayant  de BIG,  cette  partie  de  l'AES  ‚tant 
probablement la plus ennuyeuse … programmer.

  1.c Les outils n‚cessaires
  BIG  a  ‚t‚ cr‚‚ avec PURE C version 1.1.  Si vous  me  demandez  le 
source, ils sera facilement adapt‚ … des versions plus anciennes ou au 
TURBO  C,  mais n‚cessiteront sans doute une adaptation plus  ample  … 
d'autres compilateurs C.
  En ce qui concerne les ‚diteurs de ressources,  il est indispensable 
d'en  utiliser  un qui permette d'‚diter  les  ob_types,  ob_flags  et 
ob_state ‚tendus des objets.  Dans ce domaine, il y a K-Ressource (qui 
commence  … se faire vieux),  et INTERFACE (ou INTERFACE 2),  qui  est 
sans aucun doute le meilleur.  Mais n'oublions pas ORCS, presque aussi 
puissant qu'INTERFACE, qui est distribu‚ en ShareWare.

  1.d Les explications
  Pour  pr‚senter les possibilit‚s de BIG,  nous allons commencer  par 
faire  un tour du propri‚taire grƒce au programme  d'exemple  BIGdemo, 
puis  nous  entrerons  dans les d‚tails dans  l'ordre  suivant  :  les 
nouveaux types d'objets,  le concept de gestion des fenˆtres et  enfin 
les  fonctions  de  BIG avec leur syntaxe,  leurs  paramŠtres  et  des 
recommandations  pour leur programmation.  Dans  cette  documentation, 
nous  ne pr‚senterons que les  "fonctions  programmeur",  c'est-…-dire 
celles  que le d‚veloppeur doit appeler.  Les autres,  les  "fonctions 
internes" … BIG, ne seront pas mentionn‚es ici.
  Dans  toutes  ces  explications,  je m'efforcerais  d'ˆtre  le  plus 
explicatif possible. Toutefois, je supposerai que vous avez un minimum 
de connaissance en matiŠre de programmation en langage C et en ce  qui 
concerne le GEM.  Mon but n'est pas de remplacer les ouvrages relatifs 
… ces questions.  Si des points restent obscurs,  je vous conseille de 
consulter  une  documentation  correspondant au  problŠme,  ou  de  me 
contacter personnellement.
















2. Visite guid‚e : BIGdemo
  Je  vous  recommande  d'imprimer  (au  moins)  cette  partie  de  la 
documentation  afin de pouvoir lire la pr‚sentation en la suivant  sur 
l'‚cran.
  Lancez BIGdemo.  Ce programme ne r‚alise rien de particulier. Il est 
juste l… pour montrer les possibilit‚s des fonctions de BIG et comment 
elles   sont   utilis‚es.   N'h‚sitez  pas  …   ‚tudier   son   source 
attentivement, toutes les fonctions majeures y sont pr‚sentes. La d‚mo 
tourne  dans toutes les r‚solutions,  mais elle n'est pas adapt‚e  aux 
basses r‚solutions.  Les ic“nes seront d‚form‚es,  et certaines choses 
seront ‚tranges,  comme par exemple le menu qui est trop  large.  J'ai 
simplement voulu montrer que BIG permet de d‚velopper dans toutes  les 
r‚solutions, sans compliquer la d‚mo.
  Un bureau s'affiche, avec deux textes, une ic“ne et un menu de trois 
options.  L'ic“ne  et  la  boŒte des textes  peuvent  ˆtre  d‚plac‚es. 
L'ic“ne est s‚lectionnable par un clic simple,  et d‚s‚lectionnable en 
cliquant "dans le vide".
  Dans cette visite guid‚e,  les touches du clavier seront  pr‚sent‚es 
entre signes "inf‚rieur" et "sup‚rieur",  comme <ceci>. Les textes des 
boutons,   options,   formulaires,   etc,   seront   pr‚sent‚s   entre 
apostrophes, comme 'ceci'.

  2.a Le premier formulaire
  Cliquez  l'option  'Infos'  du  menu  'BIGdemo'.  Un  formulaire  se 
pr‚sente,  affichant  le  num‚ro  de  version de  BIG  et  un  mot  de 
remerciement  aux copains qui m'ont aid‚ … r‚aliser ces  routines  par 
leurs  conseils  et  leurs encouragements.  Vous  pouvez  d‚placer  ce 
formulaire  sur l'‚cran en cliquant le bouton du coin sup‚rieur  droit 
et en gardant le bouton de la souris enfonc‚.  Le mode de  d‚placement 
de  ce  formulaire  est  la  "boŒte  fant“me",   c'est-…-dire  que  le 
formulaire  disparaŒt le temps du d‚placement pour laisser la place  … 
un rectangle … ses dimensions.
  Cliquez  le  bouton 'INFOS' ou pressez la touche  <Help>.  Un  autre 
formulaire se superpose au premier. Il indique mes coordonn‚es si vous 
d‚sirez me contacter ou recevoir les sources complets de BIG.
  Quittez ce second formulaire en cliquant n'importe o— …  l'int‚rieur 
ou en pressant <Return>.  Fermez ‚galement le premier formulaire de la 
mˆme  fa‡on.  Pour  appeler cette option,  vous  auriez  ‚galement  pu 
presser la touche <I>, pour l'appeler par son raccourci clavier. Si, … 
l'aide d'un ‚diteur de ressource, vous remplacez le 'I' de l'option de 
menu  par  (par  exemple) '^F',  vous devrez  maintenant  pressez  les 
touches <Control + F> pour appeler cette option. Grƒce … BIG, il n'est 
pas  n‚cessaire  de  recompiler  le  programme  pour  que  le   nouvel 
‚quivalent clavier prenne effet !

  2.b Un formulaire plus complet
  Passons  au  second  menu,   not‚  'Formulaires'.  Cliquez  l'option 
'Formulaire  libre' (ou pressez <Control + L>).  Le formulaire qui  se 
pr‚sente  est nettement plus fourni que le  premier.  D‚placez-le  sur 
l'‚cran.  Il  se d‚place "en temps r‚el",  c'est-…-dire que  c'est  le 
formulaire  complet est plus seulement une boŒte fant“me qui suit  les 
mouvements  de  la souris.  Le titre de ce formulaire est  une  chaŒne 
graphique avec les attributs Gras, Italique et Soulign‚.
  Sous ce titre figurent deux groupes de radio boutons not‚s 'Cadre 1' 
et 'Cadre 2'.  Il se pr‚sentent sous la forme de petits boutons  ronds 
avec  le texte … leur droite.  Un des caractŠres de chaque  texte  est 
soulign‚.  Pressez  la touche <Alternate> et ce caractŠre.  Le  bouton 
r‚agit comme si vous l'aviez cliqu‚.
  Passons  au bouton ombr‚ not‚ 'Pop-Up'.  Quand vous le  cliquez,  un 
menu  pop-up s'ouvre,  plac‚ sous le bouton (… moins que  vous  n'ayez 
d‚plac‚ le formulaire de telle sorte qu'il n'y ait pas assez de  place 
…  l'‚cran  ;  dans ce cas,  le pop-up est  d‚cal‚).  Le  menu  pop-up 
s'utilise  exactement  comme  un  menu  d‚roulant.  Il  peut  contenir 
plusieurs colonnes d'options.  Choisissez-en une.  Son texte est copi‚ 
dans le bouton d'appel.  Re-cliquez ce bouton :  cette fois, le pop-up 
est positionn‚ de maniŠre … ce que la position de l'option choisie  et 
celle du bouton correspondent (mˆme remarque : s'il n'y a pas assez de 
place,  le pop-up est d‚cal‚). Passons … l'ic“ne. Un nouveau menu pop-
up  s'affiche,  mais  celui-ci  est constitu‚  d'ic“nes.  Si  vous  en 
choisissez une, son dessin est report‚ dans le bouton.
  Il  existe une autre fa‡on de changer la s‚lection d'un bouton  pop-
up.  FaŒtes  un  <Shift  +  clic>  sur  le  bouton.  L'option  suivant 
l'actuelle  est activ‚e (du moins,  la premiŠre  active).  Arriv‚  "au 
bout",  ‡a  recommence  depuis  le d‚but.  Si le texte  du  bouton  ne 
correspond … aucune des options du pop-up,  c'est la premiŠre qui  est 
choisie de cette fa‡on.
  Les deux boutons s‚lectables se pr‚sentent sous la forme d'un  petit 
carr‚ avec le texte du bouton … droite.  Si le bouton est s‚lectionn‚, 
une  croix  est  trac‚e dans le carr‚.  L…  aussi,  un  caractŠre  est 
soulign‚, pour signaler la pr‚sence d'un raccourci clavier.
  Le  bouton 'Alerte' fait afficher une alerte de type  BIG,  c'est-…-
dire qu'elle peut ‚galement ˆtre d‚plac‚e … l'‚cran.  Toutefois,  dans 
ce  cas,  elle se d‚place sous forme de boŒte fant“me.  En  effet,  le 
d‚placement  en  temps r‚el n‚cessite de sauver tout l'‚cran  dans  un 
buffer.  Or, BIG ne comporte (pour limiter l'occupation m‚moire) qu'un 
seul  buffer  de  ce  type et il est d‚j…  occup‚  par  le  formulaire 
principal.   Donc,  l'alerte  est  d‚plac‚e  en  boŒte  fant“me.  Nous 
reviendrons  en d‚tail sur cela.  L'interˆt de ce bouton 'Alerte'  est 
qu'il est li‚ … la fonction qui affiche l'alerte par un "pointeur  sur 
fonction".  Il  suffit  de  le cliquer pour que  cette  fonction  soit 
ex‚cut‚e,  sans  qu'il soit n‚cessaire d'effectuer toute une s‚rie  de 
tests ! Il s'agit l… d'un concept proche de la programmation objet qui 
est un des principaux atouts de BIG. Nous en reparlerons...
  Le  premier des deux champs ‚ditables comporte une petite flŠche  de 
chaque  cot‚.  Tapez du texte dans ce champ,  et continuez … taper  en 
arrivant  au  bout  du champ.  Le texte  d‚file,  vous  permettant  de 
poursuivre la saisie ! Vous pouvez entrer 50 caractŠres dans ce champ. 
En  fait,  BIG autorise la cr‚ation d'‚ditables ‚tendus ayant  jusqu'… 
255  caractŠres.  Si vous continuez … taper en arrivant … la  fin,  le 
dernier  caractŠre  est  remplac‚ par celui  qui  est  tap‚.  Si  vous 
saisissez du texte au milieu du champ, il est saisi en mode insertion, 
… moins que la taille maximum du texte soit atteinte.  Dans ce cas, la 
saisie se fait en mode remplacement.
  En cliquant n'importe o— dans le champ,  le curseur est positionn‚ … 
cet endroit-l….  Si on clique trop loin … droite (aprŠs le texte  d‚j… 
saisi),  il est positionn‚ … la fin, et si on clique trop … gauche, au 
d‚but.   Les  touches  fl‚ch‚es  gauche  et  droite  utilis‚es  seules 
d‚placent  le  curseur.   Arriv‚  au  bout,   le  texte   d‚file.   En 
collaboration avec la touche <Control>, les flŠches amŠnent le curseur 
au d‚but du mot pr‚c‚dent ou suivant (pas de d‚filement dans ce  cas). 
Avec la touche <Shift>,  le curseur est amen‚ tout … gauche ou tout  … 
droite  du champ ‚ditable.  Si le curseur est d‚j… sur la premiŠre  ou 
derniŠre position du champ, le texte est d‚cal‚ jusqu'… son premier ou 
son dernier caractŠre.  Enfin, en cliquant sur les petites flŠches, et 
en maintenant le bouton enfonc‚,  le texte d‚file,  mˆme si le curseur 
‚tait sur un autre champ ‚ditable.
  Le  second  champ ‚ditable est plus classique.  Il offre  les  mˆmes 
enrichissements  en ce qui concerne le d‚placement  du  curseur,  sauf 
bien  s–r  le  d‚filement du texte,  puisque ce  n'est  pas  un  champ 
"‚tendu".
  Les combinaisons <Shift + FlŠche haute> et <Clr> amŠnent le  curseur 
sur le premier champ du formulaire.  Les combinaisons <Shift +  FlŠche 
basse> et <Shift + Clr> l'amŠne sur le dernier champ (dans l'ordre  de 
num‚rotation des objets dans le ressource).
  Les touches <FlŠche basse> et <Tab> amŠnent le curseur sur le  champ 
suivant  du formulaire.  Les touches <FlŠche haute> et <Shift  +  Tab> 
l'amŠne  sur  le  champ pr‚c‚dent (dans l'ordre  de  num‚rotation  des 
objets dans le ressource).
  Le  bouton  'Confirme' est comme d'habitude activ‚ par  les  touches 
<Return>  ou  <Enter>.  Le bouton 'Annule' est activ‚  par  la  touche 
<Undo>,  et  le bouton 'Aide' par la touche  <Help>.  Les  ‚quivalents 
clavier de ces trois boutons font partie des routines BIG.  Il  suffit 
de  changer  les  attributs  de ces boutons  dans  le  ressource  pour 
modifier ces ‚quivalences.
  Le  bouton 'Aide' appelle une autre boŒte qui vient se superposer  … 
la  premiŠre  de  maniŠre … ˆtre centr‚e.  Comme  dans  le  formulaire 
d'information,  cet  appel fait partie de la gestion de  BIG,  il  est 
"automatis‚".
  Changez quelques paramŠtres du formulaire,  puis confirmez. Rappelez 
le  formulaire.  Vos modifications ont ‚t‚  enregistr‚es.  Changez-les 
encore,  mais cette fois,  annulez puis rappelez encore le formulaire. 
BIG a restaur‚ les r‚glages pr‚c‚dents.  Automatiquement (ou presque), 
BIG se charge de la sauvegarde et de la restauration de "l'‚tat"  d'un 
formulaire.

  2.c Une boŒte d'alerte
  Cliquez l'option 'BIG Alerte'.  La boŒte d'alerte qui s'affiche  est 
d‚pla‡able  en temps r‚el (puisque cette fois le buffer de  sauvegarde 
de l'‚cran est inoccup‚), comme le formulaire de tout … l'heure. Mis … 
part  ce d‚tail et des ic“nes diff‚rentes et plus nombreuses  que  les 
habituelles, elle fonctionne comme une alerte GEM.

  2.d Un premier formulaire en fenˆtre
  Laissons  de  cot‚  l'option  'Quitter'  (la  visite  ne  fait   que 
commencer !) et passons au menu 'Fenˆtres'. La premiŠre option, 'Petit 
formulaire' affiche un formulaire dans une fenˆtre.  Ceci pr‚sente  un 
immense  avantage :  la gestion du programme n'est  pas  bloqu‚e.  Les 
menus  fonctionnent  toujours,  par exemple.  Faites  l'exp‚rience  de 
rappeler le formulaire d'information. Tout fonctionne normalement... … 
un d‚tail prŠs : pour appeler ce formulaire, vous avez d– le faire par 
l'option  de menu,  car le raccourci clavier ne  fonctionne  plus.  En 
effet,  ce petit formulaire en fenˆtre comporte des champs  ‚ditables. 
Dans ce cas,  ce qui se passe sur le clavier leur est adress‚.  Il y a 
une  exception,  comme  dans  toutes les rŠgles  :  les  deux  boutons 
s‚lectables avec un caractŠre soulign‚ fonctionnent normalement. Si ce 
formulaire comportait des radios-boutons avec raccourci  clavier,  ils 
fonctionneraient ‚galement.  Simplement,  la recherche de l'‚quivalent 
clavier  ne se fait pas dans le menu lorsque nous sommes  en  pr‚sence 
d'un  formulaire  en  fenˆtre comportant un  (ou  plusieurs)  champ(s) 
‚ditable(s).
  Deux  des quatre champs ‚ditables de ce formulaire sont  des  champs 
‚tendus qui autorisent la saisie de 30 caractŠres,  pas seulement  des 
10 qui sont apparents.
  Ce  formulaire permet de changer la trame du  bureau.  Choisissez-en 
une  dans  les  trames pr‚sent‚es (qui  sont  des  radios-boutons)  et 
pressez la touche <Return> ou cliquez le bouton 'Applique'.  Le bureau 
est modifi‚ et la fenˆtre reste ouverte. Choisissez une autre trame et 
cliquez cette fois le bouton 'Confirme'. Le bureau est encore modifi‚, 
mais cette fois la fenˆtre est ferm‚e.
  L'existence des formulaires en fenˆtre implique l'apparition de deux 
nouveaux  boutons  :  'Applique' et 'R.A.Z.'.  Ils  correspondent  aux 
habituels 'Confirme' et 'Annule',  mais ne ferment pas la fenˆtre.  Le 
formulaire reste pr‚sent.  Cela est extrˆmement pratique pour modifier 
des paramŠtres sans devoir rappeler … chaque fois le formulaire si  on 
ne  trouve  pas  tout de suite le bon  r‚glage.  La  visualisation  de 
l'effet  est  imm‚diat,   mais  le  formulaire  de  param‚trage  reste 
disponible pour une autre modification.  Si la fenˆtre est ferm‚e  par 
un  clic  dans le bouton de fermeture (coin  sup‚rieur  gauche),  cela 
correspond au bouton 'Annule'.
  Comme pr‚c‚demment,  BIG se charge automatiquement de la gestion  de 
ces boutons,  en enregistrant et en restaurant si n‚cessaire  "l'‚tat" 
du formulaire.
  Le  bouton  'INFOS',  qui  appelle un formulaire  d'aide  en  ligne, 
fonctionne  de la mˆme maniŠre que ses semblables que nous avons  d‚j… 
rencontr‚.

  2.e Un autre formulaire en fenˆtre
  Passons  …  l'option  suivante,   'Grand  formulaire'.   Un  nouveau 
formulaire en fenˆtre est pr‚sent‚,  mais il est trop grand pour tenir 
sur l'‚cran (Nous supposons que vous n'utilisez pas de grand ‚cran, ni 
de  grand ‚cran virtuel,  comme BIGSCRN par exemple).  La fenˆtre  est 
donc  pourvue  d'ascenseurs pour pouvoir  d‚placer  le  contenu.  Vous 
pouvez ‚galement le faire d‚filer en utilisant le clavier : les quatre 
touches   fl‚ch‚es  sont  ‚quivalentes  …  un  clic  dans  la   flŠche 
correspondante   de  la  fenˆtre,   et  les  <Shift  +  flŠche>   sont 
‚quivalentes  …  un  clic dans la  partie  gris‚e  correspondante  des 
ascenseurs.  La touche <Esc> correspond au bouton de pleine ouverture, 
et la combinaison <Shift + Esc> au bouton de fermeture de la  fenˆtre. 
Cette possibilit‚ de manipuler les fenˆtres au clavier fait partie des 
routines BIG,  mais n'est pas obligatoirement affect‚e … une  fenˆtre. 
Il  faut  le  pr‚ciser … la cr‚ation de la  fenˆtre,  afin  que  cette 
gestion  se  fasse.  Il  y a un dernier ‚quivalent  clavier  pour  les 
fenˆtres  :  la combinaison <Control + Tab> amŠne au premier  plan  la 
fenˆtre suivante (s'il y en a une),  qui ‚tait jusqu'alors en arriŠre-
plan  (essayez,  si  vous  n'avez  pas referm‚  la  fenˆtre  du  petit 
formulaire).  Cette  possibilit‚ est active mˆme si la gestion  de  la 
fenˆtre par le clavier n'a pas ‚t‚ demand‚e,  et mˆme si le formulaire 
en fenˆtre comporte des champs ‚ditables.
  La    gestion   de   la    fenˆtre    (d‚placements,    d‚filements, 
redimensionnement, etc) est automatiquement g‚r‚e par BIG.
  Ce formulaire ne comporte pas de champs ‚ditables. En effet, puisque 
cette    fenˆtre   possŠde   des   ascenseurs   et   un   bouton    de 
redimensionnement,  le champ ‚ditable pourrait se trouver "en  dehors" 
de la fenˆtre. Dans ce cas, le curseur ne devrait pas ˆtre dessin‚, la 
saisie  du  texte  temporairement  impossible,   etc.  La  gestion  du 
formulaire  en  serait consid‚rablement compliqu‚e,  et la  taille  du 
programme   grossirait  en  cons‚quence.   J'ai  donc  opt‚  pour   un 
compromis :  Il  est possible de placer des champs ‚ditables  dans  un 
formulaire en fenˆtre,  mais BIG considŠre qu'il est TOUJOURS dans  la 
partie visible. En d'autres termes : Si vous placez des ‚ditables dans 
un  formulaire  de  fenˆtre,  cette  fenˆtre  ne  doit  pas  comporter 
d'ascenseurs et ne doit pas ˆtre redimensionnable. C'est interdit ! En 
contre-partie,  la recherche des ‚quivalents clavier s'effectue  aussi 
dans le menu.  Pressez la touche <I>,  le formulaire d'information  se 
pr‚sente.
  Le  formulaire  d'exemple comporte trois groupes  de  radios-boutons 
avec  leurs raccourcis clavier,  ainsi que deux  boutons  s‚lectables, 
‚galement avec raccourcis clavier. Il comprend ‚galement trois boutons 
pop-up,  deux  sous  forme de texte et un  sous  forme  d'ic“nes.  Ils 
permettent  de  changer les textes et l'ic“ne  du  bureau.  Le  bouton 
'INFOS' appelle un formulaire d'aide en ligne.  Nous retrouvons encore 
nos quatre boutons 'Applique', 'Confirme', 'R.A.Z.' et 'Annule'.

  2.f Un menu hi‚rarchique
  On   appelle  "menu  hi‚rarchique"  les  "sous-menus"  qui   peuvent 
apparaŒtre … droite ou … gauche du menu normal lorsque la souris passe 
sur  certaines  options de ce menu.  BIG permet de  r‚aliser  cela  de 
maniŠre  automatique,  en  prenant  en charge la gestion  de  ce  menu 
hi‚rarchique,  ainsi  que des ‚quivalents clavier qui  pourraient  s'y 
trouver.
  Amenez le curseur de la souris sur l'option 'Fenˆtre  normale',  qui 
comporte  une  petite  flŠche.  Cette flŠche est l…  pour  rappeler  … 
l'utilisateur que cette option appelle un menu hi‚rarchique,  et  elle 
indique  de  quel  cot‚  (… droite ou … gauche)  le  sous-menu  va  se 
d‚rouler.  AprŠs  un petit d‚lai d'environ une demi seconde,  le  menu 
hi‚rarchique  s'ouvre.  Si  vous sortez de l'option du cot‚  opos‚  au 
sous-menu,  ou  si vous d‚placez le curseur plus "haut"  que  lui,  il 
disparaŒt.
  Le menu hi‚rarchique comporte trois options  'Texte...',  'Image...' 
et  'Histogramme'.  Amenez la souris dans le sous-menu.  Il  s'utilise 
comme le menu normal.  Il disparaŒt si vous cliquez une option,  ou si 
vous  cliquez  en dehors,  ou si le curseur de la souris passe  …  une 
autre option du menu principal,  ou,  comme il a ‚t‚ dit,  s'il  passe 
"au-dessus"  du  sous-menu.  Ceci est n‚cessaire afin  d'‚viter  qu'un 
autre menu ne se d‚roule "par dessus" notre menu hi‚rarchique.  De  ce 
fait,  IL  EST INTERDIT de placer un menu hi‚rarchique comme  premiŠre 
option d'un m‚nu d‚roulant (voir le chapitre 3.h pour les d‚tails). La 
routine  de  recherche des ‚quivalents clavier dans  le  menu  cherche 
‚galement   dans  les  sous-menus  de  maniŠre  …   activer   l'option 
correspondante s'il y en a.

  2.g La fenˆtre de texte
  Cliquez l'option 'Texte...' ou pressez <Control + T>.  Un  s‚lecteur 
d'objet  apparaŒt afin que vous puissiez choisir un texte  …  afficher 
dans la fenˆtre. Attention, la d‚mo n'est en mesure de g‚rer seulement 
un  texte en Ascii avec un 'CR LF' … la fin de chaque ligne,  et  dont 
les lignes ont une longueur maximum de 80 caractŠres. N'essayez pas de 
charger  autre  chose,  vous auriez  de  mauvaises  surprises,  aucune 
v‚rification n'est faŒte !
  La fenˆtre qui s'ouvre permet de visualiser le texte.  Elle comporte 
tous les attributs standard d'une fenˆtre (ascenseurs,  etc),  sauf la 
barre d'information.  Cette fenˆtre,  comme celle du grand formulaire, 
peut ˆtre manipul‚e … partir du clavier. De plus, … chaque fois que le 
curseur de la souris entre dans la zone de travail de la  fenˆtre,  il 
prend  la  forme  du curseur-texte  (les  parenthŠses  dos-…-dos),  et 
reprend la forme de flŠche dŠs qu'il en sort.  Cette  caract‚ristique, 
comme la gestion par le clavier,  est automatis‚e par BIG et doit ˆtre 
r‚clam‚e  …  la  cr‚ation de la fenˆtre.  Ce n'est  pas  une  fonction 
vitale, mais c'est agr‚able en cours d'utilisation d'un logiciel.
  Toutes les fonctions de base de cette fenˆtre sont prises en  charge 
par BIG !  La seule chose qui est laiss‚e … la charge du  d‚veloppeur, 
c'est  la routine d'affichage elle-mˆme,  qui d‚pend fortement  de  la 
maniŠre  dont le fichier texte est stock‚ en m‚moire,  et de ce  qu'il 
contient.  La  routine d'affichage de BIGDEMO.C est  trŠs  simplifi‚e, 
mais elle est suffisante dans cette situation. BIG s'occupe de tout le 
reste  :  gestion  des redraws,  d‚placement par page  ou  par  ligne, 
r‚affichage lorsqu'un slider est d‚plac‚,  pleine ouverture et  taille 
pr‚c‚dente,  redimensionnement, d‚placement, etc. Tous les messages du 
GEM  sont  trait‚s sans que le programme  principal  (c'est-…-dire  la 
partie  "hors  BIG"  que  le programmeur doit  ‚crire)  n'ait  …  s'en 
occuper ! Rien que pour cela, BIG est un grand pas en avant.

  2.h La fenˆtre d'image
  La seconde option du menu hi‚rarchique affiche une fenˆtre contenant 
une  image.  Le s‚lecteur vous propose de choisir une image Degas  non 
compress‚e  (extension  'PI?').  Ne tentez pas de  charger  une  autre 
image,  ni  une  image d'un nombre de plans de couleurs  diff‚rent  de 
l'actuel, car la d‚mo ne v‚rifie rien.
  Par contre,  BIG gŠre la palette de couleurs.  La palette de l'image 
charg‚e devient la palette active.  DŠs que vous cliquez sur une autre 
fenˆtre (mˆme si elle est a un autre programme ou accessoire),  ou que 
vous fermez celle-ci, la palette par d‚faut redevient active.
  Cette fenˆtre est ‚galement manipulable au clavier.  La souris prend 
la  forme  d'une main … l'index tendu dans la zone  de  travail.  Pour 
g‚rer l'affichage d'une image avec BIG,  vous n'aurez mˆme pas  besoin 
(comme pour le texte) d'‚crire la routine d'affichage !  En effet,  la 
gestion des rasters (blocs-images) est standardis‚e dans la VDI par le 
biais  des structures MFDB ("Memory Form Definition Block" en  version 
originale).  L'image,  quels  que soient sa  taille,  son  format,  sa 
r‚solution,  etc,  est de toute maniŠre stock‚e dans une zone  m‚moire 
qui  lui  est  r‚serv‚e au chargement.  Il  suffit  d'indiquer  …  BIG 
l'adresse de cette zone m‚moire pour qu'il s'occupe du reste  !  C'est 
pas beau ?

  2.i Une fenˆtre graphique
  L'option  'Histogramme' fait apparaŒtre une fenˆtre  affichant  huit 
histogrammes de tailles diff‚rentes,  calcul‚es al‚atoirement … chaque 
appel de la fonction. Elle possŠde ‚galement une ligne d'informations.
  La fenˆtre peut ˆtre d‚plac‚e et redimensionn‚e, (uniquement par pas 
de  16 pixels,  pour des raisons dont nous reparlerons).  Dans ce  cas 
(ainsi  que dans le cas d'un retour de taille plein ‚cran … la  taille 
pr‚c‚dente),  il faut prendre garde … un d‚tail :  le GEM ne g‚nŠre un 
message de redraw que si les nouvelles dimensions sont sup‚rieures  en 
largeur ou en hauteur (au moins un des deux).  Il faut donc  aiguiller 
le  programme  vers  une  fonction qui  va  tester  cela,  et  qui  va 
r‚afficher la fenˆtre si n‚cessaire (et seulement dans ce  cas,  sinon 
la  fenˆtre  serait r‚affich‚e deux fois).  En  effet,  cette  fenˆtre 
d'histogrammes ne possŠde pas d'ascenceurs. Le graphique est redessin‚ 
… l'‚chelle de la fenˆtre … chaque fois.
  Si  la fenˆtre est … l'arriŠre-plan au moment de l'appel,  elle  est 
amen‚e au premier plan.  Dans ce cas, les histogrammes sont recalcul‚s 
et le r‚affichage du contenu de la fenˆtre doit se faire dans tous les 
cas. BIG se charge de forcer GEM … g‚rer ce redraw dans tous les cas.

  2.j Une fenˆtre avec un menu d‚roulant
  L'option  'Fenˆtre  menu' (ou <Control + M>) ouvre une  fenˆtre  qui 
contient  un menu d‚roulant !  Cette possibilit‚ de placer  des  menus 
dans  les fenˆtres permet de r‚aliser des logiciels d'une  utilisation 
trŠs ergonomique.  Par exemple,  dans un programme de  dessin,  chaque 
fenˆtre peut contenir une image,  et un menu permettant de choisir les 
paramŠtres de couleurs, l'outil de travail, etc, correspondant … cette 
image.
  Une  autre  utilisation int‚ressante des menus en fenˆtre  sont  les 
accessoires de bureau.  Un accessoire ne peut placer une barre de menu 
(il y a des exceptions,  je sais...),  et c'est regrettable.  Mais  il 
peut  ouvrir  une  fenˆtre.  Il suffit de placer un  menu  dans  cette 
fenˆtre, et le tour est jou‚ !
  Naturellement, BIG s'occupe de tout. Le menu est li‚ … la fenˆtre et 
la suit dans ses d‚placements.  Si la fenˆtre devient trop petite pour 
que l'on puisse acc‚der aux menus les plus … droite,  les deux petites 
flŠches  de gauche permettent de les d‚caler.  Cliquez sur elles  pour 
essayer.  Les menus ne se d‚roulent pas automatiquement,  du moins pas 
de suite. Cliquez sur un des titres 'BIGdemo', 'Options' ou 'Alertes'. 
Cette  fois,  le menu correspondant se d‚roule,  et l'ensemble  de  la 
barre  de  menu  fonctionne comme d'habitude.  Vous  pouvez  passer  … 
l'autre  menu,  s‚lectionner une option,  etc.  Le menu principal  est 
"bloqu‚"  pendant ce temps.  Choisissez une option ou cliquez  …  cot‚ 
pour fermer les menus.  Tout redevient normal. Le menu 'Alertes' offre 
mˆme un menu hi‚rarchique !
  BIG s'occupe aussi des ‚quivalents clavier.  Si une fenˆtre-menu  se 
trouve au premier plan (fenˆtre active),  il cherche dans son menu  si 
une  option correspond au raccourci clavier.  Il vaut mieux qu'il  n'y 
ait  pas  de raccourcis clavier identiques dans le menu  principal  et 
dans celui de la fenˆtre, mais si c'est le cas, la fenˆtre a priorit‚. 
DŠs qu'une correspondance est trouv‚e,  la recherche s'interrompt.  La 
recherche s'effectue aussi dans les menus hi‚rarchiques s'il y en a.
  Le  menu est cr‚‚ dans l'‚diteur de ressource comme un menu  normal. 
Vous  pouvez  laisser  ou  enlever  les  options  r‚serv‚es  pour  les 
accessoires  de bureau.  Elles seront supprim‚es pour  l'affichage  en 
fenˆtre. BIG se charge de "fenˆtriser" ce menu.
  Continuons la visite par ce menu de fenˆtre. L'option 'Infos' est la 
mˆme  que celle du menu principal.  Elle affiche le  mˆme  formulaire. 
L'option  'Alerte' affiche une alerte BIG,  d‚pla‡able.  L'option  est 
alternativement  "check‚e" et "d‚-check‚e" … chaque fois  qu'elle  est 
appel‚e.
  L'option  'Charger  image'  permet de charger une  image  Degas  non 
compress‚e (mˆmes remarques que tout … l'heure) et de l'afficher  dans 
la fenˆtre (l… aussi, la palette de couleurs est g‚r‚e). FaŒtes-le.
  FaŒtes  l'exp‚rience  de  charger  une image  avec  une  palette  de 
couleurs  dans  la  fenˆtre  "image",   une  autre  avec  une  palette 
diff‚rente  dans  la  fenˆtre "menu",  et ouvrez  une  autre  fenˆtre, 
"texte"  par exemple.  Passez d'une fenˆtre … l'autre en observant  la 
palette courante.
  L…  encore,  BIG s'occupe de tout :  manipulations de la  fenˆtre  … 
partir  du clavier,  forme de la souris dans la zone de  travail  (une 
croix fine),  ascenseurs, r‚affichage, palette, etc. Si du texte avait 
‚t‚  plac‚ … la place de l'image dans cette fenˆtre,  nous aurions  d– 
simplement ‚crire la routine d'affichage.
  Enfin,   l'option   'Ic“nes'  est  munie  d'un  menu   hi‚rarchique. 
Contrairement … leurs homologues du menu principal,  ils peuvent  ˆtre 
plac‚s,  dans  le cas d'un menu de fenˆtre,  en premiŠre  option  d'un 
menu.  Ce  sous-menu permet d'afficher une boŒte d'alerte  (la  mˆme), 
avec  les 9 motifs d'ic“nes d'alerte propos‚s par BIG,  plus le  "sans 
ic“ne".  On  peut ‚galement les afficher par les  raccourcis  clavier. 
Certaines  de  ses  options travaillent  par  pointeur  sur  fonction, 
d'autres non. Nous y reviendrons.

  2.k Un pop-up libre
  Nous n'avons pas fini. Cliquez avec le bouton droit de la souris. Un 
menu pop-up apparaŒt,  centr‚ sur la position du clic (ou d‚cal‚ si on 
est au bord de l'‚cran) !  Ce pop-up libre est optionnel.  BIG gŠre le 
bouton droit de la souris,  vous le signale lorsqu'il est  cliqu‚,  et 
peut en prime si vous le d‚sirez g‚rer automatiquement un menu  pop-up 
comme celui-ci. Dans l'exemple, ce menu pop-up reprend les diff‚rentes 
options  du  menu principal.  Une seule restriction  :  il  n'est  pas 
possible de placer des menus hi‚rarchiques li‚s … des options de  menu 
pop-up.

  2.l Gestion du timer
  Une autre action est r‚alis‚e par BIG,  qui n'est pas apparente dans 
la  d‚mo.  A  chaque  fois que "rien" ne  s'est  pass‚,  ni  ‚v‚nement 
clavier,  ni clic,  ni manipulation de fenˆtre, etc, BIG le signale au 
programme  principal.  Cela se produit en temps normal plusieurs  fois 
par  seconde.  Il est alors possible d'en profiter pour faire  quelque 
chose  en pseudo tƒche de fond,  par exemple d‚cr‚menter  un  compteur 
pour une sauvegarde automatique, surveiller la prise s‚rie, envoyer du 
texte  … l'imprimante,  etc.  Mais sous MultiTOS,  il faut  ˆtre  trŠs 
prudent avec ce genre de fonction...

  2.m Fin de la visite
  Cliquez l'option 'Quitter'.  BIG se charge de fermer les fenˆtres et 
de  lib‚rer  les diff‚rentes zones m‚moire  qu'il  avait  r‚serv‚,  le 
ressource, etc.
  Jetons … pr‚sent un coup d'oeil (‚bahi !) au source BIGDEMO.C  :  il 
ne fait que 781 lignes !!! 781 lignes (trŠs a‚r‚es) pour r‚aliser tout 
cela, sans aucune variable globale. Certes, ce programme est juste une 
d‚mo, il ne r‚alise rien, mais il possŠde une interface complŠte, avec 
des choses in‚dites ou presque.
  Nous  avons (rapidement) fait le tour de ce que BIG peut faire  pour 
le  programmeur :  s'occuper d'une quantit‚ de choses qui  sont  ainsi 
faŒtes une bonne fois pour toutes.  Dans un programme "sous BIG",  une 
grande  partie de la programmation de l'interface se trouve  dans  les 
routines  BIG.  Le d‚veloppeur n'a plus qu'… traiter  quelques  points 
particuliers  ou  des cas sp‚cifiques … son application.  Quant  …  la 
structure de cette interface,  elle se trouve en grande partie dans le 
ressource lui-mˆme, comme nous allons le voir trŠs vite.
  Ce  qui ne se voit pas dans la d‚mo,  c'est que grƒce aux  pointeurs 
sur  fonction,   la  taille  du  programme  diminue  dans  de  grandes 
proportions,   du  fait  que  certaines  fonctions  sont   directement 
appel‚es.






















































3. Les nouveaux types d'objets
  Commen‡ons  par jeter un coup d'´il sur les nouveaux types  d'objets 
impl‚ment‚s par BIG.  Pour les d‚finir,  nous utilisons le concept  de 
"type ‚tendu" de l'AES. De quoi s'agit-il ? Les types d'objets d‚finis 
en  standard  par  le GEM vont du num‚ro 20  au  num‚ro  32.  Ce  type 
(ob_type) ‚tant cod‚ sur un int (2 octets),  il reste pas mal de place 
disponible. Pour d‚terminer le type d'un objet, l'AES teste l'octet de 
faible poids sans s'occuper de l'autre. Nous avons donc la possibilit‚ 
de  l'utiliser  … notre guise pour y stocker jusqu'… 255  valeurs  que 
nous appelons "type ‚tendu" (En r‚alit‚, les particularit‚s du nouveau 
GEM4  se r‚servent les valeurs de 128 … 255.  Il nous reste  donc  les 
valeurs 1 … 127).  Ces objets peuvent ensuite ˆtre dessin‚s par le GEM 
(par objc_draw() ou objc_change()).  Il prendra alors l'aspect indiqu‚ 
par son type normal (l'octet de faible poids). Mais dans BIG, certains 
de  ces  objets … type ‚tendu sont transform‚s en  G_USERDEF,  ce  qui 
signifie  qu'ils seront dessin‚s par une routine du programme  et  non 
pas  par une routine GEM.  Bien entendu,  ces routines de dessin  sont 
‚galement int‚gr‚es … BIG.
  BIG utilise ‚galement les ob_state ‚tendus.  En effet,  le paramŠtre 
ob_state (ainsi que ob_flags) des objets n'est pas entiŠrement utilis‚ 
par  l'AES.  Seuls les bits 0 … 5 de ob_state (et les bits 0 …  11  de 
ob_flags) sont r‚serv‚s.  L'AES ne teste mˆme pas les autres bits lors 
d'un  appel  normal.  Nous allons les utiliser pour  certains  de  nos 
paramŠtres.
  Voici ces nouveaux types d'objets et les noms utilis‚s dans BIG  (de 
la mˆme fa‡on que tous les noms d'objets GEM commencent par 'G_',  les 
noms d'objets BIG commencent par 'B_') :
B_COCHE   Bouton coch‚.  C'est un bouton s‚lectable qui prend l'aspect 
          d'un  petit  carr‚  avec le texte du  bouton  …  sa  droite. 
          Lorsqu'il est s‚lectionn‚, le carr‚ est barr‚ de diagonales. 
          Un caractŠre du texte peut ˆtre soulign‚,  afin d'activer le 
          bouton par la combinaison <Alternate +  caractŠre>.  R‚serv‚ 
          aux boutons simplement s‚lectables.
B_RADIO   Bouton rond.  C'est un bouton s‚lectable qui prend  l'aspect 
          d'un  petit  cercle  avec le texte du bouton  …  sa  droite. 
          Lorsqu'il est s‚lectionn‚,  le cercle contient un petit rond           
          noir,  sinon ce cercle int‚rieur est vide.  Un caractŠre  du 
          texte  peut ˆtre soulign‚,  afin d'activer le bouton par  la 
          combinaison  <Alternate  + caractŠre>.  R‚serv‚  aux  radio-
          boutons.
B_EDIT    Champ  ‚ditable  ‚tendu,  permettant la saisie  de  plus  de 
          caractŠres  que  la largeur du  champ.  Ces  objets  doivent 
          imp‚rativement   comporter   de   chaque   cot‚   du   champ           
          lui-mˆme  des  petites flŠches vers la gauche et  la  droite 
          (Ascii  4  et 3).  Un espace doit respectivement  suivre  et 
          pr‚c‚der ces flŠches.
B_FRAME   Rectangle  servant  …  encadrer  d'autres  objets  pour  les 
          regrouper  visuellement,  par  exemple un groupe  de  radio-
          boutons.  Le  texte  associ‚ apparaŒt en haut  …  gauche  du           
          cadre,  … cheval sur le trait. Il est possible de donner des 
          attributs graphiques … ce texte.
B_MOVE    Bouton  servant … d‚placer le formulaire sur l'‚cran.  Il  a 
          l'aspect d'un triangle, comme si le coin du formulaire ‚tait 
          corn‚.   Il   est  traditionnellement  plac‚  dans   l'angle           
          sup‚rieur droit du formulaire.
B_DEFAULT C'est  le traditionnel bouton par d‚faut,  avec  son  aspect 
          normal.
B_UNDO    C'est  un  bouton … l'aspect normal,  mais qui  pourra  ˆtre 
          activ‚  par  une  pression sur la touche  <Undo>  (peut  par 
          exemple ˆtre le bouton 'Annuler').



B_HELP    Bouton  donnant accŠs … une aide en ligne,  sans quitter  la 
          gestion  du  formulaire en cours.  Il sera  activ‚  par  une 
          pression  sur  la  touche  <Help>.   Il  …  l'aspect   d'une           
          G_BOXTEXT  'SHADOW' et 'OUTLINE',  avec le texte  en  petits 
          caractŠres.
B_POPUP   Bouton "Shadowed" normal,  mais qui donne accŠs … la gestion 
          d'un  menu  pop-up  associ‚,  sans  quitter  la  gestion  du 
          formulaire en cours.
B_GRASTR  ChaŒne  de texte avec attributs graphiques servant de  titre 
          au formulaire.
B_HIERM   Option de menu appelant un menu  hi‚rarchique,  c'est-…-dire 
          un menu pop-up … cot‚ du menu principal. Peuvent ˆtre plac‚s 
          dans un menu de fenˆtre.
B_FNCP    N'importe quel type d'objet ou option de menu qui sera li‚ … 
          une fonction ('FNCP' signifie "FuNCtion Pointer"). Il suffit 
          de   cliquer  cet  objet  ou  cette  option  de   menu   (ou           
          de  l'invoquer  par  son  raccourci  clavier)  pour  que  la 
          fonction soit automatiquement ex‚cut‚e.

  3.a Les attributs
  Voici un tableau r‚capitulatif de ces objets, avec leur type ‚tendu, 
leurs attributs, etc, tels qu'ils doivent ˆtre cr‚‚s dans l'‚diteur de 
ressource.

  Nom       Type      Type    ob_flags  ob_state  ob_state  Attributs 
  objet    normal    ‚tendu    normal    ‚tendu    normal   interdits
B_COCHE   G_BUTTON   B_SELEC  SELECTABLE   --        --     RBUTTON  
                      (18)                                  SHADOWED
B_RADIO   G_BUTTON   B_SELEC  SELECTABLE   --        --     SHADOWED           
            (18)    RBUTTON
B_EDIT    G_FTEXT    B_EDIT   EDITABLE   Nbre de     --       --   
          G_FBOXTEXT  (25)               caractŠres
B_FRAME   G_BUTTON   B_FRAME     --      Attributs   --     SELECTABLE          
             (20)               graphiques         EXIT
B_MOVE    G_IBOX     B_MOVE   TOUCHEXIT    --     OUTLINED  SELECTABLE         
              (17)                        CROSSED
B_DEFAULT G_BUTTON     --     SELECTABLE 1 : fermer  --       --  
                              DEFAULT    fenˆtre
                              EXIT
B_UNDO    G_BUTTON   B_UNDO   SELECTABLE 1 : fermer  --       --         
              (31)    EXIT       fenˆtre
B_HELP    G_BOXTEXT  B_HELP   SELECTABLE nø form  OUTLINED    --    
    (Petit texte) (21)               associ‚  SHADOWED
B_POPUP   G_BUTTON     --     SELECTABLE nø form     --       --  
          G_IMAGE             SHADOWED   associ‚
B_GRASTR  G_BUTTON   B_GRASTR    --      Attributs   --       --            
           (19)               graphiques
B_HIERM   G_STRING   B_HIERM     --      nø form     --       --   
           (Menu)     (41)               associ‚
B_FNCP    Tous       B_FNCP      --      Rien … la   --       --          
            (51)               cr‚ation

     Notez  que les conventions pr‚sent‚es ci-dessus  sont  semblables 
aux  standards existant d‚j… dans d'autres bibliothŠques  GEM  ‚tendu, 
telle  que FLY_DIAL et INTERFACE (qui ne proposent pas de  systŠme  de 
pointeurs sur fonction ni d'attributs graphiques).  Toutefois, il peut 
y avoir des diff‚rences entre le "look" d'un type d'objet dessin‚  par 
INTERFACE et le mˆme dessin‚ par BIG.  En particulier, les B_COCHEs et 
les B_RADIOs. J'ai volontairement donn‚ un aspect diff‚rent … ces deux 
boutons,  afin  qu'ils  ne ressemblent pas trop … leur  homologues  du 
monde  Mac.  Mon opinion personnelle est que les d‚veloppeurs  doivent 
s'efforcer  de conserver … l'Atari sa "personnalit‚" et ne pas  tenter 
de lui faire ressembler … d'autres machines.

  3.b Dessine-moi un bouton
  Voyons … pr‚sent les d‚tails.  Le type normal correspond au type  de 
l'objet lors de sa cr‚ation dans l'‚diteur de ressource.  Ce sont  les 
routines de BIG qui vont se charger de la transformation de l'objet en 
G_USERDEF  (si  n‚cessaire) en fonction des autres indications  de  ce 
tableau.  Le  nom  indiqu‚ comme type ‚tendu est celui donn‚  par  les 
'#define'  de BIG.H.  La valeur correspondante est  donn‚e  avec.  Les 
attributs  de  "ob_flags  normal" repr‚sentent les  bits  qui  doivent 
obligatoirement ˆtre positionn‚s dans l'ob_flags de l'objet.  De  mˆme 
pour "ob_state normal".  La colonne "attributs interdits" repr‚sentent 
les  paramŠtres qui ne doivent JAMAIS ˆtre activ‚s.  En fait,  il  est 
conseill‚  de  n'activer que ceux qui sont indiqu‚s  dans  les  autres 
colonnes, … l'exception des ob_states 'SELECTED' et 'DISABLED'.
  Les  "ob_state  ‚tendus"  sont  utilis‚s  par  les   B_FRAMEs,   les 
B_GRASTRs,  B_POPUPs,  les B_HELPs,  les B_HIERMs,  les B_EDITs et les 
B_FNCPs.  Les B_DEFAULTs et les B_UNDOs les utilisent ‚galement,  mais 
d'une maniŠre un peu sp‚ciale sur laquelle nous reviendrons en parlant 
des formulaires plac‚s en fenˆtre.
  Comme il a d‚j… ‚t‚ dit, les 10 bits les plus forts de ob_state sont 
d'utilisation libre.  BIG n'utilise en fait que l'octet haut, c'est-…-
dire les 8 bits les plus forts.  En ce qui concerne les B_POPUPs,  les 
B_HELPs  et les B_HIERMs,  nous l'utilisons dans BIG pour y placer  le 
num‚ro  (dans le fichier ressource) du formulaire associ‚ … ce  bouton 
(Attention,  la  num‚rotation commence … z‚ro).  Par  exemple,  si  le 
formulaire  nø  12 doit ˆtre appel‚ lors de la s‚lection  d'un  bouton 
B_HELP,  nous positionnons dans l'ob_state de ce bouton les bits 10 et 
11. En ne tenant compte que de l'octet sup‚rieur, cela correspond … la 
valeur  12.   Les  routines  de  BIG  appelleront  automatiquement  ce 
formulaire et s'occuperont de sa gestion. Il est ‚galement possible de 
demander  … BIG de g‚rer une aide … partir d'un bouton  n'ayant  aucun 
ob_state ‚tendu. Nous y reviendrons.
  Le  principe est le mˆme pour les boutons pop_up et les  options  de 
menu hi‚rarchique.  Nous cr‚ons dans l'‚diteur de ressource un  bouton 
(ou une option de menu) ayant les attributs ci-dessus, et l'octet haut 
de l'ob_state contient le num‚ro du petit formulaire pop-up associ‚  … 
ce bouton. Un mˆme formulaire peut ˆtre associ‚ … plusieurs boutons.
  En ce qui concerne les B_FNCPs,  c'est encore plus  simple,  puisque 
nous  n'avons  rien … faire … la cr‚ation du fichier  ressource  (sauf 
pr‚ciser le type ‚tendu,  bien s–r) !  Le principe est de placer  dans 
l'octet haut de l'ob_state ‚tendu l'index correspondant du tableau  de 
fonctions  (il ne peut donc y avoir "que" 256 pointeurs  sur  fonction 
par  application).  Mais  cela est fait automatiquement  par  BIG.  En 
effet, les routines d'initialisation comptent le nombre d'objets ayant 
B_FNCP  comme type ‚tendu,  puis r‚servent une zone m‚moire de  taille 
ad‚quate  qui  sera  manipul‚e  comme  un  tableau  de  pointeurs  sur 
fonction. Au programmeur de faire pointer chaque ‚l‚ment de ce tableau 
sur  une  fonction du programme (Nous verrons comment en  ‚tudiant  le 
source de la d‚mo).  Il y a deux rŠgles … respecter.  La premiŠre  est 
que  les pointeurs doivent ˆtre affect‚s aux ‚l‚ments du tableau  dans 
le mˆme ordre que les objets apparaŒssent dans le ressource.
  Voyons  un exemple.  Le ressource comporte trois  arbres  :  "Menu", 
"Pr‚f‚rences" et "Choix" (dans cet ordre).  Dans "Menu",  deux  objets 
(num‚rot‚s 15 et 23) sont des B_FNCPs. Dans "Pr‚f‚rences", deux autres 
(num‚ros  5  et  8),  et enfin 3 objets  dans  le  formulaire  "Choix" 
(num‚ros 8,  11 et 13).  C'est dans l'ordre croissant (15,  puis 23 de 
"Menu" ;  5,  puis 8 de "Pr‚f‚rences" ;  8, 11 puis 13 de "Choix") que 
les  ‚l‚ments de tableaux leurs sont r‚serv‚s.  Lorsque l'objet 11  de 
"Choix" sera cliqu‚, c'est la fonction dont le pointeur est dans le 5ø 
‚l‚ment  du tableau qui sera ex‚cut‚e (Puisque c'est le 6ø objet  dans 
l'ordre, la num‚rotation commen‡ant … 0).
  La  seconde  rŠgle  est  que la fonction doit  ˆtre  du  type  'void 
fonction  (void)',   c'est-…-dire  qu'elle  ne  peut  recevoir   aucun 
paramŠtre et ne doit en retourner aucun (Il y a une astuce pour passer 
outre … cette contrainte,  voyez le chapitre 7).  Cette possibilit‚ de 
faire pointer des objets GEM sur des fonctions est un des plus  grands 
int‚rˆts de BIG. Les sources des programmes diminuent ‚norm‚ment grƒce 
… cela, puisqu'il n'est plus n‚cessaire d'effectuer une s‚rie de tests 
jusqu'alors  incontournables  :   Quel  type  d'‚v‚nement   s'est-t-il 
produit ? Si c'est un clic menu, quelle option ? Si c'est un bouton de 
formulaire, quel bouton de quel formulaire ? etc...
  Les  objets B_FRAMEs et B_GRASTRs utilisent l'ob_state  ‚tendu  pour 
d‚terminer les attributs graphiques de la chaŒne de la mˆme fa‡on  que 
la fonction 'vst_effect()' de la VDI.  L'octet sup‚rieur de l'ob_state 
contient l'attribut.
  bit 0 : Gras
  bit 1 : Clair
  bit 2 : Italique
  bit 3 : Soulign‚
  bit 4 : Contour
  Si le bit 3 est mis pour un objet B_GRASTR, le trait de soulignement 
ne se limite pas … la largeur du texte,  mais … la largeur de  l'objet 
(ob_width).
  Enfin,  l'ob_state ‚tendu est utilis‚ avec les B_EDITs pour indiquer 
le  nombre  de caractŠres qu'il est possible de saisir dans  le  champ 
‚ditable.

  3.c Les menus pop-up
  Les  formulaires  d'aide et de pop-up doivent  r‚pondre  …  certains 
imp‚ratifs.  Les aides sont de simples formulaires sans dialogue  avec 
l'utilisateur.  Ils ne contiennent en principe que du texte explicatif 
et  des cadres de pr‚sentation (Les B_FRAMEs et les B_GRASTRs  peuvent 
ˆtre  employ‚s).  Il doivent comporter au moins un objet de  sortie  : 
SELECTABLE,  DEFAULT,  EXIT.  Les  autres types de  boutons  (RBUTTON, 
B_POPUP,  etc)  sont g‚r‚s automatiquement dans un formulaire  d'aide, 
mais  la routine d'aide elle-mˆme devra ˆtre r‚‚crite si  l'on  d‚sire 
par exemple que l'affichage de l'aide d‚pende d'un Pop-Up. A moins que 
l'on utilise des pointeurs sur fonction.
  Les  formulaires pop-up ont l'aspect d'un  menu  d‚roulant.  L'objet 
racine  est  une G_BOX SHADOWED dont le contour est large  d'un  pixel 
vers l'ext‚rieur. Il y a deux types de pop-ups : le pop-up texte et le 
pop-up  image.  Les  options  d'un pop-up  texte  sont  des  G_STRINGs 
TOUCHEXIT.  Les deux premiers caractŠres sont des espaces (comme  dans 
un  menu  normal).  Si certaines options doivent  ˆtre  inactives,  la 
G_STRING correspondante doit ˆtre DISABLED.  Il est conseill‚ que  les 
num‚ros  de  ces  G_STRINGs  soient tri‚s  de  haut  en  bas.  L'objet 
"appelant" d'un pop-up texte est un G_BUTTON SHADOWED SELECTABLE.
  Les  options  d'un pop-up image sont  des  G_IMAGEs.  Elles  doivent 
toutes avoir les mˆmes dimensions (ob_width et  ob_height),  ‚galement 
les  mˆmes que celles de l'objet G_IMAGE qui a appel‚ le menu  pop-up. 
Cet  objet  "appelant"  doit  ˆtre  SHADOWED  et   SELECTABLE.   Comme 
l'attribut  SHADOWED  n'a pas d'influence sur  l'aspect  visuel  d'une 
G_IMAGE,  il est conseill‚ (comme dans la d‚mo), de la placer dans une 
G_BOX SHADOWED, puisque c'est traditionnellement l'ombrage qui signale 
la pr‚sence d'un pop-up.
  L'utilisation de ce formulaire est exactement la mˆme que celle d'un 
menu d‚roulant classique. Le pop-up tente de se placer de maniŠre … ce 
que  le texte du bouton B_POPUP et celui de la G_STRING de mˆme  texte 
(ou  la  G_IMAGE de mˆme motif) soit superpos‚s.  Si  cela  n'est  pas 
possible car le pop-up sortirait de l'‚cran,  il est d‚cal‚  d'autant. 
Si  le  texte  d'aucune G_STRING (ou le  motif  d'aucune  G_IMAGE)  ne 
correspond,  le  coin sup‚rieur gauche du pop-up est cal‚ sur le  coin 
inf‚rieur  gauche  du B_POPUP.  Pour fermer le pop-up  sans  faire  de 
choix,  il suffit de cliquer … c“t‚.  Si une s‚lection a ‚t‚ faite, le 
texte de la G_STRING cliqu‚e est report‚ dans le bouton B_POPUP qui  a 
appel‚ le pop-up (sans les espaces de d‚but et de fin), ou le motif de 
la G_IMAGE est report‚ dans la G_IMAGE B_POPUP.  Il est donc imp‚ratif 
qu'au d‚part, le texte du bouton soit au moins aussi long que celui de 
la plus longue G_STRING,  dans le cas d'un pop-up texte, ou que toutes 
les G_IMAGEs soient de mˆme dimensions dans le cas d'un pop-up image.
  Il  est  possible de r‚aliser un pop-up avec plusieurs  colonnes  de 
G_STRINGs  ou de G_IMAGEs.  Mais elles doivent  recouvrir  entiŠrement 
l'objet racine, comme dans un menu d‚roulant.

  3.d Les boutons s‚lectables
  Les  boutons  B_COCHE  et  B_RADIO partagent  le  mˆme  type  ‚tendu 
(B_SELEC). Ils sont en r‚alit‚ de la mˆme cat‚gorie : SELECTABLE. Leur 
seule  diff‚rence est que les B_RADIOs sont  des  radio-boutons,  d'o— 
leur aspect diff‚rent pour mieux les distinguer.  Ces boutons  peuvent 
comporter un caractŠre soulign‚.  Lors de la gestion du formulaire, le 
raccourci  clavier <Alternate + caractŠre> sera ‚quivalent …  un  clic 
sur  ce  bouton.  Lors de la cr‚ation du  ressource,  le  caractŠre  … 
souligner doit ˆtre pr‚c‚d‚ d'un crochet ouvert ('[').  La routine  de 
dessin du bouton se chargera du reste. Attention, si plusieurs boutons 
d'un mˆme formulaire ont le mˆme caractŠre soulign‚,  c'est le premier 
(dans  l'ordre  de num‚rotation des objets) qui sera  retenu  pour  le 
raccourci clavier. Il est possible que ces boutons quittent la gestion 
du formulaire (EXIT),  ou qu'ils soient inactifs (DISABLED).  Dans  ce 
cas, le clic souris et le raccourci clavier sont sans effet.
  Lors de la cr‚ation d'un de ces objets dans l'‚diteur de  ressource, 
la  largeur du G_BUTTON ne correspond pas forc‚ment … la  largeur  qui 
sera  occup‚  "physiquement" par l'objet dessin‚ dans  le  formulaire, 
puisque le carr‚ ou le cercle est ajout‚ … gauche du texte.  Voici  un 
conseil :  commencez par cr‚er le bouton … la taille minimum, c'est-…-
dire la largeur du texte.  Activez l'option de grille de l'‚diteur  de 
ressource (en haute r‚solution, la grille horizontale a normalement un 
pas  de 8 pixels).  Augmentez alors la largeur de ce bouton  de  trois 
"unit‚s" s'il n'y a pas de caractŠre soulign‚,  et de deux s'il y en a 
un.  Ainsi,  la  largeur du bouton dans l'‚diteur de ressource est  le 
reflet de la largeur qu'il aura une fois dessin‚ par les routines BIG.
  Les  B_POPUPs n'ont pas de type ‚tendu.  Par souci de  compatibilit‚ 
avec  les  autres  librairies de GEM ‚tendu  existant,  on  peut  leur 
attribuer le type ‚tendu B_SELEC, comme c'est g‚n‚ralement le cas. BIG 
n'en  tiendra pas compte,  le bouton ‚tant dessin‚ "normalement"  dans 
tous les cas.  Par contre, il est obligatoire de lui donner l'attribut 
SHADOWED, c'est lui qui fait la diff‚rence.
  Les  types ‚tendus des boutons B_UNDO et B_HELP n'ont pas  non  plus 
d'influence  sur  leur  aspect.  Leur dessin est laiss‚  au  soin  des 
routines  GEM normales.  Ce type ‚tendu sert … les distinguer dans  le 
formulaire  lors d'une pression sur la touche Undo ou Help,  selon  le 
cas.  Si plusieurs objets possŠdent ce type ‚tendu,  c'est le  premier 
qui sera retenu.  Cela peut ˆtre int‚ressant dans le cas des  B_HELPs. 
Il  peut ˆtre utile d'en avoir plusieurs dans le mˆme  formulaire.  Le 
premier formulaire d'aide pourra ˆtre appel‚ par la touche  Help,  les 
autres  uniquement par clic souris.  Cela a l'avantage de  laisser  la 
gestion  du  formulaire d'aide aux routines BIG,  par  le  systŠme  de 
l'ob_state  ‚tendu expliqu‚ plus haut.  Les B_DEFAULTs  appellent  les 
mˆmes  commentaires,  mais ils n'ont pas de  type  ‚tendu,  l'attribut 
DEFAULT ‚tant suffisant.
  Comme  nous l'avons rapidement vu dans la visite guid‚e de  BIGdemo, 
les formulaires en fenˆtre possŠdent 4 boutons de base  :  'Applique', 
'Confirme',  'R.A.Z.'  et 'Annule' (vous pouvez ‚videmment les  nommer 
autrement).  Selon  les pr‚f‚rences du programmeur,  ce sera  soit  la 
paire 'Applique' et 'R.A.Z.', soit la paire 'Confirme' et 'Annule' qui 
sera  activ‚e par les touches <Return> et <Undo>.  La valeur  '1'  (le 
premier  bit) doit ˆtre plac‚e dans l'ob_state ‚tendu des  objets  qui 
doivent entraŒner la fermeture de la fenˆtre.
  Par exemple,  dans les formulaires en fenˆtre de BIGdemo, 'Applique' 
et  'R.A.Z.'  sont  activables …  partir  du  clavier.  'Confirme'  et 
'Annule'  n‚cessite un clic souris,  mais ferment  automatiquement  la 
fenˆtre.  FaŒtes l'exp‚rience d'oter les attributs B_DEFAULT et B_UNDO 
des  deux premiers pour les affecter aux deux autres,  et  la  fenˆtre 
pourra ˆtre ferm‚e par le clavier. On peut envisager dans un programme 
de  laisser le choix … l'utilisateur de quelle paire de  boutons  peut 
ˆtre activ‚e par le clavier, en modifiant les attributs correspondants 
dans  le ressource en m‚moire,  tout en choisissant une  configuration 
par d‚faut … la cr‚ation du ressource.

  3.e Les ‚ditables ‚tendus
  Les  objets  B_EDIT  sont  des  champs  ‚ditables   "‚tendus",   qui 
autorisent la saisie de plus de caractŠres que la largeur apparente du 
champ  ne le laisse supposer.  Par exemple,  l'‚ditable lui-mˆme  peut 
ˆtre  large de 15 caractŠres (largeur de la chaŒne  pvalid),  mais  le 
texte peut avoir une longueur plus importante, jusqu'… 255 caractŠres.
  Le  nombre de caractŠres autoris‚s est indiqu‚ dans l'octet haut  de 
l'ob_state.  Il est imp‚ratif de placer les flŠches de part et d'autre 
du  champ,  de la maniŠre suivante (les flŠches sont repr‚sent‚es  ici 
par les caractŠres '<' et '>' au lieu des caractŠres Ascii 4 et 3) :
  Texte : < _______________ >
  Le  champ est pr‚c‚d‚ d'une flŠche … gauche et d'un espace,  il  est 
suivi d'un espace et d'une flŠche … droite.  Ces flŠches permettent de 
faire d‚filer le texte … la souris. La routine de placement du curseur 
… l'emplacement du clic (lorsqu'on clique dans le champ) tient  compte 
dans ses calculs de la pr‚sence de ces flŠches s'il s'agit d'un  objet 
B_EDIT. Si vous ommettez la flŠche de droite et son espace, le curseur 
sera positionn‚ deux caractŠres … gauche de la position cliqu‚e.
  D'autre part, lors de la saisie des caractŠres, BIG considŠre que la 
chaŒne pvalid (le filtre de saisie) est actif pour la partie apparente 
du texte. Il faut donc r‚server les B_EDIT aux ‚ditables constitu‚s de 
caractŠres  de  mˆme  type.   Par  exemple  la  chaŒne  p_valid   sera 
"XXXXXXXXXXX"  ou "9999999999".  Si elle est constitu‚e  de  plusieurs 
filtres diff‚rents, on aura de mauvaises surprises … la saisie.

  3.f D‚placer le formulaire
  Les boutons B_MOVE permettent de d‚placer le formulaire sur l'‚cran. 
Ce d‚placement peut se faire "en temps r‚el",  c'est-…-dire que  c'est 
une image du formulaire lui-mˆme que l'on d‚place jusqu'… la  nouvelle 
position,  ou  simplement  par une "boŒte fant“me" …  ses  dimensions. 
Toutefois,  s'il n'y a pas assez de m‚moire disponible pour travailler 
en  temps  r‚el (l'‚cran entier doit ˆtre sauv‚ dans  un  buffer),  le 
systŠme  de la boŒte fant“me est automatiquement utilis‚,  mˆme si  le 
d‚placement en temps r‚el est demand‚ lors de l'appel de la  fonction. 
Il est possible de forcer l'utilisation de la boŒte fant“me au lieu du 
temps r‚el mˆme s'il y a assez de m‚moire.
  Lorsqu'on clique ce bouton,  et que l'on garde le bouton enfonc‚, il 
est possible de d‚placer le formulaire.  Quand la souris est relƒch‚e, 
le  formulaire est "pos‚" au nouvel emplacement.  Les d‚placements  du 
formulaire  (ou  de la "boŒte fant“me") se font dans  les  limites  du 
bureau,  moins  trois  pixels  sur  chaque  bord,  afin  de  compenser 
l'attribut  OUTLINED qu'ont la plupart de temps les objets-racine  des 
formulaires.

  3.g Du texte graphique
  Les  B_FRAMEs  sont  des  G_BUTTONs.   Seul  leur  type  ‚tendu  les 
distingue. Le c“t‚ sup‚rieur du cadre sera trac‚ … une demi hauteur de 
caractŠre  plus  bas que l'emplacement du bouton lors de  sa  cr‚ation 
dans l'‚diteur de ressource. Le texte sera … cheval sur cette ligne, … 
une  largeur  de caractŠre du bord gauche.  L'ob_state ‚tendu  sert  … 
d‚terminer les attributs graphiques de ce texte.
  Les B_GRASTRs peuvent ˆtre des G_STRINGs ou des G_BUTTONs.  Le  type 
G_BUTTON  est  conseill‚,  car  il permet de  mieux  visualiser  (dans 
l'‚diteur de ressource) la largeur de l'objet (qui est utilis‚e si  le 
texte doit ˆtre soulign‚).

  3.h Les menus hi‚rarchiques
  Les  B_HIERMs sont imp‚rativement r‚serv‚s au G_STRINGs des  options 
de menu. L'ob_state ‚tendu contient le num‚ro du formulaire pop-up qui 
est li‚ … cette option.  La gestion du menu hi‚rarchique m‚rite  qu'on 
s'y arrˆte un peu pour des explications.
  Un  d‚lai  d'environ une demi seconde  est  respect‚,  puis,  si  le 
curseur de la souris est toujours cette l'option de menu, le sous-menu 
est  affich‚.  Le problŠme suivant se pose alors :  Si la  souris  est 
amen‚e  sur  un  autre  titre  de  menu,  le  menu  correspondant  est 
automatiquement d‚roul‚ par le GEM !  Evidemment, ce menu risque de se 
placer "par dessus" le menu hi‚rarchique.  Il ne sert … rien de tenter 
de supprimer la gestion du menu principal par  wind_update(BEG_UPDATE) 
ou menu_bar(0),  car alors le menu contenant notre B_HIERM disparaŒt ! 
La seule solution semble ˆtre la suivante (contactez-moi si vous  avez 
une autre id‚e) :  le menu hi‚rarchique est referm‚ dŠs que le curseur 
de la souris passe "au-dessus", c'est-…-dire qu'il a une position en y 
inf‚rieure  au haut du sous-menu.  Il est donc interdit de  placer  un 
menu hi‚rarchique comme premiŠre option d'un menu,  car ce "au-dessus" 
correspondrait … l'entr‚e dans la barre de menu, et nous retrouverions 
le mˆme problŠme :  un nouveau menu pourrait ˆtre d‚roul‚ sur le  menu 
hi‚rarchique.
  D'autre  part,  bien que l'option du menu soit un  Userdef,  le  GEM 
prend  la fƒcheuse initiative de la consid‚rer d‚s‚lectionn‚e dŠs  que 
le   curseur  de  la  souris  la  quitte  pour  passer  sur  le   menu 
hi‚rarchique.  La fonction charg‚e de dessiner cette option en  normal 
ou en invers‚ effectue toute une s‚rie de tests et d‚cide en  fonction 
du contexte (sous-menu affich‚ ou non) et de la position de la  souris 
(sur cette option,  sur une autre, sortie cot‚ sous-menu, sortie autre 
cot‚, plac‚e au-dessus, etc) comment elle doit ˆtre dessin‚e, et force 
‚ventuellement le bit SELECTED.
  Toutes ces consid‚rations ne s'appliquent qu'aux menus hi‚rarchiques 
du menu principal.  Dans le cas des menus en fenˆtre, la situation est 
plus  simple.  En effet,  ce n'est pas le GEM qui gŠre cette barre  de 
menu,  c'est une fonction de BIG. Si le curseur de la souris passe sur 
un  autre  titre de menu alors qu'un menu  hi‚rarchique  est  d‚roul‚, 
cette  fonction  prend  la peine de le refermer  avant  d'afficher  le 
nouveau  menu.  De  ce  fait,  il  est  possible  de  placer  un  menu 
hi‚rarchique  associ‚  …  la premiŠre option  d'un  menu  de  fenˆtre. 
Toutefois,  pour conserver une certaine homog‚n‚it‚ … l'ensemble,  les 
sous-menus disparaissent ‚galement dans le cas des fenˆtres dŠs que la 
souris passe "au-dessus".
  L'option  de  menu B_HIERM doit ˆtre compl‚t‚e par des  espaces  sur 
toute sa largeur.  En effet,  BIG place en avant-dernier caractŠre une 
petite  flŠche  dirig‚e  vers  le  cot‚ o—  va  se  d‚rouler  le  menu 
hi‚rarchique  (Ascii  3  ou 4).  Dans le cas  du  menu  principal,  la 
fonction d'initialisation se charge de l'op‚ration une bonne fois pour 
toutes  au  d‚but de l'ex‚cution du programme.  Si  votre  application 
possŠde plusieurs barres de menu,  vous devrez appeler vous-mˆme cette 
fonction  (voir le chapitre 5.b.2) … chaque changement de menu (si  le 
nouveau menu ne possŠde pas de B_HIERM,  c'est inutile).  Dans le  cas 
des menus de fenˆtre, BIG se charge de l'op‚ration … chaque fois qu'un 
menu doit ˆtre d‚roul‚,  puisque la fenˆtre a pu ˆtre d‚plac‚e  depuis 
le  dernier  calcul.  De plus,  si le sous-menu risque  de  sortir  de 
l'‚cran par le bas,  il est d‚cal‚ d'autant vers le haut.  Cela ne  se 
fait  que pour les menus en fenˆtre.  Pour le menu principal,  BIG  ne 
v‚rifie  rien,  c'est … vous de pr‚voir la hauteur des  sous-menus  en 
cons‚quence.




  3.i Les raccourcis clavier
  Dans les options de menu,  l'inscription des raccourcis clavier doit 
r‚pondre  … certains imp‚ratifs.  Pour ne pas en alourdir la  gestion, 
j'ai  pris  le  parti  de  ne  pas  permettre  d'‚quivalents   clavier 
comportant des touches de fonction,  ni des combinaisons faisant appel 
…  plusieurs touches sp‚ciales,  comme <Shift + Control> par  exemple. 
Ces  raccourcis sont en fait rarement utilis‚s dans  la  pratique,  de 
sorte que cela ne devrait pas ˆtre trop contraignant.  D'ailleurs,  la 
recommandation g‚n‚rale en ce qui concerne ce point est de placer dans 
les menus des raccourcis utilisant uniquement la touche <Control>,  la 
touche  <Alternate>  ‚tant r‚serv‚e aux ‚quivalents clavier  dans  les 
formulaires.
  BIG  ne  tient  pas compte des espaces de  remplissage  qui  peuvent 
suivre l'inscription du raccourci clavier. Le dernier caractŠre "r‚el" 
de  l'option de menu est donc le caractŠre qui doit  ˆtre  press‚,  et 
l'avant-dernier caractŠre est soit '^' pour la touche <Control>,  soit 
le  caractŠre  Ascii 7 (un losange dans un rectangle) pour  la  touche 
<Alternate>,  soit le caractŠre Ascii 1 (la flŠche vers le haut)  pour 
la touche <Shift>, soit un espace pour aucune touche.
  La  routine  de  recherche des raccourcis clavier  ne  fait  pas  la 
diff‚rence entre les majuscules et les minuscules (ni dans les  menus, 
ni dans les formulaires).  Elle ne diff‚rencie pas non plus la  touche 
<Shift  droit> de la touche <Shift gauche>.  Les  ‚quivalents  clavier 
"directs"  (sans pression sur une touche sp‚ciale)  sont  d‚conseill‚s 
pour des raisons de confort d'utilisation.
  Etant donn‚ que la recherche s'effectue dans le ressource en m‚moire 
et  en  fonction du code Ascii de la touche press‚e,  la  gestion  des 
raccourcis  clavier  est  ind‚pendante du  type  de  clavier  (Azerty, 
Qwerty,  etc),  et  d‚pendante  de l'‚quivalent  plac‚  dans  l'option 
correspondante. Pour modifier un raccourci clavier d'un programme sous 
BIG,  il suffit de le modifier dans le fichier ressource.  Sans devoir 
recompiler  le  programme,  le nouvel ‚quivalent  clavier  sera  actif 
imm‚diatement.
  Selon le contexte,  la recherche de correspondance entre une  option 
ou un bouton et le raccourci clavier effectu‚ se fait selon  certaines 
rŠgles de priorit‚.  Le cas le plus simple est celui o— un  formulaire 
ordinaire  est  affich‚.  Le  menu d‚roulant  est  alors  inactif.  La 
recherche se fait dans le formulaire seulement.
  Si  la  fenˆtre  de  premier plan  est  une  fenˆtre  ordinaire,  la 
recherche   se   fait   dans  le  menu  uniquement   (et   ses   menus 
hi‚rarchiques).  Si  c'est  une fenˆtre avec  formulaire,  et  que  ce 
formulaire ne comporte pas de champs ‚ditables, la recherche est faŒte 
en priorit‚ dans le menu,  puis elle continue (si rien n'a ‚t‚ trouv‚) 
dans  le  formulaire de la fenˆtre.  Si le formulaire  de  la  fenˆtre 
comporte un ou plusieurs champ(s) ‚ditable(s),  la recherche est faŒte 
uniquement dans le formulaire.  Si la fenˆtre comporte un menu,  c'est 
ce menu (et ses menus hi‚rarchiques) qui ont priorit‚. La recherche se 
poursuit ensuite dans le menu principal. Il est impossible d'avoir une 
fenˆtre contenant … la fois un menu et un formulaire. BIG ne le permet 
pas, et il faut avouer que cela n'aurait pas grand int‚rˆt.













4. Le travail avec les fenˆtres
  BIG prend en charge 95 % du travail sur les fenˆtres.  Il les ouvre, 
les ferme, les manipule entiŠrement (redraws, d‚filement, d‚placement, 
redimensionnement,  etc), et gŠre une quantit‚ "illimit‚e" de fenˆtres 
par  application.  Entendons-nous bien :  le GEM ne permet  d'afficher 
qu'un  nombre  limit‚ de fenˆtres simultan‚ment … l'‚cran (7  sur  les 
anciens TOS, davantage … partir de la version 4). BIG ne peut franchir 
cette  limite,  mais il r‚alise une gestion interne des  fenˆtres  qui 
existent toujours dans la m‚moire une fois qu'elles ont ‚t‚  referm‚es 
sur l'‚cran.  Un logiciel peut donc travailler virtuellement avec  des 
dizaines  de fenˆtres,  la seule limite ‚tant la quantit‚  de  m‚moire 
disponible.

  4.a Concept des fenˆtres BIG
  Sous  GEM,  on  commence  par cr‚er la  fenˆtre  (avec  la  fonction 
wind_create()),  puis  on l'ouvre (wind_open()) pour afficher  quelque 
chose  dans  sa  zone de travail.  GEM tient … jour  des  tableaux  de 
donn‚es  qui  le renseignent … n'importe quel moment sur  une  fenˆtre 
donn‚e. BIG fait la mˆme chose, mais ses tableaux contiennent beaucoup 
plus d'informations, et le nombre de tableaux (donc de fenˆtres) n'est 
pas limit‚.
  Pour ˆtre pr‚cis,  il s'agit d'un tableau de structures. C'est cette 
structure 'Window' qui contient toutes les informations n‚cessaires  … 
la  gestion  des fenˆtres par BIG.  Les routines  d'initialisation  du 
programme r‚servent dŠs le d‚but de l'ex‚cution une zone m‚moire de la 
taille n‚cessaire pour le nombre de fenˆtres qui seront utilis‚es  par 
le programme.  De sorte que nous n'avons qu'une seule variable globale 
(nomm‚e  'win'),  qui  est de la forme  "Window  *win;",  c'est-…-dire 
"pointeur  sur une structure Window".  A partir de  l…,  nous  pouvons 
acc‚der  …  la  structure  de  n'importe  quelle  fenˆtre  comme  s'il 
s'agissait  d'un  tableau.  Par exemple,  la structure  contenant  les 
informations  relatives … la troisiŠme fenˆtre se trouve  …  l'adresse 
"win[2]" (puisque la num‚rotation commence … 0).
  Voici cette structure, les d‚tails suivent...

  typedef struct window {    /* DEFINITION D'UNE FENETRE */
    int  w_hg;     /* Handle GEM (ou -1 ou 0) */
    int  w_type;   /* Type BIG de la fenˆtre */
    int  w_attr;   /* Attributs (wind_create) */
    int  w_xcurr;  /* Coordonn‚es et */
    int  w_ycurr;  /* dimensions */
    int  w_wcurr;  /* courantes de */
    int  w_hcurr;  /* la fenˆtre active */
    int  w_wmini;  /* Largeur minimum */
    int  w_hmini;  /* Hauteur minimum */
    int  w_wunit;  /* Unit‚ de d‚calage horizontale */
    int  w_hunit;  /* Unit‚ de d‚calage verticale */
    Cont w_cont;   /* Selon le contenu de la fenˆtre */
    OBJECT *w_menu; /* Si fenˆtre avec menu : adresse arbre */
    int  w_flags;  /* Pleine ouv., Clavier, Redraw, Calage, Dern. */
    int  w_mouse;  /* Forme de souris dans la fenˆtre */
    FNCP w_redraw; /* Routine de redraw */
    FNCP w_top;    /* Routine de premier plan */
    FNCP w_close;  /* Routine de fermeture */
    FNCP w_move;   /* Routine fenˆtre d‚plac‚e */
    FNCP w_size;   /* Routine redimensionnement */
    FNCP w_full;   /* Routine pleine ouverture */
    FNCP w_hslid;  /* Routine slider horizontal */
    FNCP w_vslid;  /* Routine slider vertical */
    FNCP w_uppage; /* Routine page haut */
    FNCP w_dnpage; /* Routine page bas */
    FNCP w_lfpage; /* Routine page gauche */
    FNCP w_rtpage; /* Routine page droite */
    FNCP w_upline; /* Routine ligne haut */
    FNCP w_dnline; /* Routine ligne bas */
    FNCP w_lfline; /* Routine ligne gauche */
    FNCP w_rtline; /* Routine ligne droite */
    char *w_title; /* Pointeur sur titre de la fenˆtre */
    char *w_infos; /* Pointeur sur infos de la fenˆtre */
    long w_wtot;   /* Largeur maxi contenu fenˆtre */
    long w_htot;   /* Hauteur maxi contenu fenˆtre */
    long w_lin;    /* 1ø ligne de la fenˆtre */
    long w_col;    /* 1ø colonne de la fenˆtre */
  } Window;
    Cette structure comprend une union :
  typedef union cont {  /* DEFINITION DU CONTENU D'UNE FENETRE */
    Form w_form;   /* Si fenˆtre formulaire */
    Imag w_img;    /* Si image */
    char *w_adr;   /* Si texte ou autre, adresse donn‚es */
  } Cont;

    Cette union est elle-mˆme compos‚e de deux sous-structures :   
typedef struct form {   /* DEFINITION FENETRE FORMULAIRE */
    OBJECT    *w_tree;  /* Adresse arbre */
    int  w_edit;   /* Editable courant */
    int  w_pos;    /* Position du curseur */
    char *w_bak;   /* Sauvegarde ‚tat formulaire */
  } Form;

    typedef struct imag {    /* DEFINITION FENETRE IMAGE */
    MFDB w_blk;    /* Bloc d'informations sur l'image */
    int  *w_pal;   /* Pointeur sur la palette de couleurs */
  } Imag;

    Enfin (ouf !), voici la d‚finition du type 'FNCP', qui signifie 
"FuNCtion Pointer" :
  typedef void (*FNCP)(void);

  4.b La structure Window
  Voil…  les  d‚tails promis,  la description ‚l‚ment par  ‚l‚ment  de 
cette structure. Tous les noms d'‚l‚ments commencent par 'w_' pour les 
distinguer.  Je vous conseille d'‚viter de donner … vos variables  des 
noms  commen‡ant  par  les  mˆmes  caractŠres.  Pour  chaque  ‚l‚ment, 
j'indique  la  signification mn‚monique de son nom,  qui sert  …  s'en 
souvenir   plus   facilement,   ainsi  que  la  valeur   attribu‚e   … 
l'initialisation.
  int  w_hg  "Handle Gem".  Pour acc‚der … une  fenˆtre,  BIG  utilise 
naturellement  les  appels  GEM.  Il  est  donc  indispensable  de  le 
conserver quelque part.  A l'initialisation, cet ‚l‚ment contient '-1' 
(qui  est d‚fini sous le label 'BLANK' dans le  fichier  BIG.H).  Cela 
indique que la fenˆtre n'a jamais ‚t‚ ouverte.  DŠs qu'elle est  cr‚‚e 
et ouverte,  il contient le handle GEM de la fenˆtre. Mais lorsqu'elle 
est  referm‚e,  sa valeur n'est pas remise … '-1' mais … '0',  ce  qui 
indique qu'elle a ‚t‚ cr‚‚e,  puis d‚truite par le GEM,  mais  qu'elle 
existe  toujours  pour  BIG.  Les valeurs contenues  dans  les  autres 
‚l‚ments  de  la structure ne sont donc plus des valeurs  par  d‚faut, 
mais elles repr‚sentent les paramŠtres de la fenˆtre, qui entreront de 
nouveau  en  action  si la cr‚ation de cette fenˆtre  est  de  nouveau 
demand‚e au GEM.
  int w_type "TYPE de la fenˆtre".  Il s'agit du type du point de  vue 
de BIG. Il y a plusieurs types de base. Les voici avec leurs labels de 
d‚finitions :    WTYP_PICT (3) La fenˆtre contient une image.  BIG  se 
charge de tout.
  WTYP_FORM  (2) La fenˆtre contient un formulaire.  BIG se charge  de 
tout.
  WTYP_NORM (1) La fenˆtre est "normale",  elle contient autre  chose, 
probablement  du  texte.   Le  programmeur  doit  ‚crire  la   routine 
d'affichage, BIG se charge du reste.
  WTYP_MENU  (0x8000)  Sauf  dans  le  cas  WTYP_FORM  (interdit),  le 
quinziŠme bit de w_type indique que la fenˆtre contient un menu.
  A l'initialisation : WTYP_NORM par d‚faut.
  int  w_attr "ATTRibuts".  Il s'agit des attributs GEM de la  fenˆtre 
(ascenseurs,  barre de d‚placement,  etc) qu'on indique … la  fonction 
wind_create().  Plusieurs  jeux d'attributs sont d‚finis par BIG  pour 
simplifier  le travail :    WATR_ALL (0xFFF) Tous les  attributs  sont 
activ‚s.
  WATR_CURR (0xFEF) Les attributs courants,  c'est-…-dire tous sauf la 
ligne d'infos.
  WATR_FORM  (NAME | CLOSER | MOVER) R‚serv‚ aux  fenˆtres-formulaires 
normales  (le formulaire n'est pas plus grand que l'‚cran).  Seuls  le 
nom de la fenˆtre,  le bouton de fermeture et la barre de  d‚placement 
sont actifs.
  A l'initialisation : WATR_CURR par d‚faut.
  int w_xcurr,  w_ycurr,  w_wcurr,  w_hcurr. Coordonn‚es et dimensions 
courantes de la fenˆtre.  Ces informations sont mises … jour …  chaque 
changement   de   taille   ou   d'emplacement   de   la   fenˆtre.   A 
l'initialisation : 0, 0, 100, 100.
  int w_wmini,  w_hmini.  Largeur et Hauteur minimum de la fenˆtre. Si 
on tente de la dimensionner … des valeurs inf‚rieures,  BIG corrige. A 
l'initialisation : 100, 100.
  int w_wunit, w_hunit. Unit‚s de d‚calage horizontale et verticale de 
la  fenˆtre,  en  pixels.  Lors  d'un  clic sur  une  des  flŠches  de 
d‚filement,  le contenu est d‚cal‚ dans la direction demand‚e de cette 
valeur.  Pour  du  texte,  ce serait respectivement la largeur  et  la 
hauteur d'une cellule de caractŠre. A l'initialisation : 1, 1.
  Cont  w_cont  "CONTenu  de  la  fenˆtre".   Fix‚  …  '0L'  lors   de 
l'initialisation,  cet ‚l‚ment est en fait une union.  Il d‚pend de ce 
qui  est affich‚ dans la fenˆtre.  Voici d‚crit les ‚l‚ments de  cette 
union :
  Form  w_form  "FORMulaire".  Si la fenˆtre contient  un  formulaire, 
w_cont  est  une  structure 'Form',  d‚finie  par  BIG.  En  voici  la 
description :   OBJECT *w_tree. Adresse du formulaire.
  int  w_edit.  Si le formulaire contient un (ou  plusieurs)  champ(s) 
‚ditable(s),  num‚ro  d'objet  du champ o— se trouve  le  curseur.  -1 
sinon.
  int  w_pos.  Si  le formulaire contient un (ou  plusieurs)  champ(s) 
‚ditable(s), position du curseur dans le champ courant. -1 sinon.
  char  *w_bak.  BIG  est en mesure de g‚rer les  boutons  'Confirme', 
'Annule', 'Applique' et 'R.A.Z.' des formulaires, en restaurant l'‚tat 
du  formulaire  en  cas d'annulation ou remise  …  z‚ro.  Ce  pointeur 
indique la zone de sauvegarde de l'‚tat du formulaire.
  Suite de l'union 'Cont' :
  Imag w_img "IMaGe". Si la fenˆtre contient une image, w_cont est une 
structure 'Imag'. Elle est constitu‚e de deux ‚l‚ments :
  MFDB w_blk "BLocK".  Le MFDB (Memory Form Definition Block) est  une 
structure standardis‚e de la VDI, qui contient toutes les informations 
n‚cessaires  … la gestion d'une image (son  adresse,  ses  dimensions, 
etc).  Grƒce … cette standardisation, BIG peut s'occuper int‚gralement 
de  l'affichage  de  l'image dans la  fenˆtre,  sans  intervention  du 
programme lui-mˆme.
  int  *w_pal  "PALette" Cet ‚l‚ment pointe sur une zone  m‚moire  qui 
contient la palette de couleur de cette image, au format XBIOS.
  Suite de l'union 'Cont' :
  char  *w_adr.  Si  la  fenˆtre  ne contient  ni  une  image,  ni  un 
formulaire (elle contient alors probablement du texte ou un  graphisme 
calcul‚), cet ‚l‚ment est un pointeur sur char qui indique le d‚but de 
la  zone m‚moire o— sont stock‚es les donn‚es (le texte).  La  routine 
d'affichage  de  cette fenˆtre pourra alors les  trouver  directement, 
quelque soit la fenˆtre courante.
  Revenons … la structure principale :
  OBJECT *w_menu "MENU".  Si la fenˆtre contient un menu,  adresse  de 
l'arbre de ce menu.
  int  w_flags.   Cet  ‚l‚ment  est  un  masque  de  bits.   Voici  sa 
description :
  Bit 0 : WFFULL (Window flag FULL)
  Bit 1 : WFARROW (Window Flag ARROW)
  Bit 2 : WFREDRAW (Window Flag REDRAW)
  Bit 3 : WFBOUND (Window Flag BOUNDary)
  Bit 4 : r‚serv‚
  Bit 5 : r‚serv‚
  Bit 6 : r‚serv‚
  Bit 7 : WLAST (Window LAST)
  L'octet  de  faible  poids de ce mot est  entiŠrement  r‚serv‚  pour 
d'‚ventuelles extensions futures de BIG.  Par contre, l'octet de poids 
fort  n'est  pas  utilis‚,  ni mˆme test‚.  Vous ˆtes  donc  libre  de 
l'utiliser … votre guise si les fenˆtres de votre programme ont besoin 
d'autres flags.
  Le  premier  bit est mis si la fenˆtre a sa taille  maximum  (pleine 
ouverture).  Le  second est mis si la fenˆtre doit ˆtre manipulable  … 
partir  du  clavier.  Le troisiŠme indique que la  fenˆtre  doit  ˆtre 
syst‚matiquement  r‚affich‚e  dans sa totalit‚ (et pas  seulement  les 
parties cach‚es) lorsqu'elle est amen‚e au premier plan.  Le quatriŠme 
force la zone de travail de la fenˆtre a toujours ˆtre plac‚e sur  des 
pixels multiples de 16 (‚galement pour les largeur et hauteur de cette 
zone).  Les trois bits suivants sont pour l'instant inutilis‚s.  Quant 
au  bit  7,  il est utilis‚ par BIG pour savoir si la fenˆtre  est  la 
derniŠre de celles qui ont ‚t‚ d‚clar‚es. A l'initialisation : WFARROW 
seulement.
  int   w_mouse.   Si   cet  ‚l‚ment  est  ‚gal  …  z‚ro   (valeur   … 
l'initialisation),  la souris aura toujours la traditionnelle forme de 
flŠche.  Sinon,  la  valeur est interpr‚t‚e comme le num‚ro AES de  la 
forme que la souris doit prendre dans la zone de travail de la fenˆtre 
(lorsque la fenˆtre est au premier plan).
  Viennent  …  pr‚sent une s‚rie de pointeurs sur fonctions  qui  vont 
nous  permettre  de d‚terminer comment la fenˆtre va r‚agir  dans  les 
diff‚rents  cas d'‚v‚nements,  et cela automatiquement.  Nous  verrons 
plus loin comment affecter une fonction … un pointeur.
  FNCP  w_redraw Pointeur sur la routine de r‚affichage du contenu  de 
la fenˆtre.  A l'initialisation,  0L. Ce pointeur n'est n‚cessaire que 
si la fenˆtre contient autre chose qu'une image ou un formulaire,  car 
dans ces cas BIG se charge du redraw.
  FNCP w_close Pointeur sur la routine de fermeture de la  fenˆtre.  A 
l'initialisation,  il  pointe sur la fonction 'closed()' qui ferme  la 
fenˆtre et demande au GEM d'oublier son existence (mais BIG a plus  de 
m‚moire).  Toutefois,  il faudra dans certains cas que le  programmeur 
‚crive  cette fonction afin de lib‚rer si n‚cessaire la  zone  m‚moire 
occup‚e par exemple par le texte de la fenˆtre.
  FNCP  w_move  Pointeur  sur une routine qui informe le  GEM  que  la 
fenˆtre a ‚t‚ d‚plac‚e,  et qui enregistre ses nouvelles  coordonn‚es. 
Pointe … l'initialisation sur la fonction 'moved()' (ou  'move_form()' 
dans le cas d'une fenˆtre formulaire).
  FNCP  w_size  Pointeur  sur une routine qui informe le  GEM  que  la 
fenˆtre  a  ‚t‚  redimensionn‚e,   et  qui  enregistre  ses  nouvelles 
coordonn‚es.  Pointe … l'initialisation sur la fonction 'sized()'  (ou 
'size_form()'  dans le cas d'une fenˆtre formulaire).  Voyez  dans  le 
chapitre  de la visite guid‚e ce qui a ‚t‚ dit … propos de la  fenˆtre 
d'histogrammes.
  FNCP  w_full  Pointeur sur la fonction qui donne …  la  fenˆtre  ses 
dimensions maximales, ou la ramŠne aux pr‚c‚dentes si elle est d‚j… au 
maximum.  Cette taille maximum est ‚ventuellement limit‚e dans le  cas 
d'une fenˆtre image ou formulaire aux dimensions de cette image ou  de 
ce  formulaire.  Les nouvelles coordonn‚es sont transmises au  GEM.  A 
l'initialisation,  pointe sur la fonction 'fulled()' (ou  full_form()' 
dans le cas d'une fenˆtre formulaire).
  FNCP  w_hslid,  w_vslid  "Horizontal SLIDer"  et  "Vertical  SLIDer" 
Pointeurs  sur  les fonctions … ex‚cuter en cas  de  d‚placement  d'un 
slider (horizontal ou vertical) le long de l'ascenceur  correspondant. 
La fonction effectue les tests n‚cessaires,  transmet l'information au 
GEM et l'enregistre.  A l'initialisation,  pointent respectivement sur 
'hslid()' et 'vslid()'.
  FNCP w_uppage,  w_dnpage, w_lfpage, w_rtpage "UP PAGE", "DowN PAGE", 
"LeFt PAGE" et "RighT PAGE". Pointeurs sur les fonctions … ex‚cuter en 
cas  d'‚v‚nement d'ascenceur,  c'est-…-dire une demande de  d‚filement 
par page vers le haut,  le bas,  la gauche ou la droite.  La  fonction 
effectue  les  tests n‚cessaires,  transmet l'information  au  GEM  et 
l'enregistre.   A   l'initialisation,   pointent  respectivement   sur 
'uppage()',   'dnpage()',  'lfpage()'  et  'rtpage()'.  Ces  fonctions 
d‚placent  le  contenu de la fenˆtre de la hauteur ou  de  la  largeur 
(selon  le  cas)  de  la fenˆtre,  ou moins si on  est  "au  bout"  de 
l'affichage.
  FNCP w_upline,  w_dnline,  w_lfline,  rtline "UP LINE", "DowN LINE", 
"LeFt LINE" et "RighT LINE". Pointeurs sur les fonctions … ex‚cuter en 
cas d'‚v‚nement de flŠches, c'est-…-dire une demande de d‚filement par 
ligne  vers  le haut,  le bas,  la gauche ou la  droite.  La  fonction 
effectue  les  tests n‚cessaires,  transmet l'information  au  GEM  et 
l'enregistre.   A   l'initialisation,   pointent  respectivement   sur 
'upline()',   'dnline()',  'lfline()'  et  'rtline()'.  Ces  fonctions 
d‚placent  le  contenu de la fenˆtre de la hauteur ou  de  la  largeur 
(selon  le  cas)  de l'unit‚ de d‚placement  not‚  dans  les  ‚l‚ments 
'w_wunit' et 'w_hunit'.
  char  *w_title Pointeur sur la chaŒne de titre de la  fenˆtre.  0  … 
l'initialisation.
  char *w_infos Pointeur sur la chaŒne de ligne d'infos de la fenˆtre. 
0 … l'initialisation.
  long w_wtot,  w_htot "Width TOTal" et "Height TOTal".  Ces  ‚l‚ments 
contiennent  respectivement  la  largeur et la hauteur  totale  de  la 
fenˆtre,  en pixels. Pour une image, cela correspond aux dimensions de 
cette image. Pour du texte, la largeur repr‚sente le nombre maximum de 
caractŠres  d'une  ligne  multipli‚ par la largeur  d'une  cellule  de 
caractŠre.  La  hauteur  serait le nombre de lignes multipli‚  par  la 
hauteur d'une cellule de caractŠre. 0 … l'initialisation.
  long w_lin,  w_col "LIGne" et "COLonne". Repr‚sentent (en pixel) les 
premiŠres ligne et colonne … afficher dans le coin sup‚rieur gauche de 
la zone de travail de la fenˆtre, par rapport au contenu total (w_wtot 
et w_htot). 0 … l'initialisation.




















5. Les fonctions de BIG
  BIG  met ‚videmment … votre disposition des fonctions.  Du point  de 
vue  du  d‚veloppeur,  ces fonctions peuvent ˆtre  r‚parties  en  deux 
groupes : celles que le programmeur appelle … partir du logiciel qu'il 
est en train de d‚velopper,  et celles que BIG appellent "en interne". 
Dans cette documentation,  nous ne verrons en d‚tail que les fonctions 
du premier groupe.

  5.a G‚n‚ralit‚s
  5.a.1 Les ‚v‚nements
  Pour  que les fonctions de BIG communiquent avec le GEM et avec  les 
fonctions du programme principal,  de nouveaux types d'‚v‚nements sont 
utilis‚s.  Le  type d'‚v‚nement est plac‚ dans l'‚l‚ment 0  du  buffer 
d'‚v‚nement,  qui est un tableau d'entiers.  Il peut donc prendre  des 
valeurs de 0 … 65535.  GEM n'utilise qu'une trentaine de ces  valeurs, 
de sorte que les autres sont disponibles.  Certains systŠmes (comme le 
Tube  GEM)  se  r‚servent d‚j… des  types  d'‚v‚nements  ‚tendus.  Les 
nouveaux  ‚v‚nements de BIG sont bien entendus diff‚rents de tous  les 
autres  dont  j'ai  connaissance.  J'espŠre ne pas  avoir  pi‚tin‚  le 
territoire de quelqu'un d'autre...
  Dans tous les cas, ces ‚v‚nements respectent le modŠle GEM, c'est-…-
dire  le  type  dans  l'‚l‚ment  0  du  buffer,   l'identificateur  du 
destinataire dans l'‚l‚ment 1,  et 0 dans l'‚l‚ment 2, puisqu'aucun de 
ces  ‚v‚nements  ne comporte de surplus  d'information.  Les  ‚l‚ments 
suivants contiennent des informations d‚pendantes du type de message.

  BEV_HIERM (Big EVent HIERarchical Menu)
     Une  option  de  menu  hi‚rarchique  du  menu  principal  a   ‚t‚ 
     s‚lectionn‚e. Le programme re‡oit un ‚v‚nement MU_MESAG.
   Mot 0 : BEV_HIERM (50).
   Mot 3 : Num‚ro du titre du menu principal.
   Mot 4 : Num‚ro de l'option du menu principal.
   Mot 5 : Num‚ro dans le ressource de l'arbre sous-menu.
   Mot 6 : Num‚ro de l'objet cliqu‚ dans cet arbre.

  BEV_FREEPU (Big EVent FREE Pop-Up)
     Une  option  de pop-up libre a  ‚t‚  s‚lectionn‚e.  Le  programme 
     re‡oit un ‚v‚nement MU_BUTTON.
   Mot 0 : BEV_FREEPU (51).
   Mot 3 : Num‚ro de l'arbre pop-up.
   Mot 4 : Num‚ro de l'objet cliqu‚ dans cet arbre.

  BEV_WFORM (Big EVent Window FORMulaire)
     Un objet EXIT de formulaire en fenˆtre a ‚t‚ cliqu‚. Le programme 
     re‡oit un ‚v‚nement MU_BUTTON.
   Mot 0 : BEV_WFORM (52).
   Mot 3 : Index BIG de la fenˆtre formulaire.
   Mot 4 : Num‚ro de l'objet cliqu‚.

  BEV_WMENU (Big EVent Window MENU)
     Une  option de menu en fenˆtre a ‚t‚ s‚lectionn‚e.  Le  programme 
     re‡oit un ‚v‚nement MU_BUTTON.
   Mot 0 : BEV_WMENU (53).
   Mot 3 : Num‚ro du titre de menu.
   Mot 4 : Num‚ro de l'option cliqu‚e.
   Mot 5 : Index BIG de la fenˆtre contenant le menu.







  BEV_WHIER (Big EVent Window HIERarchical menu)
     Une  option  de  menu  hi‚rarchique de  menu  en  fenˆtre  a  ‚t‚ 
     s‚lectionn‚e. Le programme re‡oit un ‚v‚nement MU_BUTTON.
   Mot 0 : BEV_WHIER (54).
   Mot 3 : Num‚ro du titre de menu.
   Mot 4 : Num‚ro de l'option qui a appel‚ le sous-menu.
   Mot 5 : Num‚ro dans le ressource de l'arbre sous-menu.
   Mot 6 : Num‚ro de l'objet cliqu‚ dans cet arbre.
   Mot 7 : Index BIG de la fenˆtre contenant le menu.

  5.a.2 Le ressource int‚gr‚
  BIG  possŠde un ressource int‚gr‚ qui lui est propre.  Il n'est  pas 
incompatible  que le programme lui-mˆme ait son ressource (externe  ou 
non) et que BIG ajoute quelques arbres int‚gr‚s.  Ce ressource  inclus 
faisant partie du programme lui-mˆme, il sera quelque part en m‚moire. 
Il  suffit de savoir o— pour transmettre les adresses n‚cessaires  aux 
fonctions  qui en ont besoin.  L'utilisation par BIG de ces  ressource 
inclus  est  entiŠrement  automatis‚e.  Vous  n'avez  pas  …  vous  en 
pr‚occuper.
  Rappelons  que  BIG peut travailler de la mˆme maniŠre avec  un  RSC 
externe  et  un interne.  Reportez-vous au chapitre 8 pour  en  savoir 
plus.
  Ce  ressource inclus compte 4 formulaires et 2  alertes  libres.  Le 
premier  formulaire est la boŒte d'alerte d‚pla‡able que  j'ai  appel‚ 
"BIG Alerte" dans la d‚mo.  Le formulaire suivant contient les  ic“nes 
d'alerte  (BIG offre 9 motifs d'ic“nes au lieu des  3  habituels).  Le 
troisiŠme  contient  les  deux  flŠches de  d‚filement  des  menus  en 
fenˆtre. Le dernier contient les G_IMAGEs utilis‚es pour le dessin des 
B_RADIOs et des B_COCHEs. Quant aux alertes, la premiŠre est celle qui 
est  utilis‚e  pour signaler que le ressource (externe)  n'a  pas  ‚t‚ 
trouv‚ pour ˆtre charg‚, et la seconde informe l'utilisateur qu'il est 
impossible d'ouvrir une nouvelle fenˆtre.

  5.a.3 Les variables globales
  BIG travaille et met en place quelques variables globales,  qui sont 
donc  accessibles au programme lui-mˆme.  Leur nombre a ‚t‚ limit‚  au 
maximum,  mais toutefois certaines contraintes sont … respecter.  J'ai 
pr‚f‚r‚ proc‚der ainsi,  plut“t que d'alourdir le travail de certaines 
fonctions  par  une incessante passation de  pointeurs,  pas  toujours 
facile … suivre et … comprendre.
  Voici  une  pr‚sentation succinte de ces  variables  globales.  Nous 
verrons les d‚tails avec les fonctions.
  int ap_id Identificateur de l'application.
  char res R‚solution courante, comme Getrez.
  int handle Handle VDI de la station de travail.
  int hc Taille standard des caractŠres, de la Base Line … la Top Line 
(telle que l'attend la fonction vst_height()).  Je vous conseille trŠs 
fortement  de  n'utiliser cette variable qu'en  lecture,  sans  JAMAIS 
changer sa valeur.  En effet,  elle est utilis‚e par les fonctions  de 
dessin  d'objets  UserDef  (comme  par  exemple  les   B_RADIOs,   les 
B_GRASTRs,  etc)  pour  que les textes de ces objets  soient  toujours 
‚crit dans une taille correspondant … la r‚solution courante.
  int xd, yd, wd, hd Position et dimensions du bureau.
  int buf[8] Buffer d'‚v‚nements.
  int mx, my, mk Position de la souris et ‚tat des boutons.
  int  edit,  pos  Editable  courant,  position du  curseur  dans  cet 
‚ditable.
  int object Objet cliqu‚ lors d'un ‚v‚nement MU_BUTTON.
  int  kbd,  key,  clik  Etat  courant des  touches  d'‚tat  (Control, 
Shift...), ‚v‚nement clavier courant, nombre de clics souris.
  int wind Handle GEM de la fenˆtre cliqu‚e.
  int n_plane Nombre de plans de couleurs.
  int  *palette  Pointeur sur la sauvegarde de la palette  par  d‚faut 
(celle qui est active au lancement du programme).
  OBJECT  *adr_menu,  *adr_desk  Noms r‚serv‚s pour les  adresses  des 
formulaires Menu et Bureau du programme (inutilis‚es si  l'application 
est un accessoire, obligatoire sinon).
  FNCP  *fnc  Adresse de la zone des pointeurs de  fonction  li‚s  aux 
objets.
  Window *win Adresse de la zone des fenˆtres (structures Windows).
  Soit 25 variables globales seulement.

  5.a.4 Les d‚finitions
  Pour  faciliter  la  programmation,  BIG propose  (et  utilise)  des 
d‚finitions  (#define)  nombreuses.   En  voici  la  liste,   avec  la 
traduction mn‚monique (lorsque c'est n‚cessaire).
  FALSE,  TRUE Respectivement '0' et '1',  ils sont utilis‚s dans  les 
tests. De grands classiques.
  NOT  (!)  Plus  facilement  lisible dans un  listing  que  le  point 
d'exclamation trop ‚troit.
  BLANK (-1) TrŠs utilis‚ par BIG,  Cette valeur est souvent transmise 
…  une  fonction  pour lui indiquer qu'elle ne doit  pas  traiter  les 
choses relatives … ce paramŠtre.  Par exemple, s'il n'y a pas de champ 
‚ditable  dans un formulaire,  le paramŠtre transmis pour la  variable 
'edit' est 'BLANK'.
  ZERO (0) Plus lisible que le chiffre 0. Attention … ne pas confondre 
cette d‚finition avec 'NULL',  d‚fini par STDDEF.H, ce ne sont pas les 
mˆmes du tout.
  MAX_ALRT  (250)  "MAXimum  ALeRTe".   Taille  maximum  d'une  chaŒne 
d'alerte. En fait, c'est un peu moins que cela.
  BIT15 (0x8000) Le 15ø bit d'un int est positionn‚ dans certains cas, 
par exemple lors d'un double-clic.
  max ( (A,  B) ((A) > (B) ? (A) : (B)) ) Macro qui retourne la valeur 
la plus ‚lev‚e entre deux.
  min ( (A,  B) ((A) < (B) ? (A) : (B)) ) Macro qui retourne la valeur 
la moins ‚lev‚e entre deux.
  B_MOVE, B_SELEC, B_GRASTR, B_FRAME, B_HELP, B_EDIT, B_UNDO, B_HIERM, 
B_FNCP,  Types  ‚tendus d'objets UserDef.  Voir le  chapitre  3,  "Les 
nouveaux types d'objets".
  DLG_DESK  ( (MU_KEYBD | MU_BUTTON | MU_M1 | MU_MESAG |  MU_TIMER)  ) 
"DiaLoGue DESK"
  DLG_FORM ( (MU_KEYBD | MU_BUTTON | MU_TIMER) ) "DiaLoGue FORMulaire"
  Pour  la  gestion  des  ‚v‚nements,   deux  masques  pour  les  deux 
situations  les  plus  courantes :  gestion du  bureau  avec  menu  et 
fenˆtres, et gestion d'un formulaire seulement.
  BEV_HIERM,   BEV_FREEPU,   BEV_WFORM,   BEV_WMENU,  BEV_WHIER,  D‚j… 
mentionn‚s,  les  nouveaux types d'‚v‚nements cr‚‚s par BIG.  Voir  le 
chapitre 5.a.1.
  WATR_ALL (0x0FFF) "Window ATtRibuts ALL"
  WATR_CURR (0x0FEF) "Window ATtRibuts CURrents"
  WATR_FORM ( (NAME | CLOSER | MOVER) ). "Window ATtRibuts FORMulaire"
     Attributs GEM des fenˆtres, trois jeux souvent employ‚s.
  WTYP_NORM (1) "Window TYPe NORMal"
  WTYP_FORM (2) "Window TYPe FORMulaire"
  WTYP_PICT (3) "Window TYPe PICTure"
  WTYP_MENU (0x8000) "Window TYPe MENU"
     Type BIG des fenˆtres. Utilis‚es dans la structure Window.
  WFFULL (0x01) "Window Flag FULL". Flag pour les fenˆtres. Ce bit est 
mis  lorsque la fenˆtre a sa taille maximum.  Il est effac‚ lors  d'un 
d‚placement,  d'un  redimensionnement,  ou lorsqu'on reclique  sur  le 
bouton de pleine ouverture.
  WFARROW (0x02) "Window Flag ARROW".  Flag pour les fenˆtres. Lorsque 
ce bit est mis, la fenˆtre peut ˆtre manipul‚e … partir du clavier.
  WFREDRAW  (0x04)  "Window  Flag REDRAW".  Flag  pour  les  fenˆtres. 
Lorsque ce bit est mis, la fenˆtre est toujours redessin‚e lorsqu'elle 
passe  au premier plan,  mˆme si elle n'‚tait pas recouverte  par  une 
autre fenˆtre.
  WFBOUND  (0x08)  "Window  Flag BOUNDary.  Flag  pour  les  fenˆtres. 
Lorsque ce bit est mis,  la zone de travail d'une fenˆtre est toujours 
positionn‚e  sur des pixels multiples de 16 (lors  d'un  d‚placement), 
ainsi que ses largeur et hauteur (lors d'un redimensionnement).
  WLAST (0x0080) "Window LAST".  Flag pour les fenˆtres.  Lorsque  BIG 
initialise  les  fenˆtres que le programme va  utiliser,  la  derniŠre 
fenˆtre de la liste est rep‚r‚e par ce bit.
  WFCLOSE (0x01) "Window Formulaire CLOSE".  Il s'agit du premier  bit 
de l'ob_state ‚tendu des objets EXIT d'un formulaire en fenˆtre. Si ce 
bit est mis, la fenˆtre est ferm‚e.
  HELP (25088)
  UNDO (24832)
  ENTER (7181)
  RETURN (29197)
  BACKSPC (3592)
  DELETE (21375)
  TAB (3849)
  ARDN (20480) "ARrow DoWn"
  ARUP (18432) "ARrow UP"
  ARLF (19200) "ARrow LeFt"
  ARRT (19712) "ARrow RighT"
  CT_ARLF (29440) "ConTrol ARrow LeFt"
  CT_ARRT (29696) "ConTrol ARrow RighT"
  SH_ARDN (20530) "SHift ARrow DoWn"
  SH_ARUP (18488) "SHift ARrow UP"
  SH_ARLF (19252) "SHift ARrow LeFt"
  SH_ARRT (19766) "SHift ARrow RighT"
  ESC (283)
  CLR (18176)
  SH_CLR (18231) "SHift CLR"
     Ces d‚finitions sont relatives au clavier. Elles repr‚sentent des 
touches  ou combinaisons de touches invariables sur tous les types  de 
claviers.  Elles sont utilis‚es par BIG pour sa gestion interne,  mais 
vous en aurez certainement besoin … l'occasion.
  Il y a d'autres d‚finitions,  que BIG utilise internement. Vous n'en 
avez pas besoin.

  5.b Les fonctions programmeur
  BIG comporte en tout 102 fonctions. Je ne vais pr‚senter ici que les 
fonctions  que le programmeur doit (ou peut) appeler.  Il y en  a  39, 
parmi  lesquelles  seules 15 … 20 sont d'un  usage  trŠs  courant,  et 
seront utilis‚es dans presque tous les d‚veloppements. Les autres sont 
des  fonctions  internes.  La pr‚sentation des fonctions  respecte  le 
modŠle suivant :
  Prototypage. Le prototypage de la fonction.
  Description. Ce que r‚alise la fonction.
  ParamŠtres. La description de chaque paramŠtre et (s'il y a lieu) du 
retour de la fonction.
  Remarques.  (Eventuellement) Des remarques sur ce qui est  fait,  ce 
qui est … faire, et ce qui est … ne pas faire.

  5.b.1 Les fonctions d'initialisation
  Prototypage
int initial (char *rsc, int menu, int desk, int nb_tree,
             OBJECT *rs_tree, char *rs_str, int n_wind);
  Description Cette fonction d‚clare l'application,  ouvre la  station 
de travail,  initialise la plupart des variables globales,  charge  le 
ressource,  met en place le ressource int‚gr‚ de BIG, met en place les 
zones m‚moires pour la gestion des fenˆtres,  des objets userdef,  des 
‚ditables  ‚tendus,  les  pointeurs  sur  fonction,  r‚serve  l'espace 
m‚moire  pour  la gestion des fenˆtres par  BIG,  initialise  certains 
‚l‚ments  des  structures  Window,  adapte  la  taille  des  objet  du 
ressource s'il est int‚gr‚, etc.
  ParamŠtres
  'rsc'  est  un  pointeur sur une chaŒne qui est le  nom  du  fichier 
ressource … charger, ou une chaŒne vide en cas de ressource int‚gr‚.
  'menu'  et 'desk' sont les num‚ros d'arbres (dans le ressource)  qui 
seront pris comme menu principal et bureau de l'application. Sauf dans 
le cas d'un accessoire de bureau,  la pr‚sence de ces deux arbres  est 
obligatoire.
  'nb_tree' est ‚gal … 0 si le ressource est un fichier externe. Si le 
programme  travaille  avec un ressource int‚gr‚,  nb_tree  indique  le 
nombre d'arbres (menus et formulaires) de ce ressource.
  'rs_tree' et 'rs_str' sont deux pointeurs sp‚ciaux. Dans le cas d'un 
ressource int‚gr‚,  ils permettent d'indiquer … BIG … quel endroit  de 
la m‚moire commencent les deux tableaux 'rs_trindex[]' et 'rs_frstr[]' 
cr‚‚s  par le fichier RSH.  Sinon,  ils pointent sur  ZERO.  Voyez  au 
chapitre 8 la fa‡on de les utiliser.
  'n_wind'  Nombre total de fenˆtres BIG avec lesquelles le  programme 
va travailler.
  retour : TRUE si tout c'est bien pass‚, FALSE sinon (par exemple, le 
fichier ressource n'a pas ‚t‚ trouv‚).
  Remarques  Les  variables  'adr_menu' et  'adr_desk'  ont  des  noms 
impos‚s pour faciliter leur gestion.  En effet,  il y a de  nombreuses 
fonctions qui font appel … ces adresses,  et les transmettre …  chaque 
fois serait fastidieux et peu pratique.  Si votre programme  travaille 
avec  plusieurs barres de menu (ou mˆme  plusieurs  bureaux,  pourquoi 
pas),  l'adresse du menu courant doit ˆtre dans adr_menu.  La fonction 
centre  …  l'avance  tous  les formulaires et  vide  tous  les  champs 
‚ditables.
  On accŠde aux structures de fenˆtres (et … leurs ‚l‚ments) comme aux 
‚l‚ments d'un tableau, par win[index].w_adr par exemple.
  Il  est  fortement  recommand‚ de ne pas faire  d'‚conomie  avec  la 
quantit‚  de  fenˆtres n‚cessaires,  et de d‚clarer  une  fenˆtre  par 
‚l‚ment d'information … traiter.
  Par  exemple,  il  est d‚conseill‚ de n'avoir  qu'une  fenˆtre  pour 
afficher un texte ou une image,  sous pr‚texte que les deux ne  seront 
pas  affich‚s  en mˆme temps.  Il vaut mieux dans ce  cas  avoir  deux 
fenˆtres distinctes, les paramŠtres contenus dans leurs ‚l‚ments ‚tant 
diff‚rents. De mˆme, d‚clarez une fenˆtre par formulaire en fenˆtre.
  La  gestion  du programme en sera simplifi‚e,  quitte …  fermer  une 
fenˆtre  avant d'en ouvrir une autre si les deux ne doivent  pas  ˆtre 
affich‚es en mˆme temps.
  Une  structure  Window  de plus en m‚moire  ne  repr‚sente  que  142 
octets,  alors  qu'une  gestion  compliqu‚e  de  peu  de  fenˆtres  se 
partageant  des contenus diff‚rents risque de prendre  beaucoup  plus, 
sans parler du temps de traitement.
  Cette  fonction  doit  IMPERATIVEMENT ˆtre appel‚  par  la  fonction 
main() du programme principal dŠs le d‚but de l'ex‚cution.

  Prototypage
void end (int intgr);
  Description  Cette fonction ferme toutes les fenˆtres du  programme, 
libŠre  les  diff‚rentes  zones  m‚moires  qui  ont  ‚t‚  r‚serv‚es  … 
l'initialisation et en cours de programme,  libŠre le ressource, ferme 
la station de travail et quitte le programme.
  ParamŠtres
  'intgr' "INT‚GR‚". TRUE si le ressource est int‚gr‚, FALSE sinon.
  Remarques  Cette  fonction n'est pas appel‚e par  BIG.  C'est  votre 
programme  qui  devra se charger de cet  appel  lorsque  l'utilisateur 
demande … quitter l'application.
  Si une zone m‚moire est affect‚ au contenu d'une fenˆtre,  elle doit 
ˆtre  lib‚r‚e.  Si  la  fonction de  fermeture  affect‚e  …  l'‚l‚ment 
win[index].w_close de cette fenˆtre ne s'en charge pas, vous devrez le 
faire "… la main" AVANT d'appeler end().

  5.b.2 Les fonctions de gestion des formulaires
  Prototypage
void  formm_draw  (OBJECT  *adr,  int  ed,  int  flmove,  MFDB  *img);     
  Description "Form Move DRAW".  Cette fonction affiche un  formulaire 
d‚pla‡able.
  ParamŠtres
  'adr' Adresse de l'arbre … afficher.
  'ed' Num‚ro d'objet du champ ‚ditable dans lequel doit se trouver le 
curseur au d‚but de la gestion du formulaire.  Le curseur est plac‚  … 
la fin du champ. -1 s'il n'y en a pas.
  'flmove'  "FLag  MOVE".  Si ce flag est  FALSE,  le  d‚placement  du 
formulaire  se fait en "boŒte fant“me".  S'il est  TRUE,  la  fonction 
r‚serve  une  zone  m‚moire et y sauve l'‚cran  afin  de  r‚aliser  le 
d‚placement en temps r‚Šl.  S'il n'est pas possible de r‚server  cette 
m‚moire, le d‚placement se fait en boŒte fant“me.
  'img'  Pointeur  sur  MFDB  utilis‚ pour  sauver  le  fond  sous  le 
formulaire.
  Remarques  L'attribut  OUTLINED  de la boŒte  racine  est  mis,  les 
routines de d‚placement du formulaire tenant compte de lui dans  leurs 
calculs. Pour enlever le formulaire de l'‚cran … la fin de la gestion, 
il faut imp‚rativement utiliser la fonction formm_undraw().
    
  Prototypage
void formm_undraw (OBJECT *adr, MFDB *img);
  Description   Cette  fonction  efface  de  l'‚cran   un   formulaire 
d‚pla‡able qui a ‚t‚ affich‚ par la fonction formm_draw().
  ParamŠtres
  'adr' Adresse de l'arbre.
  'img'  Pointeur  sur  le MFDB dans lequel a ‚t‚  sauv‚  le  fond  du 
formulaire.
  Remarques Le formulaire d‚pla‡able est affich‚ imp‚rativement par la 
fonction formm_draw().
    
  Prototypage
void formf_draw (OBJECT *adr, int ed);
  Description   "FORMulaire   Fixe  DRAW".   Affiche   un   formulaire 
traditionnel, fixe.
  ParamŠtres
  'adr' Adresse de l'arbre … afficher.
  'ed' Num‚ro d'objet du champ ‚ditable o— placer le curseur au  d‚but 
de la gestion,  s'il y en a,  ou -1.  Le curseur est plac‚ … la fin du 
champ.
  Remarques   Cette  fonction  n'existe  que  pour  des   raisons   de 
compatibilit‚ et pour ˆtre complet,  mais on lui pr‚fŠrera sans  doute 
la  fonction formm_draw().  Le formulaire affich‚ avec cette  fonction 
doit ˆtre ot‚ de l'‚cran avec formf_undraw().
    
  Prototypage
void formf_undraw (OBJECT *adr);
  Description Cette fonction efface de l'‚cran un formulaire fixe  qui 
a ‚t‚ affich‚ par la fonction formf_draw().
  ParamŠtres
  'adr' Adresse de l'arbre.
  Remarques   La  fonction  doit  ˆtre  utilis‚e  en   compl‚ment   de 
formf_draw().

  Prototypage
void create_hierm (OBJECT *adr, int intgr);
  Description Cette fonction cherche les objets B_HIERMs d'un menu  et 
place  en  avant-dernier  caractŠre de la chaŒne une  flŠche  vers  la 
droite  o—  la  gauche  selon  le cot‚  o—  va  se  d‚rouler  le  menu 
hi‚rarchique.
  ParamŠtres
  'adr' Adresse de l'arbre.
  'intgr'  "INT‚GR‚".  Indique  si l'on travaille  avec  un  ressource 
int‚gr‚ (TRUE) ou non (FALSE).
  Remarques En ce qui concerne le menu principal d'une application, la 
fonction  initial()  se  charge d'appeler  cette  fonction.  Elle  est 
‚galement appel‚e automatiquement … chaque fois qu'un clic a lieu  sur 
un titre de menu en fenˆtre, car la fenˆtre a pu ˆtre d‚plac‚e, et les 
sous-menus pourraient alors devoir ˆtre d‚roul‚s de l'autre cot‚. Mais 
si  vous d‚sirez changer la barre de menu (et si la nouvelle  comporte 
des  B_HIERMs),  vous  devez appeler cette fonction  lors  du  premier 
affichage de cette barre.  Lors des r‚affichages ult‚rieurs,  ou de la 
r‚activation de la premiŠre barre, ce n'est pas n‚cessaire.
  Les  options de menu de type B_HIERM doivent ˆtre remplis  d'espaces 
sur toute leur largeur.  L'avant-dernier caractŠre est remplac‚ par la 
flŠche (Ascii 3 ou 4) plac‚ par cette fonction.
    
  Prototypage
int dialog (int flags, OBJECT *address, int f, int intgr,
            int fl_rb, int form_pu, MFDB *img, int fl_move);
  Description  Cette  fonction est le c´ur de  BIG.  C'est  la  boucle 
principale  qui  scrute les ‚v‚nements et les gŠre en  grande  partie. 
Elle  sera toujours appel‚e au moins une fois dans un  programme  sous 
BIG.
  ParamŠtres
  'flags'  C'est le masque de bits (le mˆme que pour la  fonction  GEM 
evnt_multi())  qui indique quels ‚v‚nements doivent  ˆtre  surveill‚s. 
BIG propose des d‚finitions toutes faites pour les situations les plus 
courantes (voir le chapitre 5.a.4).
  'address' Adresse du formulaire … traiter, ou du bureau.
  'f' "Flag".  Si ce flag est TRUE,  La fonction surveille le menu, le 
bureau,  les  fenˆtres,  etc.  S'il  est  FALSE,  elle  se  limite  au 
formulaire   indiqu‚  par  'address',   consid‚rant  que  les   autres 
‚v‚nements sont bloqu‚s par wind_update().
  'intgr'  "INT‚GR‚".  Indique  si l'on travaille  avec  un  ressource 
int‚gr‚ (TRUE) ou non (FALSE).
  'fl_rb' "FLag Right Button".  Si TRUE, un clic du bouton droit de la 
souris appelle un menu pop-up libre (voir paramŠtre suivant).
  'form_pu' "FORMulaire Pop-Up".  Num‚ro d'arbre du formulaire servant 
de pop-up libre en cas de clic sur le bouton droit.  -1 s'il n'y en  a 
pas.
  'img' Dans le cas d'un formulaire d‚pla‡able,  c'est un pointeur sur 
le MFDB qui contient le fond de ce formulaire.
  'fl_move'  Indique  si le formulaire est d‚pla‡able  (TRUE)  ou  non 
(FALSE). Egalement FALSE si la fonction gŠre le bureau.
  retour  :  La fonction retourne un masque de bits  correspondant  au 
type d'‚v‚nement qui s'est produit.  Ce masque est le mˆme que pour la 
fonction GEM evnt_multi().
  Remarques Voici un rappel du masque de bits utilis‚ par evnt_multi() 
et dialog().
  Bit 0 : MU_KEYBD (‚v‚nement clavier)
  Bit 1 : MU_BUTTON     (‚v‚nement clic souris)
  Bit 2 : MU_M1    (‚v‚nement zone souris 1)
  Bit 3 : MU_M2    (‚v‚nement zone souris 2)
  Bit 4 : MU_MESAG (‚v‚nement message menu ou fenˆtre)
  Bit 5 : MU_TIMER (‚v‚nement timer ‚coul‚)
    
  Prototypage
int free_popup (int posx, int posy, int form, int intgr);
  Description Cette fonction appelle un formulaire pop-up "libre",  en 
ce  sens que sa position n'est pas li‚ … la position d'un bouton  dans 
un formulaire.

  ParamŠtres
  'posx' "POSition X".  Coordonn‚e en x du centre du pop-up.  Il  sera 
‚ventuellement d‚cal‚ s'il devait sortir de l'‚cran.
  'posy' "POSition Y".  Coordonn‚e en y du centre du pop-up.  Il  sera 
‚ventuellement d‚cal‚ s'il devait sortir de l'‚cran.
  'form' Num‚ro de l'arbre servant de pop-up.
  'intgr' "INT‚GR‚". TRUE si le ressource est int‚gr‚, FALSE sinon.
  retour :  TRUE si une option a ‚t‚ choisie, FALSE si le pop-up a ‚t‚ 
quitt‚ en cliquant … c“t‚.
  Remarques  Si  un  objet  a ‚t‚ choisi,  TRUE  est  retourn‚  et  un 
‚v‚nement   est  mis  en  place  par  la  fonction  dans   le   buffer 
d'‚v‚nements.  Il  est de type 'BEV_FREEPU' ("Big EVent FREE  Pop-Up". 
Voyez sa description au chapitre 5.a.1.
  Si l'objet cliqu‚ est de type "pointeur sur fonction",  la  fonction 
est automatiquement ex‚cut‚e avant le retour de la fonction.
  Bien  que  cette fonction soit appel‚e en interne  par  la  fonction 
dialog()  (voir le paramŠtre 'fl_rb' de dialog()),  vous pouvez  avoir 
besoin de l'appeler directement dans certaines situations.
    
  Prototypage
void get_bkgr (int of_x,  int of_y,  int of_w,  int of_h,  MFDB *img);     
  Description  (GET BacKGRound).  Cette fonction sauve  l'image  d'une 
zone  dans un MFDB,  afin de la restaurer plus tard.  Elle  permet  de 
mettre "de cot‚" le fond d'un formulaire ou d'un pop-up,  par exemple. 
Ce fond sera restaur‚ par la fonction put_bkgr().
  ParamŠtres
  'of_x' "OFfset X". Coordonn‚e en x de la zone … sauvegarder.
  'of_y' "OFfset Y". Coordonn‚e en y de la zone … sauvegarder.
  'of_w' "OFfset Width". Largeur de la zone … sauvegarder.
  'of_h' "OFfset Height". Hauteur de la zone … sauvegarder.
  'img' "IMaGe". Pointeur sur le MFDB qui d‚crira la zone sauv‚e.
  Remarques Cette fonction est appel‚e en interne par BIG,  mais  vous 
pouvez  l'utiliser pour sauver des zones d'‚cran si  n‚cessaire.  Voir 
aussi la fonction put_bkgr().
    
  Prototypage
void put_bkgr (int of_x,  int of_y,  int of_w,  int of_h,  MFDB  *img)     
  Description  (PUT BacKGRound) Cette fonction restaure l'image  d'une 
zone qui a ‚t‚ sauv‚e dans un MFDB, par la fonction get_bkgr().
  ParamŠtres
  'of_x' "OFfset X". Coordonn‚e en x de la zone … restaurer.
  'of_y' "OFfset Y". Coordonn‚e en y de la zone … restaurer.
  'of_w' "OFfset Width". Largeur de la zone … restaurer.
  'of_h' "OFfset Height". Hauteur de la zone … restaurer.
  'img' "IMaGe". Pointeur sur le MFDB qui d‚crit la zone … restaurer.
  Remarques Cette fonction est appel‚e en interne par BIG,  mais  vous 
pouvez  l'utiliser pour sauver des zones d'‚cran si  n‚cessaire.  Voir 
aussi la fonction get_bkgr().
    
  Prototypage
int big_alert (int button, int number, char *str,
               int fl_alrt, int intgr);
  Description  Cette fonction appelle et gŠre une boŒte d'alerte  BIG, 
c'est-…-dire sous forme de formulaire d‚pla‡able.  L'appel et la boŒte 
d'alerte sont semblable … leurs homologues GEM. L'alerte peut contenir 
jusqu'…  5  lignes de 31 caractŠres maximum,  et trois boutons  de  20 
caractŠres maximum.
  ParamŠtres
  'button' Num‚ro du bouton par d‚faut : 1, 2 ou 3.
  'number' Num‚ro (dans le ressource) de la chaŒne libre contenant  le 
texte  de la boŒte d'alerte,  au mˆme format que pour la fonction  GEM 
form_alert().  Si cela convient mieux … la situation,  la chaŒne  peut 
ˆtre  indiqu‚e directement dans le paramŠtre  suivant.  'number'  doit 
alors ˆtre ‚gal … -1 (BLANK).
  'str' "STRing".  Si on d‚sire transmettre directement la chaŒne,  le 
paramŠtre pr‚c‚dant est -1.  'str' est alors un pointeur sur la chaŒne 
d'alerte. Indiquez sinon une chaŒne vide.
  'fl_alrt' "FLag ALeRT". Si ce flag est TRUE, l'alerte sera g‚r‚e par 
BIG,  comme  un formulaire d‚pla‡able.  S'il est FALSE,  ce  sera  une 
alerte GEM normale, appel‚e par form_alert().
  'intgr'  "INT‚GR‚".  Indique  si l'on travaille  avec  un  ressource 
int‚gr‚ (TRUE) ou non (FALSE).
  retour :  Num‚ro (1,  2 ou 3) du bouton qui a ‚t‚ cliqu‚, comme dans 
la fonction GEM.
  Remarques  BIG propose 9 ic“nes d'alerte.  Si la chaŒne comporte  un 
num‚ro  d'ic“ne de '0',  l'alerte sera sans ic“ne.  Les num‚ros 1 …  9 
correspondent aux dessins suivants :
  1 : Point d'exclamation
  2 : Point d'interrogation
  3 : Panneau Stop
  4 : Panneau Sens interdit
  5 : Main ouverte
  6 : Lettre 'i', comme Information
  7 : Bombe (pour les messages d'erreurs)
  8 : Imprimante
  9 : Disquette
    
  Prototypage
char *get_string (int number, int intgr);
  Description Cette fonction retourne un pointeur sur une chaŒne libre 
(ou alerte libre) d'une ressource, int‚gr‚ ou non.
  ParamŠtres
  'number'  Num‚ro de la chaŒne libre dans le ressource (donn‚ par  le 
fichier header cr‚‚ par l'‚diteur de ressource).
  'intgr' "INT‚GR‚".  TRUE si le ressource est int‚gr‚, FALSE s'il est 
externe.
  retour : Pointeur sur la position de la chaŒne en m‚moire.
    
  Prototypage
int parent (OBJECT *adr, int object);
  Description  Cette fonction retourne le num‚ro de l'objet-pŠre  d'un 
objet.
  ParamŠtres
  'adr' Adresse du formulaire.
  'object' num‚ro de l'objet dont on cherche le pŠre.
  retour : Num‚ro d'objet du pŠre.
    
  Prototypage
void bak_rsc (OBJECT *tree, char **bak);
  Description  "BAcKup ReSsourCe".  Cette fonction sauvegarde dans  un 
buffer "l'‚tat" d'un formulaire, c'est-…-dire les boutons s‚lectionn‚s 
ou  non,  le  texte des ‚ditables et des pop-ups,  etc,  afin  de  les 
restituer par la fonction res_rsc() si le bouton 'Annule' est cliqu‚.
  ParamŠtres
  'tree' Adresse du formulaire.
  'bak'  Pointeur  sur  un pointeur de chaŒne qui sert  de  buffer  de 
sauvegarde … la fonction. Ce buffer est une zone m‚moire r‚serv‚e … la 
taille  n‚cessaire par la fonction.  Il sera lib‚r‚ par  res_rsc()  si 
celle-ci est appel‚e, ou devra l'ˆtre par le programmeur sinon.
  Remarques   L'appel  de  cette  fonction  doit  ˆtre  fait  par   le 
programmeur  avant  de dessiner le formulaire  (par  formm_draw()  par 
exemple).  Dans  un formulaire en fenˆtre,  il faut  r‚-appeler  cette 
fonction en cas de clic sur le bouton 'Applique' afin d'enregistrer le 
nouvel  ‚tat.  N'oubliez  pas alors de faire pr‚c‚der  cet  appel  par 
'Mfree (adr_bakrsc)' (o— 'adr_bakrsc' est l'adresse du buffer), sinon, 
une  taille  ‚quivalente  serait r‚serv‚e …  chaque  fois,  sans  ˆtre 
lib‚r‚e. Voir aussi la fonction res_rsc().
    
  Prototypage
void res_rsc (OBJECT *tree, char **bak);
  Description "REStaure ReSsourCe".  Cette fonction restaure  "l'‚tat" 
d'un formulaire sauv‚ par la fonction bak_rsc().
  ParamŠtres
  'tree' Adresse du formulaire.
  'bak'  Pointeur  sur  un pointeur de chaŒne qui sert  de  buffer  de 
sauvegarde  … la fonction.  Ce buffer est une zone m‚moire qui  a  ‚t‚ 
r‚serv‚e … la bonne taille par la fonction bak_rsc().  La m‚moire  est 
lib‚r‚e par res_rsc().
  Remarques  Attention :  Si la gestion du formulaire est quitt‚e  par 
'Annule',  le  programmeur doit appeler cette fonction pour  restaurer 
l'‚tat du formulaire. La zone m‚moire est alors lib‚r‚e. Si la gestion 
est quitt‚e par 'Confirme',  c'est le programmeur qui doit se  charger 
de la lib‚ration de la zone m‚moire par :   Mfree (adr_bakrsc);
  Sinon,  la  zone m‚moire resterait allou‚e.  Voir aussi la  fonction 
bak_rsc().

  5.b.3 Les fonctions des champs ‚ditables
  Prototypage
void set_text (OBJECT *adr, int object, char *string);
  Description  Cette  fonction place un texte dans un  objet  de  type 
G_STRING,   G_BUTTON,   G_TEXT,   G_BOXTEXT,  G_FTEXT,  G_FBOXTEXT  ou 
G_USERDEF (dans ce cas, les objets BIG comportant un texte).
  ParamŠtres
  'adr' Adresse du formulaire.
  'object' num‚ro de l'objet concern‚.
  'string' Pointeur sur la chaŒne … placer dans l'objet.
  Remarques Voir la fonction get_text().
    
  Prototypage
char *get_text (OBJECT *adr, int object);
  Description  Cette fonction retourne un pointeur sur le  texte  d'un 
objet  de  type  G_STRING,   G_BUTTON,   G_TEXT,  G_BOXTEXT,  G_FTEXT, 
G_FBOXTEXT  ou G_USERDEF (dans ce cas,  les objets BIG  comportant  un 
texte).
  ParamŠtres
  'adr' Adresse du formulaire.
  'object' Num‚ro de l'objet concern‚.
  retour : Pointeur sur la position de la chaŒne en m‚moire.
  Remarques Voir la fonction set_text().

  5.b.4 Les fonctions diverses
  Prototypage
char *path (char *pat);
  Description  Cette  fonction  retourne  le  chemin  par  d‚faut   de 
l'application  (le  chemin o— chercher le ressource et le  fichier  de 
configuration, par exemple).
  ParamŠtres
  'pat'  est  un pointeur sur une chaŒne qui contiendra en  retour  le 
chemin par d‚faut. Elle doit ˆtre de taille suffisante.
  retour : Un pointeur sur la chaŒne.
  Remarques  La  fonction place le chemin dans la variable  de  retour 
'pat', et retourne en plus un pointeur sur cette chaŒne.
    
  Prototypage
int exist (char *name, int att);
  Description  Retourne 'TRUE' (1) si un fichier  particulier  existe, 
'FALSE' (0) sinon.
  ParamŠtres
  'name'  est un pointeur sur la chaŒne du nom du fichier …  chercher, 
avec  ‚ventuellement l'indication du chemin.  Les jockers '*'  et  '?' 
peuvent ˆtre utilis‚s.
  'att' est un masque de bits repr‚sentant les ATTributs du fichier  … 
chercher, selon la rŠgle GEMDOS.
  retour  :  La  fonction  retourne 'TRUE'  …  la  premiŠre  occurence 
trouv‚e, FALSE si elle n'en trouve pas.
    
  Prototypage
void set_palette (int index);
  Description Cette fonction fixe de nouvelles valeurs pour la palette 
de couleurs.
  ParamŠtres
  'index'  est l'index BIG de la fenˆtre de type  'WTYP_IMAG',  qui  a 
l'adresse  de  la  nouvelle palette dans sa  structure.  Si  '-1'  est 
transmis comme index, la palette par d‚faut est restaur‚e.
  Remarques  Vous  pouvez  appeler  directement  cette  fonction,  par 
exemple  pour  restaurer  la  palette  par  d‚faut  …  la  demande  de 
l'utilisateur.
    
  Prototypage
long timer (void);
  Description  Cette  fonction retourne la valeur du timer 200  Hz  au 
moment o— elle est appel‚e.
  ParamŠtres
  retour : Valeur du timer.
  Remarques  Cette fonction est trŠs utile pour servir par exemple  de 
compte … rebours ou pour mesurer des intervalles de temps.
    
  Prototypage
char *trim (char *str);
  Description  Cette fonction ‚limine les espaces de d‚but et  de  fin 
d'une  chaŒne.  La  chaŒne transmise est modifi‚e en  m‚moire,  et  un 
pointeur la d‚signant est retourn‚ par la fonction.
  ParamŠtres
  'str' Pointeur sur la chaŒne … traiter.
  retour : Pointeur sur la position de la chaŒne en m‚moire.
    
  Prototypage
void  send_mesag (int type,  int wi,  int x,  int y,  int w,  int  h);     
  Description  Cette  fonction permet … l'application de  s'envoyer  … 
elle-mˆme un message, de maniŠre … simuler un ‚v‚nement.
  ParamŠtres
  'type' Type de l'‚v‚nement (GEM ou BIG). Il sera plac‚ dans le mot 0 
du buffer d'‚v‚nement.
  'wi' "WIndow". Sera plac‚ dans le mot 3 du buffer. Souvent, c'est le 
handle GEM d'une fenˆtre.
  'x'  Sera  plac‚  dans  le mot  4  du  buffer.  Souvent,  c'est  une 
coordonn‚e en x.
  'y'  Sera  plac‚  dans  le mot  5  du  buffer.  Souvent,  c'est  une 
coordonn‚e en y.
  'w' Sera plac‚ dans le mot 6 du buffer.  Souvent,  c'est une largeur 
de zone.
  'h' Sera plac‚ dans le mot 7 du buffer.  Souvent,  c'est une hauteur 
de zone.
  Remarques  Il  est parfois trŠs utile de s'envoyer  …  soi-mˆme  des 
messages, pour g‚n‚rer un redraw par exemple.
    
  Prototypage
int  selector  (char  *pat,  char  *ext,  char  *file,  char  *title);     
  Description  Cette  fonction appelle et gŠre le  s‚lecteur  d'objets 
GEM.
  ParamŠtres
  'pat' "PATh".  Pointeur sur une chaŒne indiquant le chemin d'accŠs … 
ouvrir  dans  le  s‚lecteur,  sans l'extension  …  filtrer.  AprŠs  la 
fonction,  pointe  sur le chemin choisi dans le s‚lecteur  (la  chaŒne 
doit ˆtre assez longue).
  'ext'  "EXTension".  Extension  … filtrer  dans  le  s‚lecteur.  Les 
jockers '*' et '?' sont autoris‚s.
  'file'  Pointeur  sur  une  chaŒne contenant le  nom  du  fichier  … 
"pr‚s‚lectionner" dans le s‚lecteur,  ou chaŒne vide s'il n'y a pas de 
fichier par d‚faut.  AprŠs la fonction, la chaŒne (qui doit ˆtre assez 
longue) contient le nom du fichier s‚lectionn‚.
  'title' Pointeur sur la chaŒne … afficher dans le s‚lecteur d'objet, 
… partir du TOS 1.4.
  retour :  TRUE si le s‚lecteur est quitt‚ avec le bouton 'OK', FALSE 
s'il est quitt‚ avec le bouton 'Annuler'.
  Remarques  La fonction teste le num‚ro de version du TOS et  r‚alise 
un appel fsel_input() (TOS ant‚rieur … 1.4) ou fsel_exinput() (TOS 1.4 
ou plus).  Comme la fonction GEM,  selector() retourne 0 si 'Annule' a 
‚t‚ choisi.
  Si le s‚lecteur est appel‚ pour choisir un fichier, il faut tester :
if (selector (path, ext, name, title) == TRUE && strlen (name))
Afin  de v‚rifier que c'est le bouton 'OK' qui a ‚t‚ cliqu‚  et  qu'un 
nom  de  fichier a bien ‚t‚ choisi (L'utilisateur  pourrait  confirmer 
sans choisir de fichier).
  Si  le s‚lecteur est appel‚ seulement pour demander …  l'utilisateur 
un  chemin (le nom du fichier n'a pas d'importance dans  ce  cas),  il 
suffit de tester :
if (selector (path, "\*.*", name, title) == TRUE)
  La  principale diff‚rence entre cette fonction et l'appel direct  de 
la fonction GEM est que le chemin d'accŠs retourn‚ par cette  fonction 
aprŠs l'appel est d‚pouill‚ du filtre d'extension.  Par exemple,  pour 
acc‚der au fichier choisi par l'utilisateur,  il suffit de  concat‚ner 
les  deux chaŒnes par "strcat (path,  name);" pour obtenir son  chemin 
complet dans 'path'.
    
  Prototypage
void extension (char *filename, char *ext);
  Description Cette fonction impose une extension … un nom de  fichier 
ou … un chemin d'accŠs.
  ParamŠtres
  'filename' Pointeur sur le nom du fichier ou sur le chemin complet.
  'ext' "EXTension".  Pointeur sur l'extension … imposer.  L'extension 
doit ˆtre transmise avec le point.  Il est possible de transmettre une 
chaŒne vide ("") pour supprimer l'extension.
  Remarques  Cette fonction est extrˆmement pratique par exemple  pour 
ˆtre  certain  qu'un fichier sera sauv‚ avec  une  extension  pr‚cise. 
AprŠs la saisie du nom de fichier dans un s‚lecteur par l'utilisateur, 
cette  fonction  est syst‚matiquement appel‚e de  maniŠre  …  "forcer" 
l'extension du fichier (l'extension doit ˆtre transmise avec le point, 
par exemple ".DOC").
  Elle peut ‚galement ˆtre utile dans le cas d'un programme g‚rant une 
s‚rie de fichiers plac‚s dans le mˆme chemin et tous de mˆme nom, dont 
seule  l'extension change (cas typique des bases  de  donn‚es).  Avant 
chaque accŠs … un fichier, l'extension voulue est impos‚e.

  5.b.5 Les fonctions de fenˆtres
  Prototypage
void formw_draw (OBJECT *adr, int index, int title, int infos,
                 int wed, int fb, int intgr, int attr);
  Description  Cette  fonction  ouvre une  fenˆtre  formulaire,  et  y 
affiche le formulaire.
  ParamŠtres
  'adr' Adresse du formulaire.
  'index' Index BIG de la fenˆtre … ouvrir.
  'title'  Num‚ro de la chaŒne libre contenant le titre de la  fenˆtre 
(-1 s'il n'y en a pas).
  'infos'  Num‚ro  de la chaŒne libre contenant le texte de  la  ligne 
d'informations de la fenˆtre (-1 s'il n'y en a pas).
  'wed' "Window EDitable" Num‚ro d'objet du champ ‚ditable o— doit  se 
trouver le curseur au d‚but de la gestion (-1 s'il n'y en a pas).
  'fb'  "Flag  Boundary"  Ce flag force le  bit  correspondant  de  la 
structure  Window,  afin  que la zone de travail de  la  fenˆtre  soit 
toujours cal‚e sur des multiples de 16.
  'intgr' "INT‚GR‚".  TRUE si le ressource est int‚gr‚, FALSE s'il est 
externe.
  'attr' "ATTRibuts". Attributs GEM de la fenˆtre.
  Remarques La fonction recherche s'il existe un bouton de d‚placement 
de formulaire,  et le cache (HIDETREE) si elle en trouve un. Ceci pour 
le  cas  o—  un mˆme formulaire serait utilis‚  par  le  programme  en 
"normal" et en fenˆtre. Le programmeur ne doit pas oublier de rendre … 
nouveau  visible ce bouton si le formulaire doit ensuite ˆtre  affich‚ 
normalement. D'autre part, la boŒte racine est dot‚ d'une bordure d'un 
pixel vers l'ext‚rieur, et l'‚ventuel attribut OUTLINED est annul‚.
  Si  la  fenˆtre  n'a  jamais ‚t‚  ouverte,  la  fonction  centre  le 
formulaire.
  L'option  de calage sur des multiples de 16 est trŠs utile.  Il  est 
parfois  n‚cessaire  par le fait que le formulaire peut  contenir  des 
objets tram‚s (des G_BOXs par exemple).  Si le formulaire est  d‚plac‚ 
n'importe  o—  et  qu'un redraw est fait sur  une  partie  de  l'objet 
seulement,  le motif de la trame risque d'ˆtre d‚cal‚. Le calage ‚vite 
ce d‚sagr‚ment.
  La gestion de la fenˆtre par le clavier est toujours mise s'il n'y a 
pas  de champ ‚ditable,  et annul‚e sinon.  Rappelons que sous BIG  un 
formulaire en fenˆtre avec des champs ‚ditables ne doit pas ˆtre plac‚ 
dans  une fenˆtre avec ascenseurs ou case de  redimensionnement  (voir 
paragraphe 2.e).
  Si  la  fenˆtre a ‚t‚ d‚j… ouverte,  puis  referm‚e,  ses  anciennes 
coordonn‚es sont utilis‚es.
  L'‚tat  du  formulaire  est sauvegard‚ par bak_rsc()  dans  la  zone 
d‚sign‚e par l'‚l‚ment win[index].w_cont.w_form.w_bak.
  S'il  y  a d‚j… trop de fenˆtres ouvertes,  la  fonction  se  charge 
d'afficher  la boŒte d'alerte correspondante du ressource  int‚gr‚  de 
BIG.
    
  Prototypage
int open_window (int index, int type, int attr,
                 int x, int y, int w, int h,
                 int wm, int hm, int wu, int hu,
                 int fa, int fb, int fmouse,
                 FNCP redr, FNCP clos,
                 char *title, char *info,
                 long wt, long ht,
                 int fmenu, int menu, int intgr);
  Description Cette fonction cr‚e et ouvre une fenˆtre.
  ParamŠtres
  'index' Index BIG de la fenˆtre … ouvrir.
  'type' type BIG de la fenˆtre … ouvrir.
  'attr' "ATTRibuts". Attributs GEM de la fenˆtre … ouvrir.
  'x'  Position  en  x de l'angle sup‚rieur gauche  de  la  fenˆtre  … 
ouvrir.  Il s'agit de la fenˆtre elle-mˆme,  pas seulement la zone  de 
travail.
  'y'  Position  en  y de l'angle sup‚rieur gauche  de  la  fenˆtre  … 
ouvrir.  Il s'agit de la fenˆtre elle-mˆme,  pas seulement la zone  de 
travail.
  'w'  Largeur de la fenˆtre … ouvrir.  Il s'agit de la fenˆtre  elle-
mˆme, pas seulement la zone de travail.
  'h'  Hauteur de la fenˆtre … ouvrir.  Il s'agit de la fenˆtre  elle-
mˆme, pas seulement la zone de travail.
  'wm'  "Width Mini".  Largeur minimum que pourra prendre  la  fenˆtre 
durant sa gestion. Il s'agit de la fenˆtre elle-mˆme, pas seulement la 
zone de travail.
  'hm'  "Height Mini".  Hauteur minimum que pourra prendre la  fenˆtre 
durant sa gestion. Il s'agit de la fenˆtre elle-mˆme, pas seulement la 
zone de travail.
  'wu' "Width Unit". Unit‚ de d‚calage horizontale de la fenˆtre.
  'hu' "Height Unit". Unit‚ de d‚calage verticale de la fenˆtre.
  'fa'  "Flag  Arrow".  Si ce flag est TRUE,  la fenˆtre  pourra  ˆtre 
manipul‚e … partir du clavier. Elle ne le pourra pas s'il est FALSE.
  'fb'  "Flag  Boundary"  Ce flag force le  bit  correspondant  de  la 
structure  Window,  afin  que la zone de travail de  la  fenˆtre  soit 
toujours  cal‚e sur des multiples de 16.  Il n'est jamais mis dans  le 
cas d'une fenˆtre de type WTYP_IMAG. Les routines de redraw de ce type 
de  fenˆtre sont faŒtes de telle sorte que le problŠme de la trame  ne 
peut  se produire.  Relisez ce qui a ‚t‚ expliqu‚ … ce propos dans  la 
pr‚sentation de la fonction formw_draw().
  'fmouse' "Flag MOUSE".  C'est l'index de forme que le curseur de  la 
souris  prendra  lorsqu'il sera amen‚ dans la zone de  travail  de  la 
fenˆtre   (voir  fonction  GEM  graf_mouse()).   0  pour   garder   la 
traditionnelle forme de flŠche.
  'redr'  Pointeur  sur la fonction a ex‚cuter en cas  de  message  de 
redraw sur une partie de cette fenˆtre.
  'clos'  Pointeur  sur la fonction a ex‚cuter en cas  de  message  de 
fermeture de la fenˆtre.
  'title'  Pointeur sur la chaŒne du titre de la  fenˆtre,  ou  chaŒne 
vide s'il n'y en a pas.
  'info' Pointeur sur la chaŒne de la ligne d'infos de la fenˆtre,  ou 
chaŒne vide s'il n'y en a pas.
  'wt'  "Width  Totale".  Largeur maximum totale  de  la  fenˆtre,  en 
pixels.
  'ht'  "Height  Totale".  Hauteur maximum totale de  la  fenˆtre,  en 
pixels.
  'fmenu'  "Flag MENU".True si la fenˆtre doit comporter une barre  de 
menu, FALSE sinon. Voir le paramŠtre suivant.
  'menu' Num‚ro de l'arbre qui est le menu de la fenˆtre,  -1 s'il n'y 
en pas.
  'intgr'  "INT‚GR‚".  TRUE si on travail avec un  ressource  int‚gr‚, 
FALSE sinon.
  retour  :  TRUE  si la fenˆtre a ‚t‚ correctement cr‚e  et  ouverte, 
FALSE en cas de problŠme (trop de fenˆtres ouvertes).
  Remarques  C'est  la  fonction BIG la plus  "lourde",  avec  ses  23 
paramŠtres.  Si la fenˆtre n'a jamais ‚t‚ ouverte,  les ‚l‚ments de sa 
structure  sont initialis‚s avec des valeurs par d‚faut  ou  contenues 
dans  les paramŠtres qui sont transmis.  Si elle a d‚j…  ‚t‚  ouverte, 
puis referm‚e,  les valeurs de certains ‚l‚ments sont "rafraŒchis"  au 
moyen  des  nouveaux  paramŠtres.   Si  elle  est  d‚j…  ouverte,   le 
rafraŒchissement est fait, puis elle est amen‚e au premier plan.
  Voyez  ce  qui a ‚t‚ dit pour la fonction formw_draw() …  propos  du 
calage de la fenˆtre sur des multiples de 16.
  Le paramŠtre 'redr' doit ˆtre 0 si la fenˆtre est de type WTYP_IMAG, 
car   dans  ce  cas  les  routines  de  BIG  se  chargent  du   redraw 
automatiquement  (voir  la fonction print_page()).  Dans le  cas  d'un 
autre contenu (texte,  graphique calcul‚,  etc),  le programmeur  doit 
‚crire la routine de dessin et l'indiquer par ce paramŠtre.
  Le  paramŠtre  'clos' indique la fonction … ex‚cuter  au  moment  de 
fermer la fenˆtre.  Cette fonction ne peut pas se contenter de  fermer 
et de d‚truire la fenˆtre,  elle doit aussi lib‚rer les zones m‚moires 
r‚serv‚es s'il y en a (voir la fonction closed()).
  S'il  y  a d‚j… trop de fenˆtres ouvertes,  la  fonction  se  charge 
d'afficher  la boŒte d'alerte correspondante du ressource  int‚gr‚  de 
BIG.
    
  Prototypage
int find_index (int wh);
  Description  Cette  fonction  cherche l'index BIG  d'une  fenˆtre  a 
partir de son handle GEM.
  ParamŠtres
  'wh'  "Window Handle".  Handle GEM de la fenˆtre  concern‚e.  Si  on 
transmet '-1', la fonction cherche le premier index BIG disponible.
  retour :  La fonction retourne l'index BIG de la fenˆtre,  ou -1  si 
aucune correspondance n'est trouv‚e.
  Remarques En transmettant '-1' (BLANK) comme paramŠtre,  on  obtient 
en retour le premier index BIG libre, c'est-…-dire la premiŠre fenˆtre 
n'ayant  encore jamais ‚t‚ ouverte,  ou '-1' s'il elles  l'ont  toutes 
‚t‚. Cette possibilit‚ est en principe inutile.
    
  Prototypage
int find_window (int mx, int my);
  Description  Cette  fonction  cherche si la zone  de  travail  d'une 
fenˆtre se trouve … une position donn‚e.
  ParamŠtres
  'mx' "Mouse X". Coordonn‚e en x de la position donn‚e.
  'my' "Mouse Y". Coordonn‚e en y de la position donn‚e.
  retour :  Handle GEM de la fenˆtre dont la zone de travail passe par 
ce point, FALSE s'il n'y en a pas.
  Remarques Attention, la fonction retourne le handle GEM, pas l'index 
BIG.
    
  Prototypage
void  zone_work (int index,  int *xw,  int *yw,  int  *ww,  int  *hw);     
  Description  Cette  fonction calcule les coordonn‚es de la  zone  de 
travail d'une fenˆtre, quels que soient ses attributs.
  ParamŠtres
  'index' Index BIG de la fenˆtre.
  'xw',  'yw',  'ww',  'hw'  Variables  de  retour  :  coordonn‚es  et 
dimensions de la zone de travail de la fenˆtre.
  Remarques Si la fenˆtre possŠde un menu d‚roulant,  les  coordonn‚es 
retourn‚es ne repr‚sente que la zone de travail proprement dite,  sans 
le  menu.  Sous  BIG,  il  est  conseill‚  d'utiliser  cette  fonction 
syst‚matiquement, plut“t que la fonction GEM 'wind_get (WF_WORKXYWH)', 
qui ne tiendrait pas compte d'un menu de fenˆtre.
    
  Prototypage
void height_sliders (int index);
  Description  Cette  fonction calcule et fixe les  positions  et  les 
tailles des sliders d'une fenˆtre.
  ParamŠtres
  'index' Index BIG de la fenˆtre … traiter.
    
  Prototypage
void draw_object (int object, int index);
  Description Dessine un objet faisant partie d'un formulaire ou  d'un 
menu en fenˆtre en ne dessinant que la partie visible.
  ParamŠtres
  'object' Num‚ro de l'objet … dessiner.
  'index' Index BIG de la fenˆtre qui contient le formulaire.
  Remarques   Cette   fonction  s'utilise  comme   la   fonction   GEM 
objc_draw(), mais uniquement pour les formulaires ou menus en fenˆtre. 
Elle   permet   de  dessiner  un  ou  plusieurs  objet(s)   qui   sont 
partiellement hors de la fenˆtre ou de l'‚cran, ou qui sont recouverts 
par une autre fenˆtre.
    
  Prototypage
void print_page (int index);
  Description  Cette fonction affiche le contenu entier d'une  fenˆtre 
en tenant compte des parties recouvertes par d'autres fenˆtres, etc.
  ParamŠtres
  'index' Index BIG de la fenˆtre concern‚e.
  Remarques Si la fenˆtre contient un formulaire,  il est redessin‚ au 
moyen des fonctions GEM.  Si c'est une image,  La fonction vro_cpyfm() 
est  utilis‚e  si  une image est  effectivement  stock‚e  …  l'adresse 
indiqu‚e par win[index].w_cont.w_img.w_blk (la copie est d‚cal‚e si la 
fenˆtre possŠde en plus un menu). Sinon, la fenˆtre est "vid‚e" par un 
rectangle blanc.  Dans les autres cas,  la fonction appelle la routine 
d'affichage indiqu‚e par le pointeur sur fonction win[index].w_redraw. 
Enfin, le menu de la fenˆtre (s'il y en a un) est affich‚.
  Cette fonction ne g‚nŠre pas de message de redraw  artificiel,  elle 
demande directement la liste des rectangles de cette fenˆtre (qui  est 
en permanence disponible, il suffit de la demander au GEM). Il ne faut 
l'appeler  que  si un message de redraw n'est  PAS  envoy‚,  sinon  la 
fenˆtre serait dessin‚e deux fois.
    
  Prototypage
void closed (void);
  Description Cette fonction ferme une fenˆtre et la d‚truit du  point 
de vue du GEM.
  Remarques  L'‚l‚ment win[index].w_hg de la structure Window est  mis 
… 0 pour indiquer que la fenˆtre … d‚j… ‚t‚ ouverte, mais qu'elle est 
actuellement ferm‚e.
  Si la fenˆtre contenait un formulaire, La zone m‚moire r‚serv‚e pour 
la sauvegarde de son ‚tat est lib‚r‚e.  Si elle poss‚dait un menu,  la 
zone m‚moire r‚serv‚e pour la construction de ce menu est lib‚r‚e.
  Cette  fonction  cherche  dans  le  mot  3  du  buffer  d'‚v‚nements 
(variable  globale 'buf[]') le handle GEM de la fenˆtre …  fermer,  ce 
qui explique qu'aucun paramŠtre ne lui soit transmis.
  Toutefois,  Si vous avez une fenˆtre contenant du texte par exemple, 
vous  devrez sans doute cr‚er une fonction de fermeture de fenˆtre  et 
l'affecter comme pointeur sur fonction … l'‚l‚ment  win[index].w_close 
de la structure Window, afin que votre fonction libŠre la zone m‚moire 
r‚serv‚e pour le texte.  Le plus simple est que votre fonction appelle 
elle-mˆme  la  fonction closed(),  mais vous devrez  avant  cet  appel 
mettre  le  handle  GEM  de  la  fenˆtre  dans  le  mot  3  du  buffer 
d'‚v‚nements par :
  buf[3] = win[index].w_hg;
  closed();
    
  Prototypage
void fulled (void);
  Description  Cette  fonction met la fenˆtre en pleine taille  ou  la 
ramŠne … sa taille pr‚c‚dente.
  Remarques  La fonction cherche dans le mot 3 du buffer  d'‚v‚nements 
(buf[3]) le handle GEM de la fenˆtre … traiter.  Elle tient compte  de 
l'‚ventuel flag de calage sur des multiples de 16 pixels et met … jour 
le bit WFFULL.
  Pour le retour … la taille pr‚c‚dente,  elle utilise la fonction GEM 
wind_get() avec le paramŠtre ' WF_PREVXYWH '.  Toutefois, sous BIG, si 
une fenˆtre est aggrandie … sa taille maximale, puis qu'on passe … une 
autre  en  utilisant le raccourci clavier <Control +  Tab>,  et  qu'on 
revient sur la premiŠre, le GEM a "oubli‚" ses dimensions ant‚rieures.
  Il  est commode d'appeler cette fonction … partir d'une fonction  de 
pleine taille sp‚cialement ‚crite pour une fenˆtre en particulier.
    
  Prototypage
void sized (void);
  Description Cette fonction redimensionne une fenˆtre.
  Remarques  La fonction cherche dans le mot 3 du buffer  d'‚v‚nements 
(buf[3]) le handle GEM de la fenˆtre … traiter.  Elle tient compte  de 
l'‚ventuel flag de calage sur des multiples de 16 pixels et annule  le 
bit WFFULL.
  Il  est commode d'appeler cette fonction … partir d'une fonction  de 
redimensionnement sp‚cialement ‚crite pour une fenˆtre en particulier.
    
  Prototypage
void moved (void);
  Description Cette fonction d‚place une fenˆtre.
  Remarques  La fonction cherche dans le mot 3 du buffer  d'‚v‚nements 
(buf[3]) le handle GEM de la fenˆtre … traiter.  Elle tient compte  de 
l'‚ventuel flag de calage sur des multiples de 16 pixels et annule  le 
bit WFFULL.
  Il  est commode d'appeler cette fonction … partir d'une fonction  de 
d‚placement sp‚cialement ‚crite pour une fenˆtre en particulier.


















































6. Le source de BIGdemo
  Mˆme  s'il  n'est  pas  trŠs  compliqu‚  en  soit,   le  concept  de 
programmation sous BIG doit sans doute paraŒtre un peu confus …  celui 
qui  l'aborde  pour  la premiŠre fois.  Si vous avez  lu  la  pr‚sente 
documentation  jusque l…,  vous savez en principe tout ce qu'il y a  … 
savoir pour commencer … travailler. Pourtant, il est probable que dans 
la pratique ce ne soit pas aussi clair !
  Nous allons aborder l'‚tude du source de la d‚mo.  Je vous conseille 
de  l'‚tudier attentivement,  il contient sans doute la r‚ponse  …  la 
plupart de vos questions. Pour celles qui resteraient sans r‚ponse, ou 
s'il subsiste des doutes, n'h‚sitez pas … me contacter.
  Il serait fastidieux d'examiner toutes les lignes du source une  par 
une, nous nous contenterons de d‚tailler les parties relatives … BIG.

  6.a Le ressource
  Comme  nous  l'avons  d‚j… fait  remarqu‚,  une  grande  partie  des 
informations  et  de  la  structure du programme  se  trouve  dans  le 
ressource. Jetons-lui donc un coup d'oeil.
* Le premier arbre est celui du menu.  Les options "BIGdemo /  Infos", 
"Formulaires  / Formulaire libre",  "Fenˆtres / Petit  formulaire"  et 
"Fenˆtres / Grand formulaire" sont de type pointeur sur fonction.  Une 
fonction  doit donc leur ˆtre associ‚e.  Nous n'avons rien  d'autre  … 
faire que d'indiquer le type B_FNCP (51) comme type ‚tendu.
  L'option   "Fenˆtre  /  Fenˆtre  normale"  doit  appeler   un   menu 
hi‚rarchique. Nous pla‡ons une petite flŠche … droite de l'option (BIG 
remplace l'avant-dernier caractŠre par une flŠche vers la droite ou la 
gauche),  et surtout nous signalons le type B_HIERM (41), ainsi que le 
num‚ro  du formulaire associ‚ dans l'octet haut de  l'ob_state  ‚tendu 
(la num‚rotation des formulaires commence … z‚ro).
* Le bureau n'appelle pas de commentaire particulier. La boŒte de fond 
sera redimensionn‚e par BIG en fonction de la taille du bureau dans la 
r‚solution  courante.  Les autres objets ne possŠdent  aucun  attribut 
particulier.  BIG  traite  le bureau un peu  diff‚remment  des  autres 
formulaires,  et informe le programme de tout ce qui s'y passe.  C'est 
le programme qui doit agir en cons‚quence.  Mais les objets du  bureau 
ne doivent poss‚der AUCUN flag EXIT, TOUCHEXIT, etc.
* Le  formulaire  principal de la d‚mo est plus  complexe.  La  chaŒne 
graphique  porte  le  type  ‚tendu  B_GRASTR  (19)  et  les  attributs 
graphiques dans l'ob_state. De mˆme pour les deux cadres B_FRAME (20). 
Les  radio-boutons  sont  de  type B_SELEC  (18)  avec  les  attributs 
obligatoires   SELECTABLE  et  RBUTTON.   Les  boutons   coch‚s   sont 
identiques,  sans  ˆtre  RBUTTON.  Nous indiquons pour chacun  de  ces 
boutons le caractŠre d'‚quivalent clavier en le faisant pr‚c‚der  d'un 
'['.  BIG  se chargera du reste,  mais nous devons nous assurer  qu'un 
caractŠre  n'est  pas utilis‚ deux fois dans le  mˆme  formulaire.  Le 
bouton d'alerte est un pointeur sur fonction. Pla‡ons le type B_FNCP.
  Les  deux  pop-ups  n'ont  pas  de  type  ‚tendu,   mais  ils   sont 
obligatoirement  SELECTABLE  et  SHADOWED.   De  plus,  le  num‚ro  du 
formulaire associ‚ est plac‚ dans l'octet haut de l'ob_state. La rŠgle 
sous GEM est de donner l'attribut SHADOWED aux boutons pop-up, afin de 
les distinguer plus facilement.  C'est une obligation sous  BIG.  Mais 
comme  cet  attribut n'a aucune cons‚quence visuelle sur un  objet  de 
type G_IMAGE,  j'ai avons plac‚ cet objet dans une G_BOX SHADOWED pour 
respecter la tradition. Je vous conseille de faire toujours ainsi dans 
le cas de pop-up image.
  Le  premier  des  deux champs ‚ditables est  de  type  B_EDIT.  Nous 
pla‡ons  donc  dans l'ob_state la longueur (en  caractŠres)  du  texte 
qu'il va pouvoir accueillir (50,  vous pouvez la changer).  N'oublions 
pas  les petites flŠches de part et d'autre,  ni les espaces  qui  les 
accompagnent (voir le chapitre 3.e).
  Le  bouton  de  d‚placement du formulaire est  plac‚  dans  le  coin 
sup‚rieur droit.  C'est une G_IBOX OUTLINED,  CROSSED et TOUCHEXIT  de 
type ‚tendu B_MOVE (17).
  Le bouton 'Confirme' sera le bouton par d‚faut.  'Annule' doit  ˆtre 
activ‚  par la touche <Undo>,  donnons-lui donc le type ‚tendu  B_UNDO 
(31).  Nous pla‡ons ‚galement un bouton d'aide qui sera activ‚ par  la 
touche  <Help>,  sous la forme d'une G_BOXTEXT OUTLINED,  SHADOWED  en 
petit texte,  de type B_HELP (21),  et le num‚ro du formulaire  d'aide 
associ‚ dans l'ob_state ‚tendu du bouton.
* Nous trouvons ensuite les deux formulaires pop-up texte utilis‚s par 
la  d‚mo.  Les options sont des G_STRINGs qui peuvent  ˆtre  DISABLED. 
Nous  les  faisons pr‚c‚der par deux espaces pour faire plus  joli  et 
pour une ‚ventuelle check-mark.  La surface entiŠre de la boŒte racine 
doit  ˆtre  recouverte.   Cette  boŒte  est  SHADOWED,  toujours  pour 
respecter les normes. Il est interdit de placer un B_FNCP dans un pop-
up.
* La  boŒte  d'information n'a rien de  particulier,  sauf  un  bouton 
B_HELP.  L'image est adapt‚e … la haute r‚solution et sera d‚form‚e en 
couleur,  ce qui n'est pas bien grave pour la d‚mo.  Je n'ai pas voulu 
compliquer les choses.
* Le formulaire suivant est une aide. Nous y trouvons un B_GRASTR, des 
B_FRAMEs, et un bouton de sortie dont la pr‚sence est obligatoire avec 
les attributs EXIT, SELECTABLE et DEFAULT.
* Nous arrivons au petit formulaire en fenˆtre.  Seule nouveaut‚,  les 
boutons 'Confirme' et 'Annule' doivent fermer la fenˆtre.  Nous devons 
pour  cela positionner le premier bit de l'octet haut  de  l'ob_state. 
Les boutons 'Applique ' et 'R.A.Z.' seront respectivement activ‚s  par 
les  touches <Return> et <Undo>,  mais sans fermer  la  fenˆtre.  Vous 
pouvez faire l'exp‚rience d'oter le bit de fermeture des deux premiers 
pour les placer dans les deux autres.
* Le grand formulaire ne pr‚sente rien de nouveau.
* L'arbre suivant est le menu de fenˆtre. Dans l'‚diteur de ressource, 
nous  le  cr‚ons  comme  un menu ordinaire.  BIG  se  chargera  de  le 
"fenˆtriser".  L'option  'Infos' est un B_FNCP.  L'option 'Icones'  du 
menu  'Alertes' est une B_HIERM.  L'octet haut de son ob_state  re‡oit 
donc le num‚ro du formulaire associ‚ : 15 dans ce cas.
* Voici  ensuite le menu hi‚rarchique du menu principal.  Il est  cr‚‚ 
comme un pop-up ordinaire,  mais on peut y placer n'importe quel  type 
d'objet,  ou  un  m‚lange  de plusieurs  types.  A  part  cela,  mˆmes 
remarques.  Dans  le cas de la d‚mo,  les 2 premiŠres options sont  de 
type B_FNCP, pas la troisiŠme.
* Nous  arrivons au pop-up image.  Il est constitu‚ de  G_IMAGEs.  Les 
mˆmes remarques que pour les pop-ups texte s'appliquent ici.
* L'arbre  suivant est le pop-up libre,  en tout point semblable …  un 
pop-up texte appel‚ par un bouton de formulaire, mais il peut poss‚der 
des B_FNCPs (c'est le cas dans la d‚mo).
* Le formulaire d'aide "CONTACT" a une particularit‚ :  il ne comporte 
pas  de  bouton  de  sortie.   Pourtant,   nous  avons  vu  que  c'est 
obligatoire ! En fait, une G_IBOX EXIT DEFAULT sans cadre recouvre toute la 
surface  du  formulaire.  Ainsi,  on peut cliquer  n'importe  o—  pour 
sortir.
* Un autre formulaire d'aide vient alors.
* Nous arrivons enfin au dernier formulaire :  le menu hi‚rarchique du 
menu  en fenˆtre.  Seules les deux premiŠres options sont  "normales", 
les autres ‚tant des B_FNCPs.
* Viennent  ensuite les chaŒnes libres,  la premiŠre est en  fait  une 
alerte. Elle peut ˆtre constitu‚e de 5 lignes de 31 caractŠres chacune 
(le  premier ‚tant g‚n‚ralement un espace,  il en reste 30),  et de  3 
boutons  de  20 caractŠres chacun.  9 dessins d'ic“nes  sont  …  votre 
disposition  (Voir  la  description de  la  fonction  big_alerte()  au 
chapitre 5.b.2).
* L'alerte   suivante  est  celle  qui  est  affich‚e  par   le   menu 
hi‚rarchique de la fenˆtre avec … chaque fois une ic“ne diff‚rente, et 
la  troisiŠme est celle appel‚e par le bouton 'Alerte'  du  formulaire 
principal.
* Les  chaŒnes  suivantes sont dans l'ordre les  titres  des  fenˆtres 
'Petit  formulaire'  et 'Grand formulaire',  les textes  de  s‚lecteur 
d'objet  'Charger  texte'  et 'Charger image',  Les  titres  des  deux 
fenˆtres correspondantes,  le titre de la fenˆtre avec menu,  celui de 
la  fenˆtre  d'histogrammes  et  sa  ligne  d'informations.   Il   est 
recommand‚,  surtout sous BIG,  de placer TOUS les textes utilis‚s par 
l'application dans le ressource.  PremiŠre raison :  c'est du pur GEM. 
Seconde raison :  dans le cas d'un ressource externe,  cela rend  plus 
facile  la  modification  (pour une traduction  ou  un  changement  de 
raccourcis  clavier  par exemple) puisqu'il n'est  pas  n‚cessaire  de 
recompiler le source.  De plus, (surtout si le ressource est int‚gr‚), 
cela homog‚nise la fa‡on de traiter ces chaŒnes.
  Nous avons fait le tour du ressource de la d‚mo.  Comme vous  l'avez 
vu,  beaucoup  de  choses  y  figurent,  non  seulement  l'aspect  des 
formulaires et des objets, mais aussi une bonne partie de la structure 
du  programme,  grƒce  aux pointeurs sur fonctions et aux  pop-ups  et 
aides associ‚s.

  6.b Le source
  J'ai   essay‚  de  r‚aliser  une  d‚mo   complŠte,   pr‚sentant   la 
programmation de tous les aspects de BIG.  Ainsi,  certains appels  de 
fonctions se font par B_FNCP et d'autres non,  afin de montrer comment 
traiter les ‚v‚nements BIG et d'autres points.  S'il s'‚tait agit d'un 
programme "normal", certaines parties auraient ‚t‚ trait‚es de maniŠre 
encore  plus simple.  Cette d‚mo,  comme son nom  l'indique,  est  une 
d‚monstration  non  seulement de ce que BIG peut r‚aliser  comme  type 
d'interface, mais aussi de comment programmer tous les d‚tails de BIG. 
Le source aurait pu ˆtre encore plus court !
  La   premiŠre  ligne  " #include  <big.h> "   est   particuliŠrement 
importante,  c'est elle qui ouvre la porte … BIG.  Vous noterez que la 
d‚mo  n'utilise  aucune  variable  globale.   La  programmation  d'une 
interface  sous BIG ne n‚cessite normalement aucune autre globale  que 
celles qui sont d‚finies par BIG.H.
  Ensuite,  nous signalons au compilateur que nous travaillons avec un 
ressource externe,  au moyen de la d‚finition 'INTGR'.  Suivent  alors 
des instructions destin‚es au pr‚processeur afin que le programme soit 
correctement compil‚.  Vous pouvez faire l'exp‚rience de recompiler la 
d‚mo  en  rempla‡ant le '0' par '1' dans la ligne "#define  INTGR  0", 
elle  fonctionnera  d‚sormais  avec un ressource  int‚gr‚  sans  autre 
modification.
  Nous  d‚finissons le nombre de fenˆtres avec lesquelles nous  allons 
travailler (6),  et  nous  leur  d‚finissons …  chacune  un  nom,  par 
commodit‚.

  6.b.1 La fonction main()
  Le premier appel du programme est la fonction initial().  Sous  BIG, 
il  faut TOUJOURS commencer par cela.  Par cette  simple  ligne,  nous 
chargeons  le ressource (externe),  nous mettons en place  les  objets 
USERDEFs,  le tableau des structures de fenˆtres,  celui des pointeurs 
sur fonction, Nous imposons le bureau de l'application et son menu, et 
nous  initialisons  les  principales  variables  globales,  ainsi  que 
certains ‚l‚ments des structures de fenˆtres … des valeurs par d‚faut. 
A  elle  seule,  cette fonction fait gagner de  nombreuses  lignes  de 
programme (et pas mal de temps).
  La  d‚mo  utilise  22  objets  B_FNCPs.  Nous  devons  "relier"  les 
fonctions aux objets correspondants,  ce qui est fait par la s‚rie  de 
lignes  qui  suit.  La  ligne "fnc[0] =  (void  *)  aff_infos;"  relie 
l'option du menu principal 'Infos' (qui est le premier objet B_FNCP du 
ressource)  … la fonction aff_infos().  Les lignes suivantes  font  la 
mˆme  chose,  mais vous remarquerez qu'il faut absolument traiter  les 
objets  dans  l'ordre  o—  ils sont  dans  le  ressource  (revoyez  le 
chapitre 3.b).  Il faut bien entendu que les diff‚rentes fonctions ait 
‚t‚ correctement prototyp‚es. Il faut les affecter dans cet ordre, car 
c'est  ainsi  que  la fonction initial() place dans  l'octet  haut  de 
l'ob_state de chaque B_FNCP l'index de tableau.  Je rappelle que  cela 
implique qu'il ne peut y avoir plus de 256 pointeurs sur fonction  par 
application.   Cette  "limite"  ne  devrait  pas  poser  de  problŠmes 
particuliers.
  Vous noterez ‚galement qu'une mˆme fonction peut ˆtre affect‚e … des 
objets  diff‚rents.   La  fonction  aff_infos()  est  reli‚e  aussi  … 
l'‚l‚ment 5 du tableau.
  Nous pouvons aprŠs cela aborder directement la boucle principale  du 
programme,  tout  est  d‚j…  prˆt !  Il  s'agit  d'une  grande  boucle 
'do...while' dont la ligne la plus importante est :
  evnt = dialog (DLG_DESK, adr_desk, TRUE, INTGR,
                 TRUE, PU_LIBRE, &img, FALSE);
  Cet  appel de la fonction dialog() r‚alise une quantit‚  de  choses. 
Examinons les paramŠtres transmis.
  'DLG_DESK'  C'est  un masque de bits d‚fini par  BIG.H.  Il  signale 
qu'il  faut scruter un bureau.  Seront donc surveill‚s  :  le  clavier 
(pour  la gestion des raccourcis clavier et des fenˆtres  manipulables 
au clavier), les clics souris (pour l'ic“ne et les textes), la zone o— 
se trouve la souris (pour les changements de forme dans les fenˆtres), 
les  messages  (pour  le menu et les  fenˆtres),  et  le  timer,  pour 
reprendre la main … tout moment et pour les menus hi‚rarchiques.
  'adr_desk' est l'adresse du formulaire … traiter,  le bureau dans ce 
cas.
  'TRUE'  Ce  flag signale … la fonction que nous travaillons  sur  un 
bureau.  La  fonction r‚agit de maniŠre un peu diff‚rente dans le  cas 
d'un bureau (par rapport … un formulaire).  Elle retourne au programme 
principal tous les ‚v‚nements de clic qui se produisent sur le bureau, 
afin  que  le  programmeur puisse cr‚er un  bureau  correspondant  aux 
besoins de son application.
  'INTGR'  Ce  flag  indique si nous  travaillons  avec  un  ressource 
int‚gr‚  ou non.  Ceci pour indiquer … BIG de quelle maniŠre  il  doit 
chercher  les  adresses d'arbres (pop-up,  aide,  etc) ou  de  chaŒnes 
libres.
  'TRUE' Oui, un clic sur le bouton droit de la souris doit appeler un 
"pop-up libre".
  'PU_LIBRE' C'est le num‚ro d'arbre (dans le ressource) du formulaire 
pop-up libre.
  '&img' Inutilis‚ dans le cas du bureau, ce serait un pointeur sur le 
MFDB d‚crivant le fond du formulaire.
  'FALSE' Egalement inutilis‚ ici (doit ˆtre FALSE),  c'est le flag de 
d‚placement du formulaire.
  La  fonction  traite ensuite les ‚v‚nements re‡us  en  retour.  Elle 
commence  par  les ‚v‚nements MU_MESAG.  Le premier  type  trait‚  est 
MN_SELECTED,  ‚v‚nement de menu. Trois options seulement sont trait‚es 
ici ('Big Alerte',  'Quitter' et 'Fenˆtre menu'), les autres ‚tant des 
B_FNCPs,  la fonction dialog() fait le n‚cessaire pour que la fonction 
correspondante  soit  ex‚cut‚e.  Je vous conseille de ne  pas  traiter 
l'option 'Quitter' d'une application par pointeur,  mais de revenir  … 
la boucle principale pour sortir. C'est plus lisible et plus logique.
  Ensuite  sont  trait‚s les ‚v‚nements de menu hi‚rarchique  du  menu 
principal, qui sont d'un type propre … BIG. Comme dans la d‚mo, il n'y 
a qu'une option de ce menu hi‚rarchique qui ne soit pas un B_FNCP,  il 
n'y  a  pas d'autres tests …  faire.  Sinon,  il  faudrait  ‚videmment 
chercher de quelle option il s'agit.
  Nous traitons ensuite les ‚v‚nements MU_BUTTON. Mais comme plusieurs 
types  d'‚v‚nements BIG sont … base de MU_BUTTON,  il faut  d‚tailler. 
Nous  commen‡ons  par  les ‚v‚nements de  pop-up  libre  (BEV_FREEPU). 
Seules les options 'Big alerte' et 'Fenˆtre menu' sont … examiner, les 
autres ‚tant des B_FNCPs.
  Nous examinons ensuite les MU_BUTTON / BEV_WFORM,  c'est-…-dire  les 
formulaires  en  fenˆtre.  Si  un  clic  a eu  lieu  dans  un  de  ces 
formulaires, le message arrive ici. Nous traitons s‚paremment le petit 
et  le  grand formulaire en fenˆtre,  en ne  nous  int‚ressant  qu'aux 
boutons EXIT,  les autres (pop-up,  s‚lectables,  radio-boutons,  etc) 
‚tant g‚r‚s par dialog().
  Nous n'avons pas grand-chose … faire. Si le bouton est 'Confirme' ou 
'Applique',  nous  lib‚rons  la  m‚moire de sauvegarde  de  l'‚tat  du 
formulaire,  et  nous  enregistrons le nouvel ‚tat.  Dans  le  cas  de 
'Confirme',  dialog()  a d‚j… fait le n‚cessaire pour que  la  fenˆtre 
soit   ferm‚e.   Nous  devons  aussi  appeler  la  fonction  de   d‚mo 
objets_desk()  (pour  le grand formulaire) ou  trame_desk()  (pour  le 
petit).  Si  le bouton est 'Annule' ou 'RAZ',  nous restaurons  l'‚tat 
ant‚rieur,  la m‚moire est automatiquement lib‚r‚e. Mˆme remarque pour 
la  fermeture de la fenˆtre.  Pour le bouton 'RAZ',  nous demandons  … 
r‚afficher le contenu de la fenˆtre pour actualiser les modifications. 
C'est tout !
  Nous  traitons  ensuite les ‚v‚nements MU_BUTTON  /  BEV_WMENU,  les 
‚v‚nements de menu en fenˆtre. L'option 'Infos' est un B_FNCP, nous la 
laissons  de cot‚.  Pour les autres,  nous for‡ons l'‚tat SELECTED  du 
titre de menu (il n'est pas s‚lectionn‚ automatiquement si la fonction 
est  appel‚e par ‚quivalent clavier),  et nous  traitons  l'op‚ration. 
Pour l'alerte,  vous remarquerez que la check-mark est plac‚e dans  ce 
menu  avec  la fonction AES menu_icheck() comme s'il  s'agissait  d'un 
menu normal.
  Nous  examinons ensuite les ‚v‚nements MU_BUTTON  /  BEV_WHIER,  les 
‚v‚nements  de menu hi‚rarchique de menu en fenˆtre.  Seules les  deux 
premiŠres  sont … traiter,  les autres ‚tant des  B_FNCPs.  Nous  nous 
contentons  d'appeler  la fonction icone() aprŠs avoir plac‚  dans  le 
mot 6  du  buffer ce qu'elle va y chercher :  le  num‚ro  de  l'option 
cliqu‚e.
  Il reste … traiter les clics souris directement sur le bureau. Je ne 
d‚crirais pas en d‚tail cette partie qui ne pr‚sente aucune difficult‚ 
(par pr‚caution, nous v‚rifions qu'il n'y a pas de fenˆtre … l'endroit 
du  clic).  La  maniŠre  de  traiter le  bureau  d‚pend  fortement  de 
l'application. Dans la d‚mo je me suis content‚ de cr‚er quelque chose 
de trŠs g‚n‚ral.
  Le  seul  imp‚ratif,  c'est que les objets du bureau  n'ait  pas  un 
ob_flags  EXIT  ou  TOUCHEXIT  ou  autre  chose  (sauf  ‚ventuellement 
LASTOB).  Sinon,  la  fonction dialog() tenterait de les traiter …  sa 
fa‡on. En fait elle travaille de la fa‡on suivante : si le clic a lieu 
dans  la zone de travail d'une fenˆtre,  il est trait‚  par  dialog(). 
s'il   a  lieu  sur  un  des  ‚l‚ments  de  la  fenˆtre   (bouton   de 
redimensionnement  par exemple),  il est ignor‚ (le GEM va g‚n‚rer  un 
MU_MESAG qui sera trait‚ s‚par‚ment). S'il a lieu sur un des objets du 
formulaire dont dialog() a re‡u l'adresse en paramŠtre,  elle tente de 
le  g‚rer en fonction des flags de cet  objet.  Enfin,  elle  retourne 
l'‚v‚nement au programme.
  Pour   un  bureau,   qui  n‚cessite  une  gestion  …   chaque   fois 
particuliŠre,  nous  voulons que dialog() nous signale  simplement  le 
clic  sans  rien faire,  afin que nous d‚cidions de ce qui  doit  ˆtre 
r‚alis‚.  Dans la d‚mo,  si l'ic“ne ‚tait EXIT et SELECTABLE, dialog() 
la s‚lectionnerait et la d‚s‚lectionnerait … chaque clic sur  l'ic“ne, 
mais  ne pourrait ni la d‚placer ni la d‚s‚lectionner lors  d'un  clic 
"dans le vide". En proc‚dant ainsi, nous devons faire les choses "… la 
main", mais nous faisons ce que nous voulons.
  La fin de la boucle 'do...while' teste la variable 'quit',  qui  est 
mise 'TRUE' si la sortie du programme est demand‚e.  La fonction end() 
est  alors simplement appel‚e,  en lui signalant que nous  travaillons 
avec un ressource externe.
  Cette  fonction  libŠre les diff‚rentes zones m‚moire  qui  ont  ‚t‚ 
r‚serv‚es (pour les structures de fenˆtre, les userdefs, les pointeurs 
sur fonctions,  les ‚ditables ‚tendus, le buffer d'‚cran et la palette 
par d‚faut), elle ferme toutes les fenˆtres (du moins, celles qui sont 
…  notre  application),  elle  libŠre le ressource,  ote  le  menu  et 
restaure le bureau GEM.

  6.b.2 La gestion des formulaires
  Nous  arrivons  … la fonction qui gŠre le 'formulaire libre'  de  la 
d‚mo.  Nous devons d‚clarer un MFDB qui d‚crira le fond du formulaire. 
Il ne sera utilis‚ que si nous demandons un d‚placement du  formulaire 
en boŒte fant“me (ou s'il n'y a pas assez de m‚moire pour le  r‚aliser 
en  temps r‚el).  Nous inversons le titre de menu (pour le cas  o—  la 
fonction  a ‚t‚ appel‚e par raccourci clavier ou pop-up  libre),  nous 
bloquons  l'AES  par  wind_update(),   nous  demandons  l'adresse   du 
formulaire (des instructions de pr‚processeur et la d‚finition 'INTGR' 
du d‚but du source signalent au compilateur  si nous travaillons  avec 
un  ressource int‚gr‚ ou non),  et nous sauvegardons son ‚tat dans  la 
zone  d‚sign‚e  par le pointeur 'adr_bakrsc' au moyen de  la  fonction 
bak_rsc().
  Nous  pouvons  enfin demander  l'affichage  par  formm_draw().  Nous 
pr‚cisons … cette fonction l'adresse du formulaire,  le champ ‚ditable 
o—  doit  se  trouver  le curseur au  d‚part,  que  nous  d‚sirons  un 
d‚placement  en  temps  r‚el,  et  quelle est  l'adresse  du  MFDB  de 
sauvegarde  du  fond s'il fallait proc‚der … un d‚placement  en  boŒte 
fant“me faute de m‚moire. Les diff‚rentes initialisations, r‚servation 
m‚moire,  sauvegardes  d'images,  et  calculs  sont  r‚alis‚s  par  la 
fonction.
  Nous pouvons entrer alors dans la boucle de traitement, bas‚e encore 
une fois sur dialog().  Dans ce cas,  les ‚v‚nements … surveiller sont 
moins  nombreux  que pour le bureau.  Seulement le clavier  (pour  les 
‚ditables),  les clics (pour les diff‚rents objets) et comme toujours, 
le  timer,  pour garder la main.  dialog() s'occupe de tout  (pop-ups, 
aide,  d‚placement,  pointeurs sur fonction, ‚ditables ‚tendus ou non, 
gestion du curseur, etc.
  Nous  avons juste … nous occuper de la sortie.  Si 'Confirme' a  ‚t‚ 
choisi,  rien  …  faire.  Si c'est 'Annule',  nous  restaurons  l'‚tat 
ant‚rieur du formulaire.
  Il  ne  nous  reste  plus  qu'…  oter  le  formulaire  de   l'‚cran. 
formm_undraw() s'en charge,  et libŠre les zones m‚moire r‚serv‚es par 
formm_draw().  Par contre,  c'est … nous que revient la responsabilit‚ 
de lib‚rer la m‚moire d'‚tat du formulaire.
  La  fonction aff_infos() est presque identique.  Il y juste un  test 
suppl‚mentaire au d‚but :  si les infos ont ‚t‚ demand‚es … partir  du 
menu  de  fenˆtre,  il faut inverser le titre de  menu  correspondant. 
Comme il n'y a ni bouton 'Annule',  ni de dialogue avec l'utilisateur, 
inutile de g‚rer l'‚tat du formulaire. Le d‚placement ‚tant demand‚ en 
boŒte fant“me, le pointeur sur MFDB prend ici toute son importance.
  La  fonction test_alerte() est celle qui est appel‚e par  le  bouton 
B_FNCP  'Alerte'  du formulaire libre.  Elle r‚alise un  simple  appel 
big_alert().

  6.b.3 Les formulaires en fenˆtre
  L'appel  de formulaires en fenˆtre est encore plus simple que  celui 
des formulaires "bloquant" (qui bloquent le menu, les fenˆtres, etc).
  Commen‡ons  par  la fonction pform_wind(),  qui  pr‚sente  le  petit 
formulaire.  Comme  d'habitude,  nous demandons l'adresse  de  l'arbre 
(ressource  int‚gr‚ ou non) et nous inversons le titre  de  menu.  Une 
boucle  cherche ensuite la correspondance entre la trame  actuelle  du 
bureau  et celles du formulaire afin de s‚lectionner  la  bonne.  Nous 
n'avons  plus qu'a ouvrir la fenˆtre par formw_draw() et a  r‚inverser 
le titre de menu. Il n'y a pas plus simple.
  A formw_draw() sont transmis l'adresse du formulaire, l'index BIG de 
la  fenˆtre  … ouvrir (qui a ‚t‚ d‚clar‚e par  initial()),  le  num‚ro 
(dans  le ressource) de la chaŒne libre qui doit ˆtre le titre  de  la 
fenˆtre, le num‚ro de la chaŒne pour la ligne d'infos (il n'y en a pas 
dans ce cas,  nous transmettons 'BLANK', c'est-…-dire '-1'), le num‚ro 
de l'‚ditable o— doit ˆtre le curseur … l'ouverture de la fenˆtre,  le 
flag  r‚clamant  un  calage du formulaire sur  des  multiples  de  16, 
puisqu'il  contient des trames,  le flag habituel qui signale  que  le 
ressource  n'est pas int‚gr‚ et enfin les attributs que doit  poss‚der 
la  fenˆtre (Nous utilisons ici une d‚finition de BIG  :  seuls  NAME, 
CLOSER et MOVER sont actifs).
  L'ouverture  de  la  fenˆtre du grand formulaire est  faŒte  par  la 
fonction  gform_wind().  Elle  est encore plus  simple,  puisque  nous 
n'avons pas … tester la trame. Bien qu'il comporte un fond tram‚, nous 
ne demandons pas le calage de la fenˆtre sur des multiples de 16, afin 
de  d‚montrer  l'utilit‚ de cette option.  FaŒtes cette  exp‚rience  : 
Affichez  le  grand formulaire,  et d‚placez sa  fenˆtre  de  quelques 
pixels seulement.  Affichez par dessus la fenˆtre du petit formulaire, 
et d‚placez-la jusqu'… la faire presque sortir de l'‚cran vers le bas. 
La  trame du grand formulaire est d‚cal‚e...  … moins que vous  n'ayez 
d‚plac‚ sa fenˆtre de 16 pixels exactement.
  Je  ne d‚crirai pas les fonctions trame_desk() et objets_desk()  qui 
sont  appel‚es  par main() si un bouton 'Confirme' ou  'Applique'  est 
cliqu‚,   respectivement  dans  la  fenˆtre  du  petit  et  du   grand 
formulaire. Ces fenˆtres ‚tant ouvertes, c'est la boucle principale du 
programme  (celle de main()) qui gŠre tout ce qui s'y passe,  grƒce  … 
dialog().

  6.b.4 La fenˆtre texte
  La fonction charge_texte() ouvre la fenˆtre de texte.  Je n'entrerai 
pas dans les d‚tails du chargement lui-mˆme. Ce n'est pas un modŠle du 
genre, mais il est suffisant pour la d‚mo. Ce qui est important, c'est 
que  le  texte est charg‚ dans une zone m‚moire,  qui doit  donc  ˆtre 
lib‚r‚e  … un moment ou … un autre.  Dans un programme  r‚el,  j'aurai 
choisi de la lib‚rer seulement au moment de quitter ou par une  option 
'Abandon'.  Dans  la  d‚mo,  cette  zone doit ˆtre  lib‚r‚e  …  chaque 
fermeture  de la fenˆtre.  La structure Window de cette  fenˆtre  doit 
donc  avoir comme paramŠtre 'w_close' l'adresse d'une fonction qui  se 
chargera de cela en plus de la fermeture de la fenˆtre.
  Il  faut aussi placer dans 'w_redraw' l'adresse de la  fonction  qui 
affichera  le  texte  lui-mˆme.  Le plus important  est  donc  l'appel 
'open_window()'.  Les lignes qui pr‚cŠdent cet appel chargent le texte 
(notez l'utilisation de la fonction selector()) et comptent le  nombre 
de  lignes.  Nous  demandons  ‚galement … la VDI  les  dimensions  des 
cellules de caractŠres de la police courante.
  Nous appelons open_window() en lui pr‚cisant l'index de la fenˆtre … 
ouvrir,  son type BIG (WTYP_NORM), ces attributs GEM (WATR_CURR : tous 
sauf  la ligne d'infos),  les coordonn‚es de  d‚part,  ses  dimensions 
minimum,  les unit‚s de d‚calage (la taille d'une cellule), un flag de 
fenˆtre manipulable au clavier,  pas de calage sur les multiples de 16 
et la forme de la souris dans la zone de travail. Viennent ensuite les 
pointeurs sur les fonctions d'affichage et de fermeture de la fenˆtre, 
des  pointeurs  sur les chaŒnes de titre et d'infos  (la  seconde  est 
vide),  les largeur et hauteur totales de la fenˆtre (en pixels). Nous 
devons  r‚aliser des "casts" pour que les paramŠtres  transmis  soient 
bien  de type 'long'.  Enfin,  sont transmis un flag signalant que  la 
fenˆtre  n'a pas de menu,  un '-1',  … d‚faut du num‚ro d'arbre de  ce 
menu, et un dernier flag de ressource int‚gr‚ ou non.
  Cela  fait beaucoup de paramŠtres,  mais c'est tout ce qu'il y  a  … 
faire.  A  partir de maintenant,  nous n'avons plus … nous occuper  de 
cette fenˆtre.  Elle sera d‚plac‚e,  redessin‚e,  son contenu d‚filera 
sans aucune intervention de notre part (mˆme dans le cas des  versions 
les plus r‚centes du GEM,  qui autorisent la manipulation des fenˆtres 
d'arriŠre-plan).  La  fonction d'affichage (aff_texte() dans la  d‚mo) 
sera  appel‚e  automatiquement lorsque cela sera n‚cessaire  (Je  vous 
laisse  examiner cette fonction,  qui n'est pas non plus  un  modŠle). 
S'il  n'y  a  plus de fenˆtre disponible dans  les  tableaux  du  GEM, 
l'alerte du ressource int‚gr‚ de BIG sera affich‚e pour le signaler  … 
l'utilisateur.
  Quant … la fonction close_txt(), elle appelle closed() (qui ferme la 
fenˆtre  et  modifie l'‚l‚ment w_hg) et libŠre la  m‚moire  du  texte. 
Comme closed() cherche dans buf[3] le handle GEM de la  fenˆtre,  nous 
l'y pla‡ons un peu artificiellement avant l'appel.

  6.b.5 La fenˆtre image
  La fonction charge_image() ressemble … celle du texte.  Elle est  un 
peu  plus  complexe du fait qu'elle peut ˆtre appel‚e pour  ouvrir  la 
fenˆtre image normale,  ou … partir de la fenˆtre avec  menu,  l'image 
devant  alors ˆtre plac‚e dans celle-ci.  Il y a donc plusieurs  tests 
pour cela.
  L'image   est   charg‚e  dans  une  zone   m‚moire,   et   l'‚l‚ment 
w_cont.w_img.w_blk de la structure de fenˆtre correspondante doit ˆtre 
rempli avec les dimensions de l'image. De mˆme pour w_cont.w_img.w_pal 
avec la palette de couleurs de cette image.
  L'appel  … open_window() est presque le mˆme que pour le  texte.  Le 
type  BIG  de  la fenˆtre implique que BIG se  chargera  de  tous  les 
affichages  n‚cessaires.   Nous  transmettons  donc  un  'ZERO'  comme 
fonction  de  redraw.  Les  variables 'fmenu'  et  'menu'  contiennent 
respectivement 'FALSE' et 'BLANK' dans le cas de la fenˆtre image,  et 
contiennent 'TRUE' et le num‚ro du menu dans le cas de la fenˆtre avec 
menu.
  Le  redraw de l'image est fait … partir des  informations  contenues 
dans w_cont.w_img.w_blk.  S'il n'y en a pas, c'est que l'image n'a pas 
encore ‚t‚ charg‚e. BIG trace alors un rectangle blanc dans la fenˆtre 
pour la vider.
  La  fonction  de  fermeture de fenˆtre n'est pas la  mˆme  selon  la 
fenˆtre,  puisque  la m‚moire du menu doit ˆtre lib‚r‚e si c'est  elle 
qui est ferm‚e.  La fonction close_img() travaille comme son homologue 
du  texte,  mais  doit  en plus lib‚rer la m‚moire de  la  palette  de 
couleur.  Quant  … close_wmenu(),  elle fait de mˆme avec en  plus  la 
lib‚ration de la m‚moire de menu.

  6.b.6 La fenˆtre graphique
  La  fenˆtre  d'histogrammes  est cr‚e et  ouverte  par  la  fonction 
cree_histo(). Une zone m‚moire pour les donn‚es est r‚serv‚e, puis des 
valeurs  al‚atoires sont tir‚es pour les histogrammes et plac‚es  dans 
cette zone.
  L'ouverture de la fenˆtre se fait comme nous l'avons d‚j…  vu,  mais 
nous avons besoin que cette fenˆtre ait une fonction sp‚ciale pour  le 
redimensionnement,   la   pleine  taille  (ou  retour)  et   un   flag 
particulier.  Comme ces trois choses ne font pas partie des paramŠtres 
d'open_window(), nous devons les traiter "manuellement".
  Les histogrammes doivent toujours remplir la totalit‚ de la fenˆtre. 
nous  avons  donc  besoin  de fonctions de "size"  et  de  "full"  qui 
s'occupent de cela,  et r‚affichent la totalit‚ de la fenˆtre dans  le 
cas o— un redraw ne concernerait qu'une partie (par exemple, le retour 
de  la  pleine  taille … la pr‚c‚dente).  Le  flag  'WFREDRAW'  impose 
‚galement un redraw … chaque fois que la fenˆtre est pass‚e au premier 
plan.  Ainsi,  si  les  donn‚es ont ‚t‚  modifi‚es,  l'affichage  sera 
actualis‚  …  chaque  fois en totalit‚,  et pas  seulement  la  partie 
indiqu‚e  par  la  liste  des rectangles  de  l'AES.  Cela  peut  ˆtre 
indispensable dans certaines applications, par exemple un tableur. Des 
valeurs  sont  chang‚es dans la feuille de  calcul,  puis  la  fenˆtre 
graphique, jusque l… en arriŠre-plan, est amen‚e en premier.
  Nous pla‡ons donc dans les ‚l‚ments w_size et w_full les adresses de 
nos  fonctions  correspondantes,  et nous for‡ons le bit  WFREDRAW  de 
w_flags.
  Les  histogrammes  affich‚s  ‚tant tram‚s,  nous  demandons  que  la 
fenˆtre soit toujours cal‚e sur des multiples de 16,  par le paramŠtre 
'fb' de la fonction open_window().
  La  fonction  aff_histo() ne devrait  pas  n‚cessiter  d'explication 
particuliŠre.  sized_histo() ne demande l'affichage de la fenˆtre  que 
si  les  nouvelles dimensions sont toutes deux plus  petites  que  les 
anciennes,   car  dans  ce  cas  le  GEM  ne  g‚nŠre  pas  de  redraw. 
fulled_histo()  a  la tƒche simplifi‚e :  le GEM enverra  toujours  un 
redraw pour le passage en pleine taille, et jamais pour le retour … la 
taille  pr‚c‚dente.  Pour le passage en pleine taille,  nous  appelons 
quand  mˆme la fonction fulled() afin de b‚n‚ficier du calage sur  les 
multiples  de 16 sans faire de calcul.  close_histo() fait  comme  ses 
cons´urs  texte  et image,  elle libŠre la m‚moire r‚serv‚e  pour  les 
donn‚es.
  La fonction close_wmenu() ferme la fenˆtre avec menu en lib‚rant les 
zones m‚moires r‚serv‚es pour l'image et la palette de couleurs.
  DerniŠre  fonction,  icones() r‚cupŠre dans buf[6] l'option  cliqu‚e 
(ou appel‚e par ‚quivalent clavier) dans le menu hi‚rarchique du  menu 
de fenˆtre, et choisi l'ic“ne selon cette option.
  Ce  programme BIGDEMO.PRG a ‚t‚ cr‚‚ avec des paramŠtres minimum  et 
trŠs simples.  Pour la compilation,  les seules options activ‚es  sont 
"Default char is unsigned" (-K) et "Use absolute calls"  (-P).  Aucune 
option  n'est  activ‚e  dans le linker.  La librairie  BIG.LIB  a  ‚t‚ 
compil‚e avec les mˆmes options.  Ainsi, BIG n'impose pratiquement pas 
de contraintes de compilation.













































7. ParamŠtres et pointeurs sur fonctions
  Les  fonctions  appel‚es par les objets B_FNCP sont  de  type  'void 
fonction  (void)'.  Elle  ne peuvent donc recevoir  de  paramŠtres  ni 
retourner de valeur.  Il y a des situations o— cela est g‚nant, car il 
faudra imp‚rativement transmettre des informations … la  fonction,  et 
elle devra r‚pondre quelque chose. Comment faire ?
  Il  suffit  de mettre en place une zone m‚moire,  ou  une  structure 
globale,  ou un tableau de paramŠtres,  selon le contexte,  o—  seront 
plac‚es les informations … ‚changer avec la fonction. C'est exactement 
ce  que  font l'AES et la VDI avec  les  tableaux  contrl[],  intin[], 
ptsout[], global[], etc.
  La d‚mo,  volontairement simple,  ne pr‚sente pas d'exemple de cette 
m‚thode,  mais  c'est  un  peu  ce qui est  r‚alis‚  par  la  fonction 
close_txt().  Elle  appelle  la fonction closed() qui est  charg‚e  de 
fermer une fenˆtre.  Mais,  ‚tant d‚clar‚e 'void closed (void)', on ne 
peut  lui  transmettre  le  handle  de  la  fenˆtre  dont  il  s'agit. 
close_txt()  place donc le handle GEM de la fenˆtre … fermer  dans  le 
mot  3  du tableau buf[],  qui est une  variable  globale,  puis  elle 
appelle closed().  Celle-ci va chercher dans buf[3] l'information dont 
elle a besoin : le handle GEM de la fenˆtre … fermer.











































8. Travail avec un ressource int‚gr‚
  Il  est tout … fait possible de d‚velopper avec BIG une  application 
utilisant un ressource int‚gr‚ au lieu d'un fichier RSC externe.
  Pour  r‚aliser  cela,  il est n‚cessaire d'utiliser  un  ‚diteur  de 
ressource capable de g‚n‚rer un fichier "RSH" contenant sous forme  de 
source C la description du ressource.  Il suffit ensuite de placer  au 
d‚but du programme la ligne ' #include "PROGNAME.RSH" ' et le tour est 
jou‚.
  Voici  une description de la syntaxe habituelle,  utilis‚e  par  les 
‚diteurs de ressource Interface et ORCS :.
  Les adresses des objets sont plac‚es dans un tableau  'rs_trindex[]' 
(ReSsource  TRee  INDEX).  L'adresse de l'arbre lui-mˆme  (l'objet  0) 
s'obtient par exemple par :
  adr = rs_trindex[DESK];
  Et l'adresse d'un objet particulier par :
  adr_object = adr[OBJECT];
  Avec :
  OBJECT *adr, *adr_object;
  Les  adresses  des  chaŒnes et alertes libres se  trouvent  dans  le 
tableau 'rs_frstr[]' (ReSsource FRee STRing).
  Il est n‚cessaire d'indiquer … BIG de quelle maniŠre il peut acc‚der 
aux  adresses  des  ‚l‚ments du  ressource.  Comme  nous  l'avons  vu, 
plusieurs  fonctions re‡oivent en paramŠtre un flag leur indiquant  si 
le ressource est externe ou non.  Par exemple,  la fonction (interne … 
BIG) 'pop-up()' utilise ce flag de la maniŠre suivante :  elle cherche 
dans l'ob_state ‚tendu du bouton pop-up cliqu‚ le num‚ro du formulaire 
qui lui est associ‚.  Puis,  si le ressource est externe, elle cherche 
l'adresse  de  ce  formulaire  par  'rsrc_gaddr(numero)',   sinon  par 
'rs_trindex[num‚ro]'.
  Si nous travaillons avec un ressource int‚gr‚,  nous transmettons  … 
BIG par les paramŠtres de la fonction initial() les adresses de d‚part 
des  tableaux  rs_trindex[] et rs_frstr[].  Ces  adresses  sont  alors 
simplement  copi‚es  dans deux variables internes de BIG  afin  d'ˆtre 
utilis‚es  quand  il sera n‚cessaire d'obtenir une  adresse.  Si  nous 
travaillons  avec  un ressource externe (dans  ce  cas,  le  paramŠtre 
nb_tree  est ‚gal … 0),  nous pouvons transmettre des '0'  pour  faire 
propre, mais initial() ignore simplement ces paramŠtres.
  Etudiez le source de la d‚mo pour voir comment ceci est  trait‚.  Il 
suffit de changer le '0' en '1' dans la ligne ' #define INTGR 0 ' pour 
recompiler  la  d‚mo avec un ressource int‚gr‚.  Cette  d‚finition  et 
quelques  instructions  destin‚es au compilateur  font  la  diff‚rence 
entre  ces deux situations et le programme est toujours compil‚  comme 
il  convient.  Si le ressource est int‚gr‚,  nous incluons le  fichier 
'BIGDEMO.RSH',  et  nous  transmettons … initial()  les  adresses  des 
tableaux par ' (OBJECT *)rs_trindex ' et ' (char  *)rs_frstr ',  ainsi 
que le nombre d'arbres du ressource :16 (formulaires et menus).  Si le 
ressource est externe, nous incluons simplement le fichier 'BIGDEMO.H' 
(les  d‚finitions) et les autres paramŠtres sont mis …  0.  Plus  loin 
dans  le  source (par exemple dans la  fonction  'pform_wind()')  nous 
utilisons  encore  la  d‚finition  'INTGR'  et  des  instructions   de 
compilation pour chercher l'adresse du formulaire par rsrc_gaddr()  ou 
par rs_trindex[], selon le cas.
  Dernier point :  si le ressource est int‚gr‚, les coordonn‚es et les 
dimensions  des objets doivent ˆtre adapt‚s … la r‚solution  courante, 
par la fonction GEM rsrc_obfix() (ce qui est fait automatiquement  par 
GEM au chargement d'un ressource externe).  La fonction initial() s'en 
charge automatiquement pour les ressources int‚gr‚s. Un conseil : dans 
l'‚diteur  de ressource,  calez toujours les objets sur un  offset  de 
caractŠre.




9. Epilogue
  9.a Historique
  Nous arrivons au bout de cette pr‚sentation de BIG.  Au  d‚part,  ce 
n'‚tait  que quelques fonctions dans mes d‚veloppements.  Peu  …  peu, 
elles ont grandi, en volume et en qualit‚. A chaque nouveau programme, 
je  les  recopiais  et j'ajoutais  des  options,  des  pointeurs,  des 
automatismes.  Lorsque  des copains m'ont demand‚ s'ils pouvaient  les 
utiliser,  je  me suis rendu compte que j'‚tais le seul …  pouvoir  le 
faire,  car il y avait toujours une quantit‚ de petits d‚tails propres 
… chaque application,  qui devaient ˆtre modifi‚s … chaque fois.  Mais 
j'‚tais le seul … m'y retrouver dans cette jungle !
  Alors  j'ai  pris mon courage … deux mains et j'ai tout  r‚‚crit  de 
maniŠre que cela puisse ˆtre utilis‚ dans toutes les situations,  dans 
toutes les applications, avec un minimum de contraintes, un minimum de 
variables   globales,   le   plus  de  simplicit‚  possible   et   une 
compatibilit‚  de  100 % avec toutes les machines de  la  gamme,  mˆme 
celles  qui  ‚taient … venir (Et la premiŠre version beta de  BIG  que 
j'ai test‚ sur Falcon multitƒche a fonctionn‚e... … 95 %).
  En d‚veloppant ces routines, je me suis pris au jeu et j'ai commenc‚ 
…  ajouter  des  quantit‚s de choses que je  n'avais  jamais  song‚  … 
inclure … mes programmes : menus hi‚rarchiques et en fenˆtre, forme de 
la  souris variable,  gestion automatique de la  palette,  formulaires 
d‚pla‡ables,  etc.  Je  tenais  …  cr‚er  quelque  chose  de  complet, 
reprenant tout ce qui existait d‚j… dans d'autres librairies,  dans le 
nouveau GEM, et tout ce que j'avais pu voir de plaisant dans certaines 
applications,  en bannissant toutefois tout ce qui pourrait rendre  la 
communication logiciel-utilisateur compliqu‚e.
  Il fallait bien que je m'arrˆte.  Mais BIG va sans doute encore ˆtre 
am‚lior‚.  On  pourrait par exemple mettre en place un mode "3D"  pour 
les formulaires,  o— le fond serait tram‚ et les boutons en relief. Le 
d‚placement des formulaires pourrait ˆtre am‚lior‚ en vitesse, etc.
  BIG peut sans doute ˆtre fortement optimis‚.  Mais je n'ai fait pour 
l'instant que peu d'efforts dans ce sens,  je pr‚fŠre attendre  d'ˆtre 
s–r qu'il n'y ait plus de bug.  Un source parfaitement optimis‚, c'est 
trŠs beau, mais il est parfois moins ‚vident de s'y retrouver pour une 
modification ou une correction.

  9.b Pour me contacter
  Vous pouvez me contacter pour me demander de vous faire parvenir les 
sources  complets  des routines BIG.  Pour cela,  je vous  demande  en 
‚change la somme de 100 F ($17) pour la disquette et les frais d'envoi 
(et pour qu'il me reste un petit quelque chose).
  Contactez-moi aussi si vous avez des questions,  si vous avez trouv‚ 
des  bugs,  si vous avez des suggestions … me faire pour  ‚tendre  les 
possibilit‚s de BIG, si vous voulez me f‚liciter (j'espŠre) et mˆme si 
vous voulez m'engueuler (pourquoi pas).
  Et  surtout,  si  vous  me  demandez les sources  et  que  vous  les 
am‚liorez, faŒtes-m'en profiter !
  Dans  tous les cas,  cela me permettra de vous tenir au  courant  de 
l'‚volution de BIG,  et de vous faire parvenir si vous le d‚sirez  des 
versions plus r‚centes.
  Voici mes coordonn‚es :
              Claude ATTARD
             36, rue Raspail
           94200 Ivry sur Seine
                (France)
  Dernier  point  :  L'utilisation  de  BIG  dans  des  d‚veloppements 
destin‚s  … la commercialisation est  libre.  Toutefois,  j'accepterai 
avec  grand plaisir un petit quelque chose en proportion avec le  prix 
de vente du logiciel. Cela parait correct, non ?
  Ami d‚veloppeur, je te souhaite autant de plaisir … utiliser BIG que 
j'en ai eu … le d‚velopper. Ce n'est pas peu dire !

