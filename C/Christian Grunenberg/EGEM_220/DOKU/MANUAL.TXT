
 0. INHALT:
============

 I.   Allgemeine Hinweise

        0.  Hinweise zu dieser Dokumentation
        1.  öbersetzung der Library mit Pure C, GNU-C und Lattice C
              a. Pure C
              b. GNU-C/Lattice C
        2.  Nutzung der Library mit Pure C, GNU-C und Lattice C

 II.  Neue Mîglichkeiten in Eingabefeldern

 III. erweiterte Objekt-Typen sowie Resource-Aufbau

        1.  Debugging
        2.  Highbyte des Objekt-Typs

 IV.  Globale Variablen der Library

 V.   Funktionen, Strukturen und Konstanten der Library

        1.  Routinen zur Verwaltung des Cookie-Jars
        2.  Routinen zur Verwaltung des Environments
        3.  Erweiterte Objekt-Routinen (u.a. kompatibel zum PC-GEM 2.0)
        4.  Erweiterte Rechteck-Routinen (u.a. kompatibel zum PC-GEM 2.0)
        5.  VDI-(Attribut-) und Clipping-Funktionen
        6.  Erweiterte Scrap-Directory-Routinen
        7.  Erweiterte Grafik-Routinen
        8.  MenÅ-Funktionen
        9.  Dialog-Optionen und -optik setzen
        10. Bibliothek (AES,VDI) sowie Resource (de-) initialisieren
        11. Resource- und Objekt-Initialisierung
        12. Ereignis-Auswertung
        13. Library-spezifische Nachrichten
        14. Dialog-Funktionen
        15. Fenster-Funktionen
        16. Update/Control-Funktionen
        17. Popup-Funktion
        18. XAcc-2- und AV-Protokoll-Funktionen
        19. Drag & Drop-Funktionen
        20. Auskunftsfunktionen
        21. Datei-/Pfadfunktionen
        22. Font-Funktionen
        23. Paula-Protokoll
        24. Timer-Funktionen
        25. Maus/Tastatur-Funktionen
        26. Verschiedene Funktionen
        27. Definitionen hÑufig benîtigter (Protokoll-) Konstanten

 I. Allgemeine Hinweise:
=========================

 0. Hinweise zu dieser Dokumentation
    --------------------------------

    Die in diesem Text dokumentierten Strukturen und ihre Variablen haben
    teilweise einen von der Dokumentation abweichenden Aufbau, d.h. die
    Reihenfolge der Variablen ist nicht garantiert und es kînnen weitere,
    intern benîtigte Variablen vorhanden sein. Einzig und allein die Be-
    deutung einer Variablen kann als gegeben hingenommen werden, wÑhrend
    der genaue Aufbau einer Struktur aus der Include-Datei 'E_GEM.H' ent-
    nommen werden muû.

 1. öbersetzung der Library mit Pure C, GNU-C und Lattice C
    -------------------------------------------------------

    WICHTIG:
    Bei der öbersetzung der Library darf keine Stack-öberprÅfung aktiviert
    sein, da einige Library-Funktionen (z.B. benutzerdefinierte Objekte) vom
    AES aufgerufen werden und somit den AES-Stack verwenden.

    Light-Version:
    --------------
    Durch Definition einer der folgenden Konstanten-Makros kînnen evtl.
    nicht benîtigte Teile der Library bei der öbersetzung deaktiviert
    werden, so daû die resultierenden Programme teilweise deutlich kÅrzer
    werden (bis zu 40 KByte).
    Der Code-Overhead der Library betrÑgt dann - abhÑngig von der Art der
    öbersetzung und der Ausnutzung - zwischen 20 und 80 KByte (absolut)
    und im Vergleich zur eigenen Implementation entsprechender, nicht so
    flexibler Routinen ungefÑhr 10 bis 30 KByte, wobei der Overhead i.A.
    mit der Grîûe der Anwendung abnimmt.
    (Angaben fÅr Pure C mit Pure-Libraries)

    ACHTUNG:
    Wird ein Programm mit einer Library gelinkt, welche mit anderen
    Optimierungen Åbersetzt wurde, so kann es zu AbstÅrzen oder Fehl-
    funktionen kommen, da die Strukturen der Library ebenfalls optimiert
    werden!

    /* Minimale Anzahl an Image-Varianten bei erweiterten Objekttypen */
    #define SMALL_EGEM

    /* Minimale Anzahl an Alert-Icons (die definierten Icons (s. Funktion
       xalert) sind weiterhin vorhanden) */
    #define SMALL_ALERT

    /* Kein erweiterter Text mit Attributen in Dialogen und Alertboxen
       (Funktion get_xtext() und Struktur X_TEXT sind nicht vorhanden) */
    #define SMALL_NO_XTEXT

    /* Menu-Funktionen (auûer MenuItems) und Variable menu_available sind
       nicht vorhanden; Pull-Down-MenÅs werden nicht unterstÅtzt (nur als
       FenstermenÅ) */
    #define SMALL_NO_MENU

    /* Keine Eingabefelder in Dialogen (OBJC_EDITED-Nachricht sowie die
       Funktionen ob_edit_init(), ob_edit_handler() und ob_set_cursor()
       stehen nicht zur VerfÅgung, s.a. SMALL_EDIT und SMALL_NO_HZ) */
    #define SMALL_NO_EDIT

    /* Kein blinkender Eigabecursor (entsprechende Option bei dial_options
       ist wirkungslos) */
    #define SMALL_NO_HZ

    /* Sonderzeicheneingabe/ASCII-Dialog (Funktionen MakeAscii, ExitAscii,
       ascii_box), History, Clipboard-UnterstÅtzung, erweiterten Eingabe-
       masken, ACC_TEXT-Eingabe, Eingabefelder in Slidern und Lîschen aller
       Eingabefelder per Shift-Escape sind nicht vorhanden,
       s.a. SMALL_NO_HZ) */
    #define SMALL_EDIT

    /* Keine Clipboard-UnterstÅtzung in Eingabefeldern (entsprechende
       Option der Funktion dial_options() ist ohne Wirkung) und Scrap-Funk-
       tionen sind nicht vorhanden (GEM-Clipboard wird nicht initialisiert) */
    #define SMALL_NO_CLIPBRD

    /* Keine Zeichensatzfunktionen (Funktionen FontInfo, FastFontInfo,
       FontList, FontSizes sind nicht vorhanden), kein Fontselector
       (s. SMALL_NO_FSEL); bei den Funktionen v_set_text und v_set_point
       kînnen keine Zwischengrîûen bei Vektorfonts eingestellt werden */
    #define SMALL_NO_FONT

    /* Kein Fontselector (FONTSEL-Struktur, Funktionen FontSelect und
       UpdateFsel sowie Variable FSelDialog sind nicht vorhanden) */
    #define SMALL_NO_FSEL

    /* Keine UnterstÅtzung des internen Drag&Drop-Fontselectors */
    #define SMALL_NO_DD_FSEL

    /* Keine Popup-MenÅs (POPUP_CHANGED-Nachricht, Funktion Popup sowie
       Strukturen POPUP und XPOPUP sind nicht vorhanden) und Font-
       Funktionen (s. SMALL_NO_FONT))
       (Modul 'POPUP.C' wird nicht benîtigt) */
    #define SMALL_NO_POPUP

    /* Keine Echtzeitschieber (Nachricht SLIDER_CHANGED sowie Funktionen
       graf_arrows, graf_set_slider, graf_rt_slidebox und
       graf_rt_slidecursor stehen nicht zur VerfÅgung), keine Font-
       Funktionen (s. SMALL_NO_FONT)) */
    #define SMALL_NO_GRAF

    /* Kein Drag&Drop (DRAG_DROP-Struktur, OBJC_DRAGGED-Nachricht sowie
       D&D-Funktionen sind nicht vorhanden) */
       (Modul 'DRAGDROP.C' wird nicht benîtigt) */
    #define SMALL_NO_DD

    /* Kein XAcc/AV-Protokoll (XAcc-Struktur, XACC_AV_INIT/EXIT/CLOSE-
       Nachrichten sowie alle Protokoll-Funktionen (auûer AppLoaded,
       GetMsgBuffer und AvSendMsg) sowie scrp_changed und drive_changed
       sind nicht vorhanden); kein Font-Protokoll (Funktionen FontChanged,
       FontAck und CallFontSelector sind nicht vorhanden);
       kein Paula-Protokoll (s. SMALL_NO_PAULA) */
    #define SMALL_NO_XACC_AV

    /* Kein Paula-Protokoll (Funktionen PaulaStop, PaulaShutDown sowie
       PaulaStart sind nicht vorhanden) */
    #define SMALL_NO_PAULA

    /* Keine Fenster-Scrollroutinen (SCROLL-Struktur, WIN_SCROLLED-
       Nachricht und Funktion scroll_window sind nicht vorhanden)
    #define SMALL_NO_SCROLL

    /* Keine Ikonfizierung von Fenstern (Variable iconified, Kommandos
       W_(UN)ICONIFY(ALL) der Funktion WindowHandler sind nicht vorhanden;
       Parameter fÅr ikonifizierte Darstellung beim ôffnen von Fenstern/
       Dialogen sowie bei den Funktionen MenuItems und window_set_mouse()
       sind wirkungslos) */
    #define SMALL_NO_ICONIFY

    /* Alle oben aufgefÅhrten Makros setzen */
    #define SMALL_LIGHT


    a. Pure C

    EnhancedGEM lÑût sich sowohl mit den Pure-C-Libraries als auch mit den
    MiNT-Libraries ab Patchlevel 30 compilieren.
    EnhancedGEM lÑût sich sowohl mit den Pure-C-Libraries als auch mit den
    MiNT-Libraries ab Patchlevel 30 compilieren.
    Hierzu muû jedoch mindestens Pure C V1.1 vorhanden sein und im
    Header-File AESBIND.H der MiNT-Libraries muû die Zeile

    __EXTERN int    evnt_timer __PROTO((unsigned long Interval));

    in

    __EXTERN int    evnt_timer __PROTO((int Int_locount,int Int_hicount));

    abgeÑndert werden.
    Weiterhin muû das Makro __MINT_LIB__ bei Benutzung der MiNT-Library
    definiert werden.

    b. GNU-C/Lattice C

    Ebenfalls lÑût sich EnhancedGEM mit GNU-C und Lattice C Åbersetzen,
    wobei allerdings die MiNT-Library sowie die entsprechenden Makefiles
    (Makefile.GCC bzw. Makefile.LCC) benutzt werden mÅssen. Eventuell auf-
    tretende Warnungen bei der öbersetzung sind (hoffentlich) bedeutungslos.

 2. Nutzung der Library mit Pure C, GNU-C und Lattice C
    -------------------------------------------------------

    a. Wurde EnhancedGEM mit Hilfe der MiNT-Libraries Åbersetzt, so MöSSEN
    die MiNT-Libraries und die dazugehîrigen Header-Dateien auch benutzt
    werden. Ansonsten sind die Reaktionen nicht vorhersehbar, aber hîchst-
    wahrscheinlich resultieren daraus Fehlfunktionen (auûer evtl. bei
    GNU-C).

    b. Alle (AES-) Funktionen, die bzw. deren FunktionalitÑt in Ñhnlicher
    Form von der Library angeboten werden, sollten idR nicht mehr benutzt
    werden (z.B. Ereignisfunktionen evnt_..., Fenster-Funktionen wind_...,
    énderung des Mauszeigers per graf_mouse usw.). Die AES-Fensterfunk-
    tionen dÅrfen NUR fÅr Fenster, die nicht von der Library verwaltet wer-
    den (z.B. Desktop oder Fenster anderer Anwendungen), oder wenn eine
    Funktion nicht von der Library angeboten wird, aufgerufen werden.
    I.A. sind auch die angebotenen Routinen der Library schneller (teil-
    weise deutlich schneller)

    Wird die interne VDI-Workstation der Library benutzt, so muû sicherge-
    stellt sein, daû entweder Library-Funktionen benutzt oder die Attribute
    in ihren ursprÅnglichen Zustand zurÅckgesetzt werden.
    Ist dies nicht der Fall, muû sofort nach VerÑnderung der Attribute
    die Funktion vs_attr() aufgerufen werden. Allerdings darf auf keinen
    Fall der Clipping-Bereich verÑndert werden, d.h. er ist mit den Funk-
    tionen save_clipping()/restore_clipping wiederherzustellen.

    c. Alle internen, modulÅbergreifenden globalen Variablen und Funktionen
    der Library beginnen mit einem Unterstrich '_', so daû es zu keinen
    öberschneidungen kommen sollte.

    d. Die Grîûe des Stacks sollte mindestens 4, bei grîûeren Programmen
    mindestens 8 KByte betragen.

    e. EGEM-Programme laufen unter MultiTasking automatisch in der MiNT-
    Domain (sofern vorhanden), wÑhrend unter SingleTasking (TOS) die
    normale TOS-Domain voreingestellt ist.

 II. Neue Mîglichkeiten in Eingabefeldern:
===========================================

    - zusÑtzliche GÅltigkeitsmasken:
        'c','C': Ziffern "0-9", Komma ".,", Rechenzeichen "+-*/^",
                 Klammern "(){}[]"
        'l','L': LED-Ziffern "0-9"
        '<Ziffer>': Ziffer='0'-'9', alle Ziffern von '0' bis <Ziffer>, z.B.
                 '1': BinÑrziffern '01'
                 '7': Oktalziffernn '01234567'
                 '9': Dezimalziffern '0123456789'
        'h','H': Hexadezimalziffern "0-9A-F",
                 Umwandlung in Klein/Groûbuchstaben
        'u','U': ASCII 32-127, Umwandlung in Klein-/Groûbuchstaben
        'v','V': ASCII 32-255, Umwandlung in Klein-/Groûbuchstaben
        'w','W': ASCII 32-127
        'y','Y': ASCII 32-255

        Mit Hilfe des Eingabehandlers (s. Funktion ob_edit_handler) kînnen
        diese Masken beliebig erweitert und geÑndert werden.

    - kleiner/groûer System-Font kînnen in Eingabefeldern benutzt
      werden. UnterstÅtzt das AES auch nicht-proportionale GDOS-Fonts,
      so kînnen diese ebenfalls in Eingabefeldern verwendet werden.

    - ein Eingabefeld darf maximal MAX_EDIT-Zeichen lang werden (ansonsten
      muû die Konstante bei Bedarf in der Datei 'E_GEM.H' geÑndert und die
      Library neu Åbersetzt werden)

    - Eingabefelder dÅrfen einen Klammeraffen '@' am Anfang besitzen

 III. erweiterte Objekt-Typen sowie Resource-Aufbau:
=====================================================

    1. Debugging:
    -------------

    Wird die Library mit definiertem Konstanten-Makro DEBUG (s.a.
    Projekt-Datei 'E_GEM.PRJ' bzw. 'EGEMLGHT.PRJ') Åbersetzt, so gibt die
    Library Fehlermeldungen (Alert-Boxen) aus, wenn Fehler im Resource-
    Aufbau gefunden wurden (z.B. doppelt vergebene Hotkeys, mehr als ein
    Help-/Undo-/Escape/-Default-Button usw.). Dabei werden die Art des
    Fehlers und evtl. die Nummer des fehlerhaften Objekts ausgegeben.

    2. Highbyte des Objekt-Typs (s.a. STARTUP.RSC):
    -----------------------------------------------

        TriState-Checkboxen:
        --------------------

        Ist das Flag TOUCHEXIT bei einer Checkbox gesetzt, so kann die
        Checkbox noch einen dritten Zustand (neben selektiert und nicht
        selektiert) annehmen, bei dem das Innere der Checkbox mit einem
        grauen Muster gezeichnet wird. In diesem Zustand ist der Status
        CHECKED gesetzt.

        #define CHECKBOX        1   /* Check-Box */
        #define HEADER          2   /* öberschrift */
        #define RADIO           3   /* Radio-Button */
        #define UNDERLINE       4   /* Unterstrich */

        Hotkeys:
        --------
        (Indirekte) Hotkeys kînnen jedem Text-Objekt (G_STRING, G_TITLE,
        G_BUTTON, G_(F)TEXT, G_(F)BOXTEXT, G_BOXCHAR sowie erweitertem
        Attributtext ATTR_TEXT (Hotkey wird bei prop. Fonts nicht korrekt
        positioniert!)) zugeordnet werden. Hotkeys mÅssen dabei
        jeweils ein untergeordnetes Kind-Objekt des gewÅnschten Objekts
        sein.

        #define HOTKEY          5   /* Hotkey-Objekt */
        #define CHKHOTKEY       6   /* Check-Box mit Hotkey */
        #define RBHOTKEY        7   /* Radio-Button mit Hotkey */
        #define INDHOTKEY       8   /* Hotkey-Objekt einer Check-Box oder
                                       eines Radio-Buttons */
        #define FLYDIAL         9   /* Flugecke */
        #define TXTDEFAULT      10  /* Status des DEFAULT-Objekts ist von
                                       diesem Text-Objekt abhÑngig */
        #define USERFLY         11  /* beliebiges Flugobjekt */
        #define HELP_BTN        12  /* Help-Button */

        GDOS-Fonts:
        -----------

        Der erweiterte Objekttyp ATTR_TEXT unterstÅtzt auch die Ausgabe
        von beliebigen, u.a. proportionalen GDOS-Fonts unabhÑngig vom
        AES! Dabei mÅssen die Felder te_fontid, te_fontsize der
        TEDINFO-Struktur auf die ID und die Grîûe in Punkt des Fonts ge-
        setzt werden. Auûerdem muû das Feld te_font auf eine der fol-
        genden Konstanten gesetzt werden:

             #define GDOS_PROP    0 /* Speedo GDOS font */
             #define GDOS_MONO    1 /* Speedo GDOS font, monospace */
             #define GDOS_BITM    2 /* GDOS bit map font */

        Nach dem Initialisieren der Objekte durch fix_objects(), rsrc_calc()
        oder rsrc_init() ist der Objekttyp auf G_XTEXT und der Objekt-
        status auf NORMAL gesetzt sowie die Variable ob_spec der OBJECT-
        Struktur zeigt auf einen benutzerdefinierten Block USERBLK, dessen
        Parameter ub_parm auf folgende Struktur zeigt, welche mit den
        Werten aus der Resource-Datei initialisiert ist (ein evtl. vorhan-
        denes EDITABLE-Flag wird gelîscht, alle anderen Flags und Stati
        kînnen benutzt werden):

        X_TEXT-Struktur:
        ----------------

        typedef struct
        {
            /* Zeiger auf Text (sollte nur mit ob_get_text()/ob_set_text()
               gesetzt oder ermittelt werden) */
            char    *string;

            /* Font-ID, -hîhe (<0: in Punkt, >0: in Pixel) */
            int     font_id,font_size;

            /* Farbe (0-15, kann nachtrÑglich auf beliebige VDI-Farbe
               gesetzt werden) */
            int     color;

            /* Zentrierung des Textes (TE_LEFT,TE_CNTR,TE_RIGHT) */
            int     center;

            /* Schreibmodus (MD_REPLACE,MD_TRANS,MD_XOR,MD_ERASE) */
            int     mode;

            /* Bitmap der Text-Effekte (X_SHADOWED, X_TITLE, X_3D und
               X_INVERS schlieûen sich gegenseitig aus!) */
            int     effect;

                #define X_FAT           1   /* Fett SELECTED) */
                #define X_LIGHT         2   /* Hell (DISABLED) */
                #define X_ITALICS       4   /* Kursiv (CROSSED) */
                #define X_UNDERLINED    8   /* Unterstrichen (CHECKED) */
                #define X_OUTLINED      16  /* Umrandet (OUTLINED)*/
                #define X_SHADOWED      32  /* Schattiert (SHADOWED) */
                #define X_INVERS        64  /* Invers */
                #define X_3D            256 /* 3D (DRAW3D) */
                #define X_TITLE         512 /* Titel (WHITEBAK) */

            /* Alle weiteren Variablen dieser Struktur sind fÅr interne
               Zwecke reserviert! */
        } X_TEXT;

        #define ATTR_TEXT       13  /* Text mit Attributen */

        /* Cycle-Button, der vorrangig fÅr Popups benutzt wird, und
           optional schattiert ist (Status-Bit SHADOWED) */
        #define CYCLE_BUTTON    14  /* Cycle-Button */

        /* Pfeile, die hauptsÑchlich fÅr Slider benutzt werden, und
           optional umrandet sind (Status-Bit OUTLINED) */
        #define ARROW_LEFT      15  /* Pfeil links */
        #define ARROW_RIGHT     16  /* Pfeil rechts */
        #define ARROW_UP        17  /* Pfeil hoch */
        #define ARROW_DOWN      18  /* Pfeil runter */

        #define UNDO_BTN        19  /* Undo-Button */
        #define ESC_BTN         21  /* Escape-Button */

    Jedem Objekt kînnen die erweiterten Typen UNDO_BTN, HELP_BTN, ESC_BTN,
    HEADER und USERFLY zugeordnet werden, wobei bei HEADER-Objekten die Ein-
    stellungen (Funktion header_options) nur dann gelten, wenn es sich
    um ein G_(F)BOXTEXT oder G_(F)TEXT-Objekt handelt (bei Button-Objekten
    G_BUTTON wird nur die Ausrichtung gesetzt). Bei ATTR_TEXT sowie
    TXTDEFAULT muû es sich um ein Text-Objekt (auch G_STRING, G_TITLE und
    G_BUTTON), bei UNDERLINE sollte es sich um den Typ G_BOX handeln. Alle
    anderen erweiterten Typen sollten (mÅssen aber nicht) dem Typ G_BOXCHAR
    oder G_IBOX zugeordnet werden.

        #define G_UNMODAL   0x4000  /* unmodales Objekt */
        #define G_MODAL     0x8000  /* modales Objekt */

    ZusÑtzlich kînnen alle (!) Objekte durch Setzen von Bit 14 (G_UNMODAL)
    bzw. Bit 15 (G_MODAL) im Objekt-Typ (erweiterter Objekttyp mit 64 bzw.
    128 verodern) zu einem unmodalen oder modalen Objekt deklariert werden,
    welches nur in unmodalen bzw. modalen Dialogen erscheint.

    UnterstÅtzen die AES 3D-Effekte, so kînnen die entsprechenden Bits 9 u.
    10 in den Objekt-Flags weiterhin gesetzt werden. Die erweiterten Objekte
    unterstÅtzen bisher kein 3D, wobei aber durch die variable Optik der
    Images (Check-Box, Radio-Button, Arrows, Cycle-Buttons) und die ein-
    stellbaren Farben bei Bedarf auch 3D-Effekte erreicht werden kînnen. Bei
    allen anderen erweiterten Objekten ist ein 3D-Effekt ÅberflÅssig (z.B.
    bei Hotkeys, da diese unabhÑngig vom zugehîrigen Objekt gezeichnet wer-
    den, so daû das eigentliche Objekt im 3D-Look dargestellt werden kann)
    oder kann durch die Objekt-Flag-Bits erreicht werden (z.B. bei Rahmen-
    objekten (HEADER), s.a. Optionen edit_3d und draw_3d bei der Funk-
    tion dial_colors())

    Durch Setzen des Bits 7 (DRAW3D) im Objektstatus wird das entsprechende
    Objekt auf selektierten 3D-Look eingestellt, sofern 3D-Look vorhanden
    und die entsprechende Option der Funktion dial_colors() gesetzt ist.
    Ist kein 3D vorhanden, so wird das Objekt nicht verÑndert (funktioniert
    nur in Dialogen, die mit open_dialog() geîffnet werden, d.h. u.a. nicht
    in Popups).

    WICHTIG:
    --------
    Will man den Objekttyp ermitteln, so sollte man die Variable ob_type
    der OBJECT-Struktur mit der Konstante G_TYPE maskieren!

    Nach dem Initialisieren der Resource durch die Library werden der
    Objekttyp und teilweise das obere Byte des Objektstatus der erweiterten
    Objekte verÑndert. Ebenso zeigt ob_spec meistens auf den USERBLK des
    Objekts. Daher sollte man auf diese Variablen nicht mehr zugreifen,
    sofern die énderungen nicht dokumentiert sind (wie z.B. bei ATTR_TEXT)

    Weitere (Kombinations-) Mîglichkeiten s.a. Beispielprogramme sowie
    Startup-Resource (STARTUP.RSC).

    WICHTIG:
    --------
    Werden die Funktionen rsrc_calc() oder rsrc_init() mit der Grîûe des
    Entwurfsfonts aufgerufen, so SOLLTEN nur Pull-Down-MenÅs G_TITLE-
    Objekte enthalten. Ansonsten wird der Dialog normal vom AES an die
    Grîûe des System-Fonts skaliert.

 IV. Globale Variablen der Library:
====================================

    int _app;
        -> Programm wurde als Applikation (_app!=0) oder Accessory (_app==0)
           gestartet

    int ap_id:
        -> Applikationsidentifikation (RÅckgabewert von appl_init())
           oder negativer Wert, wenn AES-Initialisierung nicht erfolg-
           reich war

    int menu_id:
        -> Nummer des Eintrags im Accessory-MenÅ oder negativer Wert

    int menu_available;
        -> Anwendung darf eigene Drop-Down-MenÅleiste anmelden
           (menu_available!=0)

    int grhandle:
        -> Handle der AES-Workstation (RÅckgabewert von graf_handle)

    int x_handle:
        -> Handle der Library-Workstation

    int work_out[57];
       -> Ausgabefeld vom ôffen der virtuellen internen Workstation

    int ext_work_out[57];
       -> erweitertes Ausgabefeld (s. Funktion vq_extnd())

    int gr_cw,gr_ch:
        -> Breite/Hîhe des System-Zeichensatzes (IBM) in Pixel

    int gr_bw,gr_bh:
        -> Breite/Hîhe eines Rechtecks, das jedes einzelne Zeichen
           des System-Zeichensatzes (IBM) vollstÑndig umgibt.

    int gr_sw,gr_sh:
        -> Breite/Hîhe des kleinen System-Zeichensatzes (SMALL) in Pixel

    int ibm_font,ibm_font_id;
        -> Hîhe des System-Zeichensatzes (IBM) in Pixel sowie Font-ID

    int small_font,small_font_id;
        -> Hîhe des kleinen System-Zeichensatzes (SMALL) in Pixel
           sowie Font-ID

    int speedo:
        -> FSM-GDOS (1), Speedo-GDOS (2), Speedo 5.0/NVDI 3.0 (3)
           oder keine Vektorfonts (0)

    int fonts_loaded;
        -> Anzahl der ZeichensÑtze (GDOS-Fonts u. System-Fonts) der
           internen Library-Workstation

    int max_w,max_h:
        -> Breite/Hîhe des Bildschirms in Pixel

    int planes, colors:
        -> Anzahl der Farbebenen sowie gleichzeitig darstellbaren
           Farben

    int colors_available;
        -> Anzahl der Farbabstufungen der Farbpalette
           (2: monochrom, 0: mehr als 32767 Farben)

    MFDB *screen;
        -> Memory Form Definition Block des Bildschirms

    GRECT desk;
    VRECT clip;
        -> Ausmaûe des Desktop-Fensters als GRECT bzw. VRECT

    int aes_version:
        -> AES-Versionsnummer

    int multi:
        -> AES-Multitasking-Betriebssystem vorhanden

    int mtos:
        -> Multi-TOS vorhanden (mtos!=0)

    int magx:
        -> Versionsnummer von MagiC ab Version 2.00

    int winx:
        -> Versionsnummer von Winx ab Version 2.10

    int mint:
        -> MiNT-Versionsnummer

    unsigned int gemdos_version:
        -> Versionsnummer des GEMDOS in korrekter Reihenfolge
           (High- und Lowbyte des RÅckgabewerts von Sversion() vertauscht)
           High-Byte: Haupt-Revision, Low-Byte: Unter-Revision

    int has_3d;
        -> AES-3D-Effekte (Bits 9/10 der Objekts-Flags) sind vorhanden

    int search:
        -> appl_search()-Funktion vorhanden

    int bevent,bottom,owner;
        -> wind_get/wind_set-Modi WF_BEVENT, WF_BOTTOM und WF_OWNER sind
           vorhanden

    int AvServer;
        -> Applikations-ID des AV-Protokoll-Servers oder negativer Wert

    OBJECT *iconified;
        -> Zeiger auf Objektbaum, der fÅr die Darstellung von ikonifizierten
           Fenstern benutzt wird (ansonsten weiûer Hintergrund des Fensters,
           falls Zeiger nicht gesetzt wurde)

    DIAINFO *FSelDialog;
        -> Zeiger auf DIAINFO-Struktur des Fontselector-Dialogs, sofern
           dieser geîffnet ist (ansonsten NULL). Dadurch kann man notwendige
           Informationen Åber den Dialog, den Objektbaum oder das Fenster
           ermitteln.

 V. Funktionen, Strukturen und Konstanten der Library:
=======================================================

    1. Routinen zur Verwaltung des Cookie-Jars
       ---------------------------------------

        COOKIE-Struktur:
        ----------------
            typedef struct
            {
                long    cookie_id;      /* ID des Cookies */
                long    cookie_value;   /* Wert des Cookies */
            } COOKIE;

        void create_cookie(COOKIE *cookie,long id,long value);
            -> Cookie 'cookie' wird mit der Identifikation 'id' und
               dem Wert 'value' initialisiert

        boolean new_cookie(COOKIE *cookie);
            -> Cookie 'cookie' in Cookie-Jar einfÅgen (RÅckgabewert
               gleich FALSE, falls Cookie-Jar nicht existiert oder
               keine freien EintrÑge mehr vorhanden sind)

        boolean get_cookie(long id,long *value);
            -> Cookie mit der Identifikation 'id' im Cookie-Jar suchen
               und Wert gegebenenfalls in der Variable '*value' sichern
               (sofern value!=NULL)
            -> RÅckgabewert ungleich FALSE, wenn Cookie gefunden wurde

        void remove_cookie(long id);
            -> Cookie mit der Identifikation 'id' aus dem Cookie-Jar
               entfernen

        void move_cookiejar(long *new_cookie_jar,long size);
            -> neuen Cookie-Jar 'new_cookie_jar' mit Platz fÅr 'size'
               EintrÑge anlegen und alten Cookie-Jar gegebenfalls
               kopieren
            -> neuer Cookie-Jar muû mindestens so viele EintrÑge wie
               der alte Cookie-Jar haben

        long cookie_size(void);
            -> Anzahl der maximalen EintrÑge im Cookie-Jar ermitteln

    2. Routinen zur Verwaltung des Environments
       ----------------------------------------

        char *getenv(const char *entry);
            -> Variable 'entry' im Environment suchen und im Erfolgsfall
               Zeiger auf Wert der Variable zurÅckgeben (ansonsten NULL)

        int putenv(const char *entry);
            -> Zeichenkette 'entry' ins Environment einfÅgen
            -> RÅckgabewert ungleich Null im Erfolgsfall

    3. Erweiterte Objekt-Routinen (u.a. kompatibel zum PC-GEM 2.0)
       -----------------------------------------------------------

        WICHTIG:
        Werden Objekte Åber die AES-Funktionen objc_draw bzw. objc_change
        ausgegeben, so dÅrfen diese in keinem Dialog enthalten sein und es
        darf sich nicht um erweiterte Objekte handeln! Auûerdem sollte immer
        ein Begrenzungsrechteck (z.B. Desktopbereich) angegeben werden!

        void ob_dostate(OBJECT *tree,int object,int masc);
            -> einzelne Bits 'masc' des Objektstatus des Objekts 'object'
               im Baum 'tree' durch Veroderung setzen

        void ob_undostate(OBJECT *tree,int object,int masc);
            -> einzelne Bits 'masc' des Objektstatus des Objekts 'object'
               im Baum 'tree' durch Maskierung lîschen

        int ob_isstate(OBJECT *tree,int object,int masc);
            -> Bits 'masc' im Objektstatus des Objekts 'object' im Baum
               'tree' testen
            -> RÅckgabewert:
               TRUE (1):  alle Bits gesetzt
               FALSE (0): Bits (teilweise) nicht gesetzt

        void ob_setstate(OBJECT *tree,int object,int state);
            -> Objektstatus des Objekts 'object' im Baum 'tree' auf den
               Wert 'state' setzen

        void ob_select(DIAINFO *info,OBJECT *tree,int object,int select,
                       int draw)
            -> Objekt 'object' im Baum 'tree' selektieren (select!=0) oder
               deselektieren (select==0) und evtl. neuzeichnen (draw!=0).
               Gehîrt der Objektbaum zu einem geîffneten Dialog, so sollte
               ein Zeiger auf die DIAINFO-Struktur des Dialogs Åbergeben
               werden, damit gegebenenfalls der Ausgabebereich korrekt be-
               rechnet werden kann.

        void ob_disable(DIAINFO *info,OBJECT *tree,int object,int disable,
                       int draw)
            -> Objekt 'object' im Baum 'tree' disablen (disable!=0) oder
               enablen (disable==0) und evtl. neuzeichnen (draw!=0).
               Gehîrt der Objektbaum zu einem geîffneten Dialog, so sollte
               ein Zeiger auf die DIAINFO-Struktur des Dialogs Åbergeben
               werden, damit gegebenenfalls der Ausgabebereich korrekt be-
               rechnet werden kann.

        void ob_hide(OBJECT *tree,int obj,int hide)
            -> Objekt 'obj' im Baum 'tree' verstecken (hide==0) oder
               anzeigen (hide!=0)

        void ob_doflag(OBJECT *tree,int object,int masc);
            -> einzelne Bits 'masc' der Objektflags des Objekts 'object'
               im Baum 'tree' durch Veroderung setzen

        void ob_undoflag(OBJECT *tree,int object,int masc);
            -> einzelne Bits 'masc' der Objektflags des Objekts 'object'
               im Baum 'tree' durch Maskierung lîschen

        int ob_isflag(OBJECT *tree,int object,int masc);
            -> Bits 'masc' der Objektflags des Objekts 'object' im Baum
               'tree' testen
            -> RÅckgabewert:
               TRUE (1):  alle Bits gesetzt
               FALSE (0): Bits (teilweise) nicht gesetzt

        void ob_setflags(OBJECT *tree,int object,int flags);
            -> Objektflags des Objekts 'object' im Baum 'tree' auf den
               Wert 'flags' setzen

        void ob_xywh(OBJECT *tree,int object,GRECT *rect);
            -> Ausmaûe und Koordinaten (relativ zur linken oberen Ecke
               des Åbergeordneten Objekts) des Objekts 'object' im Baum
               'tree' ermitteln und in der GRECT-Struktur 'rect' sichern

        void ob_pos(OBJECT *tree,int object,GRECT *rect);
            -> Ausmaûe und absolute Koordinaten des Objekts 'object' im
               Baum 'tree' ermitteln u. in der GRECT-Struktur 'rect' sichern

        char *ob_get_text(OBJECT *tree,int object,int clear);
            -> Zeiger auf den Text des Objekts 'object' im Baum 'tree'
               ermitteln und Text lîschen, sofern 'clear' ungleich Null
               (Funktion beachtet erweiterte Objekttypen (Attribut-Text)
                und funktioniert auch bei Icons (G_ICON))
            -> RÅckgabewert gleich NULL, wenn es sich um kein Text-Objekt
               handelt

        X_TEXT *get_xtext(OBJECT *tree,int object)
            -> Zeiger auf X_TEXT-Struktur des Attributtextes 'object'
               im Baum 'tree' ermitteln. Hierbei handelt es sich bisher
               nur um eine Makro-Funktion, d.h. es wird nicht geprÅft,
               ob es sich tatsÑchlich um ein Attributtext-Objekt handelt!

        void ob_set_text(OBJECT *tree,int object,char *text);
            -> Text des Objekts 'object' im Baum 'tree' auf 'text' setzen
               (Funktion beachtet erweiterte Objekttypen (Attribut-Text)
                und funktioniert auch bei Icons (G_ICON))

        void ob_set_cursor(DIAINFO *info,int obj,int index,int insert)
            -> Eingabecursor neu setzen/Eingabemodus umschalten
            -> Parameter: (negative Parameter (FAIL) verÑndern die
                           aktuellen Einstellungen (s. DIAINFO-Struktur,
                           di_ed_obj, di_ed_index, di_ed_insert) nicht)
               obj:    Objektnummer des neuen Eingabefelds
               index:  Cursorposition im Eingabefeld (wird automatisch
                       auf gÅltigen Wert gesetzt, so daû z.B. mit
                       index>=MAX_EDIT der Cursor ans Ende des Eingabe-
                       feldes gesetzt wird)
               insert: EinfÅge- (insert==TRUE) oder öberschreibenmodus
                       (insert==FALSE)

        void ob_clear_edit(OBJECT *tree)
            -> Text in allen Eingabefeldern des Baums 'tree' lîschen

        void ob_edit_init(DIAINFO *info,int first_edit)
            -> Eingabefelder des Dialogs 'info' intern neu initialisieren
               (NICHT lîschen!) und den Cursor in das Feld mit der Objekt-
               nummer 'first_edit' setzen. Ist der Parameter 'first_edit'
               kleinergleich Null, dann wird der Cursor entweder an seine
               ursprÅngliche Position gesetzt oder - wenn dies nicht mîg-
               lich ist - in das erste Eingabefeld des Dialogs.
               Diese Funktion muû aufgerufen werden, wenn der Status
               DISABLED, das Flag HIDETREE, die Variablen/Zeichenketten
               der TEDINFO-Strukturen, die Objektposition/-grîûe (auûer
               wenn diese durch eine Library-Funktion wie z.B.
               graf_set_slider()) verÑndert wurde) oder die Objektstruktur
               (z.B. Eingabefelder entfernt oder hinzugefÅgt) eines oder
               mehrerer Eingabefelder innerhalb eines geîffneten Dialogs
               geÑndert wurden.
               Allerdings darf diese Funktion nur fÅr Dialoge aufgerufen
               werden, in denen eine Ausgabe mîglich ist (s. Funktion
               get_dialog_info())

        void ob_edit_handler(boolean (*handler)(char valid,char input,
                             char *out))
            -> Handler fÅr GÅltigkeitsmasken in Eingabefeldern an-
               (handler!=NULL) oder abmelden (handler==NULL). Hierdurch
               kînnen neue GÅltigkeitsmasken implementiert sowie vor-
               handene geÑndert oder ergÑnzt werden.
            -> Parameter des Handlers:
                 valid: Zeichen aus der GÅltigkeitsmaske
                 input: Eingegebenes Zeichen
            -> RÅckgabewert:
                 TRUE:  Maske wurde bearbeitet (in *out wird das Zeichen,
                        welches eingefÅgt werden soll, oder Null, falls
                        kein Zeichen eingefÅgt werden soll, zurÅckgegeben)
                 FALSE: Maske wurde nicht bearbeitet und wird somit von
                        den normalen EGEM-Routinen bearbeitet

        int ob_set_hotkey(OBJECT *tree,int object,char hotkey);
            -> Hotkey des Objekts 'object' im Baum 'tree' auf den
               Buchstaben 'hotkey' setzen (Hotkey-Unterstrich wird
               automatisch angepaût) oder entfernen (hotkey=='\0')
            -> RÅckgabewert ungleich FALSE -> Hotkey konnte gesetzt werden

        char ob_get_hotkey(OBJECT *tree,int object);
            -> Hotkey des Objekts 'object' im Baum 'tree' ermitteln
            -> RÅckgabewert gleich Null, wenn kein Hotkey gesetzt war

        OBJECT *ob_copy_tree(OBJECT *tree)
            -> Erzeugt von dem Objektbaum 'tree' eine Kopie (z.B. damit
               man einen Dialog mehrmals îffnen kann), wobei u.a. auch die
               TEDINFO-Strukturen und alle Zeichenketten (auch erweiterter
               Attribut-Text (G_XTEXT/ATTR_TEXT)) kopiert werden. Alle
               anderen Zeiger (USERBLK, BITBLK, ICONBLK, CICONBLK) des
               Objektbaums zeigen weiterhin auf die Originalstrukturen!
               Wird die Kopie nicht mehr benîtigt, so sollte der angefor-
               derte Speicher (=der zurÅckgegebene Zeiger) durch die
               Funktion free() freigegeben werden.
            -> RÅckgabewert: Zeiger auf Kopie im Erfolgsfall oder NULL

        int ob_draw_chg(DIAINFO *info,int object,GRECT *area,int new_state);
            -> Objekt 'object' (und untergeordnete Objekte) des Dialogs
               'info' darstellen und gegebenenfalls Objektstatus Ñndern
               (new_state>=0, s. objc_change).
               Wird das Eingabefeld, in dem sich der Cursor befindet, ausge-
               geben, so wird der Cursor - sofern er vorher aktiviert war -
               anschlieûend an das Ende des Feldes gesetzt. Ist er nicht
               aktiv oder wird ein Åbergeordnetes Objekt des Eingabefeldes
               ausgegeben, so behÑlt der Cursor seinen aktuellen Status und
               seine Position.
            -> Begrenzung des Ausgabebereichs auf das Reckteck 'area' oder
               auf die Ausmaûe des Dialogs (area==NULL)
            -> RÅckgabewert:
                TRUE:  Okay
                FALSE: Objekt konnte nicht ausgegeben werden (z.B. Dialog
                       nicht geîffnet (info==NULL oder info->di_flag==CLOSED)
                       oder Ausgabe in Dialog nicht mîglich)
                FAIL:  Objekt-Status konnte nicht gesetzt werden

        int ob_draw(DIAINFO *info,int object)
            -> Objekt 'object' (und untergeordnete Objekte) des Dialogs
               'info' darstellen (verkÅrzter Aufruf von
               ob_draw_chg(info,object,NULL,FAIL))

        int ob_draw_list(DIAINFO *info,int *objects,GRECT *area);
            -> Liste von Objekten 'objects' (und untergeordnete Objekte)
               des Dialogs 'info' darstellen (Abbruch der Liste mit
               negativem Wert oder Null). Eingabecursorbehandlung s.
               Funktion ob_draw_chg().
            -> Begrenzung des Ausgabebereichs auf das Reckteck 'area' oder
               auf die Ausmaûe des Dialogs (area==NULL)
            -> Diese Funktion ist schneller als die einzelne Ausgabe
               von mehreren Objekten Åber ob_draw_chg()
            -> RÅckgabewert:
                TRUE:  Okay
                FALSE: Objekte konnten nicht ausgegeben werden (z.B. Dialog
                       nicht geîffnet (info==NULL oder info->di_flag==CLOSED)
                       oder Ausgabe in Dialog nicht mîglich)

        void ob_draw_dialog(OBJECT *tree,int x,int y,int w,int h);
            -> Dialog 'tree' zentrieren, Bildschirmbereich reservieren,
               eine sich îffnende Box von der Dialogmitte zu den
               Koordinaten (x,y,w,h) zeichnen (sofern Parameter x,y,w,h
               grîûer als Null sind) und Dialog darstellen

        void ob_undraw_dialog(OBJECT *tree,int x,int y,int w,int h);
            -> Eine sich schlieûende Box von den Koordinaten (x,y,w,h) zur
               Dialogmitte zeichnen (sofern Parameter x,y,w,h grîûer als
               Null sind) und Bildschirmbereich freigeben

        int ob_radio(OBJECT *tree,int parent,int object)
            -> Radio-Buttons innerhalb des Åbergeordneten Objekts 'parent'
               im Baum 'tree' auf neues Objekt 'object' (Index des
               Radio-Buttons, nicht Objekt-Nummer!) setzen bzw.
               aktuell gesetztes Objekt ermitteln (object<0)
            -> RÅckgabewert: Gesetztes Objekt

        int ob_get_parent(OBJECT *tree,int object);
            -> Elternobjekt des Objekts 'object' im Baum 'tree' ermitteln

    4. Erweiterte Rechteck-Routinen (u.a. kompatibel zum PC-GEM 2.0)
       -------------------------------------------------------------

        void rc_grect_to_array(GRECT *rect,int *array);
            -> Reckteck 'rect' in Koordinaten-Feld 'array' wandeln

        void rc_array_to_grect(int *array,GRECT *rect);
            -> Koordianten-Feld 'array' in Rechteck 'rect' wandeln

        int rc_copy(GRECT *src,GRECT *dst);
            -> Rechteck 'src' nach Rechteck 'dst' kopieren
            -> RÅckgabewert ist immer Null

        int rc_equal(GRECT *rect1,GRECT *rect1);
            -> Testet die Rechtecke 'rect1' und 'rect2' auf Gleichheit
               (RÅckgabewert ungleich Null)

        int rc_intersect(GRECT *src,GRECT *dst);
            -> schneidet das Rechteck 'src' mit dem Rechteck 'dst'
               und gibt den gemeinsamen Bereich in 'dst' zurÅck
            -> RÅckgabewert gleich Null, sofern die Rechtecke keinen
               gemeinsamen Bereich besitzen

        int rc_inside(int x,int y,GRECT *rect);
            -> Testet, ob die Koordinaten (x,y) im Rechteck 'rect'
               liegen (RÅckgabewert ungleich Null)

        WICHTIG:
        Alle rc_sc_()-Funktionen schalten weder die Maus an/aus noch
        setzen sie den wind_update()-Status! Auûerdem ist das Clipping
        grundsÑtzlich auf den Bildschirm eingestellt.

        RC_RECT-Struktur:
        -----------------

        typedef struct
        {
            /* Rechteck-Struktur gÅltig? (valid!=0) */
            int valid;

            /* Koordinaten des ursprÅnglichen Bildschirmrechtecks */
            GRECT   area;

            /* alle weiteren Variablen dieser Struktur sind nur fÅr INTERNE
               Zwecke */
        } RC_RECT;

        int rc_sc_save(GRECT *area,RC_RECT *rc)
            -> Bildschirmbereich 'area' in Rechteck-Struktur 'rc' sichern
            -> RÅckgabewert: (entsprechend rc->valid)
                TRUE:  Bereich konnte gesichert werden
                FALSE: Nicht genÅgend Speicher oder Bereich teilweise
                       auûerhalb des Bildschirms

        int rc_sc_freshen(int sx,int sy,RC_RECT *rc)
            -> Rechteck-Struktur 'rc' erneuern, d.h. Bildschirmbereich
               an den Koordinaten (sx,sy) in Puffer kopieren
            -> RÅckgabewert:
                TRUE:  Bereich konnte gesichert werden
                FALSE: Rechteck-Struktur nicht gÅltig oder Bereich
                       teilweise auûerhalb des Bildschirms

        int rc_sc_restore(int dx,int dy,RC_RECT *rc,int mode)
            -> Rechteck-Struktur 'rc' freigeben und/oder an Position
               (dx,dy) zurÅckkopieren
            -> Parameter 'mode':
                TRUE:  Bereich zurÅckkopieren und Speicher freigeben
                FALSE: Bereich nur zurÅckkopieren
                FAIL:  Nur Speicher freigeben
            -> RÅckgabewert:
                TRUE:  Alles in Ordnung
                FALSE: Rechteck-Struktur ungÅltig

        void rc_sc_copy(GRECT *src,int x,int y,int mode);
            -> Kopiert den Bildschirmbereich 'src' zu den Koordinaten
               (x,y) (Kopiermodus 'mode' s. vro_cpyfm)

        void rc_sc_clear(GRECT *rect);
            -> Lîscht den Bildschirmbereich 'rect'

        void rc_sc_invert(GRECT *rect);
            -> Invertiert den Bildschirmbereich 'rect'

        int rc_sc_scroll(GRECT *in_out,int dist_x,int dist_y,GRECT *out2)
            -> Rechteck 'in_out' um Distanz (dist_x,dist_y) verschieben
               und neuzuzeichnende Rechtecke in 'in_out' und 'out2'
               zurÅckgeben. Dabei wird automatisch der Bereich auf den
               Bildschirm beschrÑnkt. (diese Funktion ist die Grundlage
               der Funktion scroll_window())
            -> RÅckgabewerte:
               0 - kein Redraw nîtig
               1 - Rechteck 'in_out' muû neugezeichnet werden
               2 - Rechtecke 'in_out' und 'out2' mÅssen neugezeichnet
                   werden (nur bei diagonalem Scrolling)

    5. VDI-(Attribut-) und Clipping-Funktionen
       ---------------------------------------

        Hinweis:
        --------
        Das Clipping der internen Workstation ist normalerweise auf das
        Desktopfenster oder wÑhrend eines Redraws auf Bereiche der
        Rechteckliste eines Fensters gesetzt. GrundsÑtzlich ist der
        Ausgabebereich aber INNERHALB des Bildschirms!

        void vsf_aespattern(int handle, int x, int y, int pattern)
            -> an die Koordinaten (x,y) angepaûtes AES-FÅllmuster
               'pattern' (0-7) berechnen und als neues FÅllmuster der
               Workstation 'handle' setzen

        void vs_attr(void);
            -> wurden die Attribute der internen VDI-Workstation x_handle
               nicht Åber Library-Funktionen verÑndert, so muû diese
               Funktion sofort danach aufgerufen werden, um dies der
               Library mitzuteilen

        int v_set_font(int font_id)
            -> Zeichensatz mit der Font-ID 'font_id' einstellen
            -> RÅckgabewert: TatsÑchlich eingestellte Font-ID

        int v_set_point(int all,int height)
            -> Zeichenhîhe 'height' in Punkt einstellen. Zwischengrîûen
               kînnen bei Vektorfonts nur eingestellt werden, sofern der
               Parameter 'all' ungleich Null ist und die Library mit den
               Font-Funktionen Åbersetzt wurde (ohne SMALL_NO_FONT-Makro)
            -> RÅckgabewert: TatsÑchlich eingestellte Grîûe

        Hinweis:
        --------
        Wird fÅr einen Attribut-Parameter der folgenden Funktionen ein
        negativer Wert Åbergeben, so wird die Einstellung nicht geÑndert!

        void v_set_text(int font,int height,int color,int effect,
                        int rotate,int out[4])
            -> VDI-Text-Attribute der internen Workstation x_handle setzen:
               font:    Font-ID
               height:  Hîhe in Pixel (>0) oder in Punkt (<0, bei Vektor-
                        fonts auch Zwischengrîûen, sofern die Library
                        mit den Font-Funktionen (ohne SMALL_NO_FONT-Makro)
                        Åbersetzt wurde) (keine VerÑnderung bei 0)
               color:   Text-Farbe
               effect:  Text-Effekte
               rotate:  Text-Winkel in 1/10-Grad
               out:     Array fÅr RÅckgabewerte von vst_height/vst_point
                        oder NULL

        void v_set_mode(int mode);
            -> Grafikmodus der internen Workstation x_handle auf
               den Wert 'mode' (0-3) setzen

        void v_set_line((int color,int width,int type,int start,int end)
            -> VDI-Linien-Attribute der internen Workstation x_handle
               setzen:
               color: Linien-Farbe
               width: Linien-Dicke
               type:  Linien-Stil (benutzerdefiniertes Muster (type==7) muû
                      u.a. vor der Benutzung gesetzt werden!)
               start: Linien-Anfang
               end:   Linien-Ende

        void v_set_fill(int color,int interior,int style,int peri);
            -> VDI-FÅllmuster-Attribute der internen Workstation
               x_handle setzen:
               color:    FÅllmuster-Farbe
               interior: FÅllmuster-Typ (0-4, benutzerdefinierte Muster
                         mÅssen vor der Benutzung gesetzt werden!)
               style:    FÅllmuster-Stil
               peri:     Umrandung

        void v_aespattern(int x,int y,int pattern);
            -> an die Koordinaten (x,y) angepaûtes AES-FÅllmuster
               'pattern' (0-7) berechnen und als neues FÅllmuster der
               internen Workstation x_handle setzen

        void save_clipping(int *array);
            -> aktuellen Clipping-Bereich im Koordinaten-Feld 'array'
               sichern

        void restore_clipping(int *array);
            -> Clipping-Bereich auf Koordinaten-Feld 'array' setzen

        void v_line(int x1,int y1,int x2,int y2)
            -> Linie von den Koordinaten (x1,y1) zu den Koordinaten (x2,y2)
               entsprechend den Linien-Attributen der internen Workstation
               x_handle zeichnen

        void v_rect(int x1,int y1,int x2,int y2)
            -> Rechteck mit der linken oberen Ecke (x1,y1) und der rechten
               unteren Ecke (x2,y2) entsprechend den Linien-Attributen der
               internen Workstation x_handle zeichnen

    6. Erweiterte Scrap-Directory-Routinen
       -----------------------------------

        int scrp_path(char *path,char *file)
            -> vollstÑndigen Zugriffspfad der Clipboard-Datei 'file'
               (sofern file!=NULL) ermitteln. Wird fÅr den Parameter 'file'
               NULL Åbergeben, so wird nur der Clipboard-Pfad ermittelt.
            -> RÅckgabewert:
               TRUE:  Alles in Ordnung
               FALSE: Kein Clipboard-Pfad gesetzt

        void scrp_clear(int all);
            -> Alle Dateien (all!=0) oder nur die 'SCRAP.*'-Dateien
               im Scrap-Directory lîschen

        long scrp_length(void);
            -> Berechnung der LÑnge des Inhalts des Scrap-Directories

        int scrp_find(char *extensions,char *filename);
            -> Scrap-Directory (Clipboard) nach Scrap-Datei mit einer
               der durch Komma, Punkt oder Leerzeichen getrennten
               Erweiterungen 'extensions' durchsuchen, z.B.
               scrp_find("img.txt.asc.ps",scrap). Dabei wird die Liste
               von links nach rechts abgearbeitet.
            -> String 'filename' enthÑlt im Erfolgsfall (RÅckgabewert
               ungleich Null) den kompletten Pfad der gefundenen Datei

        void scrp_changed(int format,long best_ext);
            -> Clipboard-Inhalt wurde verÑndert (SC_CHANGED-Nachricht
               wird (per XAccBroadCast) an alle Applikationen gesendet),
               wobei nach dem Lîschen des Clipboards
               scrp_changed(SCF_INDEF,0l) aufgerufen werden sollte.
            -> format: Bitmap des Dateiformats

            #define SCF_INDEF   0x0000  /* undefiniert */
            #define SCF_DBASE   0x0001  /* Datenbank */
            #define SCF_TEXT    0x0002  /* Text */
            #define SCF_VECTOR  0x0004  /* Vektor-Grafik */
            #define SCF_RASTER  0x0008  /* Raster-Grafik */
            #define SCF_SHEET   0x0010  /* Tabellen-Kalkulation */
            #define SCF_SOUND   0x0020  /* Sound */

            -> best_ext: 4 Zeichen (z.B. ".RTF") fÅr die "beste" der
                         abgespeicherten Dateien

    7. Erweiterte Grafik-Routinen
       --------------------------

        Hinweis:
        --------
        Im Gegensatz zu den entsprechenden AES-Grafik-Funktionen blockieren
        die Echtzeit-Funktionen der Library die Ereignis-Auswertung nicht,
        so daû z.B. im Hintergrund weiterhin Timer-Ereignisse stattfinden
        kînnen.

        void graf_busy_mouse(void);
            -> Maus als rotierende Scheibe darstellen

        void graf_set_slider(SLINFO *slider,OBJECT *tree,int mode);
            -> Elemente des Sliders 'slider' im Baum 'tree' anhand der
               Werte der SLINFO-Struktur initialisieren und gegebenenfalls
               neuzeichnen. Dabei wird auch eine evtl. angegebene Funktion
               'sl_do' (s. SLINFO-Struktur) aufgerufen und die Position
               (sl_pos) auf gÅltige Werte gesetzt, sofern der Modus
               'GRAF_SET_SIZE_POS' gesetzt ist.
            -> mode: Bitmap der Initialisierung

            #define GRAF_SET_ARROWS     1
                -> Slider-Pfeile setzen
            #define GRAF_SET_SIZE_POS   2
                -> Grîûe/Position des Schiebers berechnen und setzen:

                   Ist die Seitengrîûe 'sl_page' grîûergleich des Maximal-
                   werts 'sl_max' des Schiebers, so wird die Grîûe des
                   Sliders auf die Grîûe des Elternobjekts gesetzt. Ist
                   'sl_page' kleinergleich 1, so wird die Grîûe auf den
                   'sl_max'-ten Bruchteil der Grîûe des Elternobjekts ge-
                   setzt. In allen anderen FÑllen wird die Grîûe des Sliders
                   aus dem VerhÑltnis der Seitengrîûe zum Maximalwert ge-
                   bildet.
                   Setzt man die minimale Grîûe auf die Grîûe des Eltern-
                   objekts, so kann man mit den Sliderfunktionen auch
                   automatische ZÑhlboxen realisieren (s. Beispielprogramm
                   'DialDemo')

            #define GRAF_SET            3
                -> wie GRAF_SET_ARROWS und GRAF_SET_SIZE_POS
            #define GRAF_DRAW_SLIDER    4
                -> Slider-Elemente zeichnen
            #define GRAF_DRAW           7
                -> wie GRAF_SET und GRAF_DRAW_SLIDER

        void graf_arrows(SLINFO *slider,OBJECT *tree,int draw);
            -> Pfeile des Sliders 'slider' im Baum 'tree' initialisieren
               und gegebenenfalls neuzeichnen (draw!=0)

        void graf_rt_slidebox(SLINFO *slider,int object,int double_click,
                              int pos,int cursor);
            -> Echtzeitslider auswerten und darstellen (diese Routine wird
               intern automatisch aufgerufen, wenn die SLINFO-Strukturen
               bei open_dialog() Åbergeben wurden)
            -> Parameter:
                slider: Zeiger auf SLINFO-Struktur des Sliders

                #define HOR_SLIDER      0   /* horizontaler Slider */
                #define VERT_SLIDER     1   /* vertikaler Slider */

                #define SL_STEP         0   /* Einzelschritt */
                #define SL_LINEAR       1   /* linear */
                #define SL_LOG          2   /* logarithmisch */
                #define SL_EXP          3   /* exponential */

                SLKEY-Struktur:
                ---------------

                typedef struct
                {
                    /* Scan-Code des Ereignisses
                       Highbyte: Scan-Code oder Null
                       Low-Byte: ASCII-Code oder Null */
                    int     scan;

                    /* Sondertastenstatus (K_SHIFT ist dabei eine
                       AbkÅrzung fÅr (K_RSHIFT|K_LSHIFT)) */
                    int     state;

                    /* Slider-Kommando (s. Beschreibung des
                       Parameters 'object')
                    int     cmd;
                } SLKEY;

                SLINFO-Struktur:
                ----------------

                typedef struct
                {
                    /* Zeiger auf DIAINFO-Struktur des Dialogs. Wenn die
                       SLINFO-Struktur bei open_dialog() Åbergeben wird,
                       dann muû diese Variable nicht initialisiert werden,
                       d.h. wird automatisch (zurÅck-) gesetzt. Ansonsten
                       sollte man die Variable auf NULL setzen, wenn der
                       Dialog geschlossen ist, v.a. wenn die SLINFO-
                       Struktur in diesem Fall noch benutzt wird. */
                    DIAINFO *sl_info;

                    /* Nummer des Ausgabe-Objekts (z.B. Liste mit EintrÑgen)
                       oder negativer Wert, falls nicht vorhanden oder
                       manuelle Ausgabe. Wird das Ausgabeobjekt angegeben,
                       so wird der Bereich bei einer VerÑnderung der Slider-
                       position automatisch gescrollt und aktualisiert
                       (siehe z.B. Hilfe-Fenster im Beispielprogramm
                        'DialDemo') */
                    int     sl_view;

                    /* Breite/Hîhe einer Spalte/Zeile in Pixel (wird fÅr
                       den Cursor und das Ausgabeobjekt benîtigt) */
                    int     sl_line;

                    /* Nummer des Elternobjekts */
                    int     sl_parent;

                    /* Objektnummer des Schiebers (einzige Bedingung
                       ist, daû der Schieber sich komplett innerhalb
                       des Elternobjekts befindet. Ansonsten ist der
                       Aufbau (Objekt-Typen, Grîûen, Existenz) eines
                       Echtzeitschiebers beliebig) */
                    int     sl_slider;

                    /* Minimale Grîûe des Schiebers (wird gegebenenfalls
                       auf Grîûe einer Zeichenbox hochgesetzt) */
                    int     sl_min_size;

                    /* Objektnummern der Pfeile oder negative Werte */
                    int     sl_dec,sl_inc;

                    /* Position, SeitenlÑnge (>=1) und Maximalwert des
                       Schiebers. Die Position kann die Werte von 0 bis
                       max(sl_max-sl_page,0) durchlaufe */
                    int     sl_pos,sl_page,sl_max;

                    /* Position des Cursors oder negativer Wert, falls keine
                       Cursor-Verwaltung gewÅnscht. Dabei werden von der
                       Library nur die Position automatisch verwaltet u. die
                       entsprechenden Bereiche des Ausgabeobjekts neu ausge-
                       geben (u.a. Scrolling, falls Cursor an den Rand des
                       Ausgabeobjekts kommt). Der Cursor kann dabei die
                       Werte von 0 bis max(sl_max-1,0) durchlaufen.
                       Ob und wie der Cursor dargestellt wird, bleibt dem
                       Programmierer Åberlassen.
                       WICHTIG:
                       FÅr die Cursorverwaltung mÅssen die Variablen
                       sl_view und sl_line ebenfalls gesetzt sein! */
                    int     sl_cursor;

                    /* Richtung des Sliders: */
                    char    sl_vh;      /* HOR_SLIDER,VERT_SLIDER */

                    /* Wiederholungs-Modus der Pfeile */
                    char    sl_mode;    /* SL_STEP,SL_LINEAR,SL_LOG,SL_EXP */

                    /* Verzîgerungsdauer in Milisekunden vor und wÑhrend der
                       Wiederholung */
                    int     sl_delay,sl_speed;

                    /* Zeiger auf Routine (oder NULL), welche nach jeder
                       VerÑnderung der Sliderposition (sl_pos) oder Cursor-
                       position (sl_cursor) bzw. bei vollautomatischen
                       Slidern in der Initialisierung aufgerufen wird */
                    void    (*sl_do)(SLINFO *sl,OBJECT *tree,
                                     int pos,int prev,int max_pos,
                                     int cursor,int prev_crs);
                    /* sl:      Zeiger auf SLINFO-Struktur des Sliders
                                (bei geschlossenem Dialog ist sl->sl_info
                                 ein NULL-Pointer!)
                       tree:    Zeiger auf Slider-Baum
                       pos:     aktuelle Position des Schiebers
                       prev:    vorherige Position des Schiebers
                       max_pos: maximale Position des Schiebers
                       cursor:  aktuelle Position des Cursors (negativer
                                Wert bedeutet, daû der Cursor inaktiv ist)
                       prev_crs:vorherige Position des Cursors */

                    /* Zeiger auf Feld mit Slider-Hotkeys oder NULL (wird
                       nur ausgewertet, wenn die SLINFO-Struktur bei
                       open_dialog() Åbergeben wurde) */
                    SLKEY   *sl_keys;

                    /* Anzahl der Hotkeys im Feld 'sl_keys' */
                    int     sl_keys_cnt;
               } SLINFO;

               object: angeklicktes Objekt oder eines der folgenden
                       Kommandos:

                        #define SL_UP       -1  /* Zeile/Spalte hoch */
                        #define SL_DOWN     -2  /* Zeile/Spalte runter */
                        #define SL_PG_UP    -3  /* Seite hoch */
                        #define SL_PG_DN    -4  /* Seite runter */
                        #define SL_START    -5  /* Slider-Anfang */
                        #define SL_END      -6  /* Slider-Ende */
                        #define SL_CRS_UP   -7  /* Cursor eine Zeile/Spalte
                                                   nach oben */
                        #define SL_CRS_DN   -8  /* Cursor eine Zeile/Spalte
                                                   nach unten */
                        #define SL_SET      -9  /* Slider- und Cursorposi-
                                                   tion auf Werte 'pos' und
                                                   'cursor' setzen */

               double_click: Objekt wurde per Doppelklick angeklickt
               pos,cursor:   neue Slider- und Cursorpositionen fÅr das
                             Kommando 'SL_SET'. Dabei wird der Anzeige-
                             bereich und der Cursor gegebenenfalls automa-
                             tisch neugzeichnet.

        void graf_rt_slidecursor(SLINFO *slider,int exit)
            -> automatische Positionierung des Slidercursors (sl_cursor)
               und evtl. Scrolling des Sliders 'slider' in AbhÑngigkeit von
               der Mausposition.
               Der Cursor wird auf das Objekt unter dem Mauszeiger gesetzt
               und wenn der Mauszeiger den Bereich des Sliders (sl_view-
               Objekt) verlÑût, dann wird der Slider automatisch gescrollt.
               Abgebrochen wird die Funktion, sobald die Maustaste losge-
               lassen wird oder nach dem ersten Setzen des Cursors, sofern
               exit!=0 ist.

        int graf_rt_rubberbox(int desk_clip,int s_x,int s_y,
                              int min_w,int min_h,GRECT *rect,int *w,int *h,
                              void (*box_do)(boolean draw,int *array,
                                             MKSTATE *mk));
            -> Echtzeitgummiband innerhalb des Rechtecks 'rect' mit den
               Start-Koordinaten (s_x,s_y) darstellen und auswerten (bei
               einer gedrÅckten Sondertaste (Shift, Alternate oder Control)
               wird ein quadratisches Gummiband aufgezogen).
               Wird die Funktion bei gedrÅckter linker oder rechter Maus-
               taste aufgerufen, so wird das Rechteck wÑhrend des GedrÅckt-
               haltens aufgezogen. Ist keine Maustaste beim Aufruf der Funk-
               tion gedrÅckt, so wird das Rechteck durch einen Mausklick
               bestÑtigt.
            -> Parameter:
               desk_clip:   Ist dieser Paramter gesetzt und eine Ausgabe auf
                            dem Desktop mîglich, so wird das Rechteck nur im
                            Desktopbereich - ansonsten im Vordergrund - aus-
                            gegeben
               min_w,min_h: Minimale Breite/Hîhe des Rechtecks (bei nega-
                            tiven Werten kann das Rechteck in jede Richtung
                            aufgezogen werden)
               box_do:      Zeiger auf eine Funktion (oder NULL), welche
                            nach jeder VerÑnderung des Rechtecks aufgerufen wird.
                            Dadurch kînnen z.B. Icons innerhalb des Recht-
                            ecks selektiert werden.
                            Parameter:
                            draw:  Rechteck wird gerade gezeichnet (TRUE)
                                   oder gelîscht (FALSE)
                            array: Zeiger auf das Koordinaten-Array des
                                   Rechtecks (entspricht Zeiger auf eine
                                   GRECT-Struktur)
                            mk:    Zeiger auf MKSTATE-Struktur, welche
                                   Informationen Åber die Maus und die
                                   Umschalttasten enthÑlt
            -> RÅckgabewert:
               TRUE:  Rechteck wurde aufgezogen
                      *w,*h: Breite/Hîhe des Rechtecks
               FALSE: Rechteck konnte nicht aufgezogen werden (z.B.
                      Startkoordinaten auûerhalb des Begrenzungsrechtecks)
               FAIL:  wie TRUE, nur daû die Funktion per Rechtsklick ab-
                      gebrochen wurde

        int graf_rt_dragbox(int desk_clip,GRECT *start,GRECT *bound,
                            int *x,int *y,
                            void (*box_do)(boolean draw,int *array,
                                           MKSTATE *mk));
            -> Verschieben des Rechtecks 'start' innerhalb des grîûeren
               Begrenzungsrechtecks 'bound'.
               Wird die Funktion bei gedrÅckter linker oder rechter Maus-
               taste aufgerufen, so wird das Rechteck wÑhrend des GedrÅckt-
               haltens verschoben. Ist keine Maustaste beim Aufruf der Funk-
               tion gedrÅckt, so wird das Rechteck durch einen Mausklick
               positioniert.
            -> Parameter:
               desk_clip: Ist dieser Paramter gesetzt und eine Ausgabe auf
                          dem Desktop mîglich, so wird das Rechteck nur im
                          Desktopbereich - ansonsten im Vordergrund - aus-
                          gegeben
               box_do:    Zeiger auf eine Funktion (oder NULL), welche nach
                          jeder VerÑnderung des Rechtecks aufgerufen wird.
                          Dadurch kînnen z.B. Icons unterhalb des Recht-
                          ecks selektiert werden.
                          Parameter:
                          draw:  Rechteck wird gerade gezeichnet (TRUE) oder
                                 gelîscht (FALSE)
                          array: Zeiger auf das Koordinaten-Array des Recht-
                                 ecks (entspricht Zeiger auf eine
                                 GRECT-Struktur)
                          mk:    Zeiger auf MKSTATE-Struktur, welche Infor-
                                 mationen Åber die Maus und die Umschalt-
                                 tasten enthÑlt
            -> RÅckgabewert:
               TRUE:  Rechteck wurde verschoben
                      *x/*y: Koordinaten des Rechtecks
               FALSE: Rechteck konnte nicht verschoben werden (z.B.
                      Rechteck grîûer als Begrenzungsrechteck)
               FAIL:  wie TRUE, nur daû die Funktion per Rechtsklick ab-
                      gebrochen wurde

        void graf_rt_lines(int *objects,boolean close)
            -> mehrere graue Objektrahmen (diese sollten nur aus horizon-
               talen und vertikalen Linien bestehen) im XOR-Modus zeichnen.
               Die Funktion schaltet weder die Maus aus/ein noch setzt sie
               den wind_update()-Status! Ebenso werden die Objektrahmen im
               aktuellen Clippingbereich der internen VDI-Workstation
               x_handle gezeichnet.
            -> Parameter:
               close:   evtl. nicht geschlossene Objekte werden automatisch
                        geschlossen (close==TRUE)
               objects: Aufbau des Arrays:
                        Zuerst kommt ein Integerwert, der die Anzahl der
                        folgenden Koordinaten des Objekts angibt oder ein
                        Wert kleinergleich Null fÅr das Ende der Liste.
                        Anschlieûend folgen die Koordinaten (jeweils 2
                        Integerwerte). Danach folgt das nÑchste Objekt usw.

        int graf_rt_dragobjects(int desk_clip,int *objects,GRECT *bound,
               void (*object_do)(boolean draw,int *objects,MKSTATE *mk));
            -> Verschieben der Objekte 'objects' (Aufbau des Array s.
               Funktion graf_rt_lines) innerhalb des Begrenzungsrechtecks
               'bound'.
               Wird die Funktion bei gedrÅckter linker oder rechter Maus-
               taste aufgerufen, so werden die Objekte wÑhrend des GedrÅckt-
               haltens verschoben. Ist keine Maustaste beim Aufruf der Funk-
               tion gedrÅckt, so werden die Objekte durch einen Mausklick
               positioniert.
            -> Parameter:
               desk_clip: Ist dieser Paramter gesetzt und eine Ausgabe auf
                          dem Desktop mîglich, so werden die Objekte nur im
                          Desktopbereich - ansonsten im Vordergrund - aus-
                          gegeben
               objects_do:Zeiger auf eine Funktion (oder NULL), welche nach
                          jeder PositionsverÑnderung der Objekte aufgerufen
                          wird. Dadurch kînnen z.B. Icons unterhalb der
                          Objekte/des Mauszeigers selektiert werden.
                          Parameter:
                          draw:    Objekte werden gerade gezeichnet (TRUE)
                                   oder gelîscht (FALSE)
                          objects: Zeiger auf das Objekt-Array (die
                                   Koordinaten werden automatisch angepaût)
                          mk:      Zeiger auf MKSTATE-Struktur, welche
                                   Informationen Åber die Maus und die Um-
                                   schalttasten enthÑlt
            -> RÅckgabewert:
               TRUE:  Objekte wurden verschoben (Array 'objects' enthÑlt
                      die neuen Objektkoordinaten)
               FALSE: Objekte konnten nicht verschoben werden (z.B.
                      Ausmaûe der Objekte grîûer als Begrenzungsrechteck)
               FAIL:  wie TRUE, nur daû die Funktion per Rechtsklick ab-
                      gebrochen wurde

    8. MenÅ-Funktionen
       ---------------

        WICHTIG:
        --------
        Alle MenÅ-Funktionen, bei denen kein Zeiger auf den Objektbaum
        Åbergeben wird, funktionieren nur, wenn vorher eine MenÅ-Leiste
        per menu_install() angemeldet wurde! Ansonsten mÅssen die
        entsprechenden AES-Funktionen benutzt oder die Objekt-Attribute
        direkt manipuliert werden.
        Unter MultiTasking wird beachtet, welcher Applikation die MenÅ-
        leiste gehîrt, um unnîtige Prozeûumschaltungen zu verhindern.

        int menu_install(OBJECT *menu,int show);
            -> MenÅ-Leiste 'menu' darstellen (show!=0) oder lîschen
               (show==0). Diese Funktion berÅcksichtigt, ob gegebenenfalls
               auch ein Accessory eine MenÅ-Leiste besitzen darf und ini-
               tialisiert die MenÅ-Punkte 'Fenster wechseln' und 'Fenster
               schlieûen'
            -> RÅckgabewert wie bei 'menu_bar'

        void menu_enable(boolean enable);
            -> MenÅ-Leiste aktivieren (enable==TRUE) bzw. deaktivieren
               (enable==FALSE) und neuzeichnen.

        void menu_item_enable(int object,int enable)
            -> MenÅ-Eintrag 'object' aktivieren (enable!=0) oder
               deaktivieren (enable==0)

        void menu_select(int title,int select)
            -> MenÅ-Titel 'title' normal (select==0) oder invers
               (select!=0) darstellen

        boolean menu_dropped();
            -> Testen, ob ein Drop-Down-MenÅ der MenÅleiste heruntergeklappt
               ist

        MITEM-Struktur:
        ---------------

        typedef struct
        {
            /* Objektnummer des entsprechenden MenÅeintrages oder
               negativer Wert, falls nicht vorhanden */
            int menu;

            /* Scan-Code des Hotkeys:
               Highbyte: Scan-Code oder Null
               Lowbyte:  ASCII-Code oder Null */
            int scan;

            /* Sondertastenstatus (K_SHIFT ist dabei eine AbkÅrzung fÅr
               (K_RSHIFT|K_LSHIFT)) */
            int state;

            /* gewÅnschtes Fensterkommando (mîgliche Werte siehe Kommandos
               der Funktionen WindowHandler und scroll_window (letzteres
               nur, falls Library nicht mit SMALL_NO_SCROLL Åbersetzt
               wurde)) */
            int mode;

            int msg; /* reserviert (0) */
        } MITEM;

        void MenuItems(MITEM *close,MITEM *closeall,
                       MITEM *cycle,MITEM *invcycle,MITEM *globcycle,
                       MITEM *full,MITEM *bottom,
                       MITEM *iconify,MITEM *iconify_all,
                       MITEM *menu,int menu_cnt)
            -> Hotkeys und MenÅpunkte fÅr verschiedene Fenster-Funktionen
               definieren. Wird fÅr einen MITEM-Zeiger ein NULL-Pointer
               Åbergeben, so werden die vordefinierten Hotkeys/Kommandos
               verwendet. Die jeweiligen MenÅpunkte werden entsprechend
               dem Kommando und der Anzahl der geîffneten Fenster (de-)
               aktiviert und die dazugehîrigen Aktionen (Auswahl des
               MenÅpunkts oder Tastendruck) automatisch ausgewertet. öber-
               gibt man fÅr einen Parameter eine MITEM-Struktur, deren
               Elemente alle auf Null gesetzt sind, so ist die zugehîrige
               Funktion inaktiv.
            -> Parameter:
               close:       MITEM-Struktur fÅr MenÅpunkt 'Fenster schlieûen'
                            (voreingestell: CTRL-U, Kommando W_CLOSE)
               closeall:    MITEM-Struktur fÅr MenÅpunkt 'Alle Fenster
                            schlieûen' (voreingestellt: CTRL-SHIFT-U,
                            Kommando W_CLOSEALL)
               cycle:       MITEM-Struktur fÅr MenÅpunkt 'Fenster wechseln'
                            (voreingestellt: CTRL-W, Kommando W_CYCLE)
               invcycle:    MITEM-Struktur fÅr MenÅpunkt 'Fenster invers
                            wechseln' (voreingestellt: CTRL-SHIFT-W,
                            Kommando W_INVCYCLE)
               globcycle:   MITEM-Struktur fÅr MenÅpunkt 'Fenster global
                            wechseln' (voreingestellt: ALT-CTRL-W,
                            Kommando W_GLOBALCYCLE)
               full:        MITEM-Struktur fÅr MenÅpunkt 'Volle Grîûe'
                            (voreingestellt: CTRL-#*, Kommando W_FULL)
               bottom:      MITEM-Struktur fÅr MenÅpunkt 'In Hintergrund
                            legen' (voreingestellt: CTRL-#/,
                            Kommando W_BOTTOM)
               iconify:     MITEM-Struktur fÅr MenÅpunkt 'Fenster ikonifi-
                            zieren' (voreingestellt: CTRL-Space,
                            Kommando W_ICONIFY)
               iconify_all: MITEM-Struktur fÅr MenÅpunkt 'Alle Fenster iko-
                            nifizieren' (voreingestellt: CTRL-SHIFT-Space),
                            Kommando W_ICONIFYALL)
               menu:        reserviert (NULL)
               menu_cnt:    reserviert (0)

    9. Dialog-Optionen und -optik setzen
       ---------------------------------

        void dial_colors(int dial_pattern,int dial_color,int dial_frame
                         int hotkey,int alert,int cycle_button,
                         int check_box,int radio_button,int arrow,
                         int cycle_backgrnd,int check_backgrnd,
                         int radio_backgrnd,int arrow_backgrnd,
                         int edit_3d,int draw_3d)
            -> Dialog-Optik setzen. Unter neueren AES-Versionen mit 3D-Look
               sollte man die AES-3D-Farben verwenden, indem man fÅr den
               Parameter dial_color einen negativen Wert Åbergibt.
               Die Parameter dial_pattern, cycle_backgrnd, check_backgrnd,
               radio_backgrnd und arrow_backgrnd werden dann automatisch ge-
               setzt, sofern man fÅr diese einen negativen Wert Åbergibt.

               @{B}Hinweis:@{0}
               Hintergrundfarbe u. -muster des Dialogs sowie 3D-Optionen
               gelten nur fÅr die Dialoge, die nach dem Aufruf dieser Funk-
               tion geîffnet werden, wÑhrend alle anderen Einstellungen ab
               sofort gelten, d.h. ab dem nÑchsten Neuzeichnen der ent-
               sprechenden Objekte.
               Auûerdem kînnen nur die 16 AES-Farben verwendet werden.

               dial_pattern:   Hintergrundmuster des Dialogs (0-7)
               dial_color:     Hintergrundfarbe des Dialogs
               dial_frame:     Farbe des Dialograhmens
               hotkey:         Farbe des Hotkey-Unterstrichs
               alert:          Farbe des Alert-Icons
               cycle_button:   Cycle-Button-Farbe
               check_box:      Checkbox-Farbe
               radio_button:   Radio-Button-Farbe
               arrow:          Slider-Arrow-Farbe
               cycle_backgrnd: Cycle-Button-Hintergrundfarbe
               check_backgrnd: Checkbox-Hintergrundfarbe
               radio_backgrnd: Radio-Button-Hintergrundfarbe
               arrow_backgrnd: Slider-Arrow-Hintergrundfarbe
               edit_3d:        Eingabefelder automatisch auf selektierten
                               3D-Look bei vorhandenem AES-3D-Look setzen
                               und OUTLINED-Status lîschen, wenn entweder
                               das Eingabefeld einen Rahmen besitzt oder
                               mehr als 4 Farben verfÅgbar sind.
               draw_3d:        Objekte mit gesetztem DRAW3D-Status bei vor-
                               handenem AES-3D-Look auf selektierten
                               3D-Look setzen.

        void dial_options(boolean round,boolean niceline,boolean standard,
                          boolean return_default,boolean background,
                          boolean nonselectable,boolean always_keys,
                          boolean toMouse,boolean clipboard,int hz);
            -> verschiedene Optionen setzen:
               round:          Dialogpositionen und Fensterpositionen
                               auf Bytegrenzen (aus Geschwindigkeits-
                               grÅnden) runden
               niceline:       Niceline fÅr Trennstriche in MenÅs/Popups
               standard:       gewîhnliche GEM-Optik bei Checkboxen, Slider-
                               Pfeilen und Cycle-Buttons verwenden (kann
                               auch durch die Verwendung normaler Objekte
                               im Resource oder durch entsprechende Button-
                               Images erreicht werden)
               return_default: RETURN_DEFAULT:
                                -> Return selektiert Default-Objekt
                               RETURN_NEXT_EDIT:
                                -> Return springt zum nÑchsten Eingabefeld
                               RETURN_LAST_DEFAULT:
                                -> Return selektiert Default-Objekt beim
                                   letzten Eingabefeld (ansonsten wie
                                   RETURN_NEXT_EDIT)
               background:     ALWAYS_BACK:
                                 -> Fenster (-dialoge) kînnen unter jeder
                                   TOS-Version im Hintergrund bedient werden
                               NO_BACK:
                                 -> Keine Hintergrundbedienung
                               AES_BACK:
                                 -> Hintergrundbedienung nur, wenn dies
                                    durch GEM unterstÅtzt wird (MTOS,
                                    MagiC, Geneva, Winx, Falcon-TOS)
               nonselectable:  Fliegende Dialoge fliegen auch beim Anklicken
                               von nicht-selektierbaren/editierbaren
                               Objekten (analog lassen sich Fensterdialoge
                               verschieben)
               always_keys:    KEY_FIRST:
                                -> Tastendruck erst an Event-Handler weiter-
                                   leiten und danach nicht ausgewertete
                                   TastendrÅcke in Dialogroutinen auswerten
                               KEY_STD:
                                -> Tastendruck wird zuerst von Dialog-
                                   routinen ausgewertet und nicht ausge-
                                   wertete TastendrÅcke werden an Event-
                                   Handler weitergeleitet (auûer bei
                                   modalen/fliegenden Dialogen)
                               KEY_ALWAYS:
                                -> wie KEY_STD, nur daû nicht ausgewertete
                                   TastendrÅcke immer weitergeleitet wer-
                                   den
               toMouse:        TastendrÅcke an Fensterdialog unter Maus-
                               zeiger senden, sofern oberster Dialog
                               weder modal noch fliegend ist
                               -> zusammen mit 'background' ist somit eine
                                  vollstÑndige Bedienung von Hintergrund-
                                  dialogen mîglich
               clibpoard:      KlemmbrettunterstÅtzung in Eingabefeldern
               hz:             Blinkrate (in Hertz) des Cursors in Eingabe-
                               feldern oder statischer Cursor (hz<=0)

        void header_options(boolean set,boolean center,boolean frame,
                            boolean small,boolean transp,int tcolor,
                            int fcolor,int bcolor,int bpattern)
            -> Optik der Rahmen-Objekte (erweiterter Typ HEADER) setzen
               (wirkt sich nur bei Dialogen aus, die nach dieser Funktion
                geîffnet werden)
               set:      Optik der Rahmen-Objekte entsprechend den
                         Einstellungen setzen (set==TRUE) oder die Ein-
                         stellungen im Objektbaum/Resource unverÑndert
                         lassen (set==FALSE)
               center:   öberschrift zentriert (center==TRUE) oder links-
                         bÅndig
               frame:    öberschriften umrahmen
               small:    Kleiner System-Font (SMALL)
               transp:   transparente Schrift
               tcolor:   Farbe der Schrift (0-15)
               fcolor:   Farbe des Rahmens (0-15)
               bcolor:   Innenfarbe (0-15)
               bpattern: Innenmuster (0-7)

        void title_options(boolean mode,int color,int size);
            -> Unterstrichenen Text (erweiterter Typ UNDERLINE) setzen:
               mode:  Strich wird Åber die ganze Breite des Dialogs (TRUE)
                      oder Åber die im Resource vorgebenen Koordinaten
                      (FALSE) gezeichnet
               color: Strichfarbe (0-15)
               size:  Strickdicke in Pixel oder Null, wenn der Wert aus
                      der Resource-Struktur entnommen werden soll

        BUTTON-Struktur:
        ----------------
            typedef struct
            {
                /* Zeiger auf monochrome 16x16-Bitmap (32 Bytes) des
                   selektierten und des normalen Buttons im gerÑte-
                   abhÑngigen Format */
                int *but_on,*but_off;
            } BUTTON;

        void radio_image(int index,BUTTON *radiobutton);
            -> vordefinierte Images (index: 0-8) oder benutzerdefinierten
               Button 'radiobutton' (radiobutton!=NULL) fÅr Radio-Buttons
               auswÑhlen

        void check_image(int index,BUTTON *checkbox);
            -> vordefinierte Images (index: 0-5) oder benutzerdefinierten
               Button 'checkbox' (checkbox!=NULL) fÅr Check-Box auswÑhlen
               (keine Auswirkung auf Optik der TriState-Checkbox!)

        void cycle_image(int index,BUTTON *cyclebutton,char cycle);
            -> vordefinierte Images (index: 0-2) oder benutzerdefinierten
               Button 'cyclebutton' (cyclebutton!=NULL) fÅr Cycle-Buttons
               auswÑhlen. Der Parameter 'cycle' gibt an (sofern cycle!=0),
               welches Zeichen fÅr den Cycle-Button verwendet werden soll,
               wenn die Images aufgrund der Ausmaûe des Systemfonts nicht
               verwendet werden kînnen.

        void arrow_image(int index,BUTTON *down,BUTTON *up,BUTTON *left,
                         BUTTON *right);
            -> vordefinierte Images (index: 0-2) oder benutzerdefinierte
               Buttons 'down', 'up' 'left', 'right' (sofern ungleich NULL)
               fÅr Slider-Pfeile auswÑhlen. Dabei kînnen in den BUTTON-
               Strukturen fÅr den selektierten Zustand (but_on) optional
               NULL-Pointer gesetzt werden, so daû dann einfach der normale
               Zustand (but_off) bei Selektion invertiert wird.

    10. Bibliothek (AES,VDI) sowie Resource (de-) initialisieren
        --------------------------------------------------------

        boolean open_work(int *handle,int *work_out);
            -> virtuelle Bildschirm-Workstation îffnen
            -> RÅckgabewert gleich TRUE, wenn Workstation geîffnet
               werden konnte
            -> handle:   VDI-Handle im Erfolgsfall
               work_out: work_out[57]-Feld

        void close_work(int handle);
            -> virtuelle Bildschirm-Workstation 'handle' schlieûen

        boolean open_device(int dev,int *handle,int *work_out);
            -> GDOS-Treiber mit GerÑtenummer 'dev' (mîgliche Werte s.
               Funktion driver_available) îffnen
            -> RÅckgabewert gleich TRUE, wenn GerÑt geîffnet werden konnte
            -> handle:   Device-Handle im Erfolgsfall
               work_out: work_out[57]-Feld

        void close_device(int handle)
            -> GDOS-Treiber mit Device-Handle 'handle' schlieûen

        boolean init_gem(char *win_id,char *m_entry,char *x_name,
                         char *a_name,int av_msgs,int va_msgs,int xacc_msgs)
            -> Initialisierung der Library
                - Anmeldung beim AES
                - Xacc-2/AV-Protokolle initialisieren
                - interne VDI-Workstation îffnen
                - GDOS-Fonts laden
                - Scrap-Directory initialisieren
                - globale Variablen sowie interne Strukturen initialisieren
            -> Parameter:
                win_id:    ProgrammkÅrzel vor jedem Fenster-Titel oder
                           NULL
                m_entry:   Eintrag im Accessory-MenÅ (als Accessory oder
                           unter MTOS) oder NULL
                x_name:    (erweiterter) XAcc-2-Programmname
                a_name:    AV-Programmname (maximal 8 Zeichen wie bei
                           appl_find, wobei die Library den Namen gegebenen-
                           falls mit Leerzeichen erweitert)
                av_msgs:   Bitmap der unterstÅtzten Nachrichten bei der
                           Nachricht AV_PROTOKOLL:
                           VA_START und AV_STARTED werden von der Library
                           angegeben, sofern die Library mit Drag&Drop
                           Åbersetzt wurde. Das Dateinamen-Quoting wird
                           grundsÑtzlich angegeben.

                #define MSG_SETSTATUS     0x001 /* VA_SETSTATUS */
                #define MSG_START         0x002 /* VA_START */
                #define MSG_AVSTARTED     0x004 /* AV_STARTED */
                #define MSG_AVFONTCHANGED 0x008 /* VA_FONTCHANGED */
                #define MSG_AVQUOTE       0x010 /* Quoting von Dateinamen */

                va_msgs:   Bitmap der unterstÅtzten Nachrichten bei der
                           Nachricht VA_PROTOSTATUS:
                           Quoting von Dateinamen, AV_SENDKEY, AV_EXIT,
                           AV_ACCWINDOPEN/AV_ACCWINDCLOSED sowie
                           AV_PATH_UPDATE werden von der Library immer an-
                           gegeben. Falls die Library mit Drag&Drop Åber-
                           setzt wurde, so werden noch AV_STARTED,
                           AV_OPENWIND und AV_XWIND unterstÅtzt.

                #define MSG_SENDKEY       0x001  /* AV_SENDKEY */
                #define MSG_ASKFILEFONT   0x002  /* AV_ASKFILEFONT */
                #define MSG_ASKCONFONT    0x004  /* AV_ASKCONFONT,
                                                    AV_OPENCONSOLE */
                #define MSG_ASKOBJECT     0x008  /* AV_ASKOBJECT */
                #define MSG_OPENWIND      0x010  /* AV_OPENWIND */
                #define MSG_STARTPROG     0x020  /* AV_STARTPROG */
                #define MSG_ACCWINDOPEN   0x040  /* AV_ACCWINDOPEN,
                                                    AV_ACCWINDCLOSED */
                #define MSG_STATUS        0x080  /* AV_STATUS, AV_GETSTATUS */
                #define MSG_COPY_DRAGGED  0x100  /* AV_COPY_DRAGGED */
                #define MSG_PATH_UPDATE   0x200  /* AV_PATH_UPDATE,
                                                    AV_WHAT_IZIT,
                                                    AV_DRAG_ON_WINDOW */
                #define MSG_EXIT          0x400  /* AV_EXIT */
                #define MSG_XWIND         0x800  /* AV_XWIND */
                #define MSG_VAFONTCHANGED 0x1000 /* VA_FONTCHANGED */
                #define MSG_VASTARTED     0x2000 /* AV_STARTED */
                #define MSG_VAQUOTE       0x4000 /* Quoting von Dateinamen */

                xacc_msgs: Bitmap der unterstÅtzten ACC-Nachrichten (alle
                           anderen ACC-Nachrichten werden automatisch
                           ausgewertet)

                #define X_MSG_TEXT      0x001 /* ACC_TEXT */
                #define X_MSG_META      0x002 /* ACC_META */
                #define X_MSG_IMG       0x004 /* ACC_IMG */

            -> RÅckgabewert:
                TRUE:  Ok
                FALSE: Anmeldung beim AES oder ôffnen der Workstation
                       schlug fehl

        void exit_gem(boolean all,int status);
            -> Deinitialisierung der Library:
                - Dialoge und Fenster schlieûen
                - MenÅleiste abmelden
                - Beenden der XAcc-2-/AV-Protokolle
                - geladene GDOS-Fonts wieder entfernen
                - interne VDI-Workstation schlieûen
                - Abmeldung beim AES, sofern Anwendung als Programm ge-
                  startet wurde (ansonsten Endlos-Timer)
                - Programm beenden und Wert 'status' zurÅckgeben, sofern
                  all==TRUE

        boolean open_rsc(char *rscname,char *win_id,char *m_entry,
                         char *x_name,char *a_name,int av_msgs,int va_msgs,
                         int xacc_msgs)
            -> Initialisierung der Library (s. init_gem()) sowie Resource
               'rscname' laden
            -> Parameter: s. init_gem()
            -> RÅckgabewert:
                TRUE:  Ok
                FALSE: Anmeldung beim AES oder ôffnen der Workstation
                       schlug fehl
                FAIL:  Resource-File konnte nicht geladen werden (Speicher-
                       mangel oder falscher Pfad)

        void close_rsc(boolean all,int status);
            -> Resource-Speicher freigeben und Library deinitialisieren
               (Parameter s. exit_gem())

    11. Resource- und Objekt-Initialisierung
        ------------------------------------

            void fix_objects(OBJECT *tree,int scaling,
                             int orig_cw,int orig_ch);
                -> erweiterte Objekte des Baums 'tree' initialisieren sowie
                   gegebenenfalls Images/Icons skalieren (scale_image())
                   und ins GerÑteformat konvertieren (trans_image())

                -> Parameter:
                   orig_cw: Breite des Entwurfsfonts in Pixel (meistens 8)
                            oder negativer Wert fÅr rsrc_obfix()-kompatible
                            Anpassung
                   orig_ch: Hîhe des Entwurfsfonts in Pixel (meistens 8 oder
                            16) oder negativer Wert fÅr rsrc_obfix()-kompa-
                            tible Anpassung
                   scaling: Bitmap des Image/Icon-Skalierungs-Modus

                    #define NO_SCALING      0   /* keine Skalierung */
                    #define SCALING         1   /* Skalierung */
                    #define TEST_SCALING    2   /* Testen, ob Skalierung not-
                                                   wendig ist */
                    #define DARK_SCALING    4   /* dunkle Skalierung */
                    #define STATIC_SCALING  8   /* Dialog immer in Original-
                                                   grîûe skalieren */

                    Beispiele:
                    /* Nie skalieren */
                        images = NO_SCALING;

                    /* Immer skalieren */
                        images = SCALING;

                    /* Bei Bedarf (System-Font kleiner als Entwurfsfont)
                       skalieren */
                        images = SCALING|TEST_SCALING;

                    /* Bei Bedarf dunkel skalieren */
                        images = SCALING|TEST_SCALING|DARK_SCALING;

        void scale_image(OBJECT *object,int scaling,
                         int orig_cw, int orig_ch);
            -> Image/Icon 'object' skalieren
            -> Parameter s. fix_objects()

        void trans_image(OBJECT *object);
            -> Image/Icon 'object' in GerÑteformat konvertieren

        void rsrc_calc(OBJECT *tree,int scaling,int orig_cw,int orig_ch);
            -> Koordinaten und Ausmaûe der Objekte des Baums 'tree' an
               Ausmaûe des System-Fonts unter Beachtung der Ausmaûe des
               Fonts, mit welchem die Resource-Datei erstellt wurde, an-
               passen und anschlieûend erweiterte Objekte initialisieren
               (s. fix_objects())
            -> Parameter s. fix_objects()

        void rsrc_init(int n_tree,int n_obs,int n_frstr,int n_frimg,
                       int scaling,char **rs_strings,long *rs_frstr,
                       BITBLK *rs_bitblk,long *rs_frimg,
                       ICONBLK *rs_iconblk,TEDINFO *rs_tedinfo,
                       OBJECT *rs_object,OBJECT **rs_trindex,
                       RS_IMDOPE *rs_imdope,int orig_cw,int orig_ch)
            -> in Quelltext eingebundene Resource-Datei (*.RSH)
               initialisieren

            -> Parameter:
               n_tree:     Anzahl der BÑume (NUM_TREE)
               n_obs:      Anzahl der Objekte (NUM_OBS)
               n_frstr:    Anzahl der freien Strings (NUM_FRSTR)
               n_frimg:    Anzahl der freien Images (NUM_FRIMG)

               rs_strings: String-Array (Pointer zeigen auf alle
                           Zeichenketten der Resource-Datei)
               rs_frstr:   Index-Array (Indizes der freien Strings
                           fÅr das rs_strings-Array)
               rs_bitblk:  BITBLK-Array (enthÑlt alle Bit-Blîcke)
               rs_frimg:   Index-Array (Indizes der freien Images
                           fÅr das rs_bitblk-Array)
               rs_iconblk: ICONBLK-Array (enthÑlt alle icons)
               rs_tedinfo: TEDINFO-Array (enthÑlt alle TEDINFO-Strukturen)
               rs_object:  OBJECT-Array (enthÑlt alle Objekte)
               rs_trindex: Index-Array (Indizes der ObjektbÑume
                           fÅr das rs_object-Array)
               rs_imdope:  RS_IMDOPE-Array

                RS_IMDOPE-Struktur:
                -------------------

                typedef struct
                {
                    int dummy;
                    /* Zeiger auf Bitmap (Image) */
                    int *image;
                } RS_IMDOPE;

               scaling: s. fix_objects()
               orig_cw: s. fix_objects()
               orig_ch: s. fix_objects()

               HINWEIS:
               An allen Stellen der Resource, an denen normalerweise
               Pointer vorkommen, muû der Element-Index (Long-Wert) des
               entsprechenden Arrays stehen. Die Image-Zeiger der
               Strukturen BITBLK und ICONBLK enthalten den Index des
               zugehîrigen RS_IMDOPE-Elements.

    12. Ereignis-Auswertung
        -------------------

        XEVENT-Struktur:
        ----------------

        typedef struct
        {
            /* PARAMETER: */

            /* Bitmap der gewÅnschten Events:
               MU_KEYBD:     Tastatur-Ereignis
               MU_MESAG:     Nachrichten-Ereignis
               MU_TIMER1-4:  Timer-Ereignis 1-4
               MU_BUTTON1/2: Button-Ereignis 1/2
               MU_M1-4:      Rechteck-Ereignis 1-4 (sofern MU_M1/2 verfÅgbar
                             sind, sollten diese aus GeschwindigkeitsgrÅnden
                             auch benutzt werden!) */
            int ev_mflags;

            /* Parameter des 1. Button-Events MU_BUTTON1 */
            int ev_mb1clicks,ev_mb1mask,ev_mb1state

            /* Parameter des 1. Mouse-Event-Rechtecks MU_M1 */
            int ev_mm1flags,ev_mm1x,ev_mm1y,ev_mm1width,ev_mm1height,

            /* Parameter des 2. Mouse-Event-Rechtecks MU_M2 */
            int ev_mm2flags,ev_mm2x,ev_mm2y,ev_mm2width,ev_mm2height;

            /* Parameter des 1. Timer-Events MU_TIMER1 */
            unsigned int ev_mtlocount,ev_mthicount;

            /* RöCKGABEWERTE: */

            /* eingetretene Ereignisse */
            int ev_mwich;

            /* Position des Mauszeigers sowie Zustand der Maustasten
               beim Auftreten des Events */
            int ev_mmox,ev_mmoy,ev_mmobutton;

            /* Zustand der Sondertasten beim Auftreten des Events */
            int ev_mmokstate;

            /* Scancode der gedrÅckten Taste (High-Byte: Scan-Code,
               Low-Byte: ASCII-Code oder Null) */
            int ev_mkreturn;

            /* Anzahl der Klicks mit der Maustaste (MU_BUTTON1) */
            int ev_mb1return;

            /* Nachrichten-Puffer */
            int ev_mmgpbuf[8];

            /* erweiterte PARAMETER: */

            /* Parameter des 2. Button-Events MU_BUTTON2 */
            int ev_mb2clicks,ev_mb2mask,ev_mb2state;

            /* Parameter des 3. Mouse-Event-Rechtecks MU_M3 */
            int ev_mm3flags,ev_mm3x,ev_mm3y,ev_mm3width,ev_mm3height;

            /* Parameter des 4. Mouse-Event-Rechtecks MU_M4 */
            int ev_mm4flags,ev_mm4x,ev_mm4y,ev_mm4width,ev_mm4height;

            /* Parameter des 2-4. Timer-Events MU_TIMER2-4 */
            long ev_mt2count,ev_mt3count,ev_mt4count;

            /* Zeitpunkt in Milisekunden des letzten Timer-Events
               MU_TIMER1-4 oder Null fÅr aktuelle System-Zeit */
            long ev_mt1last,ev_mt2last,ev_mt3last,ev_mt4last;

            /* Anzahl der Klicks mit der Maustaste (MU_BUTTON2) */
            int ev_mb2return;
        } XEVENT;

        KompatibilitÑts-Makros fÅr EVENT-Struktur und AES-Event-Routinen:
        -----------------------------------------------------------------

            #define ev_mbclicks     ev_mb1clicks
            #define ev_mbmask       ev_mb1mask
            #define ev_bmask        ev_mb1mask
            #define ev_mbstate      ev_mb1state
            #define ev_mbreturn     ev_mb1return

            #define ev_mtlocount    ev_mt1locount
            #define ev_mthicount    ev_mt1hicount
            #define ev_mtlast       ev_mt1last

            #define MU_TIMER1       MU_TIMER
            #define MU_BUTTON1      MU_BUTTON

        int Event_Multi(XEVENT *event);
            -> Auf Ereignis 'event' warten (benîtigte Parameter der
               Struktur mÅssen initialisiert sein, sofern dies nicht
               die Initialisierungs-Routine von Event_Handler(), s.u.,
               Åbernimmt). Die Library wertet dabei selbstÑndig Nachrichten
               der XAcc-2-, AV- und Drag&Drop-Protokolle aus und wandelt
               diese gegebenenfalls um. Ebenso werden Ereignisse, welche
               Fenster (-dialoge) bzw. allgemein die Library betreffen,
               ausgewertet.

               WICHTIG:
               Es werden nur Ereignisse zurÅckgeliefert, welche nicht von
               der Library oder dem durch die Funktion Event_Handler()
               definierten Handler ausgewertet wurden!
               Setzt man die Variable 'ev_mflags' auf Null oder Åbergibt man
               den Wert NULL fÅr den Parameter 'event', so werden KEINE
               Events zurÅckgeliefert! Alle Ereignisse mÅssen dann vom
               Handler initialisiert und ausgewertet werden!
               Library-spezifische Nachrichten (s.u.) werden NUR an den
               Event-Handler geliefert!!!

            -> RÅckgabewert: Bitmap der eingetretenen Ereignisse

        void Event_Timer(int locount,int hicount,int nokeys)
            -> Wartet bis die durch lo_count und hi_count in Millisekunden
               vorgebene Zeit verstrichen ist. Dabei werden allerdings
               noch Nachrichten durch die Library (der Nachrichtenpuffer
               wird komplett geleert) sowie Ereignisse durch den Handler
               ausgewertet, so daû diese Funktion z.B. wÑhrend eines
               rechenintensiven Vorgangs dazu benutzt werden kann,
               (Benutzer-) Ereignisse durch einen Aufruf mit kurzer Warte-
               zeit (0) auszuwerten (z.B. Fenster verschieben, neuzeichnen,
               ikonifizieren etc...).
               Ebenso wird noch die Form des Mauszeigers (sofern nicht
               blockiert (s. beg_ctrl() oder MouseUpdate()) verwaltet und
               alle automatischen Tastaturkommandos (s. Funktionen
               MenuItems() und WindowItems()) werden ausgewertet (sofern
               Parameter nokeys==FALSE)

        void Event_Handler(int (*init)(XEVENT *,int,int),
                           int (*handler)(XEVENT *));
            -> Routinen zur Ereignisauswertung festlegen, wobei diese Rou-
               tinen diejenigen Ereignisse auswerten, welche nicht auto-
               matisch von der Library bearbeitet wurden. Durch öbergabe
               von NULL kînnen bereits angemeldete Funktionen wieder
               abgemeldet werden. Ebenso kann man die Routinen beliebig
               oft neu setzen, z.B. fÅr eine lokale Ereignisauswertung.

            -> Parameter:
                int (*init)(XEVENT *event,int available):
                    -> Routine, welche vor jeder Ereignisfunktion zur Ini-
                       tialisierung aufgerufen wird und daher mîglichst
                       keine langsamen Funktionen ausfÅhren sollte. Die Rou-
                       tine gibt eine Bitmap der gewÅnschten Events zurÅck
                       und initialisiert gegebenenfalls Variablen der Åber-
                       gebenen XEVENT-Struktur 'event' (dabei darf nicht
                       nicht davon ausgegangen werden, daû es sich immer um
                       die gleiche Struktur handelt!!!) Angefordert werden
                       kînnen nur die Events, welche in der Bitmap
                       'available' gesetzt sind! (die Events MU_TIMER2/3/4
                       und MU_MESAG sind immer verfÅgbar, d.h. werden nicht
                       von der Library benutzt/gesperrt)

                int (*handler)(XEVENT *event):
                    -> Routine, welche u.a. von X_Form_Do sowie Event_Multi
                       aufgerufen wird und die Ereignisse, welche von der
                       Library nicht verarbeitet wurden, auswertet. ZurÅck-
                       gegeben wird eine Bitmap der ausgewerteten Ereig-
                       nisse. V.a. bei Tastatur-Ereignissen, welche nicht
                       ausgewertet wurden, sollte MU_KEYBD nicht gesetzt
                       werden, damit die Library gegebenenfalls den Tasten-
                       druck per Xacc-2- oder AV-Protokoll weiterleiten
                       kann.

                       WICHTIG:
                       Diese Routine darf keine Variablen der XEVENT-Struk-
                       tur (abgesehen von den Ausgabewerten) verÑndern!


    13. Library-spezifische Nachrichten
        -------------------------------

        Hinweis:
        Bei den Nachrichten AC_CLOSE/AP_TERM werden alle geîffneten
        Fenster und Dialoge AUTOMATISCH geschlossen, wobei bei
        AP_TERM anschlieûend die Applikation beendet werden sollte.

        OBJC_EDITED:
            -> Eingabefeld wurde verÑndert:
            msg[0]        = OBJC_EDITED
            msg[3]        = Nummer des aktuellen Eingabeobjekts
                            oder negativer Wert, falls alle
                            Eingabefelder betroffen sind
            msg[4]/msg[5] = Zeiger auf die DIAINFO-Struktur des
                            Dialogs

        OBJC_CHANGED:
            -> Status eines Objekts (kein EXIT-/TOUCHEXIT-Objekt)
               hat sich geÑndert:
            msg[0]        = OBJC_CHANGED
            msg[3]        = Nummer des Objekts
            msg[4]/msg[5] = Zeiger auf die DIAINFO-Struktur des
                            Dialogs

        OBJC_SIZED:
            -> Grîûe oder Position des Dialogs hat sich geÑndert,
               wobei die Ausmaûe des Wurzelobjekts bereits angepaût
               wurden (wird auch bei ikonifizierter Fensterdialogen
               verschickt!)
            msg[0]        = OBJC_SIZED
            msg[4]/msg[5] = Zeiger auf die DIAINFO-Struktur des
                            Dialogs

        OBJC_DRAGGED:
            -> Daten wurden an Applikation per Drag&Drop Åbergeben
            msg[0]        = OBJC_DRAGGED
            msg[4]/msg[5] = Zeiger auf DRAG_DROP-Struktur

        SLIDER_CHANGED:
            -> (Cursor-) Position eines vollautomatischen Sliders,
               der bei der Funktion open_dialog Åbergeben wurde,
               hat sich geÑndert
            msg[0]        = SLIDER_CHANGED
            msg[4]/msg[5] = Zeiger auf SLINFO-Struktur

        POPUP_CHANGED:
            -> Eintrag eines vollautomatischen Popups, welches bei der
               Funktion open_dialog Åbergeben wurde, wurde selektiert bzw.
               neuer aktueller Eintrag. Setzt man die Variable 'current'
               der XPOPUP-Struktur nach jeder Selektion auf einen negativen
               (=ungÅltigen) Wert, so bekommt man bei JEDER Selektion
               eine Nachricht (ansonsten nur, wenn ein anderer Eintrag ge-
               wÑhlt wurde)
            msg[0]        = POPUP_CHANGED
            msg[3]        = aktueller Eintrag
            msg[4]/msg[5] = Zeiger auf XPOPUP-Struktur

        MN_SELECTED:
            -> Ein MenÅeintrag (Pull-Down-MenÅ oder vollautomatisches
               FenstermenÅ, dessen XPOPUP-Struktur bei open_dialog() Åber-
               geben wurde) wurde selektiert
            msg[0]        = MN_SELECTED
            msg[3]        = Objektnummer des Titeleintrags (>0)
                            oder negative Identifikationsnummer (-id)
                            aus der XPOPUP-Struktur
            msg[4]        = Objektnummer des Eintrags
            msg[5]/msg[6] = Zeiger auf Objektbaum des (Fenster-) MenÅs
            msg[7]        = Åbergeordnetes Objekt (-1 bei Pull-Down-MenÅs,
                            parent-Objekt aus POPUP-Struktur bei Fenster-
                            MenÅs)

        XACC_AV_INIT:
            -> Applikation hat sich per XAcc-2- oder AV-Protokoll
               angemeldet
            msg[0]        = XACC_AV_INIT
            msg[3]        = Applikations-ID
            msg[4]/msg[5] = Zeiger auf XAcc-Struktur

        XACC_AV_EXIT:
            -> Applikation hat sich per XAcc-2- oder AV-Protokoll
               abgemeldet
            msg[0]        = XACC_AV_EXIT
            msg[3]        = Applikations-ID

        XACC_AV_CLOSE:
            -> alle anderen Applikationen haben sich per XAcc-2-
               oder AV-Protokoll abgemeldet bzw. die Protokolle
               wurden reinitialisiert
            msg[0]        = XACC_AV_CLOSE

        WIN_CHANGED:
            -> Status eines Fenster hat sich geÑndert (z.B. wurde
               das Fenster ikonifiziert/deikonifiziert). U.a. kann
               sich auch das Fenster-Handle Ñndern!
            msg[0]        = WIN_CHANGED
            msg[3]        = Fenster-Handle oder negativer Wert,
                            falls alle Fenster betroffen sind
            msg[4]/msg[5] = Zeiger auf die WIN-Struktur des
                            Fensters oder NULL, falls alle
                            Fenster betroffen sind

        WIN_NEWTOP:
            -> neues oberstes Fenster (Nachricht wird sowohl bei
               Benutzeraktionen als auch beim ôffnen, Schlieûen und
              (De-) Ikonifizieren von Fenstern verschickt)
            msg[0]        = WIN_NEWTOP
            msg[3]        = Fenster-Handle des obersten Fensters
                            (kann auch ein Fenster einer anderen
                             Applikation oder eines Dialogs sein)

        WIN_SIZED:
            -> Fenstergrîûe/-position hat sich geÑndert (bei Fenster-
               dialogen wird die Nachricht OBJC_SIZED verschickt!),
               wobei diese Nachricht auch verschickt hat, wenn das
               Fenster ikonifiziert ist
            msg[0]        = WIN_SIZED
            msg[3]        = Fenster-Handle
            msg[4]/msg[5] = Zeiger auf die WIN-Struktur des
                            Fensters

        WIN_SCROLLED:
            -> Scrollposition eines Fensters wurde geÑndert
            msg[0]        = WIN_SCROLLED
            msg[3]        = Fenster-Handle
            msg[4]/msg[5] = Zeiger auf die WIN-Struktur des
                            Fensters


    14. Dialog-Funktionen
        -----------------

        DIAINFO-Struktur:
        -----------------

        typedef struct
        {
            /* Dialog-Typ
                CLOSED      -> geschlossen
                OPENED      -> normaler Dialog
                FLYING      -> fliegender Dialog
                WINDOW      -> Fenster-Dialog
                WIN_MODAL   -> modaler Fenster-Dialog */
            DIALMODE di_flag;

            /* Zeiger auf Objektbaum */
            OBJECT   *di_tree;

            /* Zeiger auf Fenster-Struktur (nur gÅltig, wenn
               di_flag>=WINDOW!!!) */
            WIN      *di_win;

            /* bei open_dialog() angegebener Dialog-Modus */
            int      di_mode;

            /* aktuelles Eingabeobjekt oder negativer Wert */
            int      di_ed_obj;

            /* aktuelle Position des Cursors im Eingabefeld oder negativer
               Wert */
            int      di_ed_index;

            /* EinfÅge (!=0)/öberschreibenmodus (==0) in Eingabefeldern */
            int      di_insert;

            /* Offset von der linken oberen Ecke des Fensterarbeitsbereichs
               bis zur linken oberen Ecke des Dialogwurzelobjekts
               (Variable darf nicht verÑndert werden und ist nur bei
                Fensterdialogen gÅltig)
            int      di_xy_off;

            /* Differenz zwischen der Breite/Hîhe des Fensterarbeitsbereichs
               und der Breite/Hîhe des Dialogwurzelobjekts
               (Variable darf nicht verÑndert werden und ist nur bei
                Fensterdialogen gÅltig)
            int      di_wh_off;

            /* Zeiger auf ALERT-Struktur einer Alertbox (RÅckgabewert
               der Funktion MakeAlert). Ist dieser Zeiger gesetzt, so
               wird u.a. der durch die Alertbox angeforderte Speicher beim
               Schlieûen des Dialogs automatisch freigegeben */
            ALERT    *di_alert;

            /* Zeiger auf Speicher, der per malloc/calloc/strdup oder einer
               Library-Funktion (auûer GetMsgBuffer) angefordert wurde, und
               automatisch beim Schlieûen des Dialogs per free() freigeben
               werden soll (wird u.a. fÅr nonmodale/mehrfach geîffnete
               Sonderzeicheneingabe- sowie Alertboxen benîtigt) */
            void     *di_mem;

            /* alle weiteren Variablen dieser Struktur sind nur fÅr INTERNE
               Zwecke */
        } DIAINFO;

        DIAINFO *open_dialog(OBJECT *tree,char *title,char *icon_title,
                OBJECT *icon,boolean center,boolean grow_box,
                int dialog_mode,int edit,SLINFO **slider,XPOPUP *popup);
            -> Dialog îffnen und darstellen
            -> RÅckgabewert: Zeiger auf initialisierte DIAINFO-Struktur des
                             Dialogs oder NULL, falls Dialog nicht geîffnet
                             werden konnte
            -> Parameter:
                tree:        Zeiger auf Objektbaum
                title:       Zeiger auf Fenster-Titel fÅr Fensterdialoge
                icon_title:  Zeiger auf Fenstertitel im ikonifizierten Zu-
                             stand oder NULL
                icon:        Zeiger auf Objektbaum, der fÅr die ikonifi-
                             zierte Darstellung benutzt wird, oder NULL (in
                             diesem Fall wird der globale Objektbaum
                             iconified benutzt)
                center:      DIA_MOUSEPOS: Dialog um Mauszeiger zentrieren
                             DIA_CENTERED: Dialog in Bildschirmmitte zen-
                                           trieren (sichtbarer Ausschnitt
                                           des Bildschirms, d.h. VSCR-Cookie
                                           von virtuellen Bildschirmerwei-
                                           terungen wird beachtet)
                             DIA_LASTPOS:  Dialog an letzter Position îffnen
                                           (beim ersten ôffnen des Dialogs
                                            analog wie DIA_CENTERED)
                grow_box:    sich vergrîûernder Rechtecke zeichnen
                dialog_mode: Bitmap des Dialogtyps:

                        /* fliegender Dialog */
                        #define FLY_DIAL        0x01

                        /* Fenster-Dialog */
                        #define WIN_DIAL        0x02

                        /* Fenster-Dialog, sofern Fenster geîffnet werden
                           kann, ansonsten fliegender Dialog
                        #define AUTO_DIAL       (FLY_DIAL|WIN_DIAL)

                        /* modaler Fensterdialog */
                        #define MODAL           0x04

                        /* Fenster-Dialog mit dickem Rahmen */
                        #define FRAME           0x08

                        /* Fenster-Dialog kann nicht ikonifiziert werden
                           (ist bei öbersetzung der Library mit
                            SMALL_NO_ICONIFY immer gesetzt!) */
                        #define NO_ICONIFY      0x10

                        /* Fenster-Dialog mit dÅnnem Rahmen (hat Vorrang vor
                           FRAME) */
                        #define SMALL_FRAME     0x20

                        /* Fenster-Dialog mit mittlerem Rahmen */
                        #define SMART_FRAME     (FRAME|SMALL_FRAME)

                        /* Die folgenden Fensterelemente (auûer WD_CLOSER)
                           des Dialogfensters mÅssen von der Anwendung ausge-
                           wertet u. gesetzt werden!
                           Dabei wird die Grîûe des Fensters automatisch
                           gesetzt, wenn WD_SET_SIZE Åbergeben wird. An-
                           sonsten darf die Grîûe NICHT verÑndert werden! */

                        /* fliegender Dialog mit 3D-Rahmen unter 3D-AES */
                        #define DDD_DIAL         0x40

                        /* Fenster-Dialog mit horizontalem Slider
                           (Slider,Pfeile rechts/links) */
                        #define WD_HSLIDER      0x80

                        /* Fenster-Dialog mit vertikalem Slider
                           (Slider,Pfeile hoch/runter) */
                        #define WD_VSLIDER      0x100

                        /* Fenster-Dialog mit Sizer */
                        #define WD_SIZER        0x200

                        /* Fenster-Dialog mit Closer (auch bei modalen
                           Dialogen!) */
                        #define WD_CLOSER       0x400

                        /* Fenster-Dialog mit Fuller */
                        #define WD_FULLER       0x800

                        /* Fenster-Dialog mit Info-Zeile */
                        #define WD_INFO         0x1000

                        /* Grîûe bei WM_FULLED/WM_SIZED automatisch an-
                           passen (Nachricht OBJC_SIZED wird anschlieûend
                           an Anwendung geschickt) */
                        #define WD_SET_SIZE     0x2000

                        /* maximale Grîûe des Fensters auf Grîûe des Dialogs
                           setzen und Dialoggrîûe bei WD_SET_SIZE nicht ver-
                           Ñndern. Auûerdem wird bei WM_FULLED nur die
                           Grîûe, aber nicht die Position des Dialogs ge-
                           Ñndert (s.a. Beispielprogramm 'DialogDemo') */
                        #define WD_TREE_SIZE    0x4000

                edit:        Objektnummer des Eingabefeldes, in welchem
                             sich der Cursor befinden soll
                             (oder negativer Wert)

                slider:      Zeiger auf Liste mit Adressen der SLINFO-
                             Strukturen (letzter Listen-Eintrag gleich
                             NULL) der Slider des Dialogs oder NULL, wenn
                             die Slider nicht automatisch verwaltet werden
                             sollen. Dabei werden die angegebenen Slider vor
                             dem ôffnen des Dialogs intern durch
                             graf_set_slider(...,GRAF_SET) gesetzt. S.a.
                             Nachricht SLIDER_CHANGED

                popup:       Zeiger auf Liste mit Adressen der XPOPUP-
                             Strukturen (letzter Listen-Eintrag gleich
                             NULL) der Popups des Dialogs oder NULL, wenn
                             keine Popups automatisch verwaltet werden
                             sollen. S.a. Nachricht POPUP_CHANGED

            Hinweis:
            Werden nach dem ôffnen des Dialogs VerÑnderungen am Objekt-
            baum des Dialogs vorgenommen, die Eingabefelder betreffen, so
            ist sofort danach die Funktion ob_edit_init() aufzurufen.
            (Art der VerÑnderungen s. Beschreibung dieser Funktion)

            Help-, Undo-, Escape- und Default-Button dÅrfen nach dem
            ôffnen des Dialogs weder versteckt/gezeigt noch in der Baum-
            struktur hinzugefÅgt/gelîscht werden!

        int close_dialog(DIAINFO *dialog,boolean shrink_box);
            -> Dialog 'dialog' schlieûen und gegebenenfalls sich
               verkleinernde Rechtecke zeichnen (shrink_box!=0)
            -> RÅckgabewert: TRUE:  Dialog wurde geschlossen
                             FALSE: Dialog konnte nicht geschlossen werden
                                    (z.B. nicht oberster fliegender Dialog
                                     oder Popup geîffnet)

        void close_all_dialogs(void)
            -> alle geîffneten Dialoge schlieûen

        int X_Form_Do(DIAINFO **dialog)
            -> Bearbeitung der geîffneten Dialoge
            -> ZurÅckgegeben wird die Nummer des angewÑhlten Exit-Objekts
               (bei einem Doppelklick ist Bit 15 (0x8000,DOUBLE_CLICK), bei
                einem Rechtsklick optional Bit 14 (0x4000,RIGHT_CLICK) ge-
                setzt, Ausmaskieren dieser Bits mit der Konstante NO_CLICK)
               oder die Werte
               W_ABANDON -> Abbruch der Dialogbearbeitung, alle Dialoge
                            wurden automatisch geschlossen (z.B. durch
                            AC_CLOSE/AP_TERM) bzw. beim Aufruf der Funktion
                            waren keine Dialoge geîffnet (*dialog enthÑlt
                            einen NULL-Pointer)
               W_CLOSED  -> Fensterschlieûknopf wurde angeklickt (Dialog
                            muû noch geschlossen werden)
            -> '*dialog' enthÑlt (sofern ungleich NULL) einen Zeiger auf
               die DIAINFO-Struktur des aktuellen Dialogs

        int FormObject(int exit)
            -> Objektnummer aus X_Form_Do-RÅckgabewert 'exit' ermitteln
               (Doppel-/Rechtsklick ausmaskieren) oder negativer Wert, falls
               kein Objekt ausgewÑhlt wurde.

        int XFormObject(DIAINFO **back,int *form_do)
            -> entspricht FormObject(X_Form_Do(back)) (s. Beschreibung
               dieser Funktionen). Im Parameter 'form_do' (sofern ungleich
               NULL) wird der Original-RÅckgabewert von X_Form_Do() ge-
               speichert.

        int xdialog(OBJECT *tree,char *title,char *icon_title,OBJECT *icon,
                    boolean center,boolean grow_box,int dialog_mode);
            -> komplette Dialogbearbeitung (Dialog îffnen, bearbeiten und
               schlieûen), wobei diese Funktion nur verwendet werden sollte,
               wenn sonst kein Dialog geîffnet ist oder ein modaler oder
               fliegender Dialog geîffnet wird (z.B. um auf eine Benutzer-
               eingabe zu warten)
            -> Parameter und RÅckgabewerte s. open_dialog() sowie
               X_Form_Do()

        void dialog_mouse(DIAINFO *info,
                          int (*mouse)(DIAINFO *info,OBJECT *tree,int obj,
                          int last_obj,int x,int y,GRECT *out))
            -> Handler fÅr objektabhÑngige Dialogmausform des Dialogs 'info'
               anmelden (mouse!=NULL) oder abmelden (mouse==NULL). Dieser
               Handler kann sowohl fÅr Fenster- als auch fÅr fliegende Dia-
               loge angemeldet werden und wird aufgerufen, sobald der Maus-
               zeiger ein Objekt verlÑût/betritt.
            -> Parameter an Handler:
               info:     Zeiger auf DIAINFO-Struktur des Dialogs
               tree:     Zeiger auf Objektbaum des Dialogs
               obj:      Objekt unter dem Mauszeiger oder negativer Wert
               last_obj: Vorheriges Objekt unter dem Mauszeiger oder
                         negativer Wert
               x,y:      Mauskoordinaten
               rect:     Zeiger auf GRECT-Struktur des Rechtecks, welches
                         verlassen werden soll
            -> RÅckgabe:
               DIALOG_MOVEMENT: Mausform wurde vom Handler gesetzt;
                                Handler beim Verlassen des zurÅckge-
                                lieferten Rechtecks in '*rect' wieder auf-
                                rufen
               DIALOG_OBJECT:   Betreten und Verlassen der Objekte melden
               DIALOG_MOUSE:    Mausform wurde vom Handler gesetzt;
                                Betreten und Verlassen der Objekte melden

        int xalert(int default,int undo,int icon,BITBLK *user_icon,
                   int modal,int center,int width,
                   char *title,char *text,char *buttons)
            -> erweiterte Alertbox darstellen, wobei mehrere Alerts auf
               einmal geîffnet sein kînnen (zurÅckgeliefert wird der
               Index des ausgewÑhlten Buttons oder FAIL im Fehlerfall)
            -> default:   Index des DEFAULT-Buttons oder negativer Wert
               undo:      Index des UNDO-Buttons oder negativer Wert
               icon:      Nummer des Icons oder negativer Wert

                X_ICN_NONE:      /* kein Icon */
                X_ICN_MAX:       /* maximale Icon-Nummer */

                X_ICN_STOP:      /* Stop-Schild (Hinweis) */
                X_ICN_QUESTION:  /* Fragezeichen (Nachfrage) */
                X_ICN_ALERT:     /* Ausrufezeichen (Warnung) */

                X_ICN_DISC_ERR:  /* Disketten-I/O-Fehler */
                X_ICN_ERROR:     /* Bomben-Fehler */
                X_ICN_FLOPPY:    /* Disketten-Station */
                X_ICN_DISC:      /* Diskette */
                X_ICN_INFO:      /* Informations-Zeichen */
                X_ICN_PRT_ERR:   /* Drucker-I/O-Fehler */

               user_icon: Zeiger auf benutzerdefiniertes Icon oder NULL
               modal:     System-/Applikations-modale Alert-Box

                #define SYS_MODAL           0 /* System-Modal */
                #define APPL_MODAL          1 /* Applikations-Modal */

               center:    Ausrichtung der Buttons

                #define BUTTONS_CENTERED    0 /* zentriert */
                #define BUTTONS_LEFT        1 /* linksbÅndig */
                #define BUTTONS_RIGHT       2 /* rechtsbÅndig */

               width:     einheitliche Breite der Buttons (width!=0)
               title:     Zeiger auf Fenster-Titel bei applikationsmodalen
                          bzw. öberschrift bei systemmodalen Dialogen
               text:      Zeiger auf Text (maximal 24 Zeilen getrennt
                          durch '|'). Die Textattribute kînnen durch die
                          folgenden Zeichen (in beliebiger Reihenfolge)
                          am ANFANG einer Textzeile gesetzt werden:

                          Fett          = '!'
                          Unterstrichen = '_'
                          Kursiv        = '/'
                          Hell          = '~'
                          Umrandet      = '#'
                          Schattiert    = '@'
                          3D            = '%'

                          LinksbÅndig   = '<' (voreingestellt)
                          Zentriert     = ':'
                          RechtsbÅndig  = '>'

                          Kleiner Font  = '^'

               buttons:   Button-Text (maximal 6 Buttons getrennt durch
                          '|', Hotkeymarkierung durch '[') oder NULL fÅr
                          "[Ok"

        ALERT-Struktur:
        ---------------

        typedef struct
        {
            /* Zeiger auf Objektbaum der Alertbox */
            OBJECT  *tree;

            /* alle weiteren Variablen dieser Struktur sind nur fÅr INTERNE
               Zwecke */
        } ALERT;

        ALERT *MakeAlert(int default,int undo,int icon,BITBLK *user_icon,
                        int modal,int center,int width,
                        char *title,char *text,char *buttons)
            -> Erzeugt einen neuen Objektbaum einer Alertbox mit den
               gewÅnschten Parametern (s. Funktion xalert()). Hierdurch
               kann dieser Dialog selber verwaltet/fÅr eigene Zwecke ver-
               wendet und auch nonmodal sowie mehrfach geîffnet werden.
               Der Zeiger auf die ALERT-Struktur muû SOFORT nach dem ôffnen
               des Dialogs in der Variablen 'di_alert' der DIAINFO-Struktur
               eingetragen werden, damit die Speicherbereiche fÅr die Alert-
               box beim Schlieûen des Dialogs automatisch freigegeben wer-
               den.
            -> RÅckgabewert:
               Zeiger auf ALERT-Struktur oder NULL, falls nicht genÅgend
               Speicher vorhanden ist

        int ExitAlert(ALERT *alert,int exit)
            -> Button-Index aus angeklicktem Alert-Objekt berechnen.
               Diese Funktion schlieût weder den Dialog noch gibt sie den
               Speicher der Alertbox frei!
            -> Parameter:
               alert: Zeiger auf ALERT-Struktur der Alertbox
               exit:  RÅckgabewert der Funktion X_Form_Do() bzw. selek-
                      tiertes Objekt
            -> RÅckgabewert:
               Index des Buttons (s. Funktion xalert()) oder FAIL, falls
               Close-Box angeklickt oder Dialog beendet wurde

        char ascii_box(DIAINFO *dialog,char *title)
            -> Sonderzeicheneingabebox îffnen (kann mehrfach geîffnet
               werden)
            -> Parameter:
                 dialog: Zeiger auf DIAINFO-Struktur des Dialogs, in
                         dessen aktuelles Eingabefeld die Sonderzeichen
                         eingefÅgt werden sollen oder NULL, wenn die
                         Sonderzeichen zurÅckgeliefert werden sollen
                 title:  Zeiger auf Titel fÅr Fensterdialog oder NULL
            -> RÅckgabewert: ausgewÑhltes Zeichen oder Null

        OBJECT *MakeAscii(void)
            -> Erzeugt eine Kopie des Sonderzeicheneingabebaums. Hierdurch
               kann dieser Dialog selber verwaltet/fÅr eigene Zwecke ver-
               wendet und auch nonmodal sowie mehrfach geîffnet werden.
               Der Zeiger auf den Objektbaum muû NACH dem ôffnen des Dialogs
               in der Variablen 'di_mem' der DIAINFO-Struktur eingetragen
               werden, damit der Speicherbereich fÅr den Objektbaum beim
               Schlieûen des Dialogs automatisch freigegeben wird. Ansons-
               ten muû der Speicher von der Anwendung freigegeben werden.
            -> RÅckgabewert:
               Zeiger auf Objektbaum oder NULL, falls nicht genÅgend
               Speicher vorhanden ist

        char ExitAscii(OBJECT *tree,int exit)
            -> gewÅnschten ASCII-Wert in Sonderzeicheneingabebox aus an-
               geklicktem Objekt berechnen. Diese Funktion schlieût weder
               den Dialog noch gibt sie den Speicher des Baums frei!
            -> Parameter:
               tree: Zeiger auf Baum der Sonderzeicheneingabebox
               exit: RÅckgabewert der Funktion X_Form_Do() bzw. selektiertes
                     Objekt
            -> RÅckgabewert:
               ASCII-Wert des Zeichens oder Null, falls Hintergrund oder
               Close-Box angeklickt wurde.

    15. Fenster-Funktionen
        ------------------

        WIN-Struktur:
        -------------

        typedef struct
        {
             /* Handle des Fensters (handle>0, falls Fenster geîffnet) */
             int handle;

             /* VDI-Handle der zum Fenster gehîrenden VDI-Workstation
               (nach Aufruf von open_window() ist die Library-Workstation
                x_handle als VDI-Workstation gesetzt. Bei Bedarf kann
                man danach dieses Handle auf den Wert einer anderen
                Workstation oder auf einen ungÅltigen Wert (<0) setzen,
                so daû im letzten Fall das Clipping bei einer Fenster-
                ausgabe nicht von der Library gesetzt wird) */
             int vdi_handle;

             /* Bitmap der Fensterelemente (s. wind_create). Wurde beim
                ôffnen das Element SMALLER angegeben, so kann durch nach-
                trÑgliches Lîschen dieses Bits in dieser Variablen die
                automatische Ikonifizierung deaktiviert werden. */
             int gadgets;

             /* Bitmap des Fenster-Status (ICONIFIED und ICFS sind nie
                gesetzt, wenn Library mit SMALL_NO_ICONIFY Åbersetzt
                wurde) */
             char iconified;

                 #define SHADE      1  /* Fenster eingeklappt (Winx 2.3) */
                 #define ICONIFIED  2  /* Fenster ikonifiziert (MTOS) */
                 #define ICFS       4  /* Fenster ikonifiziert (ICFS) */

             /* Fenster hat maximale Ausmaûe */
             char fulled;

             /* Grîûe (1-1000)/Position (0-1000) des horiz. Sliders */
             int sl_hpos,sl_hsize;

             /* Grîûe (1-1000)/Position (0-1000) des vert. Sliders */
             int sl_vpos,sl_vsize;

             /* Zeiger auf SCROLL-Struktur oder NULL (nicht vorhanden,
                wenn Library mit SMALL_NO_SCROLL Åbersetzt wurde) */
             SCROLL *scroll;

             /* Zeiger auf Fenster-Titel u. -infozeile oder NULL */
             char   *name,*info;

             /* minimale Fensterbreite/-hîhe */
             int min_w,min_h;

             /* maximale Fensterausmaûe */
             GRECT max;

             /* bei open_window()-angegebener beliebiger Parameter */
             void *para;

             /* Zeiger auf DIAINFO-Struktur des zugehîrigen Fenster-Dialogs
                oder NULL, falls es sich um ein normales Fenster handelt */
             void *dialog;

             /* Die folgenden 3 Variablen icon, icon_name und icon_work
                sind nicht vorhanden, falls Library mit SMALL_NO_ICONIFY
                Åbersetzt wurde */

             /* Zeiger auf Objektbaum, der fÅr die ikonifizierte Darstellung
                benutzt wird, oder
                NULL: globaler Objektbaum iconified wird benutzt. Ist
                      dieser nicht gesetzt, so wird in der ikonifizierten
                      Darstellung nur ein weiûer Hintergrund gezeichnet.
                NIL:  Redraw-Handler aufrufen oder, falls dieser nicht ge-
                      setzt ist, WM_REDRAW-Nachrichten an Applikation durch-
                      reichen */
             OBJECT *icon;

             /* Zeiger auf Titel im ikonifizierten Zustand oder NULL */
             char   *icon_name;

             /* Arbeitsbereich des ikonifizierten Fensters */
             GRECT  icon_work;

             /* Die folgenden Variablen beziehen sich IMMER auf den
                nicht ikonifizierten Zustand des Fensters! */

             /* aktuelle Fensterausmaûe */
             GRECT curr;

             /* vorherige Fensterausmaûe */
             GRECT prev;

             /* Fensterarbeitsbereich */
             GRECT work;

            /* alle weiteren Variablen dieser Struktur sind fÅr
               INTERNE Zwecke reserviert */
        } WIN;

        SCROLL-Struktur:
        ----------------

        typedef struct
        {
            /* Scroll-Modus:
               NO_SCROLL   -> nur Slider (Position und Grîûe) setzen und
                              neue Werte der SCROLL-Struktur berechnen
                              (Fensterinhalt kann z.B. manuell nach Erhalt
                               der Nachricht WIN_SCROLLED angepaût werden)
               AUTO_SCROLL -> Fensterinhalt wird zusÑtzlich automatisch
                              verschoben und neugezeichnet
               FAST_SCROLL -> schnelles automatisches Fensterscrolling
                              (nur mîglich, wenn das Fenster Åber einen
                              Redraw-Handler verfÅgt und Winx nicht vor-
                              handen ist). WÑhrend des Scrollings ist das
                              Event-Handling blockiert, so daû u.a. keine
                              Timer-Events mehr vorkommen, weswegen man bei
                              kritischen Programmen/Routinen AUTO_SCROLL
                              verwenden sollte */
            int scroll;

            /* Index des Objekts, welches beim automatischen Scrolling
               (AUTO_SCROLL/FAST_SCROLL) eines Dialogs neugezeichnet werden
               soll. Hier kann natÅrlich immer das Wurzelobjekt angegeben
               werden (Clipping wird von der Library durchgefÅhrt), aber
               aus GeschwindigkeitsgrÅnden sollte man nur das betreffende
               Objekt angeben */
            int obj;

            /* Breite des Bereichs am linken/rechten Rand, der nicht
               verschoben werden darf (z.B. eine Toolbar). Diese Werte
               werden auch fÅr die Berechnung der Sliderposition/-grîûe
               benîtigt */
            int tbar_l,tbar_r;

            /* Breite des Bereichs am oberen/unteren Rand, der nicht
               verschoben werden darf (z.B. eine Toolbar) Diese Werte
               werden auch fÅr die Berechnung der Sliderposition/-grîûe
               benîtigt */
            int tbar_u,tbar_d;

            /* Breite/Hîhe einer Spalte/Zeile
               (z.B. bei Textfenstern die Fontgrîûe, bei Grafikfenstern
                meistens 1) */
            int px_hline,px_vline;

            /* Horizontale/vertikale Position des Fensterinhalts
               (in Spalten/Zeilen) */
            long hpos,vpos;

            /* Horizontale/vertikale Position des Fensterinhalts in
               Pixeln. Diese Variablen dÅrfen nicht verÑndert werden bzw.
               werden von der Library berechnet! Auûerdem sind sie nicht
               gÅltig, wenn vorher die Variablen 'hpos' bzw. 'vpos'
               manuell geÑndert wurden und das Fenster noch nicht
               angepaût wurde (mit einer der Funktionen redraw_window,
               scroll_window oder window_reinit)) */
            long px_hpos,px_vpos;

            /* Horizontale/vertikale Fenstergrîûe (in Spalten/Zeilen) */
            long hsize,vsize;

            /* Horizontale/vertikale Seitengrîûe (in Spalten/Zeilen)
               (diese Variablen dÅrfen nicht verÑndert werden bzw. werden
               von der Library berechnet!) */
            int hpage,vpage;

            /* Horizontale/vertikale Schrittweite (in Spalten/Zeilen) */
            int hscroll,vscroll;

             /* alle weiteren Variablen dieser Struktur sind fÅr
               INTERNE Zwecke reserviert */
        } SCROLL;

        Hinweis:
        Sowohl die SCROLL-Struktur als auch die Funktion scroll_window()
        sind unabhÑngig von den vorhandenen Fensterelementen, d.h. es
        kînnen z.B. auch Fenster ohne Schieber/Pfeile verschoben bzw.
        ausgewertet werden.
        Bei geîffneten systemmodalen Dialogen oder Popups werden Nach-
        richten und zu setzende Werte automatisch bis zum Schlieûen der
        der Dialoge/Popups gepuffert und dann an die Ereignisverwaltung
        weitergeleitet.

        WIN *open_window(char *title,char *icon_title,char *info,
                         OBJECT *icon,int gadgets,int box,
                         int min_w,int min_h,
                         GRECT *max,GRECT *curr,SCROLL *scroll,
                         void (*redraw)(int first,WIN *win,GRECT *area),
                         void *para,int msgs)
            -> Fenster îffnen und bei einem evtl. vorhandenen AV-Server
               anmelden (AV_ACCWINDOPEN) sowie gegebenenfalls die Hinter-
               grundbedienung aktivieren
            -> Parameter:
               title:      Zeiger auf Fenstertitel oder NULL
               icon_title: Zeiger auf Fenstertitel im ikonifizierten Zu-
                           stand oder NULL (in diesem Fall wird der Titel
                           'title' benutzt)
               info:       Zeiger auf Infozeile oder NULL
               icon:       Zeiger auf Objektbaum, der fÅr die ikonifizierte
                           Darstellung benutzt wird, oder
                           NULL: globaler Objektbaum iconified wird be-
                                 nutzt. Ist dieser nicht gesetzt, so wird
                                 in der ikonifizierten Darstellung nur ein
                                 weiûer Hintergrund gezeichnet.
                           NIL:  Redraw-Handler aufrufen oder, falls dieser
                                 nicht gesetzt ist, WM_REDRAW-Nachrichten an
                                 Applikation durchreichen
               gadgets:    Bitmap der Fensterelemente wie bei wind_create().
                           Ist SMALLER gesetzt, so kann das Fenster ikoni-
                           fiziert werden, auch wenn dies vom AES nicht
                           unterstÅtzt wird.
               box:        sich vergrîûernde Rechtecke zeichnen (box!=0)
               min_w,min_h:minimale Fensterbreite/Hîhe. Diese Werte werden
                           evtl. intern auf sinnvolle Werte gesetzt, wenn
                           die Åbergebenen Werte zu klein sind (z.B. Null)
               min_h:      minimale Fensterhîhe
               max:        maximale Fensterausmaûe (wird gegebenenfalls
                           auf die Desktopausmaûe beschrÑnkt) oder NULL fÅr
                           den Desktopbereich
                           max->g_x/g_y: minimale linke, obere Fenster-
                                         koordinaten (normalerweise die
                                         entsprechenden Koordinaten des
                                         Desktopfensters 'desk')
                           max->g_w/g_h: maximale Fensterbreite/-hîhe
               curr:       Fensterausmaûe
               scroll:     Zeiger auf initialisierte SCROLL-Struktur fÅr
                           automatisches Scrolling oder NULL. Wurde die
                           Scroll-Position geÑndert, so wird eine Nachricht
                           WIN_SCROLLED verschickt. U.a. werden von der
                           Library in diesem Fall auch Slidergrîûe und
                           -position automatisch gesetzt. (Dummy-Parameter,
                           falls Library mit SMALL_NO_SCROLL Åbersetzt
                           wurde)
               redraw:     Routine, die den Fenster-Redraw Åbernimmt. Dabei
                           muû weder das Åbergebene Rechteck 'area' mit der
                           Rechteckliste geschnitten noch das Clipping der
                           VDI-Workstation gesetzt werden! (VDI-Handle der
                           WIN-Struktur nach Aufruf von open_window()
                           gegebenenfalls auf anderen Wert als die globale
                           Library-Workstation x_handle setzen). Wird fÅr
                           'redraw' NULL Åbergeben, so wird die Nachricht
                           WM_REDRAW wie Åblich weitergeleitet.
                           Parameter 'first':
                           Bit 0: (RC_FIRST)
                             -> erstes Rechteck der Rechteckliste
                           Bit 1: (RC_SCROLL)
                             -> Scrolling (Bit gesetzt) oder Redraw
                           Der Redraw-Handler wird allerdings NUR aufgerufen,
                           wenn das Fenster NICHT ikonifiziert ist, d.h. in
                           diesem Fall wird der Redraw automatisch von der
                           Library vorgenommen.
               para:       beliebiger Parameter, der in der WIN-Struktur ge-
                           speichert wird und beispielsweise auf die zum
                           Fenster gehîrigen Daten-Strukturen zeigt
               msgs:       Bitmap der Fenster-Nachrichten, die automatisch
                           ausgewertet werden sollen (WM_REDRAW und Slider-
                           Nachrichten (WM_ARROWED,WM_HSLID,WM_VSLID) werden
                           in AbhÑngigkeit von den anderen Parametern ausge-
                           wertet; WM_CLOSED muû von der Applikation ausge-
                           wertet werden)

                             XM_TOP:    WM_TOPPED
                             XM_BOTTOM: WM_BOTTOMED
                             XM_SIZE:   WM_FULLED,WM_SIZED,WM_MOVED
                                        (Nachricht WIN_SIZED wird an Event-
                                         Handler bei Positions-/Grîûen-
                                         Ñnderung verschickt)

            -> RÅckgabewert: Zeiger auf WIN-Struktur oder NULL

        void window_reinit(WIN *win,char *title,char *icon_title,
                           char *info,int home,int draw)
            -> Fenster 'win' reinitialisieren und evtl. neuzeichnen. U.a.
               wird gegebenenfalls die SCROLL-Struktur auf gÅltige
               Werte gesetzt und die Grîûe des Fensters an die maximalen
               bzw. minimalen Ausmaûe angepaût.
            -> Parameter:
               title:      Zeiger auf Fenstertitel oder NULL
               icon_title: Zeiger auf Fenstertitel im ikonifizierten Zu-
                           stand oder NULL
               info:       Zeiger auf Infozeile oder NULL
               home:       Scroll-Position in linke obere Ecke (home!=0)
                           (keine Bedeutung, falls Library mit
                            SMALL_NO_SCROLL Åbersetzt wurde)
               draw:       TRUE  -> Fenster ohne Toolbar-Bereich neuzeichnen
                           FALSE -> komplettes Fenster neuzeichnen
                           FAIL  -> Fenster nicht neuzeichnen

        int close_window(WIN *window,int box)
            -> Fenster 'window' schlieûen und gegebenenfalls (box!=0) sich
               verkleinernde Rechtecke zeichnen. Auûerdem wird das Fenster
               bei einem evtl. vorhandenem AV-Server abgemeldet
               (AV_ACCWINDCLOSE).
            -> RÅckgabewert gleich Null, wenn ein Fehler auftrat

        void close_all_windows(void)
            -> Alle geîffneten Fenster schlieûen. Sind vorher noch Dialoge
               geîffnet, so werden diese ebenfalls geschlossen.

        void draw_window(WIN *win,GRECT *area,void *para,int mouse,
                         void (*draw)(int first,WIN *win,GRECT *area,
                         GRECT *work,void *para))
            -> beliebige Ausgabe in Fenster 'win' Åber Ausgabe-Funktion
               'draw' vornehmen. Dabei muû es sich nicht um den Redraw-
               Handler handeln, so daû z.B. einzelne Objekte des Fensters
               ausgegeben werden kînnen. Ebenso kann eine Ausgabe in
               ikonifizierten Fenstern vorgenommen werden.
            -> Parameter:
               win:        Zeiger auf WIN-Struktur des Ausgabe-Fensters
               area:       Ausgabebereich oder NULL fÅr Desktop (wird mit
                           der Rechteckliste des Fensters geschnitten)
               para:       beliebiger Parameter, der an den Ausgabe-Handler
                           Åbergeben wird
               mouse:      MOUSE_OFF: Maus vor Ausgabe ausschalten und
                                      anschlieûend wieder einschalten
                           MOUSE_ON:  Maus nicht aus-/anschalten (z.B. bei
                                      AES-Objektausgabe per objc_draw
                                      unnîtig)
                           MOUSE_TEST:Maus nur aus-/anschalten, wenn der
                                      Mauszeiger sich innerhalb des Ausgabe-
                                      bereichs befindet. Dies kann in man-
                                      chen FÑllen bei sehr schnellen Maus-
                                      bewegungen und einer relativ langsamen
                                      Ausgabe zu kleineren Redraw-Fehlern
                                      fÅhren
               draw:       Parameter der Ausgabe-Funktion:
                           first: Bit 0: (RC_FIRST)
                                    -> erstes Ausgaberechteck des Fensters
                           win:   Zeiger auf WIN-Struktur des Fensters
                           area:  Ausgabebereich (Clipping muû nicht ge-
                                  setzt werden, wenn das VDI-Handle der WIN-
                                  Struktur gÅltig ist)
                           work:  Arbeitsbereich des Fensters (entspricht
                                  den Variablen 'work' bzw. 'icon_work'
                                  (im ikonifizierten Zustand) der WIN-Struk-
                                  tur)
                           para:  Parameter, der bei draw_window() Åber-
                                  geben wurde

        void redraw_window(WIN *win,GRECT *area)
            -> Lîst einen Redraw Åber das Rechteck 'area' (area!=NULL) des
               Fensters 'win' oder den gesamten Fensterbereich (area==NULL)
               aus. Wurde fÅr das Fenster kein Redraw-Handler angemeldet,
               so wird eine WM_REDRAW-Nachricht verschickt.

        void scroll_window(WIN *win,int mode,GRECT *area)
            -> Fensterinhalt des Fensters 'win' in AbhÑngigkeit vom Para-
               meter 'mode' scrollen (Fenster muû Åber eine SCROLL-Struktur
               verfÅgen!), wobei sowohl Slidergrîûe als auch -position
               automatisch angepaût werden.
            -> Parameter:
                area: Bereich des Fensters oder NULL fÅr gesamtes Fenster
                      abzÅglich der in der SCROLL-Struktur angegebenen
                      Toolbar-Bereiche
                mode:
                /* an Anfang/Ende der Zeile */
                LINE_START,LINE_END

                /* an Anfang/Ende des Fensterinhalts */
                WIN_START,WIN_END

                /* Position (hpos,vpos) bereits gesetzt (wird automatisch
                   an gÅltigen Bereich angepaût) */
                WIN_SCROLL

                /* Seite nach links/oben/rechts/unten */
                PAGE_LEFT,PAGE_UP,PAGE_RIGHT,PAGE_DOWN

                /* Zeile/Spalte nach links/oben/rechts/unten */
                LINE_LEFT,LINE_UP,LINE_RIGHT,LINE_DOWN

        WIN *get_window(int handle)
            -> WIN-Struktur zum Fenster 'handle' ermitteln
            -> RÅckgabewert gleich NULL, falls Struktur nicht gefunden
               werden konnte

        WIN *get_top_window(void)
            -> WIN-Struktur zum obersten Fenster ermitteln
            -> RÅckgabewert gleich NULL, falls Struktur nicht gefunden
               werden konnte (Fenster gehîrt anderer Applikation oder
               kein Fenster geîffnet)

        WIN *get_window_list(int first)
            -> erste (first==TRUE) oder nÑchste (first==FALSE) WIN-Struktur
               der internen Fensterliste ermitteln. Dabei sind die Fenster
               entsprechend der Reihenfolge auf dem Bildschirm sortiert,
               d.h. get_window_list(TRUE) liefert z.B. immer das oberste
               Fenster der Applikation, unabhÑngig davon ob es von den
               Fenstern einer anderen Applikation verdeckt wird
            -> RÅckgabewert gleich NULL, falls kein Fenster geîffnet ist
               oder Liste bereits komplett abgearbeitet

        int GetTop(void)
            -> Handle des obersten Fensters ermitteln (Fenster kann auch
               einer anderen Applikation gehîren), funktioniert auch unter
               Mag!C/Mag!X

        int window_first(WIN *win,GRECT *rect);
            -> VerkÅrzter und optimierter Aufruf von
               wind_xget(handle,WF_FIRSTXYWH,...)
            -> Falls der RÅckgabewert ungleich Null ist, so enthÑlt das
               Rechteck 'rect' den ersten Ausgabebereich. Ansonsten (z.B.
               fehlerhaftes Fenster-Handle oder keine Ausgabe mîglich) ist
               die Breite und Hîhe des Ausgaberechtecks auf Null gesetzt.

        int window_next(WIN *win,GRECT *rect);
            -> VerkÅrzter und optimierter Aufruf von
               wind_xget(handle,WF_NEXTXYWH,...)
            -> Falls der RÅckgabewert ungleich Null ist, so enthÑlt das
               Rechteck 'rect' den nÑchsten Ausgabebereich. Ansonsten (z.B.
               fehlerhaftes Fenster-Handle, kein vorheriger Aufruf von
               window_first() oder keine Ausgabe mîglich) ist die Breite und
               Hîhe des Ausgaberechtecks auf Null gesetzt.

        void window_size(WIN *win,GRECT *size)
            -> Ausmaûe des Fensters 'win' auf 'size' setzen
               (im ikonifizierten Zustand wird die Grîûe erst nach der
                Deikonifizierung gesetzt)
            -> Wurde eine SCROLL-Struktur beim ôffnen des Fenster
               Åbergeben, so werden von dieser Funktion auch Slidergrîûe
               und -position automatisch gesetzt, wobei evtl. der Fenster-
               inhalt verschoben wird.

        void window_slider(WIN *win,int vh,int pos,int size)
            -> Vertikalen (vh==VERT_SLIDER) oder horizontalen
               (vh==HOR_SLIDER) Slider des Fensters 'win' setzen
               (im ikonifizierten Zustand werden die Werte erst nach der
                Deikonifizierung gesetzt)
            -> Parameter:
               pos:  Position des Sliders (0-1000) oder negativer Wert
               size: Grîûe des Sliders (1-1000,0=minimale Grîûe) oder
                     negativer Wert

        void window_set_mouse(WIN *win,int in,int work,int out,int icon,
                              MFORM *in_form,MFORM *work_form,
                              MFORM *out_form,MFORM *icon_form)
            -> Form des Mauszeigers in AbhÑngigkeit von der Position rela-
               tiv zum Fenster 'win' festlegen und setzen (der Mauszeiger
               wird dann vollautomatisch in AbhÑngigkeit vom obersten
               Fenster/Dialog verwaltet, solange die Ausgabe nicht durch
               die Funktionen MouseUpdate() oder beg_ctrl() gesperrt wurde).
               Diese Funktion kann auch bei Fensterdialogen angewendet we-
               rden, wobei bei allen Fenstern der Pfeil fÅr alle Bereiche
               voreingestellt ist.
               Soll der Mauszeiger innerhalb eines Bereichs verschiedene
               Formen annehmen (z.B. abhÑngig vom Objekt unter dem Zeiger),
               so kann dies durch eine Mouse-Event, der das Verlassen oder
               Betreten dieser Objekte Åberwacht und dann diese Funktion
               mit entsprechend neuen Parametern aufruft, realisiert werden,
               wobei fÅr Dialoge die entsprechende Funktion dialog_mouse()
               genutzt werden kann/sollte.
            -> Parameter:
               in, in_form:     Mausform innerhalb des Fensterbereichs,
                                aber nicht im Arbeitsbereich (z.B. Åber
                                Toolbar) (Bedeutung s. graf_mouse()).
               work, work_form: Mausform innerhalb des Arbeitsbereichs
               icon, icon_form: Mausform innerhalb des ikonifizierten
                                Fensterbereichs
               out, out_form:   Mausform auûerhalb des Fensterbereichs

         void WindowItems(WIN *win,int cnt,MITEM *items)
            -> Hotkeys/Tastaturkommandos sowie evtl. dazugehîrige
               MenÅpunkte fÅr das Fenster 'win' definieren. Die jeweiligen
               Aktionen (Auswahl des MenÅpunkts oder Tastendruck) werden
               automatisch ausgewertet. U.a. ist hierdurch ein auto-
               matisches Tastaturscrolling fÅr Fenster mîglich.
            -> Parameter:
               cnt:   Anzahl der MITEM-Strukturen
               items: Zeiger auf Array mit MITEM-Strukturen

        void window_name(WIN *win,char *title,char *icon_title)
            -> Titel des Fensters 'win' setzen
            -> Parameter:
               title:      Zeiger auf Fenstertitel oder NULL
               icon_title: Zeiger auf Fenstertitel im ikonifizierten Zu-
                           stand oder NULL (in diesem Fall wird der Titel
                           'title' benutzt)

        void window_info(WIN *win,char *info)
            -> Info-Zeile des Fensters 'win' setzen (im ikonifizierten
               Zustand wird die Info-Zeile erst nach der Deikonifizierung
               gesetzt)
            -> Parameter:
               info: Zeiger auf Infozeile oder NULL

        void window_top(WIN *win)
            -> Fenster 'win' nach oben bringen (entspricht
               wind_set(handle,WF_TOP))

        void window_bottom(WIN *win)
            -> Fenster 'win' nach unten legen (entspricht
               wind_set(handle,WF_BOTTOM))

        WIN *window_find(int x,int y)
            -> WIN-Struktur des Fensters an den Koordinaten (x,y)
               ermitteln
            -> RÅckgabewert gleich NULL, falls Struktur nicht gefunden
               werden konnte

        int window_work(WIN *win,GRECT *out)
            -> Arbeitsbereich des Fensters 'win' abzÅglich eventuell
               vorhandener Toolbarbereiche berechnen und im Rechteck
               'out' zurÅckgeben
            -> RÅckgabewert:
               TRUE  -> Rechteck 'out' gÅltig
               FALSE -> Arbeitsbereich nicht sichtbar

        void window_calc(int wctype,int kind,GRECT *in,GRECT *out)
            -> Entspricht von der FunktionalitÑt der AES-Funktion
               wind_calc(), nur daû anstatt einzelner Parameter Zeiger
               auf GRECT-Strukturen erwartet werden

        void window_border(int kind,int x,int y,int w,int h,GRECT *out)
            -> Koordinaten des Randbereichs (WC_BORDER) aus der linken,
               oberen Ecke (x,y) des Fensters und der Breite/Hîhe des
               Arbeitsbereiches (w,h) berechnen und im Recheck 'out'
               zurÅckgeben. Dabei wird das Ausgaberechteck automatisch
               auf den Desktop begrenzt.

        void windial_calc(int calc_work,DIAINFO *info,GRECT *work)
            -> Objektbaumausmaûe oder Fensterarbeitsbereich des Dialogs
               'info' berechnen
            -> Parameter:
               calc_work: Arbeitsbereich des Fensters (calc_work!=0) aus
                          Ausmaûen des Wurzelobjekts des Dialogobjektbaums
                          oder umgekehrt (calc_work==0) berechnen
               work:      GewÅnschte Ausmaûe als GRECT-Struktur

        int window_output(void)
            -> Testet, ob Ausgabe in ein Fenster mîglich ist
            -> RÅckgabewert gleich Null, wenn Ausgabe unmîglich (z.B.
               (fliegender) Dialog oder Popup geîffnet)

        int WindowHandler(int mode,WIN *window,GRECT *icon)
            -> verschiedene Fenster-Funktionen (abhÑngig vom Parameter
               'mode') ausfÅhren
            -> Parameter:
               mode: GewÅnschte Funktion:
                      W_CLOSE:       Fenster schlieûen (entspricht dem An-
                                     klicken der Fenster-Schlieûbox, d.h.
                                     das Fenster wird NICHT sofort ge-
                                     schlossen)
                      W_CLOSEALL:    Alle Fenster schlieûen (W_CLOSE fÅr
                                     alle Fenster). (i.A. sollte man diese
                                     Funktion nur verwenden, wenn beim
                                     Schlieûen der Fenster keine RÅckfra-
                                     gen an den Benutzer nîtig sind oder
                                     diese nur in systemmodalen Alertboxen
                                     bzw. Dialogen erscheinen bzw. per
                                     beg/end_ctrl geklammert sind!).
                      W_CYCLE:       Fenster wechseln
                      W_INVCYCLE:    Fenster rÅckwÑrts wechseln
                      W_GLOBALCYCLE: Fenster global wechseln (nur mîglich,
                                     wenn AV-Server oder neuere AES-Version
                                     mit wind_get(WF_OWNER) vorhanden ist)
                      W_FULL:        Fenster auf maximale Grîûe (entspricht
                                     dem Anklicken des Fenster-Fullers)
                      W_BOTTOM:      oberstes Fenster (unabhÑngig davon, ob
                                     es der Applikation gehîrt) in Hinter-
                                     grund legen (wird diese Funktion nicht
                                     vom AES angeboten, so versucht die
                                     Library, diese Funktion zu simulieren)
                      W_ICONIFY:     Fenster ikonifizieren. Ist das Fenster
                                     bereits ikonifiziert, so wird es de-
                                     ikonifiziert.
                      W_ICONIFYALL:  Alle Fenster einzeln ikonifizieren.
                                     Sind bereits alle Fenster ikonifiziert,
                                     so werden die Fenster deikonifiziert.
                      W_ICONIFYALLINONE:
                                     Alle Fenster in EIN Fenster ikonifi-
                                     zieren (noch nicht implementiert).
                      W_UNICONIFY:   Fenster deikonifizieren
                      W_UNICONIFYALL:Alle Fenster deikonifizieren

              window: GewÅnschtes Fenster (window!=NULL) oder oberstes
                      Fenster (window==NULL). Dieser Parameter ist nur bei
                      den Funktionen W_CLOSE, W_FULL, W_ICONIFY und
                      W_UNICONIFY von Bedeutung.

              icon:   Ausmaûe des ikonifizierten Fensters. Dieser Parameter
                      wird nur bei den Funktion W_ICONIFY und
                      W_ICONIFYALLINONE benîtigt, sofern die MTOS-
                      Ikonifizierung aktiv ist.

           -> RÅckgabewert:
              TRUE:  Funktion wurde ausgefÅhrt
              FALSE: Funktion konnte nicht ausgefÅhrt werden (z.B. Fenster
                     ist bereits (de-) ikonifiziert, oberstes Fenster ge-
                     hîrt nicht der Applikation, keine Fensterausgabe mîg-
                     lich, entsprechendes Fensterelement nicht vorhanden)

    16. Update/Control-Funktionen
        -------------------------

        Hinweis:
        --------
        Die folgenden Funktionen merken sich intern den aktuellen Status
        und vermeiden so unnîtige AES-Aufrufe, d.h. die AES-Funktion
        wind_update() sollte nicht mehr benutzt werden!

        int beg_update(int test,int off)
            -> Update-Status setzen (test==0) bzw. testen, ob Status
               gesetzt werden kann und dann evtl. setzen und optional
               Maus ausschalten (off!=0)
            -> RÅckgabewert:
               TRUE:  Status konnte gesetzt werden
               FALSE: Status konnte nicht gesetzt werden (z.B. weil eine
                      andere Applikation bereits den Status gesetzt hat)

        void end_update(int on)
            -> Update-Status wieder lîschen und Maus einschalten (on!=0)

        int beg_ctrl(int test,int output,int mouse)
            -> Maus-Kontrolle Åbernehmen und Update-Status (s. beg_update)
               setzen (nur innerhalb einer beg/end_ctrl()- oder
               MouseUpdate()-Klammerung kann der Mauszeiger beliebig ver-
               waltet/geÑndert werden; siehe window_set_mouse())
            -> Parameter:
               test:   Mouse-Status setzen (test==0) bzw. testen, ob Status
                       gesetzt werden kann und dann evtl. setzen (test!=0)
               output: Ausgabemîglichkeit Åber Bibliotheksfunktionen
                       wÑhrend Klammerung sperren und zusÑtzlich Maus
                       sperren (s.u.) (output!=0)
               mouse:  automatische Mauszeigerverwaltung wÑhrend Klammerung
                       sperren (Maus wird automatisch nach Freigabe wieder
                       initialisiert) (mouse!=0)
            -> RÅckgabewerte:
               TRUE:  Status konnte gesetzt werden
               FALSE: Status konnte nicht gesetzt werden (z.B. weil eine
                      andere Applikation bereits den Status gesetzt hat)

        void end_ctrl(int output,int mouse)
            -> Maus-Kontrolle wieder abgeben
            -> Parameter:
               output: Bildschirmausgabe wieder freigeben (output!=0)
               test:   Mausverwaltung wieder freigeben (mouse!=0)

        void MouseUpdate(int block)
            -> automatische Mauszeigerverwaltung sperren (block==TRUE) oder
               freigeben (block==FALSE). Innerhalb einer MouseUpdate()-
               Klammerung kann der Mauszeiger beliebig geÑndert werden und
               wird automatisch nach der Freigabe wieder initialisiert.

    17. Popup-Funktion
        --------------

        POPUP-Struktur:
        ---------------

            typedef struct
            {
                /* Zeiger auf DIAINFO-Struktur des Parent-Dialogs
                   oder NULL */
                DIAINFO *p_info;

                /* Zeiger auf Objektbaum des Popups (alle selektierbaren
                   Objekte (beliebiger Objekttyp) des Popups mÅssen Kinder
                   des Wurzelobjekts sein und innerhalb dieses Rahmenobjekts
                   liegen; ansonsten unterliegt der Popup-Aufbau keinen
                   EinschrÑnkungen) */
                OBJECT  *p_menu;

                /* Objektnummer des Info-Objekts (meistens Text links vom
                   Popup-Button) oder negativer Wert */
                int     p_parent;

                /* Objektnummer des Popup-Buttons oder negativer Wert */
                int     p_button;

                /* Objektnummer des Cycle-Buttons (dabei muû es sich nicht
                   um den erweiterten Typ CYCLE_BUTTON handeln) oder
                   negativer Wert */
                int     p_cycle;

                /* Beim Erreichen des ersten/letzten Eintrags mit den Cur-
                   sor-Tasten Hoch/Runter wird zum letzten/ersten Eintrag
                   gesprungen */
                boolean p_wrap;

                /* Der Text des Popup-Buttons wird automatisch auf den
                   Wert des aktuellen Eintrags gesetzt und nach dem Ende
                   der Popup-Bearbeitung neugezeichnet */
                boolean p_set;

                /* Zeiger auf Funktion, welche bei der Selektion oder der
                   Auswahl eines Popup-Eintrags (allerdings nicht im Cycle-
                   Modus!) aufgerufen wird (oder NULL). Hierdurch kînnen
                   beispielsweise SubmenÅs realisiert werden (s. Beispiel-
                   programm 'DialDemo') */
                int (*p_func)(POPUP *popup,int current,int mode);

                /* Parameter:
                   popup:   Zeiger auf POPUP-Struktur des Popups
                   current: Objektnummer des ausgewÑhlten Eintrags oder
                            negativer Wert, falls kein Eintrag selektiert
                   mode:    Bitmap des Selektionmodus:
                            POPUP_MOUSE:    Eintrag wurde per Maus (Bit ge-
                                            setzt) oder Tastatur ausgewÑhlt
                            POPUP_EXITENTRY:Popup soll mit gewÑhltem Ein-
                                            trag verlassen werden
                            POPUP_DCLICK:   Eintrag wurde per Doppelklick
                                            bzw. bei gedrÅckter Shift-Taste
                                            ausgewÑhlt
                            POPUP_RCLICK:   Eintrag wurde per Rechtsklick
                                            bzw. bei gedrÅckter Control-
                                            Taste ausgewÑhlt
                   RÅckgabewert:
                   POPUP_EXIT: Popup verlassen
                   POPUP_CONT: Popup weiter bearbeiten
                */
            } POPUP;

        XPOPUP-Struktur:
        ----------------

        typedef struct
        {
            /* POPUP-Struktur des Popups */
            POPUP  popup;

            /* Eindeutige positive Identifikationsnummer (wird nur beim
               Popup-Modus POPUP_MENU und der erweiterten MN_SELECTED-
               Nachricht benîtigt */
            int    id;

            /* Popup-Modus (Auswahl des Popup-Buttons/Infotextes) und
               Cycle-Modus (Auswahl des Cycle-Buttons). Bei einem negativen
               Wert fÅr den Cycle-Modus wird beim Cycle-Button ebenfalls
               der Popup-Modus benutzt. Ist beim Cycle-Modus POPUP_CYCLE
               oder POPUP_INVCYCLE gesetzt, so wird gegebenenfalls auto-
               matisch die Richtung invertiert. Weitere Mîglichkeiten s.
               Popup-Parameter 'mode' */
            int mode,cycle_mode;

            /* Popup-Zentrierung und -koordinaten (s. Popup-Parameter
               'center', 'x' und 'y'). Die Koordinaten kînnen - falls diese
               benîtigt werden und nicht konstant sind - z.B. nach einer
               OBJC_SIZED-Nachricht angepaût werden. */
            int center,x,y;

            /* (vordefinierte) Werte fÅr Index des ausgewÑhlten Eintrags und
               aktuellen Eintrag (wird automatisch nach jedem Popup-Aufruf
               auf aktuelle Werte gesetzt, s. Popup-Paramter 'index' und
               'select') */
            int index,current;

            /* Popup ist geîffnet (opened!=0) */
            int opened;
        } XPOPUP;

        int Popup(POPUP *popup,int mode,int center,int x,int y,
                  int *index,int select)
            -> Popup 'popup' îffnen, bearbeiten und wieder schlieûen
            -> mode: Popup-Modus (Bitmap der folgenden Konstanten)

                /* Popup-Button wurde angewÑhlt (Popup wird geîffnet, bear-
                   beitet und wieder geschlossen) */
                #define POPUP_BTN       0

                /* Cycle-Button wurde angewÑhlt (nÑchster Eintrag wird
                   ausgewÑhlt, wobei dies nur mîglich ist, wenn entweder
                   der aktuelle Eintrag Åbergeben wird (Parameter 'select')
                   oder vor dem aktuellen Eintrag ein HÑkchen ist und
                   POPUP_CHECK gesetzt ist */
                #define POPUP_CYCLE     1

                /* HÑkchen vor aktuellem Eintrag (andernfalls kînnen be-
                   liebig viele EintrÑge ein HÑkchen besitzen, wobei diese
                   von der Anwendung gesetzt/gelîscht werden mÅssen) */
                #define POPUP_CHECK     2

                /* Cycle-Button wurde "invers" angewÑhlt (vorheriger
                   Eintrag wird ausgewÑhlt, wobei dies nur mîglich ist,
                   wenn entweder der aktuelle Eintrag Åbergeben wird
                   (Parameter 'select') oder vor dem aktuellen Eintrag ein
                   HÑkchen ist und POPUP_CHECK gesetzt ist (hat Vorrang
                   vor POPUP_CYCLE) */
                #define POPUP_INVCYCLE  4

                /* Popup-MenÅ ist ein Drop-Down-MenÅ (u.a. wird bei voll-
                   automatischen Popups (s. XPOPUP-Struktur) eine erweiterte
                    MN_SELECTED-Nachricht an den Event-Handler verschickt) */
                #define POPUP_MENU      8

                /* Das Popup-MenÅ besitzt untergeordnete SubmenÅs. Die Åber-
                   geordneten Objekte, welche SubmenÅs îffnen, kînnen dann,
                   sofern die Objekt-Flags EXIT oder TOUCHEXIT gesetzt sind,
                   per Cursor-Right ausgewÑhlt und somit die SubmenÅs ge-
                   îffnet werden.
                   Wichtig:
                   Besitzt ein Popup SubmenÅs, so sollte das Popup keinen
                   Cycle-Button besitzen oder der Cycle-Modus manuell im-
                   plementiert werden! */
                #define POPUP_PARENT    16

                /* Das Popup-MenÅ ist ein SubmenÅ eines anderen Popups
                   (SubmenÅs kînnen u.a. per Cursor-Left verlassen werden) */
                #define POPUP_SUB       32

                /* Popup-MenÅ mit 3D-Rand zeichnen (ansonsten schattierter
                   Rand; hat Vorrang vor POPUP_NO_SHADOW)
                #define POPUP_3D        64

                /* Popup-MenÅ ohne Schatten zeichnen (z.B. fÅr FenstermenÅs) */
                #define POPUP_NO_SHADOW 128

                #define POPUP_BTN_CHK      (POPUP_BTN|POPUP_CHECK)
                #define POPUP_CYCLE_CHK    (POPUP_CYCLE|POPUP_CHECK)
                #define POPUP_INVCYCLE_CHK (POPUP_INVCYCLE|POPUP_CHECK)

            -> center: Position des Popups (werden fÅr die Koordianten
                       x oder y negative Werte angegeben, so werden statt-
                       dessen die Koordinaten des Popup-Buttons genommen)

                #define CENTER    1 /* in Bildschirm zentrieren */
                #define MOUSEPOS  2 /* um Mauszeiger zentrieren */
                #define XPOS      3 /* X-Koordinate x, vertikal
                                       um Mauszeiger zentrieren */
                #define YPOS      4 /* Horizontal um Mauszeiger zentrieren,
                                       Y-Koordinate y */
                #define XYPOS     5 /* Koordinaten (x,y) */
                #define OBJPOS    6 /* um aktuellen Eintrag zentrieren oder
                                       wie XYPOS */
                #define MENUPOS   7 /* Button-Objekt wird als MenÅ-Titel
                                       betrachtet und Popup wird als MenÅ
                                       dazu positioniert */

            -> select: aktueller Eintrag oder negativer Wert (in diesem
                       Fall wird der aktuelle Eintrag automatisch ermittelt,
                       sofern der POPUP_CHECK-Modus gesetzt ist)

            -> zurÅckgegeben wird die Objektnummer des selektierten
               Eintrags (oder 0) sowie in '*index' (sofern index!=NULL) der
               Index des selektierten Eintrags. Ist Bit 15 (0x8000,
               DOUBLE_CLICK) und/oder Bit 14 (0x4000, RIGHT_CLICK) des
               RÅckgabewertes gesetzt, so wurde das Objekt per Doppel- bzw.
               Rechtsklick bzw. bei gedrÅckter Shift- bzw. Control-Taste
               ausgewÑhlt.

    18. XAcc-2- und AV-Protokoll-Funktionen
        -----------------------------------

        Allgemein:
        ----------

        Die Library verwaltet intern alle An- und Abmeldungen der Proto-
        kolle XAcc2 und AV selbstÑndig, wobei alle in der Struktur 'XAcc'
        gespeicherten Informationen in lokale Puffer kopiert wurden (auf-
        grund der fehlerhaften Protokoll-Implementationen diverser
        Programme, die sich nicht korrekt abmelden).

        Ebenso werden die Nachrichten AV_SENDKEY sowie ACC_KEY automatisch
        in Keyboard-Events umgewandelt bzw. nicht ausgewertete Keyboard-
        Events werden als AV_SENDKEY bzw. ACC_KEY an den AV-Server oder die
        Hauptapplikation geschickt.

        Die Nachrichten VA_START, VA_DRAGACCWIND und AV_OPENWIND sowie
        AV_XWIND werden automatisch ausgewertet und in eine OBJC_DRAGGED-
        Nachricht umgewandelt (VA_START wird mit AV_STARTED, AV_OPENWIND
        mit VA_WINDOPEN und AV_XWIND mit VA_XOPEN beantwortet), sofern die
        Library mit Drag&Drop Åbersetzt wurde.

        Weiterhin werden nicht unterstÅtzte XAcc2-Nachrichten mit einer
        ACC_ACK-FALSE-Nachricht beantwortet und per ACC_TEXT empfangene
        Texte werden im das aktuelle Eingabefeld im obersten Dialog einge-
        fÅgt. Ist das oberste Fenster kein Dialog, so wird die Nachricht
        an die Applikation weitergeleitet, sofern diese Nachricht unter-
        stÅtzt wird.

        Alle Fensterdialoge sowie Fenster, die mit den Funktionen
        open_window() und close_window() geîffnet bzw. geschlossen werden,
        werden bei einem eventuell vorhandenen AV-Server an- bzw. abge-
        meldet. Auûerdem wird das neue Quoting von Dateinamen im AV-
        Protokoll unterstÅtzt (s.a. Drag & Drop-Protokoll)

        #define XACC    1   /* XAcc-Protokoll */
        #define AV      2   /* AV-Protokoll */

        XAcc-Struktur:
        --------------
        typedef struct
        {
            /* unterstÅtzte Protokolle (Bit 0: XAcc, Bit 1: AV) */
            int     flag;            /* XACC/AV */

            /* Applikations-Identifikation */
            int     id;              /* XAcc/AV-Protokoll */

            /* Bitmap der unterstÅtzten AV/VA-Nachrichten (Format
               s. Funktion init_gem())
            int     av_msgs,va_msgs; /* nur AV-Protokoll */

            /* Highbyte: Programmversionsnummer
               Lowbyte:  unterstÅtzte Nachrichtengruppen */
            int     version;         /* nur XAcc-Protokoll */

            /* ID des MenÅeintrags im Accessory-MenÅ */
            int     menu_id;         /* nur XAcc-Protokoll */

            /* AV-Programmname (8 Zeichen) fÅr appl_find */
            char    name[];          /* nur AV-Protokoll */

            /* (erweiterter) XAcc2-Programmname oder NULL */
            char    *xname;          /* nur XAcc-Protokoll */

            /* Zeiger auf 'XDSC'-Informationen oder NULL */
            char    *xdsc;           /* nur XAcc-Protokoll */
        } XAcc;

        void XAccBroadCast(int msg[8])
            -> Nachrichtenpuffer 'msg' an alle erreichbaren Applikationen
               verschicken (Nachricht wird nicht an eigene Applikation
               oder System-Prozesse geschickt). Unter SingleTOS (<5.00)
               kann die Nachricht prinzipbedingt nur an die Hauptappli-
               kation sowie an Applikationen, die sich mit dem XAcc-Proto-
               koll angemeldet haben, geschickt werden.

        int XAccSendAck(int sendto, int answer)
            -> ACC_ACK-RÅckmeldung 'answer' an Applikation 'sendto' senden
               (OK: answer!=0, Fehler: answer==0)
            -> RÅckgabewert:
                TRUE:  Okay
                FALSE: Fehler

        int XAccSendKey(int sendto, int scan, int state)
            -> Tasten-Druck (Scancode 'scan', Status der Umschalttasten
               'state') an Applikation 'sendto' senden
            -> RÅckgabewert:
                TRUE:   Okay
                FALSE:  Fehler
                FAIL:   Timeout (keine BestÑtigung des EmpfÑngers)

        Hinweis:
        --------
        Bei den Funktionen XAccSendText/Img/Meta und VaStart wird wÑhrend
        der Wartezeit bis zur BestÑtigung des EmpfÑngers der Mauszeiger als
        "Biene" dargestellt.

        int XAccSendText(int sendto, char *txt)
            -> Zeichenkette 'txt' an Applikation 'sendto' senden
            -> RÅckgabewert:
                TRUE:   Okay
                FALSE:  Fehler
                FAIL:   Timeout (keine BestÑtigung des EmpfÑngers)

        int XAccSendMeta(int sendto, int last, char *data, long len)
            -> Metafile-Block 'data' der LÑnge 'len' an Applikation 'sendto'
               senden (last!=0 -> letzter Datenblock)
            -> RÅckgabewert:
                TRUE:   Okay
                FALSE:  Fehler
                FAIL:   Timeout (keine BestÑtigung des EmpfÑngers)

        int XAccSendImg(int sendto, int last, char *data, long len)
            -> GEM-Image-Block 'data' der LÑnge 'len' an Applikation 'sendto'
               senden (last!=0 -> letzter Datenblock)
            -> RÅckgabewert:
                TRUE:   Okay
                FALSE:  Fehler
                FAIL:   Timeout (keine BestÑtigung des EmpfÑngers)

        int AvSendMsg(int sendto,int msg_id,int msg[8])
            -> (AV-) Nachricht 'msg_id' an Applikation 'sendto' senden
               (Message-Puffer msg[3]-msg[7] enthÑlt gegebenenfalls weitere
               Daten, falls msg!=NULL), wobei Nachrichten an die eigene
               Applikation direkt in den internen Nachrichten-Puffer ge-
               schrieben werden
            -> RÅckgabewert:
                TRUE:  Okay
                FALSE: Fehler

        int VaStart(int sendto,char *args)
            -> Argumente/Kommandozeile 'args' (Aufbau s. Funktion
               ParseArgs) an Applikation 'sendto' senden
            -> RÅckgabewert:
                TRUE:  Okay
                FALSE: Fehler
                FAIL:  Timeout (keine BestÑtigung des EmpfÑngers)

        Hinweis:
        --------
        Die XAcc/AV-UnterstÅtzung der Applikation wird ebenfalls in die
        interne XAcc/AV-Liste integriert und kann somit mit Hilfe der
        folgenden 3 Funktionen find_id, find_xacc_xdsc und find_app eben-
        falls ermittelt werden!

        XAcc *find_xacc_xdsc(int app_id,char *xdsc)
            -> erweiterten XAcc-Programmnamen der Applikation 'app_id' nach
               Zeichenkette 'xdsc' durchsuchen (app<0 -> alle XAcc-Appli-
               kationen durchsuchen)
            -> RÅckgabewert enthÑlt Zeiger auf XAcc-Struktur der
               Applikation, deren XAcc-Programmname die Zeichenkette ent-
               hÑlt, oder NULL, wenn die Zeichenkette nicht gefunden wurde

        XAcc *find_id(int app_id)
            -> XAcc-Struktur der Applikation 'app_id' ermitteln oder NULL,
               wenn es sich um keine XAcc-Applikation handelt

        XAcc *find_app(int first)
            -> XAcc-Struktur der ersten (first!=0) oder der nÑchsten
               (first==0) angemeldeten Applikation ermitteln (RÅckgabewert
               gleich NULL, wenn keine weitere Applikation gefunden wurde)

        int AppLoaded(char *name)
            -> Ermittelt die Applikations-ID der Anwendung mit dem
               Dateinamen 'name', welcher auch Pfad- und Laufwerksangaben
               enthalten darf.
            -> RÅckgabewert: Applikations-ID oder negativer Wert

     19. Drag & Drop-Funktionen
         ----------------------

        DRAG_DROP-Struktur:
        -------------------

        typedef struct
        {
            /* Art der ParameterÅbergabe */
            int dd_type;

                #define AV_DRAG     0 /* AV/Gemini-Drag&Drop */
                #define AV_START    1 /* VA_START-Nachricht */
                #define AV_OPEN     2 /* AV_OPENWIND/AV_XWIND-Nachricht */
                #define MINT_DRAG   3 /* MTOS-Drag&Drop */

            /* Applikations-ID des Senders */
            int dd_originator;

            /* Mausposition (oder negative Werte, falls nicht vom
               Benutzer verursacht bzw. Hintergrundfenster betroffen) */
            int dd_mx,dd_my;

            /* Status der Umschalttasten */
            int dd_kstate;

            /* Zeiger auf (Datei-/Pfad-) Namen der Åbergebenen Daten
               oder NULL */
            char *dd_name;

            /* Zeiger auf Argumente (z.B. Kommandozeile) oder NULL. Die
               einzelnen Argumente/Dateinamen sind durch Leerzeichen ge-
               trennt, wobei Argumente, die Leerzeichen enthalten, inner-
               halb von Hochkommatas (oder AnfÅhrungszeichen) stehen (z.B.
               'meine Datei'). Doppelte Hochkommatas stehen dann fÅr ein
               einzelnes Hochkommata (z.B. 'Christian''s Datei').
               Ist weder 'dd_mem' noch 'dd_args' gesetzt, so wurden keine
               Daten/Parameter Åbergeben. Darauf kann man z.B. entweder mit
               der normalen AC_OPEN-Routine (bei Accessories) oder mit
               dem ôffnen des Fileselectors (bei Programmen) reagieren. */
            char *dd_args;

            /* Zeiger auf Åbergebene Daten oder NULL (dieser Speicher-
               bereich darf NICHT zur weiteren Verwendung benutzt wer-
               den, d.h. wird wieder freigegeben!) */
            char *dd_mem;

            /* LÑnge der in 'dd_mem' Åbergebenen Daten oder Null */
            long dd_size;

            /* Extension der in 'dd_mem' Åbergebenen Daten oder Leer-
               string ""
            char dd_ext[4];

            /* Zeiger auf WIN-Struktur des Fensters, auf das die Daten
               gezogen wurden, oder NULL, falls Hintergrund bzw. nicht
               vom Benutzer verursacht.
               Achtung:
               Hierbei kann es sich auch um das Fenster eines Dialogs han-
               deln, also u.a. auch Alert-Boxen, Font-Selectorbox oder
               ASCII-Eingabebox. */
            WIN *dd_win;
        } DRAG_DROP;

        WICHTIG:
        --------
        Per Drag&Drop kînnen nur dann Daten empfangen werden, wenn mit
        Hilfe der Funktion Event_Handler() ein Ereignis-Handler angemeldet
        wurde, der die Drag&Drop-Nachricht 'OBJC_DRAGGED' auswertet.

        void SetDragDrop(int any_extension,char *exts)
             -> gewÅnschte/bevorzugte Dateierweiterungen fÅr das Drag&Drop-
                Protokoll festlegen. Dabei zeigt 'exts' auf eine Zeichen-
                kette mit DD_EXTSIZE Zeichen (mit Nullbytes auffÅllen), die
                die gewÅnschten Erweiterungen (z.B. ".TXT.ASC.ARGS") ent-
                hÑlt, wobei die Erweiterungen jeweils 4 Zeichen umfassen
                mÅssen und 'ARGS' fÅr Argumente steht. Wird fÅr den
                Parameter 'any_extension' TRUE Åbergeben, so wird jede
                Erweiterung akzeptiert. (voreingestellt ist, daû nur Argu-
                mente entgegengenommen werden.)

        int SendDragDrop(int msx,int msy,int kstate,char *name,
                         char *ext,long size,char *data)
             -> Daten per Drag&Drop-Protokoll an die Applikation senden,
                der das Fenster unter dem Mauszeiger gehîrt (wÑhrend der
                öbertragung wird der Mauszeiger als "Biene" dargestellt)
             -> Parameter:
                msx,msy:  Mauskoordinaten
                kstate:   Status der Umschalttasten
                name:     Zeiger auf (Datei-) Namen der Daten oder NULL
                ext[4]:   Zeiger auf Zeichenkette, die die Erweiterung
                          bzw. den Typ der Daten enthÑlt
                size:     LÑnge der Daten
                data:     Adresse der Daten
             -> RÅckgabewert:
                NO_RECEIVER: Fenster oder EmpfÑnger nicht gefunden bzw.
                             applikationseigenes Fenster
                NO_DD:       Drag&Drop-Pipe konnte nicht angelegt werden
                             (Betriebssystem unterstÅtzt kein Drag&Drop!)
                DD_NAK:      EmpfÑnger unterstÅtzt kein Drag&Drop
                DD_EXT:      EmpfÑnger kann Daten nicht empfangen (z.B.
                             unbekanntes Format)
                DD_LEN:      Nicht alle Daten konnten Åbermittelt werden
                             oder zuwenig Speicher
                DD_OK:       Alles in Ordnung

        char *ParseArgs(char *args)
            -> (Drag&Drop-) Kommandozeile auswerten (u.a. in einzelne
               Wîrter trennen und Hochkommata/AnfÅhrungszeichen entfernen,
               s.a. Element 'dd_args' der DRAG_DROP-Struktur).
               Beim ersten Aufruf zeigt der Parameter 'args' auf die Origi-
               nal-Kommandozeile, welche in einen lokalen Puffer kopiert
               wird und somit unverÑndert bleibt, und bei allen folgenden
               Aufrufen wird ein NULL-Pointer Åbergeben.
            -> RÅckgabewert:
               Pointer auf ein Element der Kommandozeile oder NULL, falls
               kein weiteres Element mehr vorhanden ist. Dabei darf der
               Pointer nur bis zum nÑchsten Aufruf dieser Funktion ver-
               wendet werden.

    20. Auskunftsfunktionen
        -------------------

        boolean driver_avaiable(int dev)
            -> Testet, ob der GDOS-Treiber mit der GerÑtenummer 'dev'
               existiert. Mîgliche GerÑtenummern:
                 Screen     1..10
                 Plotter    11..20
                 Printer    21..30
                 Metafile   31..40
                 Camera     41..50
                 Tablett    51..60
                 Memory     61..70
                 Sonstige   71..99
            -> RÅckgabewert:
                 TRUE:  Treiber existiert
                 FALSE: GDOS oder Treiber nicht vorhanden

        int mm2dpi(int size)
            -> DPI (dots per inch) eines AusgabegerÑts berechnen
            -> Parameter 'size': Grîûe eine Pixels in Micrometer
               (=1/1000 Milimeter, s. work_out[]-Array)

        int objc_sysvar(int ob_smode,int ob_swhich,int ob_sival1,
                        int ob_sival2,int *ob_soval1,int *ob_soval2)
            -> erweiterte Variante der AES-Funktion objc_sysvar(), welche
               die Existenz diese Funktion selbstÑndig ermittelt. Ist
               die Funktion nicht vorhanden, so werden die Ausgabevariablen
               '*ob_soval1' und '*ob_soval2' nicht verÑndert! FÅr die
               Ausgabevariablen kînnen auch NULL-Pointer Åbergeben werden,
               wenn der Wert nicht von Bedeutung ist.
            -> RÅckgabewerte und Parameter s. Beschreibung der ent-
               sprechenden AES-Funktion

        int appl_xgetinfo(int type,int *out1,int *out2,int *out3,int *out4);
            -> erweiterte appl_getinfo()-Routine, welche die Existenz von
               appl_getinfo() selbstÑndig ermittelt. Ist diese Funktion
               nicht vorhanden oder trat ein Fehler auf (RÅckgabewert
               FALSE), so werden die Ausgabevariablen auf Null gesetzt.
            -> RÅckgabewerte und Parameter wie bei appl_getinfo()

        int appl_getfontinfo(int font_type,int *height,int *id,int *type)
            -> Informationen Åber groûen (font_type=0) oder kleinen
               System-Font (font_type=1) ermitteln
            -> RÅckgabewerte:
                height: Font-Hîhe in Pixel
                id:     Font-ID
                type:   0 - System-Font
                        1 - FSM-Font

        int wind_xget(int w_handle, int w_field, int *w1, int *w2,
                      int *w3,int *w4);
            -> korrigierte wind_get()-Funktion fÅr erweiterte Aufrufe unter
               Winx sowie MTOS und zukÅnftigen Erweiterungen (die in der
               Pure C-GEM-Library bis V1.1 enthaltene, optimierte Routine
               funktioniert nicht mit neueren Aufrufen)

        int get_dialog_info(int *fly_dials,int *win_dials,int *wins,
                            DIAINFO **top);
            -> Informationen Åber geîffnete Dialoge und Fenster ermitteln
            -> RÅckgabewert: TRUE:  Ausgabe in beliebiges Fenster mîglich
                             FALSE: Ausgabe nur in obersten Dialog 'top'
                             FAIL:  Keine Ausgabe mîglich (z.B. Popup ge-
                                    îffnet, Echtzeit-Funktion (graf_xxx)
                                    aufgerufen oder Ausgabe per beg_ctrl()
                                    gesperrt)
               *fly_dials: Anzahl der geîffneten (fliegenden) Dialoge
                           (sofern fly_dials!=NULL)
               *win_dials: Anzahl der geîffneten Fenster-Dialoge (sofern
                           win_dials!=NULL)
               *wins:      Anzahl der geîffneten Fenster (sofern wins!=NULL)
                           inklusive der Fensterdialoge
               *top:       Zeiger auf obersten Dialog, falls RÅckgabewert
                           gleich FALSE (sofern top!=NULL)

    21. Datei-/Pfadfunktionen
        ---------------------

        void drive_changed(int drive)
            -> Inhalt des Laufwerks 'drive' (0=A,1=B,2=C,...,-1=alle Lauf-
               werke) wurde verÑndert (SH_WDRAW-Nachricht wird (per
               XAccBroadCast) an alle Applikationen gesendet)

        char *GetFilename(char *path)
            -> Zeiger auf Dateiname des Pfades 'path' ermitteln. EnthÑlt
               der Pfad keinen Dateinamen, so zeigt der RÅckgabewert auf
               das Ende (Nullbyte) des Pfades

        char *GetExtension(char *path)
            -> Zeiger auf Erweiterungs des Dateinamens des Pfades 'path'
               ermitteln. EnthÑlt der Pfad keinen Dateinamen oder keine
               Erweiterung, so zeigt der RÅckgabewert auf das Ende
               (Nullbyte) des Pfades. Diese Funktion funktioniert auch bei
               erweiterten Dateinamen!

        char *GetPath(char *path)
            -> Dateiname des Pfades 'path' wird entfernt und ein Zeiger
               auf das Ende des Pfades (Nullbyte) zurÅckgegeben

        int GetDrive(char *path)
            -> Laufwerk des Pfades 'path' ermitteln
            -> RÅckgabewert: 0=A,1=B,2=C,...

        void MakeFullpath(char *dest,char *path,char *file)
            -> kompletten Pfadnamen aus Pfad 'path' (sofern path!=NULL,
               wobei der Pfad keinen abschlieûenden Backslash enthalten
               muû) und Datei 'file' erstellen und im String 'dest' zurÅck-
               geben. Wird fÅr den Pfad 'path' NULL Åbergeben, so muû
               sich der Pfad bereits in 'dest' befinden!

        boolean SaveInfoFile(char *file,boolean auto_path,void *info,
                             int len,char *id,int version)
            -> Einstellungen des Programms sichern. Die Informationsdatei
               verfÅgt dabei im automatisch erzeugten Header sowohl Åber
               eine Identifikation als auch eine PrÅfsumme. Ebenso sind mit
               dieser Funktion (zusammen mit LoadInfoFile) auf- und abwÑrts-
               kompatible Informationsdateien mîglich.
            -> Parameter:
               file:      Zeiger auf Dateinamen (evtl. inklusive Pfad)
               auto_path: Pfad der Informationsdatei automatisch ermitteln
                          (in AbhÑngigkeit davon, ob die Anwendung als
                          Accessory oder als Programm gestartet wurde)
               info:      Zeiger auf Speicherbereich mit den zu speichern-
                          den Einstellungen
               len:       LÑnge des zu speichernden Bereichs
               id:        Zeiger auf Identifikationsstring, der vor den
                          eigentlichen Einstellungen gespeichert wird
               version:   Versionsnummer der Informationsdatei
            -> RÅckgabewert:
               TRUE:  Einstellungen wurden gespeichert
               FALSE: Datei konnte nicht gespeichert werden

        int LoadInfoFile(char *file,boolean auto_path,void *info,int len,
                         int min_len,char *id,int min_version)
            -> Einstellungen des Programms laden. Der Speicherbereich
               mit den Einstellungen wird dabei nur verÑndert, wenn Daten
               erfolgreich geladen werden konnten und der Header allen
               Anforderungen entspricht (korrekte PrÅfsumme, Identifikation,
               Versionsnummer, LÑnge der Einstellungen).
            -> Parameter:
               file:        Zeiger auf Dateinamen (evtl. inklusive Pfad)
               auto_path:   Pfad der Informationsdatei automatisch ermitteln
                            (in AbhÑngigkeit davon, ob die Anwendung als
                            Accessory oder als Programm gestartet wurde)
               info:        Zeiger auf Speicherbereich mit den zu ladenden
                            den Einstellungen
               len:         LÑnge des zu ladenden Bereichs
               min_len:     Minimale LÑnge der zu ladenden Dateien
               id:          Zeiger auf Identifikationsstring
               min_version: Minimale Versionsnummer der Einstellungen, die
                            geladen werden kînnen
            -> RÅckgabewert:
               >0:    Anzahl der geladenen Bytes
               FALSE: Fehlerhafte Informationsdatei
               FAIL:  Datei konnte nicht geladen werden/zu wenig Speicher

        int FileSelect(char *title,char *path,char *fname,char *sel,
                       int no_insel,int out,char *outptr[])
            -> Dateiselector aufrufen, wobei diese Funktion automatisch
               erkennt, ob ein erweiterter Fileselector vorliegt und/oder
               ob eine Titelzeile vom Betriebssystem unterstÅtzt wird. Sind
               systemmodale (fliegende) Dialoge geîffnet oder ist die
               Ausgabe gesperrt, so kann evtl. der Dateiselector aufgrund
               des Speicherbedarfs fÅr die Hintergrundrestaurierung nicht
               aufgerufen werden. In diesem Fall sollten die Dialoge vor dem
               Aufruf geschlossen und anschlieûend wieder geîffnet werden
               sowie die Ausgabe freigegeben werden (s. end_ctrl())
            -> Parameter:
               title:    Titel des Fileselectors
               path:     Pfad (sowohl Ein- als auch Ausgabeparameter)
               fname:    vorgegebene Datei (Eingabe) bzw. ausgewÑhlte Datei
                         (Ausgabe)
               sel:      Dateimaske oder NULL (in diesem Fall wird "*.*"
                         genommen) (die Dateimaske wird automatisch an
                         die Mîglichkeiten des Dateisystems (Groû-/Klein-
                         schreibung) angepaût)
               no_insel: keine vorgegebene Datei (no_insel!=0)
               out:      maximale Anzahl an Dateien, die ausgewÑhlt werden
                         kînnen (nur gÅltig, wenn Parameter outptr ungleich
                         NULL ist und ein erweiterter Fileselector vor-
                         handen ist)
               outptr:   Adresse eines Arrays mit Zeigern auf Strings fÅr
                         die auszuwÑhlenden Dateinamen (oder NULL, falls
                         keine Mehrfachauswahl gewÅnscht wird). Der erste
                         Dateiname in diesem Array entspricht dabei dem
                         RÅckgabewert von 'fname'. Beachtet werden muû,
                         daû fÅr jeden Dateinamen mindestens 34 Bytes re-
                         serviert werden sollten (wegen erweiterter Datei-
                         systeme unter MiNT/MagiC)
            -> RÅckgabewert:
                         FAIL:  Fileselector konnte nicht aufgerufen werden
                                (Speichermangel oder z.B. Popup geîffnet)
                         FALSE: Abbruch (keine Datei ausgewÑhlt)
                         >0:    Anzahl der ausgewÑhlten Dateien

    22. Font-Funktionen
        ---------------

        FONTINFO-Struktur:
        ------------------

        typedef struct
        {
            /* Null-terminierter Name des Zeichensatzes (max. 32 Zeichen) */
            char name[];

            /* Zeichensatz-ID (RÅckgabewert von vqt_name()) und -index fÅr
               die Funktion vqt_name()) */
            int id,index;

            /* Bitmap des Zeichensatztyps:
               FNT_PROP:     proportionaler Zeichensatz
               FNT_ASCII:    Zeichensatz enthÑlt nicht alle Zeichen
                             (ASCII 0-255)
               FNT_SYSTEM:   System-Zeichensatz
               FNT_VECTOR:   Vektor-Zeichensatz
               FNT_TRUETYPE: TrueType-Zeichensatz
               FNT_SPEEDO:   Bitstream-Zeichensatz
               FNT_TYPE1:    Type1-Zeichensatz
               FNT_CFN:      Calamus-Zeichensatz */
            int type;

            /* minimale und maximale Zeichensatzhîhe in Punkt */
            int min_size,max_size

            /* erstes und letztes Zeichen im Zeichensatz */
            int min_ascii,max_ascii;

            /* alle weiteren Variablen dieser Struktur sind fÅr interne
               Zwecke reserviert */
        } FONTINFO;

        FONTINFO *FontInfo(int id)
            -> Zeiger auf FONTINFO-Struktur des Zeichensatzes mit der ID
               'id' ermitteln. Wird eine fehlerhafte Zeichensatz-ID Åber-
               geben, so wird die FONTINFO-Struktur des Zeichensatzes
               ermittelt, der bei dieser ID gesetzt wird, d.h. der RÅckgabe-
               wert ist immer gÅltig!

        FONTINFO *FastFontInfo(int id)
            -> entspricht der Funktion FontInfo() mit der EinschrÑnkung,
               daû nur die Variablen 'name', 'id' und 'idx' der FONTINFO-
               Struktur gesetzt sind. Dadurch ist diese Funktion teilweise
               erheblich schneller.

        int FontList((int type,int min_size,int max_size,int max_fonts,
                     FONTINFO *fonts[],
                     int (*font_test)(FONTINFO *info,int size))
            -> Liste von Fonts mit den gewÅnschten Attributen erstellen.
               Besitzt ein Font keine Grîûe im Bereich zwischen 'min_size'
               und 'max_size', so wird er nicht in die Liste aufgenommen!
            -> Parameter:
               type:       Bitmap der gewÅnschten Fonts:
                           FS_FNT_BITMAP: Bitmap-Fonts
                           FS_FNT_VECTOR: Vektor-Fonts
                             -> Ist weder FS_FNT_BITMAP noch FS_FNT_VECTOR
                                gesetzt, so entspricht dies der Kombination
                                aus beiden Konstanten
                           FS_FNT_MONO:   nicht-proportionale Fonts
                           FS_FNT_PROP:   proportionale Fonts
                             -> Ist weder FS_FNT_MONO noch FS_FNT_PROP
                                gesetzt, so entspricht dies der Kombination
                                aus beiden Konstanten
                           FS_FNT_ALL:    Alle Fonts
               min_size:   Minimale Grîûe in Punkt oder negativer Wert
               max_size:   Maximale Grîûe in Punkt oder negativer Wert
               max_fonts:  Maximale Anzahl an Fonts, die die Liste auf-
                           nehmen kann
               fonts:      Zeiger auf FONTINFO-Pointer-Array der Grîûe
                           'max_fonts', welches mit der unsortierten Liste
                           der Fonts gefÅllt wird
               font_test:  Optionale flexible Routine, welche bei jedem
                           Font aufgerufen wird
                           Parameter:
                           info: Zeiger auf FONTINFO-Struktur des Fonts
                           size: GewÅnschte Grîûe in Punkt (bei dieser
                                 Funktion wird immer ein negativer Wert
                                 Åbergeben). Sinn dieses Parameters ist,
                                 daû man die gleiche Routine fÅr FontSizes
                                 und FontList verwenden kann.
                           RÅckgabewert:
                           TRUE:  Font in Liste aufnehmen
                           FALSE: mit nÑchstem Font weitermachen
            -> RÅckgabewert:
               Anzahl der Fonts in der Liste

        int FontSizes(int font_id,int free_scale,int min_size,int max_size,
                      int max_cnt,int *sizes,
                      int (*font_test)(FONTINFO *info,int size))
            -> Liste von Grîûen (in Punkt) des Fonts mit der ID 'font_id'
               erstellen
            -> Parameter:
               font_id:    ID des gewÅnschten Fonts
               free_scale: Bei Vektorfonts dÅrfen auch Zwischengrîûen von
                           der Library in die Liste integriert werden
                           (free_scale!=0). Diese Grîûen mÅssen per
                            vst_arbpt oder eine der Library-Routinen
                            v_set_text/v_set_point gesetzt werden)
               min_size:   Minimale Grîûe in Punkt oder negativer Wert
               max_size:   Maximale Grîûe in Punkt oder negativer Wert
               max_cnt:    Maximale Anzahl an Grîûen, die die Liste auf-
                           nehmen kann
               sizes:      Zeiger auf Integerarray der Grîûe 'max_cnt',
                           welches mit der grîûensortierten Liste gefÅllt
                           wird
               font_test:  Optionale flexible Routine, welche bei jeder
                           Grîûe aufgerufen wird
                           Parameter:
                           info: Zeiger auf FONTINFO-Struktur des Fonts
                           size: GewÅnschte Grîûe in Punkt
                           RÅckgabewert:
                           TRUE:  Grîûe 'size' in Liste aufnehmen
                           FALSE: mit nÑchster Grîûe weitermachen
            -> RÅckgabewert:
               Anzahl der Grîûen in der Liste

        int FontChanged(int apID,int handle,int id,int size,int effect,
                         int color)
            -> Nachricht FONT_CHANGED (s. Font-Protokoll) an Applikation
               'apID' oder alle anderen Applikationen (apID<0) senden.
            -> Parameter: (negative Parameter bedeuten keine VerÑnderung)
               handle: Handle des Fensters, dessen Font geÑndert werden
                       soll, oder negativer Wert fÅr alle Fenster (wenn
                       die Nachricht an alle Applikationen gesendet wird,
                       dann hat dieser Parameter keine Bedeutung)
               id:     Font-ID
               size:   Font-Grîûe in Punkt
               effect: Effekte
               color:  Farbe
            -> RÅckgabewert:
               TRUE:  Nachricht konnte verschickt werden
               FALSE: Nachricht wurde nicht verschickt (z.B. weil Em-
                      pfÑnger nicht existiert)

        int CallFontSelector(int handle,int id,int size,int color,int effects)
            -> D&D-FontSelector (gegenbenenfalls mit aktuellen Attributen)
               aufrufen (FONT_SELECT-Nachricht (s. Font-Protokoll) wird
               verschickt)
            -> Parameter (bei allen Parametern auûer 'handle' bedeutet
               ein negativer Wert, daû dieses Attribut nicht benîtigt wird,
               nicht eingestellt werden soll oder noch nicht gesetzt ist)
               handle: Handle des Fensters, in dem die Font-Attribute ein-
                       gestellt werden sollen, (handle>0) oder alle Fenster
                       (handle<=0)
               id:     Font-ID
               size:   Font-Grîûe in Punkt
               effect: Effekte
               color:  Farbe
            -> RÅckgabewert:
               TRUE:  FontSelector wurde aufgerufen
               FALSE: Kein Fontselector vorhanden

        int FontAck(int font_selector,boolean ack)
            -> BestÑtigungsnachricht FONT_ACK (s. Font-Protokoll) an
               D&D-Fontselector mit der ID 'font_selector' schicken
            -> Parameter:
               ack: TRUE  -> FONT_SELECT-Nachricht wurde ausgewertet
                    FALSE -> FONT_SELECT-Nachricht wurde ignoriert
            -> RÅckgabewert:
               TRUE:  Nachricht wurde verschickt
               FALSE: Nachricht wurde nicht verschickt (z.B. existiert
                      Fontselector-ID nicht oder es handelt sich nicht
                      um einen Fontselector)

        FONTSEL-Struktur:
        -----------------

        typedef struct
        {
            /* Zeiger auf Fenstertitel (ohne Bedeutung bei Modus FSEL_DIAL)
               oder NULL (in diesem Fall wird der Titel automatisch auf
               'FontSelector' gesetzt) */
            char    *win_title;

            /* Zeiger auf Dialogtitel oder NULL (in diesem Fall wird der
               unterstrichene Titel versteckt) */
            char    *title;

            /* Zeiger auf Beispieltext oder NULL (in diesem Fall wird der
               vorgegebene Text benutzt) */
            char    *example;

            /* Zeiger auf TEDINFO-Struktur des Informationsbuttons oder
               NULL (der Text kann dabei maximal 8 (SMALL-Zeichensatz) bzw.
               6 (IBM-Zeichensatz) Zeichen lang sein!). Wird kein Zeiger
               definiert, dann wird der normale Informationsbutton ver-
               wendet. */
            TEDINFO *info;

            /* Objekttyp und -status des Informationsbuttons (nur von
               Bedeutung, wenn 'info' definiert ist) */
            int     info_type,info_state;

            /* Bitmap der Elemente des Fontselectors:
               FS_GADGETS_STANDARD: Keine zusÑtzlichen Elemente
               FS_GADGETS_EFFECT:   Texteffekte
               FS_GADGETS_COLOR:    Textfarbe
               FS_GADGETS_SKEW:     Neigungswinkel bei Vektorfonts
               FS_GADGETS_SPEEDO:   Zwischengrîûen bei Vektorfonts
               FS_GADGETS_INVERS:   inverser Texteffekt
               FS_GADGETS_ALL:      Alle Elemente */
            char    gadgets;

            /* GewÅnschter Typ der Fonts, die zur Auswahl stehen sollen
               (s. Parameter 'type' der Funktion FontList) */
            char    fsel_type;

            /* Minimale und maximale Grîûe (in Punkt) der Fonts
               (s. Parameter 'min_size' und 'max_size' der Funktion
                FontList) */
            int     min_pts_size,max_pts_size;

            /* Optionen fÅr den Drag & Drop-Modus */
            struct
            {
                /* nur applikationsinternes Drag & Drop, d.h. die
                   FONT_CHANGED-Nachricht wird nicht an andere Anwendungen
                   geschickt */
                unsigned app_only : 1;

                /* 'All'- und '<Caller>'- (<Caller> steht fÅr den Aufrufer)
                   Button sichtbar */
                unsigned buttons  : 1;
            } drag;

            /* Allgemeine Optionen */
            struct
            {
                /* reserviert (0) */
                unsigned         : 7;

                /* automatischer Redraw des Beispiels nach einer
                   VerÑnderung der Attribute (diese Option kann auch vom
                   Benutzer eingestellt werden) */
                unsigned redraw  : 1;

                /* Zentrierung des Fontselectors beim ôffnen (s.
                   Parameter 'center' der Funktion open_dialog) */
                signed center    : 3;

                /* Sich vergrîûernde/verkleinernde Boxen beim ôffnen bzw.
                   Schlieûen des FontSelectors zeichnen */
                unsigned boxes   : 1;

                /* Preview der Fonts in den Slidern (diese Option kann auch
                   vom Benutzer eingestellt werden) */
                unsigned preview : 1;

                /* Alphabetisch sortierte Font- und Schnitt-Liste (diese
                   Option kann auch vom Benutzer eingestellt werden) */
                unsigned sort    : 1;

                /* GewÅnschte Aktion nach einer Drag & Drop-Aktion:
                   FS_ACT_NONE: Keine Aktion
                   FS_ACT_ICON: Fontselector ikonifizieren
                   FS_ACT_BACK: Fontselector in Hintergrund legen
                   FS_ACT_CLOSE: Fontselector schlieûen
                   Diese Option kann auch vom Benutzer eingestellt werden. */
                unsigned action  : 2;
            } options;

            /* Zeiger auf Routine zur Auswahl der Fonts oder NULL
               (s. entsprechende Parameter der Funktionen FontList und
                FontSizes) */
            int     (*font_test)(FONTINFO *info,int size);

            /* Zeiger auf Hilfe-Funktion, die beim Anklicken des Infor-
               mations-Buttons aufgerufen wird, oder NULL (in diesem Fall
               erscheint die normale Meldung des Fontselectors) */
            void cdecl (*help_func)(void);

            /* Ein- und Ausgabevariablen der Zeichensatzattribute:
               Font-ID, -grîûe (in Punkt), Effekte, Farbe und Neigung.
               Die Werte werden gegebenenfalls automatisch auf gÅltige
               Werte gesetzt. Es werden nur die Ausgabevariablen verÑndert,
               die eingestellt werden kînnen (s. 'gadgets') */
            int     id,size,effect,color,skew;

            /* Startposition (abhÑngig vom Zentrierungsmodus) bzw. Position
               des Fontselectors beim Schlieûen (Ein- u. Ausgabevariablen) */
            int     x,y;

            /* Zeiger auf FONTINFO-Struktur des ausgewÑhlten Fonts (nur
               gÅltig nach Ende der Fontselector-Funktion mit RÅckgabewert
               FS_OK oder nach einem Aufruf der Funktion UpdateFSel(TRUE,...) */
            FONTINFO *fnt;

            /* Voreingestellte Zielapplikation (oder negativer Wert, falls
               nicht vorhanden) fÅr den '<Caller>'-Button im Drag & Drop-
               Modus */
            int     app;

            /* GewÅnschtes Fenster der Zielapplikation im Drag & Drop-Modus
               oder negativer Wert fÅr alle Fenster dieser Applikation
               (Parameter hat nur Bedeutung, wenn 'app' gesetzt ist) */
            int win;
        } FONTSEL;

        int FontSelect((int mode,FONTSEL *fs)
            -> Fontselector îffnen oder geîffneten Fontselector neu setzen
            -> Parameter:
               mode: GewÅnschter Modus des Fontselectors:
                     FSEL_DIAL: fliegender Dialog
                     FSEL_WIN:  modaler Fensterdialog
                     FSEL_DRAG: Drag & Drop-Fontselector (ebenfalls
                                modaler Fensterdialog mit Schlieûbox)
               fsel: Zeiger auf FONTSEL-Struktur mit den Parametern sowie
                     Ein- und Ausgabevariablen des Fontselectors
            -> RÅckgabewert:
               FS_OK:        Font wurde ausgewÑhlt (Ok-Button, Fenster-
                             Schlieûbox oder Doppelklick auf gewÅnschten
                             Eintrag), d.h. die gewÅnschten RÅckgabe-
                             variablen sind gÅltig
               FS_CANCEL:    Kein Font ausgewÑhlt (Abbruch-Button), keine
                             VerÑnderung der RÅckgabevariablen
               FS_ABANDON:   Fontselector wurde geschlossen und kein Font
                             ausgewÑhlt (z.B. bei AC_CLOSE)
               FS_NO_WINDOW: Kein Fenster verfÅgbar
               FS_NO_FONTS:  Keine Fonts mit den gewÅnschten Attributen
                             vorhanden
               FS_RES_ERROR: Auflîsung zu gering
               FS_ERROR:     allgemeiner Fehler (z.B. Bildschirmausgabe
                             gesperrt)
               FS_ACTIVE:    Fontselector bereits aktiv, aber andere
                             FONTSEL-Struktur als Åbergebene
               FS_SET:       Fontselector bereits aktiv (Fontselector
                             wurde auf neue Einstellungen aus FONTSEL-
                             Struktur gesetzt)

        boolean UpdateFsel(boolean all,boolean example)
            -> FONTSEL-Struktur eines geîffneten Fontselectors aktualisieren
            -> Parameter:
               all:     Nur die Optionen (Struktur 'options') und die Posi-
                        tion (Variablen 'x' und 'y') des Dialoges
                        (all==FALSE) oder zusÑtzlich noch alle Fontattribute
                        (Variablen 'id', 'size', 'fnt' und gegebenenfalls
                        'skew', 'effect' und 'color'), die eingestellt wer-
                        den sollen, setzen (all==TRUE)
               example: Beispiel aktualisieren (example==TRUE)
            -> RÅckgabewert:
               TRUE:  FONTSEL-Struktur wurde aktualisiert
               FALSE: Kein Fontselector geîffnet

    23. Paula-Protokoll
        ---------------

        int PaulaStop(void)
            -> Musikwiedergabe von Paula (ab Version 2.4) stoppen
            -> RÅckgabewert:
               TRUE:  Paula hat die Funktion ausgefÅhrt
               FALSE: Paula nicht vorhanden oder
                      Funktion wurde nicht ausgefÅhrt
               FAIL:  Timeout (keine Antwort oder zu alte Paula-Version)

        int PaulaShutDown
            -> Musikwiedergabe von Paula (ab Version 2.4) stoppen,
               Speicher freigeben und Paula-Fenster schlieûen
            -> RÅckgabewert:
               TRUE:  Paula hat die Funktion ausgefÅhrt
               FALSE: Paula nicht vorhanden oder
                      Funktion wurde nicht ausgefÅhrt
               FAIL:  Timeout (keine Antwort oder zu alte Paula-Version)

        int PaulaStart(char *mod_files)
            -> Musikwiedergabe von Paula (auch bei Ñlteren Versionen)
               starten. öber den Parameter 'mod_files' kann gegebenenfalls
               eine Liste von MOD-Files (getrennt durch Leerzeichen oder
               Semikolon) Åbergeben werden, sofern mod_files!=NULL
            -> RÅckgabewert:
               TRUE:  Paula hat die Funktion ausgefÅhrt
               FALSE: Paula nicht vorhanden oder
                      Funktion wurde nicht ausgefÅhrt
               FAIL:  Timeout (keine Antwort)

    24. Timer-Funktionen
        ----------------

        MKSTATE-Struktur:
        -----------------

        typedef struct
        {
            /* X/Y-Koordinaten der Maus sowie Zustand der Mausknîpfe */
            int mx,my,mbut;
            /* Zustand der Umschalttasten */
            int kstate;
        } MKSTATE;

        long NewTimer(long timer,long para,
                      long (*fkt)(long para,long time,MKSTATE *mk))
            -> Nach dem Verstreichen der Zeit 'timer' (in Milisekunden)
               wird die Funktion 'fkt' mit dem beliebigen Parameter (para),
               der aktuellen Systemzeit seit dem Booten in Milisekunden
               (time) und einem Zeiger auf eine MKSTATE-Struktur (mk) aufge-
               rufen (die Anzahl der gleichzeitig verwendbaren Timer ist nur
               durch den verfÅgbaren Speicher und die Rechenleistung be-
               grenzt).
               Mîgliche RÅckgabewerte der Funktion 'fkt':
               CONT_TIMER: Timer mit bisheriger Periode fortsetzen
               STOP_TIMER: Timer abbrechen
               Pos. Wert:  Timer mit RÅckgabewert als neuer Periode fort-
                           setzen
            -> RÅckgabewert: Timer-ID oder Null im Fehlerfall

        int KillTimer(long id)
            -> Timer mit der ID 'id' wieder entfernen.
            -> RÅckgabewert: TRUE:  Timer wurde entfernt
                             FALSE: Timer existierte nicht (z.B. weil
                                    er bereits ausgelîst wurde)

    25. Maus/Tastatur-Funktionen
        ------------------------

        int mouse(int *x,int *y)
            -> Position und Zustand der Knîpfe der Maus ermitteln
            -> Ausgabewerte:
                   *x: X-Ordinate der Maus (falls x!=NULL)
                   *y: Y-Ordinate der Maus (falls y!=NULL)
            -> RÅckgabewert: Zustand der Maustasten

        void MouseOn(void);
        void MouseOff(void);
            -> Mauszeiger an/-ausschalten. Diese Funktionen merken sich
               intern, ob der Mauszeiger bereits an- oder ausgeschaltet
               ist.

        int MouseForm(int index,MFORM *user)
            -> FunktionalitÑt und Parameter entsprechen der AES-Funktion
               graf_mouse(), nur daû diese Funktion an die unterschiedliche
               Verwaltung des Mauszeigers in den diversen MultiTasking-
               Systemen angepaût ist.

        void MouseArrow(void);
        void MouseCursor(void);
        void MouseBee(void);
        void MouseHourGlass(void);
        void MousePointHand(void);
        void MouseFlatHand(void);
        void MouseThinCross(void);
        void MouseThickCross(void);
        void MouseOutlineCross(void);
            -> Mausform einstellen

        void NoClick(void)
            -> auf das Loslassen beider Maustaste warten (Event/Timer-
               Handling wird dadurch NICHT blockiert). Ist keine
               Maustaste gedrÅckt, so kehrt diese Funktion sofort zurÅck.

        int key(int scan,int ascii) (Makro-Funktion!)
            -> Aus Scan-Code 'scan' und ASCII-Code 'ascii' Tastencode
               (Aufbau wie bei graf_mkstate(); u.a. fÅr SLKEY/MENUITEM-
               Strukturen) berechnen

        int scan_2_ascii(int scan,int state);
            -> Groûbuchstabe eines Tastendrucks aus Scan-Code 'scan' und
               Status der Umschalttasten 'state' ermitteln

        void ClrKeybd(void)
            -> Tastatur-Puffer lîschen (wird intern auch bei vollauto-
               matischen Echtzeitschiebern sowie tastaturgesteurten
               Fensterschiebern/pfeilen aufgerufen)

    26. Verschiedene Funktionen
        -----------------------

        int int2str(char *str,int val,int size)
            -> vorzeichenbehafteten Integer-Wert 'val' in String 'str'
               konvertieren
            -> Parameter 'size':
               >0: LÑnge des Strings (Zahl wird rechtsbÅndig eingesetzt)
               0:  LÑnge des Strings wird an die Zahl angepaût
               <0: negative LÑnge des Strings, wobei kein abschlieûendes
                   Null-Byte geschrieben wird (dadurch kann man z.B. eine
                   Zahl innerhalb eines existierenden Textes einsetzen)
            -> RÅckgabewert: LÑnge des Strings

        char *strend(char *str)
            -> Liefert einen Zeiger auf das Null-Byte '\0' hinter dem String
               'str' zurÅck

        char *strlcpy(char *dest,char *source)
            -> Kopiert den String 'source' in den String 'dest'. ZurÅck-
               gegeben wird dabei im Gegensatz zu strcpy() nicht ein Zeiger
               auf den Anfang des Ziel-Strings, sondern auf das Null-Byte
               hinter dem kopierten String (strlcpy(dest,source) entspricht
               also strend(strcpy(dest,source)))

        char *strwild(char *string,char *wild)
            -> Testet, ob die Zeichenkette 'string' auf den Unix-Wildcard
               'wild' paût (v.a. fÅr Datei/Pfadnamen geeignet)
            -> Aufbau des Wildcardstrings:
               '*'         beliebige Zeichenkette (Allquantor)
               '?'         ein beliebiges Zeichen (Existenzquantor)
               '@'         Sonderzeichenquotierung/Interpunktions-Zeichen
               '^'         Ausschlieûender Wildcard (nur am Anfang des
                           Wildcards von Bedeutung!)
               '[a-f|h]'   Menge von Zeichen, wobei das Oder-Zeichen '|'
                           auch weggelassen werden kann. Ebenso kînnen meh-
                           rere Angaben in einer Menge gemacht werden, also
                           z.B. '[a-eo-sxyz]'. Sonderzeichenquotierung ist
                           innerhalb von Mengen ebenfalls mîglich, aber nur
                           fÅr die Zeichen '-', '|' und '^' von Bedeutung.
               '[^akn]'    Ausschlieûende Menge von Zeichen
            -> RÅckgabewert:
               Zeiger auf String, sofern dieser auf den Wildcard paût,
               oder ein NULL-Zeiger

        int min(int val1,int val2);
            -> Minimum der Werte 'val1' und 'val2' berechnen und zurÅck-
               geben

        int max(int val1,int val2);
            -> Maximum der Werte 'val1' und 'val2' berechnen und zurÅck-
               geben

        void Min(int *var,int val);
            -> Minimum von der Variablen '*var' und dem Wert 'val'
               berechnen und in der Variablen '*var' speichern

        void Max(int *var,int val);
            -> Maximum von der Variablen '*var' und dem Wert 'val'
               berechnen und in der Variablen '*var' speichern

        void mfdb(MFDB *mfdb,int *bitmap,int width,int height,
                  int standard,int planes)
            -> Memory form definition block 'mfdb' initialisieren
            -> bitmap:       Zeiger auf Start der Bitmap
               width,height: Breite/Hîhe der Bitmap in Pixeln
               standard:     Standardformat (1) oder gerÑteabhÑngiges
                             Format
               planes:       Anzahl der Farbebenen der Bitmap

        long mfdb_size(MFDB *mfdb);
            -> Speicherbedarf der Bitmap des Memory form definition
               block 'mfdb' berechnen

        char LowerChar(char ch)
            -> Zeichen 'ch' in Kleinbuchstaben umwandeln, wobei
               auch Umlaute beachtet werden

        char UpperChar(char ch)
            -> Zeichen 'ch' in Groûbuchstaben umwandeln, wobei
               auch Umlaute beachtet werden

        void *GetMsgBuffer(long size)
            -> globalen Speicher (u.a. fÅr XAcc-2/AV-Kommunikation) der
               Grîûe 'size' anfordern (kann durch die Funktion Mfree()
               wieder freigegeben werden)
            -> RÅckgabewert wie bei Malloc()

        int mm2dpi(int size)
            -> DPI (dots per inch) eines AusgabegerÑts berechnen
            -> Parameter 'size': Grîûe eine Pixels in Micrometer
               (=1/1000 Milimeter, s. work_out[]-Array)

    27. Definitionen hÑufig benîtigter (Protokoll-) Konstanten
        ------------------------------------------------------

        Konstanten der Library:
        -----------------------

        #define MAX_PATH    ??? /* maximale LÑnge eines Datei/Pfadnamens */
        #define MAX_EDIT    ??? /* maximale LÑnge eines Eingabefelds */
        #define MAX_WINDOWS ??? /* maximale Anzahl gleichzeitig geîffneter
                                   Applikations-Fenster */
        #define MAX_DIALS   ??? /* maximale Anzahl gleichzeitig geîffneter
                                   Dialoge */

        XAcc-2-Protokoll:
        -----------------
        (genaue Bedeutung s. XAcc-2-Dokumentation)

        #define ACC_ID      0x400
        #define ACC_OPEN    0x401
        #define ACC_CLOSE   0x402
        #define ACC_ACC     0x403
        #define ACC_EXIT    0x404

        #define ACC_ACK     0x500
        #define ACC_TEXT    0x501
        #define ACC_KEY     0x502
        #define ACC_META    0x503
        #define ACC_IMG     0x504

        AV-Protokoll:
        -------------
        (genaue Bedeutung s. AV-Dokumentation 'VA_PROTO.H')

        #define AV_PROTOKOLL        0x4700
        #define AV_GETSTATUS        0x4703
        #define AV_STATUS           0x4704
        #define AV_SENDKEY          0x4710
        #define AV_ASKFILEFONT      0x4712
        #define AV_ASKCONFONT       0x4714
        #define AV_ASKOBJECT        0x4716
        #define AV_OPENCONSOLE      0x4718
        #define AV_OPENWIND         0x4720
        #define AV_STARTPROG        0x4722
        #define AV_ACCWINDOPEN      0x4724
        #define AV_ACCWINDCLOSED    0x4726
        #define AV_COPY_DRAGGED     0x4728
        #define AV_PATH_UPDATE      0x4730
        #define AV_WHAT_IZIT        0x4732
        #define AV_DRAG_ON_WINDOW   0x4734
        #define AV_EXIT             0x4736
        #define AV_STARTED          0x4738
        #define AV_XWIND            0x4740

        #define VA_PROTOSTATUS      0x4701
        #define VA_SETSTATUS        0x4705
        #define VA_START            0x4711
        #define VA_FILEFONT         0x4713
        #define VA_CONFONT          0x4715
        #define VA_OBJECT           0x4717
        #define VA_CONSOLEOPEN      0x4719
        #define VA_WINDOPEN         0x4721
        #define VA_PROGSTART        0x4723
        #define VA_DRAGACCWIND      0x4725
        #define VA_COPY_COMPLETE    0x4729
        #define VA_THAT_IZIT        0x4733
        #define VA_DRAG_COMPLETE    0x4735
        #define VA_FONTCHANGED      0x4739
        #define VA_XOPEN            0x4741

        #define VA_OB_UNKNOWN       0
        #define VA_OB_TRASHCAN      1
        #define VA_OB_SHREDDER      2
        #define VA_OB_CLIPBOARD     3
        #define VA_OB_FILE          4
        #define VA_OB_FOLDER        5
        #define VA_OB_DRIVE         6
        #define VA_OB_WINDOW        7

        MTOS-Drag&Drop-Protokoll:
        -------------------------
        (genaue Bedeutung s. MTOS-Entwickler-Dokumentation)

        #define AP_DRAGDROP     63

        #define DD_OK           0
        #define DD_NAK          1
        #define DD_EXT          2
        #define DD_LEN          3
        #define DD_TRASH        4
        #define DD_PRINTER      5
        #define DD_CLIPBOARD    6

        #define DD_TIMEOUT      3000

        #define DD_NUMEXTS      8
        #define DD_EXTSIZE      32L
        #define DD_NAMEMAX      128

        #define DD_HDRMAX       (8+DD_NAMEMAX)

        MenÅ-Protokoll:
        ---------------

        #define WM_CLOSED       0x0016  ^U
        #define WM_FULLED       0x0017  ^#* ('*' auf Ziffernblock)
        #define WM_SAVE         0x1000  ^S
        #define WM_SAVEAS       0x1001  ^M
        #define WM_PRINT        0x1002  ^P
        #define WM_UNDO         0x1003  Undo
        #define WM_CUT          0x1004  ^X
        #define WM_COPY         0x1005  ^C
        #define WM_PASTE        0x1006  ^V
        #define WM_SELECTALL    0x1007  ^A
        #define WM_FIND         0x1008  ^F
        #define WM_REPLACE      0x1009  ^R
        #define WM_FINDNEXT     0x100a  ^G
        #define WM_HELP         0x100b  Help
        #define WM_DELETE       0x100c  Delete

        View-Protokoll:
        ---------------
        (genaue Bedeutung s. View-Dokumentation V1.04)

        #define VIEW_FILE       0x5600
        #define VIEW_FAILED     0x5601
        #define VIEW_OPEN       0x5602
        #define VIEW_CLOSED     0x5603
        #define VIEW_DATA       0x5604
        #define VIEW_GETMFDB    0x5610

        #define VIEWERR_ERROR   0
        #define VIEWERR_SIZE    1
        #define VIEWERR_COLOR   2
        #define VIEWERR_WID     3
        #define VIEWERR_MEM     4

        Paula-Protokoll:
        ----------------
        (genaue Beschreibung s. Dokumentation des MOD-Fileplayers Paula
         ab Version 2.4)

        #define MP_ACK          0x4800
        #define MP_NAK          0x4801
        #define MP_START        0x4802
        #define MP_STOP         0x4803
        #define MP_SHUTDOWN     0x4804

        Clipboard-Protokoll:
        --------------------
        (s.a. Beschreibung der Funktion scrp_changed())

        Aufbau der Nachricht:
            msg[0]        = SC_CHANGED (80)
            msg[1]        = apID
            msg[2]        = 0
            msg[3]        = Bitmap des Dateiformats
                            (Parameter 'format' von scrp_changed())
            msg[4],msg[5] = 4 Zeichen fÅr die "beste" der abgespeicherten
                            Dateien (z.B. ".RTF"), damit beim Lesen mîg-
                            lichst wenig Information verloren geht
                            (Parameter 'best_ext' von scrp_changed())
            msg[6],msg[7] = reserviert (auf Null setzen!)


        Font-Protokoll:
        ---------------

        Eine minimale UnterstÅtzung des Font-Protokolls besteht in der Aus-
        wertung der FONT_CHANGED-Nachricht. UnterstÅtzt eine Applikation das
        XAcc-2-Protokoll, so kann sie auch leicht die weiteren Nachrichten
        unterstÅtzen.

        FONT_CHANGED-Nachricht:
          -> Nachricht des Fontselectors an eine Applikation, daû der
             Zeichensatz bzw. die Zeichenattribute in einem oder mehreren
             Fenstern gewechselt werden sollen. Besitzt die Zielapplikation
             im erweiterten XAcc-Namen die Kennung 'XFontAck', so muû diese
             Nachricht mit der Nachricht FONT_ACK beantwortet werden.
          -> negative Werte in msg[4-7] stehen fÅr keine VerÑnderung

            msg[0]        = FONT_CHANGED (0x7a18)
            msg[1]        = apID
            msg[2]        = 0
            msg[3]        = Fenster-Handle oder negativer Wert, falls
                            Font in allen Fenstern gewechselt werden soll
            msg[4]        = Font-ID
            msg[5]        = Font-Grîûe in Punkt
            msg[6]        = Font-Farbe
            msg[7]        = Effekte:
                             Bit 0: Fett
                             Bit 1: Hell
                             Bit 2: Kursiv
                             Bit 3: Unterstrichen
                             Bit 4: Umrandet
                             Bit 5: Schattiert
                             Bit 6: Invers
                             (restliche Bits sind reserviert)

        FONT_SELECT-Nachricht:
          -> mit dieser Nachricht kann ein evtl. im Speicher vorhandener
             Fontselector, der im erweiterten XAcc-Namen die Kennung
             'XFontSelect' besitzt, aufgerufen werden. Zur passiven Unter-
             stÅtzung des Font-Protokolls genÅgt aber die Auswertung der
             o.g. Nachricht FONT_CHANGED.
          -> negative Werte in msg[4-7] bedeuten, daû dieser Parameter
             nicht benîtigt wird, nicht eingestellt werden soll oder noch
             nicht gesetzt wurde

            msg[0]        = FONT_SELECT (0x7a19)
            msg[1]        = apID
            msg[2]        = 0
            msg[3]        = Handle des Fensters, dessen Zeichensatz einge-
                            stellt werden soll, oder ein negativer Wert,
                            wenn der Zeichensatz in allen Fenstern der
                            Applikation gewechselt werden soll
            msg[4]        = Font-ID
            msg[5]        = Font-Grîûe in Punkt
            msg[6]        = Effekte (s.o.)
            msg[7]        = Farbe

        FONT_ACK-Nachricht:
          -> Fontselector darÅber informieren, ob die FONT_CHANGED-Nachricht
             ausgewertet bzw. die Zeichensatz-Attribute eingestellt werden
             konnten

           msg[0]         = FONT_ACK (0x7a1a)
           msg[1]         = apID
           msg[2]         = 0
           msg[3]         = TRUE (1):  Nachricht wurde ausgewertet
                            FALSE (0): Nachricht wurde ignoriert
           msg[4-7]       = 0 (reserviert)

        Scan-Codes:
        -----------

        #define SCANESC     1       /* Esc */
        #define SCANTAB     15      /* Tab */
        #define SCANRET     28      /* Return */
        #define SCANDEL     83      /* Delete */
        #define SCANBS      14      /* Backspace */
        #define SCANENTER   114     /* Enter */

        #define SCANHELP    98      /* Help */
        #define SCANUNDO    97      /* Undo */
        #define SCANINS     82      /* Insert */
        #define SCANHOME    71      /* Clr/Home */

        #define SCANUP      72      /* Up */
        #define SCANDOWN    80      /* Down */

        #define SCANLEFT    75      /* Left */
        #define SCANRIGHT   77      /* Right */

        #define CTRLLEFT    115     /* Ctrl-Left */
        #define CTRLRIGHT   116     /* Ctrl-Right */

        #define SCANF1      59      /* F1 - F10 */
        ...
        #define SCANF10     68

        #define CTRLF1      84      /* CTRL-F1 - CTRL-F10 */
        ...
        #define CTRLF10     93

        EGEM-Stringkonstanten:
        ----------------------

        E_GEM:         Name der Library ("EnhancedGEM")
        E_GEM_DATE:    Erstellungsdatum der Library, Format wie
                       bei __DATE__
        E_GEM_VERSION: Versionsnummer der Library ("x.xx")
