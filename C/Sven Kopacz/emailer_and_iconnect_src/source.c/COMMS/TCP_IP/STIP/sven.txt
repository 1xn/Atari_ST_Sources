Hi Sven!Folgende Funktionen kînnte ich Dir ohne grîûeren Aufwand anbieten. Es gibt synchroneund asnychrone Funktionen./* =============================================================================== *//* Zuerst einige Typvereinbarungen: *//* =============================================================================== */#ifndef TRUE	#define TRUE						1	#define FALSE						0	typedef short Boolean;#endif#define ERR_NONE						0#define ERR_MAC_CALL					1#define ERR_INVALID_PARAMETER			2#define ERR_OOM							3#define ERR_DNR							4#define ERR_INVALID_HANDLE				5#define ERR_UDP_TOO_LARGE				6#define MAX_DATA_SIZE					32000#define IP_ADDR_LENGTH					255typedef char IPAddress[IP_ADDR_LENGTH+1];typedef unsigned char uchar;typedef unsigned short ushort;typedef unsigned int uint;typedef unsigned long ulong;typedef ulong ConnectionHandle;/* =============================================================================== *//* Hier die synchronen Funktionen. Sie kehren erst nach getaner Arbeit zurÅck: *//* =============================================================================== *//* Ein Handle fÅr eine neue TCP-Verbindung allokieren/* handle: Zeiger auf das neue Handle Boolean TCP_Create_Sync(ConnectionHandle *handle);/* Eine neue TCP-Verbindung îffnen/* handle: wird von TCP_Create_Sync() geliefert /* connectionTimeout: Verbindungs-Timeout in Sekunden /* remoteIPAddress: Ziel-IP-Adresse, wird notfalls aufgelîst /* remotePort: Ziel-Port /* localPort: Zeiger auf Variable, die lokalen Port enthÑlt; darf 0 enthalten, /* dann wird ein neuer Port genommen und in der Variable zurÅckgeliefert.Boolean TCP_ActiveOpen_Sync(ConnectionHandle handle, ulong connectionTimeout,            IPAddress remoteIPAddress, ushort remotePort, ushort *localPort);/* Auf eine neue TCP-Verbindung warten/* handle: wird von TCP_Create_Sync() geliefert /* connectionTimeout: Verbindungs-Timeout in Sekunden /* commandTimeout: Kommando-Timeout in Sekunden /* remoteIPAddress: Ziel-IP-Adresse, wird notfalls aufgelîst; darf leer sein, dann /* wird Verbindung von jeder IP-Adresse angenommen; hier wird auch IP-Adresse des /* Verbindungspartners zurÅckgeliefert./* remotePort: Zeiger auf Variable, die Port des Partners enthÑlt; darf 0 enthalten, /* dann wird Verbindung von jedem Port angenommen; hier wird auch Port des Partners /* zurÅckgeliefert./* localPort: Zeiger auf Variable, die lokalen Port enthÑlt; darf 0 enthalten, dann /* wird ein neuer Port genommen und in der Variable zurÅckgeliefert.Boolean TCP_PassiveOpen_Sync(ConnectionHandle handle, ulong connectionTimeout,            ulong commandTimeout, IPAddress remoteIPAddress, ushort *remotePort,            ushort *localPort);/* Die Anzahl der verfÅgbaren Bytes fÅr eine TCP-Verbindung erfragen/* handle: Handle einer offnen TCP-Verbindung/* bytesAvailable: hier wird die Anzahl der verfÅgbaren Bytes zurÅckgeliefertBoolean TCP_GetBytesAvail_Sync(ConnectionHandle handle, ulong *bytesAvailable);/* Daten von einer TCP-Verbindung empfangen /* handle: Handle einer offenen TCP-Verbindung /* commandTimeout: Kommando-Timeout in Sekunden/* buffer: Zielpuffer/* bytesToReceive: Anzahl der zu empfangenden Bytes; hier wird auch die Anzahl der /* tatsÑchlich empfangenen Bytes zurÅckgeliefert.Boolean TCP_Receive_Sync(ConnectionHandle handle, ulong commandTimeout,            void *buffer, ulong *bytesToReceive);/* Daten Åber eine TCP-Verbindung senden/* handle: Handle einer offenen TCP-Verbindung/* buffer: Quellpuffer/* bytesToSend: Anzahl der zu sendenden Bytes; max. jedoch MAX_DATA_SIZE BytesBoolean TCP_Send_Sync(ConnectionHandle handle, void *buffer, ulong bytesToSend);/* Eine TCP-Verbindung "gracefully" schlieûen/* handle: Handle einer offenen TCP-VerbindungBoolean TCP_Close_Sync(ConnectionHandle handle);/* Eine TCP-Verbindung sofort beenden/* handle: Handle einer offenen TCP-VerbindungBoolean TCP_Abort_Sync(ConnectionHandle handle);/* Ein TCP-Verbindungs-Handle freigeben /* handle: ein mittels TCP_Create_Sync() allokiertes Verbindungs-Handle Boolean TCP_Release_Sync(ConnectionHandle handle);/* ================================================================================*//* UDP *//* ================================================================================*//* Einen UDP-Port allokieren /* handle: Zeiger auf das neue Handle fÅr den Port/* localPort: Zeiger auf Variable, die lokalen Port enthÑlt; darf 0 enthalten, dann /* wird ein neuer Port genommen und in der Variable zurÅckgeliefert.Boolean UDP_Create_Sync(ConnectionHandle *handle, ushort *localPort);/* Daten von einem UDP-Port lesen /* handle: UDP-Port-Handle /* commandTimeout: Kommando-Timeout in Sekunden /* buffer: Zielpuffer /* bytesToReceive: Anzahl der zu lesenden Bytes; hier wird auch die Anzahl der /* tatsÑchlich gelesenen Bytes zurÅckgeliefertBoolean UDP_Read_Sync(ConnectionHandle handle, ulong commandTimeout, void *buffer,            ulong *bytesRead);/* Daten auf einen UDP-Port schreiben/* handle: UDP-Port-Handle/* remoteIPAddress: Ziel-IP-Adresse, wird notfalls aufgelîst/* remotePort: Ziel-Port/* buffer: Quellpuffer/* bytesToWrite: Anzahl der zu schreibenden Bytes; max. jedoch MAX_DATA_SIZE BytesBoolean UDP_Write_Sync(ConnectionHandle handle, IPAddress remoteIPAddress,            ushort remotePort, void *buffer, ulong bytesToWrite);/* Ein UDP-Port-Handle freigeben /* handle: ein mittels UDP_Create_Sync() allokiertes Port-HandleBoolean UDP_Release_Sync(ConnectionHandle handle);/* MTU-Grîûe fÅr UDP-Pakete bzgl. einer bestimmten Ziel-IP-Adresse erfragen/* remoteIPAddress: Ziel-IP-Adresse, wird notfalls aufgelîst/* mtuSize: Zeiger auf Variable, in der die MTU-Grîûe zurÅckgeliefert wirdBoolean UDP_GetMTUSize_Sync(IPAddress remoteIPAddress, ulong *mtuSize);/* ================================================================================*//* IP-Adresse auflîsen/* remoteIPAddress: IP-Adresse/* addr: Zeiger auf Variable, in der die die aufgelîste Adresse zurÅckgeliefert wird.Boolean DNR_Sync(IPAddress remoteIPAddress, ulong *addr);/* ================================================================================*/sHier die asynchronen Funktionen. Sind sie beendet, wird die jeweils Åbergebene Funktion als Callback aufgerufen. Die in den Callbacks Åbergebenen "result"-Werte enthalten immer einen der oben definierten Fehlerwerte. Da die asynchronen Funktionen im Groûen und Ganzen den synchronen Funktionen entsprechen, werden sie nicht weiter kommentiert. Asynchrone und synchrone Funktionen dÅrfen fÅr eine Verbindung nicht gleichzeitig verwendet werden, sehr wohl aber nacheinander. Solange ein Callback aussteht, muû regelmÑûig Wait() aufgerufen werden, um dem Mac Rechenzeit zur AusfÅhrung seiner TCP-Aktionen zu geben. Wait() ist synchron. /* ================================================================================*//* Prototypen der Callbacks: */typedef void (TCP_Create_CB)(short result, ConnectionHandle handle);typedef void (TCP_ActiveOpen_CB)(short result, ConnectionHandle handle,               ushort localPort);typedef void (TCP_PassiveOpen_CB)(short result, ConnectionHandle handle,               ulong remoteIPAddress, ushort remotePort, ushort localPort);typedef void (TCP_GetBytesAvail_CB)(short result, ConnectionHandle handle,               ulong bytesAvailable);typedef void (TCP_Receive_CB)(short result, ConnectionHandle handle, void *buffer,               ulong bytesReceived);typedef void (TCP_Send_CB)(short result, ConnectionHandle handle);typedef void (TCP_Close_CB)(short result, ConnectionHandle handle);typedef void (TCP_Abort_CB)(short result, ConnectionHandle handle);typedef void (TCP_Release_CB)(short result, ConnectionHandle handle);typedef void (UDP_Create_CB)(short result, ConnectionHandle handle, ushort localPort);typedef void (UDP_Read_CB)(short result, ConnectionHandle handle,               ulong remoteIPAddress, ushort remotePort, void *buffer, ulong bytesRead);typedef void (UDP_Write_CB)(short result, ConnectionHandle handle);typedef void (UDP_Release_CB)(short result, ConnectionHandle handle);typedef void (UDP_GetMTUSize_CB)(short result, ulong mtuSize);typedef void (DNR_CB)(short result, ulong addr);typedef void (Test_CB)(void);Boolean TCP_Create(TCP_Create_CB *cb);Boolean TCP_ActiveOpen(ConnectionHandle handle, ulong connectionTimeout,             IPAddress remoteIPAddress, ushort remotePort, ushort localPort,             TCP_ActiveOpen_CB *cb);Boolean TCP_PassiveOpen(ConnectionHandle handle, ulong connectionTimeout,             ulong commandTimeout, IPAddress remoteIPAddress, ushort remotePort,             ushort localPort, TCP_PassiveOpen_CB *cb);Boolean TCP_GetBytesAvail(ConnectionHandle handle, TCP_GetBytesAvail_CB *cb);Boolean TCP_Receive(ConnectionHandle handle, ulong commandTimeout,             ulong bytesToReceive, TCP_Receive_CB *cb);Boolean TCP_Send(ConnectionHandle handle, void *buffer, ulong bytesToSend,             TCP_Send_CB *cb);Boolean TCP_Close(ConnectionHandle handle, TCP_Close_CB *cb);Boolean TCP_Abort(ConnectionHandle handle, TCP_Abort_CB *cb);Boolean TCP_Release(ConnectionHandle handle, TCP_Release_CB *cb);Boolean UDP_Create(ushort localPort, UDP_Create_CB *cb);Boolean UDP_Read(ConnectionHandle handle, ulong commandTimeout, UDP_Read_CB *cb);Boolean UDP_Write(ConnectionHandle handle, IPAddress remoteIPAddress,             ushort remotePort, void *buffer, ulong bytesToWrite, UDP_Write_CB *cb);Boolean UDP_Release(ConnectionHandle handle, UDP_Release_CB *cb);Boolean UDP_GetMTUSize(IPAddress remoteIPAddress, UDP_GetMTUSize_CB *cb);Boolean DNR(IPAddress remoteIPAddress, DNR_CB *cb);/* Rechenzeit an den Mac abgeben */void	Wait(void);