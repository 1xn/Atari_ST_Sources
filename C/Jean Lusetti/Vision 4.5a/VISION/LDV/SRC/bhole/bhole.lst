PASM 68040 Macro Assembler  Version Dec 18 1992  (C) 91 Pure Software  Page   1
Source File: H:\PURE_C\PROJECTS\VISION\LDV\SRC\BHOLE\BHOLE.S

   1                                        .IMPORT pre_cosin            ; array of 2*ITRIGO_ARRAY_SIZE longs
   2                                        .IMPORT pre_loffset          ; long*
   3                                        .EXPORT bh_xd, bh_yd, bh_rd2 ; long
   4                                        .EXPORT bh_xs, bh_ys, bh_ref ; long
   5                                        .EXPORT bh_xc, bh_yc         ; long
   6                                        .EXPORT bh_out_w, bh_out_h   ; short
   7                                        .EXPORT bh_in_w, bh_in_h     ; short
   8                                        .EXPORT bh_out_x, bh_out_y   ; short
   9                                    	.EXPORT BHL32_68030,BHL16_68030,BHLInd_68030
  10                                    	.EXPORT BHL32_F68030,BHL16_F68030,BHLInd_F68030
  11                                        .EXPORT lcosin_fpu
  12  
  13                                    ITRIGO_ARRAY_SIZE EQU (1 << 14)
  14                                    ITRIGO_ANGLE_MAX  EQU (ITRIGO_ARRAY_SIZE-1)
  15                                    QUARTER           EQU (ITRIGO_ARRAY_SIZE/4)
  16  
  17                                    ; The black hole transformation consists of:
  18                                    ; Rotate the destination pixel around the black hole center
  19                                    ; The closest we are to the black hole, the bigger the rotation angle is
  20                                    ; We have 2 or 3 parts of computation angle for black hole transformation:
  21                                    ; 1: Just before dividing the maximum possible angle (depending on LDV paramter Rotation angle) by:
  22                                    ; CPU: the square of distance to black hole center
  23                                    ; FPU: the distance to black hole center; here we need 68881 instruction FSQRT
  24                                    ; So there are 3 parts in macro calculations:
  25                                    ; 1.  Before dividing by distance or its square
  26                                    ; 1a. (FPU only) Compute distance
  27                                    ; 3.  Divide by either distance or its square and state if the resulting pixel is in source image
  28                                    ; Dividing by distance instead of its square gives better visual results
  29                                    MACRO BH_COMP_1
  30                                        MOVE.L    A6,D0                ; Remember A6=bh_xd
  31                                        ADD.L     D0,D0
  32                                        ADDQ.L    #1,D0
  33                                        MOVE.L    A5,D1                ; Remember A5=bh_rd2
  34                                        ADD.L     D0,D1                ; bh_rd2(D1)=1+2*bh_xd(D0)
  35                                        MOVE.L    bh_ref(PC),D2
  36                                        MOVE.L    D1,A5                ; Save bh_rd2, free D1
  37                                        ADDQ.L    #1,D1                ; We need bh_rd2+1 for divide
  38                                    ENDM
  39  
  40                                    MACRO BH_COMP_2 bail_out_addr
  41                                        DIVU.L    D1,D2                ; alpha(D2)=bh_ref/(1+bh_rd2)
  42                                        ANDI.L    #ITRIGO_ANGLE_MAX,D2 ; alpha &= ITRIGO_ANGLE_MAX
  43                                    
  44                                        LSL.L     #3,D2                ; D2=offset for pre_cosin array
  45                                        MOVE.L    A6,D0                ; D0=bh_xd   
  46                                        MOVE.L    bh_yd(PC),D1         ; D1=bh_yd   
  47                                        MOVE.L    4(A2,D2.L),D3        ; A2->pre_cosin, D3.L=SIN(alpha)
  48                                        MOVE.L    (A2,D2.L),D2         ; A2->pre_cosin, D2.L=COS(alpha)
  49                                    
  50                                        MOVEQ.L   #16,D6               ; Prepare shifts/assume not in range
  51                                    
  52                                        MOVE.L    D0,D4
  53                                        MULS.L    D2,D4                ; D4=bh_xd * pre_cos[alpha]
  54                                        MOVE.L    D1,D5
  55                                        MULS.L    D3,D5                ; D5=bh_yd * pre_sin[alpha]
  56                                        SUB.L     D5,D4                ; D4=bh_xd * pre_cos[alpha] - bh_yd * pre_sin[alpha]
PASM 68040 Macro Assembler  Version Dec 18 1992  (C) 91 Pure Software  Page   2
Source File: H:\PURE_C\PROJECTS\VISION\LDV\SRC\BHOLE\BHOLE.S

  57                                        ASR.L     D6,D4
  58                                        ADD.L     bh_xc(PC),D4         ; D6=16, assume pixel not in range
  59                                        BLT.S     bail_out_addr        ; xs < 0: not in range
  60                                        CMP.W     bh_in_w(PC),D4
  61                                        BGE.S     bail_out_addr        ; xs >= bh_in_w: not in range
  62                                        MOVE.L    D4,A3                ; A3=bh_xs= (D4 >> 16)
  63                                    
  64                                        MOVE.L    D0,D4
  65                                        MULS.L    D3,D4                ; D4=bh_xd * pre_sin[alpha]
  66                                        MOVE.L    D1,D5
  67                                        MULS.L    D2,D5                ; D5=bh_yd * pre_cos[alpha]
  68                                        ADD.L     D5,D4                ; D4=bh_xd * pre_sin[alpha] + bh_yd * pre_cos[alpha]
  69                                        ASR.L     D6,D4
  70                                        ADD.L     bh_yc(PC),D4         ; D4.L=bh_ys
  71                                        BLT.S     bail_out_addr        ; ys < 0: not in range
  72                                        CMP.W     bh_in_h(PC),D4
  73                                        BGE.S     bail_out_addr        ; ys >= bh_in_h: not in range
  74                                        MOVEQ.L   #0,D6                ; pixel in range
  75                                    ENDM
  76  
  77                                    ; Macro for CPU 68030
  78                                    MACRO BH_COMPUTE_CPU bail_out_addr
  79                                        BH_COMP_1
  80                                        BH_COMP_2 bail_out_addr
  81                                    ENDM
  82  
  83                                    ; Macro for using FPU
  84                                    ; What we do with FPU is to compute the square root of D1 which
  85                                    ; Is then the distance to the back hole center instead of its square
  86                                    MACRO BH_COMPUTE_FPU bail_out_addr
  87                                        BH_COMP_1
  88                                        FMOVE.L     D1,FP0
  89                                        FSQRT       FP0
  90                                        FMOVE.L     FP0,D1
  91                                        BH_COMP_2 bail_out_addr
  92                                    ENDM
  93  
  94                                    ; Init parameters valid for the entire call
  95                                    MACRO INIT_BHL
  96                                        LEA.L     pre_cosin,A2
  97                                    	MOVE.L    pre_loffset,A4          ; A4-->preoffset
  98                                    	MOVE.L    bh_rd2(PC),A5           ; A5=bh_rd2
  99                                    	MOVE.L    bh_xd(PC),A6            ; A6=bh_xd
 100                                    	MOVE.W    bh_out_w(PC),D7
 101                                    	SUBQ.W    #1,D7                   ; For DBF
 102                                    ENDM
 103  
 104                                    MACRO INIT_BHL_SYM
 105                                        LEA.L     pre_cosin,A2
 106                                    	MOVE.L    pre_loffset,A4          ; A4-->preoffset
 107                                    	MOVE.L    bh_rd2(PC),A5           ; A5=bh_rd2
 108                                    	MOVE.L    bh_xd(PC),A6            ; A6=bh_xd
 109                                    	MOVE.W    bh_out_w(PC),D7
 110                                        LSR.W     #1,D7                   ; loop to bh_out_w/2 counts
 111                                        ADD.W     A6,D7                   ; starting from bh_xd
 112                                        MOVE.W    D7,last_xd
PASM 68040 Macro Assembler  Version Dec 18 1992  (C) 91 Pure Software  Page   3
Source File: H:\PURE_C\PROJECTS\VISION\LDV\SRC\BHOLE\BHOLE.S

 113                                    ENDM
 114  
 115                                    ; Get pixel TC32 -->dest (Dx)
 116                                    ; A4-->pre_loffset
 117                                    MACRO GET_TCPIXEL32 p,x,y,dest
 118                                        MOVE.L    (A4,y.L*4),dest
 119                                        ADD.L     x,dest
 120                                        MOVE.L    (p,dest.L*4),dest
 121                                    ENDM
 122  
 123                                    ; Set pixel TC32 val(Dx) -->dest
 124                                    ; A4-->pre_loffset
 125                                    ; scratch_Dx scratch variable
 126                                    MACRO SET_TCPIXEL32 p,x,y,val,scratch_Dx
 127                                        MOVE.L    (A4,y.L*4),scratch_Dx
 128                                        ADD.L     x,scratch_Dx
 129                                        MOVE.L    val,(p,scratch_Dx.L*4)
 130                                    ENDM
 131  
 132                                    ; Get pixel TC16 -->dest (Dx)
 133                                    ; A4-->pre_loffset
 134                                    MACRO GET_TCPIXEL16 p,x,y,dest
 135                                        MOVE.L    (A4,y.L*4),dest
 136                                        ADD.L     x,dest
 137                                        MOVE.W    (p,dest.L*2),dest
 138                                    ENDM
 139  
 140                                    ; Set pixel TC16 val(Dx) -->dest
 141                                    ; A4-->pre_loffset
 142                                    ; scratch_Dx scratch variable
 143                                    MACRO SET_TCPIXEL16 p,x,y,val,scratch_Dx
 144                                        MOVE.L    (A4,y.L*4),scratch_Dx
 145                                        ADD.L     x,scratch_Dx
 146                                        MOVE.W    val,(p,scratch_Dx.L*2)
 147                                    ENDM
 148  
 149                                    ; Rotate 90
 150                                    ; x,y,scratch_Dx : registers, y has to be Dx
 151                                    ; #define R90(x,y)  { long _x=x; x=-y; y=_x; }
 152                                    MACRO R90 x,y,scratch_Dx
 153                                        MOVE.L    x,scratch_Dx
 154                                        NEG.L     y
 155                                        MOVE.L    y,x
 156                                        MOVE.L    scratch_Dx,y
 157                                    ENDM
 158  
 159                                    MACRO PIXINIMG x,y,w,h,bailout
 160                                        TST.W     x
 161                                        BLT.S     bailout
 162                                        TST.W     y
 163                                        BLT.S     bailout
 164                                        CMP.W     w,x
 165                                        BGE.S     bailout
 166                                        CMP.W     h,y
 167                                        BGE.S     bailout
 168                                    ENDM
PASM 68040 Macro Assembler  Version Dec 18 1992  (C) 91 Pure Software  Page   4
Source File: H:\PURE_C\PROJECTS\VISION\LDV\SRC\BHOLE\BHOLE.S

 169  
 170                                    ; On sample file 00_1480ms.jpg, Aranym 32bit:
 171                                    ; BHL32_68000 takes about 1450ms
 172                                    ; BHL32_68030 takes about 740ms
 173  
 174                                    ; 68030 routine for True Color 32bit
 175                                    ; BHL32_68030(short use_sym, void* in, void* out)
 176                                    ;                   D0,            A0        A1
 177 00000000'                          BHL32_68030:
 178 00000000' 48E7 FF3E                    MOVEM.L   D0-D7/A2-A6,-(SP)       ; Save context
 179  
 180 00000004' 4A40                         TST.W      D0
 181 00000006' 6600 00AE                    BNE        BHL32_68030_sym
 182  
 183 0000000A' 7E00                         MOVEQ.L   #0,D7
 184 0000000C' 3E3A 0488                    MOVE.W    bh_out_x(PC),D7
 185 00000010' E58F                         LSL.L     #2,D7
 186 00000012' D3C7                         ADD.L     D7,A1                   ; A1-->&out[bh_out_x]
 187                                        INIT_BHL
  96 00000014' 45F9 00000000*          +    LEA.L     pre_cosin,A2
  97 0000001A' 2879 00000000*          +	MOVE.L    pre_loffset,A4          ; A4-->preoffset
  98 00000020' 2A7A 0454               +	MOVE.L    bh_rd2(PC),A5           ; A5=bh_rd2
  99 00000024' 2C7A 0448               +	MOVE.L    bh_xd(PC),A6            ; A6=bh_xd
 100 00000028' 3E3A 0464               +	MOVE.W    bh_out_w(PC),D7
 101 0000002C' 5347                    +	SUBQ.W    #1,D7                   ; For DBF
 188 0000002E'                          bhl32_l030:
 189                                        BH_COMPUTE_CPU bhl32_tpir_030     ; -->D6=0:pixel in range
  30 0000002E' 200E                    +    MOVE.L    A6,D0                ; Remember A6=bh_xd
  31 00000030' D080                    +    ADD.L     D0,D0
  32 00000032' 5280                    +    ADDQ.L    #1,D0
  33 00000034' 220D                    +    MOVE.L    A5,D1                ; Remember A5=bh_rd2
  34 00000036' D280                    +    ADD.L     D0,D1                ; bh_rd2(D1)=1+2*bh_xd(D0)
  35 00000038' 243A 0448               +    MOVE.L    bh_ref(PC),D2
  36 0000003C' 2A41                    +    MOVE.L    D1,A5                ; Save bh_rd2, free D1
  37 0000003E' 5281                    +    ADDQ.L    #1,D1                ; We need bh_rd2+1 for divide
  41 00000040' 4C41 2002               +    DIVU.L    D1,D2                ; alpha(D2)=bh_ref/(1+bh_rd2)
  42 00000044' 0282 0000 3FFF          +    ANDI.L    #ITRIGO_ANGLE_MAX,D2 ; alpha &= ITRIGO_ANGLE_MAX
  44 0000004A' E78A                    +    LSL.L     #3,D2                ; D2=offset for pre_cosin array
  45 0000004C' 200E                    +    MOVE.L    A6,D0                ; D0=bh_xd   
  46 0000004E' 223A 0422               +    MOVE.L    bh_yd(PC),D1         ; D1=bh_yd   
  47 00000052' 2632 2804               +    MOVE.L    4(A2,D2.L),D3        ; A2->pre_cosin, D3.L=SIN(alpha)
  48 00000056' 2432 2800               +    MOVE.L    (A2,D2.L),D2         ; A2->pre_cosin, D2.L=COS(alpha)
  50 0000005A' 7C10                    +    MOVEQ.L   #16,D6               ; Prepare shifts/assume not in range
  52 0000005C' 2800                    +    MOVE.L    D0,D4
  53 0000005E' 4C02 4800               +    MULS.L    D2,D4                ; D4=bh_xd * pre_cos[alpha]
  54 00000062' 2A01                    +    MOVE.L    D1,D5
  55 00000064' 4C03 5800               +    MULS.L    D3,D5                ; D5=bh_yd * pre_sin[alpha]
  56 00000068' 9885                    +    SUB.L     D5,D4                ; D4=bh_xd * pre_cos[alpha] - bh_yd * pre_sin[alpha]
  57 0000006A' ECA4                    +    ASR.L     D6,D4
  58 0000006C' D8BA 0418               +    ADD.L     bh_xc(PC),D4         ; D6=16, assume pixel not in range
  59 00000070' 6D 26                   +    BLT.S     bhl32_tpir_030        ; xs < 0: not in range
  60 00000072' B87A 041E               +    CMP.W     bh_in_w(PC),D4
  61 00000076' 6C 20                   +    BGE.S     bhl32_tpir_030        ; xs >= bh_in_w: not in range
  62 00000078' 2644                    +    MOVE.L    D4,A3                ; A3=bh_xs= (D4 >> 16)
  64 0000007A' 2800                    +    MOVE.L    D0,D4
  65 0000007C' 4C03 4800               +    MULS.L    D3,D4                ; D4=bh_xd * pre_sin[alpha]
PASM 68040 Macro Assembler  Version Dec 18 1992  (C) 91 Pure Software  Page   5
Source File: H:\PURE_C\PROJECTS\VISION\LDV\SRC\BHOLE\BHOLE.S

  66 00000080' 2A01                    +    MOVE.L    D1,D5
  67 00000082' 4C02 5800               +    MULS.L    D2,D5                ; D5=bh_yd * pre_cos[alpha]
  68 00000086' D885                    +    ADD.L     D5,D4                ; D4=bh_xd * pre_sin[alpha] + bh_yd * pre_cos[alpha]
  69 00000088' ECA4                    +    ASR.L     D6,D4
  70 0000008A' D8BA 03FE               +    ADD.L     bh_yc(PC),D4         ; D4.L=bh_ys
  71 0000008E' 6D 08                   +    BLT.S     bhl32_tpir_030        ; ys < 0: not in range
  72 00000090' B87A 0402               +    CMP.W     bh_in_h(PC),D4
  73 00000094' 6C 02                   +    BGE.S     bhl32_tpir_030        ; ys >= bh_in_h: not in range
  74 00000096' 7C00                    +    MOVEQ.L   #0,D6                ; pixel in range
 190 00000098'                          bhl32_tpir_030:
 191 00000098' 70FF                         MOVEQ.L   #-1,D0                  ; Assume out of range
 192 0000009A' 4A46                         TST.W     D6
 193 0000009C' 66 0A                    	BNE.S     bhl32_setpix_030
 194 0000009E' 2034 4C00                	MOVE.L    (A4,D4.L*4),D0          ; D4=bh_ys, D0=pre_loffset[bh_ys]
 195 000000A2' D08B                     	ADD.L     A3,D0                   ; D0=pre_loffset[bh_ys] + bh_xs(A3)
 196 000000A4' 2030 0C00                	MOVE.L    (A0,D0.L*4),D0          ; D0=in_ptr[pre_loffset[bh_ys] + bh_xs]
 197 000000A8'                          bhl32_setpix_030:
 198 000000A8' 22C0                         MOVE.L    D0,(A1)+
 199 000000AA' 528E                         ADD.L     #1,A6                   ; bh_xd++
 200 000000AC' 51CF FF80                	DBF       D7,bhl32_l030
 201  
 202 000000B0' 4CDF 7CFF                    MOVEM.L   (SP)+,D0-D7/A2-A6       ; Restore context
 203 000000B4' 4E75                         RTS
 204  
 205 000000B6'                          BHL32_68030_sym:
 206                                        INIT_BHL_SYM
 105 000000B6' 45F9 00000000*          +    LEA.L     pre_cosin,A2
 106 000000BC' 2879 00000000*          +	MOVE.L    pre_loffset,A4          ; A4-->preoffset
 107 000000C2' 2A7A 03B2               +	MOVE.L    bh_rd2(PC),A5           ; A5=bh_rd2
 108 000000C6' 2C7A 03A6               +	MOVE.L    bh_xd(PC),A6            ; A6=bh_xd
 109 000000CA' 3E3A 03C2               +	MOVE.W    bh_out_w(PC),D7
 110 000000CE' E24F                    +    LSR.W     #1,D7                   ; loop to bh_out_w/2 counts
 111 000000D0' DE4E                    +    ADD.W     A6,D7                   ; starting from bh_xd
 112 000000D2' 33C7 00000000'          +    MOVE.W    D7,last_xd
 207 000000D8'                          bhl32_l030_sym:
 208                                        BH_COMPUTE_CPU bhl32_tpir_030_sym ; -->D6=0:pixel in range
  30 000000D8' 200E                    +    MOVE.L    A6,D0                ; Remember A6=bh_xd
  31 000000DA' D080                    +    ADD.L     D0,D0
  32 000000DC' 5280                    +    ADDQ.L    #1,D0
  33 000000DE' 220D                    +    MOVE.L    A5,D1                ; Remember A5=bh_rd2
  34 000000E0' D280                    +    ADD.L     D0,D1                ; bh_rd2(D1)=1+2*bh_xd(D0)
  35 000000E2' 243A 039E               +    MOVE.L    bh_ref(PC),D2
  36 000000E6' 2A41                    +    MOVE.L    D1,A5                ; Save bh_rd2, free D1
  37 000000E8' 5281                    +    ADDQ.L    #1,D1                ; We need bh_rd2+1 for divide
  41 000000EA' 4C41 2002               +    DIVU.L    D1,D2                ; alpha(D2)=bh_ref/(1+bh_rd2)
  42 000000EE' 0282 0000 3FFF          +    ANDI.L    #ITRIGO_ANGLE_MAX,D2 ; alpha &= ITRIGO_ANGLE_MAX
  44 000000F4' E78A                    +    LSL.L     #3,D2                ; D2=offset for pre_cosin array
  45 000000F6' 200E                    +    MOVE.L    A6,D0                ; D0=bh_xd   
  46 000000F8' 223A 0378               +    MOVE.L    bh_yd(PC),D1         ; D1=bh_yd   
  47 000000FC' 2632 2804               +    MOVE.L    4(A2,D2.L),D3        ; A2->pre_cosin, D3.L=SIN(alpha)
  48 00000100' 2432 2800               +    MOVE.L    (A2,D2.L),D2         ; A2->pre_cosin, D2.L=COS(alpha)
  50 00000104' 7C10                    +    MOVEQ.L   #16,D6               ; Prepare shifts/assume not in range
  52 00000106' 2800                    +    MOVE.L    D0,D4
  53 00000108' 4C02 4800               +    MULS.L    D2,D4                ; D4=bh_xd * pre_cos[alpha]
  54 0000010C' 2A01                    +    MOVE.L    D1,D5
  55 0000010E' 4C03 5800               +    MULS.L    D3,D5                ; D5=bh_yd * pre_sin[alpha]
PASM 68040 Macro Assembler  Version Dec 18 1992  (C) 91 Pure Software  Page   6
Source File: H:\PURE_C\PROJECTS\VISION\LDV\SRC\BHOLE\BHOLE.S

  56 00000112' 9885                    +    SUB.L     D5,D4                ; D4=bh_xd * pre_cos[alpha] - bh_yd * pre_sin[alpha]
  57 00000114' ECA4                    +    ASR.L     D6,D4
  58 00000116' D8BA 036E               +    ADD.L     bh_xc(PC),D4         ; D6=16, assume pixel not in range
  59 0000011A' 6D 26                   +    BLT.S     bhl32_tpir_030_sym        ; xs < 0: not in range
  60 0000011C' B87A 0374               +    CMP.W     bh_in_w(PC),D4
  61 00000120' 6C 20                   +    BGE.S     bhl32_tpir_030_sym        ; xs >= bh_in_w: not in range
  62 00000122' 2644                    +    MOVE.L    D4,A3                ; A3=bh_xs= (D4 >> 16)
  64 00000124' 2800                    +    MOVE.L    D0,D4
  65 00000126' 4C03 4800               +    MULS.L    D3,D4                ; D4=bh_xd * pre_sin[alpha]
  66 0000012A' 2A01                    +    MOVE.L    D1,D5
  67 0000012C' 4C02 5800               +    MULS.L    D2,D5                ; D5=bh_yd * pre_cos[alpha]
  68 00000130' D885                    +    ADD.L     D5,D4                ; D4=bh_xd * pre_sin[alpha] + bh_yd * pre_cos[alpha]
  69 00000132' ECA4                    +    ASR.L     D6,D4
  70 00000134' D8BA 0354               +    ADD.L     bh_yc(PC),D4         ; D4.L=bh_ys
  71 00000138' 6D 08                   +    BLT.S     bhl32_tpir_030_sym        ; ys < 0: not in range
  72 0000013A' B87A 0358               +    CMP.W     bh_in_h(PC),D4
  73 0000013E' 6C 02                   +    BGE.S     bhl32_tpir_030_sym        ; ys >= bh_in_h: not in range
  74 00000140' 7C00                    +    MOVEQ.L   #0,D6                ; pixel in range
 209 00000142'                          bhl32_tpir_030_sym:
 210 00000142' 70FF                         MOVEQ.L   #-1,D0                  ; Assume out of range
 211 00000144' 4A46                         TST.W     D6
 212 00000146' 66 0A                    	BNE.S     bhl32_setpix_030_sym
 213                                    	GET_TCPIXEL32  A0,A3,D4,D0        ; A0-->in_ptr, A3=bh_xs+bh_xc, D4=bh_ys+bh_yc
 118 00000148' 2034 4C00               +    MOVE.L    (A4,D4.L*4),D0
 119 0000014C' D08B                    +    ADD.L     A3,D0
 120 0000014E' 2030 0C00               +    MOVE.L    (A0,D0.L*4),D0
 214                                                                          ; D0=GET_TCPIXEL(in_ptr, bh_xs+bh_xc, bh_ys+bh_yc)
 215 00000152'                          bhl32_setpix_030_sym:
 216 00000152' 2F0E                         MOVE.L    A6,-(SP)                ; Save bh_xd
 217 00000154' 243A 0330                    MOVE.L    bh_xc(PC),D2            ; D2=bh_xc
 218 00000158' 263A 0330                    MOVE.L    bh_yc(PC),D3            ; D3=bh_yc
 219 0000015C' DDC2                         ADD.L     D2,A6                   ; A6=bh_xd+bh_xc
 220 0000015E' 2E3A 0312                    MOVE.L    bh_yd(PC),D7
 221 00000162' DE83                         ADD.L     D3,D7                   ; D7=bh_yd+bh_yc
 222                                        SET_TCPIXEL32 A1,A6,D7,D0,D5      ; SET_TCPIXEL(out_ptr, bh_xd+bh_xc, bh_yd+bh_yc, GET_TCPIXEL(in_ptr, bh_xs+bh_xc, bh_ys+bh_yc))
 127 00000164' 2A34 7C00               +    MOVE.L    (A4,D7.L*4),D5
 128 00000168' DA8E                    +    ADD.L     A6,D5
 129 0000016A' 2380 5C00               +    MOVE.L    D0,(A1,D5.L*4)
 223  
 224 0000016E' 7202                         MOVEQ.L   #2,D1                   ; 3 loops, -1 for DBF
 225 00000170'                          deduc32_030:
 226 00000170' 97C2                         SUB.L     D2,A3                   ; We need now bh_xs(A3) and bh_ys(D4) relative to
 227 00000172' 9883                         SUB.L     D3,D4                   ; Black Hole center to use R90
 228 00000174' 9DC2                         SUB.L     D2,A6                   ; We need now bh_xd(A6) and bh_yd(D7) relative to
 229 00000176' 9E83                         SUB.L     D3,D7                   ; Black Hole center to use R90
 230  
 231                                        R90       A6,D7,D0                ; Rotate (xd,yd) by PI/4
 153 00000178' 200E                    +    MOVE.L    A6,D0
 154 0000017A' 4487                    +    NEG.L     D7
 155 0000017C' 2C47                    +    MOVE.L    D7,A6
 156 0000017E' 2E00                    +    MOVE.L    D0,D7
 232                                        R90       A3,D4,D0                ; Rotate (xs,ys) by PI/4
 153 00000180' 200B                    +    MOVE.L    A3,D0
 154 00000182' 4484                    +    NEG.L     D4
 155 00000184' 2644                    +    MOVE.L    D4,A3
 156 00000186' 2800                    +    MOVE.L    D0,D4
PASM 68040 Macro Assembler  Version Dec 18 1992  (C) 91 Pure Software  Page   7
Source File: H:\PURE_C\PROJECTS\VISION\LDV\SRC\BHOLE\BHOLE.S

 233  
 234 00000188' D7C2                         ADD.L     D2,A3                   ; Now we need coords in image raster
 235 0000018A' D883                         ADD.L     D3,D4
 236 0000018C' DDC2                         ADD.L     D2,A6
 237 0000018E' DE83                         ADD.L     D3,D7
 238  
 239                                        PIXINIMG  A6,D7,bh_in_w(PC),bh_in_h(PC),dnotinimg32_030 ; Check if pixel in dest is within bounds
 160 00000190' 4A4E                    +    TST.W     A6
 161 00000192' 6D 3A                   +    BLT.S     dnotinimg32_030
 162 00000194' 4A47                    +    TST.W     D7
 163 00000196' 6D 36                   +    BLT.S     dnotinimg32_030
 164 00000198' BCFA 02F8               +    CMP.W     bh_in_w(PC),A6
 165 0000019C' 6C 30                   +    BGE.S     dnotinimg32_030
 166 0000019E' BE7A 02F4               +    CMP.W     bh_in_h(PC),D7
 167 000001A2' 6C 2A                   +    BGE.S     dnotinimg32_030
 240 000001A4' 70FF                         MOVEQ.L   #-1,D0                  ; Assume out of range
 241                                        PIXINIMG  A3,D4,bh_in_w(PC),bh_in_h(PC),plotdest32_030 ; Check if pixel in src is within bounds
 160 000001A6' 4A4B                    +    TST.W     A3
 161 000001A8' 6D 1A                   +    BLT.S     plotdest32_030
 162 000001AA' 4A44                    +    TST.W     D4
 163 000001AC' 6D 16                   +    BLT.S     plotdest32_030
 164 000001AE' B6FA 02E2               +    CMP.W     bh_in_w(PC),A3
 165 000001B2' 6C 10                   +    BGE.S     plotdest32_030
 166 000001B4' B87A 02DE               +    CMP.W     bh_in_h(PC),D4
 167 000001B8' 6C 0A                   +    BGE.S     plotdest32_030
 242                                    	GET_TCPIXEL32  A0,A3,D4,D0        ; A0-->in_ptr, A3=bh_xs+bh_xc, D4=bh_ys+bh_yc
 118 000001BA' 2034 4C00               +    MOVE.L    (A4,D4.L*4),D0
 119 000001BE' D08B                    +    ADD.L     A3,D0
 120 000001C0' 2030 0C00               +    MOVE.L    (A0,D0.L*4),D0
 243                                                                          ; D0=GET_TCPIXEL(in_ptr, bh_xs+bh_xc, bh_ys+bh_yc)
 244 000001C4'                          plotdest32_030:
 245                                        SET_TCPIXEL32 A1,A6,D7,D0,D5      ; SET_TCPIXEL(out_ptr, bh_xd+bh_xc, bh_yd+bh_yc, GET_TCPIXEL(in_ptr, bh_xs+bh_xc, bh_ys+bh_yc))
 127 000001C4' 2A34 7C00               +    MOVE.L    (A4,D7.L*4),D5
 128 000001C8' DA8E                    +    ADD.L     A6,D5
 129 000001CA' 2380 5C00               +    MOVE.L    D0,(A1,D5.L*4)
 246 000001CE'                          dnotinimg32_030:
 247 000001CE' 51C9 FFA0                     DBF D1,deduc32_030
 248  
 249 000001D2' 2C5F                         MOVE.L    (SP)+,A6                ; Restore bh_xd
 250 000001D4' 528E                         ADD.L     #1,A6                   ; bh_xd++
 251 000001D6' BCFA 02C2                    CMP.W     last_xd(PC),A6
 252 000001DA' 6F00 FEFC                    BLE       bhl32_l030_sym
 253  
 254 000001DE' 4CDF 7CFF                    MOVEM.L   (SP)+,D0-D7/A2-A6       ; Restore context
 255 000001E2' 4E75                         RTS
 256  
 257                                    ; 68030 routine for True Color 16bit
 258                                    ; BHL16_68030(short use_sym, void* in, void* out)
 259                                    ;                   D0,            A0        A1
 260 000001E4'                          BHL16_68030:
 261 000001E4' 48E7 FF3E                    MOVEM.L   D0-D7/A2-A6,-(SP)       ; Save context
 262  
 263 000001E8' 4A40                         TST.W      D0
 264 000001EA' 6600 00AE                    BNE        BHL16_68030_sym
 265  
 266 000001EE' 7E00                         MOVEQ.L   #0,D7
PASM 68040 Macro Assembler  Version Dec 18 1992  (C) 91 Pure Software  Page   8
Source File: H:\PURE_C\PROJECTS\VISION\LDV\SRC\BHOLE\BHOLE.S

 267 000001F0' 3E3A 02A4                    MOVE.W    bh_out_x(PC),D7
 268 000001F4' DE87                         ADD.L     D7,D7
 269 000001F6' D3C7                         ADD.L     D7,A1                   ; A1-->&out[bh_out_x]
 270                                        INIT_BHL
  96 000001F8' 45F9 00000000*          +    LEA.L     pre_cosin,A2
  97 000001FE' 2879 00000000*          +	MOVE.L    pre_loffset,A4          ; A4-->preoffset
  98 00000204' 2A7A 0270               +	MOVE.L    bh_rd2(PC),A5           ; A5=bh_rd2
  99 00000208' 2C7A 0264               +	MOVE.L    bh_xd(PC),A6            ; A6=bh_xd
 100 0000020C' 3E3A 0280               +	MOVE.W    bh_out_w(PC),D7
 101 00000210' 5347                    +	SUBQ.W    #1,D7                   ; For DBF
 271 00000212'                          bhl16_l030:
 272                                        BH_COMPUTE_CPU bhl16_tpir_030     ; -->D6=0:pixel in range
  30 00000212' 200E                    +    MOVE.L    A6,D0                ; Remember A6=bh_xd
  31 00000214' D080                    +    ADD.L     D0,D0
  32 00000216' 5280                    +    ADDQ.L    #1,D0
  33 00000218' 220D                    +    MOVE.L    A5,D1                ; Remember A5=bh_rd2
  34 0000021A' D280                    +    ADD.L     D0,D1                ; bh_rd2(D1)=1+2*bh_xd(D0)
  35 0000021C' 243A 0264               +    MOVE.L    bh_ref(PC),D2
  36 00000220' 2A41                    +    MOVE.L    D1,A5                ; Save bh_rd2, free D1
  37 00000222' 5281                    +    ADDQ.L    #1,D1                ; We need bh_rd2+1 for divide
  41 00000224' 4C41 2002               +    DIVU.L    D1,D2                ; alpha(D2)=bh_ref/(1+bh_rd2)
  42 00000228' 0282 0000 3FFF          +    ANDI.L    #ITRIGO_ANGLE_MAX,D2 ; alpha &= ITRIGO_ANGLE_MAX
  44 0000022E' E78A                    +    LSL.L     #3,D2                ; D2=offset for pre_cosin array
  45 00000230' 200E                    +    MOVE.L    A6,D0                ; D0=bh_xd   
  46 00000232' 223A 023E               +    MOVE.L    bh_yd(PC),D1         ; D1=bh_yd   
  47 00000236' 2632 2804               +    MOVE.L    4(A2,D2.L),D3        ; A2->pre_cosin, D3.L=SIN(alpha)
  48 0000023A' 2432 2800               +    MOVE.L    (A2,D2.L),D2         ; A2->pre_cosin, D2.L=COS(alpha)
  50 0000023E' 7C10                    +    MOVEQ.L   #16,D6               ; Prepare shifts/assume not in range
  52 00000240' 2800                    +    MOVE.L    D0,D4
  53 00000242' 4C02 4800               +    MULS.L    D2,D4                ; D4=bh_xd * pre_cos[alpha]
  54 00000246' 2A01                    +    MOVE.L    D1,D5
  55 00000248' 4C03 5800               +    MULS.L    D3,D5                ; D5=bh_yd * pre_sin[alpha]
  56 0000024C' 9885                    +    SUB.L     D5,D4                ; D4=bh_xd * pre_cos[alpha] - bh_yd * pre_sin[alpha]
  57 0000024E' ECA4                    +    ASR.L     D6,D4
  58 00000250' D8BA 0234               +    ADD.L     bh_xc(PC),D4         ; D6=16, assume pixel not in range
  59 00000254' 6D 26                   +    BLT.S     bhl16_tpir_030        ; xs < 0: not in range
  60 00000256' B87A 023A               +    CMP.W     bh_in_w(PC),D4
  61 0000025A' 6C 20                   +    BGE.S     bhl16_tpir_030        ; xs >= bh_in_w: not in range
  62 0000025C' 2644                    +    MOVE.L    D4,A3                ; A3=bh_xs= (D4 >> 16)
  64 0000025E' 2800                    +    MOVE.L    D0,D4
  65 00000260' 4C03 4800               +    MULS.L    D3,D4                ; D4=bh_xd * pre_sin[alpha]
  66 00000264' 2A01                    +    MOVE.L    D1,D5
  67 00000266' 4C02 5800               +    MULS.L    D2,D5                ; D5=bh_yd * pre_cos[alpha]
  68 0000026A' D885                    +    ADD.L     D5,D4                ; D4=bh_xd * pre_sin[alpha] + bh_yd * pre_cos[alpha]
  69 0000026C' ECA4                    +    ASR.L     D6,D4
  70 0000026E' D8BA 021A               +    ADD.L     bh_yc(PC),D4         ; D4.L=bh_ys
  71 00000272' 6D 08                   +    BLT.S     bhl16_tpir_030        ; ys < 0: not in range
  72 00000274' B87A 021E               +    CMP.W     bh_in_h(PC),D4
  73 00000278' 6C 02                   +    BGE.S     bhl16_tpir_030        ; ys >= bh_in_h: not in range
  74 0000027A' 7C00                    +    MOVEQ.L   #0,D6                ; pixel in range
 273 0000027C'                          bhl16_tpir_030:
 274 0000027C' 70FF                         MOVEQ.L   #-1,D0                  ; Assume out of range
 275 0000027E' 4A46                         TST.W     D6
 276 00000280' 66 0A                    	BNE.S     bhl16_setpix_030
 277 00000282' 2034 4C00                	MOVE.L    (A4,D4.L*4),D0          ; D4=bh_ys, D0=pre_loffset[bh_ys]
 278 00000286' D08B                     	ADD.L     A3,D0                   ; D0=pre_loffset[bh_ys] + bh_xs(A3)
PASM 68040 Macro Assembler  Version Dec 18 1992  (C) 91 Pure Software  Page   9
Source File: H:\PURE_C\PROJECTS\VISION\LDV\SRC\BHOLE\BHOLE.S

 279 00000288' 3030 0A00                	MOVE.W    (A0,D0.L*2),D0          ; D0=in_ptr[pre_loffset[bh_ys] + bh_xs]
 280 0000028C'                          bhl16_setpix_030:
 281 0000028C' 32C0                         MOVE.W    D0,(A1)+
 282 0000028E' 528E                         ADD.L     #1,A6                   ; bh_xd++
 283 00000290' 51CF FF80                	DBF       D7,bhl16_l030
 284  
 285 00000294' 4CDF 7CFF                    MOVEM.L   (SP)+,D0-D7/A2-A6       ; Restore context
 286 00000298' 4E75                         RTS
 287  
 288 0000029A'                          BHL16_68030_sym:
 289                                        INIT_BHL_SYM
 105 0000029A' 45F9 00000000*          +    LEA.L     pre_cosin,A2
 106 000002A0' 2879 00000000*          +	MOVE.L    pre_loffset,A4          ; A4-->preoffset
 107 000002A6' 2A7A 01CE               +	MOVE.L    bh_rd2(PC),A5           ; A5=bh_rd2
 108 000002AA' 2C7A 01C2               +	MOVE.L    bh_xd(PC),A6            ; A6=bh_xd
 109 000002AE' 3E3A 01DE               +	MOVE.W    bh_out_w(PC),D7
 110 000002B2' E24F                    +    LSR.W     #1,D7                   ; loop to bh_out_w/2 counts
 111 000002B4' DE4E                    +    ADD.W     A6,D7                   ; starting from bh_xd
 112 000002B6' 33C7 00000000'          +    MOVE.W    D7,last_xd
 290 000002BC'                          bhl16_l030_sym:
 291                                        BH_COMPUTE_CPU bhl16_tpir_030_sym ; -->D6=0:pixel in range
  30 000002BC' 200E                    +    MOVE.L    A6,D0                ; Remember A6=bh_xd
  31 000002BE' D080                    +    ADD.L     D0,D0
  32 000002C0' 5280                    +    ADDQ.L    #1,D0
  33 000002C2' 220D                    +    MOVE.L    A5,D1                ; Remember A5=bh_rd2
  34 000002C4' D280                    +    ADD.L     D0,D1                ; bh_rd2(D1)=1+2*bh_xd(D0)
  35 000002C6' 243A 01BA               +    MOVE.L    bh_ref(PC),D2
  36 000002CA' 2A41                    +    MOVE.L    D1,A5                ; Save bh_rd2, free D1
  37 000002CC' 5281                    +    ADDQ.L    #1,D1                ; We need bh_rd2+1 for divide
  41 000002CE' 4C41 2002               +    DIVU.L    D1,D2                ; alpha(D2)=bh_ref/(1+bh_rd2)
  42 000002D2' 0282 0000 3FFF          +    ANDI.L    #ITRIGO_ANGLE_MAX,D2 ; alpha &= ITRIGO_ANGLE_MAX
  44 000002D8' E78A                    +    LSL.L     #3,D2                ; D2=offset for pre_cosin array
  45 000002DA' 200E                    +    MOVE.L    A6,D0                ; D0=bh_xd   
  46 000002DC' 223A 0194               +    MOVE.L    bh_yd(PC),D1         ; D1=bh_yd   
  47 000002E0' 2632 2804               +    MOVE.L    4(A2,D2.L),D3        ; A2->pre_cosin, D3.L=SIN(alpha)
  48 000002E4' 2432 2800               +    MOVE.L    (A2,D2.L),D2         ; A2->pre_cosin, D2.L=COS(alpha)
  50 000002E8' 7C10                    +    MOVEQ.L   #16,D6               ; Prepare shifts/assume not in range
  52 000002EA' 2800                    +    MOVE.L    D0,D4
  53 000002EC' 4C02 4800               +    MULS.L    D2,D4                ; D4=bh_xd * pre_cos[alpha]
  54 000002F0' 2A01                    +    MOVE.L    D1,D5
  55 000002F2' 4C03 5800               +    MULS.L    D3,D5                ; D5=bh_yd * pre_sin[alpha]
  56 000002F6' 9885                    +    SUB.L     D5,D4                ; D4=bh_xd * pre_cos[alpha] - bh_yd * pre_sin[alpha]
  57 000002F8' ECA4                    +    ASR.L     D6,D4
  58 000002FA' D8BA 018A               +    ADD.L     bh_xc(PC),D4         ; D6=16, assume pixel not in range
  59 000002FE' 6D 26                   +    BLT.S     bhl16_tpir_030_sym        ; xs < 0: not in range
  60 00000300' B87A 0190               +    CMP.W     bh_in_w(PC),D4
  61 00000304' 6C 20                   +    BGE.S     bhl16_tpir_030_sym        ; xs >= bh_in_w: not in range
  62 00000306' 2644                    +    MOVE.L    D4,A3                ; A3=bh_xs= (D4 >> 16)
  64 00000308' 2800                    +    MOVE.L    D0,D4
  65 0000030A' 4C03 4800               +    MULS.L    D3,D4                ; D4=bh_xd * pre_sin[alpha]
  66 0000030E' 2A01                    +    MOVE.L    D1,D5
  67 00000310' 4C02 5800               +    MULS.L    D2,D5                ; D5=bh_yd * pre_cos[alpha]
  68 00000314' D885                    +    ADD.L     D5,D4                ; D4=bh_xd * pre_sin[alpha] + bh_yd * pre_cos[alpha]
  69 00000316' ECA4                    +    ASR.L     D6,D4
  70 00000318' D8BA 0170               +    ADD.L     bh_yc(PC),D4         ; D4.L=bh_ys
  71 0000031C' 6D 08                   +    BLT.S     bhl16_tpir_030_sym        ; ys < 0: not in range
PASM 68040 Macro Assembler  Version Dec 18 1992  (C) 91 Pure Software  Page  10
Source File: H:\PURE_C\PROJECTS\VISION\LDV\SRC\BHOLE\BHOLE.S

  72 0000031E' B87A 0174               +    CMP.W     bh_in_h(PC),D4
  73 00000322' 6C 02                   +    BGE.S     bhl16_tpir_030_sym        ; ys >= bh_in_h: not in range
  74 00000324' 7C00                    +    MOVEQ.L   #0,D6                ; pixel in range
 292 00000326'                          bhl16_tpir_030_sym:
 293 00000326' 70FF                         MOVEQ.L   #-1,D0                  ; Assume out of range
 294 00000328' 4A46                         TST.W     D6
 295 0000032A' 66 0A                    	BNE.S     bhl16_setpix_030_sym
 296                                    	GET_TCPIXEL16  A0,A3,D4,D0        ; A0-->in_ptr, A3=bh_xs+bh_xc, D4=bh_ys+bh_yc
 135 0000032C' 2034 4C00               +    MOVE.L    (A4,D4.L*4),D0
 136 00000330' D08B                    +    ADD.L     A3,D0
 137 00000332' 3030 0A00               +    MOVE.W    (A0,D0.L*2),D0
 297                                                                          ; D0=GET_TCPIXEL(in_ptr, bh_xs+bh_xc, bh_ys+bh_yc)
 298 00000336'                          bhl16_setpix_030_sym:
 299 00000336' 2F0E                         MOVE.L    A6,-(SP)                ; Save bh_xd
 300 00000338' 243A 014C                    MOVE.L    bh_xc(PC),D2            ; D2=bh_xc
 301 0000033C' 263A 014C                    MOVE.L    bh_yc(PC),D3            ; D3=bh_yc
 302 00000340' DDC2                         ADD.L     D2,A6                   ; A6=bh_xd+bh_xc
 303 00000342' 2E3A 012E                    MOVE.L    bh_yd(PC),D7
 304 00000346' DE83                         ADD.L     D3,D7                   ; D7=bh_yd+bh_yc
 305                                        SET_TCPIXEL16 A1,A6,D7,D0,D5      ; SET_TCPIXEL(out_ptr, bh_xd+bh_xc, bh_yd+bh_yc, GET_TCPIXEL(in_ptr, bh_xs+bh_xc, bh_ys+bh_yc))
 144 00000348' 2A34 7C00               +    MOVE.L    (A4,D7.L*4),D5
 145 0000034C' DA8E                    +    ADD.L     A6,D5
 146 0000034E' 3380 5A00               +    MOVE.W    D0,(A1,D5.L*2)
 306  
 307 00000352' 7202                         MOVEQ.L   #2,D1                   ; 3 loops, -1 for DBF
 308 00000354'                          deduc16_030:
 309 00000354' 97C2                         SUB.L     D2,A3                   ; We need now bh_xs(A3) and bh_ys(D4) relative to
 310 00000356' 9883                         SUB.L     D3,D4                   ; Black Hole center to use R90
 311 00000358' 9DC2                         SUB.L     D2,A6                   ; We need now bh_xd(A6) and bh_yd(D7) relative to
 312 0000035A' 9E83                         SUB.L     D3,D7                   ; Black Hole center to use R90
 313  
 314                                        R90       A6,D7,D0                ; Rotate (xd,yd) by PI/4
 153 0000035C' 200E                    +    MOVE.L    A6,D0
 154 0000035E' 4487                    +    NEG.L     D7
 155 00000360' 2C47                    +    MOVE.L    D7,A6
 156 00000362' 2E00                    +    MOVE.L    D0,D7
 315                                        R90       A3,D4,D0                ; Rotate (xs,ys) by PI/4
 153 00000364' 200B                    +    MOVE.L    A3,D0
 154 00000366' 4484                    +    NEG.L     D4
 155 00000368' 2644                    +    MOVE.L    D4,A3
 156 0000036A' 2800                    +    MOVE.L    D0,D4
 316  
 317 0000036C' D7C2                         ADD.L     D2,A3                   ; Now we need coords in image raster
 318 0000036E' D883                         ADD.L     D3,D4
 319 00000370' DDC2                         ADD.L     D2,A6
 320 00000372' DE83                         ADD.L     D3,D7
 321  
 322                                        PIXINIMG  A6,D7,bh_in_w(PC),bh_in_h(PC),dnotinimg16_030 ; Check if pixel in dest is within bounds
 160 00000374' 4A4E                    +    TST.W     A6
 161 00000376' 6D 3A                   +    BLT.S     dnotinimg16_030
 162 00000378' 4A47                    +    TST.W     D7
 163 0000037A' 6D 36                   +    BLT.S     dnotinimg16_030
 164 0000037C' BCFA 0114               +    CMP.W     bh_in_w(PC),A6
 165 00000380' 6C 30                   +    BGE.S     dnotinimg16_030
 166 00000382' BE7A 0110               +    CMP.W     bh_in_h(PC),D7
 167 00000386' 6C 2A                   +    BGE.S     dnotinimg16_030
PASM 68040 Macro Assembler  Version Dec 18 1992  (C) 91 Pure Software  Page  11
Source File: H:\PURE_C\PROJECTS\VISION\LDV\SRC\BHOLE\BHOLE.S

 323 00000388' 70FF                         MOVEQ.L   #-1,D0                  ; Assume out of range
 324                                        PIXINIMG  A3,D4,bh_in_w(PC),bh_in_h(PC),plotdest16_030 ; Check if pixel in src is within bounds
 160 0000038A' 4A4B                    +    TST.W     A3
 161 0000038C' 6D 1A                   +    BLT.S     plotdest16_030
 162 0000038E' 4A44                    +    TST.W     D4
 163 00000390' 6D 16                   +    BLT.S     plotdest16_030
 164 00000392' B6FA 00FE               +    CMP.W     bh_in_w(PC),A3
 165 00000396' 6C 10                   +    BGE.S     plotdest16_030
 166 00000398' B87A 00FA               +    CMP.W     bh_in_h(PC),D4
 167 0000039C' 6C 0A                   +    BGE.S     plotdest16_030
 325                                    	GET_TCPIXEL16  A0,A3,D4,D0        ; A0-->in_ptr, A3=bh_xs+bh_xc, D4=bh_ys+bh_yc
 135 0000039E' 2034 4C00               +    MOVE.L    (A4,D4.L*4),D0
 136 000003A2' D08B                    +    ADD.L     A3,D0
 137 000003A4' 3030 0A00               +    MOVE.W    (A0,D0.L*2),D0
 326                                                                          ; D0=GET_TCPIXEL(in_ptr, bh_xs+bh_xc, bh_ys+bh_yc)
 327 000003A8'                          plotdest16_030:
 328                                        SET_TCPIXEL16 A1,A6,D7,D0,D5      ; SET_TCPIXEL(out_ptr, bh_xd+bh_xc, bh_yd+bh_yc, GET_TCPIXEL(in_ptr, bh_xs+bh_xc, bh_ys+bh_yc))
 144 000003A8' 2A34 7C00               +    MOVE.L    (A4,D7.L*4),D5
 145 000003AC' DA8E                    +    ADD.L     A6,D5
 146 000003AE' 3380 5A00               +    MOVE.W    D0,(A1,D5.L*2)
 329 000003B2'                          dnotinimg16_030:
 330 000003B2' 51C9 FFA0                     DBF D1,deduc16_030
 331  
 332 000003B6' 2C5F                         MOVE.L    (SP)+,A6                ; Restore bh_xd
 333 000003B8' 528E                         ADD.L     #1,A6                   ; bh_xd++
 334 000003BA' BCFA 00DE                    CMP.W     last_xd(PC),A6
 335 000003BE' 6F00 FEFC                    BLE       bhl16_l030_sym
 336  
 337 000003C2' 4CDF 7CFF                    MOVEM.L   (SP)+,D0-D7/A2-A6       ; Restore context
 338 000003C6' 4E75                         RTS
 339  
 340                                    ; 68030 routine for bitplances images, converted to indexes
 341                                    ; BHLInd_68030(short use_sym, void* in, void* out)
 342                                    ;                    D0,            A0        A1
 343 000003C8'                          BHLInd_68030:
 344 000003C8' 48E7 FF3E                    MOVEM.L   D0-D7/A2-A6,-(SP)       ; Save context
 345  
 346                                        INIT_BHL
  96 000003CC' 45F9 00000000*          +    LEA.L     pre_cosin,A2
  97 000003D2' 2879 00000000*          +	MOVE.L    pre_loffset,A4          ; A4-->preoffset
  98 000003D8' 2A7A 009C               +	MOVE.L    bh_rd2(PC),A5           ; A5=bh_rd2
  99 000003DC' 2C7A 0090               +	MOVE.L    bh_xd(PC),A6            ; A6=bh_xd
 100 000003E0' 3E3A 00AC               +	MOVE.W    bh_out_w(PC),D7
 101 000003E4' 5347                    +	SUBQ.W    #1,D7                   ; For DBF
 347 000003E6'                          bhlind_l030:
 348                                        BH_COMPUTE_CPU bhlind_tpir_030    ; -->D6=0:pixel in range
  30 000003E6' 200E                    +    MOVE.L    A6,D0                ; Remember A6=bh_xd
  31 000003E8' D080                    +    ADD.L     D0,D0
  32 000003EA' 5280                    +    ADDQ.L    #1,D0
  33 000003EC' 220D                    +    MOVE.L    A5,D1                ; Remember A5=bh_rd2
  34 000003EE' D280                    +    ADD.L     D0,D1                ; bh_rd2(D1)=1+2*bh_xd(D0)
  35 000003F0' 243A 0090               +    MOVE.L    bh_ref(PC),D2
  36 000003F4' 2A41                    +    MOVE.L    D1,A5                ; Save bh_rd2, free D1
  37 000003F6' 5281                    +    ADDQ.L    #1,D1                ; We need bh_rd2+1 for divide
  41 000003F8' 4C41 2002               +    DIVU.L    D1,D2                ; alpha(D2)=bh_ref/(1+bh_rd2)
  42 000003FC' 0282 0000 3FFF          +    ANDI.L    #ITRIGO_ANGLE_MAX,D2 ; alpha &= ITRIGO_ANGLE_MAX
PASM 68040 Macro Assembler  Version Dec 18 1992  (C) 91 Pure Software  Page  12
Source File: H:\PURE_C\PROJECTS\VISION\LDV\SRC\BHOLE\BHOLE.S

  44 00000402' E78A                    +    LSL.L     #3,D2                ; D2=offset for pre_cosin array
  45 00000404' 200E                    +    MOVE.L    A6,D0                ; D0=bh_xd   
  46 00000406' 223A 006A               +    MOVE.L    bh_yd(PC),D1         ; D1=bh_yd   
  47 0000040A' 2632 2804               +    MOVE.L    4(A2,D2.L),D3        ; A2->pre_cosin, D3.L=SIN(alpha)
  48 0000040E' 2432 2800               +    MOVE.L    (A2,D2.L),D2         ; A2->pre_cosin, D2.L=COS(alpha)
  50 00000412' 7C10                    +    MOVEQ.L   #16,D6               ; Prepare shifts/assume not in range
  52 00000414' 2800                    +    MOVE.L    D0,D4
  53 00000416' 4C02 4800               +    MULS.L    D2,D4                ; D4=bh_xd * pre_cos[alpha]
  54 0000041A' 2A01                    +    MOVE.L    D1,D5
  55 0000041C' 4C03 5800               +    MULS.L    D3,D5                ; D5=bh_yd * pre_sin[alpha]
  56 00000420' 9885                    +    SUB.L     D5,D4                ; D4=bh_xd * pre_cos[alpha] - bh_yd * pre_sin[alpha]
  57 00000422' ECA4                    +    ASR.L     D6,D4
  58 00000424' D8BA 0060               +    ADD.L     bh_xc(PC),D4         ; D6=16, assume pixel not in range
  59 00000428' 6D 26                   +    BLT.S     bhlind_tpir_030        ; xs < 0: not in range
  60 0000042A' B87A 0066               +    CMP.W     bh_in_w(PC),D4
  61 0000042E' 6C 20                   +    BGE.S     bhlind_tpir_030        ; xs >= bh_in_w: not in range
  62 00000430' 2644                    +    MOVE.L    D4,A3                ; A3=bh_xs= (D4 >> 16)
  64 00000432' 2800                    +    MOVE.L    D0,D4
  65 00000434' 4C03 4800               +    MULS.L    D3,D4                ; D4=bh_xd * pre_sin[alpha]
  66 00000438' 2A01                    +    MOVE.L    D1,D5
  67 0000043A' 4C02 5800               +    MULS.L    D2,D5                ; D5=bh_yd * pre_cos[alpha]
  68 0000043E' D885                    +    ADD.L     D5,D4                ; D4=bh_xd * pre_sin[alpha] + bh_yd * pre_cos[alpha]
  69 00000440' ECA4                    +    ASR.L     D6,D4
  70 00000442' D8BA 0046               +    ADD.L     bh_yc(PC),D4         ; D4.L=bh_ys
  71 00000446' 6D 08                   +    BLT.S     bhlind_tpir_030        ; ys < 0: not in range
  72 00000448' B87A 004A               +    CMP.W     bh_in_h(PC),D4
  73 0000044C' 6C 02                   +    BGE.S     bhlind_tpir_030        ; ys >= bh_in_h: not in range
  74 0000044E' 7C00                    +    MOVEQ.L   #0,D6                ; pixel in range
 349 00000450'                          bhlind_tpir_030:
 350 00000450' 70FF                         MOVEQ.L   #-1,D0                  ; Assume out of range
 351 00000452' 4A46                         TST.W     D6
 352 00000454' 66 0A                    	BNE.S     bhlind_setpix_030
 353 00000456' 2034 4C00                	MOVE.L    (A4,D4.L*4),D0          ; D4=bh_ys, D0=pre_loffset[bh_ys]
 354 0000045A' D08B                     	ADD.L     A3,D0                   ; D0=pre_loffset[bh_ys] + bh_xs(A3)
 355 0000045C' 1030 0800                	MOVE.B    (A0,D0.L),D0            ; D0=in_ptr[pre_loffset[bh_ys] + bh_xs]
 356 00000460'                          bhlind_setpix_030:
 357 00000460' 12C0                         MOVE.B    D0,(A1)+
 358 00000462' 528E                         ADD.L     #1,A6                   ; bh_xd++
 359 00000464' 51CF FF80                	DBF       D7,bhlind_l030
 360  
 361 00000468' 4CDF 7CFF                    MOVEM.L   (SP)+,D0-D7/A2-A6       ; Restore context
 362 0000046C' 4E75                         RTS
 363  
 364 0000046E'                          .EVEN
 365 0000046E'                          bh_xd:
 366 0000046E' 0000 0000                    DC.L      0 
 367 00000472'                          bh_yd:
 368 00000472' 0000 0000                    DC.L      0 
 369 00000476'                          bh_rd2:
 370 00000476' 0000 0000                    DC.L      0 
 371 0000047A'                          bh_xs:
 372 0000047A' 0000 0000                    DC.L      0 
 373 0000047E'                          bh_ys:
 374 0000047E' 0000 0000                    DC.L      0 
 375 00000482'                          bh_ref:
 376 00000482' 0000 0000                    DC.L      0 
PASM 68040 Macro Assembler  Version Dec 18 1992  (C) 91 Pure Software  Page  13
Source File: H:\PURE_C\PROJECTS\VISION\LDV\SRC\BHOLE\BHOLE.S

 377 00000486'                          bh_xc:
 378 00000486' 0000 0000                    DC.L      0 
 379 0000048A'                          bh_yc:
 380 0000048A' 0000 0000                    DC.L      0 
 381 0000048E'                          bh_out_w:
 382 0000048E' 0000                         DC.W      0 
 383 00000490'                          bh_out_h:
 384 00000490' 0000                         DC.W      0 
 385 00000492'                          bh_in_w:
 386 00000492' 0000                         DC.W      0 
 387 00000494'                          bh_in_h:
 388 00000494' 0000                         DC.W      0 
 389 00000496'                          bh_out_x:
 390 00000496' 0000                         DC.W      0 
 391 00000498'                          bh_out_y:
 392 00000498' 0000                         DC.W      0
 393 0000049A'                          last_xd:
 394 0000049A' 0000                         DC.W      0
 395  
 396                                    ; 68030/FPU routine for True Color 32bit
 397                                    ; BHL32_F68030(short use_sym, void* in, void* out)
 398                                    ;                   D0,             A0        A1
 399 0000049C'                          BHL32_F68030:
 400 0000049C' 48E7 FF3E                    MOVEM.L   D0-D7/A2-A6,-(SP)       ; Save context
 401 000004A0' F227 6800                    FMOVE.X   FP0,-(SP)
 402  
 403                                        INIT_BHL
  96 000004A4' 45F9 00000000*          +    LEA.L     pre_cosin,A2
  97 000004AA' 2879 00000000*          +	MOVE.L    pre_loffset,A4          ; A4-->preoffset
  98 000004B0' 2A7A FFC4               +	MOVE.L    bh_rd2(PC),A5           ; A5=bh_rd2
  99 000004B4' 2C7A FFB8               +	MOVE.L    bh_xd(PC),A6            ; A6=bh_xd
 100 000004B8' 3E3A FFD4               +	MOVE.W    bh_out_w(PC),D7
 101 000004BC' 5347                    +	SUBQ.W    #1,D7                   ; For DBF
 404 000004BE'                          bhl32_lf030:
 405                                        BH_COMPUTE_FPU bhl32_tpir_f030    ; -->D6=0:pixel in range
  30 000004BE' 200E                    +    MOVE.L    A6,D0                ; Remember A6=bh_xd
  31 000004C0' D080                    +    ADD.L     D0,D0
  32 000004C2' 5280                    +    ADDQ.L    #1,D0
  33 000004C4' 220D                    +    MOVE.L    A5,D1                ; Remember A5=bh_rd2
  34 000004C6' D280                    +    ADD.L     D0,D1                ; bh_rd2(D1)=1+2*bh_xd(D0)
  35 000004C8' 243A FFB8               +    MOVE.L    bh_ref(PC),D2
  36 000004CC' 2A41                    +    MOVE.L    D1,A5                ; Save bh_rd2, free D1
  37 000004CE' 5281                    +    ADDQ.L    #1,D1                ; We need bh_rd2+1 for divide
  88 000004D0' F201 4000               +    FMOVE.L     D1,FP0
  89 000004D4' F200 0004               +    FSQRT       FP0
  90 000004D8' F201 6000               +    FMOVE.L     FP0,D1
  41 000004DC' 4C41 2002               +    DIVU.L    D1,D2                ; alpha(D2)=bh_ref/(1+bh_rd2)
  42 000004E0' 0282 0000 3FFF          +    ANDI.L    #ITRIGO_ANGLE_MAX,D2 ; alpha &= ITRIGO_ANGLE_MAX
  44 000004E6' E78A                    +    LSL.L     #3,D2                ; D2=offset for pre_cosin array
  45 000004E8' 200E                    +    MOVE.L    A6,D0                ; D0=bh_xd   
  46 000004EA' 223A FF86               +    MOVE.L    bh_yd(PC),D1         ; D1=bh_yd   
  47 000004EE' 2632 2804               +    MOVE.L    4(A2,D2.L),D3        ; A2->pre_cosin, D3.L=SIN(alpha)
  48 000004F2' 2432 2800               +    MOVE.L    (A2,D2.L),D2         ; A2->pre_cosin, D2.L=COS(alpha)
  50 000004F6' 7C10                    +    MOVEQ.L   #16,D6               ; Prepare shifts/assume not in range
  52 000004F8' 2800                    +    MOVE.L    D0,D4
  53 000004FA' 4C02 4800               +    MULS.L    D2,D4                ; D4=bh_xd * pre_cos[alpha]
PASM 68040 Macro Assembler  Version Dec 18 1992  (C) 91 Pure Software  Page  14
Source File: H:\PURE_C\PROJECTS\VISION\LDV\SRC\BHOLE\BHOLE.S

  54 000004FE' 2A01                    +    MOVE.L    D1,D5
  55 00000500' 4C03 5800               +    MULS.L    D3,D5                ; D5=bh_yd * pre_sin[alpha]
  56 00000504' 9885                    +    SUB.L     D5,D4                ; D4=bh_xd * pre_cos[alpha] - bh_yd * pre_sin[alpha]
  57 00000506' ECA4                    +    ASR.L     D6,D4
  58 00000508' D8BA FF7C               +    ADD.L     bh_xc(PC),D4         ; D6=16, assume pixel not in range
  59 0000050C' 6D 26                   +    BLT.S     bhl32_tpir_f030        ; xs < 0: not in range
  60 0000050E' B87A FF82               +    CMP.W     bh_in_w(PC),D4
  61 00000512' 6C 20                   +    BGE.S     bhl32_tpir_f030        ; xs >= bh_in_w: not in range
  62 00000514' 2644                    +    MOVE.L    D4,A3                ; A3=bh_xs= (D4 >> 16)
  64 00000516' 2800                    +    MOVE.L    D0,D4
  65 00000518' 4C03 4800               +    MULS.L    D3,D4                ; D4=bh_xd * pre_sin[alpha]
  66 0000051C' 2A01                    +    MOVE.L    D1,D5
  67 0000051E' 4C02 5800               +    MULS.L    D2,D5                ; D5=bh_yd * pre_cos[alpha]
  68 00000522' D885                    +    ADD.L     D5,D4                ; D4=bh_xd * pre_sin[alpha] + bh_yd * pre_cos[alpha]
  69 00000524' ECA4                    +    ASR.L     D6,D4
  70 00000526' D8BA FF62               +    ADD.L     bh_yc(PC),D4         ; D4.L=bh_ys
  71 0000052A' 6D 08                   +    BLT.S     bhl32_tpir_f030        ; ys < 0: not in range
  72 0000052C' B87A FF66               +    CMP.W     bh_in_h(PC),D4
  73 00000530' 6C 02                   +    BGE.S     bhl32_tpir_f030        ; ys >= bh_in_h: not in range
  74 00000532' 7C00                    +    MOVEQ.L   #0,D6                ; pixel in range
 406 00000534'                          bhl32_tpir_f030:
 407 00000534' 70FF                         MOVEQ.L   #-1,D0                  ; Assume out of range
 408 00000536' 4A46                         TST.W     D6
 409 00000538' 66 0A                    	BNE.S     bhl32_setpix_f030
 410 0000053A' 2034 4C00                	MOVE.L    (A4,D4.L*4),D0          ; D4=bh_ys, D0=pre_loffset[bh_ys]
 411 0000053E' D08B                     	ADD.L     A3,D0                   ; D0=pre_loffset[bh_ys] + bh_xs(A3)
 412 00000540' 2030 0C00                	MOVE.L    (A0,D0.L*4),D0          ; D0=in_ptr[pre_loffset[bh_ys] + bh_xs]
 413 00000544'                          bhl32_setpix_f030:
 414 00000544' 22C0                         MOVE.L    D0,(A1)+
 415 00000546' 528E                         ADD.L     #1,A6                   ; bh_xd++
 416 00000548' 51CF FF74                    DBF       D7,bhl32_lf030
 417  
 418 0000054C' F21F 4800                    FMOVE.X   (SP)+,FP0
 419 00000550' 4CDF 7CFF                    MOVEM.L   (SP)+,D0-D7/A2-A6       ; Restore context
 420 00000554' 4E75                         RTS
 421  
 422                                    ; 68030/FPU routine for True Color 16bit
 423                                    ; BHL16_F68030(short use_sym, void* in, void* out)
 424                                    ;                    D0,             A0        A1
 425 00000556'                          BHL16_F68030:
 426 00000556' 48E7 FF3E                    MOVEM.L   D0-D7/A2-A6,-(SP)       ; Save context
 427 0000055A' F227 6800                    FMOVE.X   FP0,-(SP)
 428  
 429                                        INIT_BHL
  96 0000055E' 45F9 00000000*          +    LEA.L     pre_cosin,A2
  97 00000564' 2879 00000000*          +	MOVE.L    pre_loffset,A4          ; A4-->preoffset
  98 0000056A' 2A7A FF0A               +	MOVE.L    bh_rd2(PC),A5           ; A5=bh_rd2
  99 0000056E' 2C7A FEFE               +	MOVE.L    bh_xd(PC),A6            ; A6=bh_xd
 100 00000572' 3E3A FF1A               +	MOVE.W    bh_out_w(PC),D7
 101 00000576' 5347                    +	SUBQ.W    #1,D7                   ; For DBF
 430 00000578'                          bhl16_lf030:
 431                                        BH_COMPUTE_FPU bhl16_tpir_f030    ; -->D6=0:pixel in range
  30 00000578' 200E                    +    MOVE.L    A6,D0                ; Remember A6=bh_xd
  31 0000057A' D080                    +    ADD.L     D0,D0
  32 0000057C' 5280                    +    ADDQ.L    #1,D0
  33 0000057E' 220D                    +    MOVE.L    A5,D1                ; Remember A5=bh_rd2
PASM 68040 Macro Assembler  Version Dec 18 1992  (C) 91 Pure Software  Page  15
Source File: H:\PURE_C\PROJECTS\VISION\LDV\SRC\BHOLE\BHOLE.S

  34 00000580' D280                    +    ADD.L     D0,D1                ; bh_rd2(D1)=1+2*bh_xd(D0)
  35 00000582' 243A FEFE               +    MOVE.L    bh_ref(PC),D2
  36 00000586' 2A41                    +    MOVE.L    D1,A5                ; Save bh_rd2, free D1
  37 00000588' 5281                    +    ADDQ.L    #1,D1                ; We need bh_rd2+1 for divide
  88 0000058A' F201 4000               +    FMOVE.L     D1,FP0
  89 0000058E' F200 0004               +    FSQRT       FP0
  90 00000592' F201 6000               +    FMOVE.L     FP0,D1
  41 00000596' 4C41 2002               +    DIVU.L    D1,D2                ; alpha(D2)=bh_ref/(1+bh_rd2)
  42 0000059A' 0282 0000 3FFF          +    ANDI.L    #ITRIGO_ANGLE_MAX,D2 ; alpha &= ITRIGO_ANGLE_MAX
  44 000005A0' E78A                    +    LSL.L     #3,D2                ; D2=offset for pre_cosin array
  45 000005A2' 200E                    +    MOVE.L    A6,D0                ; D0=bh_xd   
  46 000005A4' 223A FECC               +    MOVE.L    bh_yd(PC),D1         ; D1=bh_yd   
  47 000005A8' 2632 2804               +    MOVE.L    4(A2,D2.L),D3        ; A2->pre_cosin, D3.L=SIN(alpha)
  48 000005AC' 2432 2800               +    MOVE.L    (A2,D2.L),D2         ; A2->pre_cosin, D2.L=COS(alpha)
  50 000005B0' 7C10                    +    MOVEQ.L   #16,D6               ; Prepare shifts/assume not in range
  52 000005B2' 2800                    +    MOVE.L    D0,D4
  53 000005B4' 4C02 4800               +    MULS.L    D2,D4                ; D4=bh_xd * pre_cos[alpha]
  54 000005B8' 2A01                    +    MOVE.L    D1,D5
  55 000005BA' 4C03 5800               +    MULS.L    D3,D5                ; D5=bh_yd * pre_sin[alpha]
  56 000005BE' 9885                    +    SUB.L     D5,D4                ; D4=bh_xd * pre_cos[alpha] - bh_yd * pre_sin[alpha]
  57 000005C0' ECA4                    +    ASR.L     D6,D4
  58 000005C2' D8BA FEC2               +    ADD.L     bh_xc(PC),D4         ; D6=16, assume pixel not in range
  59 000005C6' 6D 26                   +    BLT.S     bhl16_tpir_f030        ; xs < 0: not in range
  60 000005C8' B87A FEC8               +    CMP.W     bh_in_w(PC),D4
  61 000005CC' 6C 20                   +    BGE.S     bhl16_tpir_f030        ; xs >= bh_in_w: not in range
  62 000005CE' 2644                    +    MOVE.L    D4,A3                ; A3=bh_xs= (D4 >> 16)
  64 000005D0' 2800                    +    MOVE.L    D0,D4
  65 000005D2' 4C03 4800               +    MULS.L    D3,D4                ; D4=bh_xd * pre_sin[alpha]
  66 000005D6' 2A01                    +    MOVE.L    D1,D5
  67 000005D8' 4C02 5800               +    MULS.L    D2,D5                ; D5=bh_yd * pre_cos[alpha]
  68 000005DC' D885                    +    ADD.L     D5,D4                ; D4=bh_xd * pre_sin[alpha] + bh_yd * pre_cos[alpha]
  69 000005DE' ECA4                    +    ASR.L     D6,D4
  70 000005E0' D8BA FEA8               +    ADD.L     bh_yc(PC),D4         ; D4.L=bh_ys
  71 000005E4' 6D 08                   +    BLT.S     bhl16_tpir_f030        ; ys < 0: not in range
  72 000005E6' B87A FEAC               +    CMP.W     bh_in_h(PC),D4
  73 000005EA' 6C 02                   +    BGE.S     bhl16_tpir_f030        ; ys >= bh_in_h: not in range
  74 000005EC' 7C00                    +    MOVEQ.L   #0,D6                ; pixel in range
 432 000005EE'                          bhl16_tpir_f030:
 433 000005EE' 70FF                         MOVEQ.L   #-1,D0                  ; Assume out of range
 434 000005F0' 4A46                         TST.W     D6
 435 000005F2' 66 0A                    	BNE.S     bhl16_setpix_f030
 436 000005F4' 2034 4C00                	MOVE.L    (A4,D4.L*4),D0          ; D4=bh_ys, D0=pre_loffset[bh_ys]
 437 000005F8' D08B                     	ADD.L     A3,D0                   ; D0=pre_loffset[bh_ys] + bh_xs(A3)
 438 000005FA' 3030 0A00                	MOVE.W    (A0,D0.L*2),D0          ; D0=in_ptr[pre_loffset[bh_ys] + bh_xs]
 439 000005FE'                          bhl16_setpix_f030:
 440 000005FE' 32C0                         MOVE.W    D0,(A1)+
 441 00000600' 528E                         ADD.L     #1,A6                   ; bh_xd++
 442 00000602' 51CF FF74                    DBF       D7,bhl16_lf030
 443  
 444 00000606' F21F 4800                    FMOVE.X   (SP)+,FP0
 445 0000060A' 4CDF 7CFF                    MOVEM.L   (SP)+,D0-D7/A2-A6       ; Restore context
 446 0000060E' 4E75                         RTS
 447  
 448                                    ; 68030/FPU routine for bitplances images, converted to indexes
 449                                    ; BHLInd_F68030(short use_sym, void* in, void* out)
 450                                    ;                   D0,              A0        A1
PASM 68040 Macro Assembler  Version Dec 18 1992  (C) 91 Pure Software  Page  16
Source File: H:\PURE_C\PROJECTS\VISION\LDV\SRC\BHOLE\BHOLE.S

 451 00000610'                          BHLInd_F68030:
 452 00000610' 48E7 FF3E                    MOVEM.L   D0-D7/A2-A6,-(SP)       ; Save context
 453 00000614' F227 6800                    FMOVE.X   FP0,-(SP)
 454  
 455                                        INIT_BHL
  96 00000618' 45F9 00000000*          +    LEA.L     pre_cosin,A2
  97 0000061E' 2879 00000000*          +	MOVE.L    pre_loffset,A4          ; A4-->preoffset
  98 00000624' 2A7A FE50               +	MOVE.L    bh_rd2(PC),A5           ; A5=bh_rd2
  99 00000628' 2C7A FE44               +	MOVE.L    bh_xd(PC),A6            ; A6=bh_xd
 100 0000062C' 3E3A FE60               +	MOVE.W    bh_out_w(PC),D7
 101 00000630' 5347                    +	SUBQ.W    #1,D7                   ; For DBF
 456 00000632'                          bhlInd_lf030:
 457                                        BH_COMPUTE_FPU bhlInd_tpir_f030   ; -->D6=0:pixel in range
  30 00000632' 200E                    +    MOVE.L    A6,D0                ; Remember A6=bh_xd
  31 00000634' D080                    +    ADD.L     D0,D0
  32 00000636' 5280                    +    ADDQ.L    #1,D0
  33 00000638' 220D                    +    MOVE.L    A5,D1                ; Remember A5=bh_rd2
  34 0000063A' D280                    +    ADD.L     D0,D1                ; bh_rd2(D1)=1+2*bh_xd(D0)
  35 0000063C' 243A FE44               +    MOVE.L    bh_ref(PC),D2
  36 00000640' 2A41                    +    MOVE.L    D1,A5                ; Save bh_rd2, free D1
  37 00000642' 5281                    +    ADDQ.L    #1,D1                ; We need bh_rd2+1 for divide
  88 00000644' F201 4000               +    FMOVE.L     D1,FP0
  89 00000648' F200 0004               +    FSQRT       FP0
  90 0000064C' F201 6000               +    FMOVE.L     FP0,D1
  41 00000650' 4C41 2002               +    DIVU.L    D1,D2                ; alpha(D2)=bh_ref/(1+bh_rd2)
  42 00000654' 0282 0000 3FFF          +    ANDI.L    #ITRIGO_ANGLE_MAX,D2 ; alpha &= ITRIGO_ANGLE_MAX
  44 0000065A' E78A                    +    LSL.L     #3,D2                ; D2=offset for pre_cosin array
  45 0000065C' 200E                    +    MOVE.L    A6,D0                ; D0=bh_xd   
  46 0000065E' 223A FE12               +    MOVE.L    bh_yd(PC),D1         ; D1=bh_yd   
  47 00000662' 2632 2804               +    MOVE.L    4(A2,D2.L),D3        ; A2->pre_cosin, D3.L=SIN(alpha)
  48 00000666' 2432 2800               +    MOVE.L    (A2,D2.L),D2         ; A2->pre_cosin, D2.L=COS(alpha)
  50 0000066A' 7C10                    +    MOVEQ.L   #16,D6               ; Prepare shifts/assume not in range
  52 0000066C' 2800                    +    MOVE.L    D0,D4
  53 0000066E' 4C02 4800               +    MULS.L    D2,D4                ; D4=bh_xd * pre_cos[alpha]
  54 00000672' 2A01                    +    MOVE.L    D1,D5
  55 00000674' 4C03 5800               +    MULS.L    D3,D5                ; D5=bh_yd * pre_sin[alpha]
  56 00000678' 9885                    +    SUB.L     D5,D4                ; D4=bh_xd * pre_cos[alpha] - bh_yd * pre_sin[alpha]
  57 0000067A' ECA4                    +    ASR.L     D6,D4
  58 0000067C' D8BA FE08               +    ADD.L     bh_xc(PC),D4         ; D6=16, assume pixel not in range
  59 00000680' 6D 26                   +    BLT.S     bhlInd_tpir_f030        ; xs < 0: not in range
  60 00000682' B87A FE0E               +    CMP.W     bh_in_w(PC),D4
  61 00000686' 6C 20                   +    BGE.S     bhlInd_tpir_f030        ; xs >= bh_in_w: not in range
  62 00000688' 2644                    +    MOVE.L    D4,A3                ; A3=bh_xs= (D4 >> 16)
  64 0000068A' 2800                    +    MOVE.L    D0,D4
  65 0000068C' 4C03 4800               +    MULS.L    D3,D4                ; D4=bh_xd * pre_sin[alpha]
  66 00000690' 2A01                    +    MOVE.L    D1,D5
  67 00000692' 4C02 5800               +    MULS.L    D2,D5                ; D5=bh_yd * pre_cos[alpha]
  68 00000696' D885                    +    ADD.L     D5,D4                ; D4=bh_xd * pre_sin[alpha] + bh_yd * pre_cos[alpha]
  69 00000698' ECA4                    +    ASR.L     D6,D4
  70 0000069A' D8BA FDEE               +    ADD.L     bh_yc(PC),D4         ; D4.L=bh_ys
  71 0000069E' 6D 08                   +    BLT.S     bhlInd_tpir_f030        ; ys < 0: not in range
  72 000006A0' B87A FDF2               +    CMP.W     bh_in_h(PC),D4
  73 000006A4' 6C 02                   +    BGE.S     bhlInd_tpir_f030        ; ys >= bh_in_h: not in range
  74 000006A6' 7C00                    +    MOVEQ.L   #0,D6                ; pixel in range
 458 000006A8'                          bhlInd_tpir_f030:
 459 000006A8' 70FF                         MOVEQ.L   #-1,D0                  ; Assume out of range
PASM 68040 Macro Assembler  Version Dec 18 1992  (C) 91 Pure Software  Page  17
Source File: H:\PURE_C\PROJECTS\VISION\LDV\SRC\BHOLE\BHOLE.S

 460 000006AA' 4A46                         TST.W     D6
 461 000006AC' 66 0A                    	BNE.S     bhlInd_setpix_f030
 462 000006AE' 2034 4C00                	MOVE.L    (A4,D4.L*4),D0          ; D4=bh_ys, D0=pre_loffset[bh_ys]
 463 000006B2' D08B                     	ADD.L     A3,D0                   ; D0=pre_loffset[bh_ys] + bh_xs
 464 000006B4' 1030 0800                	MOVE.B    (A0,D0.L),D0            ; D0=in_ptr[pre_loffset[bh_ys] + bh_xs]
 465 000006B8'                          bhlInd_setpix_f030:
 466 000006B8' 12C0                         MOVE.B    D0,(A1)+
 467 000006BA' 528E                         ADD.L     #1,A6                   ; bh_xd++
 468 000006BC' 51CF FF74                    DBF       D7,bhlInd_lf030
 469  
 470 000006C0' F21F 4800                    FMOVE.X   (SP)+,FP0
 471 000006C4' 4CDF 7CFF                    MOVEM.L   (SP)+,D0-D7/A2-A6       ; Restore context
 472 000006C8' 4E75                         RTS
 473  
 474                                    ; Pre-calculation of cosinus/sinus table using FPU
 475                                    ; void lcosin_fpu(long i, long* pcs)
 476                                    ;                      D0       A0
 477                                    ;  double angle = i*ANGLE_ADD ;
 478                                    ;  pcs[0] = 65536.0 * cos( angle ) ;
 479                                    ;  pcs[1] = 65536.0 * sin( angle ) ;
 480 000006CA'                          lcosin_fpu:
 481 000006CA' F227 E007                  FMOVEM.X   FP0-FP2,-(SP)
 482  
 483 000006CE' F200 5000                  FMOVE      D0,FP0
 484                                    ; 3.8349519697141030742952189737299e-4=M_PI/2.0/(double)QUARTER
 485                                    ; For some reason, I did not manage to use EQU with floating point constants
 486 000006D2' F23C 4823 3FF3 0000 
     000006DA' C90F DAA2 2168 C234        FMUL.X     #3.8349519697141030742952189737299e-4,FP0
 487 000006E2' F200 0131                  FSINCOS.X  FP0,FP1:FP2
 488 000006E6' F23C 48A3 400F 0000 
     000006EE' 8000 0000 0000 0000        FMUL.X     #65536.0,FP1
 489 000006F6' F23C 4923 400F 0000 
     000006FE' 8000 0000 0000 0000        FMUL.X     #65536.0,FP2
 490 00000706' F218 6080                  FMOVE.L    FP1,(A0)+
 491 0000070A' F210 6100                  FMOVE.L    FP2,(A0)
 492  
 493 0000070E' F21F D0E0                  FMOVEM.X   (SP)+,FP0-FP2
 494 00000712' 4E75                       RTS
PASM 68040 Macro Assembler  Version Dec 18 1992  (C) 91 Pure Software  Page  18
Source File: H:\PURE_C\PROJECTS\VISION\LDV\SRC\BHOLE\BHOLE.S



Symbols:
========

Name                  Value      Scope      Relocation base

BHL16_68030           000001E4   Global     TEXT
BHL16_68030_sym       0000029A   File       TEXT
BHL16_F68030          00000556   Global     TEXT
BHL32_68030           00000000   Global     TEXT
BHL32_68030_sym       000000B6   File       TEXT
BHL32_F68030          0000049C   Global     TEXT
BHLInd_68030          000003C8   Global     TEXT
BHLInd_F68030         00000610   Global     TEXT
ITRIGO_ANGLE_MAX      00003FFF   File       EQUATE
ITRIGO_ARRAY_SIZE     00004000   File       EQUATE
QUARTER               00001000   File       EQUATE
bh_in_h               00000494   Global     TEXT
bh_in_w               00000492   Global     TEXT
bh_out_h              00000490   Global     TEXT
bh_out_w              0000048E   Global     TEXT
bh_out_x              00000496   Global     TEXT
bh_out_y              00000498   Global     TEXT
bh_rd2                00000476   Global     TEXT
bh_ref                00000482   Global     TEXT
bh_xc                 00000486   Global     TEXT
bh_xd                 0000046E   Global     TEXT
bh_xs                 0000047A   Global     TEXT
bh_yc                 0000048A   Global     TEXT
bh_yd                 00000472   Global     TEXT
bh_ys                 0000047E   Global     TEXT
bhl16_l030            00000212   File       TEXT
bhl16_l030_sym        000002BC   File       TEXT
bhl16_lf030           00000578   File       TEXT
bhl16_setpix_030      0000028C   File       TEXT
bhl16_setpix_030_sym  00000336   File       TEXT
bhl16_setpix_f030     000005FE   File       TEXT
bhl16_tpir_030        0000027C   File       TEXT
bhl16_tpir_030_sym    00000326   File       TEXT
bhl16_tpir_f030       000005EE   File       TEXT
bhl32_l030            0000002E   File       TEXT
bhl32_l030_sym        000000D8   File       TEXT
bhl32_lf030           000004BE   File       TEXT
bhl32_setpix_030      000000A8   File       TEXT
bhl32_setpix_030_sym  00000152   File       TEXT
bhl32_setpix_f030     00000544   File       TEXT
bhl32_tpir_030        00000098   File       TEXT
bhl32_tpir_030_sym    00000142   File       TEXT
bhl32_tpir_f030       00000534   File       TEXT
bhlInd_lf030          00000632   File       TEXT
bhlInd_setpix_f030    000006B8   File       TEXT
bhlInd_tpir_f030      000006A8   File       TEXT
bhlind_l030           000003E6   File       TEXT
bhlind_setpix_030     00000460   File       TEXT
bhlind_tpir_030       00000450   File       TEXT
deduc16_030           00000354   File       TEXT
deduc32_030           00000170   File       TEXT
dnotinimg16_030       000003B2   File       TEXT
dnotinimg32_030       000001CE   File       TEXT
last_xd               0000049A   File       TEXT
lcosin_fpu            000006CA   Global     TEXT
plotdest16_030        000003A8   File       TEXT
plotdest32_030        000001C4   File       TEXT
pre_cosin             ********   External   
pre_loffset           ********   External   
