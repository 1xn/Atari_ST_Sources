ı‚DISK CATALOGUE SYSTEM‚ı


‚Contents‚

	Section  A - Program Overview

	Section  B - Hardware Requirements

	Section  C - Technical Overview

	Section  D - User Guide

	Section  E - Technical Guide

	Appendix A - Acknowledgements

	Appendix B - Index
























(c) L.J. Russell, 1993






ı‚DISK CATALOGUE SYSTEM‚ı


‚Section A.‚

	A.1 - A discussion of the purpose of this system.

	A.2 - A discussion of the choice of language used for this ä              system.

	A.3 - A discussion of the limitations of this system.






































ı‚DISK CATALOGUE SYSTEM‚ı


‚Section A.1. -  The Purpose Of This System.‚

The 'Disk Catalogue System' was written in order to allow the user to äorganise his floppy disks and keep track of the software stored on äthem.

With the large amount of disks that are 'given' away each month by theäcomputer magazines it quickly becomes difficult to locate a particularäprogram efficiently. Using this system êmeans êthat êthe user must get ähis collection into êa êlogical êorder êand êenables êfast location of äsoftware.

The system operates as follows,

	A) Each disk must be assigned a unique numerical sequence ä           number,

	B) Each program stored in the system has a numeric 'Subject ä           Code' assigned to it by the user. This allows the user to ä           query the database by topic as well as by specific program
           details,

	C) For ease of use, the user interacts with the system via GEM ä           forms,

	D) For speed, the catalogue is held and processed in memory,

	E) Extensive error trapping should prevent most serious ä           crashes and limited on-line help is provided in the title ä           line of each window.

Rather than being implemented as a utility built around an existing ädatabase package this system hasêbeen customêwritten so as to offer äthe following advantages;

	A) All entry fields, headings and prompts have precise ä           relevance to the task in hand,

	B) All output êdisplays êare êprecise êand êoffer êdata êin an ä           intelligible fashion,

	C) Speed,

	D) Ease of use.


ı‚DISK CATALOGUE SYSTEM‚ı


‚Section A.2. - The Choice Of Language Used For This System.‚

This system has been written entirely in C using the HiSoft Lattice C äproduct. C was chosen for the following reasons,

	1. Its modularity. C's absolute requirement for the programmer ä           to work in an orderly fashion (by insisting on the use of ä           functions), has enabled me to produce good quality, well ä           ordered code.

	2. ANSII standard conformity. This has allowed me to produce ä           'robust' code which will hopefully give the user a very ä           stable environment to work in.

	3. Speed. Because this isêan interactiveêsystem, I did not ä           want to have theêuser waitingêfor itêto process data. ä           Therefore, a compiled language was preferable to an 
           interpreted one.

	4. To enable a novice user toêmake use of the system, it had ä           to be executable from the desktop (ie TOS, TTP or PRG).

	5. The GEM interface. As GEM provides a very consistent user
           interface it was my first choice. êThe HiSoft product allowed me
 	   to make full use of GEM's capabilities.

	6. Maintenance and enhancements. Because of the modularity ä           noted in '1' above, C provides as easy upgrade path for ä           this system.

















‚ıDISK CATALOGUE SYSTEM‚ı


‚Section A.3. - The Limitations Of This System.‚

The current version of this software has the following limitations,

	1. There is a maximum of 25 subject categories,

	2. There is a ceiling 300 program records which can be stored,

	3. The system's associated RSC files ‚must‚ reside in the same ä           directory as the PRG files. This need not be the ROOT ä           directory and can be on any drive.ä
	4. The ‚LISTDATA‚ function in DISKCAT.prg requires that GDOS be ä           resident. The system is not supplied with GDOS and users ä           must install that themselves. However, as this function is ä           only intended to be a 'backup'/diagnostic tool, it should ä           not present too much of a problem to the normal user.

	5. The ‚LISTDATA‚ function in DISKCAT.prg assumes that the ä           printer is connected to the parallel interface. Serial ä           devices will not be supported.

The system does not recognise or make use of TT fast RAM, neither is äit dynamic in recognising and utilising expanded memory (ie above ä512k) on 'standard' ST's.





















ı‚DISK CATALOGUE SYSTEM‚ı


‚Section B.‚

	B.1. - Machine Type.

	B.2. - Display Type.

	B.3. - Available Memory.

	B.4. - Storage.

	B.5. - RAMDISK Usage.



































ı‚DISK CATALOGUE SYSTEM‚ı


‚Section B.1. - Machine Type.‚

This system should run on any Atari ST/STE/TT. It makes no assumptions äabout the architecture it is running on and does not utilise any of äthe features of the higher specification machines.

‚Section B.2. - Display Type.‚

The system is configured to run in ‚medium resolution‚ only. In low äresolution not all of the forms are visible and I have not made äprovision for window scrolling. It is untested in high resolution.

‚Section B.3. - Available Memory.‚

This system will happily run on a standard (512k RAM) machine. At äpresent the memory allocated to the database is static and not ädynamic, ie it does not configure the ceiling for the number of ärecords according to the amount of RAM available. I hope to äincorporate this in the next revision.

It should be noted, however, that the system operates much faster when ärunning from a RAMDISK. This is one option that the user should äconsider if enough memory is available.

‚Section B.4. - Storage.‚

The system both loads and saves data to the current logged drive and äpath. Note that if this is not a physical device (ie RAMDISK) then the äoutput files will have to be copied to one before the machine is reset äor switched off.

‚Section B.5. - RAMDISK Usage.‚

This system will run from a RAMDISK and the user should experience no äproblems when doing so. Note that if a RAMDISK is used then the notes äunder section B.4 should be observed.










ı‚DISK CATALOGUE SYSTEMı‚


‚Section C.‚

	C.1. - Discussion Of Coding Conventions Used In This System.

	C.2. - Discussion Of Memory Allocation And Disk Storage ä               Format.

	C.3. - Discussion Of GEM Usage.

	C.4. - Main System Flowchart.

	C.5. - Discussion Of Main System Flowchart.

	C.6. - Subsidiary Flowcharts.

	C.7. - Discussion Of Subsidiary Flowcharts.

	C.8. - Function Prototype Analysis.

	C.9. - Source File Listings.


























‚ıDISK CATALOGUE SYSTEM‚ı


‚Section C.1. - Discussion Of Coding Conventions.‚

‚1. GEM.‚

Each form used in this system retains the default FORMx name assigned äby WERCS.

For forms 1 to 7 the OK and ABORT buttons have the convention;

	OKn or ABORTn ... where ‚n‚ is the form number.

	eg the OK button in form 5 would be ‚OK5‚.

In form 8 there is not an OK button. The two buttons in this form äperform the 'view next record' (NEXT) function and exit (PEXIT).

Form 1 is the main menu. Its other buttons are used to enable the user äto select an operation. They also conform to the form 1 - 7 convention äand are named as follows;

	ADDn         - Add a record to the database

	AMENDn       - Amend a record in the database

	DELETEn      - Delete a record from the database

	LOADFILEn    - Load the latest file

	SAVEFILEn    - Save the current file

	FINDSUBJn    - Search the database for records matching a ä                       given subject code

	FINDFOLDn    - Search the database for a specified folder

	FINDPROGn    - Search the database for a specified program

	LISTDATAn    - List the current database to the device ä                       attached to the parallel interface

	QUITn        - Quit from the system





Although there are eight forms êthey êall êshare the same window. This äwindow utilises the following global variables;

	short	xwork, ywork, wwork, hwork - window dimensions
	short	*xw, *yw, *ww, *hw	   - pointers to dimensions
	int	wi_handle		   - AES window ID

The window dimensions are set to be the same as the DESKTOP using the äfollowing global variables;

	short	xdesk, ydesk, wdesk, hdesk   - desktop dimensions
	short 	*xd, *yd, *wd, *hd	     - pointers to dimensions
	int	ap_id			     - AES application ID
ı‚‚ı
Resource file objects use the following global variables;

	OBJECT	*menu_tree		     - the address of a tree
	short	treex, treey, treew, treeh   - tree clipping rectangle
	short	default_button_state	     - copy of ob_state field
					       for a DEFAULT button
	short	normal_button_state	     - copy of ob_state field
					       for a normal button
	MACRO	rsc_name		     - theênameêofêtheêRSC        ä					       file
	int	mousex, mousey		     - holds mouse co-ä					       ordinates
	int	event			     - holds returnêof wait_ ä					       mouse
	int	dummy			     - dummy parameter

Data entry in the forms is êconverted into the following global
variables from the TEDINFO fields;

	char	tedit_diskno[3]		     - disk number
	char	tedit_dsrce[30]		     - disk source
	char 	tedit_dcode[2]		     - subject code
	char 	tedit_fname[13]		     - folder name
	char 	tedit_pname[13]		     - program name
	char 	tedit_descr[41]		     - program description










‚2. DISKCAT Control Functions.‚

The following conventions are used in the functions which maintain the ädatabase;

	int 	cntr			     - generalêpurpose ä					       variable used to ä					       control loops
	int 	res			     - holds function return ä					       codes
	int 	pntr			     - general purpose ä					       variable used to scan ä					       lists
	int 	test			     - general purpose ä					       variable used to hold ä 					       the return codes from ä					       string comparisons
	char 	tmpvar[]		     - string buffer used to ä					       store file reads
	char 	*tmpvar_addr		     - pointer to tmpvar
	FILE 	*data_file		     - catalogue file object
	FILE 	*sub_file		     - subject code file ä					       object
	int 	close_error		     - used to hold return ä					       codes when closing data ä					       files. May be re-used ä					       for alternate purposes
ä




















ı‚DISK CATALOGUE SYSTEM‚ı


‚3. Section C.2. - Memory Allocation And Disk Storage Formats.‚

Apart from the global variables defined above there are a few others äwhich are used to store the catalogue and the subject code lookup ätable. These are;

	MACRO 	MAXRECORD		     - the ceiling for the ä					       number of catalogue ä					       entries

	int	free_rcd		     - the next available slot ä					       in the catalogue
	int	last_used_rcd[25]	     - an array which ä					       indicates the last used ä                                               record for each subject ä					       category
	struct	d_record		     - a structure which holds ä 					       the definition of a ä					       single catalogue entry
	disk_record[MAXRECORD]		     - an array of type struct ä					       d_record used to hold ä         				       the catalogue
	struct	subj_code		     - a structure which holds ä					       the definition of a ä					       single subject code ä					       lookup table entry
	subtext[25]			     - an array of type struct ä					       subj_code used to hold ä					       the subject code ä					       descriptions

The disk_record[] array requires approximately 30k of memory. This is äthe major memory requirement.

Both subtext and disk_record are stored on disk as text files and the ärecord format is the same as their structures.

Subtext[] is stored in the êfile ê‚subdata.dta‚. Disk_record[] is stored äin the file ‚dcat.dta‚. ‚DCAT.dta‚ êis êprefixed with the following before äthe contents of disk_record[],

	1 - a copy of free_rcd
	2 - a copy of last_used_rcd[]



ı‚DISK CATALOGUE SYSTEM‚ı


‚Section C.3. - A Discussion On The Use Of GEM‚

Both versions 1.00 and 1.01 ofêthis system utilised a rudimentary TOS äuser interface. This was found to be difficult to understand, äprohibited expansion of the system and posed large maintenance äproblems. For these reasons it was felt that a GEM interface was ädesirable.

All the data forms were constructed using WERCS and objects are äreferenced in the program code by their symbolic names rather than ätheir discreet index codes. However, due to the small code overhead äneeded to create them, ALERT boxes are formed using in-line code.

The system makes use of only one window. This window is referenced by äthe following global variables;

	int	wi_handle	- The AES window handle

	short	xdesk		- Desktop top left x co-ordinate
	short	ydesk		- Desktop top left y co-ordinate
	short	wdesk		- Desktop width offset
	short	hdesk		- Desktop height offset

	these 'desk' variables are used to seek the size of the ä	DESKTOP via the wind_get() function. They are then transformed into ä	the following variables via wind_create();

	short	xwork		- Work area top left x co-ordinate
	short	ywork		- Work area top left y co-ordinate
	short	wwork		- Work area width offset
	short	hwork		- Work area height offset

	the 'work' variables have the following pointers associated ä	with them;

	short	*xw		- Pointer to xwork
	short	*yw		- Pointer to ywork
	short	*ww		- Pointer to wwork
	short 	*hw		- Pointer to hwork







‚Resource File Forms.‚

The resource file data forms use the following global variables;

	MACRO	rsc_name	- The name of the resource file
	MACRO 	ROOT		- Defined as 0 to point to the start ä				  of an object tree
	OBJECT 	*menu_tree	- The address of the resource tree
	short	treex		- Top left x co-ordinate of the tree
				  clipping rectangle
	short	treey		- Top left y co-ordinate of the tree
				  clipping rectangle
	short	treew		- Width offset of the tree clipping
				  rectangle
	short	treeh		- Height offset of the tree clipping
				  rectangle

Buttons are reset to their initial state using the variables,

	short	default_button_state	- A copy of the ob_state field
					  for OK1 in FORM1
	short 	normal_button_state	- A copy of the ob_state field
					  for PEXIT in FORM8

The AES application code is stored in int ap_id.

The sequence followed for displaying and using a FORM is;

	1) close_window()
	2) open_window()
	3) disp_rsc(int form number)
	4) set_mouse(POINT_HAND)
	5) wind_title(wi_handle, "help text")
	6) form_do(menu_tree, int starting object)
	7) set_mouse(ARROW)
	8) close_window()

Note : the main() function does not need step '1' because the window äwill not be open. Main() only displays FORM1 but this is not cleared äbefore the routine selected by the user is invoked.









If the routine selected by the user terminates successfully one of the äthese functions will be executed according to the operation invoked,

	reset_form1() - the menu form
	reset_form2() - the 'ADD' form
	reset_form3() - the 'AMEND' form
	reset_form4() - the 'DELETE' form
	reset_form5() - the 'FIND SUBJECT' form
	reset_form6() - the 'FIND FOLDER' form
	reset_form7() - the 'FIND PROGRAM' form
	reset_form8() - the form used to display output from queries

	these functions reset the buttons in the forms to their ä	initial states.

In all cases if a GEM function call fails, an error message is ädisplayed in an ALERT box and the program terminates via exit() with äthe value 'EXIT_FAILURE' being passed to the operating system.

The TEDINFO fields of editable resource objects are set and read using äthe functions set_tedinfo() and get_tedinfo() respectively. These äfunctions are as defined in the '‚wtest.c‚' program supplied with äLattice C.

In forms 2 - 8 the ABORT buttons are never set as the default. This äensures that the default operation is the positive one.

In form 1 the OK button is the default. Error trapping is in place to äensure that an action has been selected. This form is split into four ä'panels' viz,

	panel 1	- the base panel, holds the title, copyright notice, ä		  OK and QUIT buttons.
	panel 2 - Radio buttons to select ADD, AMEND or DELETE.
	panel 3 - Radio buttons to select LOADFILE or SAVEFILE.
	panel 4 - Radio buttons to select FIND SUBJECT, FIND FOLDER,ä		  FIND PROGRAM or LIST DATA.












Form 1 is scanned in the order of panel 1 to panel 4 in order to ädetect which option has been chosen. The order of precedence within äthe panels is,

	‚Panel 1‚ - QUIT

	‚Panel 2 ‚- ADD
		  AMEND
		  DELETE

	‚Panel 3‚ - LOAD FILE
		  SAVE FILE

	‚Panel 4‚ - FIND SUBJECT
		  FIND FOLDER
		  FIND PROGRAM
		  LIST DATA

Because each panel uses radio buttons only one option can be chosen äfrom them. However, nothing can stop the user from selecting an option äfrom each panel. If that happens then the priority of the panel is äused to decide which option should be executed.

‚Other Functions.‚

When an error message is displayed in an ALERT box the function äerror_bell() is invoked. This function sounds the bell three times via äputchar(7) in order to provide an audible warning of the error.

Because TEDINFO fields can only hold string data a mechanism was äneeded to convert the two int fields of the d_record structure so that äthey could be displayed in FORM8. In order to achieve this these two äfunctions were used,

	char *cvtitos(int)
	void str_invert(char *)

	cvtitos() performs repeated division on the passed integer in äorder to form an output string. Because this function creates the ästring in reverse order, str_invert reverses the order of that string. äThese functions were copied from Atkinson and Atkinson's book ‚'Using äC'‚.







ı‚DISK CATALOGUE SYSTEM‚ı

‚Section C.5. - Discussion Of Main System Flowchart.‚

This flowchart shows that after the êsystem has been fully initialised äit is held in a permanent loop; cycling between displaying the initial ämenu and executing the chosen option.

The option to êquit êfrom êthe êsystem êis êdescribed êin the function ä'QUIT_SYS()', I have not êcluttered êup êthe êmain êflowchart with the älogic for this option.

‚DECLARE GLOBAL VARIABLES‚ sets up the variables needed to drive the GEM äinterface and the êarrays êneeded êto êhold êthe êcatalogue êdata, the äsubject code descriptions and the linked list.

‚OPEN WORKSTATION‚ initialises the AES êand retrieves the application ID äof this program. The program does not êuse any VDI functions, so there äis no need to open a VDI workstation.

‚LOAD RESOURCE FILE‚ loads the data form resource trees into memory.

‚INITIALISE‚ performs the following,

	1) Sets the keyboard êbuffer êto ê0 êto disable any type-ahead    ä           facility.

	2) Initialises the array LAST_USED_RSC which controls the ä	   construction of the linked list.

	3) Sets the NEXT_RCD field of each entry in DISK_RECORD to -1. ä	   This is the default state as -1 indicates the end of link 
	   chain for a particular subject code.

	4) Initialises each entry in the subject code description array ä           to blanks.

‚SET UP DEFAULT BUTTON VARIABLES‚ copies the OB_STATE fields of a änormal button and a default button into two global variables. This äwill allow similar buttons to be reset to their default state after äuse.

‚DISPLAY INITIAL MENU‚ presents the user with the main menu, resource ätree FORM1.

‚EXECUTE INITIAL MENU‚ allows the user to select an option from the äinitial menu. The FORM1 tree is parsed to see which objects have been äselected.

ı‚DISK CATALOGUE SYSTEMı‚

‚EXECUTE CHOSEN OPTION‚ passes control to the routines which service the äoption selected by the user; this includes the option to quit from the äsystem. Each option (except QUIT) passes control back to here and the äsystem then loops back to DISPLAY INITIAL MENU.











































ı‚DISK CATALOGUE SYSTEM‚ı

‚Section C.7. - Discussion Of Subsidiary Flowcharts.‚

‚DECLARE GLOBAL VARIABLES ‚(Flowchart Page 2) is straightforward and äsimply describes the initialisation of these variables. The use of äglobal variables is explained in section C.2.

‚OPEN STATION ‚(Flowchart Page 3) is also straightforward. The AES is äinitialised with a call to APPL_INIT(). If this is successfuläexecution continues with AP_ID set to the AES application handle, äotherwise the program is immediately terminated.

‚LOAD RESOURCE FILE‚ describes how the resource tree DCAT1.RSC is loaded äinto memory. If the load is successful execution continues; otherwise äthe following action is taken,

	a) The bell is sounded three times,
	b) An error form_alert is displayed,
	c) The AES is closed,
	d) The system terminates via EXIT() with the code EXIT_FAILURE ä	   sent to the OS.

‚INITIALISE‚ is as described in section C.5.

‚SET DEFAULT BUTTON‚ is as described in section C.5.

‚DISPLAY INITIAL MENU‚ is straight forward. A window is opened, the tree äFORM1 is displayed, the title of the window is set to display some ähelp text and all the buttons are set to their initial states.

‚EXECUTE CHOSEN OPTION‚ is the main controlling function. It allows the äuser to interact with FORM1, parses the OB_STATES of FORM1's buttons äto see which option has been chosen and passes control to the ärequisite sub-routine. When the sub-routine has finished it returns äcontrol back to this function which in turn returns to DISPLAY INITIAL äMENU.

‚ERROR BELL‚ provides an audible error indication by sounding the bell äthree times via PUTCHAR(7).

‚CLOSE WORKSTATION‚ simply informs the AES that the application no älonger requires it services via APPL_EXIT().

‚OPEN WINDOW‚ is quite complex although the flowchart adequately ädescribes what is going on. In simple terms it seeks to open a new äwindow with the same dimensions as the desktop. This window will have äthe title bar available.

ı‚DISK CATALOGUE SYSTEM‚ı

‚DISPLAY RSC TREE‚ is the function used to display a form in the current äwindow. It is passed an INT which indicates which form the system äwishes to display. It then seeks the start address of the form via äRSC_GADDR(). If the start cannot be found the following is taken,

	a) ERROR_BELL() is executed,
	b) An error form_alert is displayed,
	c) The current window is closed and deleted,
	d) The AES is informed that the system will no longer require ä	   its services via APPL_EXIT(),
	e) The system terminates via EXIT() with the error flag ä	   EXIT_FAILURE sent to the OS.

If the start is found the required parameters needed to display the äform in the centre of the screen are retrieved via FORM_CENTRE(). The äform is then drawn via OBJC_DRAW(). If the form cannot be drawn then ästeps a through e above are taken.

‚FIND CHOICE‚ examines the OB_STATE field of each of the buttons in äFORM1 to determine what option the user has selected. The logic that äcontrols this is described in section C.3.

‚DO CHOICE‚ passes control of the system (or terminates the system and äpasses control back to the desktop) to the function that the user has äselected according to what option FIND CHOICE has determined.
If DO CHOICE cannot match the chosen option to a sub-routine then ästeps a to e described under DISPLAY RSC TREE are taken.

‚ADD‚ is the function that allows the user to add new records to the ädatabase. The tree FORM 2 is displayed on screen and the user äinteracts with it via FORM_DO().

If the user selects the ABORT button the OB_STATE fields of the FORM
2 buttons are reset, the window is closed and control passed back to
the main menu.

Otherwise, the TEDINFO fields of FORM 2 are copied into the entry in äthe array DISK_RECORD pointed to by FREE_RCD. LAST_USED_RCD is äinterrogated to see if this code has been used before (ie it is not = ä-1) and if it has the NEXT_RCD field of the entry in DISK_RECORD äpointed to by LAST_USED_RCD is set to FREE_RCD. Finally, The entry in äLAST_USED_RCD pointed to by this record's subject code is updated to ähold FREE_RCD. FREE_RCD is then incremented.

‚AMEND‚ allows the user to alter the details stored about a program. The ätree FORM 3 is displayed and the user interacts with it via FORM_DO().

ı‚DISK CATALOGUE SYSTEM‚ı

If the user selects the ABORT button the OB_STATE fields of the FORM 3 äbuttons are reset, the window is closed and control passed back to the ämain menu.

Otherwise, the FORM 3 buttons are reset and DISK_RECORD is searched for äthe program name that the user has entered. If this name is not found äan error message is given and control is passed back to the main menu.

If the name is found the TEDINFO fields of the other fields in FORM 3 ärelating to DISK_RECORD are set to NULL and the user interacts with äthe form again via FORM_DO(). The TEDINFO fields from FORM 3 are then äcopied into the selected record in DISK_RECORD, the window is closed äand control passed back to the main menu.

‚DELETE‚ allows the user to remove an entry from the catalogue. The tree äFORM 4 is displayed and the user interacts with it via FORM_DO(). If äthe user selects the ABORT button the OB_STATE fields of the FORM 4 äbuttons are reset, the window is closed and control passed back to the ämain menu.

Otherwise, the FORM 4 buttons are reset and the window is closed. äDISK_RECORD is then searched for the program name that the user has äentered. If this name is not found an error message is given and äcontrol is passed back to the main menu.

If the name is found the system searches DISK_RECORD again for the ärecord used immediately before this one for the same subject which is änot deleted. If such a record is found then its NEXT_RCD field is set äto the NEXT_RCD field of the record to be deleted; this ensures the äintegrity of the linked list.

Finally, the subject code field of the current record is set to 99 to äindicate a logical deletion. Control is passed back to the main menu.

‚LOAD FILE‚ loads both the current catalogue and the subject code ädescriptions from disk.

‚A. Loading The Catalogue‚. - The catalogue is loaded in three distinct äblocks;
	1) One 'INT' which is a copy of FREE_RCD, FREE_RCD is updated ä	   accordingly,

	2) 25 'INT's which are a copy of LAST_USED_RCD, LAST_USED_RCD ä	   is updated accordingly,

	3) A block of data 'FREE_RCD' long which is a copy of ä	   DISK_RECORD, DISK_RECORD is updated accordingly.

ı‚DISK CATALOGUE SYSTEM‚ı

At any time, if an error occurs when reading from this disk file an äerror form_alert is displayed, the file closed and the process äaborted.

Whilst the DISK_RECORD block is being loaded the system keeps a count äof the number of logically deleted records in the database.

Once the catalogue has been loaded (or the process aborted) the system äthen loads in the descriptions of the 25 subject categories. These are ästored in SUBTEXT. Again, if at any time a read error occurs the file äis closed and the process aborted.

Finally, if there are any deleted records in the database the user is äinformed and asked (via a form_alert) whether they should be removed. äIf the user does wish to remove them then procedure REMOVE_DEL_RECS is äexecuted. Control is passed back to the main menu.

‚REMOVE DEL RECS‚ is a rather complicated function although the äflowchart does make it quite clear as to what is going on. This äfunction effectively strips out the redundant records from DISK_RECORD äand rebuilds the subject code linked list from scratch.

‚SAVE FILE‚ is a simple function. It merely writes a copy of FREE_RCD, äLAST_USED_RECORD and DISK_RECORD to the disk file DCAT.DTA in that äorder. If for any reason the data file either cannot be opened or äclosed then an error form_alert is displayed. Control passes back to äthe main menu.

There are three functions which are used to interrogate the database;
	‚FIND SUBJ
	FIND FOLD
	FIND PROG‚
and they search for records matching a user specified subject code, äfolder name or program name respectively.

Each one of these routines makes use of two forms; one to gather the äsearch criteria (ie program name) and one to display the required äcatalogue entry. An all cases if no records are found an error message äis displayed.

The forms used by these functions to allow the user to enter the äsearch criteria are:
	‚FORM 5	-  FIND SUBJ
	FORM 6  -  FIND FOLD
	FORM 7  -  FIND PROGRAM‚

All three functions provide their output via ‚FORM 8‚.
ı‚DISK CATALOGUE SYSTEM‚ı

‚Section C.8. - Function Prototype Analysis‚

‚open_station(void);‚
Initialises the AES via appl_init()

‚close_station(void);‚
Terminates the AES via appl_exit()

‚open_window(void);‚
Opens a new window with êthe êsame êdimensions as the Desktop, returns äthe window handle in wi_handle.

‚close_window(void);‚
Closes the window with handle wi_handle.

‚load_rsc(void);‚
Loads the resource whose name is stored in macro 'rsc_name'.

‚disp_rsc(int form);‚
int form;	the system number of the form to display. This can ä		have the following macro values;
			FORM1
			FORM2
			FORM3
			FORM4
			FORM5
			FORM6
			FORM7
			FORM8

Displays the resource tree whose root is pointed to by form.

‚disp_find(int cntr);‚
int cntr;	the index number in disk_record of the record to
		display.

Used only in conjunction with FORM8. Used to set the TEDINFO fields of äFORM8's display fields to contain a copy of the data held in the ärecord in disk_record pointed to by cntr.

‚set_mouse(int type);‚
int type;	the new mouse form.

Used to change the mouse form. The system only uses the values 'ARROW' äand 'POINT_HAND'.


ı‚DISK CATALOGUE SYSTEM‚ı

‚set_default_button(void);‚

Copies the ob_state fields of OK1 in FORM1 and PEXIT in FORM8 into ädefault_button_state and normal_button_state respectively. These ävalues are used to reset the buttons in all forms to their default ästate after they have been executed via a form_do() function.

‚get_tedinfo(OBJECT *tree, int obj, char *dest);‚
OBJECT *tree;	A pointer to the resource tree
int obj;	The index number of the object within *tree whose ä		contents are required
char *dest;	The address of the start of a buffer where the ä		contents of the TEDINFO field are to be stored.

The TEDINFO field of the specified object is copied into the buffer äpointed to dest.

‚set_tedinfo(OBJECT *tree, int obj, char *source);‚
OBJECT *tree;	A pointer to the resource tree
int obj;	The index number of the object within *tree whose ä		TEDINFO field is to be set to the string contained in ä		the buffer pointed to by source.

The TEDINFO field of the specified object is set to the content of the äbuffer pointed to by source.

‚reset_form1(void);‚
All the button objects in FORM1 are reset to their default states.

‚reset_form2(void);‚
All the button objects in FORM2 are reset to their default states.

‚reset_form3(void);‚
All the button objects in FORM3 are reset to their default states.

‚reset_form4(void);‚
All the button objects in FORM4 are reset to their default states.

‚reset_form5(void);‚
All the button objects in FORM5 are reset to their default states.

‚reset_form6(void);‚
All the button objects in FORM6 are reset to their default states.

‚reset_form7(void);‚
All the button objects in FORM7 are reset to their default states.

ı‚DISK CATALOGUE SYSTEMı‚

‚reset_form8(void);‚
All the button objects in FORM8 are reset to their default states.

‚char *cvtitos(int num);‚
int num;	The number which is to be translated into a string.

This function converts an integer into a string which is defined as äthe global variable outstr. This function produces an inverted string äand must be used in conjunction with str_invert.

‚str_invert(char *srce);‚
char *srce;	The address of the string to invert.

This function reverses the order of the elements of the string pointed äto by srce.

‚error_bell(void);‚
This function provides an audible error warning by ringing the bell äthree times.

‚print_string(char *buffer, int n);‚
char *buffer;	The address of the start of the buffer containing the ä		text to be printed.
int n;		The number of characters to print.

This function prints n characters from *buffer to the printer.

‚initialise(void);‚
This function performs the following system initialisation;
	a) Disables the keyboard type-ahead buffer,
	b) Sets each entry in the global array last_used_rcd to -1,
	c) Sets the global variable free_rcd to 0,
	d) Sets êeach êsubject êcode êdescription êfield ê(subjtxt) in ä	   subtext to blanks.

‚int find_choice(void);‚
This function scans the ob_state fields of the buttons in FORM1 to ädetermine which option the user has chosen. The valid return values äare :-
	1 - ADD				2 - AMEND
	3 - DELETE			4 - LOAD FILE
	5 - SAVE FILE			6 - FIND SUBJECT
	7 - FIND FOLDER			8 - FIND PROGRAM
	9 - LIST DATA FILE	       10 - QUIT

If no option is selected then the value -1 is returned.

ı‚DISK CATALOGUE SYSTEM‚ı

‚do_choice(int option);‚
int option;	The option code returned by find_choice().

This passes control to the following sub-routines according to the ävalue passed to it from find_choice();
	1 - ADD()			2 - AMEND()
	3 - DELETE()			4 - LOAD_FILE()
	5 - SAVE_FILE()			6 - FIND_SUBJ()
	7 - FIND_FOLD()			8 - FIND_PROG()
	9 - LIST_DATA() 	       10 - QUIT_SYS()

If option is -1 then an error message is displayed. If option is not äset to either 1 - 10 or -1 then an error message is displayed and the äprogram is terminated via QUIT_SYS().

‚add(void);‚
This function controls the resource tree FORM2 and allows the user to äenter the data for a new record into the system. If the ABORT button äon this form is selected control is passed back to DO_CHOICE(), äotherwise ADD_REC() is called.

‚add_rec(void);‚
This function retrieves the data for the record to be added from the äTEDINFO fields of FORM2 and updates DISK_RECORD. The linked list is äupdated accordingly.

‚amend(void);
‚This function allows the user to specify the name of the program to be äamended via FORM3. If the user wishes to abort control passes back to äDO_CHOICE(), otherwise AMEND_REC() is called.

‚amend_rec(void);‚
This function searches DISK_RECORD for the program name that the user ähas entered into FORM3. If the program cannot be found an error ämessage is displayed and control passes back to DO_CHOICE() via äAMEND(). Otherwise, the TEDINFO fields of FORM3 are set to a copy of äthe located record and the user interacts with the form again so that äthe required entries may be changed. Control then passes to AMEND_IT() äwhich is passed the index number of the record in DISK_RECORD which is äto be updated.

‚amend_it(int cntr);‚
int cntr;	The index number in DISK_RECORD of the record to be ä		updated.

This function copies the TEDINFO fields of FORM3 into DISK_RECORD at äposition cntr.
ı‚DISK CATALOGUE SYSTEM‚ı

‚delete(void);‚
This function controls the resource tree FORM4 and allows the user to äspecify the name of the program to be deleted from the database. If äthe user selects the ABORT button control is passed back to äDO_CHOICE(), otherwise DEL_REC() is called.

‚del_rec(void);‚
This function searches DISK_RECORD for the program name specified in äFORM4. If the program is not found an error message is displayed and äcontrol passes back to DO_CHOICE() via DELETE(). If the program is äfound DEL() is called and is passed the index number in DISK_RECORD of äthe record to be deleted.

‚del(int cntr);‚
int cntr;	The index number of the record in DISK_RECORD to be ä		deleted.

This function logically deleted the record in DISK_RECORD pointed to äby cntr by changing its subject code to 99 (only codes 1 to 25 are ävalid 'live' codes). In addition, the linked list is adjusted for the äremoval of this record.

‚int f_rec(char name[13]);‚
char name[13];	The name of the program to be located.

This function steps through DISK_RECORD searching for the program name äspecified in 'name'. If the program is found its index number is äreturned, otherwise this function returns -1 to indicate failure.

‚find_subj(void);‚
This function controls the use of resource tree FORM5 and allows the äuser to specify a subject code to search for. If abort is selected äcontrol is passed back to DO_CHOICE(), otherwise FIND_SUBJECT() is äcalled.

‚find_subject(void);‚
This function follows the linked list through DISK_RECORD, displaying äeach record which matched the subject code specified in FORM5 on a ägeneral purpose output form, FORM8. The user may exit from this äfunction at any time by selecting the EXIT button in FORM8. Control is äpassed back to DO_CHOICE() via FIND_SUBJ().

‚find_fold(void);‚
This function controls the use of the resource tree FORM6 and allows äthe user to specify a folder name to search for. If abort is selected äcontrol is passed back to DO_CHOICE(), otherwise FIND_FOLDER() is äcalled.
ı‚DISK CATALOGUE SYSTEM‚ı

‚find_folder(void);‚
This function searches DISK_RECORD for a record whose folder name äfield matches the name specified in FORM6. If the name is found the ädata for the record is displayed using general purpose output form äFORM8, otherwise an error message is given.

‚find_prog(void);‚
This function controls the use of the resource tree FORM7 and allows äthe user to specify a program name to search for, If abort is selected äcontrol is passed back to DO_CHOICE(), otherwise FIND_PROGRAM() is äcalled.

‚find_program(void);‚
This function searches DISK_RECORD for a record whose program name äfield matches the name specified in FORM7. If the name is found the ädata for the record is displayed using general purpose output form äFORM8, otherwise an error message is given.

‚list_data(void);‚
his function closes the active window and calls L_DATA().

‚l_data(void);‚
This function lists the content of DISK_RECORD to the printer. Because äthis sub-routine uses two GEMDOS functions (via PRINT_STRING()) this äfunction will not allow the user to print unless GDOS is installed. If äGDOS is not installed an error message is displayed.

‚load_file(void);‚
This function closes the active window and calls LOAD_F().

‚load_f(void);‚
This function loads in the current database from the disk file ä'DCAT.DTA'. If the file is not available or an error occurs when äreading from it an error message is displayed and the process is äaborted. This function also loads in the subject code descriptions äfrom the disk file 'SUBDATA.DTA'. Again, if the file could not be äopened or a read error occurs an error message is displayed.

This function will advise the user of any logically deleted records äwhich are held in the database. If the user wishes to physically ädelete them REMOVE_DEL_RECS() is called.

‚read_error_msg(void);‚
This function calls ERROR_BELL() and displays an error message äinforming the user that an error occurred when attempting to read from äthe data file.

ı‚DISK CATALOGUE SYSTEM‚ı

‚char * read_file(char *buffer, FILE *data_file);‚
char *buffer;		A buffer to store data read from disk in.
FILE *data_file;	The file to read from.

This function reads a string of data from *data_file into buffer. If äan error occurs when reading the data an error message is given. The äfunction returns a pointer to the string; this will be NULL if an äerror has occurred.

‚remove_del_recs(void);‚
This function strips out logically deleted records from DISK_RECORD äand rebuilds the subject code linked list.

‚save_file(void);‚
This function closes the active window and calls SAVE_F().

‚save_f(void);‚
This function saves the current catalogue to disk. Data is written to ädisk in the following order;
	FREE_RCD
	LAST_USED_RCD
	DISK_RECORD(free_rcd -1 entries)

If an error occurs when opening or closing the file (DCAT.DTA) an äerror message is displayed.






















‚ıDISK CATALOGUE SYSTEM‚ı

‚Section D. - User Guide‚

‚Getting Started.‚

‚System Requirements.‚

	. ATARI ST Computer
	. 1 Floppy Disk Drive
	. Colour Monitor (or colour television if your computer has an   ä	  RF modulator)

Set up your computer in accordance with the instructions given in youräowners manual.

‚Loading DISKCAT.‚

DISKCAT is a medium resolution program that uses the ST computer's 4 äcolour, 320x200 pixel display mode.

Your ST must be in medium resolution before you start this program. In äorder to set your ST computer into medium resolution follow these ästeps;

	1) Insert your working boot disk and switch your ST on.
	2) From the GEM desktop select ‚OPTIONS‚ from the top menu bar.
	3) Click with mouse on ‚SET PREFERENCES‚.
	4) When the preferences dialogue box appears, click in the ‚ä	   MEDIUM‚ box under ‚Set Screen Resolution‚.
	5) Click on ‚OK‚.

Your computer will now 'reset' and your display will change to medium äresolution.

Note : If you intend to produce a hardcopy listing of your database äwith the ‚LISTDATA‚ function then your boot disk must install GDOS. Your äDISKCAT disk does not include GDOS, you must supply this for yourself.

Once your ST is booted up and in medium resolution insert your DISKCAT ädisk into the floppy disk drive. Double click on the disk A icon to ädisplay the disk directory. Locate the file ‚DISKCAT.PRG‚ on this ädisplay and double click on it. After a few moments the main menu will äbe displayed.





ı‚DISK CATALOGUE SYSTEM‚ı

‚Using DISKCAT.‚

Once loaded, DISKCAT displays its initial menu. This is a simple GEM äform and allows you to select an operation by clicking on the relevant äbutton and then clicking ‚OK‚. The main menu offers the following äoptions;

	‚Add A New Record			- ADD
	Amend An Existing Record 		- AMEND
	Delete An Existing Record		- DELETE
	Display Data For A Chosen Subject	- FIND SUBJECT
        Display Data For A Chosen Folder	- FIND FOLDER
	Display Data For A Chosen Program	- FIND PROGRAM
	Load A Copy Of The Latest Database	- LOAD FILE
	Save The Current Database To Disk	- SAVE FILE
	Print A Copy Of The Current Database	- LIST DATA
	Quit					- QUIT‚

‚Add A New Record.‚
This option allows you to add a record to the database. When this äoption is selected the system displays a new form, you use this new äform to enter the details of the program you wish to add. The details ärequired are;

	‚Disk Number  :‚ The number of the disk that this program
		       resides on.
	‚Disk Source  :‚ A short memo field used to describe where you ä		       obtained the disk (ie the name of a PD
		       library or magazine).
	‚Subject Code :‚ A number between 1 and 25 which is the code ä		       number that you have assigned to this type of ä		       program.
	‚Program Name :‚ The name of the executable program file.
	‚Folder Name  :‚ The name of the folder that the program can be ä		       found in.
	‚Description  :‚ A short description of the program.

When you have entered all the required details click on ‚OK‚. The record äwill be added to the database and the form cleared to allow you to äenter the next one. You can keep on entering records until you click äon the ‚EXIT‚ button.

From the above you can see that you must do a small amount of äpreparatory work before using this system. Your disk collection must äbe sorted into a logical order and each disk must be assigned a änumber. In addition, for each program that you wish to store in your ädatabase you must know the details given above.
‚ıDISK CATALOGUE SYSTEM‚ı

‚Amend An Existing Record.‚
This option allows you to amend the details of a program already ästored in the database. When this option is selected the system ädisplays a new form. You use this form to enter the new details for äthis program.

The process of amending a record is in two steps. Firstly you use the äform to enter the name of the program you wish to amend. Note that the äother fields are displayed and even though you can enter data into äthem it will be ignored. Having entered the program name click on ‚OK‚. äThe system will then search the database for that record. If it cannot äfind that record it will display an error message and you will be äreturned to the main menu.

If the record is found its details are displayed on the form. You can äthen use the mouse to move between the various data fields and change äthem as necessary. When you have finished click on ‚OK‚, if you wish to äabandon your changes click on ‚ABORT‚.

‚Delete An Existing Record.‚
This option allows you delete a record from the database. When this äoption is selected the system displays a new form. Use this form to äenter the name of the program you wish to delete. When you have äentered the name click on ‚OK‚, if you wish to abort the deletion click äon ‚ABORT‚.

The system will then search the database for the specified program and äif it is found, delete the record. If the record cannot be found an äerror message is displayed.

‚Display Data For A Chosen Subject.‚
This option allows you to search the database for all records which ämatch a specified subject code. When this option is selected the äsystem displays a new form in which you enter the code to search for. äIf you wish to abort the search click on ‚ABORT‚, otherwise click on ‚OK‚.

The system then displays another form. This form will display each ärecord that matches the specified code in turn. Use the ‚NEXT‚ button to ädisplay the next record for that code or ‚EXIT‚ to return to the main ämenu.

‚Display Data For A Chosen Folder.‚
This option allows you to search the database for the details of a äparticular folder. When this option is selected the system displays a änew form in which you specify the name of the folder to be searched äfor. If you wish to abort the search click on ‚ABORT‚, otherwise click äon ‚OK‚.
‚ıDISK CATALOGUE SYSTEMı‚

The system then displays another form on which the details of the ärecord relating to the specified folder will be given. When you have äfinished click on either button to exit.

‚Display Data For A Chosen Program.‚
This option allows you to search the database for the details of a äparticular program. When this option is selected the system displays a änew form in which you specify the name of the program to be searched äfor. If you wish to abort the search click on ‚ABORT‚, otherwise click äon ‚OK‚.

The system then displays another form on which the details of the ärecord relating to the specified program will be given. When you have äfinished click on either button to exit.

‚Load A Copy Of The Latest Database.‚
This option allows you to load a copy of the latest database from ädisk. This option works in two stages; firstly the database äinformation is loaded and then the subject code descriptions are äloaded (use SUBJ.TOS to maintain the descriptions). If either of the äfiles are not available or cannot be read from an error message is ägiven.

Notes : 1) This option does not warn you that it will destroy any data ä	   that you currently have in memory. Take care !

	2) The database (DCAT.DTA) and the subject code descriptions ä	   (SUBDATA.DTA) must be in the same directory as DISKCAT.PRG.

‚Save The Current Database To Disk.‚
This option allows you to save a copy of the latest database in memory äto disk.

Note : This option will completely destroy any data previously stored ä       in DCAT.DTA, take care !

‚Print A Copy Of The Current Database.‚
This option enables you to obtain a hardcopy of the current database. äIt will only list to a parallel printer, serial devices are not äcatered for. In addition, this option requires that GDOS is installed. äIf GDOS is not installed an error message is displayed and you will be äreturned to the main menu.

‚Quit.‚
This option exits DISKCAT.PRG and returns you to the GEM desktop. Note äthat it does not save a copy of the current database before quitting, äyou must select that option for yourself if needed.
ı‚DISK CATALOGUE SYSTEM‚ı

‚Installation Notes.‚
This system will run from any disk drive/RAM disk setup that you may ähave and will also run from any folder. However, you must ensure that äall the following files are in the same folder;

	DISKCAT.PRG	- The program file
	DCAT1.RSC	- The System's Resource File
	DCAT.DTA	- The Database File
	SUBDATA.DTA	- The Subject Code Descriptions File

Note : If you are going to run this system from a RAM disk don't äforget that if you change the database you will have to copy DCAT.DTA äfrom your RAM disk to a physical disk before switching your ST off.

‚Disclaimer Notice.‚
This system has been tested on the following machine configurations;
	ATARI 520STFM - with 512k memory
	ATARI 520STE  - with 512k memory
	ATARI 520STFM - with 4meg memory

and has been found to work with no problems. The software has evolved äthrough three revisions;
	Release 1.00 - The initial release, heavily bug-ridden and ä		       swiftly replaced with,
	Release 1.01 - The first stable version. Translated from ä		       SOZOBON code to ANSII standard Lattice C code. ä		       This revision rectified release 1.00 bugs and ä		       added some extra functionality in the ADD ä		       option.
	Release 2.00 - This release. A major rewrite which updated all ä		       the screen handling for user interaction to ä		       make use of GEM. Error checking is much more ä		       precise and the system is now quite stable.

However, in the event of this program malfunctioning the author äaccepts no responsibility for any losses that the user may suffer. The äuser is deemed to accept these terms as soon as he/she first uses the äsystem.

‚Future Enhancements.‚
In the next revision of this software the author hopes to add the äfollowing enhancements,

	1) To convert SUBJ.TOS to a full blown GEM application.
	2) To improve the quality of the hardcopy produced by ‚LIST ä	   DATA‚ by making better use of GDOS.

‚ıDISK CATALOGUE SYSTEM‚ı

‚Suggestions, Comments and Bug Reports.‚
Any user who wishes to offer suggestions or comments on this system or äwho has discovered a serious bug in the software can write to me at äthe following address,

	‚Mr. L.J. Russell
	16 Rockstone Way
	Ramsgate
	Kent
	CT12 6NJ‚

This system is designated to be PUBLIC DOMAIN software by the author. äThe software may be freely copied and distributed subject to the äfollowing conditions,

	1) The author retains the 'intellectual' copyright to the ä	    code.
	2) These notes must be distributed along with the software.
	3) The code may not be altered by anyone other than the ä	   author.

Enjoy !



L.J. Russell
4th April 1993




















‚ıDISK CATALOGUE SYSTEM‚ı

‚Section E. - Technical Guide.‚

This system comprises of three files;

	DISKCAT.PRG
	DCAT1.RSC
	SUBJ.TOS

These files can be located in any folder on any drive but ‚must‚ be kept ätogether.

DISKCAT.PRG produces the following output file;

	DCAT.DTA

DCAT.DTA is an ASCII text file which contains a copy of the database äand certain control variables as described under ‚SAVE FILE‚ in section äC.7. and ‚save_f()‚ in section C.8.

SUBJ.TOS produces the following output file;

	SUBDATA.DTA

SUBDATA.DTA is an ASCII text file which contains the descriptions the äuser has decided to attribute to each of the 25 subject codes.

Once they have been created both DCAT.DTA and SUBDATA.DTA must be kept äin the same directory as the executable files.

The user guide will be found in the file GUIDE.DOC, this is also in äASCII format to allow it to be read straight from the desktop.

This software has the following restrictions/requirements;

	1) In order to obtain a hardcopy print of the database the ä	   user must have GDOS installed. GDOS is not distributed with ä	   this system, users must provide it for themselves.
	2) Hardcopy is only available on parallel printers, serial ä	   devices are not supported. In addition, this option has ä	   only been tested on a Star LC24-10 printer. The software is ä	   not guaranteed to work with other printers and if it does ä	   not the user must provide his/her own driver.
	3) All the executable files and data files must be in the same ä	   folder.
	4) The system is limited to 300 entries in the database. This ä	   may be lifted in a future revision.
	5) The system only works in medium resolution.
‚ıDISK CATALOGUE SYSTEM‚ı

	6) If the user elects to QUIT from DISKCAT.PRG no prompt is ä	   given to save the current data file if required.
	7) If the user elects to LOAD a copy of the latest data file ä	   from disk no prompt is given for the user to confirm this ä	   course of action. This option will mean that any changes ä	   the user has made to the database before loading will be ä	   lost.
	8) If the user elects to SAVE the current database to disk no ä	   prompt is given for the user to confirm this course of ä	   action. This option will destroy the previous version of ä	   the database which is on disk.
	9) The system is limited to 25 subject categories. There is no ä	   intention to extend this range.

Full details of how this system has been constructed can be found in äsection C.































‚ıDISK CATALOGUE SYSTEM‚ı

‚Appendix A. - Acknowledgements.‚

The author would like to thank the following people for their help in ätesting the system,

	Mr. C.L. Russell
	Mr. S.J. Penn

The following people offered invaluable advice during the writing of äthis system,

	Mr. S.J. Penn
	Mrs. M. Pinnington

The author would like to acknowledge the following reference sources,

	HiSoft & Lattice Inc	 - For the GET_TEDINFO and SET_TEDINFO ä				   functions given in their wtest.c ä				   program.

	Lee Atkinson &		 - For the cvtitos() and str_invert() ä	Mark Atkinson 		   functions given in their book
				   ‚'USING C'‚ (QUE, ISBN 0-88022-571-8)

	ATARI ST - Tricks & Tips - Abacus Software ISBN 0-916439-47-X

ATARI, ST. 520STFM and 520STE are trademarks or registered trademarks äof Atari Corporation.

GEM is a registered trademark of Digital Research Inc.

STAR and LC24-10 are trademarks of Star Micronics Co. Ltd.

The êfollowing softwareêhas been used during the development of this äsystem;

	The Sozobon C Compiler		- (c) Sozobon, limited
	STPAGE v 1.36			- (c) Robert Warnestam
	PROTEXT v 4.37			- (c) Arnor
	Lattice C v 5.5			- (c) HiSoft & Lattice Inc







‚ıDISK CATALOGUE SYSTEM‚ı

‚Appendix B. - Index.‚

	ADD			- C.1.1, C.7, C.8, D
	AMEND			- C.1.1, C.7, C.8, D
	DCAT.DTA		- C.1.2, C.2.3, C.7, C.8, D, E
	DELETE			- C.1.1, C.7, C.8, D
	DISPLAY			- B.2, E
	FIND SUBJECT		- C.1.1, C.7, C.8, D
	FIND FOLDER		- C.1.1, C.7. C.8, D
	FIND PROGRAM		- C.1.1, C.7, C.8, D
	GEM			- A.2, C.1.1, C.3
	GDOS			- A.3, E
	LIST DATA		- C.1.1, C.8, D
	MEMORY			- B.3
	RAMDISK			- B.3
	RESOURCE (RSC) FILE	- A.3, C.1.1, C.3, C.5
	SUBDATA.DTA		- C.1.3
	SUBJECT CODES		- A.3
	TEDINFO			- C.1.1, C.3, C.8
