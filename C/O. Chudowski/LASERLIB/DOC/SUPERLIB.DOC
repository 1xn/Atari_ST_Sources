072040001030000144008000002006000
11
207.07.89- # -superlib.doc1
F0110030001
R   [................................................]0010
9[........................................................]0010
8000100001\SUPER1.IMG
à


















8000100001\SUPER2.IMG























8000100001\SUPER3.IMG






















àInhaltsverzeichnis                                  Inhaltsverzeichnis



Å1. libstr.a  - Funktionen zum Verarbeiten von Zeichenkettenâ
Å
Ä   Zeichenkette formatieren 
        (stradj, stradjl, stradjr)

   Zeichenketten aneinanderhÑngen
        (strcat, strncat, strcatn, strncatn)

   Adresse eines Zeichens in einer Zeichenkette suchen
        (strchr, strichr, strrchr, strirchr)

   Zeichenketten vergleichen
        (strcmp, stricmp, strncmp, strnicmp, strscmp, striscmp,
strnscmp,strniscmp)

   Longwert von einer Basis in eine andere Basis wandeln
        (strcnvl,strcnvul)

   Zeichenketten miteinander kopieren
        (strcpy, strncpy, strn0cpy, strcpyn, strncpyn, strpcpy)

   Bestimmte Zeichen einer Zeichenkette zÑhlen
        (strcspn, stricspn, strspn, strispn)

   Zeichenkette zentrieren
        (strctr)

   Duplikat einer Zeichenkette erstellen
        (strdup, strndup)

   Zeichenkette auf Leerzeichen untersuchen
        (stremp, strnemp)

   Zeichenkette in einer Zeichenkettenmenge suchen
        (strfnd, strifnd)

   Longwert in String wandeln
        (strfroml,strfromul)

   Groû- in Kleinbuchstaben wandeln und umgekehrt
        (strinv, strninv)

   LÑnge einer Zeichenkette berechnen
        (strlen)

   Zeichenkette in Kleinbuchstaben wandeln
        (strlwr, strnlwr, strlwrg, strnlwrg)

   Zwei Zeichenketten matchen
        (strmat, strimat, strnmat, strnimat)

   Teil einer Zeichenkette suchen
        (strpbrk, stripbrk, strrpbrk, strirpbrk)

   Position eines Zeichens ineiner Zeichenkette suchen
        (strpos, stripos, strrpos, strirpos)
9[........................................................]0010



à______________________________________________________________________Ä
àInhaltsverzeichnis                                  InhaltsverzeichnisÄ



   Zeichen einer Zeichenkette umdrehen (an sich selbst spiegeln)
        (strrev)

   Zeichenkette rotieren
        (strrotl, strrotr, strnrotl, strnrotr)

   Zeichenmuster in einer Zeichenkette ersetzen
        (strrpl, strirpl, strnrpl, strnirpl)

   Zeichen einer Zeichenkette durch ein Zeichen ersetzen
        (strset, strnset, strsset,strspc, strnspc,memset)

ZeicheneinerZeichenkettesortieren
(strsort,strisort,strrsort,strirsort)

   Adresse einer Teil-Zeichenkette in einer Zeichenkette suchen
        (strstr, stristr, strrstr, strirstr)

   Zeichenkette in Token aufteilen
        (strtok)

   Zeichenketten in Zahlen konvertieren
        (strtol, strtoul, strtof)

   Zeichen aus Zeichenkette entfernen
        (strtrm, strtrml, strtrmr, strptrm, strptrml, strptrmr)

   Zeichenkette in Groûbuchstaben wandeln
        (strupr, strnupr, strwupr, struprg, strnuprg)

   Teil-Zeichenkette kopieren
        (substr, subnstr)

Adressbereichevergleichenundkopieren
(memchr,memcmp,memcpy)


Å2. libterm.a - Funktionen zumSteuernder Bildschirmausgabe

2.1. termcap
Ä
   Termcap-Eintrag aus Termcap-Datei lesen
        (tgetent)

   Numerischen Termcap-Eintrags-Feld-Wert suchen
        (tgetnum)

   Vorhandensein eines Termcap-Eintrags-Feldes testen
        (tgetflag)

   Alphanumerischen Termcap-Eintrags-Feld-Wert suchen
        (tgetstr)

   Cursor-Adressierungs-String erstellen
        (tgoto)

   String auf Bildschirm ausgeben
        (tputs)

à______________________________________________________________________Ä
àInhaltsverzeichnis                                  InhaltsverzeichnisÄ



Å2.2. terminalâ
Ä
   Terminal-Variablen und Terminal-Mode initialisieren
        (t_init)

   Terminal-Mode zurÅcksetzen
        (t_exit)

   Terminal zwischen Normal und Raw umschalten
        (t_rawon, t_rawoff)

   Signalton auf Standard-Ausgabe ausgeben
        (t_beep)

   Bildschirmbereiche lîschen
        (t_cls, t_cleol, t_cleos)

   Bildschirm-Cursor an- und ausschalten
        (t_curson, t_cursoff,t_cursstat)

Bildschirm-Cursor-Blinkenan-undausschalten
(t_cblink,t_csteady)

   Tastencode oder Konstante fÅr Sondertaste liefern
        (t_getc)

   Bildschirm-Cursor positionieren
        (t_goxy,t_chome,t_cup,t_cdown,t_cright,t_cleft)

   Terminal-Attribute setzen
        (t_setatt, t_invon, t_invoff)

Tabulatorweitesetzen(intern)
(t_settw)

LiniengrafikaufBildschirmerzeugen
(t_hline,t_vline,t_box)

9[........................................................]0010
Å
3.libmenu.a-FunktionenzumErstellenundBearbeitenvonMenÅs
Ä
   Popup-Menu aufbauen und ausfÅhren
        (pmexec)

   Popup-MenÅ-EintrÑge selektieren / deselektieren
        (pmselect, PMSelect, PMDesel)
9[........................................................]0010


Å4.libdata.a-FunktionenzumBearbeitenvonDatenstrukturenÄ

Stack-Datenstrukturaufbauenundmanipulieren
(stacknew,stackdel,stackpush,stackpop,stacktop,stackshow,
stacktype,stackdepth,stackname,stackempty)






à______________________________________________________________________Ä
àInhaltsverzeichnis                                  InhaltsverzeichnisÄ



Å5.libetc.a-DiverseFunktionen

ÄProgramm-Aufruf-ArgumenteprÅfenundVariablenzuordnen
(getarg,GetArg)

SystemkommandoausfÅhren
(system)

Zeichenkettebildschirmgesteuerteditieren
(editfld)


Å6. Anhang

6.1. Bedeutung der Termcap - EintrÑge

6.2. Atari Termcap

6.3. Atari vt52 - Escape - Sequenzenâ
Å
7. Index
Ä



































9[........................................................]0010

Å
à______________________________________________________________________
8000100001\ABHAENG1.IMG
à























8000100001\ABHAENG2.IMG



























8000100001\ABHAENG3.IMG












Ä
Ä
8000100001\STR1.IMG




















8000100001\STR2.IMG



























8000100001\STR3.IMG
















àlibstrAllgemeineslibstr
Ö

Ä
ÅNAMEÄ

Ölibstr-FunktionenzumVerarbeitenvonZeichenketten


ÅBESCHREIBUNGÖ
Å
ÄDieLibraryÅlibstrÄstelltFunktionenfÅrdenUmgangmitundfÅr
dieManipulationvonZeichenketten(Strings)zurVerfÅgung.
    FÅrdieBenutzungdereinzelnenFunktionenistdieDatei
    Ålibstr.incÄzuincluden.
    DieFunktionenunterteilensichinzweiGruppen.Dabeibeginnen
dieNamenallerFunktionendererstenGruppe'str'bzw.endenauf
'str';sieverarbeitenmitdemNullzeichen'\0'abgeschlossene
Zeichenketten.DieNamenderFunktionenderzweitenGruppebeg-
innenmit'mem'undbehandelndasNullzeichenànichtÄalsSonder-
zeichenfÅrdasZeichenkettenende.
Å
Ä
ÅDATEIENÄ

libstr.a
libstr.inc



































Å
à______________________________________________________________________Ä
àlibstrstradj, stradjl,stradjrlibstr
Ö
à
Ä
ÅNAME
Ä
Ö    stradj,stradjl,stradjr-Zeichenketteformatieren

Å
SYNTAX
Ä
    #include <libstr.inc>

    BYTE *stradj (str, dir)     
    BYTE *str;
    WORD dir;
    
    BYTE *stradjl (str, dir)     
    BYTE *str;
    WORD dir;

    BYTE *stradjr (str, dir)     
    BYTE *str;
    WORD dir;


ÅBESCHREIBUNGÄ

    ÅstradjlÄ bzw. ÅstradjÄ richten die Zeichenkette str linksbÅndig aus.
ÅstradjrÄformatiertdieZeichenkettestrrechtsbÅndig. 
In AbhÑngigkeit von dir werden dir Leerzeichen vor (hinter)str
    gehÑngt (dir > 0) oder dir Zeichen (nicht nur leere!) entfernt.


ÅRETURNWERTÄ

    Es wird die Adresse der formatierten Zeichenkette zurÅckgeliefert.


ÅBEMERKUNG

Ä    Insbesondere bedeutet stradj? (str, 0 - strlen (str)),daû str
 gelîscht wird. Es muû gewÑhrleistet sein, daû der Platz der
 Zeichenkette str fÅr das HinzufÅgen von Leerzeichen ausreicht.
ÅstradjÄistalsMakrodefiniertundwirdaufÅstradjlÄabgebildet.
Å

DATEIENÄ

    libstr.inc
    libstr.a
Å
Ä
ÅREFERENZÄ

Å    Ästrlen,strctr






à
______________________________________________________________________
9[.....................................................]0010
àlibstrstrcat,strncat,strcatn,strncatnlibstr
Ä

Å
NAME
Ä
Ö    strcat, strncat,strcatn,strncatn -  StringsaneinanderhÑngen


ÅSYNTAXÄ

    #include <libstr.inc>

    BYTE *strcat (dest, source)
    BYTE *dest, *source;

    BYTE *strncat (dest, source,limit)
    BYTE *dest, *source;
WORDlimit;

    BYTE *strcatn (dest, source1, source2, ..., NULP)
    BYTE *dest, *source1, *source2, ...;

    BYTE *strncatn (dest, limit,source1, source2, ..., NULP)
    BYTE *dest, *source1, *source2, ...;
WORDlimit;


ÅBESCHREIBUNGÄ

    ÅstrcatÄhÑngtdie Zeichenkette source an das Ende der Zeichenkette
 dest.ÅstrncatÄhÑngtmaximaldieerstenlimitZeichenvonsource
andasEndevondest.ÅstrcatnÄhÑngtdie Zeichenkette source1 und
 eventuell folgende Zeichenketten source2, ... bis zur leeren
 Zeichenkette NULP(muss immer letzter Parameter sein!) an das Ende
 der Zeichenkette dest.ÅstrncatnÄarbeitetwieÅstrcatnÄ,kopiert
jedochmaximaldieerstenlimitZeichenjederZeichenkette
source1,....


ÅRETURNWERT

Ä    Es wird die Adresse der Ziel-Zeichenkette destzurÅckgeliefert.


ÅBEMERKUNG
Ä
    Ist limit grîûer als die LÑnge von sourceoder negativ, so werden
    alle Zeichen von source an dest gehÑngt.


ÅDATEIENÄ

    libstr.inc
    libstr.a


ÅREFERENZÄ

    strcpy, strncpy, strn0cpy, strcpyn,strncpyn
à


______________________________________________________________________
àlibstrstrchr,strichr,strrchr,strirchrlibstr

Å

NAME
Ö
    strchr,strichr,strrchr,strirchr-Adressee.Zeichenssuchen
Ä

ÅSYNTAXÄ

    #include <libstr.inc>

    BYTE *strchr (str, symbol)
    BYTE *str;
    BYTE symbol;

    BYTE *strichr (str, symbol)
    BYTE *str;
    BYTE symbol;

    BYTE *strrchr (str, symbol)
    BYTE *str;
    BYTE symbol;

    BYTE *strirchr (str, symbol)
    BYTE *str;
    BYTE symbol;

Å
BESCHREIBUNG
Ä
    ÅstrchrÄsuchtdie erste Position des Zeichens symbol innerhalb der
 Zeichenkette str ausgehend vom Stringanfang.ÅstrichrÄunterscheidetÅ
ÄdabeinichtzwischenGroû-undKleinbuchstaben.ÅstrrchrÄsuchtdas
ersteAuftretenvonsymbolausgehendvomEndedesStringsstr.
ÅstrirchrÄdifferenziertdabeinichtzwischenGroû-/Kleinbuchstaben.


ÅRETURNWERTÄ

    Die Adresse des Zeichens symbol wird zurÅckgeliefert oder NULP,
    falls symbol nicht in der Zeichenkette str vorhanden ist.


ÅBEMERKUNGÄ

    keine
Å

DATEIEN
Ä
    libstr.inc
    libstr.a


ÅREFERENZÄ

    strstr, stristr, strirstr, strrstr,strpbrk,stripbrk,strrpbrk
strirpbrk



à______________________________________________________________________
àlibstrstrcmp,stricmp,strncmp,strnicmp,strscmp,striscmplibstr

Å

NAME
Ö
    strcmp,stricmp,strncmp,strnicmp,
strscmp,striscmp,strnscmp,strniscmp-Stringsvergleichen
Å

SYNTAXÄ

    #include <libstr.inc>

    WORD strcmp (str1, str2)
    BYTE *str1, *str2;

    WORD stricmp (str1, str2)
    BYTE *str1, *str2;

    WORD strncmp (str1, str2, limit)
    BYTE *str1, *str2;
    WORD limit;

    WORD strnicmp (str1, str2, limit)
    BYTE *str1, *str2;
    WORD limit;

    WORD strscmp (str1, str2)
    BYTE *str1, *str2;

    WORD striscmp (str1, str2)
    BYTE *str1, *str2;

    WORD strnscmp (str1, str2,limit)
    BYTE *str1, *str2;
WORDlimit;

    WORD strniscmp (str1, str2,limit)
    BYTE *str1, *str2;
WORDlimit;


ÅBESCHREIBUNGÄ

    ÅstrcmpÄuntersuchtdie Zeichenketten str1 und str2 werden auf
 Gleichheit bezÅglichdereinzelnenZeichen.ÅstricmpÄvergleicht
ebenfallsbeideZeichenketten,jedochohnezwischenGroû-und
Kleinbuchstabenzuunterscheiden.ÅstrncmpÄvergleichtmaximaldie
    ersten limitZeichen der Zeichenketten str1 und str2.ÅstrnicmpÄ
unterscheidetdabei nichtzwischen Groû- und Kleinbuchstaben.
ÅstrscmpÄ,ÅstriscmpÄ,ÅstrnscmpÄundÅstrniscmpÄarbeitenwieÅstrcmpÄbzw.
ÅstricmpÄbzw.ÅstrncmpÄbzw.ÅstrnicmpÄ,jedochwerdenbeidemVerglei-
chenLeerzeichenundTabsvernachlÑssigt.

Å
RETURNWERT

Ä    Sind beide Zeichenketten identisch, so wird 0, ansonsten die
    Differenz des letzten verglichenen Zeichenpaares von str1 und str2
    zurÅckgeliefert.

Å
à______________________________________________________________________
àlibstrstrcmp,stricmp,strncmp,strnicmp,strscmp,striscmplibstr
Ä
à
Å
BEMERKUNG
Ä
    keine


ÅDATEIEN
Ä
    libstr.inc
    libstr.a


ÅREFERENZÄ

    strmat,strimat,strfnd,strifnd













































à______________________________________________________________________
àlibstr                     strcnvl,strcnvul                    libstrÄ


Å
NAME
Ö
    strcnvl.
strcnvul - Longwert von einer Basis in eine andere Basis wandeln

Å
SYNTAX
Ä
    #include <libstr.inc>

    BYTE *strcnvl (number, ibase, obase)
    BYTE *number;
    WORD ibase, obase;

    BYTE *strcnvul (number, ibase, obase)
    BYTE *number;
    WORD ibase, obase;

Å
BESCHREIBUNG
Ä
    ÅstrcnvlÄ interpretiert den String number als Ziffernfolge der
    Basis ibase und liefert den entsprechende Wert in der Basis obase.
    Der erzeugte String zur Basis obase wird in einem statischen
    Puffer angelegt.ÅstrcnvulÄinterpretiertdeninnumberenthaltenen
WertalsunsignedLong.

Å
RETURNWERT
Ä
    Die Adresse der (statischen) Zeichenkette wird zurÅckgeliefert.


ÅBEMERKUNGÄ

    Der statische Puffer wird bei jedem Aufruf Åberschrieben.


ÅBEISPIELÄ

    #include <stdio.h>
    #include <libstr.inc>

/*cbase-ZahleinerBasiszueineranderenBasisdarstellen*/

    VOID main (argc, argv)
    WORD argc;
    BYTE *argv[];
    {
       WORD ibase = 10, obase = 10;
       WORD nibase, nobase;
       BYTE zahl[100];
       BYTE *bp;
  




  
à______________________________________________________________________
àlibstr                          strcnvl                         libstr
Ä


       if (argc == 1)
       {
          fprintf (stderr, "usage: cbase zahl[,ibase[,obase]] ...\n");
          exit (-1);
       }

       while (*++argv)
       {
          if (!(bp = strtok (*argv, ",")))
             break;
          strcpy (zahl, bp);
          if ((bp = strtok (NULP, ",")))
          {
             nibase = (WORD) strtol (bp, (BYTE *) NULP, 10);
             if (nibase < 1 || nibase > 38)
             {
                fprintf (stderr, "cbase: Falsche ibase %d\n", nibase);
                continue;
             }
             ibase = nibase;
             if ((bp = strtok (NULP, ",")))
             {
                nobase = (WORD) strtol (bp, (BYTE *) NULP, 10);
                if (nobase < 1 || nobase > 38)
                {
                   fprintf (stderr, "cbase: Falsche obase %d\n",
 nobase);
                   continue;
                }
                obase = nobase;
             }
          }
          printf ("%s\n", strcnvl (zahl, ibase, obase));
       }
    }
  

ÅDATEIENÄ

    libstr.inc
    libstr.a


ÅREFERENZÄ

    strtol, strtoul, strtof, strfroml,strfromul













à______________________________________________________________________
àlibstrstrcpy,strncpy,strn0cpy,strcpyn,strncpyn,strpcpylibstr

Å

NAME
Ä
Ö    strcpy,strncpy,strn0cpy,
strcpyn,strncpyn,strpcpy -Stringsmiteinanderkopieren
Å

SYNTAX

Ä    #include <libstr.inc>

    BYTE *strcpy (dest, source)
    BYTE *dest, *source;

    BYTE *strncpy (dest, source, limit)
    BYTE *dest, *source;
    WORD limit;

    BYTE *strn0cpy (dest, source, limit)
    BYTE *dest, *source;
    WORD limit;

    BYTE *strcpyn (dest, source1, source2, ..., NULP)
    BYTE *dest, *source1, *source2, ...;

    BYTE *strncpyn (dest, limit,source1, source2, ..., NULP)
    BYTE *dest, *source1, *source2, ...;
WORDlimit;

    BYTE *strpcpy (dest, start, end)
    BYTE *dest;
    BYTE *start;
    BYTE *end;

Å
BESCHREIBUNG

Ä    ÅstrcpyÄkopiertdenInhaltderZeichenkette sourceandieAdresse
derZeichenkettedest.Å strncpyÄ kopiert max. limit Zeichen der
 Zeichenkette source an die Adresse der Zeichenkette dest.Åstrn0cpyÄ
arbeitetwiestrncpy,hÑngtjedochein'\0'andasEndevondest.
    Die Zeichenkette source1 und eventuell folgende Zeichenketten 
    source2, ... bis zur leeren Zeichenkette NULP (muss immer letzter
    Parameter sein!) werden durchÅstrcpynÄalle miteinander verkettet,
 an die Adresse der Zeichenkette dest kopiert.
ÅstrncpynÄkopiertmaximaldieerstenlimitZeichenjederZeichen-
ketteandieAdressevondest. ÅstrpcpyÄkopiertdenInhaltder
Teilzeichenkette vonsource,diesichzwischendenbeidenAdressen
startundendbefindet,nachdest.

Å
RETURNWERT
Ä
    Es wird die Adresse der Ziel-Zeichenkette dest zurÅckgeliefert.


ÅBEMERKUNGÄ

    keine

à______________________________________________________________________
àlibstrstrcpy,strncpy,strn0cpy,strcpyn,strncpyn,strpcpylibstr

Å

DATEIEN
Ä
    libstr.inc
    libstr.a


ÅREFERENZÄ

    strcat,strncat,strcatn,strncatn


















































à______________________________________________________________________
àlibstrstrcspn,stricspn,strspn,strispnlibstr
Ä


ÅNAMEÄ

    Östrcspn,stricspn,
strspn,strispn - Bestimmte Zeichen einer Zeichenkette zÑhlen
Ä

ÅSYNTAXÄ

    #include <libstr.inc>

    WORD strcspn (str, set)
    BYTE *str;
    BYTE *set;

    WORD stricspn (str, set)
    BYTE *str;
    BYTE *set;

    WORD strspn (str, set)
    BYTE *str;
    BYTE *set;

    WORD strispn (str, set)
    BYTE *str;
    BYTE *set;
Å

BESCHREIBUNG
Ä
    ÅstrcspnÄ zÑhlt die Anzahl der Zeichen der Zeichenkette str, die 
    in der Menge set vorkommenunterBerÅcksichtigungderGroû-/
Kleinschreibung.ÅstricspnÄermitteltdieAnzahlderZeichenohne
BerÅcksichtigungderGroû-/Kleinschreibung. ÅstrspnÄundÅstrispnÄ
arbeitenanalogdazu,liefertjedochdieAnzahlderZeichen,die
nichtinderMengesetvorkommen.


ÅRETURNWERTÄ

    Es wird die Anzahl der Zeichen zurÅckgeliefert.

Å
BEMERKUNGÄ

keine

Å
DATEIEN
Ä
    libstr.inc
    libstr.a

Å
REFERENZÄ





à______________________________________________________________________
àlibstrstrctrlibstr

Ä
Å
NAME
Ä
Ö    strctr  -  Zeichenkette zentrieren

Ä
ÅSYNTAXÄ

    #include <libstr.inc>

    BYTE *strctr (str)
    BYTE *str;

Å
BESCHREIBUNG
Ä
   Å strctrÄ zentriert den String str durch AusbalancierenderÑuûeren
 Leerzeichen, falls vorhanden(Rotation).

Å
RETURNWERT

Ä    Die Adresse der zentrierten Zeichenkette str wird zurÅckgeliefert.


ÅBEMERKUNG
Ä
    keine


ÅDATEIENÄ

    libstr.inc
    libstr.a


ÅREFERENZÄ

    stradjl, stradjr,strnrotr,strnrotl





















à______________________________________________________________________
àlibstrstrdup,strnduplibstr


Å
NAME
Ä
Ö    strdup,strndup - Duplikat einer Zeichenkette erstellen

Å
SYNTAX

Ä    #include <libstr.inc>

    BYTE *strdup (str)          
    BYTE *str;

    BYTE *strndup (str,limit)          
    BYTE *str;
WORDlimit;


ÅBESCHREIBUNG

Ä    BeiÅstrdupÄwirddie Zeichenkette str in einen dynamisch erzeug-
ten Puffer kopiert. Die Zeichenkette, die zurÅckgeliefert wird,
 hat die gleiche LÑnge wie die Åbergebene Zeichenkette.
ÅstrndupÄhingegenlieferteineKopiederTeilzeichenkettemitden
maximalerstenlimitZeichenvonstr.

Å
RETURNWERT
Ä
    Es wird die Adresse der kopierten Zeichenkette zurÅckgeliefert
    oder NULP, falls kein Speicherplatz fuer die Zeichenkette reser-
viertwerden kann (malloc).


ÅBEMERKUNG

ÄWennlimit>strlen(str)ist,dannwirdtrotzdemeinBereich
vonlimitZeichenreserviert.


ÅDATEIEN

Ä    libstr.inc
    libstr.a   
               

ÅREFERENZÄ

    strlen, strcpy, malloc







à
Ä


à______________________________________________________________________Ä
àlibstrstremp,strnemplibstr
Ä

Å
NAME
Ä
    Östremp,strnemp - Zeichenkette auf Leerzeichen untersuchenÄ

Ö
ÅSYNTAX
Ä
    #include <libstr.inc>

    BOOL stremp (str)
    BYTE *str;

    BOOL strnemp (str,limit)
    BYTE *str;

Å
BESCHREIBUNG
Ä
   Å strempÄ testet, ob die Zeichenkette str nur Leerzeichen und tabs
    enthÑlt.
ÅstrnempÄuntersuchtmaximaldieerstenlimitZeichenderZeichen-
kettestraufLeerzeichen.

Å
RETURNWERT
Ä
  TRUE, wenn die Zeichenkette str nur Leerzeichen oder tabs enthÑlt,
 FALSE sonst.


ÅBEMERKUNG
Ä
keine


ÅDATEIENÄ

    libstr.inc
    libstr.a


ÅREFERENZÄ

    















à______________________________________________________________________
àlibstrstrfnd,strifndlibstr
Ä

Å
NAME
Ä
    Östrfnd,strifnd - Zeichenkette in einerZeichenkettenmengesuchenÄ


ÅSYNTAXÄ

    #include <libstr.inc>

    WORDstrfnd (pool, str)
    BYTE *pool;
    BYTE *str;

    WORDstrifnd (pool, str)
    BYTE *pool;
    BYTE *str;

Å
BESCHREIBUNG

Ä    ÅstrfndÄ durchsucht einen pool von Strings nach str. Ein pool ist
 eine Aneinanderreihung von nichtleeren Strings. Das Ende wird
 durch einen leeren String markiert.
         Bsp: str0\0str1\0str2\0str3\0...strn\0\0.
    Findet ÅstrfndÄ einen der Strings im pool, so liefert ÅstrfndÄ die
 Nummer des Strings (der erste hat die Nummer 0).
ÅstrifndÄarbeitetwieÅstrfndÄ,jedochohneBerÅcksichtigungder
Groû-/Kleinschreibung.

    
ÅRETURNWERTÄ

    Nummer des gefundenen Strings oder sollte ÅstrfndÄ einen (oderÅ
Ä mehrere) String finden die ÅstrfndÄ nur teilweise vergleichen kann,
 das heiût, ÅstrfndÄ findet str zwar noch im pool, str ist aber
 kÅrzer als der String im pool, so wird -1 geliefert.
    Findet ÅstrfndÄ keinen passenden String im pool, so wird -2 ge-
liefert.

Å
BEMERKUNG

Äkeine

Å
DATEIEN
Ä
    libstr.inc
    libstr.a

Å
REFERENZÄ

    strmat, strimat,strnmat,strnimat





à______________________________________________________________________
àlibstr                    strfroml,strfromul                   libstrÄ


Å
NAME
Ö
    strfroml,strfromul - Longwert in String wandeln

Ä
ÅSYNTAXÄ

    #include <libstr.inc>

    BYTE *strfroml (number, base)
    LONG number;
    WORD base;

    BYTE *strfromul (number, base)
    ULONG number;
    WORD base;

Å
BESCHREIBUNG
Ä
    ÅstrfromlÄ liefert den Wert number als String in der Basis base.
    Der String wird in einem statischen Puffer aufbereitet.ÅstrfromulÄ
behandeltdenWertinnumberalsunsignedLong.


ÅRETURNWERTÄ

    Die Adresse der (statischen) Zeichenkette wird zurÅckgeliefert.

Å
BEMERKUNG
Ä
    Der statische Puffer wird bei jedem Aufruf Åberschrieben.

Å
DATEIEN

Ä    libstr.inc
    libstr.a


ÅREFERENZÄ

    strtol, strtoul, strtof, strconvl,strcnvul














à
______________________________________________________________________
àlibstr                      strinv, strninv                     libstr
Ä

Å
NAME
Ö
    strinv, strninv - Groû- in Kleinbuchstaben wandeln und umgekehrt
Ä

ÅSYNTAXÄ

    #include <libstr.inc>

    BYTE *strinv (str)
    BYTE *str;

    BYTE *strninv (str, limit)
    BYTE *str;
    WORD limit;

Å
BESCHREIBUNG
Ä
   Å strinvÄ wandelt alle (ASCII!) Kleinbuchstaben der Zeichenkette str
    in Groûbuchstaben und alle Groûbuchstaben in Kleinbuchstaben um.
    ÅstrninvÄ betrachtet dabei die maximal ersten limit Zeichen von str.

Å
RETURNWERT
Ä
    Die Adresse der geÑnderten Zeichenkette str wird zurÅckgeliefert.

Å
BEMERKUNG
Ä
    keine


ÅDATEIENÄ

    libstr.inc
    libstr.a


ÅREFERENZÄ

    strlwr, strnlwr, strlwrg, strnlwrg, strupr, strnupr, strwupr,
    struprg, strnuprg

à













______________________________________________________________________
àlibstrstrlenlibstr

Å

NAMEÄ

Ö    strlen  -  LÑnge einer Zeichenkette berechnen 

Å
SYNTAX
Ä
    #include <libstr.inc>

    WORD strlen (str)           
    BYTE *str;

Å
BESCHREIBUNG
Ä
    ÅstrlenÄberechnetdie LÑnge der Zeichenkette str =Anzahlder
ZeichenohnedemNullzeichen.

Å
RETURNWERT
Ä
    Es wird die LÑnge der Zeichenkette zurÅckgeliefert.

Å
BEMERKUNG

Äkeine

Å
DATEIEN
Ä
    libstr.inc
    libstr.a


ÅREFERENZÄ























à______________________________________________________________________
àlibstrstrlwr,strnlwr,strlwrg,strnlwrglibstr

Ö
Ä
ÅNAMEÄ

Ö    strlwr,strnlwr,
strlwrg,strnlwrg - Zeichenkette in Kleinbuchstaben wandeln

Å
SYNTAX
Ä
    #include <libstr.inc>

    BYTE *strlwr (str)
    BYTE *str;

    BYTE *strnlwr (str,limit)
    BYTE *str;
WORDlimit;

    BYTE *strlwrg (str)
    BYTE *str;

    BYTE *strnlwrg (str,limit)
    BYTE *str;
WORDlimit;


ÅBESCHREIBUNGÄ

    ÅstrlwrÄwandeltalle(ASCII!)BuchstabenderZeichenkettestrin
Kleinbuchstabenum.ÅstrnlwrÄbetrachtetdabeidiemaximalersten
limitZeichenvonstr.BeiÅstrlwrgÄwerdenauchdiedeutschen
Umlaute(é,ô,ö)durchÑ,î,Åersetzt.ÅstrnlwrgÄbetrachtet
wiederumnurdiemaximalerstenlimitZeichenvonstr.

Å
RETURNWERT
Ä
    Die Adresse der geÑndertenZeichenkette str wird zurÅckgeliefert.


ÅBEMERKUNG
Ä
keine


ÅDATEIENÄ

    libstr.inc
    libstr.a


ÅREFERENZÄ

    strupr, strnupr, strwupr, struprg,strnuprg






à______________________________________________________________________
àlibstrstrmat,strimat,strnmat,strnimatlibstr
Ä


ÅNAMEÄ
Ö
    strmat,strimat,strnmat,strnimat -  zweiZeichenketten matchen

Å
SYNTAX
Ä
    #include <libstr.inc>

    WORD strmat (s, m)
    BYTE *s;
    BYTE *m;

    WORD strimat (s, m)
    BYTE *s;
    BYTE *m;

    WORD strnmat (s, m)
    BYTE *s;
    BYTE *m;

    WORD strnimat (s, m)
    BYTE *s;
    BYTE *m;

Å
BESCHREIBUNG

Ä    ÅstrmaÄt versuchtdieZeichenkettesmitdemMustermzumatchen.
    ÅstrimatÄmatchedohneGroû-/Kleinbuchstabenzuunterscheiden.Å
strnmatÄerkenntdabeinebendemNullbyteaucheinNewline'\n'als
Stringende.ÅstrnimatÄarbeitetanalog,jedochohneGroû-/Kleinbuch-
stabenzuunterscheiden.

    ÅFolgende matches sind mîglich:Ä

        ? : matched ein bel. Zeichen mit 0.
        * : matched eine bel. Zeichenkette mit 0.
        . : matched eine Anzahl gleicher Zeichen mit 0.
        % : matched eine bel. Ziffer mit 0.
        @ : matched einen bel. Kleinbuchstaben mit 0.
        $ : matched einen bel. Grossbuchstaben mit 0.
        & : matched einen bel. Buchstaben mit 0.
        ! : matched ein bel. Metazeichen mit 0.
        \\: das folgende Metazeichen verliert seine Wirkung.
     [abc]: das zu matchende Zeichen muss a oder b oder c
            sein.
     [-ab]: das zu matchende Zeichen muss ungleich a und
            ungleich b sein.                            
     [a:z]: das zu matchende Zeichen muss zwischen a und
            z (einschliesslich) liegen (a <= z <= b).
    [-a:z]: das zu matchende Zeichen darf nicht zwischen
            a und z liegen.  
Å





à______________________________________________________________________
àlibstrstrmat,strimat,strnmat,strnimatlibstr
Ä
Å

    Beispiele: 
Ä
            s             m       
         eeefeee       eeefeee    
         eeefeee       ee??eee    
         eeefeee       ee*        
         ee*           ee\\*      
         eeefeee       ee*f*      
         eeefeee       eee[a:z]e* 
         eeefeee       eee[-g:z]e*
         eeefeee       eee[afzg]e*
         eeefeee       eee[-abc]e*
         eeeeeff       e.ff      

Å
RETURNWERT
Ä
    0, bei Gleichheit, bzw. wenn der String s durch m gematched werden
    kann, sonst -999 bei falschem Match (Metazeichen!) oder die Dif-
ferenzdes letzten verglichenen Zeichenpaares von s und m.


ÅBEMERKUNGÄ

    Das Metazeichen '.' darf nicht am Anfang des Strings m stehen,
    da ja (s-1) dann noch nicht existiert.
BeiÅstrimatÄundÅstrnimatÄwerdennurdieASCII-Buchstabenohne
casebetrachtet,keineUmlaute.


ÅDATEIENÄ

    libstr.inc
    libstr.a


ÅREFERENZÄ

    strcmp, strncmp, stricmp, strnicmp




















à______________________________________________________________________Ä
àlibstrstrpbrk,stripbrk,strrpbrk,strirpbrklibstr
Ä

Å
NAME
Ö
    strpbrk,stripbrk,
strrpbrk,strirpbrk - TeileinerZeichenkette suchen

Å
SYNTAX
Ä
    #include <libstr.inc>

    BYTE *strpbrk (str, set)
    BYTE *str;
    BYTE *set;

    BYTE *stripbrk (str, set)
    BYTE *str;
    BYTE *set;

    BYTE *strrpbrk (str, set)
    BYTE *str;
    BYTE *set;

    BYTE *strirpbrk (str, set)
    BYTE *str;
    BYTE *set;


ÅBESCHREIBUNGÄ

   Å strpbrkÄ liefert die Adresse der Teil-Zeichenkette von strzurÅck,
 deren erstes Zeichen im set vorkommt. Gesucht wird ab dem ersten
 Zeichen des Strings.ÅstripbrkÄunterscheidetdabeinichtzwischen
 Groû-/Kleinbuchstaben.ÅstrrpbrkÄundÅstrirpbrkÄarbeitenanalog
dazu,beginnenjedochmitderSucheabdemletztenZeichenvon
str.


ÅRETURNWERTÄ

    Die Adresse der Teil-Zeichenkette von str oder NULP, falls keines
    der Zeichen von set in str vorhanden ist.


ÅBEMERKUNG

ÄBeiÅstripbrkÄundÅstrirpbrkÄwerdennurdieASCIIBuchstabenohne
casebetrachtet.


ÅDATEIENÄ

    libstr.inc
    libstr.a


ÅREFERENZÄ

strstr,stristr,strrstr,strirstr,strchr,strichr,strrchr

à______________________________________________________________________
àlibstrstrpos,stripos,strrpos,strirposlibstr

Ä

ÅNAME
Ä
Ö    strpos,stripos,
strrpos,strirpos - Position eines Zeichens imString suchen

Ä
ÅSYNTAXÄ

    #include <libstr.inc>

    WORD strpos (str, symbol)
    BYTE *str;
    BYTE symbol;

    WORD stripos (str, symbol)
    BYTE *str;
    BYTE symbol;

    WORD strrpos (str, symbol)
    BYTE *str;
    BYTE symbol;

    WORD strirpos (str, symbol)
    BYTE *str;
    BYTE symbol;


ÅBESCHREIBUNG

Ä    ÅstrposÄsuchtdie erste Position des Zeichens symbol innerhalb der
 Zeichenkette str ausgehend vom Stringanfang.ÅstriposÄdifferenziert
beiderSuchenichtzwischenGroû-/Kleinbuchstaben(ASCII).
ÅstrrposÄundÅstrirposÄarbeitenanalog,suchenjedochabdemString-
andevonstr.


ÅRETURNWERT

Ä    Die Position des Zeichens symbol wird zurÅckgeliefert oder -1,
    falls symbol nicht in der Zeichenkette str vorhanden ist. Dabei
 bedeutet 0 die erste Position!
    
Å
BEMERKUNG
Ä
keine

Å
DATEIENÄ

    libstr.inc
    libstr.a


ÅREFERENZÄ

    strchr, strrchr, strichr, strirchr


à______________________________________________________________________
àlibstrstrrevlibstr


Å
NAME
Ö
    strrev - Eine Zeichenkette umdrehen (an sich selbst spiegeln)

Ä
ÅSYNTAXÄ

    #include <libstr.inc>

    BYTE *strrev (str)         
    BYTE *str;


ÅBESCHREIBUNGÄ

    ÅstrrevÄliefertdie Zeichenkette str an sich selbst gespiegelt zu-
rÅck,d.h. das erste Zeichen wird zum letzten und das letzte zum
 ersten.


ÅRETURNWERTÄ

    Es wird die Adresse der gespiegelten Zeichenkette zurÅckgeliefert.


ÅBEMERKUNG
Ä
keine


ÅDATEIENÄ

    libstr.inc
    libstr.a


ÅREFERENZÄ

à




















______________________________________________________________________
àlibstr           strrotl, strrotr, strnrotl, strnrotr           libstr
Ä


ÅNAMEÄ
Ö
    strrotl, strrotr, strnrotl, strnrotr - Zeichenkette rotieren

Ä
ÅSYNTAXÄ

    #include <libstr.inc>

    BYTE *strrotl (str)
    BYTE *str;

    BYTE *strrotr (str)
    BYTE *str;

    BYTE *strnrotl (str, limit)
    BYTE *str;

    BYTE *strnrotr (str, limit)
    BYTE *str;
    

ÅBESCHREIBUNGÄ

    ÅstrrotlÄ rotiert die Zeichenkette str um ein Zeichen nach links,
    ÅstrrotrÄ um ein Zeichen nach rechts. ÅstrnrotlÄ und ÅstrnrotrÄ arbeiten
    analog, rotieren str jedoch um maximal limit Zeichen.
    

ÅRETURNWERT

Ä    Es wird die Adresse der formatierten Zeichenkette zurÅckgeliefert.


ÅBEMERKUNGÄ

    Ist limit = strlen (str), so ist der rotierte String str wieder
    gleich dem nicht rotierten.
    

ÅDATEIENÄ

    libstr.inc
    libstr.a

Å
REFERENZ
Ä
    strlen, stradj, strctr








à

______________________________________________________________________
àlibstrstrrpl,strirpl,strnrpl,strnirpllibstr

Ä
Å
NAME
Ä
Ö    strrpl,strirpl,
strnrpl,strnirpl - Zeichenmuster in einer Zeichenkette ersetzen

Ä
ÅSYNTAX

Ä    #include <libstr.inc>

    WORD strrpl (string, ptrn, rpl)   
    BYTE *string, *ptrn, *rpl;

    WORD strirpl (string, ptrn, rpl)   
    BYTE *string, *ptrn, *rpl;
Ö
Ä    WORD strnrpl (string, ptrn, rpl,limit)   
    BYTE *string, *ptrn, *rpl;
WORDlimit;

    WORD strnirpl (string, ptrn, rpl,limit)   
    BYTE *string, *ptrn, *rpl;
WORDlimit;
à

ÅBESCHREIBUNG

Ä    ÅstrrplÄ versucht in der Zeichenkette string alle Zeichenmuster ptrn
    durch rpl zu ersetzen.ÅstrirplÄvernachlÑssigtbeiderSuchevon
ptrndieUnterscheidungvonGroû-/Kleinbuchstaben.ÅstrnrplÄund
ÅstrnirplÄersetzendiemaximalerstenlimitZeichenmusterptrn.


ÅRETURNWERTÄ

    Es wird die Anzahl der Ersetzungen von rpl zurÅckgeliefert.

Å
BEMERKUNGÄ

keine


ÅDATEIENÄ

    libstr.inc
    libstr.a   (strstr, strlen, stradjl, strncpy)


ÅREFERENZÄ

    strstr, strlen, stradjl, strncpyà







______________________________________________________________________
àlibstrstrset,strnset,strsset,strspc,strnspc,memsetlibstr

Ä

ÅNAMEÄ
Ö
    strset,strnset,strsset,strspc,
strnspc,memset - Zeichen eines Strings durch e. Zeichen ersetzen

Ä
ÅSYNTAXÄ

    #include <libstr.inc>

    BYTE *strset (str, chr)
    BYTE *str;
    BYTE chr;

    BYTE *strnset (str, chr, limit)
    BYTE *str;
    BYTE chr;
    WORD limit;

    BYTE *strsset (str1, str2)
    BYTE *str1;
    BYTE *str2;

    BYTE *strspc (str)
    BYTE *str;

    BYTE *strnspc (str, limit)
    BYTE *str;
    WORD limit;

    BYTE *memset (str, chr, limit)
    BYTE *str;
    BYTE chr;
    WORD limit;

Å
BESCHREIBUNGÄ

    ÅstrsetÄersetztalleZeichen der Zeichenkette str durch das Zeichen
 chr.ÅstrnsetÄersetztdiemaximalerstenlimitZeichenvonstr
durchchr.ÅstrspcÄersetztalleZeichenvonstrdurchLeerzeichen.
ÅstrnspcÄhingegenersetztnurdiemaximalerstenlimitZeichenvon
strdurchLeerzeichen. ÅmemsetÄarbeitetwieÅstrnsetÄ,beachtetje-
dochnichtdasNullzeichen'\0'alsEnde,sondernersetztàgenauÄ
limitZeichen.ÅstrssetÄ fÅllt den String str1 solange mit der
 Zeichenkette str2, bis das Ende von str1 erkannt wurde.



ÅRETURNWERTÄ

    Es wird die Adresse der Zeichenkette str (bzw.str1)zurÅckgelie-
fert.






à______________________________________________________________________
àlibstrstrset,strnset,strsset,strspc,strnspc,memsetlibstr
Ä


ÅBEMERKUNGÄ

Beidenstr...-FunktionenwirddasNullzeichenamEndevonstr
nichtersetzt.


ÅDATEIENÄ

    libstr.inc
    libstr.a


ÅREFERENZÄ














































à______________________________________________________________________
àlibstr          strsort, strisort, strrsort, strirsort          libstrÄ



ÅNAMEÄ

   Ö strsort, strisort,
    strrsort, strirsort - Zeichen e. Zeichenkette sortierenÄ


ÅSYNTAXÄ

    #include <libstr.inc>

    BYTE *strsort (str)
    BYTE *str;

    BYTE *strisort (str)
    BYTE *str;

    BYTE *strrsort (str)
    BYTE *str;

    BYTE *strirsort (str)
    BYTE *str;


ÅBESCHREIBUNGÄ

    ÅstrsortÄ sortiert die Zeichen der Zeichenkette str nach ASCII-
    Ordnung und liefert einen Pointer auf die sortierte Zeichenkette
    str zurÅck. Bei ÅstrisortÄ wird nicht zwischen Groû-/Kleinbuchstaben
    unterschieden.Å strrsortÄ und ÅstrirsortÄ haben die gleiche Funktiona-
    litÑt wieÅ strsortÄ bzw. ÅstrisortÄ, liefern jedoch eine umgekehrt
    sortierte Zeichenkette zurÅck.

Å 
RETURNWERTÄ

    Es wird die Adresse der sortierten Zeichenkette str zurÅckgelie-
    fert.


ÅBEMERKUNGÄ

    Als Sortieralgorithmus liegt 'Bubblesort' zugrunde (nicht sehr
    schnell!). ÅstrrsortÄ und ÅstrirsortÄ sind als Macros in libstr.inc
    definiert und werden auf ÅstrsortÄ (bzw. ÅstrisortÄ) und ÅstrrevÄ abge-
    bildet.


DATEIEN

    libstr.inc
    libstr.a


REFERENZ

strrev



à______________________________________________________________________
àlibstrstrstr,stristr,strrstr,strirstrlibstr


Å
NAME
Ö
    strstr,stristr,
strrstr,strirstr - Adresse einer Zeichenkette suchen

Å
SYNTAX

Ä    #include <libstr.inc>

    BYTE *strstr (str, pattern)
    BYTE *str;
    BYTE *pattern;

    BYTE *stristr (str, pattern)
    BYTE *str;
    BYTE *pattern;
Å
Ä    BYTE *strrstr (str, pattern)
    BYTE *str;
    BYTE *pattern;

    BYTE *strirstr (str, pattern)
    BYTE *str;
    BYTE *pattern;


ÅBESCHREIBUNG

Ä    ÅstrstrÄsuchtdie erste Position der Zeichenkette pattern innerhalb
 der Zeichenkette str ausgehend vom Stringanfang.ÅstristrÄunter-
scheidetdabeinichtzwischenGroû-/Kleinbuchstaben.ÅstrrstrÄund
ÅstrirstrÄsuchendabeiabdemEndederZeichenkettestr.


ÅRETURNWERT

Ä    Die Adresse der Zeichenkette pattern wird zurÅckgeliefert oder
 '\0', falls pattern nicht in der Zeichenkette str vorhanden ist.


ÅBEMERKUNGÄ

keine


ÅDATEIENÄ

    libstr.inc
    libstr.a   (strlen, strncmp, strchr)

Å
REFERENZÄ

strchr,strichr,strrchr,strirchr



à
______________________________________________________________________
àlibstr                          strtok                          libstr

Ä
Å
NAME
Ä
   Ö strtok - Strings in Token aufteilenÄ


ÅSYNTAXÄ

    #include <libstr.inc>

    BYTE *strtok (str, delim)
    BYTE *str;
    BYTE *delim;


ÅBESCHREIBUNGÄ

    ÅstrtokÄ liefert die Adresse einer Teil-Zeichenkette von str zurÅck,
    die durch zwei Zeichen aus der Menge delim eingegrenzt wird.
    Bei öbergabe von NULP als str wird von dem letzten Teilstring
    (Token) aus nach einem weiteren Token gesucht.

Å
RETURNWERT
Ä
    Die Adresse der Teil-Zeichenkette (Token) von str oder NULP,
    falls kein weiterer Token gefunden werden kann.


ÅBEMERKUNGÄ

    Es wird ein statischer Pointer auf str angelegt, so daû bei
    öbergabe von NULP als str ab diesem Pointer weiter gesucht wird.
    
Å
DATEIEN
Ä
    libstr.inc
    libstr.a


ÅREFERENZÄ

    strfnd, strifnd, strmat, strimat
















à______________________________________________________________________
àlibstr                  strtol, strtoul, strtof                 libstr

Ä

ÅNAMEÄ

   Ö strtol, strtoul, strtof - Zeichemketten in Zahlen konvertierenÄ

Å
SYNTAX
Ä
    #include <libstr.inc>

    LONG strtol (number, nptr, base)
    BYTE *number;
    BYTE **nptr;
    WORD base;

    ULONG strtuol (number, nptr, base)
    BYTE *number;
    BYTE **nptr;
    WORD base;
    
    DOUBLE strtof (number, nptr, base)
    BYTE *number;
    BYTE **nptr;
    WORD base;

 
ÅBESCHREIBUNGÄ

    ÅstrtolÄ interpretiert den String number als Ziffernfolge und lie-
    fert den entsprechende Wert als LONG. Mit base wird die Basis der
    Zahl festgelegt (Standart ist 10). nptr kann NULL sein (dann nicht
    beachtet) oder eine gÅltige Adresse eines BYTE Pointers (dann wird
    in nptr die Adresse des Strings number ohne die interpretierten
    Ziffern geschrieben). ÅstrtoulÄ liefert den interpretierten Wert als
    unsigned long (ULONG). ÅstrtofÄ wertet den String in Hinsicht auf
    Dezimalwerte aus und liefert den Wert als DOUBLE zurÅck.


ÅRETURNWERTÄ

    Der interpretierte Wert als LONG, ULONG bzw. als DOUBLE wird
    zurÅckgeliefert.


ÅBEMERKUNGÄ

    keine
   
Å
DATEIEN
Ä
    libstr.inc
    libstr.a

Å
REFERENZ
Ä
strfroml,strcnvl

à
______________________________________________________________________
àlibstr   strtrm, strtrml, strtrmr, strptrm, strptrml, strptrmr  libstr

Ä

ÅNAMEÄ
Ö
    strtrm, strtrml, strtrmr,
    strptrm, strptrml, strptrmr - Zeichen aus Zeichenkette entfernen

Ä
ÅSYNTAXÄ

    #include <libstr.inc>

    BYTE *strtrm (str)
    BYTE *str;

    BYTE *strtrml (str)
    BYTE *str;

    BYTE *strtrmr (str)
    BYTE *str;

    BYTE *strptrm (str, junk)
    BYTE *str;
    BYTE *junk;

    BYTE *strptrml (str, junk)
    BYTE *str;
    BYTE *junk;

    BYTE *strptrmr (str, junk)
    BYTE *str;
    BYTE *junk;


ÅBESCHREIBUNGÄ

   Å strtrmÄ entfernt alle fÅhrenden und abschlieûenden Leerzeichen und
    Tabs von dem String str. ÅstrtrmlÄ und ÅstrtrmrÄ entfernen nur alle
    fÅhrenden bzw. alle abschlieûenden Leerzeichen und Tabs von str.
    ÅstrptrmÄ,Å strptrmlÄ und ÅstrptrmrÄ arbeiten analog, entfernen jedoch
    alle Zeichen von str, die sich auch in der Menge junk befinden.
    

ÅRETURNWERTÄ

    Es wird die Adresse der Zeichenkette str zurÅckgeliefert.


ÅBEMERKUNGÄ

    keine


ÅDATEIENÄ

    libstr.inc
    libstr.a

Å


à______________________________________________________________________
àlibstr   strtrm, strtrml, strtrmr, strptrm, strptrml, strptrmr  libstr

Å

REFERENZ
Ä
    strchr
























































à______________________________________________________________________
àlibstrstrupr,strnupr,strwupr,struprg,strnuprglibstr

Ö
Ä
ÅNAMEÄ

Ö    strupr,strnupr,strwupr,
struprg,strnuprg - Zeichenkette in Groûbuchstaben wandeln

Å
SYNTAX
Ä
    #include <libstr.inc>

    BYTE *strupr (str)
    BYTE *str;

    BYTE *strnupr (str,limit)
    BYTE *str;
WORDlimit;

    BYTE *strwupr (str)
    BYTE *str;

    BYTE *struprg (str)
    BYTE *str;

    BYTE *strnuprg (str,limit)
    BYTE *str;
WORDlimit;


ÅBESCHREIBUNGÄ

    ÅstruprÄwandeltalle(ASCII!)BuchstabenderZeichenkettestrin
Groûbuchstabenum.ÅstrnuprÄbetrachtetdabeidiemaximalersten
limitZeichenvonstr.ÅstrwuprÄbetrachtetnurdieWortanfÑnge
jedenWortes.WobeieinWortamAnfangderZeichenketteundnach
einerbeliebigenAnzahlvonLeerzeichenoderTabsoderNewlines
beginnt.BeiÅstruprgÄwerdenauchdiedeutschenUmlaute(Ñ,î,Å)
durché,ô,öersetzt.ÅstrnuprgÄbetrachtetwiederumnurdie
maximalerstenlimitZeichenvonstr.

Å
RETURNWERT
Ä
    Die Adresse der geÑndertenZeichenkette str wird zurÅckgeliefert.


ÅBEMERKUNG
Ä
keine


ÅDATEIENÄ

    libstr.inc
    libstr.a


ÅREFERENZÄ

    strlwr, strnlwr, strlwrg,strnlwrg
à______________________________________________________________________
àlibstr                      substr, subnstr                     libstr
Ä


ÅNAMEÄ
Ö
    substr, subnstr - Teilstring kopieren

Ä
ÅSYNTAXÄ

    #include <libstr.inc>

    BYTE *substr (dest, source, start, end)
    BYTE *dest, *source;
    WORD start, end;

    BYTE *subnstr (dest, source, start, length)
    BYTE *dest, *source;
    WORD start, length;


ÅBESCHREIBUNG

Ä   Å substrÄ kopiert den Teilstring der Zeichenkette source ab der
    Position start bis zur Position end in die Zeichenkette dest.
    ÅsubnstrÄ kopiert den Teilstring der Zeichenkette source ab der
    Position start mit der LÑnge length in die Zeichenkette dest.


ÅRETURNWERTÄ

    Es wird die Adresse der Ziel-Zeichenkette dest zurÅckgeliefert.


ÅBEMERKUNGÄ

    keine


ÅDATEIENÄ

    libstr.inc
    libstr.a


ÅREFERENZÄ

    strcpy, strncpy, strn0cpy, strcpyn, strncpyn














à______________________________________________________________________
àlibstr                  memchr, memcmp, memcpy                  libstr

Ä

ÅNAMEÄ
Ö
    memchr, memcmp, memcpy - Adreûbereiche kopieren und vergleichen

Ä
ÅSYNTAX

Ä    #include <libstr.inc>

    BYTE *memchr (buf, c, cnt)
    BYTE *buf;
    BYTE c;
    WORD cnt;

    WORD memcmp (mem1, mem2, len)
    BYTE *mem1;
    BYTE *mem2;
    WORD len;

    BYTE *memcpy (dest, source, len)
    BYTE *dest;
    BYTE *source;
    UWORD len;


ÅBESCHREIBUNG

Ä   Å memchrÄ durchsucht ab der Adresse buf maximal len Zeichen nach dem
    Auftreten des Zeichens c.Å memcmpÄ untersucht len Bytes ab Adresse
    mem1 mit den len Bytes ab Adresse mem2 auf Gleichheit. ÅmemcpyÄ
    kopiert exakt len Bytes ab Adresse source an die Adresse dest.
    

ÅRETURNWERTÄ

   Å memchrÄ returned mit der Adresse des gefundenen Zeichens oder NULP.
   Å memcmp Äliefert 0, wenn beide Adressbereiche identisch sind, sonst
    mit der Differenz des letzten verglichenen Zeichenpaares.Å memcpyÄ
    liefert die Adresse des Zielbereiches dest zurÅck.
    

ÅBEMERKUNGÄ

    Die FunktionenÅ memchrÄ,Å memcmpÄ undÅ memcpyÄ arbeiten analog zuÅ strchrÄ
   Å strcmp ÄundÅ strcpyÄ, erkennen als Ende jedoch nicht das Nullbyte, 
    sondern bearbeiten genau len Bytes.


ÅDATEIENÄ

    libstr.inc
    libstr.a

Å
REFERENZ
Ä
    strchr, strcmp, strcpy


à______________________________________________________________________Ä
8000100001\TERM1.IMG
Ä






















8000100001\TERM2.IMG























8000100001\TERM3.IMG

















à
àlibtermtgetentlibterm

Å

NAME
Ö
    tgetent  -  Termcap-Eintrag aus Termcap-Datei lesen

Ä
ÅSYNTAXÄ

    #include <libterm.inc>

    WORD  tgetent (capab, termname)
    BYTE *capab;
    BYTE *termname;


ÅBESCHREIBUNGÄ

ÅtgetentÄliestdieTermcap-DateiundsuchtnachdemEintragfÅr
denÅbergebenentermname.DerPfadderTermcap-Dateiwirdimall-
gemeinenÅberdieEnvironment-VariableÅTERMCAPÄangegeben.Ist
dieseVariablenichtvorhanden,sowirdzuerstinderDirectory
d:\etc\,dannin\etc\undsonstinderaktuellenDirectorynach
derTermcap-DateiÅtermcapÄgesucht(fÅr?NIXSysteme/etc/termcap).
oderinderaktuellenDirectoryunterdemNamentermcapoderÅber
IstTERMCAPkeinPfad,sountersuchtÅtgetentÄdieTERMCAPVariable,
obsiedirektdenTermcap-EintragenthÑlt.
    Der zu termname passende Eintrag wirdgesucht und wenn gefunden,
    in den Puffer capab (muss min.1024 Bytes gross sein) geschrieben.
    ZusÑtzlich wird ein Pointer auf capab erzeugt, der von den 
    anderen Termcap-Funktionen benutzt wird.


ÅRETURNWERTÄ

    1, wenn der Eintrag in den Puffer capab gelesen werden konnte,
    0, wenn der Eintrag und -1, wenn das Termcap-File nicht gefunden
    werden konnte.

Å
BEMERKUNGÄ

keine


ÅDATEIENÄ

    libterm.inc
    libterm.a
    libstr.a (strncmp, strcpy, strcmp, strlen)
             (getenv, fgets, fopen, fclose)


ÅREFERENZÄ

tgetnum,tgetstr,tgetflag





à______________________________________________________________________
àlibtermtgetnumlibterm


Å
NAME
Ä
    Ötgetnum  -  Numerischen Termcap-Eintrags-Feld-Wert suchenÄ


ÅSYNTAXÄ

    #include <libterm.inc>

    WORD  tgetnum (id)
    BYTE *id;


ÅBESCHREIBUNGÄ

    Die mit ÅtgetentÄ gelesene Termcap-Info kann mitÅ tgetnumÄ aufnume-
rische Werte angewendet werden. Der Wert des mit id bezeichneten
 Feldes wird zurÅckgeliefert.


ÅRETURNWERT

Ä    Wert des Feldes id, oder -1 im Fehlerfall.                  


ÅBEMERKUNG

Äkeine

Å
DATEIEN
Ä
    libterm.inc
    libterm.a
    libstr.a (strncmp)


ÅREFERENZ
Ä
tgetent,tgetstr,tgetflag

Å

















à______________________________________________________________________
àlibtermtgetflaglibterm

Ä

ÅNAMEÄ

Ö    tgetflag  -  Vorhandensein eines Termcap-Eintrags-Feldes testen

Ä
ÅSYNTAXÄ

    #include <libterm.inc>

    WORD  tgetflag (id)
    BYTE *id;


ÅBESCHREIBUNGÄ

    Die mit Åtgetent Ägelesene Termcap-Info kann mit ÅtgetflagÄ auf das
    Vorhandensein eines Feldes getestet werden.


ÅRETURNWERTÄ

    Ist das Feld im gelesen Termcap-Eintrag vorhanden, so wird 1
    zurÅckgeliefert. 0 wird geliefert, wenn das Feld nicht gefunden
    wurde, -1 im Fehlerfall.


ÅBEMERKUNGÄ

keine


ÅDATEIENÄ

    libterm.inc
    libterm.a
    libstr.a (strncmp)


ÅREFERENZÄ

tgetent,tgetstr,tgetnum


















à______________________________________________________________________
àlibtermtgetstrlibterm

Ä
Å
NAME
Ä
Ö    tgetstr  -  Alphanumerischen Termcap-Eintrags-Feld-Wert suchen

Ä
ÅSYNTAXÄ

    #include <libterm.inc>
    #include <stdio.h>

    WORD  tgetstr (id, area)
    BYTE *id;
    BYTE **area;

Å
BESCHREIBUNG
Ä
    Die mitÅ tgetentÄ gelesene Termcap-Info, kann mitÅ tgetstrÄ auf alpha-
numerische Felder angewendet werden. Die hinter dem Feldid ste-
hende Zeichenkette wird in area geschrieben und istzusÑtzlich
 auch der RÅckgabewert.


ÅRETURNWERTÄ

    Wert des Feldes id, oder NULL im Fehlerfall.                  


ÅBEMERKUNGÄ

keine


ÅDATEIENÄ

    libterm.inc
    stdio.h
    libterm.a
    libstr.a (strncmp)


ÅREFERENZÄ

tgetnum,tgetflag,tgetent















à______________________________________________________________________
àlibtermtgoto                          libterm

Ä
Å
NAME
Ä
Ö    tgoto  -  Cursor-Adressierungs-String erstellen

Å
SYNTAX
Ä
    #include <libterm.inc>
    #include <stdio.h>

    BYTE *tgoto (cm, destcol, destline)
    BYTE *cm;
    WORD destcol;
    WORD destline;


ÅBESCHREIBUNGÄ

    ÅtgotoÄ ermittelt anhand des CursorMotionStrings cm und der Åber-
    gebenen Koordinaten destcol und destline die Escape-Sequenz zum
    Adressieren des Cursors.


ÅRETURNWERTÄ

    Pointer auf die erzeugte lokal statische Escape-Sequenz oder
 "OOPS", falls ein Fehler aufgetreten ist (Parameter!).


ÅBEMERKUNGÄ

keine


ÅDATEIENÄ

    libterm.inc
    stdio.h
    libterm.a


ÅREFERENZÄ

















à______________________________________________________________________
àlibtermtputs                          libterm

Ä

ÅNAMEÄ
Ö
    tputs  -  String auf Bildschirm ausgeben

Ä
ÅSYNTAXÄ

    #include <libterm.inc>

    WORD tputs (cp, affcnt, outc)
    REGISTER BYTE  *cp;
    WORD      affcnt;
    WORD      (*outc)();


ÅBESCHREIBUNÄG

    Åtputs Ägibt die Zeichenkette cp unter Verwendung der Funktion outc
    auf dem Bildschirm aus. (Bedeutung von affcnt ?)


ÅRETURNWERTÄ

    Ohne Bedeutung.


ÅBEMERKUNG
Ä
keine


ÅDATEIENÄ

    libterm.inc
    libterm.a


ÅREFERENZ










Ä









à
______________________________________________________________________
àlibtermt_initlibterm

Å

NAME
Ö
    t_init  -  Terminal-Variablen und Terminal-Mode initialisieren

Ä
ÅSYNTAXÄ

    #include <libterm.inc>

    WORD  t_init ()                  


ÅBESCHREIBUNGÄ

    Åt_initÄ liest die Termcap (durch tgetent) und baut eine interne
    Struktur auf, um die t_-nums und t_-Strings zu initialisieren,
    damit sie von den t_xxx-Funktionen benutzt werden kînnen. Unter
    ?NIX-Systemen wird zusÑtzlich das Terminal-IO aufRaw-Mode
 gesetzt.


ÅRETURNWERTÄ

    0, wenn die Variablen initialisiert werden konnten und
    -1, wenn tgetent einen Fehler beim Lesen der Termcap geliefert
    hat.


ÅBEMERKUNG

Äkeine


ÅDATEIENÄ

    libterm.inc
    libterm.a
    libstr.a (strcpy)
             (getenv, malloc)


ÅREFERENZÄ

ÅÄt_exit,tgetent















à______________________________________________________________________
àlibtermt_exitlibterm


Ä
ÅNAMEÄ
Ö
    t_exit  -  Terminal-Mode zuruecksetzen
Ä

ÅSYNTAXÄ

    #include <libterm.inc>

    VOID  t_exit ()


ÅBESCHREIBUNGÄ

    Åt_exitÄ setzt den Terminal-Mode zurÅck (in den Zustand vor dem
    t_init()-Aufruf) und sendet den Terminal-Reinitialisierungs-
    String t_ir.


ÅBEMERKUNGÄ

keine


ÅDATEIENÄ

    libterm.inc
    libterm.a


ÅREFERENZÄ

    t_init
â

Ä























à______________________________________________________________________
àlibtermt_rawon,t_rawoff                    libterm

Ä

ÅNAMEÄ

   Ö t_rawon,t_rawoff - TerminalzwischenNormalundRaw umschaltenÄ


ÅSYNTAXÄ

    #include <libterm.inc>

    VOID  t_rawon ()
    VOID  t_rawoff ()


ÅBESCHREIBUNG

Ä    Åt_rawon Äsetzt das Terminal auf den Raw-Modus(bei ?NIX-Systemen).
Åt_rawoffÄschaltetdenModuswiederaus,dasTerminalbefindet
sichwiederimNormal-Modus.


ÅBEMERKUNG
Ä
Wirdnurbei?NIX-Systemeneingesetzt.


ÅDATEIEN

Ä    libterm.inc
    libterm.a


ÅREFERENZ
Ä
t_init
â

Ä










â











à______________________________________________________________________
àlibtermt_beep                         libterm
Ä

ÅNAMEÄ

    Öt_beep  -  Signalton auf Standard-Ausgabe ausgebenÄ

Å
SYNTAX
Ä
    #include <libterm.inc>

    VOID  t_beep ()


ÅBESCHREIBUNGÄ

   Å t_beep Ägibt den Signalton (bell, ^G) auf stdout aus.

Å
BEMERKUNGÄ

keine

Å
DATEIEN
Ä
    libterm.inc
    libterm.a


ÅREFERENZÄ

    




























à
______________________________________________________________________
àlibterm               t_cls,t_cleol,t_cleoslibterm
Ä


ÅNAMEÄ

    Öt_cls,t_cleol,t_cleos - Bildschirmbereiche lîschen
Ä
Å
SYNTAX
Ä
    #include <libterm.inc>

    VOID  t_cls ()

VOIDt_cleol()

VOIDt_cleos()


ÅBESCHREIBUNGÄ

   Å t_clsÄ lîscht den Bildschirm und positioniert den Cursor indie
 linke obere Ecke (0, 0). Åt_cleolÄ lîscht den Bildschirm vom Cursor
 bis zum Ende der ZeileÅt_cleosÄbiszumEndederSeite.



ÅBEMERKUNG

Äkeine


ÅDATEIENÄ

    libterm.inc
    libterm.a


ÅREFERENZÄ

t_goxy





















à______________________________________________________________________
àlibtermt_curson,t_cursoff,t_cursstatlibterm

Ä

ÅNAMEÄ
Ö
    t_curson,t_cursoff,
t_cursstat - Bildschirm-Cursor an-undausschalten

Ä
ÅSYNTAXÄ

    #include <libterm.inc>

    VOID  t_curson ()

VOIDt_cursoff()

BOOLt_cursstat()

Å
BESCHREIBUNG

Ä    Åt_cursonÄ schaltet den Bildschirm-Cursor anundÅt_cursoffÄschaltet
ihnwiederaus.MitÅt_cursstat()Äkannabgefragtwerden,obder
Cursorgeradeausgeschaltetist,oderan.


ÅRETURNWERTÄ

Åt_cursstat()ÄliefertTRUE,wennderCursorangeschaltetist,
FALSEsonst.


ÅBEMERKUNG
Ä
Åt_cursstat()Ä kann natÅrlich nur richtig arbeiten, wenn jedes An-/
Ausschalten des Cursors Åber die Funktionen Åt_curson()Ä und
 Åt_cursoff()Ä gesteuert wird.



ÅDATEIENÄ

    libterm.inc
    libterm.a


ÅREFERENZÄ














à______________________________________________________________________
àlibterm                    t_cblink, t_csteady                 libtermÄ


Å
NAMEÄ

   Ö t_cblink, t_csteady - Cursor-Blinken an- / ausschaltenÄ


ÅSYNTAXÄ

    #include <libterm.inc>

    VOID t_cblink()

    VOID t_csteady()


ÅBESCHREIBUNGÄ

   Å t_cblinkÄ schaltet das Blinken des Cursor ein und Åt_csteadyÄ schal-
tetdas Blinken wieder aus.


ÅBEMERKUNGÄ

    keine
    

ÅDATEIENÄ

    libterm.inc
    libterm.a


ÅREFERENZÄ

    

























à______________________________________________________________________
àlibtermt_getc                         libterm

Å
Ä
ÅNAMEÄ
Ö
    t_getc  -  Tastencode oder Konstante fuer Sondertaste liefern

Ä
ÅSYNTAXÄ

    #include <libterm.inc>

    WORD  t_getc ()

Å
BESCHREIBUNG
Ä
   Å t_getcÄ liefert den Ascii-Code einer betÑtigten Taste oder,falls
 es sich um eine Sonder-Taste handelt (Funktions-, Escape-, Cursor-
Tasten), eine in libterm.inc definierte Konstante zurÅck.Das oder
 die Zeichen (Sonder-Tasten) der Tasten werden dabei nicht geechot.


ÅRETURNWERTÄ

    Tastencode oder Konstante der Sonder-Taste.  


ÅBEMERKUNGÄ

keine


ÅDATEIENÄ

    libterm.inc
    libterm.a
    libstr.a (strfnd)


ÅREFERENZÄ

t_init



















à______________________________________________________________________
àlibtermt_goxy,t_chome,t_cup,t_cdown,t_cright,t_cleft   libterm

Ä

ÅNAMEÄ
Ö
    t_goxy,t_chome,t_cup,
t_cdown,t_cright,t_cleft  -  Bildschirm-Cursor positionieren

Å
SYNTAX
Ä
    #include <libterm.inc>

    VOID t_goxy (x, y)
    WORD x, y;

VOIDt_chome()

VOIDt_cup()

VOIDt_cdown()

VOIDt_cright()

VOIDt_cleft()

Å
BESCHREIBUNG
Ä
    Åt_goxyÄ positioniert den Cursor auf die Koordinaten x und y. Der
    Nullpunkt ist hierbei die linke obere Bildschirmecke (0,0). 
Åt_chomeÄpositioniertdenCursorindielinkeobereBildschirmecke
ohnedenBildschirmzulîschen.Åt_cupÄ,Åt_cdownÄ,Åt_crightÄundÅ
t_cleftÄpositionierendenCursorrelativzuraktuellenPosition
umeineZeilenachoben,bzw.umeineZeilenachunten,bzw.um
eineSpaltenachrechts,bzw.umeineSpaltenachlinks.  

Å
BEMERKUNG
Ä
keine

Å
DATEIEN
Ä
    libterm.inc
    libterm.a


ÅREFERENZÄ

    t_init,tgoto










à______________________________________________________________________
àlibtermt_setatt,t_invon,t_invofflibterm
Å

Ä
ÅNAMEÄ

Ö    t_setatt,t_invon,t_invoff - Terminal-Attribute setzen

Ä
ÅSYNTAXÄ

    #include <libterm.inc>

    WORD  t_setatt (newatt)
WORDnewatt;

WORDt_invon()

WORDt_invoff()


ÅBESCHREIBUNGÄ

   Å t_setatt Äsetzt entsprechend dem Parameter newatt die Terminal-
    attribute DIM, INV, BLK, UND, ALT, GRA oder NRM. Dabei wird
    versucht, die Ausgabe zu optimieren, d. h. mîglichst wenig bytes
    zu senden.Åt_invonÄundÅt_invoffÄschaltendenInvers-Modusan
bzw.aus.

    Dabei haben die Modes folgende Bedeutung:

        NRM - Normal
        DIM - Halbe Helligkeit
        BLK - Blinkend
        UND - Unterstrichen
        INV - Inverse Darstellung
        GRA -
        ALT -


ÅRETURNWERT
Ä
    ZurÅckgeliefert werden die akt. Attribut-Flags als Word.     


ÅBEMERKUNGÄ

Åt_invonÄundÅt_invoffÄsindalsMakrosdefiniertundaufÅt_setattÄ
abgebildet.
Å

DATEIEN

Ä    libterm.inc
    libterm.a







à
______________________________________________________________________Ä
àlibtermt_settwlibterm
Å

Ä
ÅNAMEÄ

Ö    t_settw-Tabulatorweitesetzen

Ä
ÅSYNTAXÄ

    #include <libterm.inc>

    VOID  t_settw (width)
WORDwidth;


ÅBESCHREIBUNGÄ

   Å t_settw Äsetzt dieinterneTabulatorweite(t_tw)aufdenWert
width.


ÅBEMERKUNGÄ

Åt_settwÄistalsMakroinlibterm.incdefiniert.
Å

DATEIEN

Ä    libterm.inc
    libterm.a






























à
______________________________________________________________________
àlibterm                 t_hline, t_vline, t_box                libterm
Ä


ÅNAMEÄ

    Öt_hline, t_vline, t_box - Linien und Boxen zeichnenÄ
    

ÅSYNTAXÄ

    #include <libterm.inc>

    VOID t_hline (col, row, width, mode, clear, chr)
    WORD col, row, width, mode;
    BOOL clear;
    BYTE chr;

    VOID t_vline (col, row, height, mode, clear, chr)
    WORD col, row, height, mode;
    BOOL clear;
    BYTE chr;

    VOID t_box (col, row, width, height, mode, clear, chr)
    WORD col, row, width, height, mode;
    BOOL clear;
    BYTE chr;


ÅBESCHREIBUNGÄ

    Åt_hlineÄ gibt eine horizontale Linie auf dem Bildschirm aus. Dabei
    beginnt die Linie ab col, row mit der LÑnge width. AbhÑngig von
    mode wird die Linie mit unterschiedlichen (Grafik-)Zeichen be-
    schrieben. mode kann einen der untenstehenden Werte annehmen:

           0 : Leer, keine Grafik, nur Leerzeichen
           1 : --- Grafik 
           2 : +-+ Grafik 
           3 : Grafik mit Zeichen chr        
           4 : Halbgrafik (linea fuer GEMDOS)

    Wenn clear = TRUE ist, dann wird bei mode 4 und GEMDOS der Bereich
    zuerst durch Leerzeichen Åberschrieben.
    MitÅ t_vlineÄ wird eine vertikale Linie mit der Hîhe height beschrie-
    ben. Åt_box Äbeschreibt eine Box mit der Breite width und der Hîhe
    height.


ÅBEMERKUNGÄ

    Unter GEMDOS wird bei mode 4 versucht die Grafik durch LineA-
    Linien zu ersetzen.
    

ÅDATEIENÄ

    libterm.inc
    libterm.a

Å
REFERENZÄ

à______________________________________________________________________Ä
8000100001\MENU1.IMG
Ä
























8000100001\MENU2.IMG



























8000100001\MENU3.IMG











à
àlibmenupmexec                         libmenu
Ä

Å
NAME
Ö
    pmexec  -  Popup-Menu aufbauen und ausfÅhren
Ä

ÅSYNTAXÄ

    #include <popmenu.inc>

    BYTE *pmexec (menup, col,row, first, retkeyp, submenu)
    PM   *menup;
    WORD  col;
    WORD  row;
    BYTE *first;
    WORD *retkeyp;
    BOOL  submenu;

Å
BESCHREIBUNG
Ä
   Å pmexecÄ ist die Hauptfunktion des Åpopup-MenÅsÄ. Sie steuert den
    gesammten MenÅ-Ablaub durch Aufruf mehrerer Unterfunktionen.
    Ein MenÅ ist eine Menge von einzelnen MenÅpunkten, die durch
    die Cursortasten angesprungen und durch die RETURN-Taste
    selektiert werden kînnen. Die MenÅpunkte werden untereinander
    dargestellt. Sind mehr MenÅeintrÑge vorhanden, als Platz angege-
    ben ist (pm_height), so wird das MenÅ in einzelne Seiten aufge-
    teilt. Um die MenÅeintrÑge wird ein Rahmen gezogen, in der ober-
    sten Zeile wird der MenÅtitel, falls vorhanden, zentriert ange-
    zeigt.

    Die Åbergebenen Parameter im einzelnen.    
    menup ist dabei ein Zeiger auf eine MenÅ-Struktur der Form:

    typedef struct
    {
       BYTE *pm_title;   /* Titel des MenÅs */
       WORD  pm_width;   /* Breite des MenÅs zwischen beiden Seiten */
       WORD  pm_height;  /* Hîhe des MenÅs zwischen beiden Linien */
       WORD  pm_size;    /* Anzahl der MenÅ-EintrÑge */
       PME  *pm_entries; /* Feld der einzelnen EintrÑgen */
    } PM;

    Die einzelnen MenÅ-EintrÑge haben dabei folgenden Aufbau:
    
    typedef struct
    {
       BYTE *pme_text;   /* Anzeigetext des MenÅ-Eintrages */
       WORD  pme_type;   /* Typ des MenÅ-Eintrages */
       BYTE *pme_ret;    /* Returnwert oder Funktion oder UntermenÅ */
       BYTE *pme_param;  /* Parameter, wenn pme_ret Funktion oder */
    } PME;               /* UntermenÅ ist. */







à______________________________________________________________________
àlibmenupmexec                         libmenu
Ä


    pme_type kann dabei folgende Werte annehmen:
    
       ÅPMVALUEÄ:   in pme_ret ist ein String vorhanden, der bei Aktivie-
                  rung des Eintrages zurÅckgeliefert wird.
       ÅPMPROCÄ:    bei Selektion des MenÅeintrages wird eine Prozedur
                  aufgerufen, das MenÅ jedoch nicht verlassen.
       ÅPMFUNCÄ:    in pme_ret ist die Adresse einer Funktion vom Typ
                  BYTE * vorhanden. Bei Selektion des MenÅeintrages
                  wird die Funktion ausgefÅhrt und ihr Wert zurÅckge-
                  liefert. Der Funktion werden dabei pme_param, 
                  ein Pointer auf die MenÅstruktur und ein Pointer
                  auf den aktivierten MenÅeintrag Åbergeben.
       ÅPMMENUÄ:    pme_ret enthÑlt die Adresse einer MenÅstruktur.
                  Bei Auswahl dieses Eintrages wird ein UntermenÅ
                  aufgebaut und beim Beenden dieses MenÅs, der Wert
                  zurÅckgeliefert (Rekursion). Dem UntermenÅ wird
                  pme_param als first Åbergeben.

    ZusÑtzlich muû pme_type entweder mit ÅPMSELECTÄ oder ÅPMDESELÄ ver-
    odert werden.
    Bei PMSELECT darf der betroffene MenÅeintrag selektiert werden,
    bei PMDESEL wird er zwar angezeigt, kann jedoch nicht durch
    RETURN aktiviert werden.

    row und col sind die Zeilen- und Spaltenposition der linken oberen
    Ecke der Umrahmung. Wenn first ungleich NULP ist, dann wird in den
    MenÅ-EintrÑgen nach dem Text gesucht, der mit dem Text von first
    beginnt. Auf diesen Eintrag wird dann der Cursor zuerst positio-
    niert. first braucht dabei nicht den gesammten Text des gewÅnschten
    Eintrages enthalten, die ersten Buchstaben genÅgen (Signifikanz
    beachten!); Groû-/Kleinschrift wird bei dem Suchen nicht berÅck-
    sichtigt (strnicmp).
    In retkeyp ist der Code der Taste enthalten, die das Beenden des
    MenÅs hervorrief.
    Mit submenu = FALSE wird der Funktion pmexec mitgeteilt, daû es
    sich bei dem Åbergebenen Menue um das Hauptmenue handelt, die
    Taste CursorLeft demnach nicht zum Beenden des MenÅs benutzt
    werden kann.    

   Å Die Tasten zum Bedienen des MenÅsÄ:
    
    Mit der Cursortaste DOWN (bzw. UP) kann von einem Menueintrag zum
    nÑchsten (vorherigen) MenÅeintrag positioniert werden.
    Die Cursortaste LEFT kann nur bedient werden, wenn der aktuelle
    MenÅeintrag vom Typ PMMENU ist, also ein UntermenÅ enthÑlt.
    Die Cursortaste RIGHT wird nur akzeptiert, wenn es sich bei dem
    aktuellen MenÅ um ein UntermenÅ handelt.
    Die RETURN und die ENTER Tasten selektieren den aktuellen Eintrag.
    Dabei wirdÅ pmexec Ämit dem Wert von pme_ret oder dem Wert der
    Funktion in pme_ret oder dem Wert des UntermenÅs in pme_ret ver-
    lassen. Ist der MenÅeintrag vom Typ PMPROC, so wird zwar die
    Prozedur in pme_ret ausgefÅhrt,Å pmexecÄ jedoch nicht verlassen.
    Cursor HOME positioniert den Cursor auf den ersten Eintrag.
    Die Leertaste versucht zuerst ein UntermenÅ aufzurufen (Cursor
    RIGHT) oder bei Miûerfolg den nÑchsten Eintrag anzuspringen
    (Cursor DOWN).



à______________________________________________________________________
àlibmenupmexec                         libmenu
Ä


    Die Backspace Taste versucht zuerst zum hîher liegenden MenÅ zu
    springen oder, falls nicht vorhanden (akt. MenÅ ist HauptmenÅ)
    den vorherigen MenÅeintrag anzuspringen.
    Wird die ESCAPE Taste 2 mal betÑtigt, so wird pmexec abgebrochen
    und NULP zurÅckgeliefert.
    FÅralle anderen Eingaben (soweit zwischen ASCII 'A' und 'z')
    wirdversucht, einen Eintrag zufinden, dessen Text mit dem ent-
sprechenden Buchstaben anfÑngt.Der Cursor wird dann auf diesen
 Eintrag positioniert.


ÅBEMERKUNGÄ

VordemAufrufvonÅpmexecÄmuûdasTerminalmitÅt_initÄinitiali-
siertwerden.


ÅRETURNWERTÄ

    Wert von pme_ret (pme_type = PMVALUE), oder Wert der Funktion in
    pme_ret (pme_type = PMFUNC), oder Wert des UntermenÅs in pme_ret
    (pme_type = PMMENU) oder NULP bei Abbruch durch ESCAPE (retkeyp =
    27) bzw. bei Auftreten eines Fehlers (retkeyp = -1).


ÅDATEIENÄ

    popmenu.inc
    stdio.h
    libmenu.a
    libstr.a
    libterm.a
    termcap


ÅREFERENZÄ

    pmselect,t_init,t_exit,t_getc





















à______________________________________________________________________
àlibmenupmexec                         libmenu
Ä


ÅBEISPIELÄ

    #include <stdio.h>
    #include <popmenu.inc>

    BYTE *functel();
    BYTE *selectall();

    extern PM testmenu;

    PME vorn_ent[] =
       {
          { "Alois",  (PMVALUE | PMSELECT), "Alois", NULP },
          { "Sandro", (PMVALUE | PMSELECT), "Sandro", NULP },
          { "Werner", (PMMENU | PMSELECT), (BYTE *) &testmenu, NULP },
          { "Meier", (PMVALUE | PMSELECT), "Meier", NULP }
       };
    PM vornmenu =
    {
       "Vornamen", 10, 6, PMTABSIZE (vorn_ent), vorn_ent
    };
    
    PME test_ent[] =
       {
          { "Name", PMVALUE | PMSELECT, "Name select", NULP },
          { "Gebname", PMVALUE | PMSELECT, "Gebname", NULP },
          { "Vorname", PMMENU | PMSELECT, (BYTE *) &vornmenu, "san" },
          { "Alter", PMMENU | PMSELECT, (BYTE *) &vornmenu, NULP },
          { "Strasse", PMVALUE | PMSELECT, "Strasse", NULP },
          { "Bezirk", PMVALUE | PMSELECT, "Bezirk", NULP },
          { "Beruf", PMVALUE | PMSELECT, "Beruf", NULP },
          { "Select", PMPROC | PMSELECT, selectall, "" }
       };
       
    PM testmenu = 
    {
       "Testmenu", 12, 7, PMTABSIZE (test_ent), test_ent
    };
    
    BYTE *selectall (dummy, menup)
    BYTE *dummy;
    PM *menup;
    {
       pmselect (menup, "", TRUE);
       return ("Alle Eintraege selektiert!");
    }

    main ()
    {
       BYTE *ret;
       WORD retkey;
       
       t_init();
       ret = pmexec (&testmenu, 5, 7, "Beruf", &retkey, !ISSUBMENU);
       printf ("'%s'\n", (retkey == 27 ? "Abbruch" : ret));
       t_getc();
       t_exit();
    }

à______________________________________________________________________
àlibmenupmselect,PMSelect,PMDesel    libmenu
Ä


ÅNAMEÄ
Ö
    pmselect,PMSelect,
PMDesel -  Popup-MenÅ-EintrÑge selektieren / deselektieren
Ä

ÅSYNTAXÄ

    #include <popmenu.inc>

    WORD pmselect (menup, text, select)
    PM   *menup;
    BYTE *text;
    BOOL  select;

    WORD PMSelect (menup, text)
    PM   *menup;
    BYTE *text;

    WORD PMDesel (menup, text)
    PM   *menup;
    BYTE *text;
    
Å
BESCHREIBUNG
Ä
   Å pmselectÄ selektiert oder deselektiert MenueintrÑge. Deselektierte
 MenueintrÑge werden zwar angezeigt, kînnten jedoch nicht mehr Åber
 RETURN (z. B.) ausgewÑhlt werden. Bei select = TRUE werden alle
 EintrÑge selektiert, deren Anzeigetext mit text gematched werden
 kînnen (text = "" -> alle selektieren).FÅr select = FALSE werden
 die entsprechenden EintrÑge deselektiert.
   Å PMSelectÄ und ÅPMDeselÄ sind als Makros in popmenu.inc definiert und
 haben bis auf den letzten Parameter die gleiche Syntax.


ÅRETURNWERTÄ

    Anzahl der betroffenen EintrÑge, wobei bereits selektierte (bzw.
    deselekt.) nicht nochmal selektiert (bzw. deselekt.) werden.
    
Å
BEMERKUNGÄ

keine

Å
DATEIEN
Ä
    popmenu.inc, libmenu.a, libstr.a,libterm.a,termcap


ÅREFERENZ
Ä
    pmexec
à



______________________________________________________________________
8000100001\DATA1.IMG
à
























8000100001\DATA2.IMG



























8000100001\DATA3.IMG












àlibdata                           stack                        libdata
Ä

Å
NAME
Ö
    stack - Funktionen zum Manipulieren der Datenstruktur stack
Ä
Å
BESCHREIBUNG
Ä
    Mithilfe der Stack-Funktionen kînnen Stack-Datenstrukturen aufge-
    baut und verÑndert werden.
    Ein Stack muû immer erst durch ÅstacknewÄ alloziert werden. Der 
    Pointer, der von stacknew geliefert wird, muû den anderen Stack-
    funktionen als Parameter Åbergeben werden. Der Pointer zeigt auf
    eine Stack-Typstruktur mit folgendem Aufbau:
    
    struct _stk
    {
       BYTE  *stk_name;      /* Name des Stacks                     */
       STE   *stk_top;       /* Zeiger auf oberstes Stack-Element   */
       WORD   stk_flag;      /* Attribut-Flag des Stacks            */
       WORD   stk_mdepth;    /* max. Tiefe des Stacks               */
       WORD   stk_cdepth;    /* akt. Tiefe des Stacks               */
    };
    typedef struct _stk  STK;

    Durch die OperationenÅ stackpushÄ undÅ stackpopÄ kînnen Elemente auf
    den Stack gepackt bzw. vom Stack entfernt werden. Die Elemente
    kînnen dabei unterscheidlichen Typs sein; der Typ des zu pushenden
    Elements wird der Operation ÅstackpushÄ Åbergeben und vom Stack
    selbst verwaltet. Der Operation ÅstackpopÄ muû dann ein Zeiger auf
    eine dem Typ entsprechende Speichervariable Åbergeben werden.
    MitÅ stacktypeÄ kann der Typ des Top-Elementes erfragt werden. Dabei
    kann der Typ einen der unterstehenden Werte annehmen:
Å    
        STKBYTE        char                       
        STKBOOL        short int                  
        STKWORD        short int                  
        STKUWORD       unsigned short int         
        STKLONG        long int                   
        STKULONG       unsigned long int                         
        STKFLOAT       float                                     
        STKDOUBLE      long float                                
        STKSTRING      char *
        STKPOINTER     char * oder int * oder ...
Ä
    Wird beiÅ stacknewÄ die Grîûe des Stacks mit > 0 angegeben, so wird
    damit die maximale Tiefe des Stack festgelegt, wird als Grîûe 0
    Åbergeben, so kann der Stack beliebig wachsen (nur durch Speicher-
    platz begrenzt).
    Zum Freigeben des vom Stack allozierten Speicherbereiches wird
   Å stackdelÄ aufgerufen.
    
Å
DATEIEN
Ä
    stack.inc   
    libdata.a


à
______________________________________________________________________
àlibdata                    stacknew, StackNew                  libdataÄ


Å
NAMEÄ

   Ö stacknew, StackNew - Stackstruktur erzeugenÄ

Å
SYNTAXÄ

    #include <stack.inc>

    STK *stacknew (name, flag, depth)
    BYTE *name;
    WORD flag;
    WORD depth;

    STK *StackNew ()

Å
BESCHREIBUNGÄ

    MitÅ stacknewÄ wird der Speicherplatz fÅr eine neue Stackstruktur
    alloziert. Der Pointer, der vonÅ stacknewÄ bzw. vonÅ StackNewÄ gelie-
    fert wird, ist den anderen Stack-Funktionen als Parameter (handle)
    zu Åbergeben. name ist eine Zeichenkette, die beiÅ stackshowÄ als
    Titel angezeigt, ansonsten jedoch nicht ausgewertet wird (kann
    auch leer "" sein). FÅr flag kann entwederÅ STKNORMALÄ oder
   Å STKVARDEPTHÄ angegeben werden. Bei öbergabe vonÅ STKVARDEPTHÄ als
    flag wird die Tiefe des Stacks nicht bzw. nur durch den Speicher-
    platz begrenzt. depth ist die Maximal-Tiefe des Stacks, falls
    als flag ÅSTKNORMALÄ angegeben wird.Å StackNewÄ arbeitet wie ÅstacknewÄ,
    verlangt jedoch keine Parameter und erzeugt eine Stack-Struktur
    ohne Namen (name = "") und mit variabler Tiefe (ÅSTKVARDEPTHÄ).

Å
RETURNWERTÄ

    Pointer auf die neue Stack-Struktur.


ÅBEMERKUNGÄ

   Å StackNewÄ ist als Macro in stack.inc definiert und wird auf
    ÅstacknewÄ abgebildet.
    

ÅBEISPIELÄ

    ...
    
    STK *stackp;

    if ((stackp = stacknew ("Titel", STKVARDEPTH, 0)) == STKNULP)
    {
       fprintf (stderr, "Fehler beim Neuanlegen eines Stacks\n");
       exit (-1);
    }
    
    ...

    
à______________________________________________________________________
àlibdata                    stacknew, StackNew                  libdataÄ


Å
DATEIENÄ

    stack.inc
    libdata.a

Å
REFERENZÄ

    stackdel


















































à______________________________________________________________________
àlibdata                         stackdel                       libdataÄ



ÅNAMEÄ

   Ö stackdel - Stackstruktur entfernenÄ


ÅSYNTAXÄ

    #include <stack.inc>

    VOID stackdel (stackp)
    STK  *stackp;


ÅBESCHREIBUNG

    stackdelÄ entfernt alle Stackelemente und die Struktur selbst.


ÅBEMERKUNGÄ

    keine
    

ÅBEISPIELÄ

    ...
    
    extern STK *stackp;

    if (stackempty (stackp))
       stackdel (stackp);
    
    ...
    

ÅDATEIENÄ

    stack.inc
    libdata.a


ÅREFERENZÄ

    stackempty, stackpop















à______________________________________________________________________
àlibdata   stackpush, PushBYTE, PushWORD, PushBOOL, PushLONG    libdataÄ



ÅNAMEÄ
Ö
    stackpush, PushBYTE, PushWORD, PushBOOL, PushUWORD,
    PushLONG, PushULONG, PushFLOAT, PushDOUBLE, PushSTRING,
    PushPOINTER  -  Element auf Stack pushen (legen)Ä


ÅSYNTAXÄ

    #include <stack.inc>

    BOOL stackpush (stp, type, buf)
    STK  *stp;
    WORD type;
    VARTYPE buf;

    BOOL PushBYTE (stp, chr)
    STK  *stp;
    BYTE chr;

    BOOL PushWORD (stp, wrd)
    STK  *stp;
    WORD wrd;

    BOOL PushUWORD (stp, uwrd)
    STK  *stp;
    UWORD uwrd;

    BOOL PushBOOL (stp, bool)
    STK  *stp;
    BOOL bool;

    BOOL PushLONG (stp, lng)
    STK  *stp;
    LONG lng;

    BOOL PushULONG (stp, ulng)
    STK  *stp;
    ULONG ulng;

    BOOL PushFLOAT (stp, flt)
    STK  *stp;
    FLOAT flt;

    BOOL PushDOUBLE (stp, dbl)
    STK  *stp;
    DOUBLE dbl;

    BOOL PushSTRING (stp, str)
    STK  *stp;
    BYTE *str;

    BOOL PushPOINTER (stp, ptr)
    STK  *stp;
    BYTE *ptr; (WORD *ptr; ...)




à______________________________________________________________________
àlibdata   stackpush, PushBYTE, PushWORD, PushBOOL, PushLONG    libdataÄ



ÅBESCHREIBUNGÄ

    MitÅ stackpushÄ kînnen Elemente (Konstanten und Variablen) belie-
    bigen Typs auf den Stack stackp gepusht (gelegt) werden. Mit type
    wird ÅstackpushÄ der Typ des zu pushenden Elementes mitgeteilt
    (ÅSTKBYTE, STKBOOL, STKWORDÄ, ...).Å PushBYTEÄ, ÅPushWORDÄ, ... haben
    die gleiche FunktionalitÑt wie ÅstackpushÄ, benîtigen jedoch nicht
    den Typ des Elementes, da implizit im Aufruf enthalten.
    

ÅBEMERKUNGÄ

    ÅPushBYTEÄ, ÅPushWORDÄ, ... sind als Macros in stack.inc definiert
    und werden aufÅ stackpushÄ abgebildet.
    

ÅBEISPIELÄ

    ...
    
    extern STK *stackp;
    WORD wrd = 120;
    BYTE str[80];

    if (stackpush (stackp, STKBYTE, 'b') != TRUE)
       fprintf (stderr, "Fehler beim Pushen von 'b'\n");
    if (PushWORD (stackp, wrd) != TRUE)
       fprintf (stderr, "Fehler beim Pushen von '%d'\n", wrd);
    scanf ("%s", str);
    if (PushSTRING (stp, str) != TRUE)
       fprintf (stderr, "Fehler beim Pushen von '%s'\n", str);
    
    ...
    

ÅDATEIENÄ

    stack.inc
    libdata.a


ÅREFERENZÄ

    stackpop, stacktop














à
______________________________________________________________________
àlibdata                    stackpop, stacktop                  libdataÄ



ÅNAMEÄ
Ö
    stackpop, stacktop - Wert des obersten Stackelements holenÄ

Å
SYNTAXÄ

    #include <stack.inc>

    BOOL stackpop (stp, buf)
    STK  *stp;
    BYTE *buf; (bzw. WORD *buf; bzw. LONG *buf; ...)

    BOOL stacktop (stp, buf)
    STK  *stp;
    BYTE *buf; (bzw. WORD *buf; bzw. LONG *buf; ...)

Å
BESCHREIBUNGÄ

   Å stackpop Äliefert den Wert des obersten Stackelementes im Puffer
    buf. Dabei wird eine implizite Typumwandlung entsprechend dem
    Typ des Elements vorgenommen. Nach dem FÅllen des Puffers wird
    das Element vom Stack entfernt (gepopt).Å stacktopÄ liefert eben-
    falls das oberste Element im Puffer buf, entfernt es jedoch nicht
    vom Stack.

Å
RETURNWERTÄ

   Å stackpopÄ undÅ stacktopÄ liefern TRUE, wenn der Stack nicht leer ist,
    FALSE sonst.


ÅBEMERKUNGÄ

    keine
    





















à______________________________________________________________________
àlibdata                    stackpop, stacktop                  libdataÄ



ÅBEISPIELÄ

    ...
    
    VOID test (stackp)
    STK *stackp;
    {
       WORD  wrd;
       LONG  lng;
       BYTE  chr;
       BOOL  ret;
        
       ...

       if (!stackempty (stackp))
          if (stacktype (stackp) == STKWORD)
             stackpop (stackp, &wrd);
       switch (stacktype (stackp))
       {
          case STKBYTE:
             ret = stackpop (stackp, &chr);
             break;
          case STKLONG:
             ret = stackpop (stackp, &lng);
             break;
          case STKEMPTY:
             printf ("Fehler: Stack ist leer\n");
             break;
       }
       if (!ret)
          printf ("Fehler beim Popen, Stack ist leer\n");
       else
          ...
    }
    
    ...
    

ÅDATEIENÄ

    stack.inc
    libdata.a


ÅREFERENZÄ

    stacknew, stackpush












à______________________________________________________________________
àlibdata                        stackshow                       libdataÄ



ÅNAMEÄ

   Ö stackshow - Attribute und Inhalte des Stacks anzeigenÄ


ÅSYNTAXÄ

    #include <stack.inc>

    VOID stackshow (stp)
    STK  *stp;


ÅBESCHREIBUNGÄ

    ÅstackshowÄ gibt die Attribute, also den Namen, das Attribut-Flag
    und die Tiefe des Stacks, sowie die einzelnen Elemente des Stacks
    auf dem Bildschirm aus. Dabei werden die Elemente durch '>' und 
    '<' eingefaût. Die Elemente werden entsprechend ihrem Typ in eine
    lesbare Form gebracht. Das Top-Element wird als erstes angezeigt.


ÅBEMERKUNGÄ

    keine
    

ÅBEISPIELÄ

    ...
    
    extern STK *stackp;

    stackshow (stackp);
    
    ...
    

ÅDATEIENÄ

    stack.inc
    libdata.a


ÅREFERENZÄ

    stacknew, stacktop












à______________________________________________________________________
àlibdata                        stackempty                      libdataÄ



ÅNAMEÄ

    Östackempty - PrÅfen, ob Stack leer istÄ


ÅSYNTAXÄ

    #include <stack.inc>

    BOOL stackempty (stackp)
    STK  *stackp;


ÅBESCHREIBUNGÄ

    ÅstackemptyÄ prÅft, ob der Stack mit der Adresse stackp leer ist,
    also keine Elemente enthÑlt.


ÅRETURNWERTÄ

   Å stackemptyÄ liefert TRUE, wenn Stack stackp leer ist, FALSE sonst.


ÅBEMERKUNGÄ

    ÅstackemptyÄ ist als Macro in stack.inc definiert.
    

ÅBEISPIELÄ

    ...
    
    VOID test (stackp)
    STK *stackp;
    {
       ...

       if (stackempty (stackp))
          printf ("Stack ist leer\n");
       else
          ...
    }
    
    ...
    

ÅDATEIENÄ

    stack.inc
    libdata.a


ÅREFERENZÄ

    stacktop, stackdepth



à______________________________________________________________________
àlibdata                        stackdepth                      libdataÄ



ÅNAMEÄ

    Östackdepth - Anzahl der Stackelemente liefernÄ


ÅSYNTAXÄ

    #include <stack.inc>

    WORD stackdepth (stackp)
    STK  *stackp;


ÅBESCHREIBUNG

    stackdepthÄ liefert die Anzahl der Stackelemente (Tiefe des Stack).


ÅRETURNWERTÄ

    Die Anzahl der Stackelemente als WORD.


ÅBEMERKUNGÄ

    ÅstackdepthÄ ist als Macro in stack.inc definiert.
    

ÅBEISPIELÄ

    ...
    
    extern STK *stackp;

    printf ("Hîhe des Stacks: %d\n", stackdepth (stackp));
    
    ...
    

ÅDATEIENÄ

    stack.inc
    libdata.a


ÅREFERENZÄ

    stackempty











à______________________________________________________________________
àlibdata                         stacktype                      libdataÄ



ÅNAMEÄ

   Ö stacktype - Typ des obersten Stackelements liefernÄ


ÅSYNTAXÄ

    #include <stack.inc>

    WORD stacktype (stackp)
    STK  *stackp;


ÅBESCHREIBUNG

    stacktypeÄ testet, ob der Stack nicht leer ist und liefert dann
    den Typ des Top-Elements von stackp.


ÅRETURNWERTÄ

   Å stacktypeÄ liefert ÅSTKBYTE, STKBOOLÄ, ... wenn der Stack nicht leer
    ist, sonstÅ STKEMPTYÄ.


ÅBEMERKUNG

    stacktypeÄ ist als Macro in stack.inc definiert.
    

ÅBEISPIELÄ

    ...
    
    extern STK *stackp;
    BYTE chr;

    switch (stacktype (stackp))
    {
       case STKBYTE:
          stacktop (stackp, &chr);
          break;
       ...
    }
    ...
    

ÅDATEIENÄ

    stack.inc
    libdata.a


ÅREFERENZÄ

    stackempty



à______________________________________________________________________
àlibdata                        stackname                       libdataÄ



ÅNAMEÄ

   Ö stackname - Name des Stacks liefernÄ


ÅSYNTAXÄ

    #include <stack.inc>

    BYTE *stackname (stackp)
    STK  *stackp;


ÅBESCHREIBUNGÄ

    ÅstacknameÄ liefert den Namen des Stacks, der bei ÅstacknewÄ mit Åber-
    geben wurde.


ÅRETURNWERTÄ

    Der Name des Stacks wird zurÅckgeliefert.


ÅBEMERKUNGÄ

    Åstackname Äist als Macro in stack.inc definiert.
    

ÅBEISPIELÄ

    ...
    
    extern STK *stackp;

    printf ("Name des Stacks: %s\n", stackname (stackp));
    
    ...
    

ÅDATEIENÄ

    stack.inc
    libdata.a


ÅREFERENZÄ

    stacknew










à______________________________________________________________________
àlibetc                       getarg, GetArg                     libetc
Ä


ÅNAMEÄ

Ö    getarg, GetArg - Programm-Argumente prÅfen und Variablen zuordnen

Å
SYNTAX
Ä
    #include <getarg.inc>

    BOOL getarg (argc, argv, argtab, tabsize, flag, usage, exitval)
    WORD *argc;
    BYTE **argv;
    ARG  *argtab;
    WORD tabsize;
    WORD flag;
    BYTE *usage;
    WORD exitval;

    BOOL GetArg (argc, argv, argtab)
    WORD *argc;
    BYTE **argv;
    ARG  *argtab;


ÅBESCHREIBUNGÄ

    ÅgetargÄ bearbeitet den Programm-Argumentvektor argv und untersucht
    ihn in Hinsicht auf vorhandene Options-Argumente. Options-Argumen-
te werden durch ein '-' eingeleitet, gefolgt von einem Buchstaben.
    Diesem Buchstaben folgt der Wert des Options-Arguments (nicht
    durch Blank getrennt!). Der Wert eines Options-Arguments wird
    einer vorher vereinbarten Variablen zugeordnet. Beispiel:

        progname -l72 -b -otest

    oder auch

        progname -l72botest .

    In der Struktur argtab sind die gÅltigen (mîglichen) Optionen und
    die Adressen ihrer zugeordneten Variablen verzeichnet. Die Struk-
    tur argtab unterliegt folgender Definition (s. a. getarg.inc):
Å    
        typedef struct
        { 
           BYTE  arg_arg;      /* Options-Argument-Zeichen  */
           BYTE  arg_type;     /* Typ des Options-Arguments */
           WORD *arg_varaddr;  /* Adresse der Variablen     */
           BYTE *arg_errmsg;   /* Fehlermeldungstext        */
        } 
        ARG;
Ä







à______________________________________________________________________
àlibetc                       getarg, GetArg                     libetc
Ä


    In arg_arg muû der Buchstabe des Options-Arguments stehen. In
    arg_type ist der Type des Options-Arguments beschrieben. Folgende
    Typen werden erkannt:
Å
        IARG  =   Integer (WORD) 
        BARG  =   Boolescher (BOOL)
        CARG  =   Character (BYTE) 
        SARG  =   String (BYTE *)  
        PARG  =   Funktion (*WORD) ()
        NARG  =   Filename (BYTE *) 
        LARG  =   Long Integer (LONG)
        DARG  =   Double (DOUBLE)
    
Ä    Die Variable, deren Adresse in arg_varaddr vorliegt, muû vom Typ
    des Options-Arguments sein. Eine Besonderheit ist bei einem 
    Options-Argument vom Typ PARG zu beachten. Wird eine Option mit
    diesem Typ zur runtime dem Programm Åbergeben, so wird die Funk-
    tion, deren Adresse in arg_varaddr steht, aufgerufen. ZusÑtzlich
    wird dieser Funktion der rest der Zeichenkette, die durch das
    Argument eingeleitet wurde, als Parameter mit Åbergeben.
    Die Zeichenkette arg_errmsg kann einen Fehlertext enthalten, der
    bei der Anzeige der Liste aller mîglichen Options-Argumente (s.u.)
    mit ausgegeben wird.
    Korrekt erkannte Options-Argumente werden aus dem Argument-Vektor
    argv entfernt und argc entsprechend um die Anzahl entfernter
    Argumente vermindert. tabsize enthÑlt die Anzahl mîglicher 
    Options-Argumente = Anzahl EintrÑge in argtab. Mit flag kann Ein-
    fluû auf die SensibilitÑt von ÅgetargÄ bei der Interpretation der
    Options-Argumente genommen werden. Dabei kann flag eine Veroderung
    aus der Menge der untenstehenen Flags sein:
Å    
        GAEXIT   =  Flag fÅr Programmabbruch, wenn falsche Option
        GABREAK  =  Flag fÅr Prozedurabbruch, wenn falsche Option
        GAUSAGE  =  Flag fÅr Anzeige des usage, wenn falsche Option
        GANOCASE =  Flag fÅr VernachlÑssigung von Groû-/Kleinschrift
Ä
    Mit usage wird ein Text (String) Åbergeben, der angezeigt wird,
    falls eine falsche Option erkannt wurde (nur bei gesetztem Flag
    GAUSAGE).
    Mit exitval kann Einfluû auf den exit-Status des Programmes ge-
    nommen werden, wenn eine falsche Option erkannt wurde und das
    flag GAEXIT in flag gesetzt ist.
   Å GetArgÄ hat die gleiche FunktionalitÑt wieÅ getargÄ, jedoch werden
    die letzten Parameter durch Default-Werte ersetzt (getarg.inc).


ÅRETURNWERTÄ

   Å getargÄ undÅGetArgÄliefern TRUE, wenn alle Option-Argumente korrekt
 erkannt worden sind, FALSE sonst (bei nicht gesetztem GAEXIT).

Å
BEMERKUNG
Ä
   Å GetArgÄ ist als Macro in getarg.inc definiert und wird aufÅ getargÄ
    abgebildet. Da der String hinter der PARG-Option, der Funktion mit
 Åbergeben wird, muû ein folgendes Options-Argument erneut durch
ein '-' eingeleitet werden.

à______________________________________________________________________
àlibetc                       getarg, GetArg                     libetc
Ä

ÅBEISPIELÄ

    BOOL   boolarg;
    BYTE   chararg;
    WORD   intarg;
    LONG   longarg = 0L;
    DOUBLE doubarg = 0.0;
    BYTE   strarg[100], filename[100];
    WORD   testproc();

    ARG argtab[] =
    {
       { 'b', BARG, &boolarg, "boolean arg"           },
       { 'c', CARG, (WORD *)&chararg, "character arg" },
       { 'i', IARG, &intarg,  "integer arg"           },
       { 'l', LARG, &longarg, "long int arg"          },
       { 'd', DARG, &doubarg, "double  arg"           },
       { 's', SARG, (WORD *)strarg,  "string arg"     },
       { 'n', NARG, (WORD *)fname,   "file arg"       },
       { 'p', PARG, (WORD *)testproc, "proc arg"      }
    };

    WORD testproc (str)
    BYTE *str;
    { 
       printf ("Inside procedure called by -p command line switch, ");
       printf (" string = <%s>\n\n", str);
       return (1);
    }

    VOID main (argc, argv)
    WORD argc;
    BYTE *argv[];
    { 
       WORD ret;
 
       ret = getarg (&argc, argv, argtab,TABSIZE (argtab),
 GAEXIT|GAUSAGE|GANOCASE, "usage", 2);

       printf ("boolarg: %d   \n", boolarg);
       printf ("chararg: %c   \n", chararg);
       printf ("intarg:  %d   \n", intarg);
       printf ("longarg: %ld  \n", longarg);
       printf ("doubarg: %lf  \n", doubarg);
       printf ("strarg:  <%s> \n", strarg);
       printf ("fname:   <%s> \n", fname);
    }

Å
DATEIEN
Ä
    getarg.inc
    libstr.inc
    libetc.a
    libstr.a

Å
REFERENZ
Ä

à______________________________________________________________________
àlibetc                           system                         libetc

Ä

ÅNAMEÄ

   Ö system - Systemkommando ausfÅhren  Ä                               


ÅSYNTAXÄ

    #include <libetc.inc>

    WORD system (com)
    BYTE  *com;


ÅBESCHREIBUNGÄ

   Å systemÄ fÅhrt das in com enthaltene Kommando aus. Dabei kann dem
    Kommando ein bzw. mehrere durch Leerzeichen getrennte Parameter
    folgen.


ÅRETURNWERTÄ

    ÅsystemÄ liefert den RÅckgabewert vonÅ PexecÄ() zurÅck (0bedeutet
KommandokonnteausgefÅhrtwerden,negative Wertesind System-
Fehler).


ÅBEMERKUNGÄ

    keine
    

ÅBEISPIELÄ

    #include <libetc.inc>
    
    main ()
    {
       WORD ret;
        
       ret = system ("test.prg param1 param2");
       if (ret < 0)
          printf ("System-Error %d\n", ret);
    }


ÅDATEIENÄ

    libetc.inc
    libetc.a
    libstr.a


ÅREFERENZÄ

à
Ä


à______________________________________________________________________
àlibetc                          editfld                         libetcÄ



ÅNAMEÄ

    Öeditfld - Zeichenkette bildschirmgesteuert editierenÄ


ÅSYNTAXÄ

    #include <libetc.inc>

    BYTE *editfld (col, row, text, pattern, efunc, epar,def)
    WORD col, row;
    STR text, pattern;
    PFBOOL efunc;
    STR epar;
    STR def;


ÅBESCHREIBUNGÄ

    Mit ÅeditfldÄ kann ein String editiert werden. Zum Editieren kînnen
    die Cursortasten benutzt werden. Beendet wird die Eingabe mit
    RETURN, abgebrochen werden kann mit der ESCAPE-Taste. Das Feld
    wird an der Position col, row mit dem Titel text angezeigt. Direkt
    hinter text folgt das Eingabefeld (text kann leer sein). Die Zei-
    chen, die fÅr die Eingabe zulÑssig sind, werdenÅ editfldÄ durch das
    Eingabemuster pattern mitgeteilt. Jedes Zeichen von pattern ent-
    spricht einem Zeichen des Feldes. Folgende Meta-Zeichen dienen dem
    Spezifizieren des entsprechenden Eingabezeichens:


     Å    ? : beliebiges Zeichen 
         # : beliebige Ziffer und '.' und '-' und '+'
         % : beliebige Ziffer  
         @ : bel. Zeichen, Buchstaben jedoch nur klein
         $ : bel. Zeichen, Buchstaben jedoch nur gross
         & : beliebiger Buchstabe Ä


    Alle anderen Zeichen werden direkt in das Feld geschrieben und kîn-
    nen nicht geÑndert werden, sondern werden beim Bewegen der Cursor-
    position Åbersprungen. Mit efunc kann die Adresse einer BOOL-
    Funktion Åbergeben werden (oder NULFB), die dann vor dem Verlassen
    von ÅeditfldÄ aufgerufen wird (das Eingabefeld und epar werden efunc
    Åbergeben). Die Funktion efunc kann dazu benutzt werden, die ein-
    gegebenen Zeichen auf ZulÑssigkeit zu untersuchen. Bei einem
    Return-Wert von TRUE wird editfld verlassen. Mit def kann eine
    Zeichenkette Åbergeben werden, mit der die frei editierbaren Zei-
    chen des Eingabefeldes vorbelegt werden kînnen.











à______________________________________________________________________
àlibetc                          editfld                         libetcÄ



    FÅr das Editieren des Eingabefeldes haben folgende Tasten eine
    besondere Bedeutung:
    Å
         ESCAPE    - Abbruch
         RETURN,
         LINEFEED  - Ende des Editierens
         CURLEFT   - Ein Zeichen nach links (falls nicht am Anfang des
                     Feldes)
         CURRIGHT  - Ein Zeichen nach rechts (falls nicht am Ende des
                     Feldes)
         CURHOME   - Zum Anfang des Feldes springen
         TAB       - t_tw (Tabwidth) Zeichen weiter nach rechtsÄ
         
    Alle anderen Tasten werden als Eingabe-Zeichen interpretiert und
    auf ZulÑssigkeit untersucht.
    

ÅRETURNWERTÄ

    Zeiger auf das Eingabefeld oder NULP, falls mit ESCAPE abgebrochen
    wurde oder ein Fehler bei den Åbergebenen Parametern festgestellt
    wurde.


ÅBEMERKUNGÄ

    Das Eingabefeld wird in einem lokal statischen Puffer realisiert.
    Bei jedem Aufruf vonÅ editfld Äwird der Inhalt dieses Puffers mit 
    den aktuellen Werten Åberschrieben.
    FÅr die Benutzung der Cursor-Tasten muû vorher das Terminal ini-
    tialisiert werden (Åt_initÄ()).


ÅBEISPIELÄ

    #include <libetc.inc>
    #include <libterm.inc>
    #include <libstr.inc>

    main ()
    {
       BYTE *ret,name[20];
       WORD month=1,row = 10, col = 20;
       BOOL chkmonth(), chkname();
       
       t_init();
       t_cblink();
       if ((ret = editfld (col, row, "Bitte Monat eingeben: ",
                           "%%", chkmonth, "", " 1")))
          month = atoi (ret);
       else
          printf ("Abbruch oder Fehler\n");
       if ((ret = editfld (col, row+2, "Bitte Name eingeben:  ",
                           "$$$$$$$$$$", chkname, "", "")))
          strcpy (name, ret);




à______________________________________________________________________
àlibetc                          editfld                         libetcÄ


       t_getc();
       t_exit();
    }

    BOOL chkmonth (mbuf)
    BYTE *mbuf;
    {
       return (atoi (mbuf) >= 1 && atoi (mbuf) <= 12 ? TRUE : FALSE);
    }

    BOOL chkname (nbuf)
    BYTE *nbuf;
    {
       return (stremp (nbuf) ? FALSE : TRUE);
    }


ÅDATEIENÄ

    libetc.inc
    libetc.a
    libterm.a
    libstr.a
    termcap


ÅREFERENZÄ

    t_init, t_settw































à______________________________________________________________________
8000100001\ANHANG1.IMG
Ä



















8000100001\ANHANG2.IMG





















8000100001\ANHANG3.IMG























àAnhangtermcap                         Anhang

Ä

ae     str   (P)   end alternate character set
Åal     str   (P*)  add new blanc lineÄë1)Ä
am     bool        terminal has automatic margins
as     str   (P)   start alternate character set
bc     str         backspace if not ^H
bl     str         bell character
Åbs     bool        terminal can backspace with ^HÄë1)Ä
BS     str         sent by backspace-key (if not bc)
bt     str   (P)   backtab
bw     bool        backspace wraps from column 0 to last column
c0..cF str         sent by shifted func-keys (# 0x10 ... 0x1F)
CC     str         command char in prototype if terminal setable
Åcd     str   (P*)  clear to end of displayë1)Å
ce     str   (P)   clear to end of lineÄë1)Ä
ÅCF     str         cursor offë1)Ä
ch     str   (P)   like cm but horizontal motion only, line stays same
CL     str         sent by char left-key
Åcl     str   (P*)  clear screenÄë1)Ä
ÅcL     str         clear to end of lineÄë1)Ä
Åcm     str   (P)   cursor motionÄë1)Ä
CN     str         sent by cancel-key
Åco     num         number of columns in lineÄë1)Ä
ÅCO   str         cursor onë1)Ä
CR     str         sent by char right-key
cr     str   (P*)  carriage return, default ^M
cs     str   (P)   change scrolling region (vt100), like cm
ÅcS     str         clear to end of screenÄë1)Ä
cv     str   (P)   like ch but vertical only
CW     str         sent by change window-key
da     bool        display may be retained above
db     bool        display may be retained below
dB     num         number of millisecs of bs delay needed
dC     num         number of millisecs of cr delay needed
DC     str         sent by delete-char-key
Ådc     str   (P*)  delete characterÄë1)Ä
dF     num         number of millisecs of ff delay needed
DK     str         sent by down arrow-key, if not kd
DL     str         sent by delete-key
Dl     str         sent by destructive character delete-key
Ådl     str   (P*)  delete lineÄë1)Ä
dm     str         delete mode enter
dN     num         number of millisecs of nl delay needed
Ådo     str         down one lineÄë1)Ä
dT     num         number of millisecs of tab delay needed
ed     str         end delete mode
EE     str         end edit mode
EG     num         number of chars taken by ES and EE
Åei     str         end insert mode; give `:ei=:` if icÄë1)Ä
EN     str         sent by end-key
eo     str         can erase overstrikes with a blank
ES     str         start edit mode
ff     str   (P*)  hardcopy terminal page eject (default ^L)
FR     str         sent by field-recall-key
fs     str         return from statusline
FS     str         sent by field-store-key
à
ë
1)wirdvonvt52unterstÅtztà

______________________________________________________________________
àAnhangtermcap                         Anhang

Ä

G1     str         upper-right corner graphic
G2     str         upper-left corner graphic
G3     str         lower-left corner graphic
G4     str         lower-right corner graphic
GC     str         cross lines (intersection) graphic
GD     str         down-tick graphic
GE     str         end graphics mode
GG     num         number of chars taken by GS and GE
GH     str         horizontal bar graphic
GL     str         left-tick graphic
GR     str         right-tick graphic
GS     str         start graphics mode
GU     str         up-tick graphic
GV     str         vertical bar graphic
hc     bool        hardcopy terminal
hd     str         halfline down (forward 1/2 linefeed)
HM     str         sent by home-key, if not kh
Åho     str         cursor home, if no cmÄë1)Ä
ÅHP     str         sent by help-keyÄë1)Ä
hs     bool        has extra statusline
hu     str         halfline up (reverse 1/2 linefeed)
hz     str         hazeltine, can`t print ~s (tilde)
Åic     str   (P)   insert characterÄë1)Ä
if     str         name of file containing is
Åim     bool        insert mode enter; give `:im=:q` if icÄë1)Ä
in     bool        insert mode distinguishes nulls on display
ip     str   (P*)  insert pad after character inserted
Åir     str         terminal resetë1)Å
is     str         terminal initialization stringÄë1)Ä
Åk0..kF str         sent by func-keys (# 0x00 ... 0x0F)Äë1)Ä
ka     str         sent by clear-all-tabs-key
kA     str         sent by insert-line-key
Åkb     str         sent by backspace-keyÄë1)Ä
kC     str         sent by clear-screen- or erase-key
kD     str         sent by delete-character-key
Åkd     str         sent by terminal down-arrow-keyÄë1)Ä
ke     str         out of keypad transmission mode
kE     str         sent by clear-to-end-of-line-key
KF     str         key-click off
kF     str         sent by scroll-forward-down-key
kH     str         sent by home-down-key
Åkh     str         sent by home-keyÄë1)Ä
ÅkI     str         sent by ins-char-/enter ins-mode-keyÄë1)Ä
kL     str         sent by delete-line-key
Åkl     str         sent by terminal left-arrow-keyÄë1)Ä
Åkn     num         number of func-keysÄë1)Ä
ÅkN     str         sent by next-page-keyÄë1)Ä
KO     str         key-click on
ko     str         termcap entries for other non-func-keys
kP     str         sent by previous-page-key
kR     str         sent by scroll-backward-up-key
Åkr     str         sent by terminal right-arrow-keyÄë1)Ä
ks     str         put terminal in keypad transmission mode
kS     str         sent by clear-to-end-of-screen-key
kt     str         sent by clear-tab-key
kT     str         sent by set-tab-key
à
ë
1)wirdvonvt52unterstÅtztà
______________________________________________________________________
àAnhangtermcap                         Anhang
Ä


Åku     str         sent by terminal up-arrow-keyÄë1)Ä
l0..lF str         labels func-keys # 0x00 ... 0x0F
LD     str         sent by line-delete-key
Åle     str         CursorleftÄë1)Ä
LF     str         sent by linefeed-key
Åli     str         number of lines on screen or pageÄë1)Ä
LK     str         sent by left-arrow-key, if not kl
ll     str         last line, first column, if no cm
lm     num         no. of lines in memory if > li (0 means varies)
ma     str         arrow key map, used by vi version 2 only
mb     str         video-attr blinking on
md     str         video-attr bold on
Åme     str         video-attr all attributes offÄë1)Ä
mh     str         video-attr half-bright (dim) on
mi     bool        safe to move while in insert mode
mk     str         video-attr blank (invisible) on
ml     str         memory lock on above cursor
MN     str         sent by minus-sign-key
MP     str         multiplan initialization string
mp     str         video-attr protected on
MR     str         multiplan reset string
Åmr     str         video-attr reverse onÄë1)Ä
ms     bool        safe to move while in standout modes
mu     str         memory unlock (turn off memory lock)
nc     bool        not correctly working carriage return (dm2500, h2000)
Ånd     str         non-destructive-space (cursor right)Äë1)Ä
nl     str   (P*)  newline character (default \n)
ns     bool        terminal is crt but doesn`t scroll
NU     str         sent by next-unlocked-cell-key
os     bool        terminal overstrikes
pc     str         pad-character rather than null
PD     str         sent by page-down-key
PL     str         sent by page-left-key
PR     str         sent by page-right-key
PS     str         sent by plus-sign-key
Åpt     bool        has hardware-tabs (may need to set with is)Äë1)Ä
PU     str         sent by page-up-key
RC     str         sent by recalc-key
RF     str         sent by toggle-reference-key
RK     str         sent by right-arrow-key, if not kr
RT     str         sent by return-key
Åse     str         end standout modeÄë1)Ä
sf     str   (P)   scroll forwards
sg     num         number of blank characters left by so or se
Åso     str         start standout modeÄë1)Ä
Åsr     str   (P)   scroll reverse (backwards)Äë1)Ä
TA     str         sent by toggle-autocase-key
ta     str   (P)   tab (other than ^I or with padding)
TB     str         sent by tab-key
tc     str         entry of similar terminal - must be last
te     str         string to end programs that use cm
TI     str         sent by toggle-autoinsert-key
ti     str         string to start programs that use cm
ts     str         goto status-line col 1
uc     str         underscore one character and move past it
ue     str         end underscore mode
à
ë
1)wirdvonvt52unterstÅtztà
______________________________________________________________________
àAnhangtermcap                         Anhang

Ä

ug     num         number of blank characters left by ue or us
UK     str         sent by up-arrow-key, if not ku
ul     bool        terminal underlines even thou it doesn`t overstrike
Åup     str         upline (cursor up)Äë1)Ä
us     str         start underscore mode
vb     str         visible bell (may not move cursor)
ve     str         end open/visual mode
vs     str         start open/visual mode
WL     str         sent by word-left-key
WR     str         sent by word-right-key
ws     num         no. of avail columns in statusline
xb     bool        beehive (f1=esc, f2=^C)
xn     bool        a newline is ignored after wrap (concept)
xr     bool        return acts like ce (\r\n) (delta data)
xs     bool        stand out not erased by writing over it (hp 264x)
xt     bool        tabs are destructive, magic so character








































ë
1)wirdvonvt52unterstÅtztÄ

à______________________________________________________________________
9[........................................................]0010
àAnhangAtari-Termcap                   Anhang
Ä


ÅNAMEÄ

Ötermcap-DateiderTerminal-EigenschaftenÄ



st520:\
   :co#80:li#25:bs:pt:\
   :cm=\EY%d%d:up=\EA:do=\EB:nd=\EC:le=\ED:ho=\EH:sr=\EM:\
   :cd=\EJ:ce=\EK:cl=\EE:cL=\EK:cS=\EJ:\
   :CF=\Ef:CO=\Ee:\
   :al=\EL:dl=\EM:ic=\E@:dc=\EP:im=:ei=:\
   :mr=\Ep:me=\Eq:so=\Ep:se=\Eq:\
   :is=\EE:ir=\EE:rs=\E[?5l:\
   :ku=\EH:kd=\EP:kr=\EM:kl=\EK:kh=\EG:kb=^H:\
   :k0=\E\073:k1=\E\074:k2=\E\075:k3=\E\076:k4=\E\077:\
   :k5=\E\080:k6=\E\081:k7=\E\082:k8=\E\083:k9=\E\084:\
   :kA=\ET:kB=\EU:kC=\EV:kD=\EW:kE=\EX:kF=\EY:\
   :Al=\E\060:kN=\E2:HP=\Eb:kI=\ER:sc=\E7:rc=\E8:








































à______________________________________________________________________
àAnhangAtari vt52-Escapes              Anhang



Å      ESC A  -  Cursor Up
ÄDerCursorspringteineZeilenachoben,sofernersich
nichtbereitsindererstenZeilebefindet;dieSpalten-
positionwirdnichtgeÑndert.
      
     Å ESC B  -  Cursor DownÄ
DerCursorwirdaufdienÑchstenZeilegleicheSpalteposi-
tioniert,jedochnurfallsersichnichtschoninderletz-
          tenZeilebefindet.
      
      ÅESC C  -  Cursor RightÄ
           DerCursorwirdumeineSpaltenachrechtsverschoben,
jedochnicht,wennersichbereitsinderletztenSpalte
befindet.
Å      
      ESC D  -  Cursor Left
Ä           DerCursorwirdumeineSpaltenachlinkspositioniert,
jedochnur,wennersichnichtindererstenSpaltebefin-
det.
      
      ÅESC E  -  Clear ScreenÄ
           DerBildschirmwirdgelîschtundderCursoraufdieerste
Zeile,ersteSpaltepositioniert.
      
     Å ESC H  -  CursorHomeÄ
           DerCursorwirdindieersteZeile,ersteSpaltepositio-
niert.
      
     Å ESC I  -  Reverse IndexÄ
           WieCursorUp;istderCursorbereitsindererstenZeile,
soscrolltderBildschirmumeineZeilenachunten.
Å      
      ESC J  -  Erase to End of Screen
Ä           LîschtdenBildschirmabderaktuellenPositionbiszum
EndedesBildschirmes.
      
     Å ESC K  -  Erase to End of LineÄ
           LîschtdieaktuelleZeilevonderCursorpositionbiszum
EndederZeile.
      
     Å ESC L  -  Insert LineÄ
           FÅgteineleereZeileanderaktuellenPositionein.Der
CursorwirdandenAnfangderneuenZeilepositioniert.
DieeventuellfolgendenZeilenwerdenumeineZeilenach
untenverschoben.

     Å ESC M  -  Delete LineÄ
           LîschtdieaktuelleZeile;dienachfolgendenZeilenwerden
umeineZeilenachobengescrollt.
à
Ä     Å ESC Y %c%c -  Position CursorÄ
           DerCursorwirdaufdiePosition%c%c(Spalte,Zeile)
gesetzt.DieNullpositionistdabeidielinkeobereBild-
schirmecke(wiebeiCursorHome).DieWertefÅrdiePosi-
tionenwerdendurchASCII-Zeichenab32(Leerzeichen)
bestimmt.
à


______________________________________________________________________
àAnhangAtari vt52-Escapes              Anhang


Ä      
     Å ESC b %c -  Set Foreground ColorÄ
           BeiFarbdarstellungwirddieVordergrundfarbeentsprechend
demWertvon%c,nurdieletztenvierBitssindrelevant,
gesetzt.
      
     Å ESC c %c -  Set Background ColorÄ
           Hintergrundfarbesetzen,sieheoben.

     Å ESC d  -  Erase toBeginning of DisplayÄ
           DerBildschirmwirdvomAnfangbiszurCursorposition
einschlieûlichgelîscht.
      
     Å ESC e  -  Enable CursorÄ
           DerCursorwirdangeschaltet.
      
     Å ESC f  -  Disable CursorÄ
           DerCursorwirdausgeschaltet.
Å      
      ESC j  -  Save Cursor Position
Ä           DieaktuelleCursorpositionwirdgespeichert.

     Å ESC k  -  Restore Cursor PositionÄ
           DerCursorwirdaufdieletztemitSaveCursorPositionge-
speichertePositiongesetzt.
      
     Å ESC l  -  Erase Entire LineÄ
           DieaktuelleZeilewirdgelîschtundderCursoraufdie
ersteSpaltedieserZeilegesetzt.

     Å ESC o  -  Erase Beginning of LineÄ
           DieaktuelleZeilewirdvomZeilenanfangbiszumCursor
einschlieûlichgelîscht.
      
      ÅESC p  -  Enter Inverse Video ModeÄ
           JedefolgendeTextausgabewirdininverserDarstellung
(weiûeSchriftaufschwarzemHintergrund)geschrieben.
      
     Å ESC q  -  Exit Inverse Video ModeÄ
           JederfolgendeTextwirdinnormalerTextdarstellungaus-
gegeben.

    Å  ESC v  -  Wrap at End of LineÄ
           JedeTextausgabe,dieÅberdasEndederZeilehinausgehen
wÅrde,wirdindernÑchstenZeiledargestellt.
      
     Å ESC w  -  Discard at End of LineÄ
           JedeTextausgabe,dieÅberdasEndederZeilehinausgehen
wÅrde,wirdnuraufderletztenSpaltedargestellt,also
dasletzteZeichenwirdimmerwiederÅberschrieben.










à______________________________________________________________________Ä
8000100001\INDEX1.IMG
à



















8000100001\INDEX2.IMG























8000100001\INDEX3.IMG





















àIndex                           Index
Ä


    editfld  .................................................  88

    getarg  ..................................................  84
    GetArg  ..................................................  84

    libstr  ..................................................   8

    memchr  ..................................................  44
    memcmp  ..................................................  44
    memcpy  ..................................................  44
    memset  ..................................................  34

    PMDesel  .................................................  69
    pmexec  ..................................................  65
    pmselect  ................................................  69
    PMSelect  ................................................  69
    PushBOOL  ................................................  75
    PushBYTE  ................................................  75
    PushDOUBLE  ..............................................  75
    PushFLOAT  ...............................................  75
    PushLONG  ................................................  75
    PushPOINTER  .............................................  75
    PushSTRING  ..............................................  75
    PushULONG  ...............................................  75
    PushUWORD  ...............................................  75
    PushWORD  ................................................  75

    stack  ...................................................  71
    stackdel  ................................................  74
    stackdepth  ..............................................  81
    stackempty  ..............................................  80
    stackname  ...............................................  83
    stacknew  ................................................  72
    StackNew  ................................................  72
    stackpop  ................................................  77
    stackpush  ...............................................  75
    stackshow  ...............................................  79
    stacktop  ................................................  77
    stacktype  ...............................................  82
    stradj  ..................................................   9
    stradjl  .................................................   9
    stradjr  .................................................   9
    strcat  ..................................................  10
    strcatn  .................................................  10
    strchr  ..................................................  11
    strcmp  ..................................................  12
    strcnvl.  ................................................  14
    strcnvul  ................................................  14
    strcpy  ..................................................  16
    strcpyn  .................................................  16
    strcspn  .................................................  18
    strctr  ..................................................  19
    strdup  ..................................................  20
    stremp  ..................................................  21
    strfnd  ..................................................  22
    strfroml  ................................................  23
    strfromul  ...............................................  23


à______________________________________________________________________Ä
àIndex                           Index
Ä


    strichr  .................................................  11
    stricmp  .................................................  12
    stricspn  ................................................  18
    strifnd  .................................................  22
    strimat  .................................................  27
    strinv  ..................................................  24
    stripbrk  ................................................  29
    stripos  .................................................  30
    strirchr  ................................................  11
    strirpbrk  ...............................................  29
    strirpl  .................................................  33
    strirpos  ................................................  30
    strirsort  ...............................................  36
    strirstr  ................................................  37
    striscmp  ................................................  12
    strisort  ................................................  36
    strispn  .................................................  18
    stristr  .................................................  37
    strlen  ..................................................  25
    strlwr  ..................................................  26
    strlwrg  .................................................  26
    strmat  ..................................................  27
    strn0cpy  ................................................  16
    strncat  .................................................  10
    strncatn  ................................................  10
    strncmp  .................................................  12
    strncpy  .................................................  16
    strncpyn  ................................................  16
    strndup  .................................................  20
    strnemp  .................................................  21
    strnicmp  ................................................  12
    strnimat  ................................................  27
    strninv  .................................................  24
    strnirpl  ................................................  33
    strniscmp  ...............................................  12
    strnlwr  .................................................  26
    strnlwrg  ................................................  26
    strnmat  .................................................  27
    strnrotl  ................................................  32
    strnrotr  ................................................  32
    strnrpl  .................................................  33
    strnscmp  ................................................  12
    strnset  .................................................  34
    strnspc  .................................................  34
    strnupr  .................................................  42
    strnuprg  ................................................  42
    strpbrk  .................................................  29
    strpcpy  .................................................  16
    strpos  ..................................................  30
    strptrm  .................................................  40
    strptrml  ................................................  40
    strptrmr  ................................................  40
    strrchr  .................................................  11
    strrev  ..................................................  31
    strrotl  .................................................  32
    strrotr  .................................................  32
    strrpbrk  ................................................  29


à______________________________________________________________________Ä
àIndex                           Index
Ä


    strrpl  ..................................................  33
    strrpos  .................................................  30
    strrsort  ................................................  36
    strrstr  .................................................  37
    strscmp  .................................................  12
    strset  ..................................................  34
    strsort  .................................................  36
    strspc  ..................................................  34
    strspn  ..................................................  18
    strsset  .................................................  34
    strstr  ..................................................  37
    strtof  ..................................................  39
    strtok  ..................................................  38
    strtol  ..................................................  39
    strtoul  .................................................  39
    strtrm  ..................................................  40
    strtrml  .................................................  40
    strtrmr  .................................................  40
    strupr  ..................................................  42
    struprg  .................................................  42
    strwupr  .................................................  42
    subnstr  .................................................  43
    substr  ..................................................  43
    system  ..................................................  87

    t_beep  ..................................................  55
    t_box  ...................................................  63
    t_cblink  ................................................  58
    t_cdown  .................................................  60
    t_chome  .................................................  60
    t_cleft  .................................................  60
    t_cleol  .................................................  56
    t_cleos  .................................................  56
    t_cls  ...................................................  56
    t_cright  ................................................  60
    t_csteady  ...............................................  58
    t_cup  ...................................................  60
    t_cursoff  ...............................................  57
    t_curson  ................................................  57
    t_cursstat  ..............................................  57
    t_exit  ..................................................  53
    t_getc  ..................................................  59
    t_goxy  ..................................................  60
    t_hline  .................................................  63
    t_init  ..................................................  52
    t_invoff  ................................................  61
    t_invon  .................................................  61
    t_rawoff  ................................................  54
    t_rawon  .................................................  54
    t_setatt  ................................................  61
    t_settw  .................................................  62
    t_vline  .................................................  63
    termcap  .................................................  96
    tgetent  .................................................  46
    tgetflag  ................................................  48
    tgetnum  .................................................  47



à______________________________________________________________________Ä
àIndex                           Index
Ä


    tgetstr  .................................................  49
    tgoto  ...................................................  50
    tputs  ...................................................  51
























































à______________________________________________________________________
