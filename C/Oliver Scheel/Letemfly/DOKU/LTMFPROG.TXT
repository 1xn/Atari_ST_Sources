               Programmer's Guide to Let 'em Fly! V1.14
               ----------------------------------------

                             Oktober 1991

                      (c) 1991 by Oliver Scheel

                  ... this guide goes Freaky Deaky!


                              Einleitung
                              ==========

Mit  der  Version  1.03 habe ich den Teil fÅr  die  Programmierer  und 
fortgeschrittenen Anwender aus der eigentlichen Anleitung herausgenom-
men, um den normalen Anwender nicht unnîtig zu verwirren.
Da  Let 'em Fly!  neue Dimensionen im Bereich  der  Dialogverarbeitung 
schafft  ist  es  notwendig,  daû  Programme  einige  Punkte  beachten 
sollten.


                            Watisennuneu?
                            =============

Let 'em Fly! ersetzt bzw. erweitert die folgenden AES-Routinen:

form_do() (komplett)
--------------------
Benutzt ein Programm diese Funktion,  so ist der komplette  Funktions-
umfang  von Let 'em Fly!  ansprechbar.  FÅr die Flugroutinen  muû  der 
Hintergrund  mit form_dial(FMD_START, ...) natÅrlich gesichert  worden 
sein!

form_dial() (teilweise)
-----------------------
Hier  wurden die Modi FMD_START/FMD_FINISH ersetzt,  sowie  die  Grow-
/Shrinkboxen  abschaltbar gemacht.  Bei FMD_START wird der  Åbergebene 
Bildschirmausschnitt  bei  ausreichendem  Speicher  gesichert.   Steht 
nicht  genug  Speicher zur VerfÅgung,  so  wird  die  Original-Routine 
angesprungen. Mit FMD_FINISH wird der Ausschnitt wieder hergestellt.
Muûte  man  vor der Version 1.13 den  Bildschirmausschnitt  pixelgenau 
berechnen,  so  ist  das  jetzt  nicht  mehr  notwendig.  Let 'em Fly! 
transformiert  die Koordinaten nun vor dem  Flug.  Der  Bildschirmaus-
schnitt sollte aber grîûer gleich dem echten angegeben  werden.  Wurde 
zuwenig reserviert, dann fliegt nichts.

form_center() (teilweise)
-------------------------
Diese  Funktion  merkt  sich  nun  die  Position  der  Dialoge.  'Save 
Position'  muû natÅrlich eingeschaltet sein.  Weiterhin ist hier  auch 
der VSCR-Support eingebaut.

form_alert() (komplett)
-----------------------
Damit auch die Alert-Boxen fliegen kînnen,  muûte die Routine komplett 
neu  geschrieben  werden.  Zudem gibt es keine  BeschrÑnkung  auf  die 
ZeilenlÑnge  mehr,  jedoch  darf der Alert-String  255  Zeichen  nicht 
Åberschreiten.   Weiterhin  ist  es  nun  mîglich  eigene  Icons   von 
Let 'em Fly! beim Start laden zu lassen.

form_error() (komplett)
-----------------------
Diese  Funktion  basiert auf form_alert(),  daher war es  kein  groûer 
Zusatzaufwand, dies noch zu implementieren.

form_keybd() (komplett)
-----------------------
In  dieser Funktion werden die TastendrÅcke in  Dialogen  verarbeitet, 
um  einerseits  den Dialog zu verlassen (RETURN) und  andererseits  um 
die Edit-Felder zu wechseln.  Wird diese Funktion in eigenen form_do() 
Routinen   benutzt  kommt  man  natÅrlich  in  den  Genuû  der   neuen 
Funktionen (die MagicDials von Peter Hellinger kînnen da als  Beispiel 
dienen).

objc_edit() (teilweise)
-----------------------
Diese Funktion bearbeitet die Eingaben in ein Edit-Feld.  Let 'em Fly! 
stellt  mit  dieser  Funktion zusÑtzlich die  Funktionen  zum  Bewegen 
innerhalb der Zeile zur VerfÅgung.  Weiterhin wird Åber diese Funktion 
die Clipboard-UnterstÅtzung realisiert.

appl_exit() (erweitert)
-----------------------
Let 'em Fly!  gibt hier nur die Speicherleichen, welche durch fehlende 
FMD_FINISHes entstanden sind, frei.


                           Neue Funktionen
                           ===============

Zudem werden ein paar neue Funktionen bereitgestellt,  welche Åber den 
Cookie-Jar ansprechbar ist (s.u.).  Die ParameterÅbergabe erfolgt Åber 
den Stack! Damit kann man diese Routinen auch aus anderen Programmier-
sprachen  als  C problemlos aufrufen.  Das beigelgte  C-Binding  Åber-
prÅft,  ob  Let  'em Fly!  installiert ist,  d.h.  man  braucht  keine 
Vorbereitungen zu treffen.  Weiterhin liegt Let 'em Fly! ein Beispiel-
form_do() bei.

1.)  int di_fly(OBJECT *tree)
-----------------------------
Wurde  der Bildschirmausschnitt vorher  mit  form_dial(FMD_START, ...) 
gesichert,  dann  kann  man Åber diese Funktion  seine  Boxen  fliegen 
lassen.  Das  ist  dann  interessant,  wenn man  eigene  Routinen  zur 
Dialogverarbeitung  benutzt.   In  jedem  Fall  sollte  man  sich   am 
form_do() Source von D.R. orientieren!!!

Beispiel:

[...]

#include <ltmf_lib.h>    /* ltmf_lib.o muû mit dazugelinkt werden */

[...]

new_form_do(OBJECT *tree, ...)
{
     [...]

     if(exit_obj == FLYBUTTON)
          di_fly(tree);       /* bei Benutzung der original  form_do() 
                              Sourcen muû zusÑtzlich noch das exit_obj 
                              bzw.   das  next_obj  auf  Null  gesetzt 
                              werden! */

     [...]
}

Falls ein anderer Mauszeiger als ARROW benutzt wurde,  muû dieser nach 
der Flugstunde wieder hergestellt werden.


2.)  int obj_clsize(OBJECT *tree,int obj,int *x,int *y,int *w,int *h)
---------------------------------------------------------------------
Diese  Funktion  berechnet die echten  Ausmaûe  eines  Objekts.  Diese 
Funktion  sollte  eigentlich  fester Bestandteil  des  AES  sein.  Die 
original  form_center() Routine berÅcksichtigt beispielsweise nur  den 
OUTLINED-Status!  Der Return-Wert sagt,  ob  Let 'em Fly!  installiert 
ist.


3.)  int init_keys(OBJECT *tree)
--------------------------------
Da man in einigen FÑllen eine eigene form_do() Routine schreiben  muû, 
kann  man  Åber  diese Funktion  die  Tastenvergabe  von  Let 'em Fly! 
aufrufen.  Es  werden innerhalb dieser Funktion auch die  Striche  ge-
malt.  Der RÅckgabewert sagt aus,  ob eine Tastenvergabe stattfand. In 
dem  beigelegten Beispiel DO_SAMPL.C wird diese  Funktion  angewendet. 
Weiterhin  ist  diese  Funktion nur  in  Verbindung  mit  lookup_key() 
sinvoll.


4.)  int lookup_key(int key, int kbshift)
-----------------------------------------
Um mit den vergebenen Tasten auch etwas anfangen zu kînnen, wird diese 
Funktion  aufgerufen.  Man Åbergibt den durch evnt_multi()  erhaltenen 
Scan/ASCII-Code  und  Shift-Status  und erhÑlt  als  RÅckgabewert  die 
Nummer des Objekts oder '0',  wenn die Taste keinem Objekt  zugewiesen 
werden  konnte.  Diese Funktion ist nur in Verbindung mit  init_keys() 
sinnvoll  und  darf auch nur benutzt  werden,  wenn  init_keys()  TRUE 
lieferte. Auch hier verweise ich auf das mitgelieferte Beispiel.

Bemerkung:     Von  diesen beiden Funktionen wurde im  Konfigurations-
               programm  Gebrauch  gemacht.  Bei  diesen  Dialogen  in 
               Fenstern   ist   weiterhin  darauf   zu   achten,   daû 
               init_keys()  nur dann aufgerufen  werden  sollte,  wenn 
               das  Window auch das Top-Window ist.  Es kann sonst  zu 
               PixelmÅll auf dem Bildschirm kommen.


     Programmierrichtlinien ... oder: wie arbeitet Let 'em Fly!?
     ===========================================================

a) Fliegende Dialoge:
---------------------
Let 'em Fly!  sichert  bei einem Aufruf von  form_dial(FMD_START, ...) 
den entsprechenden Bildschirmausschnitt.  Dieser  Bildschirmausschnitt 
wird dann zum Fliegen benîtigt.  Die Koordinaten sollten  einigermaûen 
genau angegeben werden,  d.h. lieber etwas mehr Bildschirm reservieren 
lassen.  Die  Routine form_center() spuckt bei 'normalen'  Dialogboxen 
die richtigen Werte aus und kînnen unverÑndert benutzt werden.
Zeichnet  man  nun  die  Dialogbox mit  objc_draw()  und  springt  die 
'original' form_do() Routine an,  dann testet Let 'em Fly!  bei  einem 
Mausklick  u.a.,  ob sich das unter der Maus befindliche Objekt  keine 
Flags  besitzt  (also  ob_flags == NONE).  In  diesem  Fall  wird  die 
Routine di_fly() aufgerufen,  und der Dialog fÑngt an zu fliegen. Wird 
nach  Abarbeitung des Dialogs  form_dial(FMD_FINISH, ...)  aufgerufen, 
dann   wird   der   Bildschirmausschnitt   wieder   hergestellt.   Die 
Koordinaten bei FMD_FINISH sind fÅr Let 'em Fly!  uninteressant,  aber 
trotzdem   sollte  man  sie  auf  jedem  Fall  korrekt   angeben,   da 
Let 'em Fly!  bei nicht ausreichendem Speicher den Ausschnitt bekannt-
lich nicht sichert.  Andere (oder sogar das eigene) Programme  kînnten 
so bei einem Redraw Probleme bekommen, insbesondere wenn 'Send Redraw' 
eingeschaltet ist.
Man  sollte  bei jedem Dialog nur einmal FMD_START am Anfang  und  nur 
einmal FMD_FINISH am Ende benutzen. Andernfalls kînnte der Bildschirm-
aufbau nicht mehr stimmen.  Die FMD_STARTs und FMD_FINISHs sind  gegen 
die obere (6x) und untere Grenze abgesichert.
GEM-Anwendungen  sollten immer  appl_init/appl_exit  benutzen!!!  Wird 
appl_exit()  aufgerufen,  so  gibt Let 'em Fly!  nicht  mehr  benutzte 
Speicherbereiche frei.

b) Key Dials:
-------------
Wird form_do() aufgerufen,  dann geht Let 'em Fly!  alle Objekte durch 
und  guckt  nach,  ob sie mit einer Taste belegt  werden  kînnen.  Das 
Objekt  muû  entweder SELECTABLE,  EXIT oder TOUCHEXIT sein  und  darf 
nicht DISABLED oder geHIDETREEd sein.  Ist der Parent geHIDETREEd,  so 
werden  die Children ebenfalls nicht durchsucht.  Jetzt wird  geprÅft, 
ob  sich  ein Text in dem Objekt befindet (aus dem Text wird  nur  das 
erste,  durch Leerzeichen getrennte,  Token berÅcksichtigt). Falls ja, 
dann  wird dieser Text nach einer freien Tastenkombination  abgesucht. 
Falls nicht,  dann schaut Let 'em Fly!  nach, ob das nÑchste Objekt in 
der  Liste(!) einen Text enthÑlt und dieses Objekt  nicht  SELECTABLE, 
EXIT,  TOUCHEXIT, DISABLED oder geHIDETREEd ist. Dieser Text wird dann 
zur  Zuweisung  der Tastenkombination benutzt.  Die  Y-Koordinate  des 
Ersatzobjektes  muû auf +/- 3 Pixel Åbereinstimmen.  Daher ist  darauf 
zu  achten,  daû  die Dialogbox richtig sortiert  ist.  Der  Text  des 
'Abbruch'-Buttons  sollte mit einem der oben schon aufgefÅhrten  Åber-
einstimmen. Zu beachten ist, daû es auch eine HELP-Taste geben kann.
Weiterhin  ist  es  ab  Version 1.10 mîglich  die  Tasten  gezielt  zu 
vergeben (s.u.).

c) Extended Editor:
-------------------
Dieser  Teil  ist nur fÅr die Leute interessant,  welche  eine  eigene 
form_do() Routine schreiben wollen.  Weiterhin gehe ich davon aus, daû 
die original form_do() Sourcen bekannt sind.
Let 'em Fly!   erweitert   bzw.   erstetzt   die   beiden   Funktionen 
form_keybd()  und objc_edit().  In eigenen Routinen sollte  daher  von 
diesen Funktionen auch Gebrauch gemacht werden.  Auch wenn man  selbst 
TastendrÅcke verwalten will, sollte man diese Funktionen aufrufen.

d) Extended Objects
-------------------
Ab  Version  1.10  werden  die  erweiterten  Objekttypen  benutzt,  um 
Let 'em Fly!  innerhalb  von Dialogen 'steuern' zu kînnen.  Es  kînnen 
jetzt  so bei einigen Dialogen Funktionen abgeschaltet werden und  die 
Tasten  gezielt  vergeben werden.  Der Extended Object Type  im  ROOT-
Objekt  muû ein Magic enthalten,  damit  Let 'em Fly!  weiû,  daû  die 
restlichen  Werte des Dialogs gÅltig sind.  Damit  sollen  Kollisionen 
mit fremden Dialogroutinen vermieden werden.
öber  die Objekt-Flags 10 und 11 im ROOT-Objekt kînnen  die  Key-Dials 
und  der Extended Editor global (also fÅr diesen Dialog)  abgeschaltet 
werden.  Das  Objekt-Flag  14  erzwingt  ein  Zentrieren  des  Dialogs 
(interessant  bei eingeschaltetem 'Save Position').  öber das  Objekt-
Flag  12  kann ein Dialog flugunfÑhig gemacht  werden.  Das  ist  dann 
interessant,  wenn  ein  Programm mit den  fliegenden  Dialogen  nicht 
zurrechtkommt.
Das Objekt-Flag 15 wird Åbrigens von Let 'em Fly!  benutzt,  um  einen 
bereits  zentrierten  Dialog zu markieren.  Dies  ist  unabhÑngig  vom 
Magic  und  kann nur durch den Schalter  'Save  Position'  unterdrÅckt 
werden.
FÅr  die  restlichen Objekte im Dialog wird das Extended  Object  Byte 
dazu  benutzt um Tasten gezielt zu vergeben.  Es wird  dabei  zwischen 
normalen  Tasten (A-Z,  0-9) und  Sondertasten  (HELP,  UNDO,  F1-F10) 
unterschieden.  Weiterhin  kann man bestimmen,  ob das nÑchste  Objekt 
fÅr die Tastenvergabe benutzt werden soll.
Die  Objekt-Flags 10 und 11 haben die gleiche Bedeutung wie  im  ROOT-
Objekt, sind jedoch nur lokal wirksam.

So,  und hier die genaue Belegung der Bits and Bytes (die Flags werden 
von 0, entspricht Bit 0, ab an gezÑhlt!):

ROOT-Objekt
-----------
- Extended Object Byte (erweiterter Objekttyp)
     MAGIC 0x89 (137)    Sagt Let 'em Fly!,  daû die restlichen  Werte 
                         im Dialog gÅltig sind.
     GLOBOFF 0x71 (113)  Hiermit wird Let 'em Fly!  fÅr diesen  Dialog 
                         komplett(!)  ausgeschaltet.  Das Byte  stimmt 
                         mit dem in FormDoIt!  benutzten Åberein,  ist 
                         aber nur im ROOT-Objekt wirksam.

- Objekt-Flags
     Flag 10   Schaltet den Extended Editor global aus.
     Flag 11   Schaltet die Key Dials global aus.
     Flag 12   Macht den Dialog flugunfÑhig.
     Flag 13   Rastet  den  Dialog  nach dem Fliegen  wieder  auf  das 
               ursprÅngliche Byte-Alignment ein.
     Flag 14   Erzwingt ein Zentrieren des Dialogs.

restliche Objekte
-----------------
- Extended Object Byte (erweiterter Objekttyp)
     Das  Byte wird in zwei Nibbles († 4 Bit)  unterteilt.  Das  obere 
     Nibble konfiguriert das untere Nibble.  Eine kleine Grafik dÅrfte 
     hier hilfreich sein:

     +---+---+---+---+----------------+
     | 0 | 0 | S | T | Key Identifier |
     +---+---+---+---+----------------+
               ^   ^   ^
               |   |   +----  Identifiziert  die  Taste.   Ist  dieses 
               |   |          Nibble nicht gesetzt,  also gleich Null, 
               |   |          so vergibt Let 'em Fly!  die Taste  nach 
               |   |          dem  herkîmmlichen  Verfahren.   Besitzt 
               |   |          dieses Nibble einen Wert (1-15), so wird 
               |   |          damit die Position(!) der Taste im  Text 
               |   |          angegeben.  Vorsicht: Der ZÑhler beginnt 
               |   |          mit  1  (also nicht mit  0)  und  Spaces 
               |   |          werden mitgezÑhlt!
               |   |
               |   +--------  Zeigt  an,  daû das nÑchste  Objekt  zur 
               |              Tastenvergabe  benutzt werden  soll.  Es 
               |              muû kein Key Identifier verhanden  sein. 
               |              In  diesem Fall sucht sich  Let 'em Fly! 
               |              die Taste selbst aus.
               |
               +------------  Dieses Bit sagt,  daû dieses Objekt  mit 
                              einer  Sondertaste belegt  werden  soll. 
                              Der   Key  Identifier  muû  dann   einen 
                              gÅltigen Wert haben:
                                    1 - UNDO
                                    2 - HELP
                                    3 - F1
                                     [...]
                                   12 - F10
                              Weiterhin wird das Objekt noch nach  dem 
                              Let 'em Fly! Algorithmus mit einer Taste 
                              belegt.

     Zu   beachten   ist,   daû  auch   weiterhin   die   automatische 
     Tastenvergabe aktiv ist.  Wird UNDO Åber die ExObTypes  vergeben, 
     so ist es gegen eine weitere automatische Vergabe geschÅtzt.  Bei 
     HELP ist dies nicht der Fall!

     Die restlichen Bits sind reserviert und sollten auf Null  gesetzt 
     sein.

- Objekt-Flags
     Flag 10   Schaltet den Extended Editor fÅr dieses Objekt aus.
     Flag 11   Schaltet  die Key Dials fÅr dieses Objekt  (und  dessen 
               Unterobjekte!) aus.


Vorsicht: FÅr    Kollisionen   bei   der   Tastenvergabe    ist    der 
          Programmierer,  bzw.  der  VerÑnderer des  RSC-Files  selbst 
          verantwortlich!


NatÅrlich kann man auch 'fremde' RSC-Files modifizieren, jedoch sollte 
man hier sehr vorsichtig sein.  Vielleicht werden die Bits ja auch vom 
Programm selbst benutzt und verÑndert.
Weiterhin ist es selbstverstÑndlich,  daû verÑnderte RSC-Files  grund-
sÑtzlich NICHT weitergegeben werden dÅrfen!!! Falls ich solchen FÑllen 
auf die Spur kommen sollte,  so bekommt derjenige erheblichen(!) érger 
von mir!

AbhÑngigkeiten zwischen Schalter, ob_flags und Funktionen
---------------------------------------------------------

     Function       | Switch            | ob_flags (only with MAGIC)
     ---------------+-------------------+---------------------------
     form_do()      | Let 'em Fly ON/OFF| ExObType Value 0x71 (113)
                    | Key Dials         | Flag 11
     form_dial()    | Flying ON/OFF     | Flag 12 (ROOT-only)
                    | Grow/Shrink       | ---
                    | Send Redraw       | ---
     form_center()  | Save Position     | Flag 14
                    | VSCR Support      | no flag available yet
     form_alert()   | Alert/Error-Boxes | ---
     form_error()   | Alert/Error-Boxes | ---
     form_keybd()   | Extended Editor   | Flag 10 (ROOT-only)
     objc_edit()    | Extended Editor   | Flag 10
     appl_exit()    | - no switch -     | ---
     ---------------+-------------------+---------------------------
     di_fly()       | Flying ON/OFF     | Flag 12 (ROOT-only)
                    | Solid/Hollow Fl.  | ---


e) User-Defined Key-Handler
---------------------------
Manchmal mîchte man innerhalb eines Dialogs neben den  'herkîmmlichen' 
Tasten auch noch andere verwalten.  Normalerweise muûte man hier  eine 
neue  form_do()  Routine schreiben und somit auf  die  Features  bzgl. 
Tastaturbedienbarkeit von Dialogen durch Let 'em Fly! verzichten. öber 
den  Cookie-Jar  ist  es  nun  mîglich  jeden  Tastendruck  im  Dialog 
abzufangen und u.U. selbst zu bearbeiten.

Bevor  ich  jetzt  auf Einzelheiten eingehe,  hier  ein  kleines  Bei-
spielprogramm:

[...]

#include <ltmf_lib.h>

[...]

int cdecl my_keys(int key, int kshift)
{
     printf("%04x %04x\n\r", key, kshift);
     return(0);
}

[...]

int do_dialog(OBJECT *tree)
{
     int  what;

     draw_dialog(tree);
     set_do_key(my_keys);          /* Routine einklinken */
     what = form_do(tree, 0);
     set_do_key(0l);               /* und wieder ausklinken. */
     undraw_dialog(tree);
     return(what);
}

[...]

Dieses kleine Beispielprogramm macht nichts anderes,  als einen Dialog 
darzustellen und abzuarbeiten,  jedoch werden die TastendrÅcke  inner-
halb von form_do() mit printf() auf dem Bildschirm ausgegeben.

Die Funktion zur Tastenbearbeitung muû folgenden Regeln folgen:

int cdecl do_key(int key, int kshift);

Eingabe:  key       EnthÑlt  den  Tastencode.  Er stimmt mit  dem  von 
                    evnt_keybd() zurÅckgegebenen  Åberein,  d.h.  Bits 
                    0..7  enthalten den ASCII-Code und Bits 8..15  den 
                    Scancode.
          kshift    EnthÑlt  den Shiftstatus,  der  von  evnt_button() 
                    geliefert wurde.

Return:   0         Taste  konnte  nicht  verarbeitet   werden,   bzw. 
                    Let 'em Fly!  sieht  den Tastencode als gÅltig  an 
                    und versucht ihn selbst zu verarbeiten.
          1         Taste  konnte  verarbeitet  werden.   Let 'em Fly! 
                    ignoriert die Taste nun.
          2         Wie  '1',   jedoch  wird  der  Dialog   zusÑtzlich 
                    abgebrochen  und als Ergebnis (bei form_do())  '0' 
                    zurÅckgeliefert.

Wird innerhalb dieser Routinen ein Dialog dargestellt,  so wird dieser 
nicht   von  Let 'em Fly!   unterstÅtzt,   da  der  TRAP-Handler   von 
Let 'em Fly! nicht reentrant ist.

Weiterhin muû der Programmierer dafÅr Sorge tragen, daû der Funktions-
Pointer  nach Beendigung des Dialogs auf '0L' zurÅckgesetzt  wird.  Es 
kînnten  sonst Åberraschende Effekte  (z.B.  Bomben)  auftreten.  Aus-
nahme:  Man  will nur mal kurz eine Alert-Box  darstellen.  In  diesem 
Fall wird die neue Tastenroutine von Let 'em Fly! nicht aufgerufen.

                --------------------------------------

Nachdem  Karsten  Isakovic  (Overscan and more)  schon  einen  kleinen 
Artikel  Åber  die auflîsungsunabhÑngige Programmierung  verfaût  hat, 
konnte  ich  mich mal wieder nicht zurÅckhalten  ...  hier  kommt  der 
'Artikel' zur ...

                PositionsunabhÑngige(n) Programmierung
                ======================================

Beim Testen von Let 'em Fly! ist mir aufgefallen, daû einige Programme 
Probleme bekamen, nachdem die Dialogbox verschoben wurde (z.B. Edison-
Utilities). Deshalb sollte man auf Folgendes achten:

Nach  jedem  form_do()  bzw.  di_fly()  kann  sich  die  Position  der 
Dialogbox   geÑndert  haben!   Falls  man  sich  nur  am  Anfang   die 
Koordinaten  der  Box  bzw.  der Objekte gemerkt  hat,  kann  man  bei 
Let 'em Fly!  eine  Bruchlandung  damit erleben.  Oft  wird  mit  VDI-
Routinen  in  die Dialogbox gemalt,  was ja auch nicht  verboten  oder 
'unsauber'  ist,  jedoch sollte man vorher ein objc_offset()  auf  das 
entsprechende Objekt machen.  Das GEM macht es ja genauso (sonst wÅrde 
es auch kein Let 'em Fly! geben).

Weiterhin gibt es oft Probleme mit dem Clipping-Rectangle beim  Zeich-
nen eines Dialogs,  nachdem die Position verÑndert wurde.  Man  sollte 
daher   immer   vor  dem  Zeichnen  eines   kompletten   Dialogs   ein 
form_center()  machen  und das erhaltene Clipping-Rectangle  auch  be-
nutzen.  Oft wird nur halt einmal am Programmanfang ein  form_center() 
auf alle Boxen gemacht,  wenn aber zwischenzeitlich die Box verschoben 
wurde  stimmen die Clipping-Werte beim objc_draw() nicht mehr und  die 
Box wird so nicht komplett gezeichnet.  Bei einzelnen Objekten  reicht 
ein obj_xywh() (z.B.  zum éndern eines Button-Status), auch wenn diese 
Funktion keine genauen Werte liefert.


                              Sonstiges
                              =========

Der Aufbau der RSCs fÅr die Icons der Alertboxen
------------------------------------------------
Let 'em Fly!  erwartet  in  der Datei LET_ICON.RSC drei  Icons  welche 
sinnvollerweise in einer G_BOX abgelegt sein sollten.  Die drei  Icons 
mÅssen von links nach rechts sortiert sein,  da sonst die  Zuweisungen 
nicht stimmen.  Die Grîûe der Icons betrÑgt 32x32 Pixel. Zum Editieren 
wird ein Resource-Construction-Set und u.U. ein Icon-Editor benîtigt.


Trappelshouting
---------------
Let 'em Fly!  klinkt  sich in den TRAP #2 (AES/VDI) und den  TRAP  #13 
(BIOS)  ein und benutzt dazu die XBRA-Kennung 'LTMF'.  Zudem wird  ein 
sog.  Cookie-Jar installiert (benutzt auch die Kennung 'LTMF'). Dieser 
zeigt auf die folgende Struktur:

typedef struct
{
        unsigned int    version;
        struct
        {
                unsigned light  : 1;    /* light version (read) */
                unsigned        : 2;    /* reserved             */
                unsigned flyswi : 1;    /* conf. flymode switch */
                unsigned vscr   : 1;    /* virtual scr. support */
                unsigned center : 1;    /* center mode          */
                unsigned keys   : 1;    /* key handling         */
                unsigned edit   : 1;    /* extended editor      */
                unsigned redraw : 1;    /* send redraw message  */
                unsigned flytyp : 1;    /* solid/hollow fly     */
                unsigned fly    : 1;    /* flying on/off        */
                unsigned alert  : 1;    /* Alerts/Errors on/off */
                unsigned v_mem  : 1;    /* use virtual memory   */
                unsigned f_grow : 1;    /* grow/shrink boxes    */
                unsigned g_grow : 1;
                unsigned bypass : 1;    /* ON/OFF highest prio  */
        } config;
        char    *vpath;                 /* path for v-mem       */
        void    cdecl   (*di_fly)(OBJECT *tree);
        void    cdecl   (*obj_clsize)(OBJECT *tree, int obj,
                                   int *x, int *y, int *w, int *h);
        int     cdecl   (*do_key)(int key, int kshift);
        int     cdecl   (*init_keys)(OBJECT *tree);
        int     cdecl   (*lookup_key)(int key, int kshift);
        long    res1;   /* reserved             */
        long    res2;   /* reserved             */
        int     ucol;   /* underscore color     */
        int     aicol;  /* alert icon color     */
        int     aframe; /* alert frame size     */
} LTMFLY;

'bypass'  entspricht Bit-No. 0 und eine 1  schaltet  Let 'em Fly!  aus 
und  eine  0  schaltet es ein.  Alle anderen  Bits  funktionieren  um-
gekehrt,  d.h.  1  fÅr  an  und 0 fÅr  aus,  also  nach  dem  gesunden 
Menschenverstand.
Einige  C  Compiler legen Bitfelder Åbrigens anders  als  Turbo-C  ab, 
daher:  Vorsicht.  'cdecl' heiût in Turbo-C, daû die ParameterÅbergabe 
auf  dem Stack erfolgt.  Eine Anpassung an andere (C-)Compiler  sollte 
kein groûes Problem darstellen.

'v_mem'  und '*vpath' ist noch nicht benutzt ('vpath' zeigt  zur  Zeit 
auf  einen String der LÑnge Null),  'light' dient zum Feststellen  der 
Version   und  ist  Read-Only!   Ebenso  sind  die  von   Let 'em Fly! 
bereitgestellten Funktionen Read-Only!




Meine Adresse ...

Oliver Scheel
Rothehausstr. 28
W-5000 Kîln 30

MausNet:  Oliver Scheel @ K2
InterNet: Oliver_Scheel@k2.maus.de


Let 'em Fly!     Man fliegt nicht mehr ohne ...




----
RÑchzschreipfÑler (c) 1991 by Oliver Scheel

