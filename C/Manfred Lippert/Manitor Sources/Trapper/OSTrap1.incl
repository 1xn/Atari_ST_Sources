#define ERSTER_VERSUCH 0#define ZWEITER_VERSUCH 1// Super-Mode selbst testen, oder Info in Struktur merken?// Selbst testen geht nur auf 68000!!!#define TEST_SUPER_MODE 0/* Gemeinsam benutzer Source-Code von Bios, Xbios und Gemdos -Trace! */#include <gemdos.h>static CALLSAVLTREE call_tree;static RETURNSAVLTREE return_tree;/* Routine in OS-Call-Trace einklinken: */int16 INSERT_CALL(int16 opcode, CALLFUNC func){	OSCALL *call = new OSCALL(func);						// Neues Glied mit Routine	if (!call) {		return ENSMEM;	}	CALLSAVL *callsAVL = call_tree.search(opcode);			// Opcode im Baum suchen	if (!callsAVL) {										// Opcode noch nicht getraced		callsAVL = new CALLSAVL(opcode);					// Neues Blatt im Opcode-Baum		if (!callsAVL) {			delete call;			return ENSMEM;		}		call_tree.insert(callsAVL);							// Blatt einfügen	}	callsAVL->get_calls()->insert(call, 0L, LINK_START);	// Call in Blatt einfügen	return E_OK;}/* Routine aus OS-Call-Trace ausklinken: */int16 REMOVE_CALL(int16 opcode, CALLFUNC func){	CALLSAVL *callsAVL = call_tree.search(opcode);	// Opcode im Baum suchen	if (!callsAVL) {		return ERROR;			// Fehler - Funktion kann gar nicht drin sein!	}	CALLKETTE *kette = callsAVL->get_calls();	OSCALL *call = kette->get_first();	while (call) {		if (call->get_func() == func) {			kette->kill(call);					// Routine ausklinken			if (!kette->get_first()) {			// Keine Routinen mehr drin?				call_tree.kill(callsAVL);		// Gesamtes Blatt löschen			}			return E_OK;		}		call = call->get_next();	}	return ERROR;			// Fehler - Funktion ist nicht drin}/* Routine in OS-Return-Trace einklinken: */int16 INSERT_RETURN(int16 opcode, RETURNFUNC func){	OSRETURN *call = new OSRETURN(func);				// Neues Glied mit Routine	if (!call) {		return ENSMEM;	}	RETURNSAVL *callsAVL = return_tree.search(opcode);	// Opcode im Baum suchen	if (!callsAVL) {									// Opcode noch nicht getraced		callsAVL = new RETURNSAVL(opcode);				// Neues Blatt im Opcode-Baum		if (!callsAVL) {			delete call;			return ENSMEM;		}		return_tree.insert(callsAVL);					// Blatt einfügen	}	callsAVL->get_calls()->insert(call);				// Routine in Blatt einfügen	return E_OK;}/* Routine aus OS-Return-Trace ausklinken: */int16 REMOVE_RETURN(int16 opcode, RETURNFUNC func){	RETURNSAVL *callsAVL = return_tree.search(opcode);	// Opcode im Baum suchen	if (!callsAVL) {		return ERROR;			// Fehler - Funktion kann gar nicht drin sein!	}	RETURNKETTE *kette = callsAVL->get_calls();	OSRETURN *call = kette->get_first();	while (call) {		if (call->get_func() == func) {			kette->kill(call);					// Routine ausklinken			if (!kette->get_first()) {			// Keine Routinen mehr drin?				return_tree.kill(callsAVL);		// Gesamtes Blatt löschen			}			return E_OK;		}		call = call->get_next();	}	return ERROR;			// Fehler - Funktion ist nicht drin}static int32 CALL_TRACE(__A0(int16 *para), __A1(int16 *call_original), __D1(int16 super_called)){	int32 ret = 0;	int16 opcode = *para;	CALLSAVL *callsAVL;	callsAVL = call_tree.search(-1);	if (callsAVL) {		int16 call_org;		OSCALL *call = callsAVL->get_calls()->get_first();		while (call) {			call_org = 1;			int32 ret2 = call->call(para, &call_org, super_called);			if (!call_org) {				ret = ret2;				*call_original = 0;			}			call = call->get_next();		}	}	callsAVL = call_tree.search(opcode);	if (callsAVL) {		int16 call_org;		OSCALL *call = callsAVL->get_calls()->get_first();		while (call) {			call_org = 1;			int32 ret2 = call->call(para, &call_org, super_called);			if (!call_org) {				ret = ret2;				*call_original = 0;			}			call = call->get_next();		}	}	return ret;}static int32 RETURN_TRACE(__D0(int32 ret), __A0(int16 *para), __D1(int16 is_super)){	int16 opcode = *para;	RETURNSAVL *callsAVL;	callsAVL = return_tree.search(opcode);	if (callsAVL) {		OSRETURN *call = callsAVL->get_calls()->get_first();		while (call) {			ret = call->call(ret, para, is_super);			call = call->get_next();		}	}	callsAVL = return_tree.search(-1);	if (callsAVL) {		OSRETURN *call = callsAVL->get_calls()->get_first();		while (call) {			ret = call->call(ret, para, is_super);			call = call->get_next();		}	}	return ret;}void CALLSAVLTREE::add_counter(int16 val){	if ((counter += val) == 0) {		LABEL_CALL_TRACED = 0;		if (!LABEL_RETURN_TRACED) {			LABEL_TRACED = 0;		}	} else {		LABEL_CALL_TRACED = 1;		LABEL_TRACED = 1;	}}void RETURNSAVLTREE::add_counter(int16 val){	if ((counter += val) == 0) {		LABEL_RETURN_TRACED = 0;		if (!LABEL_CALL_TRACED) {			LABEL_TRACED = 0;		}	} else {		LABEL_RETURN_TRACED = 1;		LABEL_TRACED = 1;	}}// Erster Versuch:#if ERSTER_VERSUCHstatic asm void XBRA_asm(void){entry extern LABEL_TRACED	dc.w 0entry extern LABEL_CALL_TRACED	dc.w 0entry extern LABEL_RETURN_TRACED	dc.w 0entry extern LABEL_XBRA	dc.l 'XBRA'	dc.l 'Trpp'old:	dc.l 0neu:/* A5-World: */	subq.l #4,sp		/* Platz für Jump-Adresse */	move.l a5,-(sp)		/* A5 retten */	dc.w 0x2A79			/* movea.l _A5world_ptr,a5  - A5-World herstellen! */	dc.l _A5world_ptr 	tst.w LABEL_TRACED	beq not_traced		/* Schicht wird gar nicht getraced, sofort wieder raus *//*#define STK 24#define REGS d1/d2/a0/a1*/#define STK 28#define REGS d1/d2/a0/a1/a2#ifdef REGS	movem.l REGS,-(sp)#endif/* A0: void *para ermitteln: */	moveq.l #0,d1		/* default: is not super */	move.l usp,a0	btst #5,STK(sp)		/* SR am Stack: Aufruf aus User-Mode? */	beq.s have_stack	/* Dann ist USP der richtige Stack */	moveq.l #1,d1		/* is super */	lea STK+6(sp),a0	/* Ansonsten Stackabschnitt mit Parametern in a0 */	tst.w 0x59e			/* longframe? */	beq.s have_stack	addq.l #2,a0have_stack:	moveq.l #1,d2			// d2: call_original-Flag!	tst.w LABEL_CALL_TRACED	beq.s after/* Vor Einsprung tracen: *//* A1: int16 *call_original: */	move.w d2,-(sp)			/* Platz für call_original-Flag, Standardwert: TRUE */	move.l sp,a1	move.l a0,-(sp)			/* brauchen wir nochmal */	jsr CALL_TRACE			/* Einsprung tracen!!! */	move.l (sp)+,a0	move.w (sp)+,d2			// d2: call_original-Flag!after:	tst.w LABEL_RETURN_TRACED	beq exit/* Nach Einsprung tracen: */	btst #5,STK(sp)		/* SR am Stack: Aufruf aus User-Mode? */	beq after_usermode#define PARAS 32/* Nach Einsprung tracen, Aufruf im Super-Mode: */	move.l 0x436,a2				// _memtop	cmpa.l a0,a2				// _memtop - Userstack	ble.s super_STcheckOK		// Userstack liegt über ST-Ram - kein Check	suba.l a0,a2				// _memtop - Userstack	cmp.l #PARAS,a2				// Userstack liegt mind. 32 (PARAS) Bytes unter _memtop	bge.s super_STcheckOK	move.l d3,-(sp)				// d3 sichern	move.w a2,d3				// neue Anzahl Parameter (Bytes)	and.w #0xFFFC,d3			// durch 4 teilbar	moveq.l #PARAS,d1			// Anzahl Parameter (Bytes)	sub.w d3,d1					// PARAS - Neue Anzahl = zu "überspringende" Anzahl	move.l (sp)+,d3				// d3 wiederherstellen	sub.w d1,sp	lea super_copy_paras,a2	adda.w d1,a2				// Start der Kopieraktion	jmp (a2)super_STcheckOK:	cmp.l #0x1357bd13,0x5a8		// ramvalid?	bne.s super_TTcheckOK	move.l 0x5a4,a2				// ramtop	cmpa.l a0,a2				// ramtop - Userstack	ble.s super_TTcheckOK		// Userstack liegt über TT-Ram - kein Check	suba.l a0,a2				// ramtop - Userstack	cmp.l #PARAS,a2				// Userstack liegt mind. 32 (PARAS) Bytes unter ramtop	bge.s super_TTcheckOK	move.l d3,-(sp)				// d3 sichern	move.w a2,d3				// neue Anzahl Parameter (Bytes)	and.w #0xFFFC,d3			// durch 4 teilbar	moveq.l #PARAS,d1			// Anzahl Parameter (Bytes)	sub.w d3,d1					// PARAS - Neue Anzahl = zu "überspringende" Anzahl	move.l (sp)+,d3				// d3 wiederherstellen	sub.w d1,sp	lea super_copy_paras,a2	adda.w d1,a2				// Start der Kopieraktion	jmp (a2)super_TTcheckOK:super_copy_paras:	move.l 28(a0),-(sp)	/* Parameter+Opcode (32 Bytes) kopieren */	move.l 24(a0),-(sp)	/* Parameter+Opcode (32 Bytes) kopieren */	move.l 20(a0),-(sp)	/* Parameter+Opcode (32 Bytes) kopieren */	move.l 16(a0),-(sp)	/* Parameter+Opcode (32 Bytes) kopieren */	move.l 12(a0),-(sp)	/* Parameter+Opcode (32 Bytes) kopieren */	move.l 8(a0),-(sp)	/* Parameter+Opcode (32 Bytes) kopieren */	move.l 4(a0),-(sp)	/* Parameter+Opcode (32 Bytes) kopieren */	move.l (a0),-(sp)	/* Parameter+Opcode (32 Bytes) kopieren */	tst.w 0x59e			/* longframe? */	beq.s after_nolong	move.w PARAS+STK+6(sp),-(sp)	/* longframe kopieren */	lea 2+PARAS+STK+4(sp),a0		/* Adresse Returncode (noch nicht wirklich da) */	move.l a0,2+PARAS+STK-4(sp)		/* in Adresse "Platz für Jump" schreiben (siehe Notizen) */	move.l -2(a0),(a0)				/* Adresse um 2 Bytes verschieben */	lea after_super,a0	move.l a0,-(sp)					/* verbogener Return */	move.w 4+2+PARAS+STK(sp),-(sp)	/* SR kopieren */	tst.w d2						// call_original?	beq.s exit_direct_long#ifdef REGS	movem.l PARAS+8(sp),REGS#endif	move.l old,-(sp)				/* Jump-Adresse */	move.l 4+PARAS+8+STK-8(sp),a5	rts								/* Zurück in Original-Trap */exit_direct_long:#ifdef REGS	movem.l PARAS+8(sp),REGS#endif	move.l PARAS+8+STK-8(sp),a5	rte							// direkt zurückafter_nolong:	lea PARAS+STK+2(sp),a0			/* Adresse Returncode */	move.l a0,PARAS+STK-4(sp)		/* in Adresse "Platz für Jump" schreiben (siehe Notizen) */	lea after_super,a0	move.l a0,-(sp)					/* verbogener Return */	move.w 4+PARAS+STK(sp),-(sp)	/* SR kopieren */	tst.w d2						// call_original?	beq.s exit_direct_nolong#ifdef REGS	movem.l PARAS+6(sp),REGS#endif	move.l old,-(sp)				/* Jump-Adresse */	move.l 4+PARAS+6+STK-8(sp),a5	rts								/* Zurück in Original-Trap */exit_direct_nolong:#ifdef REGS	movem.l PARAS+6(sp),REGS#endif	move.l PARAS+6+STK-8(sp),a5	rte							// direkt zurück/* Nach Einsprung tracen, Aufruf im User-Mode: */after_usermode:/*	lea STK(sp),a1	cmp.l a1,a0	blt.s stacks_ok			// USP liegt irgendwo "unter" SSP	add.l #32,a1	cmp.l a1,a0	blt.s exit				// USP und SSP überlappen sich!stacks_ok:*/	lea PARAS(a0),a1			// Anfang zu kopierender Parameter	move.l 0x436,a2				// _memtop	cmpa.l a0,a2				// _memop - Userstack	ble.s user_STcheckOK				// Userstack liegt über ST-Ram - kein Check	suba.l a0,a2				// _memop - Userstack	cmp.l #PARAS,a2				// Userstack liegt mind. 32 (PARAS) Bytes unter _memtop	bge.s user_STcheckOK	move.l d3,-(sp)				// d3 sichern	move.w a2,d3				// neue Anzahl Parameter (Bytes)	and.w #0xFFFC,d3			// durch 4 teilbar	moveq.l #PARAS,d1			// Anzahl Parameter (Bytes)	sub.w d3,d1					// PARAS - Neue Anzahl = zu "überspringende" Anzahl	move.l (sp)+,d3				// d3 wiederherstellen	suba.w d1,a1				// Anfang zu kopierender Paramater korrigieren	move.l STK+2(sp),-(a0)		// Alte Returnadresse auf USP	suba.w d1,a0				// Anfang zu kopierender Paramater korrigieren	lsr.w #1,d1					// überspringende PARAS / 2	lea copy_paras,a2	adda.w d1,a2				// Start der Kopieraktion	jmp (a2)user_STcheckOK:	cmp.l #0x1357bd13,0x5a8		// ramvalid?	bne.s user_TTcheckOK	move.l 0x5a4,a2				// ramtop	cmpa.l a0,a2				// ramtop - Userstack	ble.s user_TTcheckOK		// Userstack liegt über TT-Ram - kein Check	suba.l a0,a2				// ramtop - Userstack	cmp.l #PARAS,a2				// Userstack liegt mind. 32 (PARAS) Bytes unter ramtop	bge.s user_TTcheckOK	move.l d3,-(sp)				// d3 sichern	move.w a2,d3				// neue Anzahl Parameter (Bytes)	and.w #0xFFFC,d3			// durch 4 teilbar	moveq.l #PARAS,d1			// Anzahl Parameter (Bytes)	sub.w d3,d1					// PARAS - Neue Anzahl = zu "überspringende" Anzahl	move.l (sp)+,d3				// d3 wiederherstellen	suba.w d1,a1				// Anfang zu kopierender Paramater korrigieren	move.l STK+2(sp),-(a0)		// Alte Returnadresse auf USP	suba.w d1,a0				// Anfang zu kopierender Paramater korrigieren	lsr.w #1,d1					// überspringende PARAS / 2	lea copy_paras,a2	adda.w d1,a2				// Start der Kopieraktion	jmp (a2)user_TTcheckOK:	move.l STK+2(sp),-(a0)		// Alte Returnadresse auf USPcopy_paras:	move.l -(a1),-(a0)			// Parameter+Opcode (32 Bytes) kopieren	move.l -(a1),-(a0)			// Parameter+Opcode (32 Bytes) kopieren	move.l -(a1),-(a0)			// Parameter+Opcode (32 Bytes) kopieren	move.l -(a1),-(a0)			// Parameter+Opcode (32 Bytes) kopieren	move.l -(a1),-(a0)			// Parameter+Opcode (32 Bytes) kopieren	move.l -(a1),-(a0)			// Parameter+Opcode (32 Bytes) kopieren	move.l -(a1),-(a0)			// Parameter+Opcode (32 Bytes) kopieren	move.l -(a1),-(a0)			// Parameter+Opcode (32 Bytes) kopieren	move.l a0,usp				// Neuer Userstack		lea after_user,a1	move.l a1,STK+2(sp)			/* Return verbiegen */exit:	tst.w d2					// call_original?	beq.s exit_directexit_pterm:#ifdef REGS	movem.l (sp)+,REGS#endifnot_traced:	move.l old,4(sp)		/* Jump-Adresse eintragen */	move.l (sp)+,a5			/* A5 Wiederherstellen */	rts						/* Zurück in Original-Trap */exit_direct:#ifdef REGS	movem.l (sp)+,REGS#endif	move.l (sp)+,a5			/* A5 Wiederherstellen */	addq.l #4,sp	rte#define AFTER_REGS d1/d2/a0/a1/a5#define AFTER_STK 20after_user:	add.l #32,sp	movem.l AFTER_REGS,-(sp)	lea AFTER_STK+4(sp),a0	dc.w 0x2A79				/* movea.l _A5world_ptr,a5  - A5-World herstellen! */	dc.l _A5world_ptr 	moveq.l #0,d1			/* is not super */	jsr RETURN_TRACE		/* Returnwert tracen!!! */	movem.l (sp)+,AFTER_REGS	rtsafter_super:	move.l PARAS+STK-4(sp),sp		/* Stack korrigieren (Returnadresse holen) */	movem.l AFTER_REGS,-(sp)	lea AFTER_STK+4(sp),a0	dc.w 0x2A79				/* movea.l _A5world_ptr,a5  - A5-World herstellen! */	dc.l _A5world_ptr	moveq.l #1,d1			/* is super */	jsr RETURN_TRACE		/* Returnwert tracen!!! */	movem.l (sp)+,AFTER_REGS	rts}#endif// Zweiter Versuch:#if ZWEITER_VERSUCH#define JUMPTABLESIZE 32typedef struct {	uint32 old_return;	// ds.l 1: Alte Returnadresse (Aufrufer der OS-Routine)	uint16 is_super;		// ds.w 1: Flag, ob Routine im Supermode aufgerufen wurde	uint32 paraptr;		// ds.l 1: Zeiger auf Parameter	uint32 auf_stack;		// move.l -10(pc),-(sp): old_return auf Stack	uint32 regsave;		// movem.l d1/d2/a0/a1/a5,-(sp): Register sichern	uint32 seta0;			// lea -18(pc),a1: Adresse von JumpTableEntry in a1	uint16 jmp;				// jmp after_trap: Engültigen "after_trap"-Code anspringen	void (*after_trap)();	int32 dummy;			// damit sizeof(JUMPTABLEENTRY) == 32 !} JUMPTABLEENRTY;// sizeof(JUMPTABLEENTRY) = 32#if COUNT_JUMPTABLE_USEstatic int16 JUMPTABLECOUNTER;	// Anzahl gleichzeitiger JumpTableEntry-Benutzungint16 JUMPTABLECOUNTERMAX;			// Maximale gleichzeitige Benutzung#endifstatic asm void after_trap(void) {	// A1 zeigt auf JUMPTABLEENTRY	dc.w 0x2A79			/* movea.l _A5world_ptr,a5  - A5-World herstellen! */	dc.l _A5world_ptr #if !TEST_SUPER_MODE	move.w 4(a1),d1					// is_super in D1#else	move.w SR,d1	and.w #0x2000,d1					// is super in D1#endif	move.l 6(a1),a0					// paraptr in A0	clr.l (a1)							// JumpTableEntry freigeben#if COUNT_JUMPTABLE_USE	sub.w #1,JUMPTABLECOUNTER#endif	jsr RETURN_TRACE					// Returnwert tracen!!!	movem.l (sp)+,d1/d2/a0/a1/a5	// Register restaurieren	rts									// Zurück zum Aufrufer der OS-Routine!}static JUMPTABLEENRTY JUMPTABLE[JUMPTABLESIZE] = {	{		0,0,0,						// old_return, is_super, paraptr		0x2F3AFFF4,					// move.l -10(pc),-(sp): old_return auf Stack		0x48E760C4,					// movem.l d1/d2/a0/a1/a5,-(sp): Register sichern		0x43FAFFEC,					// lea -18(pc),a1: Adresse von JumpTableEntry in a1		0x4EF9, &after_trap		// jmp after_trap: Engültigen "after_trap"-Code anspringen	},																						// 0	{0,0,0, 0x2F3AFFF4, 0x48E760C4, 0x43FAFFEC, 0x4EF9, &after_trap},	// 1	{0,0,0, 0x2F3AFFF4, 0x48E760C4, 0x43FAFFEC, 0x4EF9, &after_trap},	// 2	{0,0,0, 0x2F3AFFF4, 0x48E760C4, 0x43FAFFEC, 0x4EF9, &after_trap},	// 3	{0,0,0, 0x2F3AFFF4, 0x48E760C4, 0x43FAFFEC, 0x4EF9, &after_trap},	// 4	{0,0,0, 0x2F3AFFF4, 0x48E760C4, 0x43FAFFEC, 0x4EF9, &after_trap},	// 5	{0,0,0, 0x2F3AFFF4, 0x48E760C4, 0x43FAFFEC, 0x4EF9, &after_trap},	// 6	{0,0,0, 0x2F3AFFF4, 0x48E760C4, 0x43FAFFEC, 0x4EF9, &after_trap},	// 7	{0,0,0, 0x2F3AFFF4, 0x48E760C4, 0x43FAFFEC, 0x4EF9, &after_trap},	// 8	{0,0,0, 0x2F3AFFF4, 0x48E760C4, 0x43FAFFEC, 0x4EF9, &after_trap},	// 9	{0,0,0, 0x2F3AFFF4, 0x48E760C4, 0x43FAFFEC, 0x4EF9, &after_trap},	// 10	{0,0,0, 0x2F3AFFF4, 0x48E760C4, 0x43FAFFEC, 0x4EF9, &after_trap},	// 11	{0,0,0, 0x2F3AFFF4, 0x48E760C4, 0x43FAFFEC, 0x4EF9, &after_trap},	// 12	{0,0,0, 0x2F3AFFF4, 0x48E760C4, 0x43FAFFEC, 0x4EF9, &after_trap},	// 13	{0,0,0, 0x2F3AFFF4, 0x48E760C4, 0x43FAFFEC, 0x4EF9, &after_trap},	// 14	{0,0,0, 0x2F3AFFF4, 0x48E760C4, 0x43FAFFEC, 0x4EF9, &after_trap},	// 15	{0,0,0, 0x2F3AFFF4, 0x48E760C4, 0x43FAFFEC, 0x4EF9, &after_trap},	// 16	{0,0,0, 0x2F3AFFF4, 0x48E760C4, 0x43FAFFEC, 0x4EF9, &after_trap},	// 17	{0,0,0, 0x2F3AFFF4, 0x48E760C4, 0x43FAFFEC, 0x4EF9, &after_trap},	// 18	{0,0,0, 0x2F3AFFF4, 0x48E760C4, 0x43FAFFEC, 0x4EF9, &after_trap},	// 19	{0,0,0, 0x2F3AFFF4, 0x48E760C4, 0x43FAFFEC, 0x4EF9, &after_trap},	// 20	{0,0,0, 0x2F3AFFF4, 0x48E760C4, 0x43FAFFEC, 0x4EF9, &after_trap},	// 21	{0,0,0, 0x2F3AFFF4, 0x48E760C4, 0x43FAFFEC, 0x4EF9, &after_trap},	// 22	{0,0,0, 0x2F3AFFF4, 0x48E760C4, 0x43FAFFEC, 0x4EF9, &after_trap},	// 23	{0,0,0, 0x2F3AFFF4, 0x48E760C4, 0x43FAFFEC, 0x4EF9, &after_trap},	// 24	{0,0,0, 0x2F3AFFF4, 0x48E760C4, 0x43FAFFEC, 0x4EF9, &after_trap},	// 25	{0,0,0, 0x2F3AFFF4, 0x48E760C4, 0x43FAFFEC, 0x4EF9, &after_trap},	// 26	{0,0,0, 0x2F3AFFF4, 0x48E760C4, 0x43FAFFEC, 0x4EF9, &after_trap},	// 27	{0,0,0, 0x2F3AFFF4, 0x48E760C4, 0x43FAFFEC, 0x4EF9, &after_trap},	// 28	{0,0,0, 0x2F3AFFF4, 0x48E760C4, 0x43FAFFEC, 0x4EF9, &after_trap},	// 29	{0,0,0, 0x2F3AFFF4, 0x48E760C4, 0x43FAFFEC, 0x4EF9, &after_trap},	// 30	{0,0,0, 0x2F3AFFF4, 0x48E760C4, 0x43FAFFEC, 0x4EF9, &after_trap}	// 31};static int16 JUMPTABLENEXT;static asm void XBRA_asm(void){entry extern LABEL_TRACED	dc.w 0entry extern LABEL_CALL_TRACED	dc.w 0entry extern LABEL_RETURN_TRACED	dc.w 0entry extern LABEL_XBRA	dc.l 'XBRA'	dc.l 'Trpp'old:	dc.l 0neu:	subq.l #4,sp		/* Platz für Jump-Adresse *//* A5-World: */	move.l a5,-(sp)	/* A5 retten */	dc.w 0x2A79			/* movea.l _A5world_ptr,a5  - A5-World herstellen! */	dc.l _A5world_ptr 	tst.w LABEL_TRACED	beq not_traced		/* Schicht wird gar nicht getraced, sofort wieder raus */#define STK 36#define REGS d1/d2/d3/d4/a0/a1/a2	movem.l REGS,-(sp)/* A0: void *para ermitteln: */	moveq.l #0,d1		/* default: is not super */	move.l usp,a0	btst #5,STK(sp)	/* SR am Stack: Aufruf aus User-Mode? */	beq.s have_stack	/* Dann ist USP der richtige Stack */	moveq.l #1,d1		/* is super */	lea STK+6(sp),a0	/* Ansonsten Stackabschnitt mit Parametern in a0 */	tst.w 0x59e			/* longframe? */	beq.s have_stack	addq.l #2,a0have_stack:	moveq.l #1,d2			// d2: call_original-Flag!	tst.w LABEL_CALL_TRACED	beq.s after/* Vor Einsprung tracen: *//* A1: int16 *call_original: */	move.w d2,-(sp)		/* Platz für call_original-Flag, Standardwert: TRUE */	move.l sp,a1	move.l a0,-(sp)		/* paraptr brauchen wir nochmal */#if !TEST_SUPER_MODE	move.w d1,-(sp)		/* is_super brauchen wir nochmal */#endif	jsr CALL_TRACE			/* Einsprung tracen!!! */#if !TEST_SUPER_MODE	move.w (sp)+,d1#endif	move.l (sp)+,a0	move.w (sp)+,d2			// d2: call_original-Flag!after:	tst.w LABEL_RETURN_TRACED	beq.s exit#if OSTRAP_IS_GEMDOS/* Pterm, Pterm0 und Ptermres dürfen nicht "Return-Traced" werden! */	tst.w (a0)		// Pterm0?	beq.s exit	cmp.w #76,(a0)	// Pterm?	beq.s exit	cmp.w #49,(a0)	// Ptermres?	beq.s exit#endif/* Nach Einsprung tracen: */	move.w JUMPTABLENEXT,d3		// Suchposition in Tabelle	lsl.w #5,d3						// JUMPTABLENEXT * sizeof(JUMPTABLEENTRY)   (*32)	lea JUMPTABLE,a1	adda.w d3,a1						// JUMPTABLE[JUMPTABLENEXT]	moveq.l #JUMPTABLESIZE-1,d4table_search:	tst.l (a1)						// Eintrag frei?	beq.s entry_found	adda.w #32,a1	addq.w #1,d3	cmp.w #JUMPTABLESIZE,d3		// Ende erreicht?	blt.s no_wrap1	moveq.l #0,d3					// vorne anfangen	lea JUMPTABLE,a1no_wrap1:	dbra.s d4,table_search	bra.s exit					// Keinen freien Tabelleneintrag gefunden (sollte normalerweise nie passieren)entry_found:	addq.w #1,d3				// Noch einmal hochzählen	cmp.w #JUMPTABLESIZE,d3	// Ende erreicht?	blt.s no_wrap2	moveq.l #0,d3				// vorne anfangenno_wrap2:	move.w d3,JUMPTABLENEXT	// Diese Suchposition merken#if !TEST_SUPER_MODE		move.w d1,4(a1)			// is_super eintragen#endif	move.l a0,6(a1)			// paraptr eintragen	move.l STK+2(sp),(a1)	// old_return eintragen	lea 10(a1),a1	move.l a1,STK+2(sp)		// Return verbiegen#if COUNT_JUMPTABLE_USE	add.w #1,JUMPTABLECOUNTER	move.w JUMPTABLECOUNTER,d3	cmp.w JUMPTABLECOUNTERMAX,d3	ble.s count_OK	move.w d3,JUMPTABLECOUNTERMAXcount_OK:#endifexit:	tst.w d2					// call_original?	beq.s exit_directexit_pterm:	movem.l (sp)+,REGSnot_traced:	move.l old,4(sp)		/* Jump-Adresse eintragen */	move.l (sp)+,a5		/* A5 Wiederherstellen */	rts						/* Zurück in Original-Trap */exit_direct:	movem.l (sp)+,REGS	move.l (sp)+,a5		/* A5 Wiederherstellen */	addq.l #4,sp	rte}#endif