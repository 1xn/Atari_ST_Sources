Trapper V2.00
=============

Geschrieben von Manfred Lippert
Email: mani@mani.de
Web:   http://www.mani.de/


Was ist Trapper?
================

Trapper ist ein Programm, das die Entwicklung von Systemerweiterungen
fÅr Programmierer enorm vereinfacht.

Mit Hilfe von Trapper kînnen sich andere Programme effektiv und
einfach vor und hinter Systemaufrufe hÑngen, diese sogar ganz
ersetzen, oder dem System neue Systemaufrufe hinzufÅgen.

Dazu ist keine Assemblerprogrammierung mehr notwendig. Man kann sofort
jede beliebige C-Routine ins System einklinken. Andere
Programmiersprachen sind ebenfalls denkbar.


Installation
============

Trapper gehîrt in den AUTO-Ordner. Zu Testzwecken kann es auch
nachtrÑglich vom Desktop aus gestartet werden.

Zu beachten ist, daû Trapper natÅrlich vor allen Systemerweiterungen
gestartet werden muû, die Trapper benîtigen.

Unter MagiC benutzt man zur Festlegung der AUTO-Ordner-Reihenfolge am
besten die Datei AUTOEXEC.BAT (siehe MagiC-Doku).


Freeware
========

Trapper darf beliebig - aber nur zusammen mit diesem Text und beides
unverÑndert - weitergegeben werden.

Trapper darf nur von Freeware-Programmen benutzt werden. Soll Trapper
von kommerziellen Programmen genutzt werden, so muû dies mit mir
abgesprochen werden: Mail an mani@mani.de.


Ich will es genauer wissen
==========================

FÅr viele clevere Tools ist es notwendig, sich in bestimmte
Systemaufrufe der verschiedenen Systemschichten (Bios, Xbios, Gemdos,
VDI oder AES) einzuklinken. Dazu waren bisher immer
Assembler-Kenntnisse notwendig. Die grîûte Schwierigkeit besteht
darin, daû die neu eingeklinkten Funktionen vollkommen reentrant sein
mÅssen.

Solange man sich nur _vor_ eine Systemfunktion hÑngt, ist das nicht
weiter schwierig: Man verbiegt den Vektor der Systemfunktion auf eine
eigene Funktion und in nach der eigenen Funktion springt man wieder an
die originale Funktion. (Am besten macht man das mit dem
XBRA-Verfahren.)

Enorme Probleme handelt man sich jedoch ein, wenn man sich _hinter_
Systemfunktionen hÑngen will, z.B. um Returnwerte zu manipulieren,
oder um Aktionen ausfÅhren zu kînnen, die man nur um User-Modus machen
darf: Man muû den RÅcksprung-Zeiger (der auf dem Stack liegt) auf eine
eigene Routine verbiegen und dann den Systemaufruf normal weiterlaufen
lassen. Kehrt der Systemaufruf zurÅck, hat man wieder die Kontrolle
und muû anschlieûend natÅrlich wieder an die ursprÅngliche
Return-Adresse zurÅckspringen. Letzteres birgt die Schwierigkeit: Wo
merkt man sich die alte Returnadresse, damit das ganze reentrant
bleibt? Da muû man sich schon Tricks einfallen lassen ... ;-)

Jeder Programmierer, der ein tooles Tool schreiben will, das sich in
Systemaufrufe hÑngt, hat mit dieser Problematik zu kÑmpfen. Als
Nebeneffekt wird das System bei jedem solchen Tool geringfÅgig
langsamer und der Stackverbrauch hîher - evtl. so hoch, daû es zu
SystemabstÅrzen kommen kann...

Hier versucht Trapper in mehrfacher Hinsicht Abhilfe zu schaffen:

Anstatt sich selbst in Systemaufrufe hÑngen zu mÅssen, ÅberlÑût man
dies einfach Trapper und meldet die einzuklinkenden Funktionen bei ihm
an.

Das hat folgende Vorteile:

- Man muû sich nicht mit komplizierter Assembler-Programmierung
herumschlagen. Man kann sich mit ganz normalen C-Funktionen sowohl vor
als auch hinter (!) beliebige Systemaufrufe klinken. (Auch andere
Programmiersprachen sind denkbar.) Die Entwicklung von
Systemerweiterungen wird dadurch enorm vereinfacht.

- Es hÑngt nur noch eine Instanz in den Systemaufrufen, wodurch
Geschwindigkeit und Stackverbrauch konstant sind.

- Man kann Trapper mitteilen, fÅr welchem Funktionsopcode die
eingeklinkte Funktion zustÑndig sein soll. Somit entfÑllt das
Dispatchen von Opcodes jedes einzeln eingeklinkten Programms und das
System wird nicht gebremst. Trapper findet eingeklinkte Funktionen
besonders schnell Åber spezielle Algorithmen (BÑume und Listen). Der
Overhead wird selbst bei enorm vielen eingeklinkten Funktionen nicht
in der Geschwindigkeit spÅrbar.

- Ein Programm kann sich problemlos wieder aus Systemaufrufen
ausklinken und sich beenden. HÑngt das Programm selbst direkt im
Systemaufruf und verbiegt Returnadressen, so hat es das enorme
Problem, daû es sich erst beenden kann, wenn alle mit verbogener
Returnadresse aufgerufenen Funktionen wieder zurÅckgekehrt sind. Viele
Systemaufrufe kehren aber u.U. sehr lange nicht zurÅck, z.B. Pexec()
oder die evnt_-Funktionen des AES. Da man Åber Trapper "indirekt" in
den Aufrufen hÑngt, ist das AushÑngen problemlos mîglich.


FÅr Programmierer
=================

Trapper klinkt sich ins Bios, Xbios, Gemdos, VDI und AES. Als
Schnittstelle zu Trapper wurde die Xbios-Funktion Nummer 555 mit
folgender Aufrufkonvention gewÑhlt:

int32 Trapper(int16 layer, int16 install, int16 opcode, void *function);

Man sollte unbedingt den RÅckgabewert von Trapper testen. Falls das
Einklinken funktioniert hat, wird E_OK geliefert, ansonsten ein
anderer Wert (z.B. ENSMEM, falls kein Speicher mehr verfÅgbar ist).

Die Parameter:

layer: Gibt die Systemschicht an, in die eine Funktion eingeklinkt
werden soll. Folgende Werte sind mîglich:

#define TRAPPER_CHECK  -1
#define TRAPPER_BIOS    0
#define TRAPPER_XBIOS   1
#define TRAPPER_GEMDOS  2
#define TRAPPER_VDI     3
#define TRAPPER_AES     4

TRAPPER_CHECK: Spezielle Funktion, um das Vorhandensein von Trapper zu
testen. "install", "opcode" sollten auf 0 gesetzt werden, "function"
ist entweder NULL oder zeigt auf folgende Struktur:

typedef struct {
	int16 version;     /* BCD coded, e.g. 0x110 for Version 1.10 */
	int16 reserved[15];
} TrapperInfo;

Ist Trapper installiert, so liefert Trapper(TRAPPER_CHECK) den Wert
E_OK (0) und fÅllt obige Struktur aus. Ansonsten wird ein Wert
ungleich E_OK geliefert, und man kann Trapper nicht benutzen.

TRAPPER_BIOS, TRAPPER_XBIOS, TRAPPER_GEMDOS, TRAPPER_VDI und
TRAPPER_AES geben die entsprechende Systemschicht an, in die die
Funktion "function" eingeklinkt werden soll. Je nach Schicht hat
function eine (geringfÅgig) abweichende Aufrufkonvention (s.u.).

install: Legt fest, was mit "function" passieren soll:

#define TRAPPER_INSTALL_CALL    0
#define TRAPPER_REMOVE_CALL     1
#define TRAPPER_INSTALL_RETURN  2
#define TRAPPER_REMOVE_RETURN   3

TRAPPER_INSTALL_CALL: Installiert die Funktion _vor_ den Systemaufruf.

TRAPPER_INSTALL_RETURN: Installiert die Funktion _hinter_ den
Systemaufruf.

TRAPPER_REMOVE_CALL und TRAPPER_INSTALL_RETURN entfernen die
betreffenden Funktionen wieder aus Trapper.

opcode: Legt den Funktions-Opcode fest, bei dem die Funktion
aufgerufen werden soll. öbergibt man -1, so wird die Funktion bei
_jeder_ Funktion der Systemschicht aufgerufen.

function: Zeigt auf die einzuklinkende bzw. zu entfernende Funktion.
(Ausnahme: TRAPPER_CHECK, siehe oben.)

Je nach Systemschicht (layer) und Installation (install) gelten
folgende Funktions-Typen (Aufrufkonventionen):

typedef int32 CDECL (*BiosCallFunc)(int16 *para, int16 *call_original, int16 super_called);
typedef int32 CDECL (*BiosReturnFunc)(int32 ret, int16 *para, int16 is_super);

typedef int32 CDECL (*XbiosCallFunc)(int16 *para, int16 *call_original, int16 super_called);
typedef int32 CDECL (*XbiosReturnFunc)(int32 ret, int16 *para, int16 is_super);

typedef int32 CDECL (*GemdosCallFunc)(int16 *para, int16 *call_original, int16 super_called);
typedef int32 CDECL (*GemdosReturnFunc)(int32 ret, int16 *para, int16 is_super);

typedef void CDECL (*VDICallFunc)(VDIPB *para, int16 *call_original, int16 super_called);
typedef void CDECL (*VDIReturnFunc)(VDIPB *para, int16 is_super);

typedef void CDECL (*AESCallFunc)(AESPB *para, int16 *call_original, int16 super_called);
typedef void CDECL (*AESReturnFunc)(AESPB *para, int16 is_super);

CDECL bedeutet, daû die Funktion nach C-Konvention die Parameter auf
dem Stack Åbergeben bekommt (in Pure-C schreibt man dafÅr "cdecl").
int16 ist ein 16-Bit Integer (in Pure-C "int" oder "short"), int32 ist
ein 32-Bit Integer (in Pure-C "long").

Der RÅckgabewert wird wie in C Åblich Åber das Register D0
zurÅckgeliefert.

Die Funktionen dÅrfen - nach C-Konvention - nur die Register
D0,D1,D2,A0,A1 verÑndern. Alle anderen Register mÅssen nach der
Funktion wiederhergestellt werden. Alle mir bekannten C-Compiler
halten sich an diese Konvention.

"para" zeigt bei Bios, Xbios und Gemdos auf den Stackbereich mit dem
Opcode und den Parametern. para[0] ist z.B. der Opcode der Funktion.
Dahinter stehen die eigentlichen Parameter, die natÅrlich vom Opcode
abhÑngig sind.

Eine besondere Rolle spielt "call_original": Diese Variable zeigt auf
ein Flag, ob nach der AusfÅhrung der Funktion die originale
Systemfunktion aufgerufen werden soll. *call_original hat bei Aufruf
der Funktion immer den Wert 1 (true), muû also im Normalfall nicht
verÑndert werden. Will man die originale Systemfunktion ersetzen,
setzt man *call_original auf 0 (false).

Der RÅckgabewert der "Call"-Funktionen spielt normalerweise nur dann
eine Rolle, wenn *call_original auf 0 gesetzt wurde, oder wenn man dem
System eine gÑnzlich neue Funktion hinzufÅgt (es also gar keine
Originalfunktion gibt). In allen anderen FÑllen sollte man einfach
E_OK (0) zurÅckliefern.

"super_called" (bei "Call"-Funktionen) enthÑlt 0 (false), falls die
Systemfunktion aus dem User-Modus heraus aufgerufen wurde und 1
(true), falls sie aus dem Supervisor-Modus heraus aufgerufen wurde. Zu
beachten ist, daû man sich natÅrlich wÑhrend der AusfÅhrung der
Funktion immer im Supervisor-Modus befindet! Man ist ja quasi "im"
Trap.

"is_super" (bei "Return"-Funktionen) enthÑlt 0 (false), falls man sich
gerade im User-Modus befindet und 1 (true), falls man sich gerade im
Supervisor-Modus befindet.

Man sollte unbedingt darauf achten, daû die Funktionen so wenig Stack
wie mîglich benutzen.

In "Call"-Funktionen, also wenn man sich vor Funktionen hÑngt,
befindet man sich immer im Supervisor-Modus und benutzt also den
Supervisor-Stack (der u.U. auch dem Userstack des jeweiligen Programms
entsprechen kann, falls dieses per Super() in den Supervisor-Modus
geschaltet hat).

In "Return"-Funktionen, also wenn man sich hinter Funktionen hÑngt,
benutzt man normalerweise den Stack des Programms, der die
Systemfunktion aufgerufen hat. Man sollte also immer im Hinterkopf
behalten, daû man "fremde" Stacks benutzt, von denen man nicht weiû,
wie groû sie sind, und deshalb so wenig Stack wie mîglich benutzen.


Wichtig: Ein Programm, das Trapper benutzt, sollte sich (sofern es
kein TSR ist) unbedingt in etv_term einklinken und so im Falle eines
unvorhergesehenen Programmabbruches alle in Trapper eingeklinkten
Funktionen wieder ausklinken.


Sinnvolle Bindings
==================

Das "Low Level"-Binding zu Trapper (Xbios-Funktion Nummer 555) sollte
man sich fÅr sein verwendetes System selbst erstellen. Das
Assemblerbinding kînnte z.B. etwa so aussehen, falls die
Trapper-Funktion seine Parameter nach C-Konvention auf dem Stack
Åbergeben bekommt:

int32 CDECL Trapper(int16 layer, int16 install, int16 opcode, void *function);

Trapper:
	pea (a2)              // TOS does not save A2 in traps
	move.l 14(sp),-(sp)   // function
	move.l 14(sp),-(sp)   // install/opcode
	move.w 16(sp),-(sp)   // layer
	move.w #555,-(sp)     // Opcode 555
	trap #14              // Xbios-Trap
	lea 12(sp),sp         // correct Stack
	move.l (sp)+,a2       // restore A2
	rts

Bei RegisterÅbergabe sieht das ganze natÅrlich geringfÅgig anders aus.


Um das Einklinken komfortabler zu machen, ist es sinnvoll, sich z.B.
folgende "Higher Level"-Bindings zu definieren, die entsprechend das
"Low Level"-Trapper-Binding aufrufen. Das hat auûerdem den Vorteil,
daû bei den Åbergebenen Funktionen eine TypÅberprÅfung stattfindet.

int32 TrapperCheck(TrapperInfo *info)
{
	return Trapper(TRAPPER_CHECK, 0, 0, info);
}


int32 TrapperInstallBiosCall(int16 opcode, BiosCallFunc func)
{
	return Trapper(TRAPPER_BIOS, TRAPPER_INSTALL_CALL, opcode, func);
}

int32 TrapperRemoveBiosCall(int16 opcode, BiosCallFunc func)
{
	return Trapper(TRAPPER_BIOS, TRAPPER_REMOVE_CALL, opcode, func);
}

int32 TrapperInstallBiosReturn(int16 opcode, BiosReturnFunc func)
{
	return Trapper(TRAPPER_BIOS, TRAPPER_INSTALL_RETURN, opcode, func);
}

int32 TrapperRemoveBiosReturn(int16 opcode, BiosReturnFunc func)
{
	return Trapper(TRAPPER_BIOS, TRAPPER_REMOVE_RETURN, opcode, func);
}


int32 TrapperInstallXbiosCall(int16 opcode, XbiosCallFunc func)
{
	return Trapper(TRAPPER_XBIOS, TRAPPER_INSTALL_CALL, opcode, func);
}

int32 TrapperRemoveXbiosCall(int16 opcode, XbiosCallFunc func)
{
	return Trapper(TRAPPER_XBIOS, TRAPPER_REMOVE_CALL, opcode, func);
}

int32 TrapperInstallXbiosReturn(int16 opcode, XbiosReturnFunc func)
{
	return Trapper(TRAPPER_XBIOS, TRAPPER_INSTALL_RETURN, opcode, func);
}

int32 TrapperRemoveXbiosReturn(int16 opcode, XbiosReturnFunc func)
{
	return Trapper(TRAPPER_XBIOS, TRAPPER_REMOVE_RETURN, opcode, func);
}


int32 TrapperInstallGemdosCall(int16 opcode, GemdosCallFunc func)
{
	return Trapper(TRAPPER_GEMDOS, TRAPPER_INSTALL_CALL, opcode, func);
}

int32 TrapperRemoveGemdosCall(int16 opcode, GemdosCallFunc func)
{
	return Trapper(TRAPPER_GEMDOS, TRAPPER_REMOVE_CALL, opcode, func);
}

int32 TrapperInstallGemdosReturn(int16 opcode, GemdosReturnFunc func)
{
	return Trapper(TRAPPER_GEMDOS, TRAPPER_INSTALL_RETURN, opcode, func);
}

int32 TrapperRemoveGemdosReturn(int16 opcode, GemdosReturnFunc func)
{
	return Trapper(TRAPPER_GEMDOS, TRAPPER_REMOVE_RETURN, opcode, func);
}


int32 TrapperInstallVDICall(int16 opcode, VDICallFunc func)
{
	return Trapper(TRAPPER_VDI, TRAPPER_INSTALL_CALL, opcode, func);
}

int32 TrapperRemoveVDICall(int16 opcode, VDICallFunc func)
{
	return Trapper(TRAPPER_VDI, TRAPPER_REMOVE_CALL, opcode, func);
}

int32 TrapperInstallVDIReturn(int16 opcode, VDIReturnFunc func)
{
	return Trapper(TRAPPER_VDI, TRAPPER_INSTALL_RETURN, opcode, func);
}

int32 TrapperRemoveVDIReturn(int16 opcode, VDIReturnFunc func)
{
	return Trapper(TRAPPER_VDI, TRAPPER_REMOVE_RETURN, opcode, func);
}


int32 TrapperInstallAESCall(int16 opcode, AESCallFunc func)
{
	return Trapper(TRAPPER_AES, TRAPPER_INSTALL_CALL, opcode, func);
}

int32 TrapperRemoveAESCall(int16 opcode, AESCallFunc func)
{
	return Trapper(TRAPPER_AES, TRAPPER_REMOVE_CALL, opcode, func);
}

int32 TrapperInstallAESReturn(int16 opcode, AESReturnFunc func)
{
	return Trapper(TRAPPER_AES, TRAPPER_INSTALL_RETURN, opcode, func);
}

int32 TrapperRemoveAESReturn(int16 opcode, AESReturnFunc func)
{
	return Trapper(TRAPPER_AES, TRAPPER_REMOVE_RETURN, opcode, func);
}


Fragen und Antworten
====================

F: Was passiert, wenn sich mehrere Funktionen in den gleichen
Systemaufruf (gleiche Systemschicht und gleicher Opcode) hÑngen?

A: Sind mehrere Funktionen in einen Systemcall eingehÑngt, so werden
die "Call"-Funktionen (vor Originalcall eingehÑngt) in umgekehrter
Reihenfolge und "Return"-Funktionen (hinter dem Systemcall) in
normaler Reihenfolge ihrer Anmeldung nacheinander aufgerufen.

Bei "Calls" werden allerdings zuerst die allgemein (mit Opcode -1) auf
Opcodes angemeldeten Funktionen aufgerufen, danach die speziell auf
den betreffenden Opcode angemeldeten Funktionen. Bei "Returns"
entsprechend umgekehrt.

Bei "Calls" gilt zusÑtzlich: Sobald eine der Funktionen das
call_original-Flag auf 0 setzt, wird die Original-Funktion ersetzt,
also anschlieûend nicht mehr aufgerufen. Als RÅckgabewert gilt dann
der der letzten Funktion, die call_original auf 0 gesetzt hat. Alle
weiteren in Trapper eingeklinkten Funktionen werden aber dennoch
aufgerufen. Das gilt sowohl fÅr die restlich eingeklinkten "Call"-
Funktionen, als auch fÅr die "Return"-Funktionen.
DemnÑchst wird es eine alternative Einklink-Mîglichkeit geben, die
sich geringfÅgig anders verhÑlt. Siehe "Ausblick".

F: Wie wird die Geschwindigkeit bei sehr vielen eingeklinkten
Funktionen gewÑhrleistet.

A: FÅr jede Systemschicht wird ein sich automatisch optimal
ausbalancierender binÑrer Baum (AVL-Baum) mit allen eingeklinkten
Funktionen angelegt. So kînnen zu einem Funktions-Opcode die
eingeklinkten Funktionen sehr schnell gefunden werden (O(log n)).
Daher ist es wenig sinnvoll, sich in eine Systemschicht mit Opcode -1
einzuklinken und dann selbst auf die richtigen Opcodes abzuprÅfen, da
das Trapper wesentlich effektiver erledigen kann.

F: Aha. Und was mache ich, wenn ich dieselbe Funktion in zwei oder
mehr Funktionen (Opcodes) verwenden will?

A: Auch dann sollte man sich nicht mit Opcode -1 einklinken, sondern
die Funktion einfach mehrmals in die gewÅnschten Opcodes einklinken.
Die Abfrage auf die Opcodes muû man dann zwar trotzdem in seine
Funktion einbauen, aber Trapper ruft die Funktion erst gar nicht bei
anderen Opcodes auf.


Ausblick
========

DemnÑchst wird man vielleicht "Calls" und "Returns" paarweise
einklinken kînnen. Programme, die sich auf diese Art Åber Trapper ins
System einklinken, verhalten sich dann Ñhnlicher zu "manuell" (ohne
Trapper) eingeklinkten Programmen. Setzt bei einem solchen
"Call-Return"-Paar die Call-Funktion das Flag *call_original auf 0
(false), so werden alle vorher eingeklinkten "Call-Return"-Paare nicht
aufgerufen - eben wie in Real Life. ;-)

Die bisherige Einklink-Mîglichkeiten in Trapper bleiben jedoch aus
KompatibilitÑtsgrÅnden erhalten. Im Gegenteil - sie haben dann immer
noch ihre sinnvolle Daseinsberechtigung: Auf die jetzige Art
eingeklinkte Funktionen werden auf jeden Fall aufgerufen. Als "Paar"
eingeklinkte Funktionen kînnen durch andere Paare ersetzt werden.
Beides kann sinnvoll sein. Um Funktionen komplett zu ersetzen, ist die
kommende Paar-Mîglichkeit sinnvoller.


History
=======

V2.00, 18.3.2000
----------------

- Mechanismus zum Einklinken "hinter" die Traps wurde vollkommen
umgeschrieben. Der Stackverbraucht ist jetzt wesentlich geringer, der
Code einfacher, sauberer und schneller. Trapper sollte jetzt Åberall
laufen.

V1.42, 1.2.2000
----------------

- Nullpointer-Bug behoben, der auf Original-Atari-Hardware zu
AbstÅrzen fÅhren konnte.

V1.41, 27.7.1999
----------------

- Ist Trapper bereits installiert, so liefert es jetzt als Returnwert
0 statt -1 zurÅck, damit MagiC keinen "Schweren Fehler"-Alert mehr
zeigt.

V1.4, 29.4.1999
---------------

- Bug behoben, durch den Trapper unter UmstÑnden AbstÅrze auf
Original-Ataris verursachte.

- Code etwas optimiert, Trapper wurde ca. 4 KB kÅrzer.

V1.3, 2.3.1999
--------------

- Debug-Session unter SingleTOS gemacht und dabei noch zwei Bugs
ausgetrieben. Trapper sollte jetzt Åberall sauber laufen.

V1.21, 1.3.1999
---------------

- Selten auftretendes Problem beim Einklinken per XBRA behoben.

V1.2, 25.2.1999
---------------

- Workaround fÅr fehlerhafte Programme, deren Startup-Code keinen
Stack einrichtet (meistens TSR-Programme).

V1.1, 19.2.1999
---------------

- Blîden Bug behoben. Dadurch lÑuft jetzt z.B. auch der Pure-Debugger
bei installiertem Trapper.

- Traps kînnen bereits im AUTO-Ordner getraced werden (auûer AES und
VDI).

- Die Calls werden jetzt in umgekehrter Reihenfolge ihrer Anmeldung
aufgerufen. (Returns wie gehabt.)


V1.0, 29.1.1999 bis 6.2.1999
----------------------------

- Erste Version


Viel Spaû mit Trapper,
Manfred Lippert
