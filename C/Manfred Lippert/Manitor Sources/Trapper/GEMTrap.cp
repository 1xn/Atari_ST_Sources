#define ERSTER_VERSUCH 0#define ZWEITER_VERSUCH 1// Super-Mode selbst testen, oder Info in Struktur merken?// Selbst testen geht nur auf 68000!!!#define TEST_SUPER_MODE 0#include <stdio.h>#include "AESTrap.h"#include "VDITrap.h"static AESCallsAVLTree AES_call_tree;static AESReturnsAVLTree AES_return_tree;/* Routine in AES-Call-Trace einklinken: */int16 AES_insert_call(int16 opcode, AESCallFunc func){	AESCall *call = new AESCall(func);				// Neues Glied mit Routine	if (!call) {		return ENSMEM;	}	AESCallsAVL *callsAVL = AES_call_tree.search(opcode);	// Opcode im Baum suchen	if (!callsAVL) {										// Opcode noch nicht getraced		callsAVL = new AESCallsAVL(opcode);				// Neues Blatt im Opcode-Baum		if (!callsAVL) {			delete call;			return ENSMEM;		}		AES_call_tree.insert(callsAVL);						// Blatt einfügen	}	callsAVL->get_calls()->insert(call, 0L, LINK_START);	// Call in Blatt einfügen	return E_OK;}/* Routine aus AES-Call-Trace ausklinken: */int16 AES_remove_call(int16 opcode, AESCallFunc func){	AESCallsAVL *callsAVL = AES_call_tree.search(opcode);	// Opcode im Baum suchen	if (!callsAVL) {		return ERROR;			// Fehler - Funktion kann gar nicht drin sein!	}	AESCallKette *kette = callsAVL->get_calls();	AESCall *call = kette->get_first();	while (call) {		if (call->get_func() == func) {			kette->kill(call);					// Routine ausklinken			if (!kette->get_first()) {			// Keine Routinen mehr drin?				AES_call_tree.kill(callsAVL);		// Gesamtes Blatt löschen			}			return E_OK;		}		call = call->get_next();	}	return ERROR;			// Fehler - Funktion ist nicht drin}/* Routine in AES-Return-Trace einklinken: */int16 AES_insert_return(int16 opcode, AESReturnFunc func){	AESReturn *call = new AESReturn(func);				// Neues Glied mit Routine	if (!call) {		return ENSMEM;	}	AESReturnsAVL *callsAVL = AES_return_tree.search(opcode);	// Opcode im Baum suchen	if (!callsAVL) {										// Opcode noch nicht getraced		callsAVL = new AESReturnsAVL(opcode);				// Neues Blatt im Opcode-Baum		if (!callsAVL) {			delete call;			return ENSMEM;		}		AES_return_tree.insert(callsAVL);						// Blatt einfügen	}	callsAVL->get_calls()->insert(call);					// Routine in Blatt einfügen	return E_OK;}/* Routine aus AES-Return-Trace ausklinken: */int16 AES_remove_return(int16 opcode, AESReturnFunc func){	AESReturnsAVL *callsAVL = AES_return_tree.search(opcode);	// Opcode im Baum suchen	if (!callsAVL) {		return ERROR;			// Fehler - Funktion kann gar nicht drin sein!	}	AESReturnKette *kette = callsAVL->get_calls();	AESReturn *call = kette->get_first();	while (call) {		if (call->get_func() == func) {			kette->kill(call);					// Routine ausklinken			if (!kette->get_first()) {			// Keine Routinen mehr drin?				AES_return_tree.kill(callsAVL);		// Gesamtes Blatt löschen			}			return E_OK;		}		call = call->get_next();	}	return ERROR;			// Fehler - Funktion ist nicht drin}static void AES_call_trace(__D1(AESPB *para), __A0(int16 *call_original), __D2(int16 super_called)){	int16 opcode = para->contrl[0];	AESCallsAVL *callsAVL;	callsAVL = AES_call_tree.search(-1);	if (callsAVL) {		int16 call_org;		AESCall *call = callsAVL->get_calls()->get_first();		while (call) {			call_org = 1;			call->call(para, &call_org, super_called);			if (!call_org) {				*call_original = 0;			}			call = call->get_next();		}	}	callsAVL = AES_call_tree.search(opcode);	if (callsAVL) {		int16 call_org;		AESCall *call = callsAVL->get_calls()->get_first();		while (call) {			call_org = 1;			call->call(para, &call_org, super_called);			if (!call_org) {				*call_original = 0;			}			call = call->get_next();		}	}}static void AES_return_trace(__D1(AESPB *para), __D2(int16 is_super)){	int16 opcode = para->contrl[0];	AESReturnsAVL *callsAVL;	callsAVL = AES_return_tree.search(opcode);	if (callsAVL) {		AESReturn *call = callsAVL->get_calls()->get_first();		while (call) {			call->call(para, is_super);			call = call->get_next();		}	}	callsAVL = AES_return_tree.search(-1);	if (callsAVL) {		AESReturn *call = callsAVL->get_calls()->get_first();		while (call) {			call->call(para, is_super);			call = call->get_next();		}	}}void AESCallsAVLTree::add_counter(int16 val){	if ((counter += val) == 0) {		AES_call_traced = 0;		if (!AES_return_traced) {			AES_traced = 0;		}	} else {		AES_call_traced = 1;		AES_traced = 1;	}}void AESReturnsAVLTree::add_counter(int16 val){	if ((counter += val) == 0) {		AES_return_traced = 0;		if (!AES_call_traced) {			AES_traced = 0;		}	} else {		AES_return_traced = 1;		AES_traced = 1;	}}/******************** VDI ***********************/static VDICallsAVLTree VDI_call_tree;static VDIReturnsAVLTree VDI_return_tree;/* Routine in VDI-Call-Trace einklinken: */int16 VDI_insert_call(int16 opcode, VDICallFunc func){	VDICall *call = new VDICall(func);				// Neues Glied mit Routine	if (!call) {		return ENSMEM;	}	VDICallsAVL *callsAVL = VDI_call_tree.search(opcode);	// Opcode im Baum suchen	if (!callsAVL) {										// Opcode noch nicht getraced		callsAVL = new VDICallsAVL(opcode);				// Neues Blatt im Opcode-Baum		if (!callsAVL) {			delete call;			return ENSMEM;		}		VDI_call_tree.insert(callsAVL);						// Blatt einfügen	}	callsAVL->get_calls()->insert(call, 0L, LINK_START);	// Call in Blatt einfügen	return E_OK;}/* Routine aus VDI-Call-Trace ausklinken: */int16 VDI_remove_call(int16 opcode, VDICallFunc func){	VDICallsAVL *callsAVL = VDI_call_tree.search(opcode);	// Opcode im Baum suchen	if (!callsAVL) {		return ERROR;			// Fehler - Funktion kann gar nicht drin sein!	}	VDICallKette *kette = callsAVL->get_calls();	VDICall *call = kette->get_first();	while (call) {		if (call->get_func() == func) {			kette->kill(call);					// Routine ausklinken			if (!kette->get_first()) {			// Keine Routinen mehr drin?				VDI_call_tree.kill(callsAVL);		// Gesamtes Blatt löschen			}			return E_OK;		}		call = call->get_next();	}	return ERROR;			// Fehler - Funktion ist nicht drin}/* Routine in VDI-Return-Trace einklinken: */int16 VDI_insert_return(int16 opcode, VDIReturnFunc func){	VDIReturn *call = new VDIReturn(func);				// Neues Glied mit Routine	if (!call) {		return ENSMEM;	}	VDIReturnsAVL *callsAVL = VDI_return_tree.search(opcode);	// Opcode im Baum suchen	if (!callsAVL) {										// Opcode noch nicht getraced		callsAVL = new VDIReturnsAVL(opcode);				// Neues Blatt im Opcode-Baum		if (!callsAVL) {			delete call;			return ENSMEM;		}		VDI_return_tree.insert(callsAVL);						// Blatt einfügen	}	callsAVL->get_calls()->insert(call);					// Routine in Blatt einfügen	return E_OK;}/* Routine aus VDI-Return-Trace ausklinken: */int16 VDI_remove_return(int16 opcode, VDIReturnFunc func){	VDIReturnsAVL *callsAVL = VDI_return_tree.search(opcode);	// Opcode im Baum suchen	if (!callsAVL) {		return ERROR;			// Fehler - Funktion kann gar nicht drin sein!	}	VDIReturnKette *kette = callsAVL->get_calls();	VDIReturn *call = kette->get_first();	while (call) {		if (call->get_func() == func) {			kette->kill(call);					// Routine ausklinken			if (!kette->get_first()) {			// Keine Routinen mehr drin?				VDI_return_tree.kill(callsAVL);		// Gesamtes Blatt löschen			}			return E_OK;		}		call = call->get_next();	}	return ERROR;			// Fehler - Funktion ist nicht drin}static void VDI_call_trace(__D1(VDIPB *para), __A0(int16 *call_original), __D2(int16 super_called)){	int16 opcode = para->contrl[0];	VDICallsAVL *callsAVL;	callsAVL = VDI_call_tree.search(-1);	if (callsAVL) {		int16 call_org;		VDICall *call = callsAVL->get_calls()->get_first();		while (call) {			call_org = 1;			call->call(para, &call_org, super_called);			if (!call_org) {				*call_original = 0;			}			call = call->get_next();		}	}	callsAVL = VDI_call_tree.search(opcode);	if (callsAVL) {		int16 call_org;		VDICall *call = callsAVL->get_calls()->get_first();		while (call) {			call_org = 1;			call->call(para, &call_org, super_called);			if (!call_org) {				*call_original = 0;			}			call = call->get_next();		}	}}static void VDI_return_trace(__D1(VDIPB *para), __D2(int16 is_super)){	int16 opcode = para->contrl[0];	VDIReturnsAVL *callsAVL;	callsAVL = VDI_return_tree.search(opcode);	if (callsAVL) {		VDIReturn *call = callsAVL->get_calls()->get_first();		while (call) {			call->call(para, is_super);			call = call->get_next();		}	}	callsAVL = VDI_return_tree.search(-1);	if (callsAVL) {		VDIReturn *call = callsAVL->get_calls()->get_first();		while (call) {			call->call(para, is_super);			call = call->get_next();		}	}}void VDICallsAVLTree::add_counter(int16 val){	if ((counter += val) == 0) {		VDI_call_traced = 0;		if (!VDI_return_traced) {			VDI_traced = 0;		}	} else {		VDI_call_traced = 1;		VDI_traced = 1;	}}void VDIReturnsAVLTree::add_counter(int16 val){	if ((counter += val) == 0) {		VDI_return_traced = 0;		if (!VDI_call_traced) {			VDI_traced = 0;		}	} else {		VDI_return_traced = 1;		VDI_traced = 1;	}}#if ERSTER_VERSUCH#define TEST 0static asm void GEM_XBRA_asm(void){entry extern AES_traced	dc.w 1entry extern AES_call_traced	dc.w 0entry extern AES_return_traced	dc.w 1entry extern VDI_traced	dc.w 0entry extern VDI_call_traced	dc.w 0entry extern VDI_return_traced	dc.w 0entry extern GEM_XBRA	dc.l 'XBRA'	dc.l 'Trpp'old_GEM:	dc.l 0new_GEM:/* A5-World: */	subq.l #4,sp		/* Platz für Jump-Adresse */	move.l a5,-(sp)		/* A5 retten */	dc.w 0x2A79			/* movea.l _A5world_ptr,a5  - A5-World herstellen! */	dc.l _A5world_ptr 	cmp.w #115,d0	/* VDI-Trap? */	beq is_VDI	cmp.w #200,d0	/* AES-Trap? */	bne AES_not_traced#define REGS d0/d1/d2/a0/a1#define STK 28is_AES:	tst.w AES_traced	beq AES_not_traced	/* AES wird gar nicht getraced, sofort wieder raus */#ifdef REGS	movem.l REGS,-(sp)#endif	moveq.l #1,d2			// d2: call_original-Flag!	tst.w AES_call_traced	beq.s AES_after/* Vor Einsprung tracen: */	moveq.l #0,d2		/* default: is not super */	btst #5,STK(sp)		/* SR am Stack: Aufruf aus User-Mode? */	beq.s AES_user	moveq.l #1,d2		/* is super */AES_user:/* A0: int16 *call_original: */	move.w #1,-(sp)			/* Platz für call_original-Flag, Standardwert: TRUE */	move.l sp,a0	movem.l d0/d1,-(sp)		/* brauchen wir noch */	jsr AES_call_trace		/* Einsprung tracen!!! */	movem.l (sp)+,d0/d1	move.w (sp)+,d2			// d2: call_original-Flag!AES_after:	tst.w AES_return_traced	beq exit_AES/* Nach Einsprung tracen: */	btst #5,STK(sp)		/* SR am Stack: Aufruf aus User-Mode? */	beq.s AES_after_usermode/* Nach Einsprung tracen, Aufruf im Super-Mode: */#if TEST/*	move.l usp,a0	lea STK(sp),a1	cmp.l a1,a0	blt.s stacks_ok_AES		// USP liegt irgendwo "unter" SSP	add.l #32,a1	cmp.l a1,a0	bgt.s stacks_ok_AES// USP und SSP überlappen sich!	pea text3	jsr	Cconws	addq.l #5,spstacks_ok_AES:*/move.l STK+2(sp),-(sp)move.l STK+2+4(sp),-(sp)lea printstack,a0jsr printfaddq.l #8,sp	move.l usp,a1	subq.l #4,a1	move.l a1,usp	move.l STK+2(sp),(a1)		// Alte Returnadresse auf USP	lea after_AES_super,a0		// Neue Returnadresse	move.l a0,STK+2(sp)			// Returnadresse verbiegenmove.l (a1),-(sp)move.l a1,-(sp)lea printstack,a0jsr printfaddq.l #8,sp	/*pea text1jsr Cconwsaddq.l #4,sp*/	bra.s exit_AES#endif#if !TEST	tst.w 0x59e			/* longframe? */	beq.s AES_after_nolong	move.w STK+6(sp),-(sp)		/* longframe kopieren */	lea 2+STK+4(sp),a0			/* Adresse Returncode (noch nicht wirklich da) */	move.l a0,2+STK-4(sp)		/* in Adresse "Platz für Jump" schreiben (siehe Notizen) */	move.l -2(a0),(a0)			/* Adresse um 2 Bytes verschieben */	lea after_AES_super,a0	move.l a0,-(sp)				/* verbogener Return */	move.w 4+2+STK(sp),-(sp)	/* SR kopieren */	tst.w d2					// call_original?	beq.s exit_AES_direct_long#ifdef REGS	movem.l 8(sp),REGS#endif	move.l old_GEM,-(sp)		/* Jump-Adresse */	move.l 4+8+STK-8(sp),a5	rts							/* Zurück in Original-Trap */exit_AES_direct_long:#ifdef REGS	movem.l 8(sp),REGS#endif	move.l 8+STK-8(sp),a5	rte							// direkt zurückAES_after_nolong:	lea STK+2(sp),a0			/* Adresse Returncode */	move.l a0,STK-4(sp)			/* in Adresse "Platz für Jump" schreiben (siehe Notizen) */	lea after_AES_super,a0	move.l a0,-(sp)				/* verbogener Return */	move.w 4+STK(sp),-(sp)		/* SR kopieren */	tst.w d2					// call_original?	beq.s exit_AES_direct_nolong#ifdef REGS	movem.l 6(sp),REGS#endif	move.l old_GEM,-(sp)		/* Jump-Adresse */	move.l 4+6+STK-8(sp),a5	rts							/* Zurück in Original-Trap */exit_AES_direct_nolong:#ifdef REGS	movem.l 6(sp),REGS#endif	move.l 6+STK-8(sp),a5	rte							// direkt zurück#endif/* Nach Einsprung tracen, Aufruf im User-Mode: */AES_after_usermode:/*	lea STK(sp),a1	cmp.l a1,a0	blt.s stacks_ok_AES		// USP liegt irgendwo "unter" SSP	add.l #32,a1	cmp.l a1,a0	blt.s exit_AES			// USP und SSP überlappen sich!stacks_ok_AES:*/	move.l usp,a0	subq.l #4,a0	move.l a0,usp			/* Platz auf Userstack schaffen */	move.l STK+2(sp),(a0)	/* Alte Returnadresse auf USP */		lea after_AES_user,a1	move.l a1,STK+2(sp)		/* Return verbiegen */exit_AES:	tst.w d2				// call_original?	beq.s exit_AES_direct#ifdef REGS	movem.l (sp)+,REGS#endifAES_not_traced:	move.l old_GEM,4(sp)	/* Jump-Adresse eintragen */	move.l (sp)+,a5			/* A5 Wiederherstellen */	rts						/* Zurück in Original-Trap */exit_AES_direct:#ifdef REGS	movem.l (sp)+,REGS#endif	move.l (sp)+,a5			/* A5 Wiederherstellen */	addq.l #4,sp	rte#define AFTER_REGS d0/d1/d2/a0/a1/a5#define AFTER_STK 24after_AES_user:	movem.l AFTER_REGS,-(sp)	dc.w 0x2A79				/* movea.l _A5world_ptr,a5  - A5-World herstellen! */	dc.l _A5world_ptr 	moveq.l #0,d2			/* is not super */	jsr AES_return_trace	/* Returnwert tracen!!! */	movem.l (sp)+,AFTER_REGS	rtsafter_AES_super:#if TEST	subq.l #4,sp				// Platz für Returnadresse	movem.l AFTER_REGS,-(sp)	// Register sichern	dc.w 0x2A79				/* movea.l _A5world_ptr,a5  - A5-World herstellen! */	dc.l _A5world_ptr 	move.l usp,a0	cmp.l a0,sp					// Userstack == aktiver Stack?	bne.s after_AES_is_super	// immernoch Supermode	subq.l #2,sp				// kann Zufall sein	move.l usp,a0	cmp.l a0,sp					// Userstack immernoch == aktiver Stack?	bne.s after_AES_is_super2	addq.l #2,spafter_AES_is_user:	moveq.l #0,d2			/* is not super *///	jsr AES_return_trace	/* Returnwert tracen!!! */	movem.l (sp)+,AFTER_REGS	// Register wiederherstellen	addq.l #4,sp				// Returnadresse liegt schon am USP (ist aktueller Stack)	rtsafter_AES_is_super2:	addq.l #2,spafter_AES_is_super:pea text2jsr Cconwsaddq.l #4,spmove.l usp,a1move.l (a1),-(sp)move.l a1,-(sp)lea printstack,a0jsr printfaddq.l #8,sp	moveq.l #1,d2			/* is super *///	jsr AES_return_trace	/* Returnwert tracen!!! */	move.l usp,a0	move.l (a0)+,AFTER_STK(sp)	// Returnadresse vom USP auf SSP	move.l a0,usp				// Userstack korrigieren	movem.l (sp)+,AFTER_REGS	// Register wiederherstellen	rts							// zurückspringen#endif#if !TEST	move.l STK-4(sp),sp		/* Stack korrigieren (Returnadresse holen) */	movem.l AFTER_REGS,-(sp)	dc.w 0x2A79				/* movea.l _A5world_ptr,a5  - A5-World herstellen! */	dc.l _A5world_ptr /*AES_nimmer_super:	move.w sr,d1	btst #13,d1	beq.s AES_nimmer_super  // :-(((((*/	moveq.l #1,d2			/* is super */	jsr AES_return_trace	/* Returnwert tracen!!! */	movem.l (sp)+,AFTER_REGS	rts#endif/************************** VDI ****************************/is_VDI:	tst.w VDI_traced	beq VDI_not_traced	/* VDI wird gar nicht getraced, sofort wieder raus */#ifdef REGS	movem.l REGS,-(sp)#endif	moveq.l #1,d2			// d2: call_original-Flag!	tst.w VDI_call_traced	beq.s VDI_after/* Vor Einsprung tracen: */	moveq.l #0,d2		/* default: is not super */	btst #5,STK(sp)		/* SR am Stack: Aufruf aus User-Mode? */	beq.s VDI_user	moveq.l #1,d2		/* is super */VDI_user:/* A0: int16 *call_original: */	move.w #1,-(sp)			/* Platz für call_original-Flag, Standardwert: TRUE */	move.l sp,a0	movem.l d0/d1,-(sp)		/* brauchen wir noch */	jsr VDI_call_trace		/* Einsprung tracen!!! */	movem.l (sp)+,d0/d1	move.w (sp)+,d2			// d2: call_original-Flag!VDI_after:	tst.w VDI_return_traced	beq exit_VDI/* Nach Einsprung tracen: */	btst #5,STK(sp)		/* SR am Stack: Aufruf aus User-Mode? */	beq.s VDI_after_usermode/* Nach Einsprung tracen, Aufruf im Super-Mode: */	tst.w 0x59e			/* longframe? */	beq.s VDI_after_nolong	move.w STK+6(sp),-(sp)		/* longframe kopieren */	lea 2+STK+4(sp),a0			/* Adresse Returncode (noch nicht wirklich da) */	move.l a0,2+STK-4(sp)		/* in Adresse "Platz für Jump" schreiben (siehe Notizen) */	move.l -2(a0),(a0)			/* Adresse um 2 Bytes verschieben */	lea after_VDI_super,a0	move.l a0,-(sp)				/* verbogener Return */	move.w 4+2+STK(sp),-(sp)	/* SR kopieren */	tst.w d2					// call_original?	beq.s exit_VDI_direct_long#ifdef REGS	movem.l 8(sp),REGS#endif	move.l old_GEM,-(sp)		/* Jump-Adresse */	move.l 4+8+STK-8(sp),a5	rts							/* Zurück in Original-Trap */exit_VDI_direct_long:#ifdef REGS	movem.l 8(sp),REGS#endif	move.l 8+STK-8(sp),a5	rte							// direkt zurückVDI_after_nolong:	lea STK+2(sp),a0			/* Adresse Returncode */	move.l a0,STK-4(sp)			/* in Adresse "Platz für Jump" schreiben (siehe Notizen) */	lea after_VDI_super,a0	move.l a0,-(sp)				/* verbogener Return */	move.w 4+STK(sp),-(sp)		/* SR kopieren */	tst.w d2					// call_original?	beq.s exit_VDI_direct_nolong#ifdef REGS	movem.l 6(sp),REGS#endif	move.l old_GEM,-(sp)		/* Jump-Adresse */	move.l 4+6+STK-8(sp),a5	rts							/* Zurück in Original-Trap */exit_VDI_direct_nolong:#ifdef REGS	movem.l 6(sp),REGS#endif	move.l 6+STK-8(sp),a5	rte							// direkt zurück/* Nach Einsprung tracen, Aufruf im User-Mode: */VDI_after_usermode:/*	lea STK(sp),a1	cmp.l a1,a0	blt.s stacks_ok_VDI			// USP liegt irgendwo "unter" SSP	add.l #32,a1	cmp.l a1,a0	blt.s exit_VDI			// USP und SSP überlappen sich!stacks_ok_VDI:*/	move.l usp,a0	subq.l #4,a0	move.l a0,usp			/* Platz auf Userstack schaffen */	move.l STK+2(sp),(a0)	/* Alte Returnadresse auf USP */		lea after_VDI_user,a1	move.l a1,STK+2(sp)		/* Return verbiegen */exit_VDI:	tst.w d2				// call_original?	beq.s exit_VDI_direct#ifdef REGS	movem.l (sp)+,REGS#endifVDI_not_traced:	move.l old_GEM,4(sp)	/* Jump-Adresse eintragen */	move.l (sp)+,a5			/* A5 Wiederherstellen */	rts						/* Zurück in Original-Trap */exit_VDI_direct:#ifdef REGS	movem.l (sp)+,REGS#endif	move.l (sp)+,a5			/* A5 Wiederherstellen */	addq.l #4,sp	rteafter_VDI_user:	movem.l AFTER_REGS,-(sp)	dc.w 0x2A79				/* movea.l _A5world_ptr,a5  - A5-World herstellen! */	dc.l _A5world_ptr 	moveq.l #0,d2			/* is not super */	jsr VDI_return_trace	/* Returnwert tracen!!! */	movem.l (sp)+,AFTER_REGS	rtsafter_VDI_super:	move.l STK-4(sp),sp		/* Stack korrigieren (Returnadresse holen) */	movem.l AFTER_REGS,-(sp)	dc.w 0x2A79				/* movea.l _A5world_ptr,a5  - A5-World herstellen! */	dc.l _A5world_ptr /*VDI_nimmer_super:	move.w sr,d1	btst #13,d1	beq.s VDI_nimmer_super  // :-(((((*/		moveq.l #1,d2			/* is super */	jsr VDI_return_trace	/* Returnwert tracen!!! */	movem.l (sp)+,AFTER_REGS	rts#if TESTtext1: dc.b "Eins\r\n",0text2: dc.b "Zwei\r\n",0text3: dc.b "Drei\r\n",0printstack: dc.b "%lx %lx\r\n",0#endif}#endif#if ZWEITER_VERSUCHtypedef struct {	uint32 old_return;	// ds.l 1: Alte Returnadresse (Aufrufer der OS-Routine)	uint16 is_super;		// ds.w 1: Flag, ob Routine im Supermode aufgerufen wurde	uint32 paraptr;		// ds.l 1: Zeiger auf Parameter (AESPB/VDIPB)	uint32 auf_stack;		// move.l -10(pc),-(sp): old_return auf Stack	uint32 regsave;		// movem.l d0/d1/d2/a0/a1/a5,-(sp): Register sichern	uint32 seta0;			// lea -18(pc),a1: Adresse von JumpTableEntry in a1	uint16 jmp;				// jmp after_trap: Engültigen "after_trap"-Code anspringen	void (*after_trap)();	int32 dummy;			// damit sizeof(JUMPTABLEENTRY) == 32 !} JumpTableEntry;// sizeof(JUMPTABLEENTRY) = 32#if COUNT_JUMPTABLE_USEstatic int16 aes_debug_counter;	// Anzahl gleichzeitiger JumpTableEntry-Benutzungint16 aes_debug_counter_max;		// Maximale gleichzeitige Benutzungstatic int16 vdi_debug_counter;	// Anzahl gleichzeitiger JumpTableEntry-Benutzungint16 vdi_debug_counter_max;		// Maximale gleichzeitige Benutzung#endifstatic asm void after_aes_trap(void) {	// A1 zeigt auf JUMPTABLEENTRY	dc.w 0x2A79			/* movea.l _A5world_ptr,a5  - A5-World herstellen! */	dc.l _A5world_ptr #if !TEST_SUPER_MODE	move.w 4(a1),d2					// is_super in D2#else	move.w SR,d2	and.w #0x2000,d2					// is super in D2#endif	move.l 6(a1),d1					// paraptr in D1	clr.l (a1)							// JumpTableEntry freigeben#if COUNT_JUMPTABLE_USE	sub.w #1,aes_debug_counter#endif	jsr AES_return_trace				// Returnwert tracen!!!	movem.l (sp)+,d0/d1/d2/a0/a1/a5	// Register restaurieren	rts									// Zurück zum Aufrufer der OS-Routine!}#define AESTABLESIZE 64static JumpTableEntry aes_jump_table[AESTABLESIZE] = {	{		0,0,0,						// old_return, is_super, paraptr		0x2F3AFFF4,					// move.l -10(pc),-(sp): old_return auf Stack		0x48E7E0C4,					// movem.l d0/d1/d2/a0/a1/a5,-(sp): Register sichern		0x43FAFFEC,					// lea -18(pc),a1: Adresse von JumpTableEntry in a1		0x4EF9, &after_aes_trap	// jmp after_aes_trap: Engültigen "after_aes_trap"-Code anspringen	},																								// 0	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 1	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 2	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 3	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 4	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 5	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 6	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 7	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 8	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 9	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 10	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 11	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 12	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 13	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 14	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 15	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 16	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 17	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 18	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 19	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 20	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 21	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 22	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 23	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 24	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 25	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 26	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 27	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 28	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 29	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 30	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 31	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 32	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 33	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 34	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 35	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 36	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 37	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 38	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 39	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 40	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 41	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 42	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 43	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 44	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 45	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 46	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 47	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 48	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 49	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 50	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 51	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 52	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 53	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 54	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 55	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 56	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 57	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 58	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 59	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 60	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 61	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap},	// 62	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_aes_trap}		// 63};static int16 aes_next_entry;static asm void after_vdi_trap(void) {	// A1 zeigt auf JUMPTABLEENTRY	dc.w 0x2A79			/* movea.l _A5world_ptr,a5  - A5-World herstellen! */	dc.l _A5world_ptr #if !TEST_SUPER_MODE	move.w 4(a1),d2					// is_super in D2#else	move.w SR,d2	and.w #0x2000,d2					// is super in D2#endif	move.l 6(a1),d1					// paraptr in D1	clr.l (a1)							// JumpTableEntry freigeben#if COUNT_JUMPTABLE_USE	sub.w #1,vdi_debug_counter#endif	jsr VDI_return_trace				// Returnwert tracen!!!	movem.l (sp)+,d0/d1/d2/a0/a1/a5	// Register restaurieren	rts									// Zurück zum Aufrufer der OS-Routine!}#define VDITABLESIZE 32JumpTableEntry vdi_jump_table[VDITABLESIZE] = {	{		0,0,0,						// old_return, is_super, paraptr		0x2F3AFFF4,					// move.l -10(pc),-(sp): old_return auf Stack		0x48E7E0C4,					// movem.l d0/d1/d2/a0/a1/a5,-(sp): Register sichern		0x43FAFFEC,					// lea -18(pc),a1: Adresse von JumpTableEntry in a1		0x4EF9, &after_vdi_trap	// jmp after_vdi_trap: Engültigen "after_vdi_trap"-Code anspringen	},																								// 0	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_vdi_trap},	// 1	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_vdi_trap},	// 2	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_vdi_trap},	// 3	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_vdi_trap},	// 4	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_vdi_trap},	// 5	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_vdi_trap},	// 6	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_vdi_trap},	// 7	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_vdi_trap},	// 8	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_vdi_trap},	// 9	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_vdi_trap},	// 10	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_vdi_trap},	// 11	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_vdi_trap},	// 12	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_vdi_trap},	// 13	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_vdi_trap},	// 14	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_vdi_trap},	// 15	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_vdi_trap},	// 16	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_vdi_trap},	// 17	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_vdi_trap},	// 18	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_vdi_trap},	// 19	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_vdi_trap},	// 20	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_vdi_trap},	// 21	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_vdi_trap},	// 22	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_vdi_trap},	// 23	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_vdi_trap},	// 24	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_vdi_trap},	// 25	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_vdi_trap},	// 26	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_vdi_trap},	// 27	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_vdi_trap},	// 28	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_vdi_trap},	// 29	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_vdi_trap},	// 30	{0,0,0, 0x2F3AFFF4, 0x48E7E0C4, 0x43FAFFEC, 0x4EF9, &after_vdi_trap}		// 31};static int16 vdi_next_entry;static asm void GEM_XBRA_asm(void){entry extern AES_traced	dc.w 1entry extern AES_call_traced	dc.w 0entry extern AES_return_traced	dc.w 1entry extern VDI_traced	dc.w 0entry extern VDI_call_traced	dc.w 0entry extern VDI_return_traced	dc.w 0entry extern GEM_XBRA	dc.l 'XBRA'	dc.l 'Trpp'old_GEM:	dc.l 0new_GEM:	subq.l #4,sp		/* Platz für Jump-Adresse *//* A5-World: */	move.l a5,-(sp)	/* A5 retten */	dc.w 0x2A79			/* movea.l _A5world_ptr,a5  - A5-World herstellen! */	dc.l _A5world_ptr 	cmp.w #115,d0	/* VDI-Trap? */	beq is_VDI	cmp.w #200,d0	/* AES-Trap? */	bne AES_not_traced#define REGS d0/d1/d2/d3/d4/d5/a0/a1#define STK 40is_AES:	tst.w AES_traced	beq AES_not_traced	/* AES wird gar nicht getraced, sofort wieder raus */	movem.l REGS,-(sp)	moveq.l #0,d2		/* default: is not super */	btst #5,STK(sp)	/* SR am Stack: Aufruf aus User-Mode? */	beq.s AES_user	moveq.l #1,d2		/* is super */AES_user:	moveq.l #1,d5			// d5: call_original-Flag!	tst.w AES_call_traced	beq.s AES_after/* Vor Einsprung tracen: *//* A0: int16 *call_original: */	move.w d5,-(sp)			/* Platz für call_original-Flag, Standardwert: TRUE */	move.l sp,a0#if !TEST_SUPER_MODE	movem.l d0/d1/d2,-(sp)	/* brauchen wir noch */#else	movem.l d0/d1,-(sp)	/* brauchen wir noch */#endif	jsr AES_call_trace		/* Einsprung tracen!!! */#if !TEST_SUPER_MODE	movem.l (sp)+,d0/d1/d2#else	movem.l (sp)+,d0/d1#endif	move.w (sp)+,d5			// d5: call_original-Flag!AES_after:	tst.w AES_return_traced	beq.s exit_AES/* Nach Einsprung tracen: */	move.w aes_next_entry,d3	// Suchposition in Tabelle	lsl.w #5,d3						// JUMPTABLENEXT * sizeof(JUMPTABLEENTRY)   (*32)	lea aes_jump_table,a1	adda.w d3,a1					// JUMPTABLE[JUMPTABLENEXT]	moveq.l #AESTABLESIZE-1,d4AES_table_search:	tst.l (a1)						// Eintrag frei?	beq.s AES_entry_found	adda.w #32,a1	addq.w #1,d3	cmp.w #AESTABLESIZE,d3		// Ende erreicht?	blt.s AES_no_wrap1	moveq.l #0,d3					// vorne anfangen	lea aes_jump_table,a1AES_no_wrap1:	dbra.s d4,AES_table_search	bra.s exit_AES					// Keinen freien Tabelleneintrag gefunden (sollte normalerweise nie passieren)AES_entry_found:	addq.w #1,d3				// Noch einmal hochzählen	cmp.w #AESTABLESIZE,d3	// Ende erreicht?	blt.s AES_no_wrap2	moveq.l #0,d3				// vorne anfangenAES_no_wrap2:	move.w d3,aes_next_entry	// Diese Suchposition merken	#if !TEST_SUPER_MODE		move.w d2,4(a1)			// is_super eintragen#endif	move.l d1,6(a1)			// paraptr eintragen	move.l STK+2(sp),(a1)	// old_return eintragen	lea 10(a1),a1	move.l a1,STK+2(sp)		// Return verbiegen#if COUNT_JUMPTABLE_USE	add.w #1,aes_debug_counter	move.w aes_debug_counter,d3	cmp.w aes_debug_counter_max,d3	ble.s AES_count_OK	move.w d3,aes_debug_counter_maxAES_count_OK:#endifexit_AES:	tst.w d5				// call_original?	beq.s exit_AES_direct	movem.l (sp)+,REGSAES_not_traced:	move.l old_GEM,4(sp)	/* Jump-Adresse eintragen */	move.l (sp)+,a5		/* A5 Wiederherstellen */	rts						/* Zurück in Original-Trap */exit_AES_direct:	movem.l (sp)+,REGS	move.l (sp)+,a5			/* A5 Wiederherstellen */	addq.l #4,sp	rte/************************** VDI ****************************/is_VDI:	tst.w VDI_traced	beq VDI_not_traced	/* VDI wird gar nicht getraced, sofort wieder raus */	movem.l REGS,-(sp)	moveq.l #0,d2		/* default: is not super */	btst #5,STK(sp)	/* SR am Stack: Aufruf aus User-Mode? */	beq.s VDI_user	moveq.l #1,d2		/* is super */VDI_user:	moveq.l #1,d5			// d5: call_original-Flag!	tst.w VDI_call_traced	beq.s VDI_after/* Vor Einsprung tracen: *//* A0: int16 *call_original: */	move.w d5,-(sp)			/* Platz für call_original-Flag, Standardwert: TRUE */	move.l sp,a0#if !TEST_SUPER_MODE	movem.l d0/d1/d2,-(sp)	/* brauchen wir noch */#else	movem.l d0/d1,-(sp)	/* brauchen wir noch */#endif	jsr VDI_call_trace		/* Einsprung tracen!!! */#if !TEST_SUPER_MODE	movem.l (sp)+,d0/d1/d2#else	movem.l (sp)+,d0/d1#endif	move.w (sp)+,d5			// d5: call_original-Flag!VDI_after:	tst.w VDI_return_traced	beq.s exit_VDI/* Nach Einsprung tracen: */	move.w vdi_next_entry,d3	// Suchposition in Tabelle	lsl.w #5,d3						// JUMPTABLENEXT * sizeof(JUMPTABLEENTRY)   (*32)	lea vdi_jump_table,a1	adda.w d3,a1					// JUMPTABLE[JUMPTABLENEXT]	moveq.l #VDITABLESIZE-1,d4VDI_table_search:	tst.l (a1)						// Eintrag frei?	beq.s VDI_entry_found	adda.w #32,a1	addq.w #1,d3	cmp.w #VDITABLESIZE,d3		// Ende erreicht?	blt.s VDI_no_wrap1	moveq.l #0,d3					// vorne anfangen	lea vdi_jump_table,a1VDI_no_wrap1:	dbra.s d4,VDI_table_search	bra.s exit_VDI					// Keinen freien Tabelleneintrag gefunden (sollte normalerweise nie passieren)VDI_entry_found:	addq.w #1,d3				// Noch einmal hochzählen	cmp.w #VDITABLESIZE,d3	// Ende erreicht?	blt.s VDI_no_wrap2	moveq.l #0,d3				// vorne anfangenVDI_no_wrap2:	move.w d3,vdi_next_entry	// Diese Suchposition merken#if !TEST_SUPER_MODE		move.w d2,4(a1)			// is_super eintragen#endif	move.l d1,6(a1)			// paraptr eintragen	move.l STK+2(sp),(a1)	// old_return eintragen	lea 10(a1),a1	move.l a1,STK+2(sp)		// Return verbiegen#if COUNT_JUMPTABLE_USE	add.w #1,vdi_debug_counter	move.w vdi_debug_counter,d3	cmp.w vdi_debug_counter_max,d3	ble.s VDI_count_OK	move.w d3,vdi_debug_counter_maxVDI_count_OK:#endifexit_VDI:	tst.w d5				// call_original?	beq.s exit_VDI_direct	movem.l (sp)+,REGSVDI_not_traced:	move.l old_GEM,4(sp)	/* Jump-Adresse eintragen */	move.l (sp)+,a5		/* A5 Wiederherstellen */	rts						/* Zurück in Original-Trap */exit_VDI_direct:	movem.l (sp)+,REGS	move.l (sp)+,a5			/* A5 Wiederherstellen */	addq.l #4,sp	rte}#endif