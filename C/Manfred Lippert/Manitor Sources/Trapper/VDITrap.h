#ifndef __Trapper_VDITrap_H__#define __Trapper_VDITrap_H__#include "TrapperDebug.h"#include <xbra.h>#include <AVLTree.h>#include <LinkedList.h>#include <trapper.h>#if COUNT_JUMPTABLE_USEextern int16 vdi_debug_counter_max;#endifextern int16 VDI_traced;		// Flag, ob VDI grundsŠtzlich getraced werden sollextern int16 VDI_call_traced;	// Flag, ob vor VDI-Aufrufen getraced werden sollextern int16 VDI_return_traced;	// Flag, ob nach VDI-Aufrufen getraced werden sollextern XBRA GEM_XBRA;extern int16 VDI_insert_call(int16 opcode, VDICallFunc func);extern int16 VDI_remove_call(int16 opcode, VDICallFunc func);extern int16 VDI_insert_return(int16 opcode, VDIReturnFunc func);extern int16 VDI_remove_return(int16 opcode, VDIReturnFunc func);/* Klasses for Call-Trace: */class VDICall : public Listable {	VDICallFunc func;	// eingeklinkte Routinepublic:	VDICall(VDICallFunc func) {this->func = func;};	void call(VDIPB *para, int16 *call_original, int16 super_called) const {		func(para, call_original, super_called);	};	VDICall *get_next() const {return (VDICall *)Listable::get_next();};	VDICall *get_prev() const {return (VDICall *)Listable::get_prev();};	VDICallFunc get_func() const {return func;};};class VDICallKette : public LinkedList {public:	void insert(VDICall *glied, VDICall *pos = 0, int16 posdef = LINK_END) {		LinkedList::insert(glied, pos, posdef);	};	void remove(VDICall *glied) {LinkedList::remove(glied);};	void kill(VDICall *glied) {LinkedList::kill(glied);};	VDICall *get_first() const {return (VDICall *)LinkedList::get_first();};	VDICall *get_last() const {return (VDICall *)LinkedList::get_last();};};class VDICallsAVL : public AVL {	int16 opcode;			// VDI-Call, in den sich diese Routinen eingeklinkt haben	VDICallKette calls;	// eingeklinkte Routinenpublic:	VDICallsAVL(int16 opcode) {this->opcode = opcode;};	int16 get_opcode() const {return opcode;};	VDICallKette *get_calls() {return &calls;};};#pragma warn_unusedarg offclass VDICallsAVLTree : public AVLTree {	int32 counter;public:	virtual int32 compare(AVL *a, AVL *b) const {return compare((VDICallsAVL *)a, (VDICallsAVL *)b);};	virtual int32 compare(AVL *a, int32 val) const {return compare((VDICallsAVL *)a, val);};	virtual int32 compare(AVL *a, void *ptr) const {return 0;};	int32 compare(VDICallsAVL *a, VDICallsAVL *b) const {		return (int32)(a->get_opcode() - b->get_opcode());	};	int32 compare(VDICallsAVL *a, int32 opcode) const {		return (int32)(a->get_opcode() - (int16)opcode);	};	void add_counter(int16 val);	void insert(VDICallsAVL *elem) {AVLTree::insert(elem); add_counter(1);};	void remove(VDICallsAVL *elem) {add_counter(-1); AVLTree::remove(elem);};	void kill(VDICallsAVL *elem) {add_counter(-1); AVLTree::kill(elem);};	VDICallsAVL *search(VDICallsAVL *elem) const {		return (VDICallsAVL *)AVLTree::search(elem);	};	VDICallsAVL *search(int16 opcode) const {		return (VDICallsAVL *)AVLTree::search((int32)opcode);	};};#pragma warn_unusedarg reset/* Klasses for Return-Trace: */class VDIReturn : public Listable {	VDIReturnFunc func;	// eingeklinkte Routinepublic:	VDIReturn(VDIReturnFunc func) {this->func = func;};	void call(VDIPB *para, int16 is_super) const {		func(para, is_super);	};	VDIReturn *get_next() const {return (VDIReturn *)Listable::get_next();};	VDIReturn *get_prev() const {return (VDIReturn *)Listable::get_prev();};	VDIReturnFunc get_func() const {return func;};};class VDIReturnKette : public LinkedList {public:	void insert(VDIReturn *glied, VDIReturn *pos = 0, int16 posdef = LINK_END) {		LinkedList::insert(glied, pos, posdef);	};	void remove(VDIReturn *glied) {LinkedList::remove(glied);};	void kill(VDIReturn *glied) {LinkedList::kill(glied);};	VDIReturn *get_first() const {return (VDIReturn *)LinkedList::get_first();};	VDIReturn *get_last() const {return (VDIReturn *)LinkedList::get_last();};};class VDIReturnsAVL : public AVL {	int16 opcode;			// VDI-Return, in den sich diese Routinen eingeklinkt haben	VDIReturnKette calls;	// eingeklinkte Routinenpublic:	VDIReturnsAVL(int16 opcode) {this->opcode = opcode;};	int16 get_opcode() const {return opcode;};	VDIReturnKette *get_calls() {return &calls;};};#pragma warn_unusedarg offclass VDIReturnsAVLTree : public AVLTree {	int32 counter;public:	virtual int32 compare(AVL *a, AVL *b) const {return compare((VDIReturnsAVL *)a, (VDIReturnsAVL *)b);};	virtual int32 compare(AVL *a, int32 val) const {return compare((VDIReturnsAVL *)a, val);};	virtual int32 compare(AVL *a, void *ptr) const {return 0;};	int32 compare(VDIReturnsAVL *a, VDIReturnsAVL *b) const {		return (int32)(a->get_opcode() - b->get_opcode());	};	int32 compare(VDIReturnsAVL *a, int32 opcode) const {		return (int32)(a->get_opcode() - (int16)opcode);	};	void add_counter(int16 val);	void insert(VDIReturnsAVL *elem) {AVLTree::insert(elem); add_counter(1);};	void remove(VDIReturnsAVL *elem) {add_counter(-1); AVLTree::remove(elem);};	void kill(VDIReturnsAVL *elem) {add_counter(-1); AVLTree::kill(elem);};	VDIReturnsAVL *search(VDIReturnsAVL *elem) const {		return (VDIReturnsAVL *)AVLTree::search(elem);	};	VDIReturnsAVL *search(int16 opcode) const {		return (VDIReturnsAVL *)AVLTree::search((int32)opcode);	};};#pragma warn_unusedarg reset#endif