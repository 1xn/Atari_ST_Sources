#if COUNT_JUMPTABLE_USEextern int16 JUMPTABLECOUNTERMAX;#endifextern int16 LABEL_TRACED;			// Flag, ob Schicht grundsŠtzlich getraced werden sollextern int16 LABEL_CALL_TRACED;		// Flag, ob vor OS-Aufrufen getraced werden sollextern int16 LABEL_RETURN_TRACED;	// Flag, ob nach OS-Aufrufen getraced werden sollextern XBRA LABEL_XBRA;extern int16 INSERT_CALL(int16 opcode, CALLFUNC func);extern int16 REMOVE_CALL(int16 opcode, CALLFUNC func);extern int16 INSERT_RETURN(int16 opcode, RETURNFUNC func);extern int16 REMOVE_RETURN(int16 opcode, RETURNFUNC func);/* Klasses for Call-Trace: */class OSCALL : public Listable {	CALLFUNC func;	// eingeklinkte Routinepublic:	OSCALL(CALLFUNC func) {this->func = func;};	int32 call(int16 *para, int16 *call_original, int16 super_called) const {		return func(para, call_original, super_called);	};	OSCALL *get_next() const {return (OSCALL *)Listable::get_next();};	OSCALL *get_prev() const {return (OSCALL *)Listable::get_prev();};	CALLFUNC get_func() const {return func;};};class CALLKETTE : public LinkedList {public:	void insert(OSCALL *glied, OSCALL *pos = 0, int16 posdef = LINK_END) {		LinkedList::insert(glied, pos, posdef);	};	void remove(OSCALL *glied) {LinkedList::remove(glied);};	void kill(OSCALL *glied) {LinkedList::kill(glied);};	OSCALL *get_first() const {return (OSCALL *)LinkedList::get_first();};	OSCALL *get_last() const {return (OSCALL *)LinkedList::get_last();};};class CALLSAVL : public AVL {	int16 opcode;			// Call, in den sich diese Routinen eingeklinkt haben	CALLKETTE calls;		// eingeklinkte Routinenpublic:	CALLSAVL(int16 opcode) {this->opcode = opcode;};	int16 get_opcode() const {return opcode;};	CALLKETTE *get_calls() {return &calls;};};#pragma warn_unusedarg offclass CALLSAVLTREE : public AVLTree {	int32 counter;public:	virtual int32 compare(AVL *a, AVL *b) const {return compare((CALLSAVL *)a, (CALLSAVL *)b);};	virtual int32 compare(AVL *a, int32 val) const {return compare((CALLSAVL *)a, val);};	virtual int32 compare(AVL *a, void *ptr) const {return 0;};	int32 compare(CALLSAVL *a, CALLSAVL *b) const {		return (int32)(a->get_opcode() - b->get_opcode());	};	int32 compare(CALLSAVL *a, int32 opcode) const {		return (int32)(a->get_opcode() - (int16)opcode);	};	void add_counter(int16 val);	void insert(CALLSAVL *elem) {AVLTree::insert(elem); add_counter(1);};	void remove(CALLSAVL *elem) {add_counter(-1); AVLTree::remove(elem);};	void kill(CALLSAVL *elem) {add_counter(-1); AVLTree::kill(elem);};	CALLSAVL *search(CALLSAVL *elem) const {		return (CALLSAVL *)AVLTree::search(elem);	};	CALLSAVL *search(int16 opcode) const {		return (CALLSAVL *)AVLTree::search((int32)opcode);	};};#pragma warn_unusedarg reset/* Klasses for Return-Trace: */class OSRETURN : public Listable {	RETURNFUNC func;	// eingeklinkte Routinepublic:	OSRETURN(RETURNFUNC func) {this->func = func;};	int32 call(int32 ret, int16 *para, int16 is_super) const {		return func(ret, para, is_super);	};	OSRETURN *get_next() const {return (OSRETURN *)Listable::get_next();};	OSRETURN *get_prev() const {return (OSRETURN *)Listable::get_prev();};	RETURNFUNC get_func() const {return func;};};class RETURNKETTE : public LinkedList {public:	void insert(OSRETURN *glied, OSRETURN *pos = 0, int16 posdef = LINK_END) {		LinkedList::insert(glied, pos, posdef);	};	void remove(OSRETURN *glied) {LinkedList::remove(glied);};	void kill(OSRETURN *glied) {LinkedList::kill(glied);};	OSRETURN *get_first() const {return (OSRETURN *)LinkedList::get_first();};	OSRETURN *get_last() const {return (OSRETURN *)LinkedList::get_last();};};class RETURNSAVL : public AVL {	int16 opcode;			// Return, in den sich diese Routinen eingeklinkt haben	RETURNKETTE calls;		// eingeklinkte Routinenpublic:	RETURNSAVL(int16 opcode) {this->opcode = opcode;};	int16 get_opcode() const {return opcode;};	RETURNKETTE *get_calls() {return &calls;};};#pragma warn_unusedarg offclass RETURNSAVLTREE : public AVLTree {	int32 counter;public:	virtual int32 compare(AVL *a, AVL *b) const {return compare((RETURNSAVL *)a, (RETURNSAVL *)b);};	virtual int32 compare(AVL *a, int32 val) const {return compare((RETURNSAVL *)a, val);};	virtual int32 compare(AVL *a, void *ptr) const {return 0;};	int32 compare(RETURNSAVL *a, RETURNSAVL *b) const {		return (int32)(a->get_opcode() - b->get_opcode());	};	int32 compare(RETURNSAVL *a, int32 opcode) const {		return (int32)(a->get_opcode() - (int16)opcode);	};	void add_counter(int16 val);	void insert(RETURNSAVL *elem) {AVLTree::insert(elem); add_counter(1);};	void remove(RETURNSAVL *elem) {add_counter(-1); AVLTree::remove(elem);};	void kill(RETURNSAVL *elem) {add_counter(-1); AVLTree::kill(elem);};	RETURNSAVL *search(RETURNSAVL *elem) const {		return (RETURNSAVL *)AVLTree::search(elem);	};	RETURNSAVL *search(int16 opcode) const {		return (RETURNSAVL *)AVLTree::search((int32)opcode);	};};#pragma warn_unusedarg reset