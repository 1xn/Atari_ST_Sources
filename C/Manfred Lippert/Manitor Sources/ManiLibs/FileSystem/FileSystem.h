/*----------------------------------------------------------------------------------------	FileSystem.h, file system objects and operations		28.9.2000 by Manfred Lippert, mani@mani.de	last change: 18.10.2001----------------------------------------------------------------------------------------*/#ifndef __ManiLibs_FileSystem_h__#define __ManiLibs_FileSystem_h__#include <Types2B.h>#include <UniString.h>#include <TimeSpec.h>#if TARGET_MACOS#include <Files.h>#include <Folders.h>#elif TARGET_TOS#include <LinkedList.h>#include <gemdos.h>#endif/*** General Constants ******************************************************************/#if TARGET_MACOSconst uint16 FSYS_PATH_DELIMITER = (uint16)':';#elif TARGET_TOSconst uint16 FSYS_PATH_DELIMITER = (uint16)'\\';#elseconst uint16 FSYS_PATH_DELIMITER = (uint16)'/';#endif#if TARGET_TOSconst size_t MAXPATH0 = 512;#endif/*** FSysInfo ***************************************************************************/const uint32 FSYS_INFO_NONE				= 0x00000;const uint32 FSYS_INFO_TEXT_ENCODING	= 0x00001;const uint32 FSYS_INFO_NODE_FLAGS		= 0x00002;const uint32 FSYS_INFO_VOLUME				= 0x00004;const uint32 FSYS_INFO_PARENT_DIR_ID	= 0x00008;const uint32 FSYS_INFO_NODE_ID			= 0x00010;const uint32 FSYS_INFO_CREATE_DATE		= 0x00020;const uint32 FSYS_INFO_CONTENT_MOD		= 0x00040;const uint32 FSYS_INFO_ATTR_MOD			= 0x00080;const uint32 FSYS_INFO_ACCESS_DATE		= 0x00100;const uint32 FSYS_INFO_BACKUP_DATE		= 0x00200;const uint32 FSYS_INFO_PERMISSIONS		= 0x00400;const uint32 FSYS_INFO_FINDER_INFO		= 0x00800;const uint32 FSYS_INFO_FINDER_XINFO		= 0x01000;const uint32 FSYS_INFO_VALENCE			= 0x02000;const uint32 FSYS_INFO_DATA_SIZES		= 0x04000;const uint32 FSYS_INFO_RSRC_SIZES		= 0x08000;const uint32 FSYS_INFO_SHARING_FLAGS	= 0x10000;const uint32 FSYS_INFO_USER_PRIVS		= 0x20000;const uint32 FSYS_INFO_ALL_DATES			= 0x003E0;const uint32 FSYS_INFO_GETTABLE			= 0x3FFFF;const uint32 FSYS_INFO_SETTABLE			= 0x01FE3;class FSysInfo {friend class FSysObj;friend class FSysIterator;#if TARGET_MACOS	FSCatalogInfo info;#endifpublic:	Err get_create_time(TimeSpec *spec);			// object's creation time	Err get_modify_time(TimeSpec *spec);			// object's last modification time	Err get_attmod_time(TimeSpec *spec);			// object's last attribut modification time	Err get_access_time(TimeSpec *spec);			// object's last access time	Err get_backup_time(TimeSpec *spec);			// object's last backup time	Err set_create_time(const TimeSpec *spec);	// object's creation time	Err set_modify_time(const TimeSpec *spec);	// object's last modification time	Err set_attmod_time(const TimeSpec *spec);	// object's last attribut modification time	Err set_access_time(const TimeSpec *spec);	// object's last access time	Err set_backup_time(const TimeSpec *spec);	// object's last backup time};/*** FSysVolumeInfo *********************************************************************/const uint32 FSYS_VOLINFO_NONE			= 0x0000;const uint32 FSYS_VOLINFO_CREATE_DATE	= 0x0001;const uint32 FSYS_VOLINFO_MODIFY_DATE	= 0x0002;const uint32 FSYS_VOLINFO_BACKUP_DATE	= 0x0004;const uint32 FSYS_VOLINFO_CHECKED_DATE	= 0x0008;const uint32 FSYS_VOLINFO_FILE_COUNT	= 0x0010;const uint32 FSYS_VOLINFO_FOLDER_COUNT	= 0x0020;const uint32 FSYS_VOLINFO_SIZES			= 0x0040;const uint32 FSYS_VOLINFO_BLOCKS			= 0x0080;const uint32 FSYS_VOLINFO_NEXT_ALLOC	= 0x0100;const uint32 FSYS_VOLINFO_RSRC_CLUMP	= 0x0200;const uint32 FSYS_VOLINFO_DATA_CLUMP	= 0x0400;const uint32 FSYS_VOLINFO_NEXT_ID		= 0x0800;const uint32 FSYS_VOLINFO_FINDER_INFO	= 0x1000;const uint32 FSYS_VOLINFO_FLAGS			= 0x2000;const uint32 FSYS_VOLINFO_FS_INFO		= 0x4000;const uint32 FSYS_VOLINFO_DRIVE_INFO	= 0x8000;const uint32 FSYS_VOLINFO_GETTABLE		= 0xFFFF;const uint32 FSYS_VOLINFO_SETTABLE		= 0x3004;class FSysVolumeInfo {friend class FSysObj;friend class FSysVolumeIterator;#if TARGET_MACOS	FSVolumeInfo info;#endifpublic:	Err get_create_time(TimeSpec *spec);			// object's creation time	Err get_modify_time(TimeSpec *spec);			// object's last modification time	Err get_backup_time(TimeSpec *spec);			// object's last backup time	Err get_checked_time(TimeSpec *spec);			// object's last check time	Err set_backup_time(const TimeSpec *spec);	// object's last backup time};/*** FSysObj ****************************************************************************/const uint32 FSYS_FINDFILE_MYSELF = 'mysf';			// application's file (Carbon: Bundle!)const uint32 FSYS_FINDFOLDER_MYSELF = 'mysf';		// application's parent folder (Carbon: Bundles parent folder!)const uint32 FSYS_FINDFOLDER_RESOURCES = 'rsrc';	// application's resource files folderclass FSysObj {	// specification of an existing (!) file system object (volume, folder, file), aliases are NOT resolvedfriend class FSysFork;friend class FSysVolumeIterator;friend class FSysIterator;friend class FSysForkIterator;#if TARGET_MACOS#if PPC	FSRef ref;#endif	FSSpec spec;	// only used if HFSPlus-APIs are not present, or on 68k-Macs	uint16 type_cache_mask;	// Which bits are valid?	uint16 type_cache;		// bits for type (file/folder, volume/not volume, alias/not alias)static const uint16 TYPE_FOLDER			= 0x01;	// file or folder/volume?static const uint16 TYPE_VOLUME			= 0x02;	// folder is volume?static const uint16 TYPE_ALIAS			= 0x04;	// alias?#elif TARGET_TOS	char *path;	boolean alias;#endif#if TARGET_MACOS	void Mac_check_alias();#elif TARGET_TOS	Err TOS_check_path();// only one of these 3 functions returns TRUE: (on error insensitiv returns TRUE, the others FALSE)	boolean TOS_is_case_insensitiv() const;	// file system of "this" object is case insensitiv? (and not preserving)	boolean TOS_is_case_sensitiv() const;		// file system of "this" object is case sensitiv? (but not only preserving)	boolean TOS_is_case_preserving() const;	// file system of "this" object is case preserving?	boolean TOS_is_case_insensitiv_or_preserving() const;	size_t TOS_get_max_name_length() const;	// maximal length of a file name	boolean TOS_is_truncating() const;			// file names are automatically truncated? (Otherwise errors are reported)	boolean TOS_is_DOS_truncating() const;		// file names are truncated to DOS rules (8.3)#endifpublic:	FSysObj();	~FSysObj();// create file or folder specifications:	Err init(const FSysObj *copy);									// exact copy of another specification	Err init(FSysObj *parent, const UniString *name);			// file or folder by parent and name ("name" can be only a leaf!)	Err find_folder(uint32 def);										// special folder objects	Err find_file(uint32 def);											// special file objects#if TARGET_MACOS#if PPC	Err Mac_init_fsref(const FSRef *ref);							// Mac compatibility, object by FSRef#endif	Err Mac_init_volume(FSVolumeRefNum mac_volref);				// Mac compatibility, volume by RefNum	Err Mac_init_fsspec(const FSSpec *spec);						// Mac compatibility, object by FSSpec#if PPC	Err Mac_get_fsref(FSRef *out_ref) const;						// Mac compatibility, convert object to FSRef#endif	Err Mac_get_fsspec(FSSpec *out_spec) const;					// Mac compatibility, convert object to FSSpec	Err Mac_get_volume(FSVolumeRefNum *mac_volref) const;		// Mac compatibility, get volume RefNum#elif TARGET_TOS	void TOS_init_direct(char *path, boolean alias);			// TOS init direct (path pointer is directly USED, path is not copied, path is not checked!)	Err TOS_init(FSysObj *parent, const char *path);			// TOS compatibility, object by parent and partial path	Err TOS_init_path(const char *path);							// TOS compatibility, object by full path	Err TOS_init_volume(char drive);									// TOS compatibility, volume by drive letter	Err TOS_get_drive(char *drive);									// TOS compatibility, get drive letter#endif	void dispose();// is_file/is_folder infos may not be correct if "this" is an alias and the alias cannot be resolved!	boolean is_file();											// object is a file? (can also be an alias to a file)	boolean is_folder();											// object is a folder? (can also be a volume or an alias to a folder or an alias to a volume)	boolean is_volume();											// object is a volume? (can normally NOT be an alias! - the alias itself IS NOT a volume, it can only POINT to a volume)	boolean is_alias();											// object is an alias to another object	boolean is_file_or_alias();								// possibly faster than (is_file() || is_alias())	boolean is_equal(const FSysObj *other) const;				// compare if "other" specifies the same file system object	Err create_file(const UniString *name, FSysObj *out);		// create new file in this folder/volume (out cannot be this!)	Err create_folder(const UniString *name, FSysObj *out);	// create new folder in this folder/volume (out cannot be this!)	Err create_alias(const FSysObj *original, const UniString *name, FSysObj *out);	// create new alias in this folder/volume that points to object "original" (out cannot be this!)	Err resolve_alias(FSysObj *out);									// resolve this alias to original object (out can be this)	Err kill();																// delete the file or (empty!) folder	Err move(FSysObj *destination_folder);							// move to folder or volume (if it returns error, user must copy and kill it - eventually recursive - for its own)	Err rename(const UniString *name);								// rename object// Err exchange(const FSysObj *destination) const;	Err create_fork(const UniString *fork_name) const;			// create new fork	Err create_data_fork() const;										// create data fork	Err create_resource_fork() const;								// create resource fork	Err kill_fork(const UniString *fork_name) const;			// delete fork	Err kill_data_fork() const;										// delete data fork	Err get_info(	uint32 which_info,								// get info about object						FSysInfo *out_info,						UniString *out_name,						FSysObj *out_parent);	Err get_parent(FSysObj *out_parent) {return get_info(0, 0, 0, out_parent);};	Err get_name(UniString *out_name);								// get name of object	Err get_path(UniString *out_path);								// get full path of object#if TARGET_TOS	char *TOS_get_direct_path() const {return path;};#endif	Err set_info(	uint32 which_info,								// set info about object						const FSysInfo *info);	Err set_type_and_creator(uint32 type, uint32 creator);	// does nothing under non-MacOS systems	Err get_volume_info(	uint32 which_info,						// get info about volume								FSysVolumeInfo *out_info,								UniString *out_name,								FSysObj *out_volume);	Err set_volume_info(	uint32 which_info,						// set info about volume								const FSysVolumeInfo *info);	static Err get_data_fork_name(UniString *out);				// get general name of data fork	static Err get_resource_fork_name(UniString *out);			// get general name of resource fork (error if no resource forks are supported by the system)};/*** FSysVolumeIterator *****************************************************************/class FSysVolumeIterator {#if TARGET_MACOS	uint32 index;#elif TARGET_TOS	uint32 volume_bitmask;	uint8 index;#endifpublic:	Err open();	Err read(FSysObj *out_volume,				uint32 which_info,				FSysVolumeInfo *out_info,				UniString *out_name);	Err close();};/*** FSysForkIterator *******************************************************************/class FSysForkIterator {#if TARGET_MACOS && PPC	FSysObj *obj;	CatPositionRec iterator;#else	boolean got_it;#endifpublic:	FSysForkIterator(FSysObj *obj);	Err get_next(	UniString *out_fork_name,		// can be 0						uint64 *out_fork_size = 0);	// can be 0	Err count(uint16 *out_count);	// may call reset/get_next.../reset	void reset(FSysObj *obj);};/*** FSysPosition ***********************************************************************/const uint16 FSYS_POS_MASK			= 0xF;	// mask for position definition (without "flags")// position definition:const uint16 FSYS_POS_AT_MARK		= 0;		// current position, offset ignoredconst uint16 FSYS_POS_FROM_START	= 1;		// offset from startconst uint16 FSYS_POS_FROM_END	= 2;		// offset from endconst uint16 FSYS_POS_FROM_MARK	= 3;		// offset from mark// flags:const uint16 FSYS_POS_CACHE		= 0x10;	// please cache this requestconst uint16 FSYS_POS_NOCACHE		= 0x20;	// please do not cache this requestconst uint16 FSYS_POS_FORCE_READ = 0x40;	// force read from disc (bypass cache for reading, but filling the cache is allowed)class FSysPosition {	uint16 mode;	int64 offset;public:	FSysPosition();	FSysPosition(uint16 mode, int64 offset);	void set(uint16 mode, int64 offset) {this->mode = mode; this->offset = offset;};	uint16 get_mode() const {return mode;};	int64 get_offset() const {return offset;};};/*** FSysFork ***************************************************************************/#if TARGET_MACOS//const int8 FSYS_PERM_CURRENT	= 0;	// oversized to realize on some systemsconst int8 FSYS_PERM_READ			= 1;const int8 FSYS_PERM_WRITE			= 2;const int8 FSYS_PERM_RW				= 3;//const int8 FSYS_PERM_RW_SHARED	= 4;	// ???#elif TARGET_TOSconst int8 FSYS_PERM_READ			= FO_READ;		// 0const int8 FSYS_PERM_WRITE			= FO_WRITE;		// 1const int8 FSYS_PERM_RW				= FO_RW;			// 2#endifclass FSysFork {#if TARGET_MACOS	int16 ref;	boolean open_flag;#elif TARGET_TOS	int16 handle;	Err TOS_seek(const FSysPosition *pos);#endifpublic:	FSysFork();	~FSysFork();	Err open(FSysObj *obj,											// open fork for reading and/or writing				const UniString *fork_name,				int8 permissions);	Err open_data_fork(FSysObj *obj, int8 permissions);	// open data fork for reading and/or writing	boolean is_open() const {#if TARGET_MACOS		return open_flag;#elif TARGET_TOS		return (handle >= 0);#endif	};	Err read(const FSysPosition *pos, void *buf, size_t size, size_t *out_size);	Err write(const FSysPosition *pos, const void *buf, size_t size, size_t *out_size);	Err get_position(uint64 *out);	Err set_position(const FSysPosition *pos);	Err get_size(uint64 *out);	Err set_size(const FSysPosition *pos);// Err allocate(flags, FSysPosition *pos, count, out_count);	Err flush();	Err close();// get_info(...);};/*** FSysSearchParams *******************************************************************/class FSysSearchParams {	friend class FSysIterator;#if TARGET_MACOS	FSSearchParams params;#endifpublic:};/*** FSysIterator ***********************************************************************/const uint32 FSYS_ITER_FLAT		= 0;	// immediate children of container onlyconst uint32 FSYS_ITER_SUBTREE	= 1;	// entire subtree rooted at container (not available on all file systems; order of returned items is unspecified)// Be careful: Under some systems (MagiC) the FSysIterator can NOT be used recursively// (MagiC is limited to a specific count of simlultanuous Dopendir-calls ... and crashes if there are too much.)#if TARGET_TOSclass FSysObjLink : public FSysObj, public Link<FSysObjLink> {};class FSysObjList : public List<FSysObjLink> {};#endifclass FSysIterator {#if TARGET_MACOS	FSIterator ref;	boolean finished;#elif TARGET_TOS	int32 dir;	char *path;	boolean subtree_flag;	FSysObjList subtree_folder_list;	Err TOS_open_without_subtree_killing(FSysObj *container, uint32 flags);	Err TOS_close_without_subtree_killing();#endifpublic:	FSysIterator();	~FSysIterator();	Err open(FSysObj *container, uint32 flags = FSYS_ITER_FLAT);// ERR_FINISHED, if no more items - out_count guaranteed to be 0 in this case!	Err read(uint32 count,				uint32 *out_count,										boolean *changed_flag,				uint32 which_info,				FSysInfo *out_info_array[],				FSysObj *out_obj_array[],				UniString *out_name_array[]);	Err read(boolean *changed_flag,				uint32 which_info,				FSysInfo *out_info,				FSysObj *out_obj,				UniString *out_name);	static uint32 get_help_buffer_size() {#if TARGET_MACOS		return (sizeof(FSCatalogInfo) + sizeof(FSRef) + sizeof(HFSUniStr255));#else		return 0;#endif	};	Err read(uint32 count,				void *help_buffer,	// must be count * help_buffer_size!!! (or 0 if help_buffer_size is 0)				uint32 *out_count,										boolean *changed_flag,				uint32 which_info,				FSysInfo *out_info_array[],				FSysObj *out_obj_array[],				UniString *out_name_array[]);// ERR_FINISHED, if no more items - out_count guaranteed to be 0 in this case!	Err search(	const FSysSearchParams *search_criteria,					uint32 count,					uint32 *out_count,											boolean *changed_flag,					uint32 which_info,					FSysInfo *out_info_array[],					FSysObj *out_obj_array[],					UniString *out_name_array[]);	Err search(	const FSysSearchParams *search_criteria,					boolean *changed_flag,					uint32 which_info,					FSysInfo *out_info,					FSysObj *out_obj,					UniString *out_name);	Err close();};#endif