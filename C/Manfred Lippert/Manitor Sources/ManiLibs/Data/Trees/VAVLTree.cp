/*----------------------------------------------------------------------------------------	VAVLTree.cp, class for handling automatically balanced binary trees, "virtual" version		7.6.1999 by Manfred Lippert, mani@mani.de	last change: 29.6.1999----------------------------------------------------------------------------------------*/#include <VAVLTree.h>// VAVL element:VAVL::~VAVL() {}Err VAVL::get_left_lock(VAVL **elem) {	if (left != VAVL_UNLOADED) {			// already in memory?		if (left) {			left->lock();		}		*elem = left;		return OK;	}	Err err = load_left(&left);	// virtual function to load element in memory	if (err == OK) {			// OK, element loaded (not 0 and not AVL_UNLOADED!)		left->top = this;		left->direction = VAVLDIR_LEFT;		left->lock();		*elem = left;	}	return err;}Err VAVL::get_right_lock(VAVL **elem) {	if (right != VAVL_UNLOADED) {			// already in memory?		if (right) {			right->lock();		}		*elem = right;		return OK;	}	Err err = load_right(&right);	// virtual function to load element in memory	if (err == OK) {				// OK, element loaded (not 0 and not AVL_UNLOADED!)		right->top = this;		right->direction = VAVLDIR_RIGHT;		right->lock();		*elem = right;	}	return err;}Err VAVL::get_next_lock(VAVL **result) {	VAVL *such;	Err err = get_right_lock(&such);	if (err != OK) {		return err;	}	if (such) {		VAVL *left;		while ((err = such->get_left_lock(&left)) == OK && left != 0L) {			such->unlock();			such = left;		}		if (err == OK) {			*result = such;		// gefunden!		} else {			such->unlock();		}		return err;	}	VAVL *old;	such = this;	such->lock();	while (such && such->direction == VAVLDIR_RIGHT) {		old = such;		such = such->get_top_lock();		old->unlock();	}	if (such) {		old = such;		such = such->get_top_lock();		old->unlock();	}	*result = such;	return err;}Err VAVL::get_prev_lock(VAVL **result) {	VAVL *such;	Err err = get_left_lock(&such);	if (err != OK) {		return err;	}	if (such) {		VAVL *right;		while ((err = such->get_left_lock(&right)) == OK && right != 0L) {			such->unlock();			such = right;		}		if (err == OK) {			*result = such;		// gefunden!		} else {			such->unlock();		}		return err;	}	VAVL *old;	such = this;	such->lock();	while (such && such->direction == VAVLDIR_LEFT) {		old = such;		such = such->get_top_lock();		old->unlock();	}	if (such) {		old = such;		such = such->get_top_lock();		old->unlock();	}	*result = such;	return err;}// VAVL tree:VAVLTree::VAVLTree(VAVL *root) {	this->root = root;}VAVLTree::~VAVLTree() {	delete_all();		// Standard zerstšrt alle VAVL-Objekte, aber behŠlt Baum prinzipiell bei}Err VAVLTree::get_root_lock(VAVL **elem) {	if (root != VAVL_UNLOADED) {			// already in memory?		if (root) {			root->lock();		}		*elem = root;		return OK;	}	Err err = load_root();	// virtual function to load element in memory	if (err == OK) {		// OK, element loaded (not 0 and not AVL_UNLOADED!)		root->top = 0;		root->direction = VAVLDIR_ROOT;		root->lock();		*elem = root;	}	return err;}Err VAVLTree::empty_with_killing() {	VAVL *elem;	VAVL *next;	Err err = get_first_lock(&elem);	if (err != OK) {		return err;	}	while (elem) {		err = elem->get_next_lock(&next);		elem->unlock();		if (err != OK) {			return err;		}		kill(elem);				// alle Elemente zerstšren		elem = next;	}	return err;}Err VAVLTree::unload_recursive(VAVL *elem) {	Err err;	VAVL *child = elem->left;	if (child && child != VAVL_UNLOADED) {		err = unload_recursive(child);		if (err != OK) {			return err;		}	}	child = elem->left;	if (child && child != VAVL_UNLOADED) {		err = unload_recursive(child);		if (err != OK) {			return err;		}	}	return elem->unload();}Err VAVLTree::unload_all() {	Err err;	if (root && root != VAVL_UNLOADED) {		err = unload_recursive(root);		if (err == OK) {			root = VAVL_UNLOADED;		}	}	return err;}void VAVLTree::delete_recursive(VAVL *elem) {	VAVL *child = elem->left;	if (child && child != VAVL_UNLOADED) {		delete_recursive(child);	}	child = elem->left;	if (child && child != VAVL_UNLOADED) {		delete_recursive(child);	}	delete elem;}void VAVLTree::delete_all() {	if (root && root != VAVL_UNLOADED) {		delete_recursive(root);		root = VAVL_UNLOADED;	}}Err VAVLTree::little_rotate_left(VAVL *elem) {	Err err;	VAVL *top;	VAVL *left;	VAVL *grand_right;	err = elem->get_left_lock(&left);	if (err != OK) {		return err;	}	err = left->get_right_lock(&grand_right);	if (err != OK) {		left->unlock();		return err;	}	top = elem->get_top_lock();	if (!top) {		root = left;	} else {		if (elem->direction == VAVLDIR_LEFT) {			top->left = left;		} else {			top->right = left;		}	}	left->direction = elem->direction;	left->top = top;	elem->left_height = left->right_height++;	left->right = elem;	elem->top = left;	elem->direction = VAVLDIR_RIGHT;	elem->left = grand_right;	grand_right->top = elem;	grand_right->direction = VAVLDIR_LEFT;	grand_right->unlock();	left->unlock();	top->unlock();	return err;}Err VAVLTree::little_rotate_right(VAVL *elem) {	Err err;	VAVL *top;	VAVL *right;	VAVL *grand_left;	err = elem->get_right_lock(&right);	if (err != OK) {		return err;	}	err = right->get_left_lock(&grand_left);	if (err != OK) {		right->unlock();		return err;	}	top = elem->get_top_lock();	if (!top) {		root = right;	} else {		if (elem->direction == VAVLDIR_LEFT) {			top->left = right;		} else {			top->right = right;		}	}	right->top = top;	right->direction = elem->direction;	elem->right_height = right->left_height++;	right->left = elem;	elem->top = right;	elem->direction = VAVLDIR_LEFT;	elem->right = grand_left;	grand_left->top = elem;	grand_left->direction = VAVLDIR_RIGHT;	grand_left->unlock();	right->unlock();	top->unlock();	return err;}Err VAVLTree::big_rotate_left(VAVL *elem) {	Err err;	VAVL *top;	VAVL *left;	VAVL *grand_right;	VAVL *great_grand_left;	VAVL *great_grand_right;	err = elem->get_left_lock(&left);	if (err != OK) {		return err;	}	err = left->get_right_lock(&grand_right);	if (err != OK) {		left->unlock();		return err;	}	err = grand_right->get_left_lock(&great_grand_left);	if (err != OK) {		grand_right->unlock();		left->unlock();		return err;	}	err = grand_right->get_right_lock(&great_grand_right);	if (err != OK) {		if (great_grand_left) {			great_grand_left->unlock();		}		grand_right->unlock();		left->unlock();		return err;	}	top = elem->get_top_lock();	left->right_height = grand_right->left_height;	grand_right->left_height = (int16)(elem->left_height - 1);	elem->left_height = grand_right->right_height;	grand_right->right_height = (int16)(elem->right_height + 1);	if (!top) {		root = grand_right;	} else {		if (elem->direction == VAVLDIR_LEFT) {			top->left = grand_right;		} else {			top->right = grand_right;		}	}	grand_right->top = top;	grand_right->direction = elem->direction;	grand_right->left = left;	grand_right->right = elem;	left->top = grand_right;	left->right = great_grand_left;	elem->top = grand_right;	elem->direction = VAVLDIR_RIGHT;	elem->left = great_grand_right;	if (great_grand_left) {		great_grand_left->top = left;		great_grand_left->direction = VAVLDIR_RIGHT;		great_grand_left->unlock();	}	if (great_grand_right) {		great_grand_right->top = elem;		great_grand_right->direction = VAVLDIR_LEFT;		great_grand_right->unlock();	}	grand_right->unlock();	left->unlock();	top->unlock();	return err;}Err VAVLTree::big_rotate_right(VAVL *elem) {	Err err;	VAVL *top;	VAVL *right;	VAVL *grand_left;	VAVL *great_grand_left;	VAVL *great_grand_right;	err = elem->get_right_lock(&right);	if (err != OK) {		return err;	}	err = right->get_left_lock(&grand_left);	if (err != OK) {		right->unlock();		return err;	}	err = grand_left->get_left_lock(&great_grand_left);	if (err != OK) {		grand_left->unlock();		right->unlock();		return err;	}	err = grand_left->get_right_lock(&great_grand_right);	if (err != OK) {		if (great_grand_left) {			great_grand_left->unlock();		}		grand_left->unlock();		right->unlock();		return err;	}	top = elem->get_top_lock();	right->left_height = grand_left->right_height;	grand_left->right_height = (int16)(elem->right_height - 1);	elem->right_height = grand_left->left_height;	grand_left->left_height = (int16)(elem->left_height + 1);	if (!top) {		root = grand_left;	} else {		if (elem->direction == VAVLDIR_LEFT) {			top->left = grand_left;		} else {			top->right = grand_left;		}	}	grand_left->top = top;	grand_left->direction = elem->direction;	grand_left->right = right;	grand_left->left = elem;	right->top = grand_left;	right->left = great_grand_right;	elem->top = grand_left;	elem->direction = VAVLDIR_LEFT;	elem->right = great_grand_left;	if (great_grand_right) {		great_grand_right->top = right;		great_grand_right->direction = VAVLDIR_LEFT;		great_grand_right->unlock();	}	if (great_grand_left) {		great_grand_left->top = elem;		great_grand_left->direction = VAVLDIR_RIGHT;		great_grand_left->unlock();	}	grand_left->unlock();	right->unlock();	top->unlock();	return err;}/* Hšhe des Astes um eins erhšhen und ggf. ausbalancieren */Err VAVLTree::growbalance(VAVL *elem, int8 child_direction, int8 grandchild_direction) {	Err err;	VAVL *old;	elem->lock();	do {		if (child_direction == VAVLDIR_LEFT) {			if (++elem->left_height > elem->right_height + 1) {	/* mu§ rotiert werden? */				if (child_direction != grandchild_direction) {					err = big_rotate_left(elem);				} else {					err = little_rotate_left(elem);				}				elem->unlock();				return err;			}			if (elem->left_height <= elem->right_height) {	/* Vater wird nicht hšher? */				elem->unlock();				return err;			}		} else {			if (++elem->right_height > elem->left_height + 1) {	/* mu§ rotiert werden? */				if (child_direction != grandchild_direction) {					err = big_rotate_right(elem);				} else {					err = little_rotate_right(elem);				}				elem->unlock();				return err;			}			if (elem->right_height <= elem->left_height) {	/* Vater wird nicht hšher? */				elem->unlock();				return err;			}		}		grandchild_direction = child_direction;		child_direction = elem->direction;		old = elem;		elem = elem->get_top_lock();		old->unlock();	} while (elem);	return err;}Err VAVLTree::insert(VAVL *elem) {	Err err;	VAVL *pos;	err = search_nearest_lock(elem, &pos, &elem->direction);	if (err != OK) {		return err;	}	elem->top = pos;	elem->left = 0;	elem->right = 0;	elem->left_height = 0;	elem->right_height = 0;	if (!pos) {						// Noch kein Element - als Root eingefŸgt		root = elem;	} else {						// ggf. ausbalancieren		if (elem->direction == VAVLDIR_LEFT) {	// links eingefŸgt			pos->left = elem;			err = growbalance(pos, VAVLDIR_LEFT, VAVLDIR_ROOT);		} else {								// rechts eingefŸgt			pos->right = elem;			err = growbalance(pos, VAVLDIR_RIGHT, VAVLDIR_ROOT);		}		pos->unlock();	}	return err;}Err VAVLTree::swap(VAVL *a, VAVL *b) {	Err err;	VAVL *a_top;	VAVL *a_left;	VAVL *a_right;	VAVL *b_top;	VAVL *b_left;	VAVL *b_right;	err = a->get_left_lock(&a_left);	if (err != OK) {		return err;	}	err = a->get_right_lock(&a_right);	if (err != OK) {		a_left->unlock();		return err;	}	err = b->get_left_lock(&b_left);	if (err != OK) {		a_right->unlock();		a_left->unlock();		return err;	}	err = b->get_right_lock(&b_right);	if (err != OK) {		b_left->unlock();		a_right->unlock();		a_left->unlock();		return err;	}	a_top = a->get_top_lock();	b_top = b->get_top_lock();	{								/* Inhalt von a und b tauschen */		int16 a_lheight = a->left_height;		int16 a_rheight = a->right_height;		int8 a_dir = a->direction;		a->top = b_top;		a->left = b_left;		a->right = b_right;		a->left_height = b->left_height;		a->right_height = b->right_height;		a->direction = b->direction;		b->top = a_top;		b->left = a_left;		b->right = a_right;		b->left_height = a_lheight;		b->right_height = a_rheight;		b->direction = a_dir;	}	if (a->top == a) {				/* a zeigt auf sich selbst (-> b mu§ auf a gezeigt haben, daher muž a jetzt auf b zeigen) */		a->top = b;	} else if (a->left == a) {		/* a zeigt auf sich selbst */		a->left = b;	} else if (a->right == a) {		/* a zeigt auf sich selbst */		a->right = b;	}	if (b->top == b) {				/* b zeigt auf sich selbst */		b->top = a;	} else if (b->left == b) {		/* b zeigt auf sich selbst */		b->left = a;	} else if (b->right == b) {		/* b zeigt auf sich selbst */		b->right = a;	}	if (!a_top) {		root = b;							/* a war Root, jetzt wird es b */	} else if (a_top != b) {		if (b->direction == VAVLDIR_LEFT) {	/* Element Ÿber a bekommt jetzt b als Nachfolger */			a_top->left = b;		} else {			a_top->right = b;		}	}	if (!b_top) {		root = a;							/* b war Root, jetzt wird es a */	} else if (b_top != a) {		if (a->direction == VAVLDIR_LEFT) {	/* Element Ÿber b bekommt jetzt a als Nachfolger */			b_top->left = a;		} else {			b_top->right = a;		}	}	if (a_left && a_left != b) {		a_left->top = b;		/* linker Nachfolger von a bekommt jetzt b als Vater */	}	if (a_right && a_right != b) {		a_right->top = b;		/* rechter Nachfolger von a bekommt jetzt b als Vater */	}	if (b_left && b_left != a) {		b_left->top = a;		/* linker Nachfolger von b bekommt jetzt a als Vater */	}	if (b_right && b_right != a) {		b_right->top = a;		/* rechter Nachfolger von b bekommt jetzt a als Vater */	}	b_right->unlock();	b_left->unlock();	b_top->unlock();	a_right->unlock();	a_left->unlock();	a_top->unlock();	return err;}Err VAVLTree::shrinkbalance(VAVL *elem, int8 child_direction) {	Err err;	int8 elem_direction;	VAVL *top;	VAVL *right;	VAVL *left;	elem->lock();		do {		elem_direction = elem->direction;		top = elem->get_top_lock();				if (child_direction == VAVLDIR_LEFT) {			if (--elem->left_height < elem->right_height - 1) {	// mu§ rotiert werden?				err = elem->get_right_lock(&right);				// Ursache (lŠngeren Enkel-Ast) feststellen				if (err != OK) {					if (top) {						top->unlock();					}					elem->unlock();					return err;				}				if (right->left_height > right->right_height) {	/* innerer Knoten */					err = big_rotate_right(elem);				} else {					err = little_rotate_right(elem);				}				right->unlock();				if (!top || err != OK) {					elem->unlock();					return err;				}				if (elem_direction == VAVLDIR_LEFT) {					elem->unlock();					err = top->get_left_lock(&elem);					if (err != OK) {						top->unlock();						return err;					}					if (elem->left_height == top->left_height - 1 || elem->right_height == top->left_height - 1) {						top->unlock();						elem->unlock();						return err;					}				} else {					elem->unlock();					err = top->get_right_lock(&elem);					if (err != OK) {						top->unlock();						return err;					}					if (elem->left_height == top->right_height - 1 || elem->right_height == top->right_height - 1) {						top->unlock();						elem->unlock();						return err;					}				}			} else if (elem->left_height < elem->right_height) {	// Vater wird nicht kleiner?				if (top) {					top->unlock();				}				elem->unlock();				return err;			}		} else {			if (--elem->right_height < elem->left_height - 1) {	// mu§ rotiert werden?				err = elem->get_left_lock(&left);				// Ursache (lŠngeren Enkel-Ast) feststellen				if (err != OK) {					if (top) {						top->unlock();					}					elem->unlock();					return err;				}				if (left->left_height < left->right_height) {	// innerer Knoten					err = big_rotate_left(elem);				} else {					err = little_rotate_left(elem);				}				if (!top || err != OK) {					elem->unlock();					return err;				}				if (elem_direction == VAVLDIR_LEFT) {					elem->unlock();					err = top->get_left_lock(&elem);					if (err != OK) {						top->unlock();						return err;					}					if (elem->left_height == top->left_height - 1 || elem->right_height == top->left_height - 1) {						top->unlock();						elem->unlock();						return err;					}				} else {					elem->unlock();					err = top->get_right_lock(&elem);					if (err != OK) {						top->unlock();						return err;					}					if (elem->left_height == top->right_height - 1 || elem->right_height == top->right_height - 1) {						top->unlock();						elem->unlock();						return err;					}				}			} else if (elem->right_height < elem->left_height) {	// Vater wird nicht kleiner?				if (top) {					top->unlock();				}				elem->unlock();				return err;			}		}		child_direction = elem_direction;		elem->unlock();		elem = top;	} while (elem);	return err;}Err VAVLTree::remove(VAVL *elem) {	Err err;	{		VAVL *tausch;		err = elem->get_left_lock(&tausch);				// vom linken Unterbaum...		if (tausch) {									// (falls vorhanden)			VAVL *el2;			do {				while ((err = tausch->get_right_lock(&el2)) == OK && el2 != 0L) {	// ...das rechteste suchen...					tausch->unlock();					tausch = el2;				}				if (err != OK) {					tausch->unlock();					return err;				}				err = swap(elem, tausch);					// ...und mit dem zu lšschenden vertauschen				tausch->unlock();				if (err != OK) {					return err;				}				err = elem->get_left_lock(&tausch);			// weiterversuchen (tausch mu§ noch kein Blatt sein!)				if (err != OK) {					return err;				}			} while (tausch);		} else {			VAVL *el2;			err = elem->get_right_lock(&tausch);			// oder vom rechten Unterbaum...			if (err != OK) {				return err;			}			if (tausch) {				do {					while ((err = tausch->get_left_lock(&el2)) == OK && el2 != 0L) {	// ...das linkeste suchen...						tausch->unlock();						tausch = el2;					}					if (err != OK) {						tausch->unlock();						return err;					}					err = swap(elem, tausch);				// ...und mit dem zu lšschenden vertauschen					tausch->unlock();					if (err != OK) {						return err;					}					err = elem->get_right_lock(&tausch);	// weiterversuchen (tausch mu§ noch kein Blatt sein!)					if (err != OK) {						return err;					}				} while (tausch);			}		}	}	/* Jetzt elem (Blatt) entfernen: */	{		VAVL *top;		top = elem->get_top_lock();		if (!top) {			root = 0;			/* War letztes Element */		} else {			if (elem->direction == VAVLDIR_LEFT) {				top->left = 0;				err = shrinkbalance(top, VAVLDIR_LEFT);			} else {				top->right = 0;				err = shrinkbalance(top, VAVLDIR_RIGHT);			}			top->unlock();		}	}	return err;}Err VAVLTree::kill(VAVL *elem) {	Err err = remove(elem);	if (err == OK) {		delete elem;	}	return err;}Err VAVLTree::search_lock(VAVL *elem, VAVL **result) {	Err err;	VAVL *old;	VAVL *such;	err = get_root_lock(&such);	if (err != OK) {		return err;	}	int32 comp;	while (such) {		err = compare(elem, such, &comp);		if (err != OK) {			such->unlock();			return err;		}		if (comp == 0) {			*result = such;			return err;		}		old = such;		if (comp < 0) {			err = such->get_left_lock(&such);		} else {			err = such->get_right_lock(&such);		}		old->unlock();		if (err != OK) {			return err;		}	}	*result = such;	return err;}Err VAVLTree::search_nearest_lock(VAVL *elem, VAVL **result, int8 *direction) {	Err err;	VAVL *such;	VAVL *next;	int32 comp;	err = get_root_lock(&such);	if (err != OK) {		return err;	}	while (such) {		err = compare(elem, such, &comp);		if (err != OK) {			such->unlock();			return err;		}		if (comp < 0) {			err = such->get_left_lock(&next);			if (err != OK) {				such->unlock();				return err;			}			if (!next) {				if (direction) {					*direction = VAVLDIR_LEFT;				}				*result = such;				return err;			}		} else {			err = such->get_right_lock(&next);			if (err != OK) {				such->unlock();				return err;			}			if (!next) {				if (direction) {					*direction = VAVLDIR_RIGHT;				}				*result = such;				return err;			}		}		such->unlock();		such = next;	}	*result = such;	return err;}Err VAVLTree::search_lock(int32 val, VAVL **result) {	Err err;	VAVL *old;	VAVL *such;	err = get_root_lock(&such);	if (err != OK) {		return err;	}	int32 comp;	while (such) {		err = compare(such, val, &comp);		if (err != OK) {			such->unlock();			return err;		}		if (comp == 0) {			*result = such;			return err;		}		old = such;		if (comp > 0) {			err = such->get_left_lock(&such);		} else {			err = such->get_right_lock(&such);		}		old->unlock();		if (err != OK) {			return err;		}	}	*result = such;	return err;}Err VAVLTree::search_nearest_lock(int32 val, VAVL **result, int8 *direction) {	Err err;	VAVL *such;	VAVL *next;	int32 comp;	err = get_root_lock(&such);	if (err != OK) {		return err;	}	while (such) {		err = compare(such, val, &comp);		if (err != OK) {			such->unlock();			return err;		}		if (comp > 0) {			err = such->get_left_lock(&next);			if (err != OK) {				such->unlock();				return err;			}			if (!next) {				if (direction) {					*direction = VAVLDIR_LEFT;				}				*result = such;				return err;			}		} else {			err = such->get_right_lock(&next);			if (err != OK) {				such->unlock();				return err;			}			if (!next) {				if (direction) {					*direction = VAVLDIR_RIGHT;				}				*result = such;				return err;			}		}		such->unlock();		such = next;	}	*result = such;	return err;}Err VAVLTree::search_lock(void *ptr, VAVL **result) {	Err err;	VAVL *old;	VAVL *such;	err = get_root_lock(&such);	if (err != OK) {		return err;	}	int32 comp;	while (such) {		err = compare(such, ptr, &comp);		if (err != OK) {			such->unlock();			return err;		}		if (comp == 0) {			*result = such;			return err;		}		old = such;		if (comp > 0) {			err = such->get_left_lock(&such);		} else {			err = such->get_right_lock(&such);		}		old->unlock();		if (err != OK) {			return err;		}	}	*result = such;	return err;}Err VAVLTree::search_nearest_lock(void *ptr, VAVL **result, int8 *direction) {	Err err;	VAVL *such;	VAVL *next;	int32 comp;	err = get_root_lock(&such);	if (err != OK) {		return err;	}	while (such) {		err = compare(such, ptr, &comp);		if (err != OK) {			such->unlock();			return err;		}		if (comp > 0) {			err = such->get_left_lock(&next);			if (err != OK) {				such->unlock();				return err;			}			if (!next) {				if (direction) {					*direction = VAVLDIR_LEFT;				}				*result = such;				return err;			}		} else {			err = such->get_right_lock(&next);			if (err != OK) {				such->unlock();				return err;			}			if (!next) {				if (direction) {					*direction = VAVLDIR_RIGHT;				}				*result = such;				return err;			}		}		such->unlock();		such = next;	}	*result = such;	return err;}Err VAVLTree::get_first_lock(VAVL **first) {	Err err;	VAVL *elem;	err = get_root_lock(&elem);	if (err != OK) {		return err;	}	if (elem) {		VAVL *left;		while ((err = elem->get_left_lock(&left)) == OK && left != 0L) {			elem->unlock();			elem = left;		}		if (err != OK) {			elem->unlock();			return err;		}	}	*first = elem;	return err;}Err VAVLTree::get_last_lock(VAVL **last) {	Err err;	VAVL *elem;	err = get_root_lock(&elem);	if (err != OK) {		return err;	}	if (elem) {		VAVL *right;		while ((err = elem->get_right_lock(&right)) == OK && right != 0L) {			elem->unlock();			elem = right;		}		if (err != OK) {			elem->unlock();			return err;		}	}	*last = elem;	return err;}Err VAVLTree::resort_rekursive(VAVL *el) {	Err err;	VAVL *left;	VAVL *right;	err = el->get_left_lock(&left);	if (err != OK) {		return err;	}	err = el->get_right_lock(&right);	if (err != OK) {		left->unlock();		return err;	}	err = insert(el);	if (err != OK) {		right->unlock();		left->unlock();		return err;	}	if (left) {		err = resort_rekursive(left);		left->unlock();		if (err != OK && right != 0L) {			right->unlock();			return err;		}	}	if (right) {		err = resort_rekursive(right);		right->unlock();	}	return err;}Err VAVLTree::resort() {	Err err;	VAVL *root;	err = get_root_lock(&root);	if (err != OK) {		return err;	}	if (root) {		empty_with_removing();		err = resort_rekursive(root);		root->unlock();	}	return err;}