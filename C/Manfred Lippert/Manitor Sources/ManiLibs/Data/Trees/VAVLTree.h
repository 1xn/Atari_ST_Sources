/*----------------------------------------------------------------------------------------	VAVLTree.h, class for handling automatically balanced binary trees, "virtual" version		7.6.1999 by Manfred Lippert, mani@mani.de	last change: 15.6.1999----------------------------------------------------------------------------------------*/#ifndef __ManiLibs_VAVLTree_H__#define __ManiLibs_VAVLTree_H__#include <Err.h>#include <Lockable.h>#define VAVLDIR_ROOT	0	// Root kann allerdings auch andere Directions haben! (undefiniert)#define VAVLDIR_LEFT	1#define VAVLDIR_RIGHT	2#define VAVL_UNLOADED ((VAVL *)(-1L))class VAVL : public Lockable {friend class VAVLTree;	VAVL *top;			// always valid!	VAVL *left;			// 0, VAVL_UNLOADED or valid pointer	VAVL *right;		// 0, VAVL_UNLOADED or valid pointer	int16 left_height;	// always valid	int16 right_height;	// always valid	int8 direction;		// always valid; VAVLDIR_ROOT, VAVLDIR_LEFT, VAVLDIR_RIGHT// these virtual functions must allocate memory for VAVL, load its data,// set the right pointer of this->left or this->right// and initialize the following VAVL datas in the new allocted element:// left, right (to 0 or VAVL_UNLOADED)// left_height, right_height (!!!)// top and direction must NOT be initialized! Its done automatically	virtual Err load_left(VAVL **left) = 0;		// must set *left (=this->left)	virtual Err load_right(VAVL **right) = 0;	// must set *right (=this->right)	virtual Err unload() = 0;		// must delete "this" or return an errorpublic:	virtual ~VAVL();	VAVL *get_top_lock() {top->lock(); return top;};	Err get_left_lock(VAVL **left);	Err get_right_lock(VAVL **right);	Err get_next_lock(VAVL **next);	Err get_prev_lock(VAVL **prev);	int32 get_left_height() const {return left_height;};	int32 get_right_height() const {return right_height;};	int8 get_direction() const {return direction;};	void set_left_height(int32 height) {left_height = height;};	void set_right_height(int32 height) {right_height = height;};};class VAVLTree {	VAVL *root;	Err little_rotate_left(VAVL *elem);	Err little_rotate_right(VAVL *elem);	Err big_rotate_left(VAVL *elem);	Err big_rotate_right(VAVL *elem);	Err growbalance(VAVL *elem, int8 child_direction, int8 grandchild_direction);	Err swap(VAVL *a, VAVL *b);	Err shrinkbalance(VAVL *elem, int8 child_direction);	Err resort_rekursive(VAVL *elem);// this virtual function must allocate memory for root VAVL, load its data,// set the pointer of this->root// and initialize the following VAVL datas in the new allocted element:// left, right (to 0 or VAVL_UNLOADED)// left_height, right_height (!!!)// top and direction must NOT be initialized! Its done automatically	virtual Err load_root() = 0;	// must set root	virtual Err unload() = 0;		// must delete "this" or return error	Err unload_recursive(VAVL *elem);	void delete_recursive(VAVL *elem);public:	VAVLTree(VAVL *root);			// create with root = 0 (empty tree) or root = VAVL_UNLOADED	virtual ~VAVLTree();			// Standard macht delete_all	virtual Err compare(VAVL *a, VAVL *b, int32 *diff_result) const = 0;	virtual Err compare(VAVL *a, int32 val, int32 *diff_result) const = 0;	virtual Err compare(VAVL *a, void *ptr, int32 *diff_result) const = 0;	Err get_root_lock(VAVL **root);	Err get_first_lock(VAVL **first);	Err get_last_lock(VAVL **last);	Err insert(VAVL *elem);			// Element einhängen	Err remove(VAVL *elem);			// Element ausklinken	Err kill(VAVL *elem);			// Element ausklinken und zerstören	Err search_lock(VAVL *elem, VAVL **result);	Err search_nearest_lock(VAVL *elem, VAVL **result, int8 *direction = (int8 *)0);	Err search_lock(int32 val, VAVL **result);	Err search_nearest_lock(int32 val, VAVL **result, int8 *direction = (int8 *)0);	Err search_lock(void *ptr, VAVL **result);	Err search_nearest_lock(void *ptr, VAVL **result, int8 *direction = (int8 *)0);	Err resort();				// Elemente neu sortieren (z.B. wenn sich compare geändert hat, oder viele Elemente verändert wurden)	void empty_with_removing() {root = 0;};	// empty tree (root = 0), remove elements from tree (but don't delete them)	Err empty_with_killing();				// empty tree (root = 0), remove elements from tree and delete then (kill)	Err unload_all();	// unload all elements (don't remove them from tree!). Afterwards root is 0 or VAVL_UNLOADED (or an error is returned)	void delete_all();	// delete all elements (don' remove them from tree!), changes to elements are lost (no unload!). Afterwards root is 0 or VAVL_UNLOADED.};#endif