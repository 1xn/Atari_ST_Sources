/*----------------------------------------------------------------------------------------	HeapManager.cp, class for allocating memory in bigger native blocks		20.6.2000 by Manfred Lippert, mani@mani.de	last change: 14.9.2001----------------------------------------------------------------------------------------*/#include <HeapManager.h>#include <SysInfo.h>#include <string.h>#if HEAPMANAGER_DEBUG || AVLTREE_DEBUG#include <stdio.h>#endif#if TARGET_TOS#include <gemdos.h>#elif TARGET_MACOS#include <MacMemory.h>#if PPC#include <Multiprocessing.h>#endif#endif#if HEAPMANAGER_DEBUGstatic const uint32 HEAPMANAGER_MAGIC = 'HdBg';typedef struct {	uint32 magic;	char *file;	int32 line;} HeapManagerDebugInfo;#endifconst size_t HEAP_DEFAULT_PAGE_SIZE = 16384L;	// default page size 16 KBHeap heap;	// global Heap for the whole application#if __MWERKS__extern void *operator new(size_t size, void *adr);	// without this, CodeWarrior will not compile ...#if !TARGET_TOS// Replacing new/delete operators (simply call malloc/free - no exceptions!):void *operator new(size_t size) {	return malloc(size);}void *operator new(size_t size, void *adr) {#pragma unused(size)	return adr;}void operator delete(void *adr) {	if (adr) {		free(adr);	}}void *operator new[](size_t size) {	return malloc(size);}void operator delete[](void *adr) {	if (adr) {		free(adr);	}}#endif	// !TARGET_TOS#endif	// __MWERKS__/* Replacing Std-C malloc/free/realloc: */#if HEAPMANAGER_DEBUG#undef malloc#endif#if TARGET_TOSvoid *malloc( __D0(size_t size) ) {#elseextern "C" void *malloc(size_t size);	// don't know why I have to put this here!?!void *malloc(size_t size) {#endif	return heap.alloc(size);}#if TARGET_TOSvoid free( __A0(void *ptr) ) {#elseextern "C" void free(void *ptr);	// don't know why I have to put this here!?!void free(void *ptr) {#endif#if HEAPMANAGER_DEBUG	HeapManagerDebugInfo *info = ((HeapManagerDebugInfo *)ptr) - 1;	if (info->magic == HEAPMANAGER_MAGIC) {		heap.free((void *)info);	} else {		heap.free(ptr);	}#else	heap.free(ptr);#endif}#if TARGET_TOSvoid *realloc( __A0(void *ptr), __D0(size_t newsize) ) {#elseextern "C" void *realloc(void *ptr, size_t newsize);	// don't know why I have to put this here!?!void *realloc(void *ptr, size_t newsize) {#endif	return heap.realloc(ptr, newsize);}#if TARGET_TOSvoid *calloc( __D0(size_t elt_count), __D1(size_t elt_size) ) {#elseextern "C" void *calloc(size_t elt_count, size_t elt_size);	// don't know why I have to put this here!?!void *calloc(size_t elt_count, size_t elt_size) {#endif	size_t size = elt_count * elt_size;	void *adr = heap.alloc(size);	if (adr != 0) {		memset(adr, 0, size);	}	return adr;}#if HEAPMANAGER_DEBUGvoid *debug_malloc(size_t size, char *file, int32 line) {#if TARGET_MACOS	void *adr = std::malloc(size + sizeof(HeapManagerDebugInfo));	// don't know why I have to use std:: here!?!#else	void *adr = malloc(size + sizeof(HeapManagerDebugInfo));#endif	if (adr) {		HeapManagerDebugInfo *info = ((HeapManagerDebugInfo *)adr)++;		info->magic = HEAPMANAGER_MAGIC;		info->file = file;		info->line = line;	}	return adr;}#define malloc(x) debug_malloc(x, __FILE__, __LINE__)#endif/* Routines for native memory allocation: */#if TARGET_MACOSstatic void *Mac_remote_native_alloc(void *size_ptr) {	size_t size = *(size_t *)size_ptr + sizeof(Handle);// Vorne Platz für Handle/* Erst App Heap, dann Temp Mem:	Macht Probleme, weil App Heap schnell voll wird, und dann diverse	andere Routinen Probleme bekommen - z.B. printf(), aber auch Quicktime-Aufrufe usw.	Handle hnd = NewHandle(size);								// Neuer Block	if (hnd == 0 || *hnd == 0) {								// nicht im App Heap geklappt?		OSErr oserr;		hnd = TempNewHandle(size, &oserr);					// mit TempMem versuchen	}*//* Erst Temp Mem, dann App Heap: */	OSErr oserr;	Handle hnd = TempNewHandle((Size)size, &oserr);		// mit TempMem versuchen	if (hnd == 0 || *hnd == 0) {								// nicht geklappt?		if (hnd != 0) {											// aber Master Pointer bekommen			DisposeHandle(hnd);									// Master Pointer freigeben		}		hnd = NewHandle((Size)size);							// mit NewHandle versuchen	}	if (hnd == 0) {												// kein Speicher oder Master Pointer mehr		return 0;													// ERROR	}	if (*hnd == 0) {												// kein Speicher mehr (aber Master Pointer bekommen)		DisposeHandle(hnd);										// Master Pointer freigeben		return 0;													// ERROR	}	HLock(hnd);	*(Handle *)*hnd = hnd;										// Handle vorne merken	return (void *)((uint8 *)*hnd + sizeof(Handle));	// Adresse hinter Handle zurückgeben}static void *Mac_remote_native_free(void *adr) {	DisposeHandle(*(Handle *)((uint8 *)adr - sizeof(Handle)));	return 0;}#endif	// TARGET_MACOSstatic void *native_alloc(size_t size) {#if TARGET_MACOS	if (sysinfo.os_version < 0x910 && sysinfo.mp_support) {		return Mac_remote_call(Mac_remote_native_alloc, &size);	// on < 9.1 systems (with MP): call it remotely	} else {		return Mac_remote_native_alloc(&size);							// up from  Mac OS 9.1/X allocators are MP-safe: call it directly	}#elif TARGET_TOS	return Malloc((int32)size);#else	return ::malloc(size);#endif}static void native_free(void *adr) {#if TARGET_MACOS	if (sysinfo.os_version < 0x910 && sysinfo.mp_support) {		Mac_remote_call(Mac_remote_native_free, adr);				// on < 9.1 versions (with MP): call it remotely	} else {		Mac_remote_native_free(adr);										// up from  Mac OS 9.1/X allocators are MP-safe: call it directly	}#elif TARGET_TOS	Mfree(adr);#else	::free(size);#endif}/****** HeapBlockTree *****************************************************************/HeapBlockTree::~HeapBlockTree() {	// do nothing!	// memory is only allocated by HeapNodes in HeapList}/****** Heap **************************************************************************/Heap::Heap() {	page_size = HEAP_DEFAULT_PAGE_SIZE;}Heap::~Heap() {	while(get_last()) {		kill(get_last());	// own special kill method!!!	}}void Heap::kill(HeapPage *element) {	// special kill method	remove(element);	native_free((void *)element);}void *Heap::alloc(size_t size) {	if (size == 0) {		return 0;	}	void *back = 0;	// return value	critical_region.enter();	HeapPage *heap_page;	HeapBlock *block = free_blocks.search_right_nearest((int32)size);	if (block == 0) {	// cannot find free block - allocate new "page":		size_t min_size = size + sizeof(HeapPage) + sizeof(HeapBlock);	// Platz für HeapPage-Objekt (=Header) und mindestens ein HeapBlock-Objekt		size_t best_size = min_size <= page_size ? page_size : (((min_size - 1) / page_size + 1) * page_size);		size_t alloc_size = best_size;		heap_page = (HeapPage *)native_alloc(alloc_size);		// new heap page with multiple of page_size		if (!heap_page) {			alloc_size = min_size;			heap_page = (HeapPage *)native_alloc(alloc_size);	// new heap page with minimal size		}		if (heap_page) {			heap_page = new((void *)heap_page) HeapPage();	// call constructor			insert(heap_page);		// insert in list			block = (HeapBlock *)(heap_page + 1);			alloc_size -= (sizeof(HeapPage) + sizeof(HeapBlock));			block = new((void *)block) HeapBlock(alloc_size, size, heap_page, TRUE);	// call constructor			heap_page->insert(block);		}	} else {		heap_page = block->get_heap_page();		free_blocks.remove(block);			// remove out of free block tree		block->set_used(TRUE);				// block is used now		block->set_used_size(size);		// set used size	}	if (block) {		size_t used = block->get_used_size();//		used = (used + 1) & ~(size_t)1;	// nur gerade Werte zulassen! (68000 ...)		used = (used + 0x3) & ~(size_t)0x3;	// Alignment to 4-Byte-Boundary!		size_t diff = block->get_real_size();		if (diff > used) {			diff -= used;			if (diff > sizeof(HeapBlock)) {	// neuer freier HeapBlock kann abgespalten werden				HeapBlock *behind = (HeapBlock *)((uint8 *)block->get_data_adr() + used);				block->set_real_size(used);				diff -= sizeof(HeapBlock);				behind = new((void *)behind) HeapBlock(diff, diff, heap_page, FALSE);		// call constructor				heap_page->insert(behind, block, LINK_AFTER);				free_blocks.insert(behind);						// insert into free block tree			}		}		used_blocks.insert(block);			// insert into used block tree		back = block->get_data_adr();		// return value	}#if AVLTREE_DEBUG	if (!free_blocks.debug()) {		printf(">>> ERROR in free_blocks\n");	}	if (!used_blocks.debug()) {		printf(">>> ERROR in used_blocks\n");	}	#endif	critical_region.exit();	return back;}void Heap::free(void *adr) {	if (adr == 0) {		return;	}	critical_region.enter();	HeapBlock *block = ((HeapBlock *)adr - 1);	HeapPage *page = block->get_heap_page();#if HEAPMANAGER_DEBUG	if (!block->is_used()) {		printf("ERROR!!! Called heap.free() for unused HeapBlock!\n");		critical_region.exit();		return;	}#endif	used_blocks.remove(block);	block->set_used(FALSE);	free_blocks.insert(block);	HeapBlock *left = block->Link<HeapBlock>::get_prev();	HeapBlock *right = block->Link<HeapBlock>::get_next();	if (left && !left->is_used()) {		// unit with previous block?		free_blocks.remove(block);			// remove block out of free block tree		page->remove(block);					// remove block out of block list in this page		free_blocks.remove(left);			// remove previous block because the size changes		left->set_real_size(left->get_real_size() + block->get_real_size() + sizeof(HeapBlock));	// increase size of previous block		free_blocks.insert(left);			// re-insert previous block with changed size		block = left;		left = block->Link<HeapBlock>::get_prev();	}	if (right && !right->is_used()) {	// unit with following block?		free_blocks.remove(right);			// remove following block out of free block tree		page->remove(right);					// remove following block out of block list in this page		free_blocks.remove(block);			// remove block because the size changes		block->set_real_size(block->get_real_size() + right->get_real_size() + sizeof(HeapBlock));	// increase size of block		free_blocks.insert(block);			// re-insert block with changed size		right = block->Link<HeapBlock>::get_next();	}	if (left == 0 && right == 0) {	// no more other blocks in this page?		free_blocks.remove(block);		kill(page);				// delete the whole page	}	critical_region.exit();}void *Heap::realloc(void *adr, size_t newsize) {	if (newsize == 0) {		free(adr);		return 0;	}	if (adr == 0) {		return alloc(newsize);	}	critical_region.enter();	HeapBlock *block = ((HeapBlock *)adr - 1);	HeapPage *page = block->get_heap_page();#if HEAPMANAGER_DEBUG	if (!block->is_used()) {		printf("ERROR!!! Called heap.realloc() for unused HeapBlock!\n");		critical_region.exit();		return 0;	}#endif	if (newsize > block->get_used_size()) {							// block grows		if (newsize <= block->get_real_size()) {						// enough place in block			block->set_used_size(newsize);		} else {																	// must resize block			size_t needed = newsize - block->get_real_size();			HeapBlock *right = block->Link<HeapBlock>::get_next();			if (!right || right->is_used() || (right->get_real_size() + sizeof(HeapBlock)) < needed) {	// cannot use following block?				adr = alloc(newsize);										// allocate new block				if (adr) {					memcpy(adr, block->get_data_adr(), block->get_used_size());	// copy data into new block					free(block->get_data_adr());											// free old block				}			} else {																// can use following block				used_blocks.remove(block);									// remove block because its size changes				free_blocks.remove(right);									// remove following block				page->remove(right);											// remove also out of page-list				if (needed < right->get_real_size()) {					// following block can further exist					size_t rest = right->get_real_size() - needed;	// rest size for following block					block->set_real_size(newsize);					block->set_used_size(newsize);					right = (HeapBlock *)((uint8 *)block->get_data_adr() + newsize);	// new position of following block					right = new((void *)right) HeapBlock(rest, rest, page, FALSE);		// call constructor					page->insert(right, block, LINK_AFTER);					free_blocks.insert(right);								// insert following block into free block tree				} else {															// need to remove following block					block->set_real_size(block->get_real_size() + right->get_real_size() + sizeof(HeapBlock));	// use complete space of following block					block->set_used_size(newsize);				}				used_blocks.insert(block);									// re-insert block with changed size			}		}	} else if (newsize < block->get_used_size()) {					// block shrinks		size_t rest = block->get_used_size() - newsize;		block->set_used_size(newsize);		if (rest > sizeof(HeapBlock)) {									// can create new free block			rest -= sizeof(HeapBlock);			used_blocks.remove(block);										// remove block because its size changes			block->set_real_size(newsize);			used_blocks.insert(block);										// re-insert block with changed size			HeapBlock *right = (HeapBlock *)((uint8 *)block->get_data_adr() + newsize);	// new position of following block			right = new((void *)right) HeapBlock(rest, rest, page, FALSE);		// call constructor			page->insert(right, block, LINK_AFTER);			free_blocks.insert(right);										// insert following block into free block tree		}	}		critical_region.exit();	return adr;}#if HEAPMANAGER_DEBUGvoid Heap::debug_get_count(uint32 *free, uint32 *used, uint32 *pages) {	critical_region.enter();	uint32 page_count = 0;	uint32 free_count = 0;	uint32 used_count = 0;	HeapBlock *block;	HeapPage *heap_page = get_first();	while (heap_page) {		block = heap_page->get_first();		while (block) {			if (block->is_used()) {				used_count++;			} else {				free_count++;			}			block = block->Link<HeapBlock>::get_next();		}				page_count++;		heap_page = heap_page->get_next();	}	*free = free_count;	*used = used_count;	*pages = page_count;		critical_region.exit();}boolean Heap::debug_print(boolean list_pages, boolean list_blocks, size_t max_dump_size) {	critical_region.enter();	boolean error = FALSE;	printf("---- HeapManager: ----\n");	HeapPage *heap_page = get_first();	HeapBlock *block, *last;	uint32 page_count = 0;	uint32 count1 = 0, count2 = 0, count3 = 0;	while (heap_page) {		if (list_pages) {			printf("\n** HeapPage at 0x%lx:\n", (long)heap_page);		}		block = heap_page->get_first();		last = 0;		while (block) {			if (list_blocks) {				printf("* HeapBlock at 0x%lx (size %ld, used %ld)\n", (long)block, (long)block->get_real_size(), (long)block->get_used_size());			}			if (block->get_real_size() == 0 || block->get_used_size() == 0) {				if (!list_blocks) {					printf("* HeapBlock at 0x%lx (size %ld, used %ld)\n", (long)block, (long)block->get_real_size(), (long)block->get_used_size());				}				printf(" <<< ERROR! (Size 0)\n");				error = TRUE;			}			if (block->get_heap_page() != heap_page) {				if (!list_blocks) {					printf("* HeapBlock at 0x%lx (size %ld, used %ld)\n", (long)block, (long)block->get_real_size(), (long)block->get_used_size());				}				printf(" <<< ERROR! Wrong page! (0x%lx != 0x%lx)\n", (long)block->get_heap_page(), (long)heap_page);				error = TRUE;			}			if (last && block < last) {				if (!list_blocks) {					printf("* HeapBlock at 0x%lx (size %ld, used %ld)\n", (long)block, (long)block->get_real_size(), (long)block->get_used_size());				}				printf(" <<< ERROR! (0x%lx < 0x%lx)\n", (long)block, (long)last);				error = TRUE;			}			last = block;			block = block->Link<HeapBlock>::get_next();			count1++;		}		page_count++;		heap_page = heap_page->get_next();	}	if (list_blocks) {		printf("\n---- Used Blocks:\n\n");	}	block = used_blocks.get_first();	while (block) {		if (list_blocks) {			printf("* HeapBlock at 0x%lx (size %ld, used %ld)\n", (long)block, (long)block->get_real_size(), (long)block->get_used_size());			HeapManagerDebugInfo *info = (HeapManagerDebugInfo *)block->get_data_adr();			if (info->magic == HEAPMANAGER_MAGIC) {				printf("Allocated in file >>%s<<, line %ld\n", info->file, (long)info->line);			}			if (max_dump_size) {				size_t dump_size = block->get_used_size();				if (dump_size > max_dump_size) {					dump_size = max_dump_size;				}				if (dump_size) {					size_t count = dump_size;											uint8 *dump = (uint8 *)block->get_data_adr();					uint8 c;					printf("\nHex-Dump:\n");					while (count--) {						c = *dump++;						printf("0x%x ", (int)c);					}					count = dump_size;											dump = (uint8 *)block->get_data_adr();					printf("\n\nASCII-Dump:\n");					while (count--) {						c = *dump++;						printf("%c", c >= 32 && c != 127 ? c : '?');					}					printf("\n\n");				}			}		}		block = block->Node<HeapBlock>::get_next();		count2++;	}	if (list_blocks) {		printf("\n---- Free Blocks:\n\n");	}	block = free_blocks.get_first();	while (block) {		if (list_blocks) {			printf("* HeapBlock at 0x%lx (size %ld, used %ld)\n", (long)block, (long)block->get_real_size(), (long)block->get_used_size());		}		block = block->Node<HeapBlock>::get_next();		count3++;	}	printf("\n%ld Pages, %ld Blocks, %ld used, %ld free\n", (long)page_count, (long)count1, (long)count2, (long)count3);	if (count1 != count2 + count3) {		printf("ERROR: %ld != %d\n", (long)count1, (long)(count2 + count3));		error = TRUE;	}	if (error) {		printf("ERROR in HeapManager\n");	} else {		printf("Heap OK\n");	}	printf("----------------------\n");	critical_region.exit();	return !error;}#endif	// HEAPMANGER_DEBUG