/*----------------------------------------------------------------------------------------	HeapManager.h, class for allocating memory in bigger native blocks						replaces malloc/free/new/delete ...		8.7.2000 by Manfred Lippert, mani@mani.de	last change: 24.8.2001----------------------------------------------------------------------------------------*/#ifndef __ManiLibs_HeapManager_h__#define __ManiLibs_HeapManager_h__/*××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××	MP-safe:			yes, if used the standard way (automatically)	MP-callable:	any context (normally hidden by malloc/free/new/delete ...)××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××*/#include <LinkedList.h>#include <AVLTree.h>#include <CriticalRegion.h>#include <stdlib.h>/*Heap heap - global object, should only be one!The HeapPage objects are the (only) native allocated memory blocks andall other objects (the HeapBlocks) are embedded in these blocks.The HeapBlocks are the "virtual" allocated memory blocks.A HeapBlock can be used or unused (=free).If it is used, there can be free space at the end of the block(so the "virtual" block can eventually grow).|HeapPage________________________________________________|         |used HeapBlock___________|free HeapBlock_______|                        |used |free|              |"used"|All HeapPage objects are doubly linked in Heap:	Heap is List<HeapPage> (HeapPage is Link<HeapPage>)All HeapBlock objects in one HeapPage are doubly linked:	HeapPage is List<HeapBlock> (HeapBlock is Link<HeapBlock>)All free HeapBlock objects are organized as AVL tree in Heap:	Heap has HeapBlockTree free_blocks (HeapBlock is Node<HeapBlock>)	HeapBlockTree is Tree<HeapBlock>All used HeapBlock objects are organized as AVL tree in Heap:	Heap has HeapBlockTree used_blocks (HeapBlock is Node<HeapBlock>)	HeapBlockTree is Tree<HeapBlock>Summary:Heap is List<HeapPage>Heap has HeapBlockTree free_blocksHeap has HeapBlockTree used_blocksHeapBlockTree is Tree<HeapBlock>HeapPage is Link<HeapPage> and List<HeapBlock> {HeapBlock is Node<HeapBlock> and Link<HeapBlock>*//****** HeapBlock *********************************************************************/class HeapBlock : public Node<HeapBlock>, public Link<HeapBlock> {	size_t real_size;				// real (data) size	size_t used_size;				// used (data) size	class HeapPage *heap_page;	// the heap page in which this Block is enclosed	boolean used;public:	HeapBlock(size_t real_size, size_t used_size, class HeapPage *heap_page, boolean used) {		this->real_size = real_size;		this->used_size = used_size;		this->heap_page = heap_page;		this->used = used;	};	size_t get_real_size() const {return real_size;};	size_t get_used_size() const {return used_size;};	void set_real_size(size_t size) {real_size = size;};	void set_used_size(size_t size) {used_size = size;};	void *get_data_adr() const {return (void *)(this + 1);};	class HeapPage *get_heap_page() const {return heap_page;};	boolean is_used() const {return used;};	void set_used(boolean used) {this->used = used;};};/****** HeapBlockTree *****************************************************************/class HeapBlockTree : public Tree<HeapBlock> {public:	~HeapBlockTree();	// does nothing	int32 compare(HeapBlock *a, HeapBlock *b) const {		return (int32)(a->get_real_size() - b->get_real_size());	};	int32 compare(HeapBlock *a, int32 val) const {		return (int32)(a->get_real_size() - val);	};/*	int32 compare(HeapBlock *a, void *ptr) const {		(void)a; (void)ptr;		return 0;	};*/	virtual int32 compare(AVL *a, AVL *b) const {		return compare((HeapBlock *)a, (HeapBlock *)b);	};	virtual int32 compare(AVL *a, int32 val) const {		return compare((HeapBlock *)a, val);	};	virtual int32 compare(AVL *a, void *ptr) const {//		return compare((HeapBlock *)a, ptr);		(void)a; (void)ptr;		return 0;	};};/****** HeapPage **********************************************************************/class HeapPage : public Link<HeapPage>, public List<HeapBlock> {};/****** Heap **************************************************************************/class Heap : private List<class HeapPage> {	class HeapBlockTree free_blocks;	// Tree of unused (free) blocks	class HeapBlockTree used_blocks;	// Tree of used blocks	size_t page_size;						// size of prealloced heaps	CriticalRegion critical_region;	// to make it thread-save	void kill(HeapPage *element);		// need special version of kill methodpublic:	Heap();	~Heap();	void *alloc(size_t size);						// allocate memory	void free(void *adr);							// free memory	void *realloc(void *adr, size_t newsize);	// reallocate memory	size_t get_page_size() const {return page_size;};	void set_page_size(size_t size) {page_size = size;};#if HEAPMANAGER_DEBUG	void debug_get_count(uint32 *free, uint32 *used, uint32 *pages);	boolean debug_print(boolean list_pages, boolean list_blocks, size_t max_dump_size);#endif};extern Heap heap;	// global Heap for the whole application#endif