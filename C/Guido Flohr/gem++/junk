# 1 "gema.cc"
 
 
 
 
 
 
 
 
 

# 1 "/usr/lib/g++-include/limits.h" 1 3
 








# 1 "/usr/local/include/compiler.h" 1 3
 
 







 




 















 
 
 
 
 
 
 
		 

 
 
 
 






 






# 71 "/usr/local/include/compiler.h" 3













# 96 "/usr/local/include/compiler.h" 3









# 129 "/usr/local/include/compiler.h" 3


# 146 "/usr/local/include/compiler.h" 3









 
 


















      







# 203 "/usr/local/include/compiler.h" 3






 






 



# 10 "/usr/lib/g++-include/limits.h" 2 3












































 



 



  


 











 	 


































 



















# 11 "gema.cc" 2

# 1 "/usr/local/include/aesbind.h" 1 3


    
# 1 "/usr/local/include/gemfast.h" 1 3








extern "C" {


 

























 

		 












		 










		 


		 



		 





		 





		 
typedef struct pEvntrec
{
	int	ap_evnt;
	long	ap_value;
}EVNTREC;
		
		 









		 



		 
























		 












		 



		 







		 





		 











		 


		
		 




		 



		 




		 



		 



		 



		 


		 


 




typedef struct _mn_set
{
    long Display;     
    long Drag;        
    long Delay;       
    long Speed;       
    short Height;     
} MN_SET;

		 










		 









		 




















		 














		 



		 





























		 





















		 









		 




		 


















    	 



		 








		 





		 


















		 



		 













		 











		 








		 

















		 










		 




		 



		 



		 






		
		 


		 







typedef struct
{



	long		fd_addr;     
                                     
                                     

	short		fd_w;	     
	short		fd_h;        
	short		fd_wdwidth;  
	short		fd_stand;    
	short		fd_nplanes;  
	short		fd_r1;       
	short		fd_r2;       
	short		fd_r3;       
} MFDB;




# 550 "/usr/local/include/gemfast.h" 3


		 
typedef struct mouse_form
	{
	short	mf_xhot;
	short 	mf_yhot;
	short 	mf_nplanes;
	short	mf_bg;
	short 	mf_fg;
	short 	mf_mask[16];
	short 	mf_data[16];
	} MFORM ;

typedef struct mouse_event_type
	{
	int	*x;
	int 	*y;
	int	*b;
	int	*k;
	} Mouse;

typedef struct graphic_rectangle
	{	 
	int g_x;
	int g_y;
	int g_w;
	int g_h;
	} GRECT;

typedef struct vdi_rectangle
	{
	int v_x1;
	int v_y1;
	int v_x2;
	int v_y2;
	} VRECT;

typedef struct orect
{
    	struct orect	*o_link;
	int	o_x;
	int	o_y;
	int	o_w;
	int	o_h;
} ORECT;

typedef struct rect_for_rect_utils
	{	 
	int x;
	int y;
	int w;
	int h;
	} Rect;

typedef struct text_edinfo
	{
	char *te_ptext;			 
	char *te_ptmplt;		 
	char *te_pvalid;		 
	short	te_font;		 
	short	te_junk1; 		 
	short	te_just;		 
	short	te_color; 		 
	short	te_junk2; 		 
	short	te_thickness;		 
	short	te_txtlen;		 
	short	te_tmplen;		 
	} TEDINFO;

typedef struct icon_block
	{
	short	*ib_pmask;
	short	*ib_pdata;
	char 	*ib_ptext;
	short	ib_char;
	short	ib_xchar;
	short	ib_ychar;
	short	ib_xicon;
	short	ib_yicon;
	short	ib_wicon;
	short	ib_hicon;
	short	ib_xtext;
	short	ib_ytext;
	short	ib_wtext;
	short	ib_htext;
	} ICONBLK;

typedef struct bit_block
	{
	char 	*bi_pdata;			 
	short	bi_wb;				 
	short	bi_hl;				 
	short	bi_x;				 
	short	bi_y;				 
	short	bi_color; 			 

	} BITBLK;


typedef struct object
	{
	short	ob_next;	 
	short	ob_head;	 
	short	ob_tail;	 
	unsigned short ob_type;	 
	unsigned short ob_flags; 
	unsigned short ob_state; 
	unsigned long  ob_spec;	 
	short	ob_x;		 
	short	ob_y;		 
	short	ob_width; 	 
	short	ob_height;	 
	} OBJECT;
# 705 "/usr/local/include/gemfast.h" 3


typedef struct parm_block
	{
	OBJECT 	*pb_tree;
	short	pb_obj;
	short	pb_prevstate;
	short	pb_currstate;
	short	pb_x, pb_y, pb_w, pb_h;
	short	pb_xc, pb_yc, pb_wc, pb_hc;
	long 	pb_parm;
	} PARMBLK;

typedef struct user_block
	{



 
	int (*ub_code)(void *parmblock);

	long ub_parm;
	} USERBLK;

						 
typedef struct rshdr
{
	short		rsh_vrsn;
	unsigned short	rsh_object;
	unsigned short	rsh_tedinfo;
	unsigned short	rsh_iconblk;	 
	unsigned short	rsh_bitblk;
	unsigned short	rsh_frstr;	
	unsigned short	rsh_string;
	unsigned short	rsh_imdata;	 
	unsigned short	rsh_frimg;	
	unsigned short	rsh_trindex;
	short		rsh_nobs;	 
	short		rsh_ntree;
	short		rsh_nted;
	short		rsh_nib;
	short		rsh_nbb;
	short		rsh_nstring;
	short		rsh_nimages;
	unsigned short	rsh_rssize;	 
} RSHDR;



 



typedef struct _menu
{
    OBJECT *mn_tree;     
    short   mn_menu;     
    short   mn_item;     
    short   mn_scroll;   














    short   mn_keystate;  

} MENU_T;

typedef MENU_T MENU;


typedef struct
{
        int     m_out;
        int     m_x;
        int     m_y;
        int     m_w;
        int	m_h;
} MOBLK;

typedef struct
{
    int    *contrl;
    int    *global;
    int    *intin;
    int    *intout;
    int    *addrin;
    int    *addrout;
} AESPB;

 
extern short 		_intin[], _intout[], _ptsin[], _ptsout[];
extern AESPB		*aesparams;




extern int		gl_apid, gl_ap_version;


}



# 4 "/usr/local/include/aesbind.h" 2 3






extern "C" {


    
  int	appl_init  (void)  ;
  int	appl_read  (int ApId, int Length, void *ApPbuff)  ;
  int	appl_write  (int ApId, int Length, void *ApPbuff)  ;
  int	appl_find  (const char *Name)  ;
  int	appl_tplay  (void *Mem, int Num, int Scale)  ;
  int	appl_trecord  (void *Mem, int Count)  ;
  int	appl_search  (int mode, char *fname, int *type, int *ap_id)  ;
  int	appl_exit  (void)  ;
  int	appl_getinfo  (int type, int *out1, int *out2, int *out3, int *out4)  ;

  int	evnt_keybd  (void)  ;
  int	evnt_button  (int Clicks, int WhichButton,
				     int WhichState, int *Mx, int *My,
				     int *ButtonState, int *KeyState)  ; 
  int	evnt_mouse  (int EnterExit, int InX, int InY, int InW,
				    int InH, int *OutX, int *OutY, 
				    int *ButtonState, int *KeyState)  ; 
  int	evnt_mesag  (int MesagBuf[])  ;
  int	evnt_timer  (unsigned long Interval)  ;
# 53 "/usr/local/include/aesbind.h" 3

  int	evnt_multi  (int Type, int Clicks, int WhichButton,
				    int WhichState, int EnterExit1, int In1X,
				    int In1Y, int In1W, int In1H,
				    int EnterExit2, int In2X, 
				    int In2Y, int In2W, int In2H,
				    int MesagBuf[],  unsigned long Interval,
				    int *OutX, int *OutY,
				    int *ButtonState, int *KeyState, int *Key,
				    int *ReturnCount)  ;

  int	evnt_dclick  (int ToSet, int SetGet)  ;

  int	form_do  (void *Tree, int StartObj)  ;
  int	form_dial  (int Flag, int Sx, int Sy, int Sw, int Sh,
				   int Bx, int By, int Bw, int Bh)  ;
  int	form_alert  (int DefButton, char *Str)  ;
  int	form_error  (int ErrorCode)  ;
  int	form_center  (void *Tree, int *Cx, int *Cy, int *Cw,
				     int  *Ch)  ; 
  int    form_keybd  (void *Ktree, int Kobject, int Kobnext,
				   int Kchar, int *Knxtobject, int *Knxtchar)  ;
  int	form_button  (void *Btree, int Bobject, int Bclicks,
				     int *Bnxtobj)  ;


  int	fsel_input  (char *Path, char *File, int *ExitButton)  ;
  int	fsel_exinput  (char *Path, char *File, int *ExitButton,
				      char *Prompt)  ;

  int	graf_rubberbox  (int Ix, int Iy, int Iw, int Ih,
					int *Fw, int *Fh)  ;
  int	graf_dragbox  (int Sw, int Sh, int Sx, int Sy, int Bx,
				      int By, int Bw, int Bh, int *Fw, int *Fh)  ; 
  int	graf_movebox  (int Sw, int Sh, int Sx, int Sy, int Dx,
				      int Dy)  ;
  int	graf_growbox  (int Sx, int Sy, int Sw, int Sh, int Fx,
				      int Fy, int Fw, int Fh)  ; 
  int	graf_shrinkbox  (int Fx, int Fy, int Fw, int Fh,
					int Sx, int Sy, int Sw, int Sh)  ; 
  int	graf_watchbox  (void *Tree, int Object, int InState, int OutState)  ;
  int	graf_slidebox  (void *Tree, int Parent, int Object,
				       int Direction)  ; 
  int	graf_handle  (int *Wchar, int *Hchar, int *Wbox, 
				     int *Hbox)  ;
  int	graf_mouse  (int Form, void *FormAddress)  ;
  int	graf_mkstate  (int *Mx, int *My, int *ButtonState,
				      int *KeyState)  ; 

  int	menu_bar  (void *Tree, int ShowFlag)  ;
  int	menu_icheck  (void *Tree, int Item, int CheckFlag)  ;
  int	menu_ienable  (void *Tree, int Item, int EnableFlag)  ;
  int	menu_tnormal  (void *Tree, int Item, int NormalFlag)  ;
  int	menu_text  (void *Tree, int Item, char *Text)  ;
  int	menu_register  (int ApId, char *MenuText)  ;
  int	menu_popup  (MENU_T *me_menu, int me_xpos, int me_ypos,
                                    MENU_T *me_mdata)  ;
  int	menu_attach  (int me_flag, OBJECT *me_tree, int me_item,
                                     MENU_T *me_mdata)  ;
  int	menu_istart  (int me_flag, OBJECT *me_tree,
                                     int me_imenu, int me_item)  ;
  int	menu_settings  (int me_flag, MN_SET *me_values)  ;


  int	objc_add  (void *Tree, int Parent, int Child)  ;
  int	objc_delete  (void *Tree, int Object)  ;
  int	objc_draw  (void *Tree, int Start, int Depth, int Cx,
				   int Cy, int Cw, int Ch)  ;
  int	objc_find  (void *Tree, int Start, int Depth, int Mx,
				   int My)  ;
  int	objc_offset  (void *Tree, int Object, int *X, int *Y)  ;
  int	objc_order  (void *Tree, int Object, int NewPos)  ;




  int	objc_edit  (void *Tree, int Object, int Char, int Index,
				   int Kind, int *NewIndex)  ; 

  int	objc_change  (void *Tree, int Object, int Res, int Cx,
				     int Cy, int Cw, int Ch, int NewState,
				     int Redraw)  ;
  int	objc_sysvar  (int mode, int which, int in1, int in2, int *out1, int *out2)  ;

  int	rsrc_load  (char *Name)  ;
  int	rsrc_free  (void)  ;
  int	rsrc_gaddr  (int Type, int Index, void *Address)  ;
  int	rsrc_saddr  (int Type, int Index, void *Address)  ;
  int	rsrc_obfix  (void *Tree, int Index)  ;
  int	rsrc_rcfix  (void *rc_header)  ;

  int	scrp_read  (char *Scrappath)  ;
  int	scrp_write  (char *Scrappath)  ;
  int	scrp_clear  (void)  ;

  int	shel_read  (char *Command, char *Tail)  ;
  int	shel_write  (int Exit, int Graphic, int Aes,
				    char *Command, char *Tail)  ;
  int	shel_find  (char *buf)  ;
  int	shel_envrn  (char *result, char *param)  ;
  int 	shel_get  (char *Buf, int Len)  ;
  int 	shel_put  (char *Buf, int Len)  ;

  int	wind_create  (int Parts, int Wx, int Wy, int Ww,
				     int Wh)  ; 
  int	wind_open  (int WindowHandle, int Wx, int Wy, int Ww,
				   int Wh)  ;
  int	wind_close  (int WindowHandle)  ;
  int	wind_delete  (int WindowHandle)  ;



  int	wind_get  (int WindowHandle, int What,
				  int *W1, int *W2, int *W3, int *W4)  ; 

  int	wind_set  (int WindowHandle, int What, ...)  ;
  int	wind_find  (int X, int Y)  ;
  int	wind_update  (int Code)  ;
  int	wind_calc  (int Type, int Parts, int InX, int InY, int
				   InW, int InH, int *OutX, int *OutY,
				   int *OutW, int *OutH)  ;  
  void	wind_new  (void)  ;

  int	rc_copy  (GRECT *src, GRECT *dst)  ;
  int	rc_equal  (GRECT *src, GRECT *dst)  ;
  int 	rc_intersect  (GRECT *r1, GRECT *r2)  ;
  int	*grect_to_array  (GRECT *area, int *array)  ;


}



# 12 "gema.cc" 2


# 1 "aesext.h" 1
 
















 




 







# 1 "../config.h" 1
 
 

 
 

 
 

 

 

 


 
 

 
 

 
 

 


 


 
 

 
 

 
 

 
 

 


 
 

 






 

 


 
 

 


 


 


 


 


 


 


 
 

 


 
 

 


 
 

 


 
 

 
 

 
 

 
 

 


 


 
 

 


 


 
 

 


 
 

 


 
 

 


 


 


 


 


 
 

 


 


 


 


 


 


 


 


 


 


 
 

 


 
 

 


 


 


 


 
 

 


 


 
 

 
 

 


 


 
 

 


 


 


 


 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 


# 31 "aesext.h" 2




extern "C" {

# 1 "/usr/local/include/common.h" 1 3
 









 













 













 











 





 


















 
 



extern short 		_intin[255 ], _intout[45 ];
extern short		_ptsin[2 * 1024 ], _ptsout[2 * 6 ];
extern unsigned short	_contrl[12 ], _global[15 ];
extern int		gl_apid, gl_ap_version;
extern void		*_vdiparams[];


 
int __aes__(unsigned long coded_control);

 
void __vdi__(unsigned long coded_contrl, int handle);
void vdi(void);


# 37 "aesext.h" 2


}




# 1 "../system.h" 1
 

















 








# 1 "../config.h" 1
 
 

 
 

 
 

 

 

 


 
 

 
 

 
 

 


 


 
 

 
 

 
 

 
 

 


 
 

 






 

 


 
 

 


 


 


 


 


 


 


 
 

 


 
 

 


 
 

 


 
 

 
 

 
 

 
 

 


 


 
 

 


 


 
 

 


 
 

 


 
 

 


 


 


 


 


 
 

 


 


 


 


 


 


 


 


 


 


 
 

 


 
 

 


 


 


 


 
 

 


 


 
 

 
 

 


 


 
 

 


 


 


 


 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 


# 28 "../system.h" 2




# 1 "/usr/include/stdio.h" 1 3
 













extern "C" {




typedef long unsigned int   size_t;


 















			 









 





 













typedef	struct			 
	{
	long		_cnt;		 
	unsigned char	*_ptr;		 
	unsigned char	*_base;		 
	unsigned int	_flag;		 
	int		_file;		 
	long		_bsiz;		 
	unsigned char	_ch;		 
	}
	FILE;

 
typedef unsigned long fpos_t;

 







extern	FILE	_iob[];

 




 






 

  char *	ctermid	 (char *)  ;




  int	remove	 (const char *)  ;
  int	rename	 (const char *, const char *)  ;
  char *	tmpnam	 (char *)  ;
  FILE *	tmpfile	 (void)  ;

  int	fclose	 (FILE *)  ;
  int	fflush	 (FILE *)  ;

  FILE *	fopen	 (const char *, const char *)  ;
  FILE *	freopen	 (const char *, const char *, FILE *)  ;

  void	setbuf	 (FILE *, char *)  ;
  int	setvbuf	 (FILE *, char *, int, size_t)  ;






  int  fscanf   (FILE *, const char *, ...)  ;
  int  scanf    (const char *, ...)  ;
  int  sscanf   (const char *, const char *, ...)  ;


  int	fprintf	 (FILE *, const char *, ...)  ;
  int	printf	 (const char *, ...)  ;
  int	sprintf	 (char *, const char *, ...)  ;

  int 	vfprintf  (FILE *, const char *, void * )  ;
  int 	vprintf	  (const char *, void * )  ;
  int 	vsprintf  (char *, const char *, void * )  ;

  int	vscanf   (const char *, void * )  ;
  int	vfscanf  (FILE *, const char *, void * )  ;
  int	vsscanf	 (const char *, const char *, void * )  ;


  int	fgetc	 (FILE *)  ;
  char	*fgets	 (char *, int, FILE *)  ;
  char	*gets	 (char *)  ;
  int	fputc	 (int c, FILE *)  ;
  int	fputs	 (const char *, FILE *)  ;
  int	puts	 (const char *)  ;

  size_t	fread	 (void *, size_t, size_t, FILE *)  ;
  size_t	fwrite	 (const void *, size_t, size_t, FILE *)  ;

  int	fgetpos	 (FILE *, fpos_t *)  ;
  int	fsetpos	 (FILE *, fpos_t *)  ;

  int	fseek	 (FILE *, long, int)  ;
  long	ftell	 (FILE *)  ;
  void	rewind	 (FILE *)  ;

  void	perror	 (const char *)  ;


  FILE	*fdopen	 (int, const char *)  ;


  FILE *	fopenp	 (const char *, const char *)  ;
  int 	fungetc	 (int, FILE *)  ;
  int	pclose	 (FILE *)  ;
  FILE *	popen	 (const char *, const char *)  ;
  void	setlinebuf	 (FILE *)  ;

  void	_binmode	 (int)  ;		 
  long 	getl	 (FILE *)  ;
  long 	putl	 (long, FILE *)  ;
  short 	getw	 (FILE *)  ;
  short 	putw	 (short, FILE *)  ;
  void	_getbuf	 (FILE *fp)  ;





 

  int	_filbuf	 (FILE *)  ;	 



# 204 "/usr/include/stdio.h" 3











}



# 32 "../system.h" 2



















 


# 1 "/usr/include/locale.h" 1 3
 












extern "C" {













struct lconv {
        char    *decimal_point;
        char    *thousands_sep;
        char    grouping;
        char    *int_curr_symbol;
        char    *currency_symbol;
        char    *mon_decimal_point;
        char    *mon_thousands_sep;
        char    mon_grouping;
        char    *positive_sign;
        char    *negative_sign;
        char    int_frac_digits;
        char    frac_digits;
        char    p_cs_precedes;
        char    p_sep_by_space;
        char    n_cs_precedes;
        char    n_sep_by_space;
        char    p_sign_posn;
        char    n_sign_posn;
};

  char *		setlocale   (int category, const char *locale)  ;
 

  struct lconv *	localeconv  (void)  ;


}



# 54 "../system.h" 2



 



















# 90 "../system.h"


 




# 1 "/usr/include/errno.h" 1 3








extern "C" {









































					 




























					 
















 






































extern	int	errno;
extern	int	sys_nerr;
extern	char *	sys_errlist[];



}



# 97 "../system.h" 2






# 1 "/usr/include/fcntl.h" 1 3
 











extern "C" {







 












 










 







 













struct flock {
	short l_type;



	short l_whence;
	long l_start;
	long l_len;
	short l_pid;
};


 


 
 









  int	creat	 (const char *, unsigned)  ;
  int	fcntl	 (int f, int cmd, ...)  ;
  int	open	 (const char *, int, ...)  ;


}





# 103 "../system.h" 2






 

 












 










 







 



extern "C" {

 
extern char* basename  (const char* name)  ;
extern int dos2unx  (const char* dos, char* unx)  ;
extern char* findfile  (const char* fname, const char* fpath, 
    char const * const *fext)  ;
extern int _path_dos2unx  (const char* dos, char* unx)  ;
extern int _path_unx2dos  (const char* unx, char* dos)  ;
extern int unx2dos  (const char* unx, char* dos)  ;
extern void* xcalloc  (size_t bytes, size_t size)  ;
extern void* xmalloc  (size_t bytes)  ;
extern void* xrealloc  (void* ptr, size_t bytes)  ;


}


# 44 "aesext.h" 2



extern "C" {







extern int appl_getinfo  (int type, int* out1, int* out2, int* out3, int* out4)  ;



int get_cookie  (long int cookie, long int* value)  ;



}


 





























































 




























 























































 
 


















 



























 





















 










# 14 "gema.cc" 2

# 1 "gemfb.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 




 


enum GEMfeedback { EndInteraction, ContinueInteraction, RedrawMe, RedrawMyParent, IgnoredEvent };


# 15 "gema.cc" 2

# 1 "geme.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 




# 1 "bool.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 





# 1 "../config.h" 1
 
 

 
 

 
 

 

 

 


 
 

 
 

 
 

 


 


 
 

 
 

 
 

 
 

 


 
 

 






 

 


 
 

 


 


 


 


 


 


 


 
 

 


 
 

 


 
 

 


 
 

 
 

 
 

 
 

 


 


 
 

 


 


 
 

 


 
 

 


 
 

 


 


 


 


 


 
 

 


 


 


 


 


 


 


 


 


 


 
 

 


 
 

 


 


 


 


 
 

 


 


 
 

 
 

 


 


 
 

 


 


 


 


 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 


# 27 "bool.h" 2



 
# 41 "bool.h"



# 19 "geme.h" 2




class GEMevent
{
	int ev_which;
	int btn_clicks, btn_state, btn_mask, btn_not;
	int rf[2];
	int r[2][4];
	int msg[32];
	int interval;
	int mx, my, btn;
	int meta, key, clicks;

public:
	GEMevent ();
	GEMevent (int x, int y, int button = 1, int clicks = 1);
	GEMevent (int key);

	void Get (int ev_flags);  

	void Which (int w) { ev_which = w; }  

	void Button (int mask, int state, bool not=false)	{ btn_mask=mask; btn_state=state; btn_not=not; }
	void Rectangle1 (int x, int y, int w, int h, bool out_not_in)	{ rf[0]=out_not_in; r[0][0]=x; r[0][1]=y; r[0][2]=w; r[0][3]=h; }
	void Rectangle2 (int x, int y, int w, int h, bool out_not_in)	{ rf[1]=out_not_in; r[1][0]=x; r[1][1]=y; r[1][2]=w; r[1][3]=h; }
	void Rectangle (int x, int y, int w, int h, bool out_not_in, int R=1)	{ rf[R-1]=out_not_in; r[R-1][0]=x; r[R-1][1]=y; r[R-1][2]=w; r[R-1][3]=h; }
	void Interval (int i)	{ interval=i; }
	int Interval () const		{ return interval; }

	bool Keyboard () const	{ return !!(ev_which& 0x0001 ); }
	bool Button () const		{ return !!(ev_which& 0x0002 ); }
	bool Rectangle1 () const	{ return !!(ev_which& 0x0004 ); }
	bool Rectangle2 () const	{ return !!(ev_which& 0x0008 ); }
	bool Rectangle () const	{ return !!(ev_which&(0x0004 | 0x0008 )); }
	bool Message () const	{ return !!(ev_which& 0x0010 ); }
	bool Timer () const		{ return !!(ev_which& 0x0020 ); }

	bool OutNotIn (int rect=1) const   { return rf[rect-1]; }

	int X () const			{ return mx; }
	int Y () const			{ return my; }

	int Message (int i) const	{ return msg[i]; }
	int Button (int b) const	{ return btn&(1<<b); }
	int Clicks () const		{ return clicks; }
	int Meta () const		{ return meta; }
	int Key () const			{ return key; }
};


# 16 "gema.cc" 2

# 1 "gempa.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 






class GEMpanarea
{
public:
	GEMpanarea();
	GEMpanarea(int visiblelines, int totallines, int visiblecolumns, int totalcolumns);
	virtual ~GEMpanarea();

	virtual void SetVisibleLines(int noOfLines);
	virtual void SetTotalLines(int noOfLines);
	virtual void SetTopLine(int noOfLine);
	virtual void SetVisibleColumns(int noOfColumns);
	virtual void SetTotalColumns(int noOfColumns);
	virtual void SetLeftColumn(int noOfColumn);

	int TotalLines() const { return totalLines; }
	int TotalColumns() const { return totalColumns; }

	int VisibleLines() const { return visibleLines; }
	int VisibleColumns() const { return visibleColumns; }

	int TopLine() const { return actualTopLine; }
	int LeftColumn() const { return actualLeftColumn; }

	void LineUp();
	void LineDown();
	void PageUp();
	void PageDown();
	virtual int VPageAmount();
	virtual int VLineAmount();
	
	void ColumnLeft();
	void ColumnRight();
	void PageLeft();
	void PageRight();
	virtual int HPageAmount();
	virtual int HColumnAmount();

	void VGetScaledValue(int scale, int& size, int& position);
	void HGetScaledValue(int scale, int& size, int& position);

private:
	int actualTopLine,actualLeftColumn;
	int visibleLines,visibleColumns;
	int totalLines,totalColumns;
};



# 17 "gema.cc" 2

# 1 "gemw.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 















# 1 "grect.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 




# 1 "/usr/lib/g++-include/iostream.h" 1 3
 

























#pragma interface



# 1 "/usr/lib/g++-include/streambuf.h" 1 3
 


























#pragma interface


   



extern "C" {
# 1 "/usr/lib/g++-include/libio.h" 1 3
 























 




# 1 "/usr/lib/g++-include/_G_config.h" 1 3
  







typedef unsigned long _G_clock_t;
typedef unsigned short _G_dev_t;
typedef unsigned long _G_fpos_t;
typedef unsigned short _G_gid_t;
typedef unsigned long _G_ino_t;
typedef unsigned short _G_mode_t;
typedef short _G_nlink_t;
typedef long _G_off_t;
typedef int _G_pid_t;



typedef long int _G_ptrdiff_t;
typedef int   _G_sigset_t;



typedef long unsigned int _G_size_t;
typedef long _G_time_t;
typedef unsigned short _G_uid_t;
typedef short unsigned int _G_wchar_t;
typedef int   _G_ssize_t;
typedef int   _G_wint_t;
typedef void * _G_va_list;




typedef          int   _G_int8_t __attribute__((__mode__(__QI__)));
typedef unsigned int  _G_uint8_t __attribute__((__mode__(__QI__)));
typedef          int  _G_int16_t __attribute__((__mode__(__HI__)));
typedef unsigned int _G_uint16_t __attribute__((__mode__(__HI__)));
typedef          int  _G_int32_t __attribute__((__mode__(__SI__)));
typedef unsigned int _G_uint32_t __attribute__((__mode__(__SI__)));
typedef          int  _G_int64_t __attribute__((__mode__(__DI__)));
typedef unsigned int _G_uint64_t __attribute__((__mode__(__DI__)));


































# 30 "/usr/lib/g++-include/libio.h" 2 3













# 51 "/usr/lib/g++-include/libio.h" 3




# 1 "/usr/include/sys/cdefs.h" 1 3
 
















































 






















# 98 "/usr/include/sys/cdefs.h" 3


 















 






# 55 "/usr/lib/g++-include/libio.h" 2 3










 




































 























 

















 

struct _IO_jump_t;  struct _IO_FILE;

struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;
   

   
  int _pos;
# 164 "/usr/lib/g++-include/libio.h" 3

};

struct _IO_FILE {
  int _flags;		 


   
   
  char* _IO_read_ptr;	 
  char* _IO_read_end;	 
  char* _IO_read_base;	 
  char* _IO_write_base;	 
  char* _IO_write_ptr;	 
  char* _IO_write_end;	 
  char* _IO_buf_base;	 
  char* _IO_buf_end;	 
   
  char *_IO_save_base;  
  char *_IO_backup_base;   
  char *_IO_save_end;  

  struct _IO_marker *_markers;
  
  struct _IO_FILE *_chain;
  
  int _fileno;
  int _blksize;
  _G_off_t  _offset;
  

   
  unsigned short _cur_column;
  char _unused;
  char _shortbuf[1];
  
   
};





struct _IO_FILE_plus;
extern struct _IO_FILE_plus _IO_stdin_, _IO_stdout_, _IO_stderr_;





extern "C" {


extern int __underflow  (_IO_FILE*)  ;
extern int __uflow  (_IO_FILE*)  ;
extern int __overflow  (_IO_FILE*, int)  ;

















 



extern int _IO_vfscanf  (_IO_FILE*, const char*, _G_va_list , int*)  ;
extern int _IO_vfprintf  (_IO_FILE*, const char*, _G_va_list )  ;
extern _G_ssize_t  _IO_padn  (_IO_FILE *, int, _G_ssize_t )  ;
extern _G_size_t  _IO_sgetn  (_IO_FILE *, void*, _G_size_t )  ;

extern _G_fpos_t  _IO_seekoff  (_IO_FILE*, _G_off_t , int, int)  ;
extern _G_fpos_t  _IO_seekpos  (_IO_FILE*, _G_fpos_t , int)  ;

extern void _IO_free_backup_area  (_IO_FILE*)  ;


}



# 36 "/usr/lib/g++-include/streambuf.h" 2 3

}
 






















extern "C++" {
class istream;  
class ostream; class streambuf;

 



typedef _G_off_t  streamoff;
typedef _G_fpos_t  streampos;
typedef _G_ssize_t  streamsize;

typedef unsigned long __fmtflags;
typedef unsigned char __iostate;

struct _ios_fields
{  
    streambuf *_strbuf;
    ostream* _tie;
    int _width;
    __fmtflags _flags;
    short  _fill;
    __iostate _state;
    __iostate _exceptions;
    int _precision;

    void *_arrays;  
};















# 115 "/usr/lib/g++-include/streambuf.h" 3


class ios : public _ios_fields {
  ios& operator=(ios&);   
  ios (const ios&);  
  public:
    typedef __fmtflags fmtflags;
    typedef int iostate;
    typedef int openmode;
    typedef int streamsize;
    enum io_state {
	goodbit = 0 ,
	eofbit = 1 ,
	failbit = 2 ,
	badbit = 4  };
    enum open_mode {
	in = 1 ,
	out = 2 ,
	ate = 4 ,
	app = 8 ,
	trunc = 16 ,
	nocreate = 32 ,
	noreplace = 64 ,
	bin = 128 ,  
	binary = 128  };
    enum seek_dir { beg, cur, end};
     
     
    enum { skipws= 01 ,
	   left= 02 , right= 04 , internal= 010 ,
	   dec= 020 , oct= 040 , hex= 0100 ,
	   showbase= 0200 , showpoint= 0400 ,
	   uppercase= 01000 , showpos= 02000 ,
	   scientific= 04000 , fixed= 010000 ,
	   unitbuf= 020000 , stdio= 040000 



	   };
    enum {  
	basefield=dec+oct+hex,
	floatfield = scientific+fixed,
	adjustfield = left+right+internal
    };

# 168 "/usr/lib/g++-include/streambuf.h" 3


    ostream* tie() const { return _tie; }
    ostream* tie(ostream* val) { ostream* save=_tie; _tie=val; return save; }

     
    short  fill() const { return (short )_fill; }
    short  fill(short  newf)
	{short  oldf = (short )_fill; _fill = (char)newf; return oldf;}
    fmtflags flags() const { return _flags; }
    fmtflags flags(fmtflags new_val) {
	fmtflags old_val = _flags; _flags = new_val; return old_val; }
    int precision() const { return _precision; }
    int precision(int newp) {
	unsigned short oldp = _precision; _precision = (unsigned short)newp;
	return oldp; }
    fmtflags setf(fmtflags val) {
	fmtflags oldbits = _flags;
	_flags |= val; return oldbits; }
    fmtflags setf(fmtflags val, fmtflags mask) {
	fmtflags oldbits = _flags;
	_flags = (_flags & ~mask) | (val & mask); return oldbits; }
    fmtflags unsetf(fmtflags mask) {
	fmtflags oldbits = _flags;
	_flags &= ~mask; return oldbits; }
    int width() const { return _width; }
    int width(int val) { int save = _width; _width = val; return save; }




    void _throw_failure() const { }

    void clear(iostate state = 0) {
	_state = _strbuf ? state : state|badbit;
	if (_state & _exceptions) _throw_failure(); }
    void set(iostate flag) { _state |= flag;
	if (_state & _exceptions) _throw_failure(); }
    void setstate(iostate flag) { _state |= flag;  
	if (_state & _exceptions) _throw_failure(); }
    int good() const { return _state == 0; }
    int eof() const { return _state & ios::eofbit; }
    int fail() const { return _state & (ios::badbit|ios::failbit); }
    int bad() const { return _state & ios::badbit; }
    iostate rdstate() const { return _state; }
    operator void*() const { return fail() ? (void*)0 : (void*)(-1); }
    int operator!() const { return fail(); }
    iostate exceptions() const { return _exceptions; }
    void exceptions(iostate enable) {
	_exceptions = enable;
	if (_state & _exceptions) _throw_failure(); }

    streambuf* rdbuf() const { return _strbuf; }
    streambuf* rdbuf(streambuf *_s) {
      streambuf *_old = _strbuf; _strbuf = _s; clear (); return _old; }

    static int sync_with_stdio(int on);
    static void sync_with_stdio() { sync_with_stdio(1); }
    static fmtflags bitalloc();
    static int xalloc();
    void*& pword(int);
    void* pword(int) const;
    long& iword(int);
    long iword(int) const;









     
    class Init {
    public:
      Init () { }
    };

  protected:
    inline ios(streambuf* sb = 0, ostream* tie_to = 0);
    inline virtual ~ios();
    inline void init(streambuf* sb, ostream* tie = 0);
};




typedef ios::seek_dir _seek_dir;


 
 
 
 
 

 
 
class streammarker : private _IO_marker {
    friend class streambuf;
    void set_offset(int offset) { _pos = offset; }
  public:
    streammarker(streambuf *sb);
    ~streammarker();
    int saving() { return  1; }
    int delta(streammarker&);
    int delta();
};

struct streambuf : public _IO_FILE {  
    friend class ios;
    friend class istream;
    friend class ostream;
    friend class streammarker;
    const void *&_vtable() { return *(const void**)((_IO_FILE*)this + 1); }
  protected:
    static streambuf* _list_all;  
    _IO_FILE*& xchain() { return _chain; }
    void _un_link();
    void _link_in();
    char* gptr() const
      { return _flags  & 0x100  ? _IO_save_base : _IO_read_ptr; }
    char* pptr() const { return _IO_write_ptr; }
    char* egptr() const
      { return _flags  & 0x100  ? _IO_save_end : _IO_read_end; }
    char* epptr() const { return _IO_write_end; }
    char* pbase() const { return _IO_write_base; }
    char* eback() const
      { return _flags  & 0x100  ? _IO_save_base : _IO_read_base;}
    char* base() const { return _IO_buf_base; }
    char* ebuf() const { return _IO_buf_end; }
    int blen() const { return _IO_buf_end - _IO_buf_base; }
    void xput_char(char c) { *_IO_write_ptr++ = c; }
    int xflags() { return _flags ; }
    int xflags(int f) {int fl = _flags ; _flags  = f; return fl;}
    void xsetflags(int f) { _flags  |= f; }
    void xsetflags(int f, int mask)
      { _flags  = (_flags  & ~mask) | (f & mask); }
    void gbump(int n)
      { _flags  & 0x100  ? (_IO_save_base+=n):(_IO_read_ptr+=n);}
    void pbump(int n) { _IO_write_ptr += n; }
    void setb(char* b, char* eb, int a=0);
    void setp(char* p, char* ep)
      { _IO_write_base=_IO_write_ptr=p; _IO_write_end=ep; }
    void setg(char* eb, char* g, char *eg) {
      if (_flags  & 0x100 ) _IO_free_backup_area(this); 
      _IO_read_base = eb; _IO_read_ptr = g; _IO_read_end = eg; }
    char *shortbuf() { return _shortbuf; }

    int in_backup() { return _flags & 0x100 ; }
     
    char *Gbase() { return in_backup() ? _IO_save_base : _IO_read_base; }
     
    char *eGptr() { return in_backup() ? _IO_save_end : _IO_read_end; }
     
    char *Bbase() { return in_backup() ? _IO_read_base : _IO_save_base; }
    char *Bptr() { return _IO_backup_base; }
     
    char *eBptr() { return in_backup() ? _IO_read_end : _IO_save_end; }
    char *Nbase() { return _IO_save_base; }
    char *eNptr() { return _IO_save_end; }
    int have_backup() { return _IO_save_base != (0)  ; }
    int have_markers() { return _markers != (0)  ; }
    void free_backup_area();
    void unsave_markers();  
    int put_mode() { return _flags & 0x800 ; }
    int switch_to_get_mode();
    
    streambuf(int flags=0);
  public:
    static int flush_all();
    static void flush_all_linebuffered();  
    virtual ~streambuf();
    virtual int overflow(int c = (-1) );  
    virtual int underflow();  
    virtual int uflow();  
    virtual int pbackfail(int c);
 
    virtual streamsize xsputn(const char* s, streamsize n);
    virtual streamsize xsgetn(char* s, streamsize n);
    virtual streampos seekoff(streamoff, _seek_dir, int mode=ios::in|ios::out);
    virtual streampos seekpos(streampos pos, int mode = ios::in|ios::out);

    streampos pubseekoff(streamoff o, _seek_dir d, int mode=ios::in|ios::out)
      { return _IO_seekoff (this, o, d, mode); }
    streampos pubseekpos(streampos pos, int mode = ios::in|ios::out)
      { return _IO_seekpos (this, pos, mode); }
    streampos sseekoff(streamoff, _seek_dir, int mode=ios::in|ios::out);
    streampos sseekpos(streampos pos, int mode = ios::in|ios::out);
    virtual streambuf* setbuf(char* p, int len);
    virtual int sync();
    virtual int doallocate();

    int seekmark(streammarker& mark, int delta = 0);
    int sputbackc(char c);
    int sungetc();
    int unbuffered() { return _flags & 2  ? 1 : 0; }
    int linebuffered() { return _flags & 0x200  ? 1 : 0; }
    void unbuffered(int i)
	{ if (i) _flags |= 2 ; else _flags &= ~2 ; }
    void linebuffered(int i)
	{ if (i) _flags |= 0x200 ; else _flags &= ~0x200 ; }
    int allocate() {  
	if (base() || unbuffered()) return 0;
	else return doallocate(); }
     
    void allocbuf() { if (base() == (0)  ) doallocbuf(); }
    void doallocbuf();
    int in_avail() { return _IO_read_end - _IO_read_ptr; }
    int out_waiting() { return _IO_write_ptr - _IO_write_base; }
    streamsize sputn(const char* s, streamsize n) { return xsputn(s, n); }
    streamsize padn(char pad, streamsize n) { return _IO_padn(this, pad, n); }
    streamsize sgetn(char* s, streamsize n) { return _IO_sgetn(this, s, n); }
    int ignore(int);
    int get_column();
    int set_column(int);
    long sgetline(char* buf, _G_size_t  n, char delim, int putback_delim);
    int sputc(int c) { return (((  this )->_IO_write_ptr >= (  this )->_IO_write_end) ? __overflow(  this , (unsigned char)( c )) : (unsigned char)(*(  this )->_IO_write_ptr++ = ( c ))) ; }
    int sbumpc() { return (( this )->_IO_read_ptr >= ( this )->_IO_read_end ? __uflow( this ) : *(unsigned char*)( this )->_IO_read_ptr++) ; }
    int sgetc() { return (( this )->_IO_read_ptr >= ( this )->_IO_read_end && __underflow( this ) == (-1)  ? (-1)  : *(unsigned char*)( this )->_IO_read_ptr) ; }
    int snextc() {
	if (_IO_read_ptr >= _IO_read_end && __underflow(this) == (-1) )
	  return (-1) ;
	else return _IO_read_ptr++, sgetc(); }
    void stossc() { if (_IO_read_ptr < _IO_read_end) _IO_read_ptr++; }
    int vscan(char const *fmt0, _G_va_list  ap, ios* stream = (0)  );
    int scan(char const *fmt0 ...);
    int vform(char const *fmt0, _G_va_list  ap);
    int form(char const *fmt0 ...);




    virtual streamsize sys_read(char* buf, streamsize size);
    virtual streamsize sys_write(const char*, streamsize);
    virtual streampos sys_seek(streamoff, _seek_dir);
    virtual int sys_close();
    virtual int sys_stat(void*);  
};

 
 

class filebuf : public streambuf {
  protected:
    void init();
  public:
    static const int openprot;  
    filebuf();
    filebuf(int fd);
    filebuf(int fd, char* p, int len);



    ~filebuf();
    filebuf* attach(int fd);
    filebuf* open(const char *filename, const char *mode);
    filebuf* open(const char *filename, ios::openmode mode, int prot = 0664);
    virtual int underflow();
    virtual int overflow(int c = (-1) );
    int is_open() const { return _fileno >= 0; }
    int fd() const { return is_open() ? _fileno : (-1) ; }
    filebuf* close();
    virtual int doallocate();
    virtual streampos seekoff(streamoff, _seek_dir, int mode=ios::in|ios::out);
    virtual streambuf* setbuf(char* p, int len);
    streamsize xsputn(const char* s, streamsize n);
    streamsize xsgetn(char* s, streamsize n);
    virtual int sync();
  protected:  
 
    int is_reading() { return eback() != egptr(); }
    char* cur_ptr() { return is_reading() ?  gptr() : pptr(); }
     
    char* file_ptr() { return eGptr(); }
     
    virtual streamsize sys_read(char* buf, streamsize size);
    virtual streampos sys_seek(streamoff, _seek_dir);
    virtual streamsize sys_write(const char*, streamsize);
    virtual int sys_stat(void*);  
    virtual int sys_close();




};

inline void ios::init(streambuf* sb, ostream* tie_to) {
		_state = sb ? ios::goodbit : ios::badbit; _exceptions=0;
		_strbuf=sb; _tie = tie_to; _width=0; _fill=' ';

		_flags=ios::skipws|ios::dec;



		_precision=6; _arrays = 0; }

inline ios::ios(streambuf* sb, ostream* tie_to) { init(sb, tie_to); }

inline ios::~ios() {



    if (_arrays) delete [] _arrays;
}
}  

# 31 "/usr/lib/g++-include/iostream.h" 2 3


extern "C++" {
class istream; class ostream;
typedef ios& (*__manip)(ios&);
typedef istream& (*__imanip)(istream&);
typedef ostream& (*__omanip)(ostream&);

extern istream& ws(istream& ins);
extern ostream& flush(ostream& outs);
extern ostream& endl(ostream& outs);
extern ostream& ends(ostream& outs);

class ostream : virtual public ios
{
     
    void do_osfx();
  public:
    ostream() { }
    ostream(streambuf* sb, ostream* tied= (0)  );
    int opfx() {
	if (!good()) return 0; else { if (_tie) _tie->flush(); return 1;} }
    void osfx() { if (flags() & (ios::unitbuf|ios::stdio))
		      do_osfx(); }
    ostream& flush();
    ostream& put(char c) { _strbuf->sputc(c); return *this; }





    ostream& write(const char *s, streamsize n);
    ostream& write(const unsigned char *s, streamsize n)
      { return write((const char*)s, n);}
    ostream& write(const signed char *s, streamsize n)
      { return write((const char*)s, n);}
    ostream& write(const void *s, streamsize n)
      { return write((const char*)s, n);}
    ostream& seekp(streampos);
    ostream& seekp(streamoff, _seek_dir);
    streampos tellp();
    ostream& form(const char *format ...);
    ostream& vform(const char *format, _G_va_list  args);

    ostream& operator<<(char c);
    ostream& operator<<(unsigned char c) { return (*this) << (char)c; }
    ostream& operator<<(signed char c) { return (*this) << (char)c; }
    ostream& operator<<(const char *s);
    ostream& operator<<(const unsigned char *s)
	{ return (*this) << (const char*)s; }
    ostream& operator<<(const signed char *s)
	{ return (*this) << (const char*)s; }
    ostream& operator<<(const void *p);
    ostream& operator<<(int n);
    ostream& operator<<(unsigned int n);
    ostream& operator<<(long n);
    ostream& operator<<(unsigned long n);

    ostream& operator<<(long long n);
    ostream& operator<<(unsigned long long n);

    ostream& operator<<(short n) {return operator<<((int)n);}
    ostream& operator<<(unsigned short n) {return operator<<((unsigned int)n);}

    ostream& operator<<(bool b) { return operator<<((int)b); }

    ostream& operator<<(double n);
    ostream& operator<<(float n) { return operator<<((double)n); }



    ostream& operator<<(__omanip func) { return (*func)(*this); }
    ostream& operator<<(__manip func) {(*func)(*this); return *this;}
    ostream& operator<<(streambuf*);



};

class istream : virtual public ios
{
     
protected:
    _G_size_t  _gcount;

    int _skip_ws();
  public:
    istream() { _gcount = 0; }
    istream(streambuf* sb, ostream*tied= (0)  );
    istream& get(char* ptr, int len, char delim = '\n');
    istream& get(unsigned char* ptr, int len, char delim = '\n')
	{ return get((char*)ptr, len, delim); }
    istream& get(char& c);
    istream& get(unsigned char& c) { return get((char&)c); }
    istream& getline(char* ptr, int len, char delim = '\n');
    istream& getline(unsigned char* ptr, int len, char delim = '\n')
	{ return getline((char*)ptr, len, delim); }
    istream& get(signed char& c)  { return get((char&)c); }
    istream& get(signed char* ptr, int len, char delim = '\n')
	{ return get((char*)ptr, len, delim); }
    istream& getline(signed char* ptr, int len, char delim = '\n')
	{ return getline((char*)ptr, len, delim); }
    istream& read(char *ptr, streamsize n);
    istream& read(unsigned char *ptr, streamsize n)
      { return read((char*)ptr, n); }
    istream& read(signed char *ptr, streamsize n)
      { return read((char*)ptr, n); }
    istream& read(void *ptr, streamsize n)
      { return read((char*)ptr, n); }
    istream& get(streambuf& sb, char delim = '\n');
    istream& gets(char **s, char delim = '\n');
    int ipfx(int need = 0) {
	if (!good()) { set(ios::failbit); return 0; }
	else {
	  if (_tie && (need == 0 || rdbuf()->in_avail() < need)) _tie->flush();
	  if (!need && (flags() & ios::skipws)) return _skip_ws();
	  else return 1;
	}
    }
    int ipfx0() {  
	if (!good()) { set(ios::failbit); return 0; }
	else {
	  if (_tie) _tie->flush();
	  if (flags() & ios::skipws) return _skip_ws();
	  else return 1;
	}
    }
    int ipfx1() {  
	if (!good()) { set(ios::failbit); return 0; }
	else {
	  if (_tie && rdbuf()->in_avail() == 0) _tie->flush();
	  return 1;
	}
    }
    void isfx() { }
    int get() { if (!ipfx1()) return (-1) ;
		else { int ch = _strbuf->sbumpc();
		       if (ch == (-1) ) set(ios::eofbit);
		       return ch;
		     } }
    int peek();
    _G_size_t  gcount() { return _gcount; }
    istream& ignore(int n=1, int delim = (-1) );
    int sync ();
    istream& seekg(streampos);
    istream& seekg(streamoff, _seek_dir);
    streampos tellg();
    istream& putback(char ch) {
	if (good() && _strbuf->sputbackc(ch) == (-1) ) clear(ios::badbit);
	return *this;}
    istream& unget() {
	if (good() && _strbuf->sungetc() == (-1) ) clear(ios::badbit);
	return *this;}
    istream& scan(const char *format ...);
    istream& vscan(const char *format, _G_va_list  args);






    istream& operator>>(char*);
    istream& operator>>(unsigned char* p) { return operator>>((char*)p); }
    istream& operator>>(signed char*p) { return operator>>((char*)p); }
    istream& operator>>(char& c);
    istream& operator>>(unsigned char& c) {return operator>>((char&)c);}
    istream& operator>>(signed char& c) {return operator>>((char&)c);}
    istream& operator>>(int&);
    istream& operator>>(long&);

    istream& operator>>(long long&);
    istream& operator>>(unsigned long long&);

    istream& operator>>(short&);
    istream& operator>>(unsigned int&);
    istream& operator>>(unsigned long&);
    istream& operator>>(unsigned short&);

    istream& operator>>(bool&);

    istream& operator>>(float&);
    istream& operator>>(double&);



    istream& operator>>( __manip func) {(*func)(*this); return *this;}
    istream& operator>>(__imanip func) { return (*func)(*this); }
    istream& operator>>(streambuf*);
};

class iostream : public istream, public ostream
{
  public:
    iostream() { }
    iostream(streambuf* sb, ostream*tied= (0)  );
};

class _IO_istream_withassign : public istream {
public:
  _IO_istream_withassign& operator=(istream&);
};

class _IO_ostream_withassign : public ostream {
public:
  _IO_ostream_withassign& operator=(ostream&);
};

extern _IO_istream_withassign cin;
 
extern _IO_ostream_withassign cout, cerr;

extern _IO_ostream_withassign clog



;

struct Iostream_init { } ;   

inline ios& dec(ios& i)
{ i.setf(ios::dec, ios::dec|ios::hex|ios::oct); return i; }
inline ios& hex(ios& i)
{ i.setf(ios::hex, ios::dec|ios::hex|ios::oct); return i; }
inline ios& oct(ios& i)
{ i.setf(ios::oct, ios::dec|ios::hex|ios::oct); return i; }
}  


# 27 "grect.h" 2








# 1 "yd.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 





























# 35 "grect.h" 2



class GRect : public GRECT
{
public:
   
  GRect() {}
  GRect (int x, int y, int w, int h);
  GRect (int xy[4]);
  
   
  virtual GRect& MoveAbs (int x, int y);
  virtual GRect& MoveRel (int xOffset, int yOffset);
  virtual GRect& MoveLeft (int xOffset = 1) { g_x -= xOffset; return *this; }
  virtual GRect& MoveRight (int xOffset = 1) { g_x += xOffset; return *this; }
  virtual GRect& MoveUp (int yOffset = 1) { g_y -= yOffset; return *this; }
  virtual GRect& MoveDown (int yOffset = 1) { g_y += yOffset; return *this; }
  virtual GRect& PressLeft (int xOffset = 1);
  virtual GRect& PressRight (int xOffset = 1);
  virtual GRect& PressTop (int xOffset = 1);
  virtual GRect& PressBottom (int xOffset = 1);
  
  GRect& Resize (int w, int h);
  GRect& SetRect (int x, int y, int w, int h);
  GRect& SetRect (int xywh[4]);
  
   
  void GetOrigin (int& x, int& y) const;
  void GetSize (int& w, int& h) const;
  void GetRect (int& x, int& y, int& w, int& h) const;
  void GetRect (int xywh[4]) const;
  int Contains (int x, int y) const;
  int Area () const { return ((int) *this); }
   
   
   
   
  void Dump (const char* name, ostream& out = cerr) const;
  
   
        GRect& Clip (const GRect& border);
        GRect& Bound (const GRect& border);
        GRect& Constrain (const GRect& border);
        GRect& Scale (int hscale, int vscale);
  virtual GRect& Center (const GRect& reference);
        GRect& Combine (const GRect& add);
        GRect& Absolute ();
        GRect& Positive ();
        GRect& Negative ();
        
         
        GRect  Absolute (const GRect&) const;
        GRect  Positive (const GRect&) const;
        GRect  Negative (const GRect&) const;
        GRect  Intersect (const GRect& other);   
  
   
  inline bool operator== (const GRect&) const;
  inline bool operator!= (const GRect&) const;
  
  int GRect::operator [] (int i) const; 
  
   
   
   
  const GRect  operator+ (const GRect& other) const;
  const GRect  operator& (const GRect& other) const;
  const GRect& operator+= (const GRect& other);
  const GRect& operator&= (const GRect& other);
  
   
  inline bool operator> (const GRect& other) const;
  inline bool operator>= (const GRect& other) const;
  inline bool operator< (const GRect& other) const;
  inline bool operator<= (const GRect& other) const;
  inline bool operator> (const int& i) const;
  inline bool operator>= (const int& i) const;
  inline bool operator< (const int& i) const;
  inline bool operator<= (const int& i) const;
  
   
  friend inline bool operator> (const int& i, const GRect& g);
  friend inline bool operator>= (const int& i, const GRect& g);
  friend inline bool operator< (const int& i, const GRect& g);
  friend inline bool operator<= (const int& i, const GRect& g);
  
   
  operator bool () const { return ((g_w != 0) || (g_h != 0)); }
  operator int () const;
  operator int* () const;
  
private:
  mutable int xy[4];
};

 
inline void GRect::GetOrigin (int& x, int& y) const
{
  x = g_x;
  y = g_y;
}

inline void GRect::GetSize (int& w, int& h) const
{
  w = g_w;
  h = g_h;
}

inline int GRect::Contains (int x, int y) const
{
  GRect ref = Absolute (*this);
  return (x >= ref.g_x && y >= ref.g_y 
      && x - ref.g_x < ref.g_w && y - ref.g_y < ref.g_h);
}

inline bool GRect::operator== (const GRect& other) const
{
  return (!(*this != other));
}

inline bool GRect::operator!= (const GRect& o) const
{
  return (g_x != o.g_x || g_y != o.g_y || g_w != o.g_w || g_h != o.g_h);
}

inline bool GRect::operator>  (const GRect& other) const
{
  return ((int) *this > (int) other);
}

inline bool GRect::operator>= (const GRect& other) const
{
  return ((int) *this >= (int) other);
}

inline bool GRect::operator<  (const GRect& other) const
{
  return ((int) *this < (int) other);
}

inline bool GRect::operator<= (const GRect& other) const
{
  return ((int) *this <= (int) other);
}

inline bool GRect::operator> (const int& i) const
{
  return ((int) (*this) > i);
}

inline bool GRect::operator>= (const int& i) const
{
  return ((int) (*this) >= i);
}

inline bool GRect::operator< (const int& i) const
{
  return ((int) (*this) < i);
}

inline bool GRect::operator<= (const int& i) const
{
  return ((int) (*this) <= i);
}

inline bool operator> (const int& i, const GRect& g)
{
  return (i > (int) g);
}

inline bool operator>= (const int& i, const GRect& g)
{
  return (i >= (int) g);
}

inline bool operator< (const int& i, const GRect& g)
{
  return (i < (int) g);
}

inline bool operator<= (const int& i, const GRect& g)
{
  return (i <= (int) g);
}

# 33 "gemw.h" 2





class GEMactivity;
class GEMevent;

class GEMwindow : public GEMpanarea
{
public:
  GEMwindow(GEMactivity& in, int Parts);
  GEMwindow(GEMactivity& in, int Parts, const GRect&);
  GEMwindow(GEMactivity& in, int Parts, const GRect& actWorkArea, const GRect& maxWorkArea);
  GEMwindow(const GEMwindow&);

  virtual ~GEMwindow();

   
  virtual bool Create();
  virtual void Open();
  virtual void Close();
  virtual void Delete();

   
   
  virtual void BecomeDeleted();

   
  virtual bool  IsOpen() const;
   
  virtual bool IsCreated () const { return created; }
  virtual bool  IsIconified(int& w, int& h) const;
  bool  IsIconified() const;
        
  GRect BorderRect() const  { return Work2Win(Pos); }
  GRect WorkRect() const    { return Pos;     }

   
  virtual void Top(const GEMevent&);
  virtual void Bottom(const GEMevent&);
  virtual void Move(int X, int Y);
  virtual void Resize(int w, int h);   
  virtual GEMfeedback Click(const GEMevent&);
   
   
  virtual GEMfeedback ToolbarClick (int obj, int clicks, int keystate);

   
   


  void RedrawOverlaps(const GRect&);  
  void RedrawOverlapsViaMessage(const GRect&);

  int Handle() const { return handle; }

  void Align(int x, int y, int xmult=8, int ymult=1);
   

  virtual GEMfeedback UserClosed();
  virtual void UserFulled();
  virtual void UserResized(int w,int h);
  virtual void UserMoved(int x, int y);
  virtual void UserIconified(const GRect&);
  virtual void UserUniconified(const GRect&);

   
  virtual void VSlidered(int newPos);
  
   
  virtual void HSlidered(int newPos);

   
  char *InfoText() const  { return info;  }
  void SetInfoText(const char *);

   
  void SetName(const char *);
  const char *Name() const { return name; }

   
  virtual void Flush();

   
  void SetVisibleLines(int noOfLines);
  void SetTotalLines(int noOfLines);
  void SetTopLine(int noOfLine);
  void SetVisibleColumns(int noOfColumns);
  void SetTotalColumns(int noOfColumns);
  void SetLeftColumn(int noOfColumn);

   
  void LineHeight(int i) { lineHeight=i; }
  void ColumnWidth(int i) { columnWidth=i; }
  int LineHeight() { return lineHeight; }
  int ColumnWidth() { return columnWidth; }

   
  void SetPartColor (int part, short activecolour, short inactivecolour);
  void DefaultPartColor (int part);

   
  void SetPartColors (class GEMform& active, class GEMform& inactive);
  void DefaultPartColors ();

  short PartColor (int part, bool activecolour) const;

  int ButtonEventFlags(int flags);

  int Parts() const { return parts; }
  void Parts(int parts);

  GEMactivity& Activity() const { return *act; }

  void SetBorderRect(const GRect&);
  virtual void SetWorkRect(const GRect&);
  virtual void SetMaxWorkRect(const GRect&);

   
  virtual int ClipTrackingRectangle(int x, int y, GRect&);
  virtual void MousePosition(const GEMevent&);
  virtual void MousePositionOff();
   
  static int ClipTrackingRectangle(GRect& me, int x, int y, GRect& track);

   
  virtual void InFocus(bool yes);

   
  virtual GEMfeedback Key(const GEMevent&);

protected:
   
   
  virtual GRect Win2Work(const GRect& outer) const;
  virtual GRect Work2Win(const GRect& work) const;

  virtual void Redraw(const GRect&);

  virtual bool ScrollByBlitting() const;

  void VCalculateGEMvalues();
  void VCalculateValues();
  virtual void VFlushSlider();
  void HCalculateGEMvalues();
  void HCalculateValues();
  virtual void HFlushSlider();

private:
  int parts;
   
  GRect Pos, Max;  

  char *info;
  GRect storer;      
  char *name;
  int handle;
    
  bool opened, created;
  GEMactivity* act;
  int xoff,yoff,xalign,yalign;
  short bevent;

   
  int vSize,
    vPosition;
  int hSize,
    hPosition;

   
  int lineHeight,columnWidth;

  void InActivity(GEMactivity& in);

  class GEMwPartCol* partcol;
};



# 18 "gema.cc" 2

# 1 "gemm.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 





# 1 "gemf.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 





# 1 "gemrawo.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 









class GEMobject;

class GEMrawobject : private OBJECT
 
 
{
public:
   
   
  GEMobject* Cook();

  GEMrawobject() { }

   
   
   
   
   
   
   
   
   
  GEMrawobject(const GEMrawobject&);

   
   
   
   
   

  bool Selected(bool s)   { return State(0x0001 ,s); }
  bool Selected() const   { return States(0x0001 ); }
  void Select()       { Selected(true); }
  void Deselect()       { Selected(false); }
  bool Crossed(bool s)    { return State(0x0002 ,s); }
  bool Crossed() const    { return States(0x0002 ); }
  void Cross()        { Crossed(true); }
  void Uncross()        { Crossed(false); }
  bool Checked(bool s)    { return State(0x0004 ,s); }
  bool Checked() const    { return States(0x0004 ); }
  void Check()        { Checked(true); }
  void Uncheck()        { Checked(false); }
  bool Disabled(bool s)   { return State(0x0008 ,s); }
  bool Disabled() const   { return States(0x0008 ); }
  void Disable()        { Disabled(true); }
  void Enable()       { Disabled(false); }
  bool Outlined(bool s)   { return State(0x0010 ,s); }
  bool Outlined() const   { return States(0x0010 ); }
  void Outline()        { Outlined(true); }
  void Unoutline()      { Outlined(false); }
  bool Shadowed(bool s)   { return State(0x0020 ,s); }
  bool Shadowed() const   { return States(0x0020 ); }
  void Shadow()       { Shadowed(true); }
  void Unshadow()       { Shadowed(false); }

  bool Selectable(bool f)   { return Flag(0x0001 ,f); }
  bool Selectable() const   { return Flags(0x0001 ); }
  bool Default(bool f)    { return Flag(0x0002 ,f); }
  bool Default() const    { return Flags(0x0002 ); }
  bool Exit(bool f)     { return Flag(0x0004 ,f); }
  bool Exit() const     { return Flags(0x0004 ); }
  bool Editable(bool f)   { return Flag(0x0008 ,f); }
  bool Editable() const   { return Flags(0x0008 ); }
  bool RadioButton(bool f)  { return Flag(0x0010 ,f); }
  bool RadioButton() const  { return Flags(0x0010 ); }
  bool LastObject(bool f)   { return Flag(0x0020 ,f); }
  bool LastObject() const   { return Flags(0x0020 ); }
  bool TouchExit(bool f)    { return Flag(0x0040 ,f); }
  bool TouchExit() const    { return Flags(0x0040 ); }
  bool HideTree(bool f)   { return Flag(0x0080 ,f); }
  bool HideTree() const   { return Flags(0x0080 ); }
  bool Indirect(bool f)   { return Flag(0x0100 ,f); }
  bool Indirect() const   { return Flags(0x0100 ); }

  int Head() const      { return ob_head; }
  int Tail() const      { return ob_tail; }
  int Next() const      { return ob_next; }

  unsigned long ObjectSpecific() const;
  void ObjectSpecific(unsigned long l);

  int Type() const      { return ob_type&0xff; }
  int ExtType() const     { return ob_type>>8; }
  void Type(int t)      { ob_type=ob_type&0xff00|t; }
  void ExtType(int t)     { ob_type=ob_type&0x00ff|(t<<8); }

  void MoveTo(short x, short y) { ob_x=x; ob_y=y; }
  void MoveBy(short x, short y) { ob_x+=x; ob_y+=y; }

  short States() const    { return ob_state; }
  short Flags() const     { return ob_flags; }

  short X() const               { return ob_x; }
  short Y() const { return ob_y; }          
  void Resize(short w, short h)       { ob_width=w; ob_height=h; }
  short Width() const             { return ob_width; }
  short Height() const            { return ob_height; }

  char* ImageBitmap(bool Mask=false) const;
  short ImageHeight() const;
  short ImageWidth() const;
  void SetImageBitmap(char* bitmap, short w, short h, bool Mask=false);
  char* Text() const;
  void SetText(char* str);

  int FillPattern() const;
  void FillPattern(int);

  bool Transparent() const;
  void Transparent(bool);

  int Font() const;
  void Font(int font);

  int ForeCol() const;
  void ForeCol(int colourindex);

  int BackCol() const;
  void BackCol(int colourindex);

  int BorderCol() const;
  void BorderCol(int colourindex);

  int BorderWidth() const;
  void BorderWidth(int width);

  int TextAlignment() const;
  void TextAlignment(int align) const;

   
  GEMfeedback Touch(int x, int y, const class GEMevent&);
  void InFocus(bool yes);

  void SetWidth(short w);
  void SetHeight(short h);

private:
  bool State(short s, bool on) { bool t=ob_state&s; if (on)
      ob_state|=s; else ob_state&=~s; return !!t; }
  bool States(short s) const  { return !!(ob_state&s); }

  bool Flag(short f, bool on) { bool t=ob_flags&f; if (on)
      ob_flags|=f; else ob_flags&=~f; return !!t;}
  bool Flags(short f) const { return !!(ob_flags&f); }
};


# 27 "gemf.h" 2




class GEMobject;
class GEMrsc;
class GEMevent;
class GRect;

class GEMform
{
public:
  GEMform(const GEMrsc& in, int RSCindex);
  GEMform(const GEMform&);
  virtual ~GEMform();

  int Do();  
  virtual int Do(int x, int y);

  bool Zooms(bool b);
  bool Flight(bool b);
  void Fly(bool opaque=true);

  virtual void RedrawObject(int RSCindex);
   
  virtual void RedrawObject (int RSCindex, const GRect& area);
  virtual void RedrawObject(int RSCindex,int Cx,int Cy,int Cw,int Ch);  
  void RedrawObjectFromRoot(int RSCindex);

  int Parent(int RSCindex) const;

   
  GEMrawobject& Object(int RSCindex) const { return Obj[RSCindex]; }
  GEMrawobject& operator[](int RSCindex) const { return Object(RSCindex); }

  virtual void AlignObject(int RSCindex, int xmult=8, int ymult=1);

  const int SearchDown=-1;
  const int SkipSubtree=-2;

  int Map (int Do (GEMrawobject*, int), bool skiphidden=true, int RSCfrom=0, int RSCto=-1);
  
  virtual GEMfeedback DoItem(int item, const GEMevent& e);

  int Index() const { return myindex; }

  virtual bool IsOpen();

   
   
  virtual GRect* FirstClip(int RSCobject);
  virtual GRect* NextClip(GRect* prev);

private:
  int myindex;
  void* flybuffer;
  int vdihandle;
  int open;
  static int global_count;
  static GEMrawobject* global_obj;
  static int CountObj (GEMrawobject* o, int i);
  static int CopyObj (GEMrawobject* o, int i);
  
protected:
  bool ZoomOn;
  bool flight;
  GEMrawobject *Obj;
  virtual int FormDo(GEMevent& finalevent);
  int xoffset,yoffset,xmult,ymult;

  void FlagOpen(int dopen) { open+=dopen; }
};
inline  bool GEMform::Zooms(bool b) { bool t=b; ZoomOn=b; return t; }

# 20 "gemm.h" 2


class GEMactivity;
class GEMevent;

class GEMmenu : public GEMform
{
public:
	GEMmenu(GEMactivity& in, const GEMrsc& rsc, int RSCindex);
	~GEMmenu();

	GEMfeedback Select(const GEMevent&);
	void Show(bool on=true);
	void Hide() { Show(false); }

private:
	GEMactivity& act;
};


# 19 "gema.cc" 2

# 1 "gemt.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 






class GEMactivity;
class GEMevent;

class GEMtimer
{
public:
	GEMtimer (GEMactivity& in, int millisec);
	virtual ~GEMtimer();

	int Interval() { return interval; }

	 
	void Interval (int i) { interval = i; }

	virtual GEMfeedback Expire (const GEMevent&) = 0;

	 
	static int NextInterval ();
	static GEMfeedback ExpireNext (const GEMevent&);

	GEMactivity& Activity() const { return *act; }

private:
	void InsertInto (GEMtimer*&);
	void DeleteFrom (GEMtimer*&);

	static GEMactivity* act;
	static GEMtimer* head;
	static int now;

	GEMtimer* next;
	int interval;
	int mytime;
};


# 20 "gema.cc" 2

# 1 "gemda.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 





class GEMapplication;
class GEMactivity;
class GEMevent;

class GEMdeskaccessory
{
public:
	GEMdeskaccessory(const GEMapplication& appl, GEMactivity& in, const char* MenuItemName);
	virtual ~GEMdeskaccessory();

	void Open(const GEMevent&);
	void Close(const GEMevent&);

protected:
	virtual void Open()=0;
	virtual void Close()=0;

private:
	GEMactivity& act;
	int menuid;
};



# 21 "gema.cc" 2

# 1 "gemks.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 






class GEMactivity;
class GEMevent;

class GEMkeysink
{
public:
	GEMkeysink(GEMactivity& in);
	virtual ~GEMkeysink();

	virtual GEMfeedback Consume(const GEMevent&)=0;

private:
	GEMactivity& act;
};


# 22 "gema.cc" 2

# 1 "gemrt.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 






class GEMactivity;
class GEMevent;

class GEMrectangletracker
{
public:
	GEMrectangletracker(GEMactivity& in);
	virtual ~GEMrectangletracker();

	virtual void CalculateRectangles(GEMevent&);
	virtual GEMfeedback MousePosition(const GEMevent&);

private:
	GEMactivity& act;
	int prev_x,prev_y;
};


# 23 "gema.cc" 2


# 1 "contract.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
















# 1 "/usr/include/stdlib.h" 1 3
 











extern "C" {









typedef __wchar_t   wchar_t;




















typedef struct {
    int		quot;	 
    int		rem;	 
} div_t;

typedef struct {
    long	quot;	 
    long	rem;	 
} ldiv_t;

  double atof  (const char *s)  ;
  int atoi  (const char *str)  ;
  long atol  (const char *str)  ;
  long int strtol  (const char *nptr, char **endptr, int base)  ;
  unsigned long int strtoul  (const char *nptr, char **endptr, int base)  ;
  double strtod  (const char *s, char **endptr)  ;  

  void srand  (unsigned int seed)  ;
  int rand  (void)  ;

  void *malloc  (size_t n)  ;
  void free  (void *param)  ;
  void *realloc  (void *_r, size_t n)  ;
  void *calloc  (size_t n, size_t sz)  ;















       void _malloczero  (int yes)  ;
       void _mallocChunkSize  (size_t siz)  ;




  void  abort  (void)   __attribute__ ((noreturn)) ;

   
  int atexit  (void (*)(void))  ;

  void  exit  (int)   __attribute__ ((noreturn)) ;

  char *getenv  (const char *tag)  ;
  int system  (const char *s)  ;

  void *bsearch  (const void *key, const void *base, size_t num, size_t size, int (*cmp )(const void *, const void *))  ;
  void qsort  (void *base, size_t total_elems, size_t size, int (*cmp )(const void *, const void *))  ;

  int abs  (int x)  ;
  long labs  (long x)  ;

  div_t div  (int num, int denom)  ;
  ldiv_t ldiv  (long num, long denom)  ;

  int mblen  (const char *, size_t)  ;
  size_t mbstowcs  (wchar_t *, const char *, size_t)  ;
  int mbtowc  (wchar_t *, const char *, size_t)  ;
  size_t wcstombs  (char *, const wchar_t *, size_t)  ;
  int wctomb  (char *, wchar_t)  ;

  wchar_t *wcscat  (wchar_t *, const wchar_t *)  ;
  int wcscmp  (const wchar_t *, const wchar_t *)  ;
  wchar_t *wcscpy  (wchar_t *, const wchar_t *)  ;
  size_t wcslen  (const wchar_t *)  ;
  wchar_t *wcsncat  (wchar_t *, const wchar_t *, size_t)  ;
  int wcsncmp  (const wchar_t *, const wchar_t *, size_t)  ;
  wchar_t *wcsncpy  (wchar_t *, const wchar_t *, size_t)  ;

# 130 "/usr/include/stdlib.h" 3



}



# 42 "contract.h" 2










# 1 "/usr/include/string.h" 1 3
 










extern "C" {












  void *memcpy  (void *dst, const void *src, size_t size)  ;
  void *memmove  (void *dst, const void *src, size_t size)  ;
  int memcmp  (const void *s1, const void *s2, size_t size)  ;
  void *memchr  (const void *s, int ucharwanted, size_t size)  ;
  void *memset  (void *s, int ucharfill, size_t size)  ;

  char *strcpy  (char *dst, const char *src)  ;
  char *strncpy  (char *dst, const char *src, size_t n)  ;
  char *strcat  (char *dst, const char *src)  ;
  char *strncat  (char *dst, const char *src, size_t n)  ;
  int strcmp  (const char *scan1, const char *scan2)  ;
  int strncmp  (const char *scan1, const char *scan2, size_t n)  ;
  int strcoll  (const char *scan1, const char *scan2)  ;
  size_t	strxfrm  (char *to, const char *from, size_t maxsize)  ;
  char *strchr  (const char *s, int charwanted)  ;
  size_t strcspn  (const char *s, const char *reject)  ;
  char *strpbrk  (const char *s, const char *breakat)  ;
  char *strrchr  (const char *s, int charwanted)  ;
  size_t strspn  (const char *s, const char *accept)  ;
  char *strstr  (const char *s, const char *wanted)  ;
  char *strtok  (char *s, const char *delim)  ;
  size_t strlen  (const char *scan)  ;
  char *strerror  (int errnum)  ;


 



  void *memccpy  (void *dst, const void *src, int ucharstop, size_t size)  ;
  char *strlwr  (char *string)  ;
  char *strupr  (char *string)  ;
 


  char *strrev  (char *string)  ;
  char *strdup  (const char *s)  ;

 


  char *index  (const char *s, int charwanted)  ;
  char *rindex  (const char *s, int charwanted)  ;
  void bcopy  (const void *src, void *dst, size_t length)  ;
  int bcmp  (const void *src, const void *dst, size_t n)  ;
  void bzero  (void *b, size_t n)  ;

  void _bcopy  (const void *src, void *dst, unsigned long length)  ;
  int  _bcmp  (const void *s1, const void *s2, unsigned long length)  ;
  void _bzero  (void *dst, unsigned long length)  ;

  int stricmp  ( const char *, const char * )  ;
  int strnicmp  ( const char *, const char *, size_t )  ;
  int strcmpi  ( const char *, const char * )  ;
  int strncmpi  ( const char *, const char *, size_t )  ;
  int strcasecmp  ( const char *, const char * )  ;
  int strncasecmp  ( const char *, const char *, size_t )  ;



 





# 126 "/usr/include/string.h" 3



# 139 "/usr/include/string.h" 3



}



# 52 "contract.h" 2




# 70 "contract.h"





inline void Inspect( const char *message )
{
	char buf[120] = "[1][\0";
	
	strcat( buf, message );
	strcat( buf, "][ Continue ]" );
	
	form_alert( 1, buf );
}





# 114 "contract.h"























# 25 "gema.cc" 2

# 1 "scancode.h" 1
 
 
 
 
 
 
 
 
 
 
 



 
 
 





























































































# 26 "gema.cc" 2


# 1 "gema.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 











# 1 "gemprot.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
















class GEMactivity;

class GEMprotocol
{
public:
  GEMprotocol (GEMactivity& in, int priority_request = 2147483647 );
  
   
   
  virtual ~GEMprotocol ();
  
   
   
   
   
   
   
   
   
   
  virtual GEMfeedback Dispatch (const GEMevent& event) = 0;
  
   
   
   
   
   
   
   
   
   
   
   
  int Priority () const { return priority; }
  
   
  int MaximumPriority ();
  
   
   
  void LockPriority (bool yes) { lock = yes; }
  
   
  bool Locked () { return lock; }
  
   
   
  int Priority (int priority_request);
  
   
   
   
   
   
   
   
   
   
  int Promote (GEMprotocol* buddy, int priority_request);
  
   
   
  friend class GEMactivity;

   
   
   
   
  inline bool operator>  (const GEMprotocol& other) const;
  inline bool operator>= (const GEMprotocol& other) const;
  inline bool operator<  (const GEMprotocol& other) const;
  inline bool operator<= (const GEMprotocol& other) const;
  inline bool operator== (const GEMprotocol& other) const;
  
   
  bool Send (const char* partner, int* msg, int length = 16, 
             int sender_id = -1) const;
  bool Send (int partner_id, int* msg, int length = 16, 
             int sender_id = -1) const;
  int FindApplication (const char* name) const;
  
   
  void ConvertAESName (char* name) const;
  void str2int (int i[], const char c[], size_t length = 0);
  void int2str (char c[], const int i[], size_t length = 0);
  
protected:
  GEMprotocol* Next () const { return next; }
  GEMprotocol* Prev () const { return prev; }
  
private:
  GEMactivity& act;
  int priority;
  bool lock;
  GEMprotocol* next;
  GEMprotocol* prev;
  
  GEMprotocol (const GEMprotocol&);       
  void operator= (const GEMprotocol&);    
};

class AESprotocol : public GEMprotocol
{
public:
  AESprotocol (GEMactivity& in, int priority_request = 2147483647 ) :
    GEMprotocol (in, priority_request),
    ApTermDefault (EndInteraction),
    ApReschgDefault (EndInteraction),
    ApTfailDefault (IgnoredEvent),
    ChExitDefault (IgnoredEvent),
    CtKeyDefault (IgnoredEvent),
    ReschgCompletedDefault (IgnoredEvent),
    ScChangedDefault (IgnoredEvent),
    ShWdrawDefault (IgnoredEvent),
    ShutCompletedDefault (IgnoredEvent),
    SmMSpecialDefault (IgnoredEvent),
    WmAlliconifyDefault (IgnoredEvent)
      {}

  virtual GEMfeedback Dispatch (const GEMevent& event);

  virtual void DefaultFeedback (const GEMfeedback fb);
  
  void SetApTermDefault (const GEMfeedback fb) { ApTermDefault = fb; }
  void SetApReschgDefault (const GEMfeedback fb) { ApReschgDefault = fb; }
  void SetApTfailDefault (const GEMfeedback fb) { ApTfailDefault = fb; }
  void SetApAestermDefault (const GEMfeedback fb) { ApAestermDefault = fb; }
  void SetChExitDefault (const GEMfeedback fb) { ChExitDefault = fb; }
  void SetCtKeyDefault (const GEMfeedback fb) { CtKeyDefault = fb; }
  void SetReschgCompletedDefault (const GEMfeedback fb) { ReschgCompletedDefault = fb; }
  void SetScChangedDefault (const GEMfeedback fb) { ScChangedDefault = fb; }
  void SetShWdrawDefault (const GEMfeedback fb) { ShWdrawDefault = fb; }
  void SetShutCompletedDefault (const GEMfeedback fb) { ShutCompletedDefault = fb; }
  void SetSmMSpecialDefault (const GEMfeedback fb) { SmMSpecialDefault = fb; }
  void SetWmAlliconifyDefault (const GEMfeedback fb) { WmAlliconifyDefault = fb; }
  
protected:
  virtual GEMfeedback ApTerm (const GEMevent&) { return ApTermDefault; }
  virtual GEMfeedback ApReschg (const GEMevent&) { return ApReschgDefault; }
  virtual GEMfeedback ApTfail (const GEMevent&) { return ApTfailDefault; }
  virtual GEMfeedback ApAesterm (const GEMevent&) { return ApAestermDefault; }
  virtual GEMfeedback ChExit (const GEMevent&) { return ChExitDefault; }
  virtual GEMfeedback CtKey (const GEMevent&) { return CtKeyDefault; }
  virtual GEMfeedback ReschgCompleted (const GEMevent&) { return ReschgCompletedDefault; }
  virtual GEMfeedback ScChanged (const GEMevent&) { return ScChangedDefault; }
  virtual GEMfeedback ShWdraw (const GEMevent&) { return ShWdrawDefault; }
  virtual GEMfeedback ShutCompleted (const GEMevent&) { return ShutCompletedDefault; }
  virtual GEMfeedback SmMSpecial (const GEMevent&) { return SmMSpecialDefault; }
  virtual GEMfeedback WmAlliconify (const GEMevent&) { return WmAlliconifyDefault; }

private:
  GEMfeedback ApTermDefault;
  GEMfeedback ApReschgDefault;
  GEMfeedback ApTfailDefault;
  GEMfeedback ApAestermDefault;
  GEMfeedback ChExitDefault;
  GEMfeedback CtKeyDefault;
  GEMfeedback ReschgCompletedDefault;
  GEMfeedback ScChangedDefault;
  GEMfeedback ShWdrawDefault;
  GEMfeedback ShutCompletedDefault;
  GEMfeedback SmMSpecialDefault;
  GEMfeedback WmAlliconifyDefault;
};

inline bool GEMprotocol::operator> (const GEMprotocol& other) const
{
  return (priority <= other.priority);
}

inline bool GEMprotocol::operator>= (const GEMprotocol& other) const
{
  return (priority < other.priority);
}

inline bool GEMprotocol::operator< (const GEMprotocol& other) const
{
  return (priority >= other.priority);
}

inline bool GEMprotocol::operator<= (const GEMprotocol& other) const
{
  return (priority > other.priority);
}

inline bool GEMprotocol::operator== (const GEMprotocol& other) const
{
  return (priority == other.priority);
}


# 25 "gema.h" 2



class GEMmenu;
class GEMdeskaccessory;
class GEMwindow;
class GEMtimer;
class GEMkeysink;
class GEMrectangletracker;

class GEMactivity
{
public:
  GEMactivity();

  virtual ~GEMactivity();

   
  void Do();

   
  void BeginDo();
  GEMfeedback OneDo();
  GEMfeedback OneDo(int eventmask);
  void EndDo();

   
  void AddWindow(GEMwindow&);
  void RemoveWindow(GEMwindow&);
  void SetMenu(GEMmenu*);
  void SetTimer(GEMtimer*);
  void SetKeySink(GEMkeysink*);
  void SetDeskAccessory(GEMdeskaccessory*);
  void SetRectangleTracker(GEMrectangletracker*);
  void Topped(const GEMwindow&);
  void Bottomed(const GEMwindow&);

   

   
   
   
  void* First() const                      { return winlist; }
  void Next(void*& i) const                { i=((WL*)i)->next; }
  void Prev(void*& i) const                { i=((WL*)i)->prev; }
   
   
   
  GEMwindow& operator[](void* i) const     { return *((WL*)i)->window; }

   
  GEMwindow* TopWindow() const;
  GEMwindow* WindowUnder(const GEMwindow*) const;

private:
  GEMfeedback PerformMessage(const GEMevent&);
  struct WL {
    WL(GEMwindow *wind, WL *n);
    GEMwindow *window;
    struct WL *next;
    struct WL *prev;
  } *winlist;
  GEMwindow* Window(int ID) const;
  WL* ListWindow(int ID) const;

  GEMmenu *menu;
  GEMdeskaccessory *acc;
  GEMtimer *timer;
  GEMkeysink *keysink;
  GEMrectangletracker *rectrack;
  
  GEMprotocol* firstprot;
  GEMprotocol* lastprot;
  
  GEMprotocol* FindSlot (int permission, int request);
  void InsertAfter (GEMprotocol* before, GEMprotocol* insert);
  
  friend class GEMprotocol;
  
  int AddProtocol (GEMprotocol*, int priority);
  void RemoveProtocol (GEMprotocol*);
  int PromoteProtocol (GEMprotocol* sponsor, GEMprotocol* buddy, int priority);
  
  GEMevent event;
};


# 28 "gema.cc" 2



GEMactivity::WL::WL(GEMwindow *wind, GEMactivity::WL *n) :
  window(wind),
  next(n),
  prev(n ? n->prev : 0)
{
  if (n) n->prev=this;
}

GEMactivity::GEMactivity() :
  winlist(0), menu(0), acc(0), timer(0), keysink(0), rectrack(0),
  firstprot (0), lastprot (0)
{ }

GEMactivity::~GEMactivity()
{ }

 
 
 
static bool IsDesktop(GEMwindow* w)
{
  return w->IsOpen() && w->Handle()==0;
}

void GEMactivity::AddWindow(GEMwindow& w)
{
  winlist=new struct WL(&w,winlist);
}

void GEMactivity::RemoveWindow(GEMwindow& w)
{
  WL* c;
  
  for (c=winlist; c && c->window!=&w;  c=c->next)
    ;

  if (c) {
     
    if (c->prev) c->prev->next=c->next;
    if (c->next) c->next->prev=c->prev;
    if (c==winlist) winlist=c->next;

    delete c;
  }
}

int GEMactivity::AddProtocol (GEMprotocol* that, int priority_request)
{
   
  if (!that)
    return -1;
  
  GEMprotocol* preceder = FindSlot (2147483647 , priority_request);
  InsertAfter (preceder, that);
  return that->priority;  
}

void GEMactivity::RemoveProtocol (GEMprotocol* that)
{
  if (!that)
    return;
  if (that == firstprot)
    firstprot = that->next;
  if (that == lastprot)
    lastprot = that->prev;
    
  GEMprotocol* cursor = that->next;
  while (cursor) {
    cursor->priority--;
    cursor = cursor->next;
  }
  if (that->next)
    that->next->prev = that->prev;
  if (that->prev)
    that->prev->next = that->next;
  that->next = that->prev = (0)  ;
  that->priority = 2147483647 ;
}

int GEMactivity::PromoteProtocol (GEMprotocol* sponsor, GEMprotocol* buddy, 
                                  int priority_request)
{
  if (!sponsor || !buddy)
    return -1;
  int permission = sponsor->priority < buddy->priority ? 
      sponsor->priority : buddy->priority;
  
  GEMprotocol* preceder = FindSlot (permission, priority_request);
  RemoveProtocol (buddy);
  InsertAfter (preceder, buddy);
  return buddy->priority;
}

void GEMactivity::InsertAfter (GEMprotocol* preceder, GEMprotocol* insert)
{
  if (!preceder) {
     
    insert->prev = (0)  ;
    if (firstprot) {
       
      insert->next = firstprot->next;
      firstprot->prev = insert;
    } else {
       
      insert->next = (0)  ;
      lastprot = insert;
    }
    insert->priority = 0;
    firstprot = insert;
    return;
  }
  if (preceder->next) {
     
     
    preceder->next->prev = insert;
  } else {
     
    lastprot = insert;
  }
  insert->next = preceder->next;
  preceder->next = insert;
  insert->prev = preceder;
  insert->priority = preceder->priority + 1;
}

GEMprotocol* GEMactivity::FindSlot (int permission, int request) {
  GEMprotocol* cursor = lastprot;
  while (cursor) {
    if (((cursor->lock) && (cursor->priority <= permission))
          || (cursor->priority > request))
        return cursor;
    cursor->priority++;
    cursor = cursor->next;
  }
  return cursor;
}

void GEMactivity::SetMenu(GEMmenu* m)
{
  menu=m;
}

void GEMactivity::SetTimer(GEMtimer* t)
{
  timer=t;
}

void GEMactivity::SetKeySink(GEMkeysink* k)
{
  keysink=k;
}

void GEMactivity::SetDeskAccessory(GEMdeskaccessory* a)
{
  acc=a;
}

void GEMactivity::SetRectangleTracker(GEMrectangletracker* rt)
{
  rectrack=rt;
}

void GEMactivity::Do()
{
  GEMfeedback res=ContinueInteraction;

  BeginDo();

  while (res != EndInteraction) {
    res=OneDo();
  }

  EndDo();
}

void GEMactivity::BeginDo()
{
  if (menu) menu->Show();

  graf_mouse(0 ,0);
}

GEMfeedback GEMactivity::OneDo()
{
  return OneDo(0xffff);  
}

GEMfeedback GEMactivity::OneDo(int eventmask)
{
  GEMfeedback res = ContinueInteraction;

  int get = 0x0002 | 0x0010 ;

  if (timer && timer->NextInterval () >= 0) {
    get |= 0x0020 ;
    event.Interval (timer->NextInterval ());
  }

  if (keysink) get |= 0x0001 ;

  if (rectrack) {
    get |= 0x0004 ;  
    rectrack->CalculateRectangles (event);
  }

  event.Get (get & eventmask);

  if (rectrack) {
    rectrack->MousePosition (event);
  }

  if (event.Keyboard ()) {
    res = keysink->Consume (event);
  }

  if (event.Timer()) {
    res = timer->ExpireNext (event);
  }

  if (event.Button()) {
    GEMwindow *win=0;
    WL* c;
    
    for (c=winlist; c && !win; c=c->next) {
      int X,Y,W,H;
      if (c->window->IsOpen()) {
        wind_get(c->window->Handle(),4 ,&X,&Y,&W,&H);
        if (event.X()>=X && event.X()<X+W && event.Y()>=Y && event.Y()<Y+H)
          win=c->window;
      }
    }
    if (win) res=win->Click(event);
  }

  if (event.Message()) {
    res = PerformMessage(event);
  }

  return res;
}

void GEMactivity::EndDo()
{
  if (menu) menu->Hide();
}

GEMwindow* GEMactivity::Window(int ID) const
{
  WL* c;
  
  for (c=winlist; c && c->window->Handle()!=ID;  c=c->next)
    ;
  return c ? c->window : 0;
}

GEMactivity::WL* GEMactivity::ListWindow(int ID) const
{
  WL* c;
  
  for (c=winlist; c && c->window->Handle()!=ID;  c=c->next)
    ;
  return c;
}

void GEMactivity::Bottomed(const GEMwindow& w)
{
   
  WL* c;
  for (c=winlist; c && c->window!=&w;  c=c->next)
    ;

  if (c) {
     
    WL* end=c;
    while (end->next
        && !IsDesktop(end->next->window)
        && end->next->window->IsOpen())
    {
      end=end->next;
    }

     
    if (c!=end) {
       
      if (c->prev) c->prev->next=c->next;
      if (c->next) c->next->prev=c->prev;
      if (c==winlist) winlist=c->next;

       
      c->next=end->next;
      if (c->next) c->next->prev=c;
      end->next=c;
      c->prev=end;
    }
  }
}

void GEMactivity::Topped(const GEMwindow& w)
{
   
  WL* c;
  for (c=winlist; c && c->window!=&w;  c=c->next)
    ;

   
  if (c && c!=winlist) {
     
    if (c->prev) c->prev->next=c->next;
    if (c->next) c->next->prev=c->prev;

     
    c->next=winlist;
    c->prev=0;
    winlist->prev=c;
    winlist=c;
  }
}






GEMfeedback GEMactivity::PerformMessage(const GEMevent& event)
{
  GEMfeedback r = ContinueInteraction;

  if (event.Message(0)== 10  && menu) {
    return menu->Select(event);
  } else if (event.Message(0)== 40 ) {
    if (acc) acc->Open(event);
    return ContinueInteraction;
  } else if (event.Message(0)== 41 ) {
    if (acc) acc->Close(event);
    return ContinueInteraction;
  }

  bool processed = false;
  
  GEMwindow* To=Window(event.Message(3));

  if (To) {
    GRect rect(event.Message(4),event.Message(5),event.Message(6),event.Message(7));
    switch (event.Message(0)) {
      case 20 :
        To->RedrawOverlaps(rect);
        processed = true;
        break; 
      case 37 :
        r = To->ToolbarClick (event.Message (4), event.Message (5), 
            event.Message (6));
        processed = true;
        break;
      case 22 :  
        r=To->UserClosed();
        processed = true;
        break; 
      case 28 : 
        To->UserMoved(rect.g_x,rect.g_y);
        processed = true;
        break; 
      case 21 :  
        To->Top(event);
        processed = true;
        break; 
      case 100 :
      case WM_BOTTOMED:  
        To->Bottom(event);
        processed = true;
        break; 
      case 23 :  
        To->UserFulled();
        processed = true;
        break; 
      case 34 : 
        To->UserIconified(rect);   
         
        processed = true;
        break; 
      case 35 : 
        To->UserUniconified(rect);
        processed = true;
        break; 
      case 27 : 
        To->UserResized(rect.g_w,rect.g_h);
        processed = true;
        break; 
      case 26 : 
        To->VSlidered(event.Message(4));
        processed = true;
        break; 
      case 25 : 
        To->HSlidered(event.Message(4));
        processed = true;
        break; 
      case 24 :
        switch (event.Message(4)) {
          case 2 :
            To->LineUp();
            break; 
          case 3 :
            To->LineDown();
            break; 
          case 0 :
            To->PageUp();
            break; 
          case 1 :
            To->PageDown();
            break; 
          case 6 :
            To->ColumnLeft();
            break; 
          case 7 :
            To->ColumnRight();
            break; 
          case 4 :
            To->PageLeft();
            break; 
          case 5 :
            To->PageRight();
        }
        processed = true;
    }
  }
  
  if (processed) {
    if (r == RedrawMe) {
      To->RedrawOverlaps(To->WorkRect());
      r = ContinueInteraction;
    }
  } else {
    GEMprotocol* prot = firstprot;
    while (prot) {
      GEMfeedback state = prot->Dispatch (event);
      if (state == EndInteraction)
        return state;
      else if (state == ContinueInteraction)
        break;
      prot = prot->next;
    }
  }
  
  return r;
}

GEMwindow* GEMactivity::TopWindow() const
{
  WL* c;
  
  for (c=winlist; c; c=c->next) {
    if (c->window->IsOpen()) return c->window;
  }

  return 0;
}

GEMwindow* GEMactivity::WindowUnder(const GEMwindow* find) const
{
  WL* c;
  for (c=winlist; c && c->window!=find; c=c->next) {
     
  }

  if (!c) return 0;  

   
  c=c->next;

  for ( ; c; c=c->next) {
    if (c->window->IsOpen()) return c->window;
  }

  return 0;
}
