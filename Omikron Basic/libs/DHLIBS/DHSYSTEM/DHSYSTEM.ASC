 DEF PROC Dhsystem
     PRINT CHR$(27)+"p"
     PRINT "                            "
     PRINT "       DHSYSTEM.LIB         "
     PRINT "     V0.51  13.10.1993      "
     PRINT "                            "
     PRINT "      System-Library        "
     PRINT "  for Omikron.Basic > V3.5  "
     PRINT "                            "
     PRINT "        (c) 1993 by         "
     PRINT "   Dirk Hagedorn Software   "
     PRINT "      D-59846 Sundern       "
     PRINT "                            "
     PRINT "    All rights reserved.    "
     PRINT "                            "
     PRINT CHR$(27)+"q"
 END_PROC
     '.
     '. ^DHSYSTEM.START
     '.
     '.
     '. ^Dhsystem
     '. ---------------------------------------------------
     '. - Typ:
     '.   Prozedur aus der !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Gibt Informationen zur Library aus.
     '. - Hinweis:
     '.   Dieser Aufruf ist lediglich fÅr den Direktmodus
     '.   des Interpreters gedacht.
     '.
     '.
     '. ^Informationen zur DHSYSTEM.LIB
     '. ---------------------------------------------------
     '.                  DHSYSTEM.LIB
     '.                      V0.51
     '.                   13.10.1993
     '.                    Freeware
     '. Die aktuelle Version ist beim Autor gegen Einsen-
     '. dung einer formatierten Diskette sowie eines
     '. adressierten und ausreichend frankierten RÅckum-
     '. schlags erhÑltlich.
     '. Modembesitzer finden die aktuelle Version immer in
     '. der Quark Paderborn (05251/71409; Gastdownload) im
     '. Brett "320-ST-Entwicklung" als Archiv mit dem Namen
     '. "DHSYSxxx.ZIP".
     '. Beachten Sie bei der Weitergabe der Library bitte
     '. die Punkte aus der beigefÅgten Datei LIESMICH.TXT.
     '.
     '.
     '. ^Autor der DHSYSTEM.LIB
     '. ---------------------------------------------------
     '.                   DHSYSTEM.LIB
     '.                   (c) 1993 by
     '.                  Dirk Hagedorn
     '.                 In der Esmecke 9
     '.                  59846 Sundern
     '.               All rights reserved.
     '. E-Mail:
     '. - MausNet:  Dirk Hagedorn @ PB
     '. - MagicNet: Seep @ Paderbox
     '. - ZNet:     D.Hagedorn @ HSP
     '. - Internet: dirk_hagedorn@pb.maus.de
     '.             (privat, keine Binaries, UUe's etc.)
     '.
     '.
     '.
     '. ^DHSYSTEM.LIB
     '. ---------------------------------------------------
     '. - !Autor der DHSYSTEM.LIB!
     '. - !Informationen zur DHSYSTEM.LIB!
     '. DHSYSTEM.LIB ist eine Freeware-Library mit Routinen
     '. fÅr die Betriebssystemebene. Sie stellt derzeit
     '. folgende Routinen zur VerfÅgung:
     '. - !Cookie-Routinen!
     '. - !OS-Header-Routinen!
     '. - !Basepage-Routinen!
     '. - !Commandline-Routinen!
     '. - !Environment-Routinen!
     '. - !XBRA-Routinen!
     '. - !Shell-Routinen!
     '. - !Systemvariablen-Routinen!
     '. - !VT52-Routinen!
     '. - !Ausgabe-Routinen fÅr standard output!
     '. - Interne Routinen:
     '.    - !Dhsystem!
     '.    - !FN Dhsystem_Init!
     '.    - !FN Dhsystem_Exit!
     '.    - !FN Dhsystem_Version!
     '.    - !FN Dhsystem_Date!
     '. - Sonstiges:
     '.   - !OSHEADER-Struktur!
     '.   - !BASEPAGE-Struktur!
     '.   - !XBRA-Struktur!
     '.
     '.
     '. ^OSHEADER-Struktur
     '. ---------------------------------------------------
     '. typedef struct _osheader
     '. {
     '.     UWORD      os_entry;   /* BRAnch-Instruktion
     '                                zum Reset-Handler  */
     '.     UWORD      os_version; /* TOS-Versionsnummer */
     '.     void      *reseth;     /* Zeiger auf RESET-
     '.                               Handler            */
     '.     struct _osheader *os_beg;
     '.                            /* Basisadresse des
     '.                               Betriebssystems    */
     '.     void      *os_end;     /* Erstes nicht vom OS
     '.                               benutztes Byte     */
     '.     LONG       os_rsv1;    /* reserviert         */
     '.     GEM_MUPB  *os_magic;   /* Zeiger auf GEM
     '.                               memory usage block */
     '.     LONG       os_date;    /* TOS-Herstellungsdatum
     '.                               im BCD-Format      */
     '.     UWORD      os_conf;    /* diverse Konfigura-
     '.                               tionsbytes         */
     '.     UWORD      os_dosdate; /* TOS-Herstellungsdatum
     '.                               im GEMDOS-Format   */
     '.     /* die folgenden Felder erst ab TOS 1.02 */
     '.     char     **p_root;     /* Basisadresse des
     '.                               GEMDOS-Pools       */
     '.     BYTE     **pkbshift;   /* Zeiger auf BIOS-
     '.                               interne Variable fÅr
     '.                               den aktuellen Wert
     '.                               von Kbshift()      */
     '.     BASEPAGE **p_run;      /* Adresse der Variablen
     '.                               die einen Zeiger auf
     '.                               den aktuellen GEMDOS-
     '.                               Prozess enthÑlt    */
     '.     char      *p_rsv2;     /* reserviert         */
     '. } OSHEADER;
     '.
     '.
     '. ^BASEPAGE-Struktur
     '. ---------------------------------------------------
     '. typedef struct basepage
     '. {
     '.     void *p_lowtpa;      /* Anfangsadresse der
     '.                             TPA                  */
     '.     void *p_hitpa;       /* Erstes Byte nach dem
     '.                             Ende der TPA         */
     '.     void *p_tbase;       /* Anfangsadresse des
     '.                             Programmcodes (TEXT-
     '.                             Segment)             */
     '.     LONG  p_tlen;        /* LÑnge des Programm-
     '.                             codes                */
     '.     void *p_dbase;       /* Adresse des Bereichs
     '.                             fÅr vorinitialisierte
     '.                             Daten (DATA-Segment) */
     '.     LONG  p_dlen;        /* LÑnge des DATA-
     '.                             Segments             */
     '.     void *p_bbase;       /* Adresse des Variablen-
     '.                             bereichs (BSS-
     '.                             Segment)             */
     '.     LONG  p_blen;        /* LÑnge des BSS-
     '.                             Segments             */
     '.     DTA  *p_dta;         /* Zeiger auf Default-DTA.
     '.                             Zeigt zunÑchst auf die
     '.                             Kommandozeile        */
     '.     struct basepage *p_parent;
     '.                          /* Zeiger auf die Basepage
     '.                             des aufrufendes
     '.                             Prozesses            */
     '.     LONG  p_resvrd0;     /* reserviert           */
     '.     char *p_env;         /* Adresse der Environ-
     '.                             ment-Strings         */
     '.     CHAR  p_resvrd1[80]; /* reserviert           */
     '.     CHAR  p_cmdlin[128]; /* Kommandozeile        */
     '. } BASEPAGE;
     '.
     '.
     '. ^XBRA-Struktur
     '. ---------------------------------------------------
     '. typedef struct
     '. {
     '.     char xb_magic[4]; /* "XBRA" = 0x58425241     */
     '.     char xb_id[4];    /* vier Buchstaben lange
     '.                          Kennung wie bei Cookies */
     '.     LONG xb_oldvec;   /* ursprÅnglicher Wert des
     '.                          Vektors                 */
     '. } XBRA;
     '.
     '.
     '.

 ' **********************************************************************
 ' *                                                                    *
 ' * SYSTEM-LIB   (c) by Dirk Hagedorn, In der Esmecke 9, 59846 Sundern *
 ' *                                                                    *
 ' **********************************************************************
 ' * HISTORY:                                                           *
 ' *--------------------------------------------------------------------*
 ' * 15.09.1993:  Cookie-Lese-Routinen erstellt                         *
 ' *              OS-Header-Lese-Routinen erstellt                      *
 ' *              Basepage-Lese-Routinen erstellt                       *
 ' *              Systemvariablen-Lese-Funktionen begonnen              *
 ' *--------------------------------------------------------------------*
 ' * 16.09.1993:  Systemvariablen-Lese-Funktionen beendet               *
 ' *              Basepage-Lese-Routinen gefixed                        *
 ' *              VT52-Routinen erstellt                                *
 ' *              Environment-Lese-Routinen erstellt                    *
 ' *--------------------------------------------------------------------*
 ' * 17.09.1993:  XBRA-Lese-Routinen erstellt                           *
 ' *              Wichtige Routinen kommentiert ;-)                     *
 ' *              FN Get_Cookie geÑndert auf 2D-Longinteger-Array und   *
 ' *              gleichzeitig Bug gefixed (zuviele Cookies wurden      *
 ' *              gefunden)                                             *
 ' *              Commandline-Routinen beendet (mit ARGV-Verfahren)     *
 ' *--------------------------------------------------------------------*
 ' * 22.09.1993:  Ausgabe-Routinen auf standard-output eingefÅgt.       *
 ' *--------------------------------------------------------------------*
 ' * 13.10.1993:  stdout() gibt jetzt Åber cconws() aus                 *
 ' *--------------------------------------------------------------------*
 ' *    geplant:  "PATH=" muû noch angepaût werden                      *
 ' **********************************************************************
 '
 '
 DEF FN Dhsystem_Init%L
     '. ^FN Dhsystem_Init
     '. R=FN Dhsystem_Init
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Initialisierung der !DHSYSTEM.LIB!
     '. - Parameter:
     '.   R:  TRUE : Initialisierung hat geklappt
     '.       FALSE: Initialisierung hat nicht geklappt
     '. - Hinweise:
     '.   Die Konstanten TRUE und FALSE mÅssen auûerhalb
     '.   der DHSYSTEM.LIB bereits vor dem Aufruf dieser
     '.   Funktion mit Werten belegt worden sein, sonst
     '.   kann diese Library nicht initialisiert werden.
     '.
     LOCAL Init_Ok%L
     '
     IF True%L=False%L THEN
        Init_Ok%L=0
     ELSE
        Init_Ok%L=True%L
     ENDIF
     '
     RETURN Init_Ok%L
 END_FN
 DEF FN Dhsystem_Exit%L
     '. ^FN Dhsystem_Exit
     '. R=FN Dhsystem_Exit
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Abmelden der !DHSYSTEM.LIB!
     '. - Parameter:
     '.   R:  TRUE : Abmeldung hat geklappt
     '.       FALSE: Abmeldung hat nicht geklappt
     '.
     '
     RETURN True%L
 END_FN
 '
 DEF FN Dhsystem_Version%L
     '. ^FN Dhsystem_Version
     '. R=FN Dhsystem_Version
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion der !DHIMG.LIB!
     '. - Aufgabe:
     '.   Liefert die Versionsnummer der !DHSYSTEM.LIB!
     '. - Parameter:
     '.   R: Versionsnummer der !DHIMG.LIB! als HEX-Wert
     '.      (z.B. $123 fÅr Version 1.23, $50 fÅr V0.5)
     '.
     RETURN $51
 END_FN
 DEF FN Dhsystem_Date%L
     '. ^FN Dhsystem_Date
     '. R=FN Dhsystem_Date
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion der !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Liefert das Erstellungsdatum der !DHSYSTEM.LIB!.
     '. - Parameter:
     '.   R: Erstellungsdatum der Library im BCD-Format
     '.      (z.B. $04011993 fÅr den 1. April 1993)
     '.
     RETURN $10131993
 END_FN

 '
 '
 ' =============================================================================
 '                                                                       COOKIES
 ' =============================================================================
     '.
     '. ^Cookie-Routinen
     '. ---------------------------------------------------
     '. Die !DHSYSTEM.LIB! bietet einige Cookie-Jar-
     '. Routinen. Dies sind im einzelnen:
     '. - !FN Get_Cookie!    Cookie suchen
     '. - !FN Get_Cookies!   Cookies auslesen
     '. - !Get_Cookies!      dito
     '.
     '.
 DEF FN Get_Cookie%L(Cookie$,Ptr_Value%L)'    [POINTER]
     '. ^FN Get_Cookie
     '. R=FN Get_Cookie(Cookie$,Ptr_Value)
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Sucht im Cookie-Jar nach einem Cookie namens
     '.   Cookie$ und retourniert den Cookie-Wert.
     '. - Parameter:
     '.   Cookie$  : vier Zeichen langer String, der den
     '.              Namen des zu suchenden Cookies enthÑlt
     '.   Ptr_Value: Pointer auf eine Longinteger-Variable,
     '.              die den Wert des gefundenen Cookies
     '.              enthÑlt
     '.   R        :  TRUE: Cookie wurde gefunden.
     '.              FALSE: Cookie nicht gefunden oder kein
     '.                     Cookie-Jar vorhanden
     '. - Hinweise:
     '.   - Auch der Nullcookie wird gefunden.
     '.   - siehe auch !FN Sys__P_Cookies!
     '.
     LOCAL Cjar%L,Found%L
     '
     Cjar%L= LPEEK($5A0)
     Found%L=0
     IF Ptr_Value%L>0 THEN *Ptr_Value%L=0
     '
     IF Cjar%L>0 THEN
        Cjar%L-=8
        REPEAT
          Cjar%L+=8
          IF MKIL$( LPEEK(Cjar%L))=Cookie$ THEN
             IF Ptr_Value%L>0 THEN
                *Ptr_Value%L= LPEEK(Cjar%L+4)
             ENDIF
             Found%L=-1
          ENDIF
        UNTIL LPEEK(Cjar%L)=0 OR Found%L=-1
     ENDIF
     '
     RETURN Found%L
 END_FN
 DEF FN Get_Cookies%L(Ptr_Long_Array2_%L)'    [POINTER]
     '. ^FN Get_Cookies
     '. R=FN Get_Cookies(Ptr_Long_Array2)
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Liest den gesamten Cookie-Jar aus und Åbertragt
     '.   die Daten in ein zweidimensionales Longinteger-
     '.   Array.
     '. - Parameter:
     '.   Ptr_Long_Array2: Pointer auf ein zweidimensio-
     '.                    nales Longinteger-Array.
     '.   R:           >0: Anzahl der im Cookie-Jar
     '.                    enthaltenen Cookies
     '.                =0: kein Cookie-Jar vorhanden
     '. - Hinweise:
     '.   - siehe auch !FN Sys__P_Cookies!
     '.   - Wird ein Nullpointer Åbergeben, so wird nur
     '.     die Anzahl der Cookies im Cookie-Jar
     '.     retourniert.
     '.   - der Nullcookie wird berÅcksichtigt
     '. - Beispiel: Anzeigen der Cookie-Daten
     '.   Anzahl=FN Get_Cookies(0)
     '.   DIM Cookies(Anzahl,1)
     '.   !Get_Cookies!(&Cookies(0,0))
     '.   FOR I=1 TO Anzahl
     '.       PRINT !MKIL$!(Cookies(I,0)),Cookies(I,1)
     '.   NEXT I
     '.
     LOCAL Cjar%L,Anzahl%L
     '
     Cjar%L= LPEEK($5A0)
     Anzahl%L=0
     '
     IF Cjar%L>0 THEN
        Cjar%L-=8
        REPEAT
          Cjar%L+=8
          Anzahl%L+=1
          IF Ptr_Long_Array2_%L>0 THEN
             *Ptr_Long_Array2_%L(Anzahl%L,0)= LPEEK(Cjar%L)
             *Ptr_Long_Array2_%L(Anzahl%L,1)= LPEEK(Cjar%L+4)
          ENDIF
        UNTIL LPEEK(Cjar%L)=0
     ENDIF
     '
     RETURN Anzahl%L
 END_FN
 DEF PROC Get_Cookies(Ptr_Long_Array2_%L)'  [POINTER]
     '. ^Get_Cookies
     '. PROC Get_Cookies(Ptr_Long_Array2)
     '. ---------------------------------------------------
     '. - Typ:
     '.   Prozedur aus !DHSYSTEM.LIB!
     '. - Parameter:
     '.   siehe !FN Get_Cookies!
     '. - Hinweis:
     '.   Diese Prozedur ruft lediglich FN Get_Cookies auf
     '.   und hat keinen RÅckgabewert.
     '.
     LOCAL R%L=FN Get_Cookies%L(Ptr_Long_Array2_%L)
 END_PROC
 '
 '
 '
 ' =============================================================================
 '                                                                     OS-HEADER
 ' =============================================================================
     '.
     '. ^OS-Header-Routinen
     '. ---------------------------------------------------
     '. Die !DHSYSTEM.LIB! bietet einige Routinen zum Lesen
     '. des OS-Header. Dies sind im einzelnen:
     '. - !FN Osheader!
     '. - !FN Os_Entry!
     '. - !FN Os_Version!    !FN Os_Version$!
     '. - !FN Reseth!
     '. - !FN Os_Beg!
     '. - !FN Os_End!
     '. - !FN Os_Rsv1!
     '. - !FN Os_Magic!
     '. - !FN Os_Date!       !FN Os_Date$!
     '. - !FN Os_Conf!
     '. - !FN Os_Dosdate!
     '. - !FN P_Root!
     '. - !FN Pkbshift!
     '. - !FN P_Run!
     '. - !FN P_Rsv2!
     '. - !FN Getrun!
     '.
 DEF FN Osheader%L
     '. ^FN Osheader
     '. R=FN Osheader
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Parameter:
     '.   R: Adresse des OS-Header
     '. - Hinweis:
     '.   siehe auch !OSHEADER-Struktur!
     '.
     RETURN LPEEK($4F2)
 END_FN
 '
 DEF FN Os_Entry%L
     '. ^FN Os_Entry
     '. R=FN Os_Entry
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung von os_entry aus dem OS-Header
     '. - Parameter:
     '.   R: os_entry
     '. - Hinweis:
     '.   siehe auch !OSHEADER-Struktur!
     '.
     '.
     RETURN WPEEK(FN Osheader%L+$0)
 END_FN
 DEF FN Os_Version%L
     '. ^FN Os_Version
     '. R=FN Os_Version
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung von os_version aus dem OS-Header
     '. - Parameter:
     '.   R: os_version
     '. - Hinweise:
     '.   - siehe auch !FN Os_Version$!
     '.   - siehe auch !OSHEADER-Struktur!
     '.
     RETURN WPEEK(FN Osheader%L+$2)
 END_FN
 DEF FN Reseth%L
     '. ^FN Reseth
     '. R=FN Reseth
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung von reseth aus dem OS-Header
     '. - Parameter:
     '.   R: reseth
     '. - Hinweis:
     '.   siehe auch !OSHEADER-Struktur!
     '.
     RETURN LPEEK(FN Osheader%L+$4)
 END_FN
 DEF FN Os_Beg%L
     '. ^FN Os_Beg
     '. R=FN Os_Beg
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung von os_beg aus dem OS-Header
     '. - Parameter:
     '.   R: os_beg
     '. - Hinweis:
     '.   siehe auch !OSHEADER-Struktur!
     '.
     RETURN LPEEK(FN Osheader%L+$8)
 END_FN
 DEF FN Os_End%L
     '. ^FN Os_End
     '. R=FN Os_End
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung von os_end aus dem OS-Header
     '. - Parameter:
     '.   R: os_end
     '. - Hinweis:
     '.   siehe auch !OSHEADER-Struktur!
     '.
     RETURN LPEEK(FN Osheader%L+$C)
 END_FN
 DEF FN Os_Rsv1%L
     '. ^FN Os_Rsv1
     '. R=FN Os_Rsv1
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung von os_rsv1 aus dem OS-Header
     '. - Parameter:
     '.   R: os_rsv1
     '. - Hinweis:
     '.   siehe auch !OSHEADER-Struktur!
     '.
     RETURN LPEEK(FN Osheader%L+$10)
 END_FN
 DEF FN Os_Magic%L
     '. ^FN Os_Magic
     '. R=FN Os_Magic
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung von os_magic aus dem OS-Header
     '. - Parameter:
     '.   R: os_magic
     '. - Hinweis:
     '.   siehe auch !OSHEADER-Struktur!
     '.
     '.
     RETURN LPEEK(FN Osheader%L+$14)
 END_FN
 DEF FN Os_Date%L
     '. ^FN Os_Date
     '. R=FN Os_Date
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung von os_date aus dem OS-Header
     '. - Parameter:
     '.   R: os_date
     '. - Hinweise:
     '.   - siehe auch !FN Os_Date$!
     '.   - siehe auch !OSHEADER-Struktur!
     '.
     RETURN LPEEK(FN Osheader%L+$18)
 END_FN
 DEF FN Os_Conf%L
     '. ^FN Os_Conf
     '. R=FN Os_Conf
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung von os_conf aus dem OS-Header
     '. - Parameter:
     '.   R: os_conf
     '. - Hinweis:
     '.   siehe auch !OSHEADER-Struktur!
     '.
     RETURN WPEEK(FN Osheader%L+$1C)
 END_FN
 DEF FN Os_Dosdate%L
     '. ^FN Os_Dosdate
     '. R=FN Os_Dosdate
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung von os_dosdate aus dem OS-Header
     '. - Parameter:
     '.   R: os_dosdate
     '. - Hinweis:
     '.   siehe auch !OSHEADER-Struktur!
     '.
     RETURN WPEEK(FN Osheader%L+$1E)
 END_FN
 DEF FN P_Root%L
     '. ^FN P_Root
     '. R=FN P_Root
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung von p_root aus dem OS-Header
     '. - Parameter:
     '.   R: p_root
     '. - Hinweis:
     '.   siehe auch !OSHEADER-Struktur!
     '.
     '.
     RETURN LPEEK(FN Osheader%L+$20)
 END_FN
 DEF FN Pkbshift%L
     '. ^FN Pkbshift
     '. R=FN Pkbshift
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung von pkbshift aus dem OS-Header
     '. - Parameter:
     '.   R: pkbshift
     '. - Hinweis:
     '.   siehe auch !OSHEADER-Struktur!
     '.
     '.
     RETURN LPEEK(FN Osheader%L+$24)
 END_FN
 DEF FN P_Run%L
     '. ^FN P_Run
     '. R=FN P_Run
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung von p_run aus dem OS-Header
     '. - Parameter:
     '.   R: p_run
     '. - Hinweise:
     '.   - siehe auch !FN Getrun!
     '.   - siehe auch !OSHEADER-Struktur!
     '.
     RETURN LPEEK(FN Osheader%L+$28)
 END_FN
 DEF FN P_Rsv2%L
     '. ^FN P_Rsv2
     '. R=FN P_Rsv2
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung von p_rsv2 aus dem OS-Header
     '. - Parameter:
     '.   R: p_rsv2
     '. - Hinweis:
     '.   siehe auch !OSHEADER-Struktur!
     '.
     RETURN LPEEK(FN Osheader%L+$2C)
 END_FN
 '
 DEF FN Os_Version$
     '. ^FN Os_Version$
     '. R$=FN Os_Version$
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung der TOS-Versionsnummer
     '. - Parameter:
     '.   R$: formatierter String mit TOS-Versionsnummer
     '.       (z.B. "3.06")
     '. - Hinweise:
     '.   - siehe auch !FN Os_Version!
     '.   - siehe auch !OSHEADER-Struktur!
     '.
     LOCAL V%L,V$
     '
     V%L=FN Os_Version%L
     V$= MID$( HEX$(V%L),2,1)+"."+ RIGHT$( HEX$(V%L),2)
     '
     RETURN V$
 END_FN
 DEF FN Os_Date$
     '. ^FN Os_Date$
     '. R$=FN Os_Date$
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung des TOS-Herstellunsdatums
     '. - Parameter:
     '.   R$: formatierter String mit TOS-Herstellungsdatum
     '.       (z.B. "24.09.1991")
     '. - Hinweise:
     '.   - siehe auch !FN Os_Date!
     '.   - siehe auch !OSHEADER-Struktur!
     '.
     LOCAL D%L,D$
     '
     D%L=FN Os_Date%L
     D$= RIGHT$("00000000"+ MID$( HEX$(D%L),2),8)
     D$= MID$(D$,3,2)+"."+ MID$(D$,1,2)+"."+ MID$(D$,5,4)
     '
     RETURN D$
 END_FN
 '
 DEF FN Getrun%L
     '. ^FN Getrun
     '. R=FN Getrun
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung des Zeigers auf die Basepage des
     '.   gerade aktiven GEMDOS-Prozesses.
     '. - Parameter:
     '.   R: Zeiger auf die Basepage
     '. - Hinweis:
     '.   die Adresse der Basepage erhÑlt man mit
     '.   Addr=LPEEK(FN Getrun)
     '. - Hinweis:
     '.   siehe auch !OSHEADER-Struktur!
     '.
     LOCAL Basebage%L
     '
     IF FN Os_Version%L<$102 THEN
        IF (FN Os_Conf%L SHR 1)=4 THEN
           Basepage%L=$873C
        ELSE
           Basepage%L=$602C
        ENDIF
     ELSE
        Basepage%L=FN P_Run%L
     ENDIF
     '
     RETURN Basepage%L
 END_FN
 '
 '
 '
 ' =============================================================================
 '                                                                      BASEPAGE
 ' =============================================================================
     '.
     '. ^Basepage-Routinen
     '. ---------------------------------------------------
     '. Die !DHSYSTEM.LIB! bietet einige Routinen zum Lesen
     '. der Basepage. Dies sind im einzelnen:
     '. - !FN Basepage!
     '. - !FN P_Lowtpa!
     '. - !FN P_Hitpa!
     '. - !FN P_Tbase!
     '. - !FN P_Tlen!
     '. - !FN P_Dbase!
     '. - !FN P_Dlen!
     '. - !FN P_Bbase!
     '. - !FN P_Blen!
     '. - !FN P_Dta!
     '. - !FN P_Parent!
     '. - !FN P_Resrvd0!
     '. - !FN P_Env!
     '. - !FN P_Resrvd1!     !FN P_Resrvd1$!
     '. - !FN P_Cmdlin!      !FN P_Cmdlin$!
     '.
 DEF FN Basepage%L
     '. ^FN Basepage
     '. R=FN Basepage
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung der Basepage-Adresse des gerade
     '.   aktuellen GEMDOS-Prozesses.
     '. - Parameter:
     '.   R: Adresse
     '. - Hinweise:
     '.   - siehe auch !BASEPAGE-Struktur!
     '.   - R ist identisch mit LPEEK(!FN Getrun!)
     '.
     RETURN LPEEK(FN Getrun%L)
 END_FN
 '
 DEF FN P_Lowtpa%L
     '. ^FN P_Lowtpa
     '. R=FN P_Lowtpa
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung von p_lowtpa aus der Basepage
     '. - Parameter:
     '.   R: p_lowtpa
     '. - Hinweis:
     '.   siehe auch !BASEPAGE-Struktur!
     '.
     RETURN LPEEK(FN Basepage%L+0)
 END_FN
 DEF FN P_Hitpa%L
     '. ^FN P_Hitpa
     '. R=FN P_Hitpa
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung von p_hitpa aus der Basepage
     '. - Parameter:
     '.   R: p_hitpa
     '. - Hinweis:
     '.   siehe auch !BASEPAGE-Struktur!
     '.
     RETURN LPEEK(FN Basepage%L+4)
 END_FN
 DEF FN P_Tbase%L
     '. ^FN P_Tbase
     '. R=FN P_Tbase
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung von p_tbase aus der Basepage
     '. - Parameter:
     '.   R: p_tbase
     '. - Hinweis:
     '.   siehe auch !BASEPAGE-Struktur!
     '.
     RETURN LPEEK(FN Basepage%L+8)
 END_FN
 DEF FN P_Tlen%L
     '. ^FN P_Tlen
     '. R=FN P_Tlen
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung von p_tlen aus der Basepage
     '. - Parameter:
     '.   R: p_tlen
     '. - Hinweis:
     '.   siehe auch !BASEPAGE-Struktur!
     '.
     RETURN LPEEK(FN Basepage%L+12)
 END_FN
 DEF FN P_Dbase%L
     '. ^FN P_Dbase
     '. R=FN P_Dbase
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung von p_dbase aus der Basepage
     '. - Parameter:
     '.   R: p_dbase
     '. - Hinweis:
     '.   siehe auch !BASEPAGE-Struktur!
     '.
     RETURN LPEEK(FN Basepage%L+16)
 END_FN
 DEF FN P_Dlen%L
     '. ^FN P_Dlen
     '. R=FN P_Dlen
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung von p_dlen aus der Basepage
     '. - Parameter:
     '.   R: p_dlen
     '. - Hinweis:
     '.   siehe auch !BASEPAGE-Struktur!
     '.
     RETURN LPEEK(FN Basepage%L+20)
 END_FN
 DEF FN P_Bbase%L
     '. ^FN P_Bbase
     '. R=FN P_Bbase
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung von p_bbase aus der Basepage
     '. - Parameter:
     '.   R: p_bbase
     '. - Hinweis:
     '.   siehe auch !BASEPAGE-Struktur!
     '.
     RETURN LPEEK(FN Basepage%L+24)
 END_FN
 DEF FN P_Blen%L
     '. ^FN P_Blen
     '. R=FN P_Blen
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung von p_blen aus der Basepage
     '. - Parameter:
     '.   R: p_blen
     '. - Hinweis:
     '.   siehe auch !BASEPAGE-Struktur!
     '.
     RETURN LPEEK(FN Basepage%L+28)
 END_FN
 DEF FN P_Dta%L
     '. ^FN P_Dta
     '. R=FN P_Dta
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung von p_dta aus der Basepage
     '. - Parameter:
     '.   R: p_dta
     '. - Hinweis:
     '.   siehe auch !BASEPAGE-Struktur!
     '.
     RETURN LPEEK(FN Basepage%L+32)
 END_FN
 DEF FN P_Parent%L
     '. ^FN P_Parent
     '. R=FN P_Parent
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung von p_parent aus der Basepage
     '. - Parameter:
     '.   R: p_parent
     '. - Hinweis:
     '.   siehe auch !BASEPAGE-Struktur!
     '.
     '.
     RETURN LPEEK(FN Basepage%L+36)
 END_FN
 DEF FN P_Resrvd0%L
     '. ^FN P_Resrvd0
     '. R=FN P_Resrvd0
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung von p_resrvd0 aus der Basepage
     '. - Parameter:
     '.   R: p_resrvd0
     '. - Hinweis:
     '.   siehe auch !BASEPAGE-Struktur!
     '.
     RETURN LPEEK(FN Basepage%L+40)
 END_FN
 DEF FN P_Env%L
     '. ^FN P_Env
     '. R=FN P_Env
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung von p_env aus der Basepage
     '. - Parameter:
     '.   R: p_env
     '. - Hinweis:
     '.   siehe auch !BASEPAGE-Struktur!
     '.
     RETURN LPEEK(FN Basepage%L+44)
 END_FN
 DEF FN P_Resrvd1%L
     '. ^FN P_Resrvd1
     '. R=FN P_Resrvd1
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung von p_resrvd1 aus der Basepage
     '. - Parameter:
     '.   R: p_resrvd1
     '. - Hinweis:
     '.   - siehe auch: !FN P_Resrvd1$!
     '.   - siehe auch !BASEPAGE-Struktur!
     '.
     RETURN FN Basepage%L+80
 END_FN
 DEF FN P_Cmdlin%L
     '. ^FN P_Cmdlin
     '. R=FN P_Cmdlin
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung von p_cmdlin aus der Basepage
     '. - Parameter:
     '.   R: p_cmdlin
     '. - Hinweis:
     '.   - siehe auch: !FN P_Cmdlin$!
     '.   - siehe auch !BASEPAGE-Struktur!
     '.
     RETURN FN Basepage%L+128
 END_FN
 '
 DEF FN P_Resrvd1$
     '. ^FN P_Resrvd1$
     '. R$=FN P_Resrvd1$
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung des reservierten Strings aus der
     '.   Basepage des gerade aktiven GEMDOS-Prozesses
     '. - Parameter:
     '.   R$: reservierter String aus der Basepage
     '. - Hinweis:
     '.   siehe auch !BASEPAGE-Struktur!
     '.
     LOCAL R$,I%L,Resrvd1%L
     '.
     Resrvd1%L=FN Basepage%L+80
     R$=""
     FOR I%L=1 TO 80
         R$=R$+ CHR$( PEEK(Resrvd1%L+I%L-1))
     NEXT I%L
     RETURN R$
 END_FN
 DEF FN P_Cmdlin$
     '. ^FN P_Cmdlin$
     '. R$=FN P_Cmdlin$
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung der dem aktuellen GEMDOS-Prozess
     '.   Åbergebenen Kommandozeile aus der Basepage.
     '. - Parameter:
     '.   R$: String mit Kommadozeile
     '. - Hinweis:
     '.   - Der String wird nicht bearbeitet, d.h. daû das
     '.     LÑngenbyte noch entfernt und das Ende der
     '.     Kommandozeile ermittelt werden muû.
     '.   - siehe auch !BASEPAGE-Struktur!
     '.
     LOCAL C$,I%L,Cmdlin%L
     '
     Cmdlin%L=FN Basepage%L+128
     C$=""
     FOR I%L=1 TO 128
         C$=C$+ CHR$( PEEK(Cmdlin%L+I%L-1))
     NEXT I%L
     RETURN C$
 END_FN
 '
 '
 DEF PROC Set_P_Cmdlin(C$)
     '. ^Set_P_Cmdlin$
     '. PROC Set_P_Cmdlin$(C$)
     '. ---------------------------------------------------
     '. - Typ:
     '.   Prozedur aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Setzen der Kommandozeile in der Basepage des
     '.   aktiven GEMDOS-Prozesses
     '. - Parameter:
     '.   C$: String mit Kommadozeile
     '. - Hinweis:
     '.   - Der String darf nicht lÑnger als 124 Zeichen
     '.     sein und wird - falls doch lÑnger - rigoros
     '.     abgeschnitten.
     '.   - Der String wird den nîtigen Anforderungen
     '.     automatisch angepaût, d.h. in das erste Byte
     '.     wird die LÑnge des Strings eingetragen.
     '.   - siehe auch !BASEPAGE-Struktur!
     '.
     LOCAL I%L,Cmdlin%L
     '
     Cmdlin%L=FN Basepage%L+128
     C$= LEFT$(C$,123)
     C$= CHR$( LEN(C$))+C$
     FOR I%L=1 TO LEN(C$)
         POKE Cmdlin%L+I%L-1, ASC( MID$(C$,I%L,1))
     NEXT I%L
     '
 END_PROC
 '
 '
 '
 ' =============================================================================
 '                                                                   COMMANDLINE
 ' =============================================================================
     '.
     '. ^Commandline-Routinen
     '. ---------------------------------------------------
     '. Die !DHSYSTEM.LIB! bietet zwei Routinen zum
     '. komfortablen Bearbeiten der Commandline. Die Namen
     '. der Routinen wurden angelehnt an identische
     '. Routinen aus Pure Pascal. Dies sind:
     '. - !FN Param_Count!
     '. - !FN Param_Str$!
     '.
 DEF FN Param_Count%L
     '. ^FN Param_Count
     '. R=FN Param_Count
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung der Anzahl der Parameter, die dem
     '.   Programm Åber die Kommadozeile Åbergeben wurden.
     '. - Parameter:
     '.   R: Anzahl der Commadline-Parameter
     '. - Hinweis:
     '.   - Das ARGV-Verfahren wird unterstÅtzt
     '.
     '.
     ' --VARIABLEN--------------------------------------------------------------
     ' Cmd$   : Kommandozeile aus der Basepage
     ' Cmd_Len: LÑnge der Kommandozeile (127 -> ARGV)
     ' Count  : ZÑhler und RÅckgabewert
     ' -------------------------------------------------------------------------
     '
     LOCAL Argv$,Cmd$,Count%L,Cmd_Len%L,I%L,Char%L
     '
     Cmd$=FN P_Cmdlin$'          Kommandozeile aus Basepage lesen
     Cmd_Len%L= ASC( LEFT$(Cmd$,1))'   LÑnge ermitteln
     Count%L=0
     '
     IF Cmd_Len%L>0 THEN
        '
        ' ARGV im Environment suchen
        '
        Argv$=FN Get_Env_String$("ARGV=")
        '
        IF LEN(Argv$) THEN
           IF Cmd_Len%L=127 THEN
              ' Kommandos werden mittels ARGV-Verfahren Åbergeben
              ' Das Ende der Kommandozeile besteht aus 2 Nullbytes.
              ' Zum ZÑhlen der Kommandos reicht das ZÑhlen der
              ' einzelnen Nullbytes. Achtung: argv(0) ist der Programmname
              '
              ' Argv$ kommt ohne Nullbyte am Ende!
              Argv$=Argv$+ CHR$(0)
              '
              ' ARGV= entfernen
              Cmd$= MID$(Argv$, INSTR(Argv$, CHR$(0))+1)
              '
              ' nur ASCII(0) ist Kommandotrenner
              Count%L=-1' Der nullte Parameter ist ja der Programmpfad
              FOR I%L=1 TO LEN(Cmd$)
                 IF ASC( MID$(Cmd$,I%L,1))=0 THEN Count%L+=1
              NEXT I%L
           ENDIF
        ELSE
           ' normale öbergabe der Kommandozeile
           ' erstmal das LÑngenbyte abschneiden. Das Nullbyte am
           ' Ende wird noch benîtigt.
           Cmd$= MID$(Cmd$,2)
           '
           ' ASCII(32) (Leerzeichen) ist Kommandotrenner
           ' ASCII(0) steht hinter dem letzen Kommando
           I%L=0
           Count%L=0
           REPEAT
              I%L+=1
              Char%L= ASC( MID$(Cmd$,I%L,1))
              IF Char%L=32 OR Char%L=0 THEN Count%L+=1
           UNTIL Char%L=0
        ENDIF
     ENDIF
     '
     RETURN Count%L
 END_FN
 DEF FN Param_Str$(Which%L)
     '. ^FN Param_Str$
     '. R$=FN Param_Str$(X)
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung des x. Kommandozeilen-Parameter
     '. - Parameter:
     '.   X:  Nummer des Commadline-Parameters
     '.   R$: String mit diesem Parameter bzw. Leerstring,
     '.       wenn nicht soviele Parameter in der
     '.       Commandline Åbergeben wurden.
     '. - Hinweis:
     '.   Das ARGV-Verfahren wird unterstÅtzt.
     '.
     '.
     ' --VARIABLEN--------------------------------------------------------------
     ' Cmd$   : Kommandozeile aus der Basepage
     ' Cmd_Len: LÑnge der Kommandozeile (127 -> ARGV)
     ' Count  : ZÑhler
     ' Ps$    : gefundenes Kommando
     ' -------------------------------------------------------------------------
     '
     LOCAL Argv$,Cmd$,Count%L,Cmd_Len%L,I%L,Ps$,Found%L
     '
     Cmd$=FN P_Cmdlin$'          Kommandozeile aus Basepage lesen
     Cmd_Len%L= ASC( LEFT$(Cmd$,1))'   LÑnge ermitteln
     Count%L=0
     Ps$=""
     '
     IF Cmd_Len%L>0 THEN
        '
        ' ARGV im Environment suchen
        '
        Argv$=FN Get_Env_String$("ARGV=")
        '
        IF LEN(Argv$) THEN
           IF Cmd_Len%L=127 THEN
              ' Kommandos werden mittels ARGV-Verfahren Åbergeben
              ' Das Ende der Kommandozeile besteht aus 2 Nullbytes.
              ' Zum ZÑhlen der Kommandos reicht das ZÑhlen der
              ' einzelnen Nullbytes. Achtung: argv(0) ist der Programmname
              '
              ' Argv$ kommt als "ARGV=.PROGRAMM.K1.K2" ohne Nullbyte am Ende!
              Argv$=Argv$+ CHR$(0)
              '
              ' "ARGV=" entfernen
              Cmd$= MID$(Argv$, INSTR(Argv$, CHR$(0))+1)
              '
              ' nur ASCII(0) ist Kommandotrenner
              Count%L=-1' Sorgt dafÅr, daû in Param_Str$(0) der Programmpfad steht
              Ps$=""
              FOR I%L=1 TO LEN(Cmd$)
                 Char%L= ASC( MID$(Cmd$,I%L,1))
                 IF Char%L=0 THEN
                    Count%L+=1
                    IF Count%L<>Which%L THEN
                       Ps$=""
                    ELSE
                       Found%L=-1
                       EXIT
                    ENDIF
                 ELSE
                    Ps$=Ps$+ CHR$(Char%L)
                 ENDIF
              NEXT I%L
              '
              IF Found%L=0 THEN Ps$=""
           ENDIF
        ELSE
           ' normale öbergabe der Kommandozeile
           ' erstmal das LÑngenbyte abschneiden. Das Nullbyte am
           ' Ende wird noch benîtigt.
           Cmd$= MID$(Cmd$,2)
           '
           ' ASCII(32) (Leerzeichen) ist Kommandotrenner
           I%L=0
           Count%L=0
           REPEAT
              I%L+=1
              Char%L= ASC( MID$(Cmd$,I%L,1))
              IF Char%L=32 OR Char%L=0 THEN
                 Count%L+=1
                 IF Count%L<>Which%L THEN
                    Ps$=""
                 ELSE
                    Found%L=-1
                 ENDIF
              ELSE
                 Ps$=Ps$+ CHR$(Char%L)
              ENDIF
           UNTIL Count%L>=Which%L
        ENDIF
     ENDIF
     '
     RETURN Ps$
 END_FN
 '
 '
 '
 ' =============================================================================
 '                                                                   ENVIRONMENT
 ' =============================================================================
     '.
     '. ^Environment-Routinen
     '. ---------------------------------------------------
     '. Die !DHSYSTEM.LIB! bietet zwei Routinen zum
     '. komfortablen Auslesen der Environment-Strings:
     '. - !FN Get_Env_Strings!
     '. - !FN Get_Env_String$!
     '
 DEF FN Get_Env_Strings%L(Ptr_String_Array_%L)'  [POINTER]
     '. ^FN Get_Env_Strings
     '. R=FN Get_Env_Strings(Ptr_String_Array)
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung der Environment-Strings aus der
     '.   Basepage des gerade aktiven GEMDOS-Prozesses.
     '. - Parameter:
     '.   Ptr_String_Array: Pointer auf ein String-Array
     '.   R:                Anzahl der vorhandenen
     '.                     Environment-Strings
     '. - Hinweise:
     '.   - Wird ein Nullpointer Åbergeben, so wird nur die
     '.     Anzahl der Environment-Strings zurÅckgeliefert.
     '.   - UnterstÅtzung des ARGV-Verfahrens
     '. - Beispiel: Environment-Strings ausgeben
     '.   Anzahl = FN Get_Env_Strings(0)
     '.   DIM Env$(Anzahl)
     '.   Anzahl = FN Get_Env_Strings(&Env$(0))
     '.   FOR I=1 TO Anzahl
     '.       PRINT Env$(i)
     '.   NEXT i
     '.
     LOCAL Env%L,S$,Anzahl%L,Flag%L
     '
     Env%L=FN P_Env%L'                         Adresse aus der Basepage auslesen
     Anzahl%L=0
     Flag%L=0
     '
     IF Env%L>0 THEN
        REPEAT
          Anzahl%L+=1
          '
          S$=""
          '
          ' Die Environment-Variable "ARGV" bekommt eine Sonderbehandlung,
          ' da beim ARGV-Verfahren die Kommandos durch Nullbytes getrennt
          ' werden. Ansonsten wÅrden zuviele Strings erkannt!
          '
          WHILE PEEK(Env%L)>0 OR ( LEFT$(S$,4)="ARGV" AND PEEK(Env%L)=0 AND PEEK(Env%L+1)>0)
            S$=S$+ CHR$( PEEK(Env%L))
            Env%L+=1
          WEND
          IF Ptr_String_Array_%L>0 THEN *Ptr_String_Array_$(Anzahl%L)=S$
          IF PEEK(Env%L+1)=0 THEN
             Flag%L=-1
          ELSE
             Env%L+=1
          ENDIF
          '
        UNTIL Flag%L
     ENDIF
     '
     RETURN Anzahl%L
 END_FN
 DEF FN Get_Env_String$(Env$)
     '. ^FN Get_Env_String$
     '. R$=FN Get_Env_String$(Env$)
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Sucht einen Environment-String und liefert
     '.   diesen zurÅck.
     '. - Parameter:
     '.   Env$: zu suchender Environment-String
     '.         (z.B. "PATH=")
     '.   R$:   gefundener String bzw. Leerstring, wenn
     '.         der Environment-String nicht vorhanden
     '.         ist.
     '.
     LOCAL Env%L,S$,Found$,Flag%L,String_Len%L,Argv_Flag%L
     '
     Env%L=FN P_Env%L'                         Adresse aus der Basepage auslesen
     Found$=""
     Flag%L=0
     S$=""
     Argv_Flag%L=0
     String_Len%L= LEN(Env$)
     '
     IF Env%L>0 AND String_Len%L>0 THEN
        REPEAT
          '
          S$=""
          '
          ' Die Environment-Variable "ARGV" bekommt eine Sonderbehandlung,
          ' da beim ARGV-Verfahren die Kommandos durch Nullbytes getrennt
          ' werden. Ansonsten wÅrden zuviele Strings erkannt!
          '
          WHILE PEEK(Env%L)>0 OR ( LEFT$(S$,4)="ARGV" AND PEEK(Env%L)=0 AND PEEK(Env%L+1)>0)
            S$=S$+ CHR$( PEEK(Env%L))
            Env%L+=1
          WEND
          '
          IF LEFT$(S$,String_Len%L)=Env$ THEN
             Found$=S$
             Flag%L=-1
          ENDIF
          '
          IF PEEK(Env%L+1)=0 THEN
             Flag%L=-1
          ELSE
             Env%L+=1
          ENDIF
          '
        UNTIL Flag%L
     ENDIF
     '
     RETURN Found$
 END_FN
 '
 '
 '
 ' =============================================================================
 '                                                                          XBRA
 ' =============================================================================
     '.
     '. ^XBRA-Routinen
     '. ---------------------------------------------------
     '. Die !DHSYSTEM.LIB! bietet zwei Routinen zum
     '. komfortablen Auslesen der XBRA-Kennungen:
     '. - !FN Get_Xbra!
     '. - !Get_Xbra!
     '
 DEF FN Get_Xbra%L(Ptr_Long_Array2_%L)'    [POINTER]
     '. ^FN Get_Xbra
     '. R=FN Get_Xbra(Ptr_Long_Array2)
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ermittlung aller XBRA-Kennungen und deren Werte.
     '. - Parameter:
     '.   Ptr_Long_Array2: Pointer auf ein zweidimensio-
     '.                    nales Longinteger-Array
     '.   R:               Anzahl der XBRA-Kennungen
     '. - Hinweise:
     '.   - siehe auch !XBRA-Struktur!
     '.   - Wird ein Nullpointer Åbergeben, so wird nur die
     '.     Anzahl der vorhandenen XBRA-Kennungen ermittelt
     '.   - Die XBRA-Werte werden folgendermaûen in das
     '.     Array eingetragen (I=Index):
     '.     *Ptr_Long_Array(I,0): Adresse des geÑnderten
     '.                           Vektors
     '.     *Ptr_Long_Array(I,1): XBRA-Kennung
     '.     *Ptr_Long_Array(I,2): ursprÅnglicher Wert des
     '.                           geÑnderten Vektors
     '.     *Ptr_Long_Array(I,3): jetziger Vektor-Wert
     '. - Beispiel: Ausgabe der XBRA-Kennungen
     '.   Anzahl=FN Get_Xbra(0)
     '.   DIM Xbra(Anzahl,3)
     '.   Get_Xbra(&Xbra(0,0))
     '.   FOR I=1 TO Anzahl
     '.       PRINT "Adresse     :",Xbra(I,0)
     '.       PRINT "XBRA-Kennung:", MKIL$(Xbra(I,1))
     '.       PRINT "ursprÅnglich:",Xbra(I,2)
     '.       PRINT "jetzt     '  :",Xbra(I,3)
     '.   NEXT I
     '.
     '
     ' --VARIABLEN--------------------------------------------------------------
     ' Anzahl : ZÑhler fÅr XBRA-Kenungen
     ' Membot : Unteres Ende des unter GEMDOS freien ST-Kompatiblen Speichers
     ' Memtop : Analog das obere Ende
     ' Pointer: Zeiger auf Vektorroutine
     ' -------------------------------------------------------------------------
     '
     LOCAL Addr%L,Pointer%L,Anzahl%L,Membot%L,Memtop%L
     '
     Anzahl%L=0
     Membot%L= LPEEK($432)
     Memtop%L= LPEEK($436)
     '
     FOR Addr%L=$8 TO $1BC STEP 4
         Pointer%L= LPEEK(Addr%L)
         IF Pointer%L>Membot%L AND Pointer%L<Memtop%L THEN
            IF MKIL$( LPEEK(Pointer%L-12))="XBRA" THEN
               Anzahl%L+=1
               IF Ptr_Long_Array2_%L>0 THEN
                  *Ptr_Long_Array2_%L(Anzahl%L,0)=Addr%L'               verÑnderter Vektor
                  *Ptr_Long_Array2_%L(Anzahl%L,1)= LPEEK(Pointer%L-8)'  XBRA-Kennung
                  *Ptr_Long_Array2_%L(Anzahl%L,2)= LPEEK(Pointer%L-4)'  ursprÅnglicher Wert des Vektors
                  *Ptr_Long_Array2_%L(Anzahl%L,3)= LPEEK(Addr%L)'       jetziger Wert des Vektors
               ENDIF
            ENDIF
         ENDIF
     NEXT Addr%L
     '
     RETURN Anzahl%L
 END_FN
 DEF PROC Get_Xbra(Ptr_Long_Array2_%L)'  [POINTER]
     '. ^Get_Xbra
     '. PROC Get_Xbra(Ptr_Long_Array2)
     '. ---------------------------------------------------
     '. - Typ:
     '.   Prozedur aus !DHSYSTEM.LIB!
     '. - Hinweis:
     '.   Aufgabe und ParameterÅbergabe identisch mit
     '.   !FN Get_Xbra!.
     '.
     LOCAL R%L=FN Get_Xbra%L(Ptr_Long_Array2_%L)
 END_PROC
 '
 '
 '
 ' =============================================================================
 '                                                               SYSTEMVARIABLEN
 ' =============================================================================
     '.
     '. ^Systemvariablen-Routinen
     '. ---------------------------------------------------
     '. Die !DHSYSTEM.LIB! liefert einige Funktionen, um
     '. Systemvariablen des Betriebssystems zu ermitteln.
     '. Die Namen der Funktionen lauten jeweils
     '. Sys_SYSVAR, wobei SYSVAR fÅr den Namen der
     '. jeweiligen Systemvariablen steht.
     '. Der Inhalt der Systemvariablen etv_timer lÑût sich
     '. somit mittels R=FN Sys_Etv_Timer ermitteln.
     '. Auf eine Auflistung aller Routinen wurde aus
     '. PlatzgrÅnden hier verzichtet.
     '.
 DEF FN Sys_Etv_Timer%L = LPEEK($400)
 DEF FN Sys_Etv_Critic%L = LPEEK($404)
 DEF FN Sys_Etv_Term%L = LPEEK($408)
 DEF FN Sys_Etv_Xtra%L = LPEEK($40C)
 DEF FN Sys_Memvalid%L = LPEEK($420)
 DEF FN Sys_Memcntrl%L = PEEK($424)
 DEF FN Sys_Resvalid%L = LPEEK($426)
 DEF FN Sys_Resvector%L = LPEEK($42A)
 DEF FN Sys_Phystop%L = LPEEK($42E)
 DEF FN Sys__Membot%L = LPEEK($432)
 DEF FN Sys__Memtop%L = LPEEK($436)
 DEF FN Sys_Memval2%L = LPEEK($43A)
 DEF FN Sys_Flock%L = WPEEK($43E)
 DEF FN Sys_Seekrate%L = WPEEK($440)
 DEF FN Sys__Timr_Ms%L = WPEEK($442)
 DEF FN Sys__Fverify%L = WPEEK($444)
 DEF FN Sys__Bootdev%L = WPEEK($446)
 DEF FN Sys_Palmode%L = WPEEK($448)
 DEF FN Sys_Defshiftmd%L = PEEK($44A)
 DEF FN Sys_Sshiftmd%L = PEEK($44C)
 DEF FN Sys__V_Bas_Ad%L = LPEEK($44E)
 DEF FN Sys_Vblsem%L = WPEEK($452)
 DEF FN Sys_Nvbls%L = WPEEK($454)
 DEF FN Sys__Vblqueue%L = LPEEK($456)
 DEF FN Sys_Colorptr%L = LPEEK($45A)
 DEF FN Sys_Screenpt%L = LPEEK($45E)
 DEF FN Sys__Vblock%L = LPEEK($462)
 DEF FN Sys__Frclock%L = LPEEK($466)
 DEF FN Sys_Hdv_Init%L = LPEEK($46A)
 DEF FN Sys_Swv_Vec%L = LPEEK($46E)
 DEF FN Sys_Hdv_Bpb%L = LPEEK($472)
 DEF FN Sys_Hdv_Rw%L = LPEEK($476)
 DEF FN Sys_Hdv_Boot%L = LPEEK($47A)
 DEF FN Sys_Hdv_Mediach%L = LPEEK($47E)
 DEF FN Sys__Cmdload%L = WPEEK($482)
 DEF FN Sys_Conterm%L = PEEK($484)
 DEF FN Sys_Trp14ret%L = LPEEK($486)
 DEF FN Sys_Criticret%L = LPEEK($48A)
 DEF FN Sys_Themd%L = LPEEK($48E)
 DEF FN Sys____Md%L = LPEEK($49E)
 DEF FN Sys_Savptr%L = LPEEK($4A2)
 DEF FN Sys__Nflops%L = WPEEK($4A6)
 DEF FN Sys_Con_State%L = LPEEK($4A8)
 DEF FN Sys_Sav_Row%L = WPEEK($4AC)
 DEF FN Sys_Sav_Context%L = LPEEK($4AE)
 DEF FN Sys__Bufl%L = LPEEK($4B2)
 DEF FN Sys__Hz_200%L = LPEEK($4BA)
 DEF FN Sys_The_Env%L = LPEEK($4BE)
 DEF FN Sys__Drvbits%L = LPEEK($4C2)
 DEF FN Sys__Dskbufp%L = LPEEK($4C6)
 DEF FN Sys__Autopath%L = LPEEK($4CA)
 DEF FN Sys__Vbl_List%L = LPEEK($4CE)
 DEF FN Sys_Prt_Cnt%L = WPEEK($4EE)
 DEF FN Sys__Prtabt%L = WPEEK($4F0)
 DEF FN Sys__Sysbase%L = LPEEK($4F2)
 DEF FN Sys__Shell_P%L = LPEEK($4F6)
 DEF FN Sys_End_Os%L = LPEEK($4FA)
 DEF FN Sys_Exec_Os%L = LPEEK($4FE)
 DEF FN Sys_Scr_Dump%L = LPEEK($502)
 DEF FN Sys_Prv_Lsto%L = LPEEK($506)
 DEF FN Sys_Prv_Lst%L = LPEEK($50A)
 DEF FN Sys_Prv_Auxo%L = LPEEK($50E)
 DEF FN Sys_Prv_Aux%L = LPEEK($512)
 DEF FN Sys_Pun_Ptr%L = LPEEK($516)
 DEF FN Sys_Memval3%L = LPEEK($51A)
 DEF FN Sys_Xconstat%L = LPEEK($51E)
 DEF FN Sys_Xconin%L = LPEEK($53E)
 DEF FN Sys_Xcostat%L = LPEEK($55E)
 DEF FN Sys_Xconout%L = LPEEK($57E)
 DEF FN Sys__Longframe%L = WPEEK($59E)
 DEF FN Sys__P_Cookies%L = LPEEK($5A0)
 DEF FN Sys_Ramtop%L = LPEEK($5A4)
 DEF FN Sys_Bell_Hook%L = LPEEK($5AC)
 DEF FN Sys_Kcl_Hook%L = LPEEK($5B0)
 '
 '
 '
 ' =============================================================================
 '                                                                 SHELL-COMMAND
 ' =============================================================================
     '.
     '. ^Shell-Routinen
     '. ---------------------------------------------------
     '. Die !DHSYSTEM.LIB! bietet eine Routine, mit der man
     '. ein Kommado an eine TOS-Shell Åbergeben kann:
     '. - !FN System!
     '.
 DEF FN System%L(Cmd$)
     '. ^FN System
     '. R=FN System(Cmd$)
     '. ---------------------------------------------------
     '. - Typ:
     '.   Funktion aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Das Kommado Cmd$ wird an eine TOS-Shell Åbergeben
     '.   und von dieser ausgefÅhrt. Die Shell sollte sich
     '.   in _shell_p installiert haben.
     '. - Parameter:
     '.   Cmd$<>"": Cdm$ enthÑlt ein Kommando, welches an
     '.             eine installierte TOS-Shell Åbergeben
     '.             wird.
     '.          R: RÅckgabewert der Shell aus Register D0
     '.             bzw. -1, wenn keine Shell vorhanden
     '.             ist.
     '.    Cmd$="": Es wird lediglich getestet, ob eine
     '.             TOS-Shell vorhanden ist.
     '.          R:  TRUE: TOS-Shell vorhanden
     '.             FALSE: keine TOS-Shell vorhanden
     '. - Hinweis:
     '.   siehe auch !FN Sys__Shell_P!
     '. - Beispiele:
     '.   -  IF FN System("") THEN
     '.         PRINT "Shell installiert."
     '.      ELSE
     '.         PRINT "Keine Shell installiert"
     '.      ENDIF
     '.   -  Result=FN System("ls -l")
     '.
     LOCAL R%L,Do_Sys%L
     '
     ' FÅhrt ein Kommando Åber eine in _shell_p installierte Shell aus
     '
     ' Cmd$="": TRUE wird retouriniert, falls _shell_p gesetzt ist
     ' Sonst  : Aufruf der Shell-Routine mit öbergabe des Kommandos.
     '          Retourniert wird Register D0
     '
     Do_Sys%L= LPEEK($4F6)' _shell_p
     '
     IF Cmd$="" THEN
        R%L=(Do_Sys%L<>0)
     ELSE
        IF Do_Sys%L<>0 THEN
           Cmd$=Cmd$+ CHR$(0)
           Ptr_Cmd%L= LPEEK( VARPTR(Cmd$))+ LPEEK( SEGPTR +28)
           CALL Do_Sys%L(L Ptr_Cmd%L)
           R%L= LPEEK( RESERVED(0))
        ELSE
           R%L=-1
        ENDIF
     ENDIF
     '
     RETURN R%L
 END_FN
 '
 '
 '
 ' =============================================================================
 '                                                                VT52-KOMMANDOS
 ' =============================================================================
     '.
     '. ^VT52-Routinen
     '. ---------------------------------------------------
     '. Die !DHSYSTEM.LIB! bietet Routinen zum Aufruf von
     '. VT52-Routinen. Die Ausgabe der VT52-Befehle erfolgt
     '. mittels Cconout() Åber das GEMDOS auf standard
     '. output!
     '. - !Vt52_Cursor_Up!
     '. - !Vt52_Cursor_Down!
     '. - !Vt52_Cursor_Forward!
     '. - !Vt52_Cursor_Backward!
     '. - !Vt52_Clear_Screen!
     '. - !Vt52_Home_Cursor!
     '. - !Vt52_Reverse_Index!
     '. - !Vt52_Erase_To_End_Of_Page!
     '. - !Vt52_Clear_To_End_Of_Line!
     '. - !Vt52_Insert_Line!
     '. - !Vt52_Delete_Line!
     '. - !Vt52_Position_Cursor!
     '. - !Vt52_Set_Foreground_Color!
     '. - !Vt52_Set_Background_Color!
     '. - !Vt52_Erase_Beginning_Of_Display!
     '. - !Vt52_Enable_Cursor!
     '. - !Vt52_Disable_Cursor!
     '. - !Vt52_Save_Current_Position!
     '. - !Vt52_Restore_Current_Position!
     '. - !Vt52_Erase_Entire_Line!
     '. - !Vt52_Erase_Beginning_Of_Line!
     '. - !Vt52_Enter_Reverse_Video_Mode!
     '. - !Vt52_Exit_Reverse_Video_Mode!
     '. - !Vt52_Wrap_At_End_Of_Line!
     '. - !Vt52_Discard_At_End_Of_Line!
     '.
 DEF PROC Vt52_Out_My_(Out$)
     ' Ausgabe mittels Cconout (GEMDOS 2) - Write character to standard output
     LOCAL R%L,I%L
     Out$= CHR$(27)+Out$
     FOR I%L=1 TO LEN(Out$)
         GEMDOS (R%L,2, ASC( MID$(Out$,I%L,1)))
     NEXT I%L
 END_PROC
 '
 DEF PROC Vt52_Cursor_Up
     '. ^Vt52_Cursor_Up
     '. PROC Vt52_Cursor_Up
     '. ---------------------------------------------------
     '. - Typ:
     '.   Prozedur aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Cursor um eine Zeile nach oben bewegen
     '.
     Vt52_Out_My_("A")
 END_PROC
 DEF PROC Vt52_Cursor_Down
     '. ^Vt52_Cursor_Down
     '. PROC Vt52_Cursor_Down
     '. ---------------------------------------------------
     '. - Typ:
     '.   Prozedur aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Cursor um eine Zeile nach unten bewegen
     '.
     Vt52_Out_My_("B")
 END_PROC
 DEF PROC Vt52_Cursor_Forward
     '. ^Vt52_Cursor_Forward
     '. PROC Vt52_Cursor_Forward
     '. ---------------------------------------------------
     '. - Typ:
     '.   Prozedur aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Cursor um eine Spalte nach links bewegen
     '.
     Vt52_Out_My_("C")
 END_PROC
 DEF PROC Vt52_Cursor_Backward
     '. ^Vt52_Cursor_Backward
     '. PROC Vt52_Cursor_Backward
     '. ---------------------------------------------------
     '. - Typ:
     '.   Prozedur aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Cursor um eine Spalte nach links bewegen
     '.
     Vt52_Out_My_("D")
 END_PROC
 DEF PROC Vt52_Clear_Screen
     '. ^Vt52_Clear_Screen
     '. PROC Vt52_Clear_Screen
     '. ---------------------------------------------------
     '. - Typ:
     '.   Prozedur aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Bildschirm lîschen und Cursor in die linke obere
     '.   Ecke bewegen.
     '.
     Vt52_Out_My_("E")
 END_PROC
 DEF PROC Vt52_Home_Cursor
     '. ^Vt52_Home_Cursor
     '. PROC Vt52_Home_Cursor
     '. ---------------------------------------------------
     '. - Typ:
     '.   Prozedur aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Cursor in die linke obere Ecke setzen
     '.
     Vt52_Out_My_("H")
 END_PROC
 DEF PROC Vt52_Reverse_Index
     '. ^Vt52_Reverse_Index
     '. PROC Vt52_Reverse_Index
     '. ---------------------------------------------------
     '. - Typ:
     '.   Prozedur aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Cursor eine Zeile nach oben bewegen. Wenn der
     '.   Cursor bereits in der obersten Zeile war, dann
     '.   wird der Rest des Bildschirms nach unten ver-
     '.   schoben.
     '.
     Vt52_Out_My_("I")
 END_PROC
 DEF PROC Vt52_Erase_To_End_Of_Page
     '. ^Vt52_Erase_To_End_Of_Page
     '. PROC Vt52_Erase_To_End_Of_Page
     '. ---------------------------------------------------
     '. - Typ:
     '.   Prozedur aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Lîschen des Bildschirms ab der Cursorposition.
     '.
     Vt52_Out_My_("J")
 END_PROC
 DEF PROC Vt52_Clear_To_End_Of_Line
     '. ^Vt52_Clear_To_End_Of_Line
     '. PROC Vt52_Clear_To_End_Of_Line
     '. ---------------------------------------------------
     '. - Typ:
     '.   Prozedur aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Restliche Zeile ab Cursorposition lîschen.
     '.
     Vt52_Out_My_("K")
 END_PROC
 DEF PROC Vt52_Insert_Line
     '. ^Vt52_Insert_Line
     '. PROC Vt52_Insert_Line
     '. ---------------------------------------------------
     '. - Typ:
     '.   Prozedur aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   FÅgt eine Zeile an der aktuellen Cursorposition
     '.   ein und schiebt den Rest des Bildschirms nach
     '.   unten. Der Cursor springt an den Anfang der
     '.   eingefÅgten Zeile.
     '.
     Vt52_Out_My_("L")
 END_PROC
 DEF PROC Vt52_Delete_Line
     '. ^Vt52_Delete_Line
     '. PROC Vt52_Delete_Line
     '. ---------------------------------------------------
     '. - Typ:
     '.   Prozedur aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Lîschen der Zeile, in der sich der Cursor
     '.   befindet. Der Rest des Bildschirm wird nach rÅckt
     '.   nach oben auf.
     '.
     Vt52_Out_My_("M")
 END_PROC
 DEF PROC Vt52_Position_Cursor(X%L,Y%L)
     '. ^Vt52_Position_Cursor
     '. PROC Vt52_Position_Cursor(X,Y)
     '. ---------------------------------------------------
     '. - Typ:
     '.   Prozedur aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Positioniert den Cursor in Spalte X und Zeile Y.
     '. - Parameter:
     '.   X,Y: [0..224]
     '. - Hinweis:
     '.   Die Erhîhung um 32 wird automatisch vorgenommen.
     '.
     Vt52_Out_My_("Y"+ CHR$(32+Y%L)+ CHR$(32+X%L))
 END_PROC
 DEF PROC Vt52_Set_Foreground_Color(C%L)
     '. ^Vt52_Set_Foreground_Color
     '. PROC Vt52_Set_Foreground_Color(C)
     '. ---------------------------------------------------
     '. - Typ:
     '.   Prozedur aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Setzen der Schriftfarbe.
     '.
     Vt52_Out_My_("b"+ CHR$(C%L))
 END_PROC
 DEF PROC Vt52_Set_Background_Color(C%L)
     '. ^Vt52_Set_Background_Color
     '. PROC Vt52_Set_Background_Color(C)
     '. ---------------------------------------------------
     '. - Typ:
     '.   Prozedur aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Setzen der Hintergrundfarbe.
     '.
     Vt52_Out_My_("c"+ CHR$(C%L))
 END_PROC
 DEF PROC Vt52_Erase_Beginning_Of_Display
     '. ^Vt52_Erase_Beginning_Of_Display
     '. PROC Vt52_Erase_Beginning_Of_Display
     '. ---------------------------------------------------
     '. - Typ:
     '.   Prozedur aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Lîschen des Bildschirms bis zur aktuellen Cursor-
     '.   position.
     '.
     Vt52_Out_My_("d")
 END_PROC
 DEF PROC Vt52_Enable_Cursor
     '. ^Vt52_Enable_Cursor
     '. PROC Vt52_Enable_Cursor
     '. ---------------------------------------------------
     '. - Typ:
     '.   Prozedur aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Schaltet den Cursor ein.
     '.
     Vt52_Out_My_("e")
 END_PROC
 DEF PROC Vt52_Disable_Cursor
     '. ^Vt52_Disable_Cursor
     '. PROC Vt52_Disable_Cursor
     '. ---------------------------------------------------
     '. - Typ:
     '.   Prozedur aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Schaltet den Cursor aus.
     '.
     Vt52_Out_My_("f")
 END_PROC
 DEF PROC Vt52_Save_Current_Position
     '. ^Vt52_Save_Current_Position
     '. PROC Vt52_Save_Current_Position
     '. ---------------------------------------------------
     '. - Typ:
     '.   Prozedur aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Sichern der aktuellen Cursorposition
     '.
     Vt52_Out_My_("j")
 END_PROC
 DEF PROC Vt52_Restore_Current_Position
     '. ^Vt52_Restore_Current_Position
     '. PROC Vt52_Restore_Current_Position
     '. ---------------------------------------------------
     '. - Typ:
     '.   Prozedur aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   ZurÅcksetzen des Cursor auf die mittels
     '.   !Vt52_Save_Current_Position! gesicherten Cursor-
     '.   position.
     '.
     Vt52_Out_My_("k")
 END_PROC
 DEF PROC Vt52_Erase_Entire_Line
     '. ^Vt52_Erase_Entire_Line
     '. PROC Vt52_Erase_Entire_Line
     '. ---------------------------------------------------
     '. - Typ:
     '.   Prozedur aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Lîschen der gesamten Zeile, in der sich der
     '.   Cursor befindet.
     '.
     Vt52_Out_My_("l")
 END_PROC
 DEF PROC Vt52_Erase_Beginning_Of_Line
     '. ^Vt52_Erase_Beginning_Of_Line
     '. PROC Vt52_Erase_Beginning_Of_Line
     '. ---------------------------------------------------
     '. - Typ:
     '.   Prozedur aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Lîschen der Zeichen einer Zeile bis zur Cursor-
     '.   Spalte.
     '.
     Vt52_Out_My_("o")
 END_PROC
 DEF PROC Vt52_Enter_Reverse_Video_Mode
     '. ^Vt52_Enter_Reverse_Video_Mode
     '. PROC Vt52_Enter_Reverse_Video_Mode
     '. ---------------------------------------------------
     '. - Typ:
     '.   Prozedur aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Umschalten auf inverse Bildschirmdarstellung.
     '.
     Vt52_Out_My_("p")
 END_PROC
 DEF PROC Vt52_Exit_Reverse_Video_Mode
     '. ^Vt52_Exit_Reverse_Video_Mode
     '. PROC Vt52_Exit_Reverse_Video_Mode
     '. ---------------------------------------------------
     '. - Typ:
     '.   Prozedur aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Umschalten auf normale Bildschirmdarstellung.
     '.
     Vt52_Out_My_("q")
 END_PROC
 DEF PROC Vt52_Wrap_At_End_Of_Line
     '. ^Vt52_Wrap_At_End_Of_Line
     '. PROC Vt52_Wrap_At_End_Of_Line
     '. ---------------------------------------------------
     '. - Typ:
     '.   Prozedur aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Erreicht der Cursor den rechten Bildschirmrand,
     '.   so springt er automatisch an den Beginn der
     '.   nÑchsten Zeile.
     '.
     Vt52_Out_My_("v")
 END_PROC
 DEF PROC Vt52_Discard_At_End_Of_Line
     '. ^Vt52_Discard_At_End_Of_Line
     '. PROC Vt52_Discard_At_End_Of_Line
     '. ---------------------------------------------------
     '. - Typ:
     '.   Prozedur aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Gelangt der Cursor an den rechten Bildschirmrand,
     '.   so bleibt er dort stehen, solange kein CR-LF
     '.   ausgegeben wird.
     '.
     Vt52_Out_My_("w")
 END_PROC
 '
 '
 '
 ' =============================================================================
 '                                                              STANDARD-AUSGABE
 ' =============================================================================
     '.
     '. ^Ausgabe-Routinen fÅr standard output
     '. ---------------------------------------------------
     '. Die !DHSYSTEM.LIB! bietet drei Routinen zur Ausgabe
     '. von Zeichenketten mittels cconout() Åber GEMDOS auf
     '. standard output.
     '. Sollten Sie TTP's programmieren, so sollten Sie
     '. immer diese Routinen statt des Basic-Befehls !PRINT!
     '. verwenden, da !PRINT! nur auf CON: ausgibt. Eine
     '. Ausgabeumlenkung durch eine Shell kann nur bei
     '. cconout() bzw. cconws() erfolgen!
     '. Dies gilt natÅrlich genauso fÅr TOS-Programme.
     '. - !Stdout!(Out$)
     '. - !Stdoutln!
     '. - !Stdoutln!(Out$)
     '.
 DEF PROC Stdout(Out$)
     '. ^Stdout
     '. PROC Stdout(Out$)
     '. ---------------------------------------------------
     '. - Typ:
     '.   Prozedur aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   Ausgabe eines Strings Åber das GEMDOS auf
     '.   standard output ohne Zeilenvorschub.
     '. - Parameter:
     '.   Out$: Ausgabe-String
     '.
     LOCAL Addr%L
     '
     Out$=Out$+ CHR$(0)
     '
     Addr%L= LPEEK(&Out$)+ LPEEK( SEGPTR +28)
     ' Ausgabe Åber Cconws()
     GEMDOS (,9,L Addr%L)
 END_PROC
 DEF PROC Stdoutln
     Stdout( CHR$(13)+ CHR$(10))
 END_PROC
 DEF PROC Stdoutln(Out$)
     '. ^Stdoutln
     '. PROC Stdoutln
     '. PROC Stdoutln(Out$)
     '. ---------------------------------------------------
     '. - Typ:
     '.   Prozeduren aus !DHSYSTEM.LIB!
     '. - Aufgabe:
     '.   - Stdoutln(Out$):
     '.     Ausgabe eines Strings Åber das GEMDOS auf
     '.     standard output mit Zeilenvorschub.
     '.   - Stdoutln
     '.     Nur Ausgabe eines Zeilenvorschubs.
     '. - Parameter:
     '.   Out$: Ausgabe-String
     '.
     Stdout(Out$+ CHR$(13)+ CHR$(10))
 END_PROC
 '
 ' -EOF-
 '
 '
     '.
     '. ^DHSYSTEM.END
     '.

