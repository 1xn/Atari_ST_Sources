' Prg zum Schreiben kurzer NotenstÅcke fÅr c-Flîte allein | 'NOTEDITA.GFA' V.1.0
' ##############################################################################
ON ERROR GOSUB a_fehler_abfangen  !_:            * StÅckanz.: 160 pro Diskette
@0_globalvariablen                !_:            * TextlÑnge: 200 Noten=1Bldsch.
@0_programmbild_malen             !_:            * TonlÑngen: 1/4,1/8,1/16,1/32
@0_hauptfile_laden                !_:            * Tonumfang: c1...c3/einstimmig
@0_midi_vorbereiten               !_:            * Keyboard.: Casio MT-260(opt.)
@0_hauptschleife                  !_:            * P.sprache: GFA-BASIC 3.07 D
' ##############################################################################
'   V o r b e r e i t u n g e n :
' ##############################################################################
> PROCEDURE 0_globalvariablen     !_:
  ' ----------------------------------------------------------------------------
  '       Lokalvariablen fÅr diese Prozedur:
  ' ----------------------------------------------------------------------------
  LOCAL j|              ! ZÑhlvariable
  LOCAL i|              ! ZÑhlvariable
  LOCAL z|              ! ZÑhlvariable
  LOCAL lz|             ! Notenlinienzwischenraumanzahl pro Notenzeile
  LOCAL i%              ! ZÑhlvariable
  LOCAL r%              ! Druckerparameter dezimal
  LOCAL a$              ! Druckerparameter binÑr
  ' ----------------------------------------------------------------------------
  '     D r u c k e r a n p a s s u n g :
  ' ----------------------------------------------------------------------------
  LET r%=XBIOS(33,-1)   ! Druckparameter lesen
  ' PRINT a$            ! test
  LET a$=BIN$(r%)       ! BinÑr
  MID$(a$,LEN(a$)-2)="1"! 960 Punkte setzen : GFA-Handbuch: 12 - 25
  LET r%=VAL("&X"+a$)   ! Dezimal
  LET r%=XBIOS(33,r%)   ! Parameter setzen
  ' LET r%=XBIOS(33,-1) ! Parameter lesen / test
  ' LET a$=BIN$(r%)     ! test
  ' PRINT a$            ! test
  ' ----------------------------------------------------------------------------
  '     K o n s t a n t e n :
  ' ----------------------------------------------------------------------------
  '                     ! B i l d s c h i r m a b m e s s u n g e n :
  LET g_bb%=640         ! Bildschirmbreite
  LET g_bh%=400         ! Bildschirmhîhe
  '                     ! N o t e n r e c h t e c k :
  LET g_nb|=16          ! Notenrechteckbreite
  '                     ! M e n Å v a r i a b l e :
  LET g_mh|=35          ! MenÅhîhe (da bei Null angefangen, geht das MenÅ bis
  '                     ! einschlieûlich: g_mh|-1, d.h. die oberste Notenzeile
  '                     ! fÑngt an bei einschlieûlich y=g_mh|. Bitte so
  '                     ! wÑhlen, daû g_nzlh|(Notenzeilenhîhe) ganze Zahl wird !
  '                     ! N o t e n z e i l e :
  LET g_za|=5           ! Anzahl der Notenzeilen: so wÑhlen, daû
  '                     ! g_nzlh| eine ganze Zahl wird:
  LET g_nzlh|=(g_bh%-g_mh|)/g_za| ! Notenzeilenhîhe berechnen: (Bildschirmhîhe
  '                     ! -MenÅhîhe)/Anzahl der Notenzeilen
  LET lz|=11            ! Notenlinienzwischenraumanzahl pro Notenzeile:
  '                     ! 5 Hauptnotenlinien = [4] ZwischenrÑume +
  '                     ! 1 untere Linie + Randabstand = 1 + 2 = [3]
  '                     ! 2 obere Linien + Randabstand = 2 + 2 = [4]
  LET g_la|=g_nzlh|/lz| ! Abstand zwischen zwei Notenlinien berechnen:
  '                     ! Zeilenhîhe / Linienzwischenraumanzahl pro Notenzeile
  '                     ! Dieser Notenlinienabstand ist eigentlich eins weniger,
  '                     ! weil eine Notenliniendicke (=1) miteinberechnet wurde.
  '                     ! Die Zahl muû durch 2 teilbar sein,wegen '2_noten_foto'
  '                     ! O b e r e  N o t e n a n z a h l s c h r a n k e :
  LET g_npz|=g_bb%/(g_nb|)  ! Anzahl der Noten pro Zeile berechnen:
  '                     ! Bildschirmbreite / Notenbreite+Notenabstand
  LET g_os%=g_za|*g_npz|! obere Schranke aller Noten berechnen:
  '                     ! Notenzeilenanzahl * Zeilenanzahl
  '                     ! T o n h î h e n - & P e r i o d e n a n z a h l :
  LET g_tha|=25         ! Tonhîhenanzahl=Tontastenanzahl: c1 - c3
  LET g_tpa|=3          ! Tonperiodenanzahl,beginne mit 0: 1/4, 1/8, 1/16, 1/32
  '                     ! K l a v i a t u r t a s t e n b r e i t e :
  LET g_ntb|=24         ! Notentastenbreite
  LET g_ptb|=20         ! Pausentastenbreite
  '                     ! S o u n d p a r a m e t e r :
  LET g_vz|=24          ! Verzîgerungswert: muû durch 2^g_tpa| teilbar sein
  LET g_okt|=4          ! Startoktave (bei 4 Oktaven ist das die 3.von unten)
  '                     ! fÅr Sound-Befehl (also nicht fÅr MIDI)
  LET g_ls|=12          ! LautstÑrke (1-12 [+3=15,1.Note im Takt])
  LET g_sp%=40          ! Pause zwischen den StÅcken fÅr's Abspielen
  '                     ! S t Å c k a n z a h l :
  LET g_stka|=160       ! 8*20 StÅcke kînnen in den Ram-Speicher geladen werden.
  '                     ! C u r s o r s t r i n g :
  LET g_cs$=""          ! Vîllig leerer Notenbereich, auch ohne Notenlinien
  '                     ! L e e r z e i c h e n n e g a t i v :
  LET g_lz$=""          ! Da kommt einfach ein StÅck leere Notenzeile rein
  '                     ! L î s c h n o t e :
  LET g_ln$=""          ! Da kommt ein StÅck Notenzeile ohne Note rein
  '                     ! N o t e n s c h l Å s s e l :
  LET g_ns$=""          ! Da kommt der NotenschlÅssel rein
  '                     ! P r o g r a m m n a m e :
  LET g_prgname$=""     ! Bildspeicher fÅr Programmname
  '                     ! D a t e i n a m e n :
  LET g_fn$="A\:.NTA"   ! der StÅckname des aktuell bearbeiteten StÅcks
  LET g_hf$="HAUPTFLE.NTN" ! vorlÑufiger Name fÅr die Hauptdatei
  '                     ! K l a v i a t u r :
  LET g_kl$=""          ! Die Klaviatur soll fotografiert werden weg. Infotexte
  '                     ! L e e r b i l d s c h i r m :
  LET g_lb$=""          ! Der ganze Bildschirm ohne Noten soll fotografiert wer.
  '                     ! H e l p t a s t e n t e x t b i l d s c h i r m :
  LET g_hp$=""          ! Helptastenbildschirm speichern
  '                     ! F i l e s e l e c t b o x :
  LET g_fsb$=""         ! Fileselectbox wird fotografiert werden
  '                     ! T e s t :
  LET g_proctest$=""    ! Name der aufrufenden Prozedur fÅrDebugging
  '                     ! B l o c k v a r i a b l e n :
  LET g_bla%=0          ! Blockanfang
  LET g_ble%=0          ! Blockende
  '                     ! M i d i :
  LET g_k1|=10          ! Elec.-Piano-Sound auf Kanal 1
  LET g_k2|=18          ! Synth.-Ens-Sound  auf Kanal 2
  LET g_k3|=9           ! Percussion-Sound auf  Kanal 3
  LET g_perc|=0         ! Schlagzeugwahl
  ' ----------------------------------------------------------------------------
  '     L a u f v a r i a b l e n :
  ' ----------------------------------------------------------------------------
  LET g_w!=FALSE        ! =-1: Statt normalem Hauptfile anderes laden
  LET g_midi!=FALSE     ! =-1: Midi-Keyboard angeschlossen
  '                     ! N o t e n n u m m e r n :
  LET g_mt|=0           ! Merker fÅr alte Tonhîhe( siehe Procedrue'a2_s')
  LET g_n%=1            ! aktuelle Notennummer=Cursorposition
  LET g_mn%=0           ! bisherige, maximale Notennummer
  LET gu_mn%=0          ! maximale notennummer bei UndostÅck
  LET g_t%=1            ! 0=1/4, 1=1/8, 2=1/16, 3=1/32
  ' ----------------------------------------------------------------------------
  '     A r r a y s :
  ' ----------------------------------------------------------------------------
  '                     ! F r e q u e n z - A r r a y :
  DIM fr%(25*2)         ! Frequenzen aller 25 Tasten einschlieûlich Vierteltîne
  RESTORE frequenzen    ! Read-Zeiger auf Frequenzdatei
  FOR i|=1 TO 25*2      ! d
    READ fr%(i|)        ! Frequenz einlesen
  NEXT i|               ! d
  '                     ! S t u e c k e - A r r a y :
  DIM g_stueck$(g_stka|+1)! Hier stehen alle StÅcke drin, die derzeit bearbeitet
  '                     ! werden kînnen.
  '                     ! 0.Stelle Inhvz., 1. Stelle Datum, deshalb 161 statt159
  '                     ! B o o l - F e l d  f Å r  H a u p t m e n Å :
  DIM g_zs!(2,5)        ! Dimensionierung Bool-Feld: Zeilen 1-2 , Spalten a-e
  ' ............................................................................
  '                     ! N o t e n s p e i c h e r :
  DIM g_n$(g_os%+1)     ! Notenspeicher g_n$(g_n%) ist String mit den Stellen:
  '                     ! 1.) Tonhîhe (a-y) c1=a, c3=y, Pause=z
  '                     ! 2.) Periodendauerkennziffer (0-3):
  '                           0=1/4, 1=1/8, 2=1/16, 3=1/32
  '                     ! 3.) Gebunden mit VorgÑngernote ? (Ja=1,Nein=0)
  '                     ! 4.) Betonte Note ? (Ja=1,Nein=0)
  DIM gu_n$(g_os%+1)    ! UndostÅck-Array identisch mit g_n$()-Array vor letz-
  '                     ! tem Befehl.
  ' ............................................................................
  '                     ! N o t e n b i l d s p e i c h e r :
  DIM g_nb$(g_tha|+1,g_tpa|,1,1) ! Notenbildspeicherarray, die Argumente sind:
  '                     ! 1.) Tonhîhe (1-26) c1=1, c3=25, Pause=26
  '                     ! 2.) Periodendauerkennziffer (0-3)
  '                           0=1/4, 1=1/8, 2=1/16, 3=1/32
  '                     ! 3.) Gebunden mit VorgÑngernote ? (Ja=1,Nein=0)
  '                     ! 4.) Betonte Note ? (Ja=1,Nein=0)
  ' Dieser Array wird in der Prozedur '2_noten_foto(,)' gefÅllt
  ' ............................................................................
  '                     ! S t a r t k o o r d i n a t e n :
  '                     ! (links oben) eines Notenrechtecks:
  DIM g_x%(g_os%+1)     ! x-Startkoordinatenarray (Åber maximale Notenanzahl)
  DIM g_y%(g_os%+1)     ! y-Startkoordinatenarray (Åber maximale Notenanzahl)
  ' ............................................................................
  FOR i%=1 TO g_os%     ! Alle Notennummern=Notenpositionen durch:
    ' ..........................................................................
    INC j|              ! ZÑhler fÅr Notenspalte um eins erhîhen
    ' ..........................................................................
    LET g_x%(i%)=(j|-1)*g_nb|            ! x-Startk. fÅr Note i% berechn.:
    '                                    ! (Sp.zÑhler-1)*Notenbreite
    LET g_y%(i%)=g_mh|+z|*g_nzlh|        ! y-Startk. fÅr Note i% berechn.:
    '                                    ! (y-Start der 1.Notenzeile +
    '                                    ! Notenzeile * Notenzeilenhîhe)
    '    BOX g_x%(i%),g_y%(i%),g_x%(i%)+g_nb|,g_y%(i%)+g_nzlh| ! Testbild
    ' ..........................................................................
    IF j|=g_npz|        ! F rechts angelangt, also Zeile zu ende:
      LET j|=0          ! ZÑhler fÅr Notenspalte null
      INC z|            ! ZÑhler fÅr Notenzeile um eins erhîhen
    ENDIF               ! EF rechts angelangt
    ' ..........................................................................
  NEXT i%               ! NÑchste Notennummer=Notenposition
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 0_programmbild_malen  !_:
  ' ----------------------------------------------------------------------------
  LOCAL w$              ! Tastaturspeicher
  ' ............................................................................
  @1_helptaste          ! Text einlesen fÅr DrÅcken der Help-Taste
  GET g_x%(1),g_y%(1),g_x%(1)+g_nb|-1,g_y%(1)+g_nzlh|-2,g_cs$ ! Cursorstr.fotogr
  @1_notenschluessel    ! d
  @1_programmname       ! d
  PRINT AT(5,17);"Startvorbereitungen fÅr ";CHR$(27);CHR$(112);"  N O T E D I T A  ";CHR$(27);CHR$(113);" Bitte warten... "
  @1_notenbild_array    ! Dort werden die Noten gemalt und dann photographiert
  @1_notenlinien        ! d
  @1_begrenzungslinien  ! zw 2 Notenzeilen, jeweils 1 Åber y-Startpunkt v. Zle
  @1_klaviatur          ! d
  GET g_x%(1),g_y%(1),g_x%(1)+g_nb|-1,g_y%(1)+g_nzlh|-2,g_ln$ ! Lîschnote fotogr
  GET g_x%(1),g_y%(1),g_x%(1)+g_nb|-1,g_y%(1)+g_nzlh|-2,g_lz$ ! Leerz. fotogr.
  SGET g_lb$            ! Den ganzen Leerbildschirm fotografieren
  PRINT AT(5,17);"Startvorbereitungen fÅr ";CHR$(27);CHR$(112);"  N O T E D I T A  ";CHR$(27);CHR$(113);" Bitte warten... "
  GET 0,0,g_bb%-1,g_mh|-1,g_kl$     ! Klaviatur fotografieren
  PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9 ! Cusor ein
  LET w$=INKEY$         ! F was von der Tastatur anliegt:
  IF w$=" "             ! F Wahlmîglichkeit fÅr Hauptfile erwÅnscht:
    LET g_w!=TRUE       ! Flag fÅr freie Wahl des Hauptfiles setzten
  ENDIF                 ! d
  ' ----------------------------------------------------------------------------
RETURN
' ------------------------------------------------------------------------------
> PROCEDURE 1_helptaste           !_:
  ' ----------------------------------------------------------------------------
  LOCAL a$                      ! Lesestring
  ' ............................................................................
  CLS                           ! Bildschirm lîschen
  RESTORE helptext              ! Zeiger setzen
  READ a$                       ! Zeile einlesen
  REPEAT                        ! Leseschleife
    LET a$=a$                   ! linker Rand von 0 Spalten
    PRINT a$;                   ! Zeile auf Bildschirm
    IF LEN(a$)<80 AND NOT LEFT$(a$,7)=" ZurÅck" ! F bis nicht bis zum r. Rand :
      PRINT                     ! LF
    ENDIF                       ! d
    READ a$                     ! Zeile einlesen
  UNTIL a$="**"                 ! Ende
  '  GET 0,0,g_bb%-1,g_bh%-1,a$    ! Bildschirm retten
  '  PUT 0,0,a$,8                  ! Bildschirm invertieren
  SGET g_hp$                    ! Helptastenbildschirm speichern
  CLS                           ! Bildschirm sauber machen
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 1_notenschluessel     !_:
  ' ----------------------------------------------------------------------------
  LOCAL x%                      ! x-Koordinate vom aktuellen Punkt
  LOCAL y%                      ! y-Koordinate vom aktuellen Punkt
  LOCAL x%                      ! x-Koordinate vom alten Punkt
  LOCAL y%                      ! y-Koordinate vom alten Punkt
  ' ............................................................................
  RESTORE notenschluessel       ! Read-Zeiger auf NotenschlÅssel-daten
  REPEAT                        ! Leseschleife
    READ x%,y%                  ! Koordinaten fÅr aktuellen Punkt einlesen
    IF mx%<>0 AND x%<>-1        ! f alter Punkt nicht 0 und neuer nicht letzter:
      LINE mx%,my%,x%,y%        ! vom alten zum aktuellen Punkt Linie zeichnen
    ENDIF                       ! d
    LET mx%=x%                  ! aktuellen Punkt merken
    LET my%=y%                  ! d
  UNTIL x%=-1                   ! raus f Koordinate= -1
  ' ............................................................................
  '                             ! NotenschlÅssel fotografieren:
  GET g_x%(51),g_y%(51),g_x%(51)+2*g_nb|-1,g_y%(51)+g_nzlh|-2,g_ns$
  CLS                           ! Bildschirm lîschen
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 1_programmname        !_:
  ' ----------------------------------------------------------------------------
  LOCAL x%                      ! x-Koordinate vom aktuellen Punkt
  LOCAL y%                      ! y-Koordinate vom aktuellen Punkt
  LOCAL x%                      ! x-Koordinate vom alten Punkt
  LOCAL y%                      ! y-Koordinate vom alten Punkt
  ' ............................................................................
  RESTORE programmname          ! Read-Zeiger auf Programmname-daten
  REPEAT                        ! Leseschleife
    READ x%,y%                  ! Koordinaten fÅr aktuellen Punkt einlesen
    IF mx%<>0 AND x%<>-1        ! f alter Punkt nicht 0 und neuer nicht letzter:
      LINE mx%,my%,x%,y%-2        ! vom alten zum aktuellen Punkt Linie zeichnen
    ENDIF                       ! d
    LET mx%=x%                  ! aktuellen Punkt merken
    LET my%=y%                  ! d
  UNTIL x%=-1                   ! raus f Koordinate= -1
  ' ............................................................................
  '                             ! Programmnamen fotografieren:
  GET 56*8,0,80*8-1,16,g_prgname$! d
  PUT 56*8+4,0,g_prgname$,7     ! Schatten
  GET 56*8,0,80*8-1,16,g_prgname$! d
  CLS                           ! Bildschirm lîschen
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 1_notenbild_array     !_:
  ' ----------------------------------------------------------------------------
  LOCAL z|              ! PeriodenzÑhler
  LOCAL p|              ! PositionszÑhler
  LOCAL hua|            ! Noten-mit-Hals-unten-Anzahl, also c1-a
  LOCAL hoa|            ! Noten-mit-Hals-oben-Anzahl,  also h-c3
  LOCAL ka|             ! Kombinationenanzahl der Noten ohne FÑhnch. od. Hilfsl.
  LOCAL mg_n%           ! Merker fÅr Notennummer
  ' ............................................................................
  LET hua|=9            ! Noten-mit-Hals-unten-Anzahl
  LET hoa|=6            ! Noten-mit-Hals-oben-Anzahl
  LET ka|=16            ! Kombinationenanzahl der Noten ohne FÑhnch. od. Hilfsl.
  LET mg_n%=g_n%        ! Merker fÅr Notennummer
  ' ............................................................................
  @2_noten_malen                ! Noten malen ohne FÑhnchen und ohne Hilfslinien
  ' ............................................................................
  FOR z|=0 TO g_tpa|            ! Alle Tonperioden durch (TonPeriodenAnzahl):
    '                           ! Man kann hier auch FÑhnchenanzahl dazu sagen.
    LET w$=INKEY$               ! F was von der Tastatur anliegt:
    IF w$="w" OR w$="W"         ! F Wahlmîglichkeit fÅr Hauptfile erwÅnscht:
      LET g_w!=TRUE             ! Flag fÅr freie Wahl des Hauptfiles setzten
    ENDIF                       ! d
    ' ..........................................................................
    FOR g_n%=1 TO ka|/2         ! Alle Komb ohne FÑhnch. od. Hilfsli: Hals unten
      @3_faehnchen(z|,0)        ! z| FÑhnchen zeichnen, 0=Hals nach unten
    NEXT g_n%                   ! NÑchste Note mit nÑchster Kombination
    FOR p|=1 TO hua|            ! Alle Notenpositionen mit Hals nach unten durch
      @2_noten_foto(0,p|,z|)    ! d 0=Hals unten, p|=Position fÅr Negativ
    NEXT p|                     ! NÑchste Notenposition mit Hals nach unten
    ' ..........................................................................
    FOR g_n%=ka|/2+1 TO ka|     ! Alle Komb ohne FÑhnch. od. Hilfsli: Hals oben
      @3_faehnchen(z|,1)        ! z| FÑhnchen zeichnen, 1=Hals nach oben
    NEXT g_n%                   ! NÑchste Note mit nÑchster Kombination
    FOR p|=1 TO hoa|            ! Alle Notenpositionen mit Hals nach oben durch
      @2_noten_foto(1,p|,z|)    ! d 1=Hals oben, p|=Position fÅr Negativ
    NEXT p|                     ! NÑchste Notenposition mit Hals nach oben
    ' ..........................................................................
    LET g_n%=ka|+1              ! Cursorposition auf Pause
    @3_faehnchen(z|,1)          ! z| FÑhnchen zeichnen, 1=Hals nach oben
    ' ..........................................................................
    LET g_n%=ka|+2              ! Cursorposition auf Pause
    @3_faehnchen(z|,1)          ! z| FÑhnchen zeichnen, 1=Hals nach oben
    @3_taktstrich               ! Taktstrich
    @2_pausen_foto(ka|+1,z|)    ! Pause fotografieren
    ' ..........................................................................
  NEXT z|                       ! NÑchste Tonperiode
  CLS                           ! Noten wieder lîschen, Bildschirm also leer
  LET g_n%=mg_n%                ! Notennr.wiederherstellen mit Merker fÅr Notenr
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 2_noten_malen         !_:
  ' ----------------------------------------------------------------------------
  LOCAL h|              ! ZustandszÑhler: Notenhals unten=0 & Notenhals oben=1
  ' ............................................................................
  LET g_n%=0            ! Notenposition null setzen
  ' ............................................................................
  FOR h|=0 TO 1           ! Notenhals unten: öbergabe=0, oben: öbergabe=1
    ' ..........................................................................
    INC g_n%              ! Eine Notenposition weiter
    @3_notenkopf(h|)      ! Notenkopf
    @3_notenhals(h|)      ! Notenhals
    ' ..........................................................................
    INC g_n%              ! Eine Notenposition weiter
    @3_notenkopf(h|)      ! Notenkopf
    @3_notenhals(h|)      ! Notenhals
    @3_gebundenzeichen(h|)! Gebundenzeichen
    ' ..........................................................................
    INC g_n%              ! Eine Notenposition weiter
    @3_notenkopf(h|)      ! Notenkopf
    @3_notenhals(h|)      ! Notenhals
    '    @3_betonung(h|)       ! Betonungszeichen
    @3_taktstrich         ! Taktstrich
    ' ..........................................................................
    INC g_n%              ! Eine Notenposition weiter
    @3_notenkopf(h|)      ! Notenkopf
    @3_notenhals(h|)      ! Notenhals
    '    @3_betonung(h|)       ! Betonungszeichen
    @3_taktstrich         ! Taktstrich
    @3_gebundenzeichen(h|)! Gebundenzeichen
    ' ..........................................................................
    INC g_n%              ! Eine Notenposition weiter
    @3_notenkopf(h|)      ! Notenkopf
    @3_notenhals(h|)      ! Notenhals
    @3_kreuz(h|)          ! Erhîhungszeichen=Kreuz
    ' ..........................................................................
    INC g_n%              ! Eine Notenposition weiter
    @3_notenkopf(h|)      ! Notenkopf
    @3_notenhals(h|)      ! Notenhals
    @3_kreuz(h|)          ! Erhîhungszeichen=Kreuz
    @3_gebundenzeichen(h|)! Gebundenzeichen
    ' ..........................................................................
    INC g_n%              ! Eine Notenposition weiter
    @3_notenkopf(h|)      ! Notenkopf
    @3_notenhals(h|)      ! Notenhals
    @3_kreuz(h|)          ! Erhîhungszeichen=Kreuz
    '    @3_betonung(h|)       ! Betonungszeichen
    @3_taktstrich         ! Taktstrich
    ' ..........................................................................
    INC g_n%              ! Eine Notenposition weiter
    @3_notenkopf(h|)      ! Notenkopf
    @3_notenhals(h|)      ! Notenhals
    @3_kreuz(h|)          ! Erhîhungszeichen=Kreuz
    '    @3_betonung(h|)       ! Betonungszeichen
    @3_taktstrich         ! Taktstrich
    @3_gebundenzeichen(h|)! Gebundenzeichen
    ' ..........................................................................
  NEXT h|                 ! Notenhals oben
  ' ..........................................................................
  INC g_n%                ! Eine Notenposition weiter
  @3_notenhals(1)         ! Notenhals nach oben soll Pause oh.Taktstr.darstellen
  ' ..........................................................................
  INC g_n%                ! Eine Notenposition weiter
  @3_notenhals(1)         ! Notenhals nach oben soll Pause mitTaktstr.darstellen
  ' ----------------------------------------------------------------------------
RETURN
' ------------------------------------------------------------------------------
> PROCEDURE 3_notenkopf(h|)       !_:
  ' ----------------------------------------------------------------------------
  ' h|                  ! Notenhals unten:=0, oben:=1
  ' ----------------------------------------------------------------------------
  LOCAL kb|             ! Notenkopf: Pboxbreite
  LOCAL kh|             ! Notenkopf: Pboxhîhe
  LOCAL kx|             ! Notenkopf: x-Startkoordinate
  LOCAL kx|             ! Notenkopf: y-Startkoordinate
  LOCAL x1%             ! links
  LOCAL y1%             ! oben
  LOCAL x2%             ! rechts
  LOCAL y2%             ! unten
  ' ............................................................................
  LET kb|=6             ! Notenkopf: Pboxbreite
  LET kh|=4             ! Notenkopf: Pboxhîhe
  LET kx|=5             ! Notenkopf: x-Startkoordinate
  LET ky|=15            ! Notenkopf: y-Startkoordinate
  ' ............................................................................
  LET x1%=g_x%(g_n%)+kx|! links
  LET y1%=g_y%(g_n%)+ky|! oben
  LET x2%=x1%+kb|       ! rechts
  LET y2%=y1%+kh|       ! unten
  ' ............................................................................
  IF h|=1               ! F Notenhals oben:
    LET x1%=g_x%(g_n%)+g_nb|-kx|        ! links wird zu rechts
    LET y1%=g_y%(g_n%)+g_nzlh|-ky|      ! oben wird zu unten
    LET x2%=x1%-kb|     ! rechts wird zu links
    LET y2%=y1%-kh|     ! unten wird zu oben
  ENDIF                 ! EF Notenhals oben
  ' ............................................................................
  PBOX x1%,y1%,x2%,y2%  ! Notenkopf malen
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 3_notenhals(h|)       !_:
  ' ----------------------------------------------------------------------------
  ' h|                  ! Notenhals unten:=0, oben:=1
  ' ----------------------------------------------------------------------------
  LOCAL lx|             ! x-Startwert
  LOCAL ly|             ! y-Startwert
  LOCAL ll|             ! NotenhalslÑnge
  LOCAL x%              ! x-Standort
  LOCAL y1%             ! y-Start
  LOCAL y2%             ! y-Ende
  ' ............................................................................
  LET lx|=5             ! x-Startwert
  LET ly|=20            ! y-Startwert
  LET ll|=24            ! NotenhalslÑnge
  ' ............................................................................
  LET x%=g_x%(g_n%)+lx| ! x-Standort
  LET y1%=g_y%(g_n%)+ly|! y-Start
  LET y2%=y1%+ll|       ! y-Ende
  ' ............................................................................
  IF h|=1               ! F Notenhals oben:
    LET x%=g_x%(g_n%)+g_nb|-lx|         ! links wird zu rechts
    LET y1%=g_y%(g_n%)+g_nzlh|-ly|      ! oben wird zu unten
    LET y2%=y1%-ll|     ! unten wird zu oben
  ENDIF                 ! EF Notenhals oben
  ' ............................................................................
  LINE x%,y1%,x%,y2%    ! Notenhals malen
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 3_taktstrich          !_:
  ' ----------------------------------------------------------------------------
  LOCAL lx|             ! x-Startwert
  LOCAL ly|             ! y-Startwert
  LOCAL ll|             ! TaktstrichlÑnge
  LOCAL x%              ! x-Standort
  LOCAL y1%             ! y-Start
  LOCAL y2%             ! y-Ende
  ' ............................................................................
  LET lx|=1             ! x-Startwert
  LET ly|=0             ! y-Startwert
  LET ll|=150           ! TaktstrichlÑnge
  ' ............................................................................
  LET x%=g_x%(g_n%)+lx| ! x-Standort
  LET y1%=ly|           ! y-Start
  LET y2%=ll|           ! y-Ende
  ' ............................................................................
  DEFLINE &X11111111111111111010101010101011,1,0,0         ! Gepunktete Linie
  LINE x%,y1%,x%,y2%    ! Taktstrich malen
  DEFLINE 1,1,0         ! Durchgezogene Linie
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 3_kreuz(h|)           !_:
  ' ----------------------------------------------------------------------------
  ' h|                  ! Notenhals unten:=0, oben:=1
  ' ----------------------------------------------------------------------------
  LOCAL hb|             ! Erhîhungszeichen=Kreuz: Pboxbreite
  LOCAL hh|             ! Erhîhungszeichen=Kreuz: Pboxhîhe
  LOCAL hx|             ! Erhîhungszeichen=Kreuz: x-Startkoordinate
  LOCAL hx|             ! Erhîhungszeichen=Kreuz: y-Startkoordinate
  LOCAL x1%             ! links
  LOCAL y1%             ! oben
  LOCAL x2%             ! rechts
  LOCAL y2%             ! unten
  ' ............................................................................
  LET hb|=5             ! Notenhîheninfo=Kreuz: Boxbreite
  LET hh|=4             ! Notenhîheninfo=Kreuz: Boxhîhe
  LET hx|=5             ! Notenhîheninfo=Kreuz: x-Startkoordinate
  LET hy|=26            ! Notenhîheninfo=Kreuz: y-Startkoordinate
  ' ............................................................................
  LET x1%=g_x%(g_n%)+hx|! links
  LET y1%=g_y%(g_n%)+hy|! oben
  LET x2%=x1%+hb|       ! rechts
  LET y2%=y1%+hh|       ! unten
  ' ............................................................................
  IF h|=1               ! F Notenhals oben:
    LET x1%=g_x%(g_n%)+g_nb|-hx|        ! links wird zu rechts
    LET y1%=g_y%(g_n%)+g_nzlh|-hy|      ! oben wird zu unten
    LET x2%=x1%-hb|     ! rechts wird zu links
    LET y2%=y1%-hh|     ! unten wird zu oben
  ENDIF                 ! EF Notenhals oben
  ' ............................................................................
  BOX x1%,y1%,x2%,y2%   ! Erhîhungszeichen=Kreuz malen
  IF h|=1               ! F Notenhals oben:
    BOX x1%-1,y1%,x2%-1,y2%! dickere RÑnder links und rechts
  ELSE                  ! F Notenhals unten:
    BOX x1%+1,y1%,x2%+1,y2%! dickere RÑnder links und rechts
  ENDIF                 ! d
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 3_betonung(h|)        !_:
  ' ----------------------------------------------------------------------------
  ' h|                  ! Notenhals unten:=0, oben:=1
  ' ----------------------------------------------------------------------------
  LOCAL bb|             ! Betonungszeichen: Pboxbreite
  LOCAL bh|             ! Betonungszeichen: Pboxhîhe
  LOCAL bx|             ! Betonungszeichen: x-Startkoordinate
  LOCAL bx|             ! Betonungszeichen: y-Startkoordinate
  LOCAL x1%             ! links
  LOCAL y1%             ! oben
  LOCAL x2%             ! rechts
  LOCAL y2%             ! unten
  ' ............................................................................
  LET bb|=4             ! Betonungszeichen: Boxbreite
  LET bh|=2             ! Betonungszeichen: Boxhîhe
  LET bx|=5             ! Betonungszeichen: x-Startkoordinate
  LET by|=22            ! Betonungszeichen: y-Startkoordinate
  ' ............................................................................
  LET x1%=g_x%(g_n%)+bx|! links
  LET y1%=g_y%(g_n%)+by|! oben
  LET x2%=x1%+bb|       ! rechts
  LET y2%=y1%+bh|       ! unten
  ' ............................................................................
  IF h|=1               ! F Notenhals oben:
    LET x1%=g_x%(g_n%)+g_nb|-bx|        ! links wird zu rechts
    LET y1%=g_y%(g_n%)+g_nzlh|-by|      ! oben wird zu unten
    LET x2%=x1%-bb|     ! rechts wird zu links
    LET y2%=y1%-bh|     ! unten wird zu oben
  ENDIF                 ! EF Notenhals oben
  ' ............................................................................
  PBOX x1%,y1%,x2%,y2%  ! Betonungszeichen malen
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 3_gebundenzeichen(h|) !_:
  ' ----------------------------------------------------------------------------
  ' h|                  ! Notenhals unten:=0, oben:=1
  ' ----------------------------------------------------------------------------
  LOCAL bb|             ! Gebundenzeichen: Pboxbreite
  LOCAL bh|             ! Gebundenzeichen: Pboxhîhe
  LOCAL bx|             ! Gebundenzeichen: x-Startkoordinate
  LOCAL bx|             ! Gebundenzeichen: y-Startkoordinate
  LOCAL x1%             ! links
  LOCAL y1%             ! oben
  LOCAL x2%             ! rechts
  LOCAL y2%             ! unten
  ' ............................................................................
  LET gd|=6             ! Gebunden mit vorheriger Note: Boxbreite
  LET gh|=2             ! Gebunden mit vorheriger Note: Boxhîhe
  LET gx|=5             ! Gebunden mit vorheriger Note: x-Startkoordinate
  LET gy|=10            ! Gebunden mit vorheriger Note: y-Startkoordinate
  ' ............................................................................
  LET x1%=g_x%(g_n%)+gx|! links
  LET y1%=g_y%(g_n%)+gy|! oben
  LET x2%=x1%+gd|       ! rechts
  LET y2%=y1%+gh|       ! unten
  ' ............................................................................
  IF h|=1               ! F Notenhals oben:
    LET x1%=g_x%(g_n%)+g_nb|-gx|        ! links wird zu rechts
    LET y1%=g_y%(g_n%)+g_nzlh|-gy|      ! oben wird zu unten
    LET x2%=x1%-gd|     ! rechts wird zu links
    LET y2%=y1%-gh|     ! unten wird zu oben
  ENDIF                 ! EF Notenhals oben
  ' ............................................................................
  BOX x1%,y1%,x2%,y2%   ! Gebundenzeichen malen
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 3_faehnchen(t|,h|)    !_:
  ' ----------------------------------------------------------------------------
  ' t|                  ! Anzahl der FÑhnchen
  ' h|                  ! Notenhals unten:=0, oben:=1
  ' ----------------------------------------------------------------------------
  LOCAL ax1|            ! ?-tel-FÑhnchen, Linie a: x-Startkoordinate
  LOCAL ax2|            ! ?-tel-FÑhnchen, Linie a: x-Endkoordinate
  LOCAL bx2|            ! ?-tel-FÑhnchen, Linie b: x-Endkoordinate
  '
  LOCAL a32y1|          ! 32-tel-FÑhnchen, Linie a: y-Startkoordinate
  LOCAL a32y2|          ! 32-tel-FÑhnchen, Linie a: y-Endkoordinate
  LOCAL b32y1|          ! 32-tel-FÑhnchen, Linie b: y-Startkoordinate
  '
  LOCAL a16y1|          ! 16-tel-FÑhnchen, Linie a: y-Startkoordinate
  LOCAL a16y2|          ! 16-tel-FÑhnchen, Linie a: y-Endkoordinate
  LOCAL b16y1|          ! 16-tel-FÑhnchen, Linie b: y-Startkoordinate
  '
  LOCAL a8y1|           ! 8-tel-FÑhnchen, Linie a: y-Startkoordinate
  LOCAL a8y2|           ! 8-tel-FÑhnchen, Linie a: y-Endkoordinate
  LOCAL b8y1|           ! 8-tel-FÑhnchen, Linie b: y-Startkoordinate
  '
  LOCAL x%              ! Speicher fÅr Start-x-Wert des aktuellen Notenfensters
  LOCAL y%              ! Speicher fÅr Start-y-Wert des aktuellen Notenfensters
  '
  LOCAL x1%             ! links
  LOCAL y1%             ! unten
  LOCAL x2%             ! rechts
  LOCAL y2%             ! oben
  ' ............................................................................
  LET ax1|=6            ! ?-tel-FÑhnchen, Linie a: x-Startkoordinate
  LET ax2|=9            ! ?-tel-FÑhnchen, Linie a: x-Endkoordinate
  LET bx2|=10            ! ?-tel-FÑhnchen, Linie b: x-Endkoordinate
  '
  LET a32y1|=35         ! 32-tel-FÑhnchen, Linie a: y-Startkoordinate
  LET a32y2|=32         ! 32-tel-FÑhnchen, Linie a: y-Endkoordinate
  LET b32y1|=a32y1|+1   ! 32-tel-FÑhnchen, Linie b: y-Startkoordinate
  '
  LET a16y1|=39         ! 16-tel-FÑhnchen, Linie a: y-Startkoordinate
  LET a16y2|=36         ! 16-tel-FÑhnchen, Linie a: y-Endkoordinate
  LET b16y1|=a16y1|+1   ! 16-tel-FÑhnchen, Linie b: y-Startkoordinate
  '
  LET a8y1|=43          ! 8-tel-FÑhnchen, Linie a: y-Startkoordinate
  LET a8y2|=40          ! 8-tel-FÑhnchen, Linie a: y-Endkoordinate
  LET b8y1|=a8y1|+1     ! 8-tel-FÑhnchen, Linie b: y-Startkoordinate
  '
  LET x%=g_x%(g_n%)     ! Start-x-Wert des Notenfensters in einfachere Variable
  LET y%=g_y%(g_n%)     ! Start-y-Wert des Notenfensters in einfachere Variable
  ' ............................................................................
  IF t|=0               ! F Kein FÑhnchen verlangt:
    GOTO r_faehnchen    ! verlasse unverrichteter Dinge die Prozedur
  ENDIF                 ! EF kein FÑhnchen verlangt
  ' ............................................................................
  '                     ! A c h t e l  -  F Ñ h n c h e n :
  ' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  IF h|=0               ! F Notenhals unten:
    LET x1%=x%+ax1|     ! links
    LET y1%=y%+a8y1|    ! unten
    LET x2%=x%+ax2|     ! rechts
    LET y2%=y%+a8y2|    ! oben
  ELSE IF h|=1          ! F Notenhals oben, Werte spiegeln:
    LET x1%=x%+g_nb|-ax1| ! aus links wird rechts
    LET y1%=y%+g_nzlh|-a8y1|! aus unten wird oben
    LET x2%=x%+g_nb|-ax2| ! aus rechts wird links
    LET y2%=y%+g_nzlh|-a8y2|! aus oben wird unten
  ENDIF                 ! EFU Notenhals unten / oben
  ' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  LINE x1%,y1%,x2%,y2%  ! 8-tel NotenfÑhnchen, Linie a malen
  ' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  IF h|=0               ! F Notenhals unten:
    LET x1%=x%+ax1|     ! links
    LET y1%=y%+b8y1|    ! unten
    LET x2%=x%+bx2|     ! rechts
    LET y2%=y%+a8y2|    ! oben
  ELSE IF h|=1          ! F Notenhals oben, Werte spiegeln:
    LET x1%=x%+g_nb|-ax1| ! aus links wird rechts
    LET y1%=y%+g_nzlh|-b8y1|! aus unten wird oben
    LET x2%=x%+g_nb|-bx2| ! aus rechts wird links
    LET y2%=y%+g_nzlh|-a8y2|! aus oben wird unten
  ENDIF                 ! EF Notenhals oben
  ' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  LINE x1%,y1%,x2%,y2%  ! 8-tel NotenfÑhnchen, Linie b malen
  ' ............................................................................
  IF t|=1               ! F Kein FÑhnchen mehr verlangt:
    GOTO r_faehnchen    ! verlasse nach getaner Arbeit die Prozedur
  ENDIF                 ! EF kein FÑhnchen mehr verlangt
  ' ............................................................................
  '                     ! S e c h z e h n t e l  -  F Ñ h n c h e n :
  ' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  IF h|=0               ! F Notenhals unten:
    LET x1%=x%+ax1|     ! links
    LET y1%=y%+a16y1|   ! unten
    LET x2%=x%+ax2|     ! rechts
    LET y2%=y%+a16y2|   ! oben
  ELSE IF h|=1          ! F Notenhals oben, Werte spiegeln:
    LET x1%=x%+g_nb|-ax1| ! aus links wird rechts
    LET y1%=y%+g_nzlh|-a16y1|! aus unten wird oben
    LET x2%=x%+g_nb|-ax2| ! aus rechts wird links
    LET y2%=y%+g_nzlh|-a16y2|! aus oben wird unten
  ENDIF                 ! EFU Notenhals unten / oben
  ' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  LINE x1%,y1%,x2%,y2%  ! 16-tel NotenfÑhnchen, Linie a malen
  ' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  IF h|=0               ! F Notenhals unten:
    LET x1%=x%+ax1|     ! links
    LET y1%=y%+b16y1|   ! unten
    LET x2%=x%+bx2|     ! rechts
    LET y2%=y%+a16y2|   ! oben
  ELSE IF h|=1          ! F Notenhals oben, Werte spiegeln:
    LET x1%=x%+g_nb|-ax1| ! aus links wird rechts
    LET y1%=y%+g_nzlh|-b16y1|! aus unten wird oben
    LET x2%=x%+g_nb|-bx2| ! aus rechts wird links
    LET y2%=y%+g_nzlh|-a16y2|! aus oben wird unten
  ENDIF                 ! EF Notenhals oben
  ' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  LINE x1%,y1%,x2%,y2%  ! 16-tel NotenfÑhnchen, Linie b malen
  ' ............................................................................
  IF t|=2               ! F Kein FÑhnchen mehr verlangt:
    GOTO r_faehnchen    ! verlasse nach getaner Arbeit die Prozedur
  ENDIF                 ! EF kein FÑhnchen mehr verlangt
  ' ............................................................................
  '                     ! Z w e i u n d d r e i û i g s t e l - F Ñ h n c h e n
  ' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  IF h|=0               ! F Notenhals unten:
    LET x1%=x%+ax1|     ! links
    LET y1%=y%+a32y1|   ! unten
    LET x2%=x%+ax2|     ! rechts
    LET y2%=y%+a32y2|   ! oben
  ELSE IF h|=1          ! F Notenhals oben, Werte spiegeln:
    LET x1%=x%+g_nb|-ax1| ! aus links wird rechts
    LET y1%=y%+g_nzlh|-a32y1|! aus unten wird oben
    LET x2%=x%+g_nb|-ax2| ! aus rechts wird links
    LET y2%=y%+g_nzlh|-a32y2|! aus oben wird unten
  ENDIF                 ! EFU Notenhals unten / oben
  ' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  LINE x1%,y1%,x2%,y2%  ! 32-tel NotenfÑhnchen, Linie a malen
  ' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  IF h|=0               ! F Notenhals unten:
    LET x1%=x%+ax1|     ! links
    LET y1%=y%+b32y1|   ! unten
    LET x2%=x%+bx2|     ! rechts
    LET y2%=y%+a32y2|   ! oben
  ELSE IF h|=1          ! F Notenhals oben, Werte spiegeln:
    LET x1%=x%+g_nb|-ax1| ! aus links wird rechts
    LET y1%=y%+g_nzlh|-b32y1|! aus unten wird oben
    LET x2%=x%+g_nb|-bx2| ! aus rechts wird links
    LET y2%=y%+g_nzlh|-a32y2|! aus oben wird unten
  ENDIF                 ! EF Notenhals oben
  ' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  LINE x1%,y1%,x2%,y2%  ! 32-tel NotenfÑhnchen, Linie b malen
  ' ............................................................................
  r_faehnchen:          ! Label zum vorzeitigen Verlassen der Prozedur
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 2_noten_foto(l|,v|,t|)!_:
  ' ----------------------------------------------------------------------------
  ' l|                  ! Notenhals unten:=0, oben:=1
  ' v|                  ! vertikale, logische Position des Negativs
  ' t|                  ! FÑhnchenanzahl
  ' ----------------------------------------------------------------------------
  LOCAL d|              ! physikalische Vertikalposition
  LOCAL h|              ! Zwischenspeicher fÅr Notenzeilenhîhe minus 1
  LOCAL nb|             ! Zwischenspeicher fÅr Notenbreite
  LOCAL a$              ! Bildschirmzwischenspeicher brauchts wegen Hilfslinien
  ' ............................................................................
  '                     ! N o t e n b i l d s p e i c h e r :
  ' g_nb$(g_tha|,g_tpa|,1,1) ! Notenbildspeicherarray, die Argumente sind:
  '                     ! 1.) Tonhîhe (1-25) c1=1, c3=25
  '                     ! 2.) Periodendauerkennziffer (0-3)
  '                           0=1/4, 1=1/8, 2=1/16, 3=1/32
  '                     ! 3.) Gebunden mit VorgÑngernote ? (Ja=1,Nein=0)
  '                     ! 4.) Betonte Note ? (Ja=1,Nein=0)
  ' ............................................................................
  LET rga%=-3           ! Richtiger Gebundenzeichenabstand: beim Spiegeln der
  '                     ! Noten mit Hals nach unten (um die mit Hals nach oben
  '                     ! zu erreichen) ist der Abstand zum unteren Rand in-
  '                     ! korrekt und wird durch rga% korrigiert (s.a. Bild)
  LET h|=g_nzlh|-2      ! Zwischenspeicher fÅr Notenzeilenhîhe minus 2, weil:
  '                     ! g_y%(?)+g_nzlh| bereits 1.Pkt v.nÑchstunteren Notenbe-
  '                     ! reich, siehe auch Bild der Beispielnote!
  LET nb|=g_nb|-1       ! Zwischenspeicher fÅr Notenbreite,spart immer 2 Zeichen
  SGET a$               ! Bildschirm retten
  ' ............................................................................
  IF l|=0               ! F Notenhals unten:
    ' ..........................................................................
    IF v|=1             ! F 1. logische Vertikalposition = h1, Noten fotograf.:
      LET d|=8*(g_la|/2)! physikalische Vertikalposition festlegen
      GET g_x%(1),g_y%(1)-d|,g_x%(1)+nb|,g_y%(1)+h|-d|,g_nb$(12,t|,0,0)
      GET g_x%(2),g_y%(2)-d|,g_x%(2)+nb|,g_y%(2)+h|-d|,g_nb$(12,t|,1,0)
      GET g_x%(3),g_y%(3)-d|,g_x%(3)+nb|,g_y%(3)+h|-d|,g_nb$(12,t|,0,1)
      GET g_x%(4),g_y%(4)-d|,g_x%(4)+nb|,g_y%(4)+h|-d|,g_nb$(12,t|,1,1)
    ELSE IF v|=2        ! F 2. logische Vertikalposition = c2, cis2
      LET d|=7*(g_la|/2)! physikalische Vertikalposition festlegen
      GET g_x%(1),g_y%(1)-d|,g_x%(1)+nb|,g_y%(1)+h|-d|,g_nb$(13,t|,0,0)
      GET g_x%(2),g_y%(2)-d|,g_x%(2)+nb|,g_y%(2)+h|-d|,g_nb$(13,t|,1,0)
      GET g_x%(3),g_y%(3)-d|,g_x%(3)+nb|,g_y%(3)+h|-d|,g_nb$(13,t|,0,1)
      GET g_x%(4),g_y%(4)-d|,g_x%(4)+nb|,g_y%(4)+h|-d|,g_nb$(13,t|,1,1)
      GET g_x%(5),g_y%(1)-d|,g_x%(5)+nb|,g_y%(5)+h|-d|,g_nb$(14,t|,0,0)
      GET g_x%(6),g_y%(2)-d|,g_x%(6)+nb|,g_y%(6)+h|-d|,g_nb$(14,t|,1,0)
      GET g_x%(7),g_y%(3)-d|,g_x%(7)+nb|,g_y%(7)+h|-d|,g_nb$(14,t|,0,1)
      GET g_x%(8),g_y%(4)-d|,g_x%(8)+nb|,g_y%(8)+h|-d|,g_nb$(14,t|,1,1)
    ELSE IF v|=3        ! F 3. logische Vertikalposition = d2, dis2
      LET d|=6*(g_la|/2)! physikalische Vertikalposition festlegen
      GET g_x%(1),g_y%(1)-d|,g_x%(1)+nb|,g_y%(1)+h|-d|,g_nb$(15,t|,0,0)
      GET g_x%(2),g_y%(2)-d|,g_x%(2)+nb|,g_y%(2)+h|-d|,g_nb$(15,t|,1,0)
      GET g_x%(3),g_y%(3)-d|,g_x%(3)+nb|,g_y%(3)+h|-d|,g_nb$(15,t|,0,1)
      GET g_x%(4),g_y%(4)-d|,g_x%(4)+nb|,g_y%(4)+h|-d|,g_nb$(15,t|,1,1)
      GET g_x%(5),g_y%(1)-d|,g_x%(5)+nb|,g_y%(5)+h|-d|,g_nb$(16,t|,0,0)
      GET g_x%(6),g_y%(2)-d|,g_x%(6)+nb|,g_y%(6)+h|-d|,g_nb$(16,t|,1,0)
      GET g_x%(7),g_y%(3)-d|,g_x%(7)+nb|,g_y%(7)+h|-d|,g_nb$(16,t|,0,1)
      GET g_x%(8),g_y%(4)-d|,g_x%(8)+nb|,g_y%(8)+h|-d|,g_nb$(16,t|,1,1)
    ELSE IF v|=4        ! F 4. logische Vertikalposition = e2
      LET d|=5*(g_la|/2)! physikalische Vertikalposition festlegen
      GET g_x%(1),g_y%(1)-d|,g_x%(1)+nb|,g_y%(1)+h|-d|,g_nb$(17,t|,0,0)
      GET g_x%(2),g_y%(2)-d|,g_x%(2)+nb|,g_y%(2)+h|-d|,g_nb$(17,t|,1,0)
      GET g_x%(3),g_y%(3)-d|,g_x%(3)+nb|,g_y%(3)+h|-d|,g_nb$(17,t|,0,1)
      GET g_x%(4),g_y%(4)-d|,g_x%(4)+nb|,g_y%(4)+h|-d|,g_nb$(17,t|,1,1)
    ELSE IF v|=5        ! F 5. logische Vertikalposition = f2, fis2
      LET d|=4*(g_la|/2)! physikalische Vertikalposition festlegen
      GET g_x%(1),g_y%(1)-d|,g_x%(1)+nb|,g_y%(1)+h|-d|,g_nb$(18,t|,0,0)
      GET g_x%(2),g_y%(2)-d|,g_x%(2)+nb|,g_y%(2)+h|-d|,g_nb$(18,t|,1,0)
      GET g_x%(3),g_y%(3)-d|,g_x%(3)+nb|,g_y%(3)+h|-d|,g_nb$(18,t|,0,1)
      GET g_x%(4),g_y%(4)-d|,g_x%(4)+nb|,g_y%(4)+h|-d|,g_nb$(18,t|,1,1)
      GET g_x%(5),g_y%(1)-d|,g_x%(5)+nb|,g_y%(5)+h|-d|,g_nb$(19,t|,0,0)
      GET g_x%(6),g_y%(2)-d|,g_x%(6)+nb|,g_y%(6)+h|-d|,g_nb$(19,t|,1,0)
      GET g_x%(7),g_y%(3)-d|,g_x%(7)+nb|,g_y%(7)+h|-d|,g_nb$(19,t|,0,1)
      GET g_x%(8),g_y%(4)-d|,g_x%(8)+nb|,g_y%(8)+h|-d|,g_nb$(19,t|,1,1)
    ELSE IF v|=6        ! F 6. logische Vertikalposition = g2, gis2
      LET d|=3*(g_la|/2)! physikalische Vertikalposition festlegen
      GET g_x%(1),g_y%(1)-d|,g_x%(1)+nb|,g_y%(1)+h|-d|,g_nb$(20,t|,0,0)
      GET g_x%(2),g_y%(2)-d|,g_x%(2)+nb|,g_y%(2)+h|-d|,g_nb$(20,t|,1,0)
      GET g_x%(3),g_y%(3)-d|,g_x%(3)+nb|,g_y%(3)+h|-d|,g_nb$(20,t|,0,1)
      GET g_x%(4),g_y%(4)-d|,g_x%(4)+nb|,g_y%(4)+h|-d|,g_nb$(20,t|,1,1)
      GET g_x%(5),g_y%(1)-d|,g_x%(5)+nb|,g_y%(5)+h|-d|,g_nb$(21,t|,0,0)
      GET g_x%(6),g_y%(2)-d|,g_x%(6)+nb|,g_y%(6)+h|-d|,g_nb$(21,t|,1,0)
      GET g_x%(7),g_y%(3)-d|,g_x%(7)+nb|,g_y%(7)+h|-d|,g_nb$(21,t|,0,1)
      GET g_x%(8),g_y%(4)-d|,g_x%(8)+nb|,g_y%(8)+h|-d|,g_nb$(21,t|,1,1)
    ELSE IF v|=7        ! F 7. logische Vertikalposition = a2, b2
      @3_hilfslinie_a2  ! Hilfslinie fÅrs obere a malen
      LET d|=2*(g_la|/2)! physikalische Vertikalposition festlegen
      GET g_x%(1),g_y%(1)-d|,g_x%(1)+nb|,g_y%(1)+h|-d|,g_nb$(22,t|,0,0)
      GET g_x%(2),g_y%(2)-d|,g_x%(2)+nb|,g_y%(2)+h|-d|,g_nb$(22,t|,1,0)
      GET g_x%(3),g_y%(3)-d|,g_x%(3)+nb|,g_y%(3)+h|-d|,g_nb$(22,t|,0,1)
      GET g_x%(4),g_y%(4)-d|,g_x%(4)+nb|,g_y%(4)+h|-d|,g_nb$(22,t|,1,1)
      GET g_x%(5),g_y%(1)-d|,g_x%(5)+nb|,g_y%(5)+h|-d|,g_nb$(23,t|,0,0)
      GET g_x%(6),g_y%(2)-d|,g_x%(6)+nb|,g_y%(6)+h|-d|,g_nb$(23,t|,1,0)
      GET g_x%(7),g_y%(3)-d|,g_x%(7)+nb|,g_y%(7)+h|-d|,g_nb$(23,t|,0,1)
      GET g_x%(8),g_y%(4)-d|,g_x%(8)+nb|,g_y%(8)+h|-d|,g_nb$(23,t|,1,1)
      SPUT a$           ! ursprÅnglichen Bildschirm wiederherstellen
    ELSE IF v|=8        ! F 8. logische Vertikalposition = h2
      @3_hilfslinie_h2  ! Hilfslinie fÅrs obere h malen
      LET d|=1*(g_la|/2)! physikalische Vertikalposition festlegen
      GET g_x%(1),g_y%(1)-d|,g_x%(1)+nb|,g_y%(1)+h|-d|,g_nb$(24,t|,0,0)
      GET g_x%(2),g_y%(2)-d|,g_x%(2)+nb|,g_y%(2)+h|-d|,g_nb$(24,t|,1,0)
      GET g_x%(3),g_y%(3)-d|,g_x%(3)+nb|,g_y%(3)+h|-d|,g_nb$(24,t|,0,1)
      GET g_x%(4),g_y%(4)-d|,g_x%(4)+nb|,g_y%(4)+h|-d|,g_nb$(24,t|,1,1)
      SPUT a$           ! ursprÅnglichen Bildschirm wiederherstellen
    ELSE IF v|=9        ! F 9. logische Vertikalposition = c3
      @3_hilfslinie_a2  ! Hilfslinie fÅrs obere a malen
      @3_hilfslinie_c3  ! untere Hilfslinie fÅrs obere c malen
      LET d|=0*(g_la|/2)! physikalische Vertikalposition festlegen
      GET g_x%(1),g_y%(1)-d|,g_x%(1)+nb|,g_y%(1)+h|-d|,g_nb$(25,t|,0,0)
      GET g_x%(2),g_y%(2)-d|,g_x%(2)+nb|,g_y%(2)+h|-d|,g_nb$(25,t|,1,0)
      GET g_x%(3),g_y%(3)-d|,g_x%(3)+nb|,g_y%(3)+h|-d|,g_nb$(25,t|,0,1)
      GET g_x%(4),g_y%(4)-d|,g_x%(4)+nb|,g_y%(4)+h|-d|,g_nb$(25,t|,1,1)
      SPUT a$           ! ursprÅnglichen Bildschirm wiederherstellen
    ENDIF               ! EFU logische Vertikalpositionen 1-9: Hals unten
    ' ..........................................................................
  ELSE IF l|=1          ! F Notenhals oben:
    ' ..........................................................................
    IF v|=1             ! F 1. logische Vertikalposition = a1, b1
      LET d%=rga%+5*(g_la|/2)! physikalische Vertikalposition festlegen
      GET g_x%(9),g_y%(9)+d%,g_x%(9)+nb|,g_y%(9)+h|+d%,g_nb$(10,t|,0,0)
      GET g_x%(10),g_y%(10)+d%,g_x%(10)+nb|,g_y%(10)+h|+d%,g_nb$(10,t|,1,0)
      GET g_x%(11),g_y%(11)+d%,g_x%(11)+nb|,g_y%(11)+h|+d%,g_nb$(10,t|,0,1)
      GET g_x%(12),g_y%(12)+d%,g_x%(12)+nb|,g_y%(12)+h|+d%,g_nb$(10,t|,1,1)
      GET g_x%(13),g_y%(13)+d%,g_x%(13)+nb|,g_y%(13)+h|+d%,g_nb$(11,t|,0,0)
      GET g_x%(14),g_y%(14)+d%,g_x%(14)+nb|,g_y%(14)+h|+d%,g_nb$(11,t|,1,0)
      GET g_x%(15),g_y%(15)+d%,g_x%(15)+nb|,g_y%(15)+h|+d%,g_nb$(11,t|,0,1)
      GET g_x%(16),g_y%(16)+d%,g_x%(16)+nb|,g_y%(16)+h|+d%,g_nb$(11,t|,1,1)
    ELSE IF v|=2        ! F 2. logische Vertikalposition = g1, gis1
      LET d%=rga%+4*(g_la|/2)! physikalische Vertikalposition festlegen
      GET g_x%(9),g_y%(9)+d%,g_x%(9)+nb|,g_y%(9)+h|+d%,g_nb$(8,t|,0,0)
      GET g_x%(10),g_y%(10)+d%,g_x%(10)+nb|,g_y%(10)+h|+d%,g_nb$(8,t|,1,0)
      GET g_x%(11),g_y%(11)+d%,g_x%(11)+nb|,g_y%(11)+h|+d%,g_nb$(8,t|,0,1)
      GET g_x%(12),g_y%(12)+d%,g_x%(12)+nb|,g_y%(12)+h|+d%,g_nb$(8,t|,1,1)
      GET g_x%(13),g_y%(13)+d%,g_x%(13)+nb|,g_y%(13)+h|+d%,g_nb$(9,t|,0,0)
      GET g_x%(14),g_y%(14)+d%,g_x%(14)+nb|,g_y%(14)+h|+d%,g_nb$(9,t|,1,0)
      GET g_x%(15),g_y%(15)+d%,g_x%(15)+nb|,g_y%(15)+h|+d%,g_nb$(9,t|,0,1)
      GET g_x%(16),g_y%(16)+d%,g_x%(16)+nb|,g_y%(16)+h|+d%,g_nb$(9,t|,1,1)
    ELSE IF v|=3        ! F 3. logische Vertikalposition = f1, fis1
      LET d%=rga%+3*(g_la|/2)! physikalische Vertikalposition festlegen
      GET g_x%(9),g_y%(9)+d%,g_x%(9)+nb|,g_y%(9)+h|+d%,g_nb$(6,t|,0,0)
      GET g_x%(10),g_y%(10)+d%,g_x%(10)+nb|,g_y%(10)+h|+d%,g_nb$(6,t|,1,0)
      GET g_x%(11),g_y%(11)+d%,g_x%(11)+nb|,g_y%(11)+h|+d%,g_nb$(6,t|,0,1)
      GET g_x%(12),g_y%(12)+d%,g_x%(12)+nb|,g_y%(12)+h|+d%,g_nb$(6,t|,1,1)
      GET g_x%(13),g_y%(13)+d%,g_x%(13)+nb|,g_y%(13)+h|+d%,g_nb$(7,t|,0,0)
      GET g_x%(14),g_y%(14)+d%,g_x%(14)+nb|,g_y%(14)+h|+d%,g_nb$(7,t|,1,0)
      GET g_x%(15),g_y%(15)+d%,g_x%(15)+nb|,g_y%(15)+h|+d%,g_nb$(7,t|,0,1)
      GET g_x%(16),g_y%(16)+d%,g_x%(16)+nb|,g_y%(16)+h|+d%,g_nb$(7,t|,1,1)
    ELSE IF v|=4        ! F 4. logische Vertikalposition = e1
      LET d%=rga%+2*(g_la|/2)! physikalische Vertikalposition festlegen
      GET g_x%(9),g_y%(9)+d%,g_x%(9)+nb|,g_y%(9)+h|+d%,g_nb$(5,t|,0,0)
      GET g_x%(10),g_y%(10)+d%,g_x%(10)+nb|,g_y%(10)+h|+d%,g_nb$(5,t|,1,0)
      GET g_x%(11),g_y%(11)+d%,g_x%(11)+nb|,g_y%(11)+h|+d%,g_nb$(5,t|,0,1)
      GET g_x%(12),g_y%(12)+d%,g_x%(12)+nb|,g_y%(12)+h|+d%,g_nb$(5,t|,1,1)
    ELSE IF v|=5        ! F 5. logische Vertikalposition = d1, dis1
      LET d%=rga%+1*(g_la|/2)! physikalische Vertikalposition festlegen
      GET g_x%(9),g_y%(9)+d%,g_x%(9)+nb|,g_y%(9)+h|+d%,g_nb$(3,t|,0,0)
      GET g_x%(10),g_y%(10)+d%,g_x%(10)+nb|,g_y%(10)+h|+d%,g_nb$(3,t|,1,0)
      GET g_x%(11),g_y%(11)+d%,g_x%(11)+nb|,g_y%(11)+h|+d%,g_nb$(3,t|,0,1)
      GET g_x%(12),g_y%(12)+d%,g_x%(12)+nb|,g_y%(12)+h|+d%,g_nb$(3,t|,1,1)
      GET g_x%(13),g_y%(13)+d%,g_x%(13)+nb|,g_y%(13)+h|+d%,g_nb$(4,t|,0,0)
      GET g_x%(14),g_y%(14)+d%,g_x%(14)+nb|,g_y%(14)+h|+d%,g_nb$(4,t|,1,0)
      GET g_x%(15),g_y%(15)+d%,g_x%(15)+nb|,g_y%(15)+h|+d%,g_nb$(4,t|,0,1)
      GET g_x%(16),g_y%(16)+d%,g_x%(16)+nb|,g_y%(16)+h|+d%,g_nb$(4,t|,1,1)
    ELSE IF v|=6        ! F 6. logische Vertikalposition = c1, cis1
      @3_hilfslinie_c1(rga%)  ! Hilfslinie fÅrs unterste c malen
      LET d%=rga%+0*(g_la|/2)! physikalische Vertikalposition festlegen
      GET g_x%(9),g_y%(9)+d%,g_x%(9)+nb|,g_y%(9)+h|+d%,g_nb$(1,t|,0,0)
      GET g_x%(10),g_y%(10)+d%,g_x%(10)+nb|,g_y%(10)+h|+d%,g_nb$(1,t|,1,0)
      GET g_x%(11),g_y%(11)+d%,g_x%(11)+nb|,g_y%(11)+h|+d%,g_nb$(1,t|,0,1)
      GET g_x%(12),g_y%(12)+d%,g_x%(12)+nb|,g_y%(12)+h|+d%,g_nb$(1,t|,1,1)
      GET g_x%(13),g_y%(13)+d%,g_x%(13)+nb|,g_y%(13)+h|+d%,g_nb$(2,t|,0,0)
      GET g_x%(14),g_y%(14)+d%,g_x%(14)+nb|,g_y%(14)+h|+d%,g_nb$(2,t|,1,0)
      GET g_x%(15),g_y%(15)+d%,g_x%(15)+nb|,g_y%(15)+h|+d%,g_nb$(2,t|,0,1)
      GET g_x%(16),g_y%(16)+d%,g_x%(16)+nb|,g_y%(16)+h|+d%,g_nb$(2,t|,1,1)
      SPUT a$           ! ursprÅnglichen Bildschirm wiederherstellen
    ENDIF               ! EFU logische Vertikalpositionen 1-6: Hals oben
    ' ..........................................................................
  ENDIF                 ! EFU Notenhals unten / oben
  ' ............................................................................
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 2_pausen_foto(l|,t|)  !_:
  ' ----------------------------------------------------------------------------
  '                     ! Diese Prozedur ist der '2_noten_foto()' sehr Ñhnlich.
  ' ............................................................................
  ' l|                  ! Cursorpostion fÅr die Pause ist wohl immer gleich=17
  ' t|                  ! FÑhnchenanzahl=Pausendauer
  ' ............................................................................
  LOCAL d|              ! physikalische Vertikalposition
  LOCAL h|              ! Zwischenspeicher fÅr Notenzeilenhîhe minus 1
  LOCAL nb|             ! Zwischenspeicher fÅr Notenbreite
  ' ............................................................................
  LET rga%=-3           ! Richtiger Gebundenzeichenabstand: beim Spiegeln der
  '                     ! Noten mit Hals nach unten (um die mit Hals nach oben
  '                     ! zu erreichen) ist der Abstand zum unteren Rand in-
  '                     ! korrekt und wird durch rga% korrigiert (s.a. Bild)
  LET h|=g_nzlh|-2      ! Zwischenspeicher fÅr Notenzeilenhîhe minus 2, weil:
  '                     ! g_y%(?)+g_nzlh| bereits 1.Pkt v.nÑchstunteren Notenber
  LET nb|=g_nb|-1       ! Zwischenspeicher fÅr Notenbreite,spart immer 2 Zeichen
  ' ............................................................................
  LET d%=rga%+5*(g_la|/2)! physikalische Vertikalposition festlegen
  '                      ! Pause ohne Taktstrich, 'ungebunden':
  GET g_x%(17),g_y%(17)+d%,g_x%(17)+nb|,g_y%(17)+h|+d%,g_nb$(26,t|,0,0)
  '                      ! Pause ohne Taktstrich, 'gebunden':
  GET g_x%(17),g_y%(17)+d%,g_x%(17)+nb|,g_y%(17)+h|+d%,g_nb$(26,t|,1,0)
  '                      ! Pause mit Taktstrich, 'ungebunden':
  GET g_x%(18),g_y%(18)+d%,g_x%(18)+nb|,g_y%(18)+h|+d%,g_nb$(26,t|,0,1)
  '                      ! Pause mit Taktstrich, 'gebunden':
  GET g_x%(18),g_y%(18)+d%,g_x%(18)+nb|,g_y%(18)+h|+d%,g_nb$(26,t|,1,1)
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 3_hilfslinie_a2       !_:
  ' ----------------------------------------------------------------------------
  LOCAL ha2x|            ! Hilfslinie a2: x-Startkoordinate
  LOCAL ha2y|            ! Hilfslinie a2: y-Startkoordinate
  LOCAL hd|              ! Hilflinienbreite
  LOCAL x1%              ! links
  LOCAL y%               ! y-Koordinate
  LOCAL x2%              ! rechts
  ' ............................................................................
  LET ha2x|=4            ! Hilfslinie a2: x-Startkoordinate
  LET ha2y|=17           ! Hilfslinie a2: y-Startkoordinate
  LET hd|=9              ! Hilflinienbreite
  ' ............................................................................
  FOR i|=1 TO 8          ! Alle Noten mit Hals nach unten durch
    LET x1%=g_x%(i|)+ha2x|! links
    LET y%=g_y%(i|)+ha2y|! y-Koordinate
    LET x2%=x1%+hd|      ! rechts
    LINE x1%,y%,x2%,y%   ! Hilfslinie malen
  NEXT i|                ! NÑchste Note mit Hals nach unten
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 3_hilfslinie_h2       !_:
  ' ----------------------------------------------------------------------------
  LOCAL hh2x|            ! Hilfslinie h2: x-Startkoordinate
  LOCAL hh2y|            ! Hilfslinie h2: y-Startkoordinate
  LOCAL hd|              ! Hilflinienbreite
  LOCAL x1%              ! links
  LOCAL y%               ! y-Koordinate
  LOCAL x2%              ! rechts
  ' ............................................................................
  LET hh2x|=4            ! Hilfslinie h2: x-Startkoordinate
  LET hh2y|=20           ! Hilfslinie h2: y-Startkoordinate
  LET hd|=9              ! Hilflinienbreite
  ' ............................................................................
  FOR i|=1 TO 8          ! Alle Noten mit Hals nach unten durch
    LET x1%=g_x%(i|)+hh2x|! links
    LET y%=g_y%(i|)+hh2y|! y-Koordinate
    LET x2%=x1%+hd|      ! rechts
    LINE x1%,y%,x2%,y%   ! Hilfslinie malen
  NEXT i|                ! NÑchste Note mit Hals nach unten
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 3_hilfslinie_c3       !_:
  ' ----------------------------------------------------------------------------
  LOCAL hc3x|            ! Hilfslinie c3: x-Startkoordinate
  LOCAL hc3y|            ! Hilfslinie c3: y-Startkoordinate
  LOCAL hd|              ! Hilflinienbreite
  LOCAL x1%              ! links
  LOCAL y%               ! y-Koordinate
  LOCAL x2%              ! rechts
  ' ............................................................................
  LET hc3x|=4            ! Hilfslinie c3: x-Startkoordinate
  LET hc3y|=23           ! Hilfslinie c3: y-Startkoordinate
  LET hd|=9              ! Hilflinienbreite
  ' ............................................................................
  FOR i|=1 TO 8          ! Alle Noten mit Hals nach unten durch
    LET x1%=g_x%(i|)+hc3x|! links
    LET y%=g_y%(i|)+hc3y|! y-Koordinate
    LET x2%=x1%+hd|      ! rechts
    LINE x1%,y%,x2%,y%   ! Hilfslinie malen
  NEXT i|                ! NÑchste Note mit Hals nach unten
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 3_hilfslinie_c1(yk%)  !_:
  ' ----------------------------------------------------------------------------
  ' yk%                  ! y-Korrekturfaktor (s.a. Bild unter 'rga%')
  ' ----------------------------------------------------------------------------
  LOCAL hc1x|            ! Hilfslinie c1: x-Startkoordinate
  LOCAL hc1y|            ! Hilfslinie c1: y-Startkoordinate
  LOCAL hd|              ! Hilflinienbreite
  LOCAL x1%              ! links
  LOCAL y%               ! y-Koordinate
  LOCAL x2%              ! rechts
  ' ............................................................................
  LET hc1x|=4            ! Hilfslinie c1: x-Startkoordinate
  LET hc1y|=59           ! Hilfslinie c1: y-Startkoordinate
  LET hd|=9              ! Hilflinienbreite
  ' ............................................................................
  FOR i|=9 TO 16         ! Alle Noten mit Hals nach oben durch
    LET x1%=g_x%(i|)+hc1x|! links
    LET y%=g_y%(i|)+hc1y|+yk%! y-Koordinate
    LET x2%=x1%+hd|      ! rechts
    LINE x1%,y%,x2%,y%   ! Hilfslinie malen
  NEXT i|                ! NÑchste Note mit Hals nach oben
  ' ----------------------------------------------------------------------------
RETURN
' ------------------------------------------------------------------------------
> PROCEDURE 1_notenlinien         !_:
  ' ----------------------------------------------------------------------------
  LOCAL n1y|                    ! Pos. 1.Notenlinie: g_y%(?)+n1y|
  LOCAL npz|                    ! Anzahl der Noten pro Zeile berechnen:
  LOCAL i|                      ! NotenzeilenzÑhler
  LOCAL j|                      ! NotenlinienzÑhler
  ' ............................................................................
  LET n1y|=29                   ! Pos. 1.Notenlinie: g_y%(?)+n1y|(s.a.'invers')
  LET npz|=g_bb%/(g_nb|)        ! Anzahl der Noten pro Zeile berechnen:
  ' ............................................................................
  FOR i|=1 TO g_za|             ! Alle Notenzeilen durch
    FOR j|=1 TO 5               ! Alle Notenlinien durch
      LET y%=g_y%(1+(i|-1)*npz|)+n1y|+(j|-1)*g_la| ! Notenlinien-y-Koordinate
      LINE 0,y%,g_bb%,y%        ! Notenlinie zeichnen
    NEXT j|                     ! nÑchste Notenlinie
  NEXT i|                       ! nÑchste Notenzeile
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 1_begrenzungslinien   !_:
  ' ----------------------------------------------------------------------------
  LOCAL npz|                    ! Anzahl der Noten pro Zeile berechnen:
  LOCAL i|                      ! NotenzeilenzÑhler
  ' ............................................................................
  LET npz|=g_bb%/(g_nb|)        ! Anzahl der Noten pro Zeile berechnen:
  ' ............................................................................
  FOR i|=1 TO g_za|             ! Alle Notenzeilen durch
    LET y%=g_y%(1+(i|-1)*npz|)-1! y-Koordinate der oberen Begrenzungslinie
    LINE 0,y%,g_bb%,y%          ! Obere Begrenzungslinie zeichnen
  NEXT i|                       ! NÑchste Notenzeile
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 1_klaviatur           !_:
  ' ----------------------------------------------------------------------------
  LOCAL ntb|                    ! Notentastenbreite
  LOCAL ptb|                    ! Pausentastenbreite
  LOCAL i|                      ! TastenzÑhler
  LOCAL x1%                     ! links
  LOCAL y1%                     ! oben
  LOCAL x2%                     ! rechts
  LOCAL y2%                     ! unten
  ' ............................................................................
  LET ntb|=g_ntb|               ! Notentastenbreite
  LET ptb|=g_ptb|               ! Pausentastenbreite
  LET y1%=0                     ! oben
  LET y2%=g_mh|-1               ! unten=MenÅhîhe-1
  ' ............................................................................
  FOR i|=1 TO g_tha|+1          ! Alle Notentasten durch
    LET x1%=ptb|+(i|-1)*ntb|    ! links
    LET x2%=ptb|+i|*ntb|        ! rechts
    LINE x1%,y1%,x1%,y2%        ! Tastenbegrenzung links
    '                           ! F schwarze Taste:
    IF i|=2 OR i|=4 OR i|=7 OR i|=9 OR i|=11 OR i|=14 OR i|=16 OR i|=19 OR i|=21 OR i|=23
      PBOX x1%,y1%,x2%,y2%      ! schwarze Taste malen
    ENDIF                       ! EF schwarze Taste
  NEXT i|                       ! nÑchste Notentaste
  ' ............................................................................
  BOUNDARY 0                    ! Rand ausschalten
  DEFFILL 1,2,4                 ! Muster fÅr Pausentaste
  PBOX x1%+1,y1%,x1%+ptb|,y2%-1 ! Pausentaste rechts
  PBOX 0,y1%,ptb|-1,y2%-1       ! Pausentaste links
  DEFFILL 1,2,8                 ! Muster wieder schwarz
  BOUNDARY 1                    ! Rand wieder einschalten
  ' ............................................................................
  GET 0,0,g_bb%-1,g_mh|-1,g_kl$ ! Klaviatur fotografieren
  ' ----------------------------------------------------------------------------
RETURN
' ------------------------------------------------------------------------------
> PROCEDURE 0_midi_vorbereiten    !_:
  ' ----------------------------------------------------------------------------
  IF g_midi!=TRUE                       ! F Midi ein:
    OUT 3,192,g_k1|                     ! Sound fÅr Kanal 1
    OUT 3,193,g_k2|                     ! Sound fÅr Kanal 2
    OUT 3,194,g_k3|                     ! Sound fÅr Kanal 3
  ENDIF                                 ! d
  ' ----------------------------------------------------------------------------
RETURN
' ------------------------------------------------------------------------------
> PROCEDURE 0_hauptfile_laden     !_:
  ' ----------------------------------------------------------------------------
  LOCAL dummy|                          ! Dummy fÅr Alertbox
  LOCAL dummy%                          ! Dummy fÅr RECALL-Befehl
  LOCAL m$                              ! Speicher fÅr Filename
  ' ............................................................................
  IF (NOT EXIST(g_hf$)) OR g_w!         ! f Notenhauptdatei nicht auf Disk oder
    '                                   ! Wahlmîglichkeit erwÅnscht:
    FILESELECT "A:\*.NTN",m$,m$         ! Fileselectbox
    IF m$="" OR NOT EXIST(m$)           ! F Abbruch gewÑhlt:
      @a_alert("Hauptfile wird im RAM neuangelegt!/ok!",dummy|)
      LET g_stueck$(0)=STRING$(g_stka|*8,"_")!Inhaltsverz. mit Leerz. auffÅllen
      LET g_stueck$(1)=g_stueck$(0)         ! Datumteil
      FOR s%=2 TO g_stka|+1                 ! Alle StÅcke durch
        LET g_stueck$(s%)=STRING$(800,"@")  ! Mit Leerzeichen auffÅllen
      NEXT s%                               ! nÑchstes StÅck
      GOTO raus_0_hauptfile_laden       ! d
    ELSE                                ! sonst:
      LET g_hf$=RIGHT$(m$,LEN(m$)-3)    ! 'A:\' wegschneiden
    ENDIF                               ! d
  ENDIF                                 ! d
  ' ............................................................................
  OPEN "I",#1,g_hf$                     ! Hauptnotenfile îffnen
  RECALL #1,g_stueck$(),-1,dummy%       ! Array laden
  CLOSE #1                              ! File schlieûen
  ' ............................................................................
  raus_0_hauptfile_laden:               ! d
  @1_fileselectboxfoto                  ! Fileselectbox fotografieren
  SPUT g_lb$                            ! Lîschbildschirm
  PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9     ! Cusor ein
  ' ............................................................................
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 1_fileselectboxfoto   !_:
  ' ----------------------------------------------------------------------------
  ' Hier wird die Fileselectbox angezeigt und fotografiert. Diese Prozedur wird
  ' auch von 'abspeichern' aus aufgerufen.
  ' ----------------------------------------------------------------------------
  LOCAL i|                                      ! ZÑhlvariable
  LOCAL a|                                      ! Wahlvariable fÅr MenÅ
  LOCAL m|                                      ! Maustastenvar. fÅr MenÅ
  LOCAL c$                                      ! Bildschirmnegativ
  DIM a$(g_stka|)                               ! MenÅeintragsfelderarray dim.
  DIM a%(g_stka|)                               ! Nummerierungsarray dim.
  ' ............................................................................
  SGET c$                                       ! Bildschirm retten
  ' ............................................................................
  SPUT g_lb$                                    ! Lîschbild ausgeben, wichtig,
  '                                             ! weil diese Proc.auch von
  '                                             ! 'abspeichern' aus aufger.wird
  ' ............................................................................
  FOR i|=1 TO g_stka|                           ! Alle MenÅeintrÑge durch
    LET a$(i|)=MID$(g_stueck$(0),(i|-1)*8+1,8)  ! Ins MenÅeintragsfeld kopieren
    LET a%(i|)=i|                               ! Nummerierungsarrayeintrag
  NEXT i|                                       ! nÑchster MenÅeintrag
  ' ............................................................................
  QSORT a$(),g_stka|+1,a%()                     ! Sortieren
  ' ............................................................................
  @a_menue(-1,0,0,0,0,-1,4,4,8,20,m|,a|,a$(),d!()) ! MenÅprozedur aufrufen
  LET a|=a%(a|)                                 ! wirkliche Wahlnummer ermitteln
  ' ............................................................................
  SGET g_fsb$                                   ! Fileselectbox fotografieren
  ' ............................................................................
  SPUT c$                                       ! Bildschirm wieder herstellen
  ' ............................................................................
  ERASE a$()                                    ! MenÅeintragsarray lîschen
  ERASE a%()                                    ! Nummerierungsarray lîschen
  ' ----------------------------------------------------------------------------
RETURN
' ##############################################################################
'  N o t e n e i n g a b e :
' ##############################################################################
> PROCEDURE 0_hauptschleife       !_:
  ' ----------------------------------------------------------------------------
  ' Dies ist die oberste Ebene des Hauptprogramms. In der Schleife wird erst
  ' eine Unterprozedur aufgerufen, die Nach Maus- und Tastatur fragt. Wurde
  ' dort eine Eingabe gemacht, geht's hier wieder weiter. Es wird untersucht,
  ' welcher der Befehle in der Tabelle (oder Helptaste) angesprochen wurde und
  ' daraufhin entsprechend verzweigt. Nach Beendigung des Befehls geht's dann
  ' wieder von vorne los, usw. bis zum bestÑtigten Befehl 'Programmende'.
  ' ----------------------------------------------------------------------------
  LOCAL t|      ! Help-Taste? Undo-Taste?
  LOCAL o|      ! - 2 Oktaven ?
  LOCAL x%      ! Maus-x-Koordinate
  LOCAL y%      ! Maus-y-Koordinate
  ' ----------------------------------------------------------------------------
  ' Achtung!  Erst Zeilen-, dann Spaltennummer ! ! !
  '
  '
  '              1.Spalte:    2.Spalte:    3.Spalte:    4.Spalte:    5.Spalte:
  '
  '            | linksoben  | Notentaste | rechtsoben | Notentext  | Cursor   |
  '
  '            |--------------------------------------------------------------|
  ' 1  LMT     | Pause      | 1/8 Note   | Pause      | Cursorpos. | Taktstr. |
  '            |------------+------------+------------+------------+----------|
  ' 2  RMT     | HauptmenÅ  | Nur Ton    | Backspace  | Abspielen  | FÑhnchen |
  '            |--------------------------------------------------------------|
  DO
    LET t|=0
    LET o|=0
    @1_a(x%,y%,o|,t|)
    IF t|=1
      @1_helptext
    ELSE IF t|=2
      @1_undo
    ELSE IF g_zs!(1,1) ! 1. Zeile: --------------------------------------------
      @1_write(0,x%)                    ! Pause
    ELSE IF g_zs!(1,2)
      @1_write(o|,x%)                   ! 1/8 Note
    ELSE IF g_zs!(1,3)
      @1_write(0,x%)                    ! Pause
    ELSE IF g_zs!(1,4)
      @1_neu_cpos(x%,y%)                ! Cursorpos.
    ELSE IF g_zs!(1,5)
      @1_takt_setzen                    ! Taktstr.
    ELSE IF g_zs!(2,1) ! 2. Zeile: --------------------------------------------
      @0_hauptmenue                     ! HauptmenÅ
    ELSE IF g_zs!(2,2)
      @1_nur_ton(o|,x%)                 ! Nur Ton
    ELSE IF g_zs!(2,3)
      @1_backspace                      ! Backspace
    ELSE IF g_zs!(2,4)
      @1_spielen(x%,y%)                 ! Abspielen
    ELSE IF g_zs!(2,5)
      @1_faehnchen                      ! FÑhnchen
    ENDIF
    ' ..........................................................................
  LOOP
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 1_a(VAR x%,y%,v|,k|)  !_:
  ' ----------------------------------------------------------------------------
  ' In dieser Prozedur werden Maus und Tastatur abgefragt auf:
  ' Maustasten, Mauskoordinaten, Alternate-Taste, Helptaste
  ' Die der Befehlstabelle (siehe 'hauptschleife' oder 'Dokumentation')
  ' entsprechenden Bedingungen werden abgefragt und die Ergebnisse in einem
  ' Boolean-Array zurÅckÅbergeben, das ist: g_zs!() .
  ' ----------------------------------------------------------------------------
  '
  ' x%                    ! Maus-x-Koordinate
  ' y%                    ! Maus-y-Koordinate
  ' v|                    ! Minuszweioktavenflag gesetzt ?
  ' k|                    ! =1 f Help-taste, =2 f Undotaste
  ' g_zs!()               ! Array fÅr Befehlsanalyse
  '
  LOCAL lmt!              ! Linke Maustaste ?   -1=ja,  0=nein
  LOCAL rmt!              ! rechte Maustaste ?  -1=ja,  0=nein
  LOCAL jnb!              ! -1=Notenbereich 0=Klaviatur
  '
  LOCAL bs!               ! Bildschirm schwarz gewesen ?
  '
  LOCAL m|                ! Maustaste
  LOCAL dummy|            ! Bei Mausabfrage Tastaturinfo ÅberflÅssig
  LOCAL midi|             ! Midi-Code-Variable
  '
  LOCAL n%                ! Notennummer unterm Mauspfeil
  LOCAL t%                ! Zeitmesser fÅr Bildschirmabschaltung
  '
  LOCAL r%                ! Speicher fÅr Tastaturcode(Alt/Contr)von: BIOS(11,-1)
  '
  LOCAL mx%               ! X-Koordinate der Maus merken
  LOCAL my%               ! Y-Koordinate der Maus merken
  '
  LOCAL s$                ! Speicher fÅr Tastaturcode (Help-Taste)
  '
  LOCAL a$                ! Negativspeicher fÅr Bildschirmrettung
  '
  LOCAL m$                ! Midiinformation
  '
  DIM z!(5)               ! Zeilenarray
  DIM s!(5)               ! Spaltenarray
  ' ............................................................................
  '     1. )   M a u s -  u n d  T a s t a t u r a b f r a g e :
  ' ............................................................................
  SHOWM                   ! Mauspfeil zeigen
  ' ............................................................................
  REPEAT                  ! Warteschleife zum Entleeren von Maus-und Tast.puffer
    LET r%=BIOS(11,-1)    ! F noch Taste, in r% merken
  UNTIL MOUSEK=0 AND INKEY$="" AND r%<>2 AND r%<>16+2 ! es braucht inkey und r%
  ' r%=2 oder r%=16+2 bedeutet Shift (Backspace), das soll keine automatische
  ' Wiederholung bekommen, also stoppen.
  ' ............................................................................
  REPEAT                  ! Abfrageschleife,analysiert nur,ob Maus od.Tastatur:
    ' ..........................................................................
    '                     ! S c h w a r z s c h a l t u n g :
    INC t%                ! Zeitmesser raufsetzen
    IF t%=50000           ! F Zeit fÅr Bildschirmabschaltung:
      HIDEM               ! Maus weg
      IF bs!=FALSE        ! F Bildschirm bisher noch nicht schwarz
        SGET a$           ! Bildschirm retten
      ENDIF               ! d
      PBOX 0,0,g_bb%-1,g_bh%-1! Bildschirm schwarz
      LET bs!=TRUE        ! Bildschirm schwarz merken
      LET t%=0            ! Weiterlaufen ohne Overflow, deshalb null setzen
    ENDIF                 ! d
    IF (mx%<>MOUSEX OR my%<>MOUSEY) AND bs!=TRUE! F Mausbewegung + Blds.schwarz
      LET t%=0            ! Weiterlaufen ohne Overflow
      LET bs!=FALSE       ! Bildschirm nicht mehr schwarz
      SPUT a$             ! Bildschirm wieder herstellen
      SHOWM               ! Maus her
    ENDIF                 ! d
    LET mx%=MOUSEX        ! X-Koordinate der Maus merken
    LET my%=MOUSEY        ! Y-Koordinate der Maus merken
    ' ..........................................................................
    '                     ! E n t g Å l t i g e  A b f r a g e :
    MOUSE x%,y%,m|        ! Mausdaten Åbermitteln
    LET s$=INKEY$         ! Taste ?
    LET m$=INPMID$        ! Midiinfo ?
    LET r%=BIOS(11,-1)    ! F zusÑtzliche Taste, in r% merken
    ' Alternate: 8, Shiftlinks: 2, Control:4  , bei CapsLock: +16, Shiftrechts:1
    IF ASC(s$)=97 OR ASC(s$)=65 ! F 'a' oder 'A' gedrÅckt: StÅck spielen
      LET m|=2            ! linke Maustaste simulieren
      LET x%=g_x%(1)+1    ! x-Mauskoordinate auf 1.Note
      LET y%=g_y%(1)+1    ! y-Mauskoordinate auf 1.Note
    ENDIF                 ! d
    IF r%=2 OR r%=16+2    ! F Linksshift gedrÅckt: Wie Backspace=rechte Pausent.
      LET m|=2            ! rechte Maustaste simulieren
      LET x%=g_bb%-2      ! x-Mauskoordinate rechts simulieren
      LET y%=1            ! y-Mauskoordinate oben simulieren
    ENDIF                 ! d
    IF ASC(s$)=27         ! F "Esc"-Taste :Wie HauptmenÅ=linke Pausentaste
      LET m|=2            ! rechte Maustaste simulieren
      LET x%=1            ! x-Mauskoordinate links simulieren
      LET y%=1            ! y-Mauskoordinate oben simulieren
    ENDIF                 ! d
    IF s$=" "             ! F Space gedrÅckt: Wie irgendeine Pausentaste
      LET m|=1            ! linke Maustaste simulieren
      LET x%=1            ! x-Mauskoordinate links simulieren
      LET y%=1            ! y-Mauskoordinate oben simulieren
    ENDIF                 ! d
    IF r%=4 OR r%=16+4    ! F Control gedrÅckt: Cursor nach links
      IF g_n%>1           ! F links von Cursor noch was ist:
        LET m|=1          ! linke Maustaste simulieren
        LET x%=g_x%(g_n%-1)+1 ! x-Mauskoordinate auf Note links v. akt. Cursor
        LET y%=g_y%(g_n%-1)+1 ! y-Mauskoordinate auf Note links v. akt. Cursor
      ELSE                ! F links vom Cursor nichts mehr ist:
        LET r%=0          ! Keine weitere Botschaft mehr
      ENDIF               ! d
    ENDIF                 ! d
    IF ASC(s$)=9 AND g_n%<g_os% ! F "Tab"-Taste gedrÅckt: Cursor nach rechts
      IF g_n%<g_os%       ! F rechts von Cursor noch was sein kann:
        LET m|=1          ! linke Maustaste simulieren
        LET x%=g_x%(g_n%+1)+1 ! x-Mauskoordinate auf Note links v. akt. Cursor
        LET y%=g_y%(g_n%+1)+1 ! y-Mauskoordinate auf Note links v. akt. Cursor
      ELSE                ! F rechts vom Cursor nichts mehr ist:
        LET s$=""         ! Keine weitere Botschaft mehr
      ENDIF               ! d
    ENDIF                 ! d
    ' ..........................................................................
    '                     ! B e i  M i d i  a u f r Ñ u m e n :
    IF m$<>"" AND (r%=8 OR r%=16+8)  ! F was in Midi kam und Alternate-Taste:
      IF RIGHT$(m$,1)="@" ! F letzte Meldung: Ton ein:
        LET m$=INPMID$    ! 'Ton aus'-Meldung holen
      ENDIF               ! d
      LET midi|=ASC(LEFT$(m$,1))  ! Tonhîhe feststellen
    ENDIF                 ! d
    ' ..........................................................................
  UNTIL m| OR s$<>"" OR midi|<>0     ! F Eingabe
  ' ............................................................................
  IF bs!                  ! F Bildschirm noch schwarz:
    SPUT a$               ! Bildschirm wieder herstellen
    SHOWM                 ! Maus her
  ENDIF                   ! d
  ' ............................................................................
  IF NOT g_midi!                        ! F kein Midi-Keyboard angeschlossen:
    WAVE 0,0                            ! Ton aus
  ELSE                                  ! F Midi-Keyboard angeschlossen
    OUT 3,128,g_mt1|,1                  ! alten Ton aus Kanal 1
    OUT 3,128,g_mt1|-24,1               ! alten Taktstrichton aus Kanal 1
    OUT 3,129,g_mt2|,1                  ! alten Ton aus Kanal 2
    OUT 3,130,g_perc|                   ! alten Ton aus Kanal 3
  ENDIF                                 ! d
  ' ............................................................................
  '     2. )  e r s t e  P e r i p h e r i e e i n g a b e a u s w e r t u n g :
  ' ............................................................................
  IF m$<>""                     ! F Midi-Eingabe
    IF midi|>59 AND midi|<59+26 ! F 'legale' Tonhîhe fÅr Oktaven Nr. 3 und 4
      LET midi|=midi|-59        ! tonhîhe einsetzen
      LET x%=midi|*g_ntb|+g_ptb|-5     ! x-Koordinate fÅr entsprechende Taste
      LET y%=1                  ! y-Koordinate fÅr Klaviatur
      LET m|=1                  ! linke Maustaste simulieren
    ELSE IF midi|>35 AND midi|<60 ! F 'legale' Tonhîhe fÅr Oktaven Nr. 1 und 2
      LET midi|=midi|-35        ! tonhîhe einsetzen
      LET x%=midi|*g_ntb|+g_ptb|-5     ! x-Koordinate fÅr entsprechende Taste
      LET y%=1                  ! y-Koordinate fÅr Klaviatur
      LET m|=1                  ! linke Maustaste simulieren
      LET v|=1                  ! Minuszweioktavenflag gesetzt
    ENDIF                       ! d
  ENDIF                         ! d
  ' ............................................................................
  LET lmt!=(2-m|)               ! Linke Maustaste ?
  LET rmt!=NOT lmt!             ! rechte Maustaste ?
  LET jnb!=(y%>g_mh|)           ! auf Notenbereich ?
  LET z!(1)=lmt!                !                                    Zeile [1]
  LET z!(2)=rmt!                !                                    Zeile [2]
  LET s!(1)=(NOT jnb!) AND (x%<g_ptb|) ! Linke Pausentaste ?         Spalte [a]
  LET s!(3)=(NOT jnb!) AND (x%>g_bb%-g_ptb|)  ! Rechte Pausentaste ? Spalte [c]
  LET s!(2)=(NOT jnb!) AND (NOT s!(1)) AND (NOT s!(3)) ! Notentaste ?Spalte [b]
  IF y%>g_mh|                   ! f Maus auf Notenbereich :
    @3_notenr(x%,y%,n%)         ! Welche Note liegt unter dem Mauspfeil?
    IF n%=g_n%                  ! F Cursor bereits auf Note unter Mauspfeil:
      LET s!(5)=TRUE            !                                    Spalte [e]
    ELSE                        ! F Cursor nicht auf Note unter Mauspfeil:
      LET s!(4)=TRUE            !                                    Spalte [d]
    ENDIF                       ! d
  ENDIF                         ! d
  ' ............................................................................
  '     3. )  ö b e r g a b e p a r a m e t e r  s e t z e n :
  ' ............................................................................
  FOR i|=1 TO 2                 ! Alle Zeilen durch
    FOR j|=1 TO 5               ! Alle Spalten durch
      LET g_zs!(i|,j|)=z!(i|) AND s!(j|) ! Zeilen-Spalten-Array setzen
    NEXT j|                     ! NÑchste Spalte
  NEXT i|                       ! NÑchste Zeile
  IF (g_zs!(1,2) OR g_zs!(2,2)) AND (r%=1 OR r%=16+1)   ! F Rechtsshift gedrÅckt
    '                   ! und auûerdem eine Note eingegeben wurde oder 'Nurton'
    LET v|=1            ! Minuszweioktavenflag gesetzt
  ENDIF                 ! d
  IF ASC(RIGHT$(s$,1))=98       ! [Help]-Taste gedrÅckt ?
    LET k|=1                    ! öbergabecode fÅr diese Taste
  ELSE IF ASC(RIGHT$(s$,1))=97 AND LEN(s$)=2 ! [Undo]-Taste gedrÅckt ?
    LET k|=2                    ! öbergabecode fÅr diese Taste
  ENDIF                         ! d
  ' ............................................................................
  ERASE z!(),s!()               ! Einzelfelder weg, sonst mehrfaches Dimens.
  ' ----------------------------------------------------------------------------
RETURN
' ------------------------------------------------------------------------------
> PROCEDURE 1_helptext            !_:
  ' ----------------------------------------------------------------------------
  ' Hier wird der bereits im Vorbereitungsteil des Programms photographierte
  ' Hilfstext ausgegeben und auf einen Tastendruck gewartet
  ' ----------------------------------------------------------------------------
  LOCAL ft|                       ! Nr. des 1. falschen Takts
  LOCAL tn|                       ! Taktnummer des letzten Taktes
  LOCAL i|                        ! ZÑhler fÅr Textarray
  LOCAL j|                        ! ZÑhler fÅrs Invertieren
  LOCAL d|                        ! Dauer einer Viertelnote in Sekunden
  LOCAL t%                        ! Zeitmeûvariable
  LOCAL s%                        ! Anzahl der schwarzen Tasten
  LOCAL w%                        ! Anzahl der weiûen Tasten
  LOCAL a$                        ! Zwischenspeicher fÅr Infotextzeile
  LOCAL b$                        ! Bildschirmnegativ zum Bildschirm retten
  LOCAL i$                        ! Infostring
  LOCAL t$                        ! Negativ fÅr unteren Textteil fÅrsInvertieren
  LOCAL takt$                     ! Art des Takts
  DIM a$(20)                      ! Array fÅr Infotext
  DIM n$(g_stka|)                 ! Array fÅr StÅcknamen
  ' ............................................................................
  LET d|=8                        ! Dauer einer Viertelnote in Zehntelsekunden
  '                               ! Muû duch 2^3=8 teilbar sein: 3 FÑnchen mîgl.
  SGET b$                         ! Bildschirm retten
  SPUT g_hp$                      ! Helptext ausgeben
  ' ............................................................................
  '     1.)  I n f o t e x t a r r a y  f Å l l e n :
  ' ............................................................................
  '          1234567890123456789012345678901234567890
  LET a$(1)="Freier Speicher in Bytes: '"+STR$(FRE(0))+"'"
  LET a$(2)="Name des aktuellen StÅcks: '"+g_fn$+"'"
  FOR i|=1 TO g_stka|             ! Alle MenÅeintrÑge durch (physikalisch)
    LET n$(i|)=MID$(g_stueck$(0),(i|-1)*8+1,8)    ! Namen festhalten
    IF g_fn$=n$(i|)               ! f Namen gefunden
      LET j|=i|                   ! Nummer des gefundenen Namens merken
    ENDIF                         ! d
  NEXT i|                         ! nÑchster MenÅeintrag
  LET a$(3)="physikalische Nr. des StÅckes: '"+STR$(j|)+"'"
  QSORT n$()                      ! Namen alph. sortieren
  FOR i|=1 TO g_stka|             ! Alle MenÅeintrÑge durch (alphabetisch)
    EXIT IF g_fn$=n$(i|)          ! raus f Namen gefunden
  NEXT i|                         ! nÑchster MenÅeintrag
  LET a$(4)="alphabetische Nr. des StÅckes: '"+STR$(i|)+"'"
  @2_t(tn|,ft|,d|,t%)             ! Letzte Taktnr. und Nr. des 1.falschen Takts
  LET a$(5)="Nummer des letzten Taktes:' "+STR$(tn|)+"'"
  LET a$(6)="Nr. des ersten falschen Taktes: '"+STR$(ft|)+"'"
  LET a$(7)="1/4 Note dauert: '"+STR$(d|)+"'Zehntelsekunden"
  LET a$(8)="Dauer des StÅcks in Zehntelsek.: '"+STR$(t%)+"'"
  LET a$(9)="Notenanzahl: '"+STR$(g_mn%)+"'"
  @2_shwtch(s%,w%,z!)             ! Mehr schwarze als weiûe Tasten ?
  LET a$(10)="Anzahl der schwarzen Tasten: '"+STR$(s%)+"'"
  LET a$(11)="Anzahl der weiûen Tasten:   '"+STR$(w%)+"'"
  LET a$(12)="Name des Hauptfiles: '"+g_hf$+"'"
  ' ............................................................................
  '     2.)  I n f o t e x t  a n z e i g e n :
  ' ............................................................................
  LET j|=0                        ! InverszÑhler null
  FOR i|=1 TO 6                   ! Linke Spalte des Infotextes:
    INC j|                        ! ZÑhler fÅrs Invertieren
    IF ODD(j|)                    ! F j| ungerade:
      PRINT CHR$(27);CHR$(112);   ! Invers ein
    ELSE                          ! F j| gerade:
      PRINT CHR$(27);CHR$(113);   ! Invers aus
    ENDIF                         ! d
    LET a$=a$(i|)                 ! Infozeile Åbergeben
    LET a$=a$+SPACE$(40-LEN(a$))  ! Infozeile auf LÑnge von 40 erweitern
    PRINT AT(1,2+i|);a$;          ! Infozeile ausgeben
  NEXT i|                         ! nÑchste Zeile der linken Spalte des Infos
  LET j|=0                        ! InverszÑhler null
  FOR i|=7 TO 12                  ! Rechte Spalte des Infotextes:
    INC j|                        ! ZÑhler fÅrs Invertieren
    IF EVEN(j|)                   ! F j| gerade:
      PRINT CHR$(27);CHR$(113);   ! Invers aus
    ELSE                          ! F j| ungerade:
      PRINT CHR$(27);CHR$(112);   ! Invers ein
    ENDIF                         ! d
    LET a$=a$(i|)                 ! Infozeile Åbergeben
    LET a$=a$+SPACE$(40-LEN(a$))  ! Infozeile auf LÑnge von 40 erweitern
    PRINT AT(41,2+i|-6);a$;       ! Infozeile ausgeben
  NEXT i|                         ! nÑchste Zeile der rechten Spalte des Infos
  PRINT CHR$(27);CHR$(113);       ! Invers aus
  GET 0,18*16,g_bh%-1,g_bb%-1,t$  ! Unteren Textteil fotografieren
  PUT 0,18*16,t$,8                ! Invers ausgeben
  ' ............................................................................
  '     3.)  W a r t e n   a u f  T a s t e n d r u c k :
  ' ............................................................................
  REPEAT                          ! Warteschleife, damit's Bild erst mal bleibt:
  UNTIL INKEY$=""                 ! Erst Raus, wenn Puffer leer
  REPEAT                          ! Warteschleife
    PRINT AT(60,1);DATE$;"  ";TIME$ ! Datum + Uhrzeit ausgeben
  UNTIL MOUSEK OR INKEY$<>""      ! Raus, falls Taste gedrÅckt
  ' ............................................................................
  SPUT b$                         ! Bildschirm wiederherstellen
  ERASE a$()                      ! Array fÅr Infotext lîschen
  ERASE n$()                      ! Array fÅr StÅcknamen lîschen
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 2_t(VAR tn|,ft|,d|,t%)!_:
  ' ----------------------------------------------------------------------------
  ' Hier wird die Nummer des ersten falschen Taktes, sowie die Nr. des letzten
  ' Taktes und die Gesamtdauer des StÅcks in Zehntelssekunden ermittelt.
  ' ----------------------------------------------------------------------------
  ' ft|                           ! Nr. des 1. falschen Takts
  ' tn|                           ! Taktnummer, am Ende: Nr. des letzten Taktes
  ' d|                            ! Dauer einer Viertelnote in Sekunden
  ' t%                            ! Zeitmeûvariable
  '
  LOCAL b|                        ! Periodendauer der akt. Note
  LOCAL p|                        ! Betonungsmerker der akt. Note
  LOCAL i|                        ! ZÑhler fÅr StÅcknummerermittlung
  LOCAL i%                        ! ZÑhler fÅr Zeitmessung
  ' ............................................................................
  LET tn|=1                       ! Mit erstem Takt anfangen
  FOR i%=1 TO g_mn%               ! Alle Noten durch
    ' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    LET b|=VAL(MID$(g_n$(i%),2,1))!  Periode
    LET p|=VAL(RIGHT$(g_n$(i%),1))!  betont?
    ' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    IF t%=3*(d|/2) AND p|=1       ! F Taktstrich und 3/8 bisher:
      LET takt$="3/8"             ! 3/8-Takt ist angesagt
    ELSE IF t%=4*(d|/2) AND p|=1  ! F Taktstrich und 4/8 bisher:
      LET takt$="4/8"             ! 4/8-Takt ist angesagt
    ENDIF                         ! EFU 3/8, 4/8
    ' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    IF takt$="3/8" AND p|=1       ! F 3/8-Takt und akt. Note mit Taktstrich:
      IF t%-(tn|-1)*(3*(d|/2))<>3*(d|/2) AND ft|=0 ! F letzter Takt falsch
        LET ft|=tn|               ! Taktnr. des 1.falschen Takts merken
      ENDIF                       ! d
    ELSE IF takt$="4/8" AND p|=1  ! F 4/8-Takt und akt. Note mit Taktstrich:
      IF t%-(tn|-1)*(4*(d|/2))<>4*(d|/2) AND ft|=0 ! F letzter Takt falsch
        LET ft|=tn|               ! Taktnr. des 1.falschen Takts merken
      ENDIF                       ! d
    ENDIF                         ! EFU 3/8, 4/8
    ' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    LET t%=t%+d|/(2^b|)           ! Notendauer bei 1/4=d sec.
    ' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    IF p|=1                       ! F Taktstrich:
      INC tn|                     ! Taktnummer erhîhen
    ENDIF                         ! d
    ' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  NEXT i%                         ! nÑchste Note
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 1_undo                !_:
  ' ----------------------------------------------------------------------------
  ' Falls im gu_n$()-Array sich ein StÅck befindet, so wird es mit dem StÅck im
  ' g_n$()-Arrray ausgetauscht.
  ' ............................................................................
  IF gu_mn%=0                   ! F gar kein UndostÅck da:
    GOTO raus_undo              ! raus
  ENDIF                         ! d
  ' ............................................................................
  SWAP g_mn%,gu_mn%             ! StÅcklÑnge des UndostÅcks wird jetzt aktuell
  SWAP g_n$(),gu_n$()           ! UndostÅck wird jetzt aktuell
  SPUT g_lb$                    ! Lîschbild
  IF g_mn%=g_os%                ! F 200 Noten
    LET g_n%=g_mn%              ! Cursor auf letzte Note
  ELSE                          ! sonst:
    LET g_n%=g_mn%+1            ! Notencursor hinter StÅckende
  ENDIF                         ! d
  @2_stueck_ganz_zeigen         ! d
  LET g_bla%=0                  ! Blockanfang lîschen
  LET g_ble%=0                  ! Blockende lîschen
  PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9 ! Cusor ein
  ' ............................................................................
  raus_undo:                    ! Rauslabel
  ' ----------------------------------------------------------------------------
RETURN
' ------------------------------------------------------------------------------
> PROCEDURE 1_write(v|,x%)        !_:
  ' ----------------------------------------------------------------------------
  ' Es gibt zwei Mîglichkeiten. Entweder der Editor befindet sich im Moment
  ' im Insertmodus (g_n%<g_mn%+1) oder im Endschreibmodus (g_n%=g_mn%+1). Ent-
  ' sprechend wird dann in die jeweiligen Unterprozeduren verzweigt.
  ' ............................................................................
  ' v|                     ! Minuszweioktavenflag gesetzt ?
  ' x%                     ! Koordinate der Maus auf der Klaviatur
  ' ----------------------------------------------------------------------------
  IF g_bla%=0 AND g_ble%=0 ! Nur schreiben, wenn keine Blockmarken existieren
    IF g_n%<g_mn%+1        ! F nicht Endschreibmodus, also Insertmodus
      @2_insert(v|,x%)     ! d
    ELSE                   ! F Endschreibmodus
      @2_endeschr(v|,x%)   ! d
    ENDIF                  ! EFU Insertmodus / Endschreibmodus
  ENDIF                    ! d
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 2_endeschr(v|,x%)     !_:
  ' ----------------------------------------------------------------------------
  ' Diese Prozedur wird im Endschreibmodus aufgerufen und sorgt dafÅr, daû die
  ' durch eine Klaviaturtaste vom Benutzer bereits festgelegte Note hinten am
  ' Notentextende angefÅgt wird.
  ' ----------------------------------------------------------------------------
  ' v|                              ! Minuszweioktavenflag gesetzt ?
  ' x%                              ! Koordinate der Maus auf der Klaviatur
  LOCAL f!                          ! Fehlerflag fÅr Tonausgabe
  LOCAL h|                          ! Notentastennummer
  ' ............................................................................
  IF g_mn%>=g_os%                   ! F Nummer der letzten Note >=obere Schranke
    GOTO raus_endeschreiben         ! d
  ENDIF                             ! d
  ' ............................................................................
  IF x%<g_ptb| OR x%>g_bb%-g_ptb|   ! Pausentaste ?
    LET h|=26                       ! Pausencode
  ELSE                              ! Notentaste:
    LET h|=TRUNC((x%-g_ptb|)/g_ntb|)+1! Notentaste feststellen
  ENDIF                             ! d
  PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9 ! Cusor aus
  PUT g_x%(g_n%),g_y%(g_n%),g_nb$(h|,1,v|,0),7      ! Note auf Bildschirm
  LET g_n$(g_n%)=CHR$(64+h|)+"1"+STR$(v|)+"0"       ! Note abspeichern
  LET g_proctest$="endeschr"        ! Name der aufrufenden Prozedur fÅrDebugging
  IF NOT g_midi!                    ! F kein Midi-GerÑt angeschlossen
    @a_tonausgabe(f!)               ! d
  ENDIF                             ! endif
  IF g_n%<g_os%                     ! F akt. Notennummer < obere Schranke
    INC g_n%                        ! Notennummer=Cursorposition erhîhen
  ENDIF                             ! d
  INC g_mn%                         ! Nummer der letzten Note erhîhen
  PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9 ! Cusor ein
  ' ............................................................................
  raus_endeschreiben:               ! d
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 2_insert(v|,x%)       !_:
  ' ----------------------------------------------------------------------------
  ' Bei Aufruf dieser Prozedur befindet sich der Editor momentan im Insert-
  ' modus, das heiût der Cursor steht nicht ganz am Notentextende auf dem Leer-
  ' platz hinter der letzten Note, sondern  a u f  irgendeiner Note. Dann wird
  ' die gewÅnschte, durch eine Klaviaturtaste vom Benutzer bereits festge-
  ' legte Note vor der Cursorposition im Notentext eingefÅgt.
  ' ----------------------------------------------------------------------------
  ' v|                              ! Vierteltonflag gesetzt ?
  ' x%                              ! Koordinate der Maus auf der Klaviatur
  LOCAL f!                          ! Fehlerflag fÅr Tonausgabe
  LOCAL h|                          ! Notentastennummer
  ' ............................................................................
  IF g_mn%>=g_os%                   ! F Notenendnr>= maximale obere Schranke
    GOTO raus_insert                ! Prozedur unverrichteter Dinge verlassen
  ENDIF                             ! d
  ' ............................................................................
  IF x%<g_ptb| OR x%>g_bb%-g_ptb|   ! Pausentaste ?
    LET h|=26                       ! Pausencode
  ELSE                              ! Notentaste:
    LET h|=TRUNC((x%-g_ptb|)/g_ntb|)+1! Notentaste feststellen
  ENDIF                             ! d
  ' ............................................................................
  PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9 ! Cusor aus
  ' ............................................................................
  '                                 ! Note im Notenspeicherstring einfÅgen:
  INSERT g_n$(g_n%)=CHR$(64+h|)+"1"+STR$(v|)+"0"
  INC g_mn%                         ! Nummer der letzten Note erhîhen
  @3_grafikinsert                   ! alles hinter & einschl.Cursor 1 weiter
  ' ............................................................................
  LET g_proctest$="insert"          ! Name der aufrufenden Prozedur fÅrDebugging
  IF NOT g_midi!                    ! F kein Midi-GerÑt angeschlossen
    @a_tonausgabe(f!)               ! d
  ENDIF                             ! endif
  ' ............................................................................
  PUT g_x%(g_n%),g_y%(g_n%),g_nb$(h|,1,v|,0),7      ! Note auf Bildschirm
  ' ............................................................................
  INC g_n%                          ! Notennummer=Cursorposition erhîhen
  ' ............................................................................
  PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9 ! Cusor ein
  ' ............................................................................
  raus_insert:                      ! d
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 3_grafikinsert        !_:
  ' ----------------------------------------------------------------------------
  ' In dieser Prozedur wird vor der akt. Cursorposition ein Leerplatz einge-
  ' fÅgt und alles, was dahinter ist, um eins weiter nach rechts gerÅckt.
  ' Achtung! : Insert im Speicherarray  v o r  Aufruf dieser Prozedur !! Das
  ' gilt auch fÅr die Aktualisierung der letzten Notennummer: g_mn% !!
  ' Genauer:
  ' 1.) Erst wird in der aktuellen Zeile, in der sich der Cursor befindet, alles
  ' rechts vom Cursor einschlieûlich der Note auf der Cursorposition fotogra-
  ' fiert und eine Position weiter rechts wieder ausgegeben.
  ' Nun wir die Cursornote der aktuellen Zeile, die ja jetzt doppelt vorhanden
  ' ist, gelîscht und stattdessen ein Leerplatz dort ausgegeben.
  ' 2.) Dann werden alle Zeilen unterhalb der aktuellen Zeile auf einmal foto-
  ' grafiert und zwar so, daû rechts eine eine Note breite Spalte bleibt. Dieser
  ' Zeilenblock wird dann eine Position weiter rechts wieder ausgegeben.
  ' Nun wird die Ñuûerst linke Notenspalte, die ja jetzt doppelt vorhanden ist,
  ' in einer FOR-NEXT-Schleife gelîscht und in derselben Schleife stattdessen
  ' die entsprechenden ersten Noten der jeweiligen Zeilen dort ausgegeben.
  ' ----------------------------------------------------------------------------
  LOCAL i|                      ! ZeilenzÑhler physikalisch
  LOCAL j|                      ! ZeilenzÑhler logisch
  LOCAL aktz|                   ! Aktuelle Zeile
  LOCAL x1%                     ! links
  LOCAL x2%                     ! rechts
  LOCAL y1%                     ! oben
  LOCAL y2%                     ! unten
  LOCAL x%                      ! x-Koordinate nach dem Verschieben
  LOCAL lnr%                    ! Linkenotennr: Notennr. der Note am link. Rand
  LOCAL n%                      ! irgendeine Note in der letzten Zeile
  ' ............................................................................
  LET aktz|=TRUNC((g_n%-1)/g_npz|)+1! Akt.Zeile=tr.(akt.Note-1/Noten proZeile)+1
  ' ............................................................................
  ' 1.)                         ! Jetzt die aktuelle Zeile (siehe auch Bild):
  ' ............................................................................
  LET x1%=g_x%(g_n%)            ! links
  LET x2%=g_bb%-g_nb|           ! rechts
  LET y1%=g_y%(g_n%)            ! oben
  LET y2%=y1%+g_nzlh|-1         ! unten: oben + Notenzeilenhîhe - 1
  GET x1%,y1%,x2%,y2%,a$        ! Alles rechts vom Cursor (einschl.) fotograf.
  LET x%=x1%+g_nb|              ! Neuer Wert links: um 1 Notenpos. weiter rechts
  PUT x%,y1%,a$                 ! Fotografierte Notenzeile 1 weiter recht ausgeb
  PUT x1%,y1%,g_lz$             ! Leerzeichen an Cursorposition ausgeben
  ' ............................................................................
  IF g_mn%<=aktz|*g_npz|        ! F Endnote <= letzte Note in aktueller Zeile
    GOTO raus_grafikinsert      ! raus,eigentlich mÅûte das die FOR-Schleife tun
  ENDIF                         ! d
  ' ............................................................................
  ' 2.)                         ! Jetzt die Zeilen unter der akt. (s.a. Bild):
  ' ............................................................................
  LET x1%=0                     ! Neue Linkskoordinate, Rechtsk. bleibt gleich
  LET y1%=g_y%((aktz|*g_npz|)+1)! oben y-Wert: (akt.Zeile*Zeilennot.anz) + 1
  LET y2%=g_bh%-1               ! unten: Bildschirmhîhe - 1
  GET x1%,y1%,x2%,y2%,a$        ! i|-te Notenzeile fotograf. auûer Note rechts
  LET x%=x1%+g_nb|              ! Wert links: um eine Notenpos.weiter rechts
  PUT x%,y1%,a$                 ! Fotografierte Notenzeile 1 weiter recht ausgeb
  FOR i|=aktz| TO g_za|         ! Alle Zeilen unterhalb akt. Zeile(einschl)durch
    LET lnr%=i|*g_npz|+1        ! linke Note der i|-ten Zeile berr:
    '                           ! Notenanzahl pro Zeile * Term analog aktz|
    EXIT IF lnr%>g_mn%          ! raus, falls in der aktuellen Zeile nix mehr is
    LET a|=ASC(LEFT$(g_n$(lnr%),1))-64  ! linke Note der i|-ten Zeile: Tonhîhe
    LET b|=VAL(MID$(g_n$(lnr%),2,1))    ! linke Note der i|-ten Zeile: Periode
    LET c|=VAL(MID$(g_n$(lnr%),3,1))    ! linke Note der i|-ten Zeile: gebund.?
    LET d|=VAL(RIGHT$(g_n$(lnr%),1))    ! linke Note der i|-ten Zeile: betont?
    PUT g_x%(lnr%),g_y%(lnr%),g_lz$ ! In i|-ter Zle in 1.Spalte: Leerzeichen
    PUT g_x%(lnr%),g_y%(lnr%),g_nb$(a|,b|,c|,d|),7 ! linke Note der i|-ten
    '                           ! Zeile in i|-ter Zeile in 1. Spalte ausgeben
  NEXT i|                       ! nÑchste Zeile unterhalb akt. Zeile
  ' ............................................................................
  raus_grafikinsert:            ! Rauslabel
  ' ............................................................................
  '                     Originaler Text:        Text mit inserted space vor (s):
  '
  ' aktuelle Zeile            q r(s)t u         q r _ s t
  '    .                          .             u   .
  '    .                          .                 .
  '    .                          .   x             .
  ' i|-1 te Zeile:            a b c d e         x a b c d
  ' i| te Zeile:              f g h i j         e f g h i
  ' i|+1 te Zeile:            k l m n o         j k l m n
  '    .                          .             o   .
  '    .                          .                 .
  '    .                          .                 .
  ' i| te Zeile:              f g h i j         e f g h i
  '                           |_____|    --->     |_____|
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 1_neu_cpos(x%,y%)     !_:
  ' ----------------------------------------------------------------------------
  ' Hier wird die neue gewÅnschte Cursorposition ermittelt und der Cursor
  ' entsprechend neu positioniert.
  ' ----------------------------------------------------------------------------
  LOCAL n%              ! vorlÑufige Notennr
  LOCAL f!              ! Fehlerflag fÅr Tonausgabe
  ' ............................................................................
  PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9 ! Cusor aus
  @3_notenr(x%,y%,n%)   ! Welche Note liegt unter dem Mauspfeil?
  IF n%>=g_mn%+1        ! F vorl.Notennr > letzte Notennr + 1: Endschreibmodus:
    '                   ! d.h. der Cursor wird dann hinter der letzten Note sein
    LET g_n%=g_mn%+1    ! vorlÑufige Notennummer an entgÅltige Globalvar Åbergeb
  ELSE                  ! F es beim Insertmodus bleibt
    LET g_n%=n%         ! vorlÑufige Notennummer an entgÅltige Globalvar Åbergeb
    LET g_proctest$="neu_cpos"  ! Name der aufrufenden Prozedur fÅrDebugging
    @a_tonausgabe(f!)   ! geht eben nur f Note da, dh. g_n%<=g_mn%
  ENDIF                 ! d
  PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9 ! Cusor ein
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 1_takt_setzen         !_:
  ' ----------------------------------------------------------------------------
  ' Es werden bei der aktuellen Note unter dem Cursor ein Taktstrich gesetzt
  ' bzw. gelîscht (wenn vorher schon einer da war.).
  ' ----------------------------------------------------------------------------
  LOCAL a|                              ! Tonhîhe
  LOCAL b|                              ! Periodendauer
  LOCAL c|                              ! - 2 Oktaven ?
  LOCAL d|                              ! Taktstrich ?
  LOCAL i|                              ! ZÑhler fÅr die 4 Kombinationsmîglichk.
  ' ............................................................................
  IF g_bla%<>0 OR g_ble%<>0             ! F Blockmarken existieren:
    GOTO raus_takt_setzen               ! Raus
  ENDIF                                 ! d
  IF g_n%>g_mn%                         ! F Endschreibmodus:
    GOTO raus_takt_setzen               ! Raus
  ENDIF                                 ! d
  IF ASC(LEFT$(g_n$(g_n%),1))-64<0      ! F kaputte Tonhîhe
    GOTO raus_takt_setzen               ! Raus
  ENDIF                                 ! d
  ' ............................................................................
  LET a|=ASC(LEFT$(g_n$(g_n%),1))-64    ! Tonhîhe
  LET b|=VAL(MID$(g_n$(g_n%),2,1))      ! Periode
  LET c|=VAL(MID$(g_n$(g_n%),3,1))      ! - 2 Oktaven?
  LET d|=VAL(RIGHT$(g_n$(g_n%),1))      ! Taktstrich?
  ' ............................................................................
  IF d|=1                               ! F Taktstrich gesetzt:
    LET d|=0                            ! Taktstrich lîschen
  ELSE                                  ! F Taktstrich nicht gesetzt:
    LET d|=1                            ! Taktstrich setzen
  ENDIF                                 ! d
  ' ............................................................................
  MID$(g_n$(g_n%),4,1)=STR$(d|)         ! énderung abspeichern
  PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9     ! Cusor aus
  PUT g_x%(g_n%),g_y%(g_n%),g_lz$       ! Leerzeichen an Cursorposition ausgeben
  PUT g_x%(g_n%),g_y%(g_n%),g_nb$(a|,b|,c|,d|),7      ! Note auf Bildschirm
  PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9     ! Cusor ein
  ' ............................................................................
  raus_takt_setzen:                     ! Raus
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 3_notenr(x%,y%,VAR n%)!_:
  ' ----------------------------------------------------------------------------
  ' Hier wird ermittelt, welchen Koordinaten x% und y% welche Notennummer auf
  ' dem Bildschirm entsprechen.
  ' ----------------------------------------------------------------------------
  LOCAL aktz|                   ! Aktuelle Zeile
  LOCAL aktsp|                  ! Aktuelle Spalte
  ' ............................................................................
  LET aktz|=TRUNC((y%-g_mh|)/g_nzlh|)+1 ! Aktuelle Zeile berechnen:
  '                                     ! [(y%-MenÅhîhe)/Notenzeilenhîhe]+1
  LET aktsp|=TRUNC(x%/g_nb|)+1          ! Aktuelle Spalte berechnen:
  '                                     ! [x%/Notenbreite]+1
  LET n%=aktsp|+(aktz|-1)*g_npz|        ! Aktuelle Notennummer berechnen
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 1_nur_ton(v|,x%)      !_:
  ' ----------------------------------------------------------------------------
  ' Hier wird nur getînt, nichts gespeichert und nichts gezeichnet.
  ' ----------------------------------------------------------------------------
  LOCAL t|                          ! Notentastennummer
  ' ............................................................................
  LET t|=TRUNC((x%-g_ptb|)/g_ntb|)+1! Notentaste feststellen
  @a2_s(g_ls|,t|,v|,10)             ! Tonausgabe
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 1_backspace           !_:
  ' ----------------------------------------------------------------------------
  ' Hier wird die Note vor dem Cursor gelîscht, also nicht die unter ihm.
  ' ----------------------------------------------------------------------------
  IF g_bla%<>0 OR g_ble%<>0 OR g_n%=1! Nur Backspace,f keine Blockmarken&>1.Note
    GOTO raus_backspace             ! Prozedur unverrichteter Dinge verlassen
  ENDIF                             ! d
  ' ............................................................................
  PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9 ! Cusor aus
  ' ............................................................................
  IF g_n%=g_mn%+1                   ! F Endschreibmodus eingeschaltet:
    DELETE g_n$(g_n%)               ! Note bei Cursorpos.imNotenspeicher lîschen
    PUT g_x%(g_mn%),g_y%(g_mn%),g_lz$! Leerzeichen 1 vor Cursorposition ausgeben
    DEC g_mn%                       ! Nummer der letzten Note erniedrigen
  ELSE                              ! F Insertmodus eingeschaltet:
    DELETE g_n$(g_n%-1)             ! Note vor Cursorpos.imNotenspeicher lîschen
    DEC g_mn%                       ! Nummer der letzten Note erniedrigen
    @2_grafikdelete                 ! alles hinter & einschl.Cursor 1 zurÅck
  ENDIF                             ! EFU Endschreibmodus / Insertmodus
  ' ............................................................................
  DEC g_n%                          ! Notennummer=Cursorposition erniedrigen
  ' ............................................................................
  PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9 ! Cusor ein
  ' ............................................................................
  raus_backspace:                   ! d
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 2_grafikdelete        !_:
  ' ----------------------------------------------------------------------------
  ' In dieser Prozedur wird die Note vor der aktuellen Cursorposition gelîscht,
  ' d.h. alle Noten rechts vom Cursor, einschlieûlich der Note auf dem Cursor
  ' werden um eine Stelle nach links gerÅckt.
  ' Genauer:
  ' 1.) Erst wird in der aktuellen Zeile, in der sich der Cursor befindet, alles
  ' rechts vom Cursor einschlieûlich der Note auf der Cursorposition fotogra-
  ' fiert und eine Position weiter links wieder ausgegeben.
  ' 2.) Dann werden alle Zeilen unterhalb der aktuellen Zeile auf einmal foto-
  ' grafiert und zwar so, daû links eine eine Note breite Spalte bleibt. Dieser
  ' Zeilenblock wird dann eine Position weiter links wieder ausgegeben.
  ' Nun wird die Ñuûerst rechte Notenspalte, die ja jetzt doppelt vorhanden ist,
  ' in einer FOR-NEXT-Schleife gelîscht und in derselben Schleife stattdessen
  ' die entsprechenden letzten Noten der jeweiligen Zeilen dort ausgegeben. D.h.
  ' Delete muû im Speicherstringarray bereits   v  o  r   Aufruf dieser Prozedur
  ' hier stattgefunden haben !! Das gilt auch fÅr die Endnotennummer g_mn% !!!
  ' ----------------------------------------------------------------------------
  LOCAL i|                      ! ZeilenzÑhler physikalisch
  LOCAL j|                      ! ZeilenzÑhler logisch
  LOCAL aktz|                   ! Aktuelle Zeile
  LOCAL x1%                     ! links
  LOCAL x2%                     ! rechts
  LOCAL y1%                     ! oben
  LOCAL y2%                     ! unten
  LOCAL x%                      ! x-Koordinate nach dem Verschieben
  LOCAL enr%                    ! Linksnotennr: Notennr. der Note am rechtenRand
  LOCAL n%                      ! irgendeine Note in der nÑchsten Zeile
  ' ............................................................................
  LET aktz|=TRUNC((g_n%-1)/g_npz|)+1! Akt.Zeile=tr.(akt.Note-1/Noten proZeile)+1
  ' ............................................................................
  ' 1.)                         ! Jetzt die aktuelle Zeile (siehe auch Bild):
  ' ............................................................................
  LET x1%=g_x%(g_n%)            ! links
  LET x2%=g_bb%-1               ! rechts=rechter Bildschirmrand
  LET y1%=g_y%(g_n%)            ! oben
  LET y2%=y1%+g_nzlh|-1         ! unten: oben + Notenzeilenhîhe - 1
  IF g_n%-1+g_npz|=aktz|*g_npz| ! F Cursor auf 1. Spalte:
    DEC aktz|                   ! Bei 2.) 1 Zeile frÅher anfangen
  ELSE                          ! F Cursor nicht auf 1. Spalte:
    GET x1%,y1%,x2%,y2%,a$      ! Alles rechts vom Cursor (einschl.) fotograf.
    LET x%=x1%-g_nb|            ! Neuer Wert links: um 1 Notenpos. links zurÅck
    PUT x%,y1%,a$               ! Fotografierte Notenzeile 1 weiter links ausgeb
  ENDIF                         ! EFU Cursor auf / nicht auf  1. Spalte
  ' ............................................................................
  IF g_mn%<aktz|*g_npz|         ! F Endnote < letzte Note in aktueller Zeile
    '                           ! Warum nicht <= ? Weil im Speicherstringarray
    '                           ! bereits Delete gemacht wurde und Gleichheit
    '                           ! somit bedeutet, daû vor Backspace nicht die
    '                           ! Gleichheit galt, sondern g_mn%=aktz|*g_npz|+1!
    '                           ! Dh. in der unteren Zeile war noch eine Note
    '                           ! und die muû ja auch noch gelîscht werden, die
    '                           ! IF-Bedingung darf also nicht erfÅllt sein.
    PUT x2%-g_nb|,y1%,g_lz$     ! Leerzeichen am rechten Zeilenrand ausgeben
    GOTO raus_grafikdelete      ! Prozedur verlassen
  ENDIF                         ! EF Endnote <= letzte Note in aktueller Zeile
  ' ............................................................................
  ' 2.)                         ! Jetzt die Zeilen unter der akt. (s.a. Bild):
  ' ............................................................................
  LET x1%=g_nb|                 ! Neue Linkskoordinate, Rechtsk. bleibt gleich
  LET y1%=g_y%((aktz|*g_npz|)+1)! oben y-Wert: (akt.Zeile*Zeilennot.anz) + 1
  LET x2%=g_bb%-1               ! rechts=rechter Bildschirmrand
  LET y2%=g_bh%-1               ! unten: Bildschirmhîhe - 1
  GET x1%,y1%,x2%,y2%,a$        ! Notenzeilenblock fotograf. auûer Note rechts
  LET x%=0                      ! Neuer wert links: Notenzeilenanfang
  PUT x%,y1%,a$                 ! Fotografierter Zeilenblock1 weiter links ausg
  ' ..........................................................................
  FOR i|=aktz| TO g_za|         ! Zeilen unterhalb akt. Zeile (einschl.) durch
    ' ..........................................................................
    LET enr%=i|*g_npz|          ! Endnotennr der i|-ten Zeile berr:
    '                           ! Aktuelle Zeile * Notenanzahl pro Zeile
    EXIT IF enr%>g_mn%          ! Raus f Endnotennr > Nr. letzter Note
    LET a|=ASC(LEFT$(g_n$(enr%),1))-64  ! Endnote d. i|-ten Zle: Tonhîhe
    LET b|=VAL(MID$(g_n$(enr%),2,1))    ! Endnote d. i|-ten Zle: Periode
    LET c|=VAL(MID$(g_n$(enr%),3,1))    ! Endnote d. i|-ten Zle: gebund.?
    LET d|=VAL(RIGHT$(g_n$(enr%),1))    ! Endnote d. i|-ten Zle: betont?
    LET y1%=g_y%(enr%)          ! oben y-Wert der Endnote
    PUT x2%-g_nb|,y1%,g_lz$     ! Leerzeichen am rechten Zeilenrand ausgeben
    PUT g_x%(enr%),g_y%(enr%),g_nb$(a|,b|,c|,d|),7 ! Endnote d.i|-ten Zle
    '                           ! in akt. Zeile an letzter Stelle ausgeben
    ' ..........................................................................
  NEXT i|                       ! nÑchste Zeile unterhalb akt. Zeile
  PUT x2%-g_nb|,g_y%(enr%),g_lz$ ! Leerzeichen am rechten Zeilenrand ausgeben
  raus_grafikdelete:            ! Rauslabel
  ' ............................................................................
  '                     Originaler Text:        Text nach delete von r
  '
  ' aktuelle Zeile            q r(s)t u         q(s)t u v
  '    .                      v   .                 .
  '    .                          .                 .
  '    .                          .                 .   a
  ' i|-1 te Zeile:            a b c d e         b c d e f
  ' i| te Zeile:              f g h i j         g h i j k
  ' i|+1 te Zeile:            k l m n o         l m n o p
  '    .                      p   .                 .
  '    .                          .                 .
  '    .                          .                 .
  ' i| te Zeile:              f g h i j         g h i j k
  '                             |_____|   --->  |_____|
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 1_spielen(x%,y%)      !_:
  ' ----------------------------------------------------------------------------
  ' FÅhr den Befehl der rechten Maustaste (ohne Alternate-Taste) aus: Von
  ' der Note unter dem Mauspfeil bis zur Note unterhalb des Cursors soll ge-
  ' spielt werden, bzw. umgekehrt, falls eine Note hinter dem Cursor ange-
  ' klickt wurde.
  ' ----------------------------------------------------------------------------
  LOCAL q|              ! Startnote
  LOCAL r|              ! Endnote
  LOCAL n%              ! vorlÑufige Notennr
  ' ............................................................................
  @3_notenr(x%,y%,n%)   ! Welche Note liegt unter dem Mauspfeil?
  ' ............................................................................
  IF n%>g_mn%           ! F vorl.Notennr > letzte Notennr:
    GOTO raus_spielen   ! Spielen zwecklos, raus!
  ENDIF                 ! d
  IF n%>g_n%            ! F Mauspfeilnote > Cursornote
    LET q|=g_n%         ! Startnote = Cursornote
    LET r|=n%           ! Endnote = Mauspfeilnote
  ELSE                  ! F Mauspfeilnote <= Cursornote
    LET q|=n%           ! Startnote = Mauspfeilnote
    LET r|=g_n%         ! Endnote = Cursornote
  ENDIF                 ! EFU Mauspfeilnote > / <= Cursornote
  IF q|>g_mn%           ! F Start > letzte existierende Note
    LET q|=g_mn%        ! setze Startnote = letzte existierende Note
  ENDIF                 ! d
  IF r|>g_mn%           ! F Endnote > letzte existierende Note
    LET r|=g_mn%        ! setze Endnote = letzte existierende Note
  ENDIF                 ! d
  ' ............................................................................
  @2_abspielen(q|,r|)   ! Von Note q| bis Note r| spielen
  ' ............................................................................
  raus_spielen:         ! Rauslabel
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 2_abspielen(q|,r|)    !_:
  ' ----------------------------------------------------------------------------
  ' Hier wird von der Note q| bis zur Note r| gespielt.
  ' ----------------------------------------------------------------------------
  LOCAL f!                        ! Fehlerflag fÅr Tonausgabe
  LOCAL dw!                       ! Dauerwiederholvorgabe
  LOCAL b|                        ! Periodendauer
  LOCAL mg_n%                     ! Merker fÅr Cursorposition
  LOCAL k%                        ! Tastencode
  ' ............................................................................
  @3_soundwahl                    ! Sound bei Midi-Keyboard einstellen
  LET b|=VAL(MID$(g_n$(g_mn%),2,1))     ! Periode der letzten Note
  IF b|=3 AND g_mn%>3 AND g_mn%-r|<3    ! F letzte Note 1/32 und > 3 Noten da:
    LET r|=r|-2                   ! Soundmarkierungen beim Abspielen weglassen
  ENDIF                           ! d
  ' ............................................................................
  LET mg_n%=g_n%                  ! Cursorposition merken
  ' ............................................................................
  REPEAT            ! Warteschleife fÅr Mauseingabe:
  UNTIL MOUSEK=0    ! Erst Raus,wenn Maus nix mehr meldet,also Puffer leer
  ' ............................................................................
  PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9 ! Cusor aus
  ' ............................................................................
  REPEAT                          ! Dauerwiederholschleife
    ' ..........................................................................
    FOR g_n%=q| TO r|             ! Alle zu spielenden Noten durch
      ' ........................................................................
      IF MOUSEK=2                 ! F rechte Maustaste
        LET dw!=TRUE              ! Dauerwiederholvorgabe einschalten
      ENDIF                       ! d
      ' ........................................................................
      PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9 ! Cusor ein
      ' ........................................................................
      KEYLOOK k%                ! gedrÅckte Taste anschauen
      IF MOUSEK=1 OR k%=65563 OR k%=268501019 ! F linke Maustaste; oft Abbruchm.
        PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9 ! Cusor aus
        LET dw!=FALSE             ! Dauerwiederholungsvorgabe=Falsch
        EXIT IF -1                ! raus
      ENDIF                       ! d
      ' ........................................................................
      LET g_proctest$="abspielen" ! Name der aufrufenden Prozedur fÅrDebugging
      ' ........................................................................
      IF MOUSEK=1                 ! F linke Maustaste; oft Abbruchm.
        PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9 ! Cusor aus
        LET dw!=FALSE             ! Dauerwiederholungsvorgabe=Falsch
        EXIT IF -1                ! raus
      ENDIF                       ! d
      ' ........................................................................
      LET f!=FALSE                ! Fehlerflag erst mal 0 (dh. alles ok!)
      @a_tonausgabe(f!)           ! d
      IF f!                       ! f Fehlerflag gesetzt
        PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9 ! Cusor aus
        LET dw!=FALSE             ! Dauerwiederholungsvorgabe=Falsch
        EXIT IF -1                ! raus
      ENDIF                       ! d
      ' ........................................................................
      IF MOUSEK=1                 ! F linke Maustaste; oft Abbruchm.
        PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9 ! Cusor aus
        LET dw!=FALSE             ! Dauerwiederholungsvorgabe=Falsch
        EXIT IF -1                ! raus
      ENDIF                       ! d
      ' ........................................................................
      PAUSE g_vz|/2^VAL(MID$(g_n$(g_n%),2,1))! Pause Abspielgeschw./2^FÑhnchenzahl
      ' ........................................................................
      IF MOUSEK=1                 ! F linke Maustaste; oft Abbruchm.
        PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9 ! Cusor aus
        LET dw!=FALSE             ! Dauerwiederholungsvorgabe=Falsch
        EXIT IF -1                ! raus
      ENDIF                       ! d
      ' ........................................................................
      PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9 ! Cusor aus
      ' ........................................................................
    NEXT g_n%                     ! nÑchste zu spielende Note
    ' ..........................................................................
  UNTIL dw!=FALSE                 ! wiederhole bis abgebrochen
  WAVE 0,0                        ! Ton aus
  ' ............................................................................
  LET g_n%=mg_n%                  ! Cursorposition wiederherstellen
  PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9 ! Cusor ein
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 3_soundwahl           !_:
  ' ----------------------------------------------------------------------------
  ' (*): Wenn die letzte Note im StÅck eine 1/32- Note ist, wird
  ' ............................................................................
  LOCAL al|                             ! Tonhîhe der letzten Note
  LOCAL av|                             ! Tonhîhe der vorletzten Note
  LOCAL b|                              ! Periodendauer
  LOCAL s1%                             ! Soundparameter
  LOCAL s2%                             ! Soundparameter
  LOCAL s3%                             ! Soundparameter
  ' ............................................................................
  LET b|=VAL(MID$(g_n$(g_mn%),2,1))     ! Periode der letzten Note
  IF b|=3 AND g_midi!=TRUE AND g_mn%>3  ! F letzte Note 1/32 und Midi ein:
    LET s1%=ASC(LEFT$(g_n$(g_mn%-1),1))-65! Tonhîhe der vorletzen Note
    LET s2%=ASC(LEFT$(g_n$(g_mn%),1))-65! Tonhîhe der letzten Note
    '    PRINT AT(1,1);"'";s1%;"'","'";s2%;"'     "
    OUT 3,192,s1%                       ! Sound einschalten Kanal 1
    OUT 3,193,s2%                       ! Sound einschalten Kanal 2
  ENDIF                                 ! d
  OUT 3,194,g_k3|                       ! immer Percussion-Sound auf  Kanal 3
  ' ............................................................................
  ' (*): Die Vorletzte Note bildet die 1. Ziffer des Soundparameters, die
  '      letzte Note (genauer: die Tonhîhe der letzten Note) die 2. Ziffer.
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 1_faehnchen           !_:
  ' ----------------------------------------------------------------------------
  ' Der aktuellen Note wird ein FÑhnchen hinzugefÅgt. Ist die FÑhnchenobergrenze
  ' bereits erreicht, fÑngt's wieder bei null FÑhnchen an.
  ' ----------------------------------------------------------------------------
  LOCAL a|                              ! Tonhîhe
  LOCAL b|                              ! Periodendauer
  LOCAL c|                              ! gebunden?
  LOCAL d|                              ! betont?
  ' ............................................................................
  IF g_bla%<>0 OR g_ble%<>0             ! F Blockmarken existieren:
    GOTO raus_faehnchen                 ! Raus
  ENDIF                                 ! d
  IF g_n%>g_mn%                         ! F Endschreibmodus:
    GOTO raus_faehnchen                 ! Raus
  ENDIF                                 ! d
  IF ASC(LEFT$(g_n$(g_n%),1))-64<0      ! F kaputte Tonhîhe
    GOTO raus_takt_setzen               ! Raus
  ENDIF                                 ! d
  ' ............................................................................
  LET a|=ASC(LEFT$(g_n$(g_n%),1))-64    ! letzte Note d.vorherigen Zle: Tonhîhe
  LET b|=VAL(MID$(g_n$(g_n%),2,1))      ! letzte Note d.vorherigen Zle: Periode
  LET c|=VAL(MID$(g_n$(g_n%),3,1))      ! letzte Note d.vorherigen Zle: gebund.?
  LET d|=VAL(RIGHT$(g_n$(g_n%),1))      ! letzte Note d.vorherigen Zle: betont?
  ' ............................................................................
  IF b|=3                               ! F maximale FÑhnchenanzahl:
    LET b|=0                            ! FÑhnchenanzahl null
  ELSE                                  ! < maximale FÑhnchenanzahl:
    INC b|                              ! ein FÑhnchen dazu
  ENDIF                                 ! d
  MID$(g_n$(g_n%),2,1)=STR$(b|)         ! énderung abspeichern
  PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9     ! Cusor aus
  PUT g_x%(g_n%),g_y%(g_n%),g_lz$       ! Leerzeichen an Cursorposition ausgeben
  PUT g_x%(g_n%),g_y%(g_n%),g_nb$(a|,b|,c|,d|),7      ! Note auf Bildschirm
  PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9     ! Cusor ein
  ' ............................................................................
  raus_faehnchen:                       ! d
  ' ----------------------------------------------------------------------------
RETURN
' ------------------------------------------------------------------------------
> PROCEDURE a_tonausgabe(f!)      !_:
  ' ----------------------------------------------------------------------------
  ' Aufrufende Prozeduren: 'endeschr', 'insert', 'neu_cpos', 'abspielen'
  ' ----------------------------------------------------------------------------
  ' f!                                  ! Fehlerflag
  LOCAL m|                              ! Wahldummy fÅr Alertbox
  LOCAL a|                              ! Tonhîhe
  LOCAL b|                              ! Periodendauer
  LOCAL c|                              ! - 2 Oktaven?
  LOCAL d|                              ! Taktstrich ?
  LOCAL m$                              ! MenÅtextvariable
  ' ............................................................................
  IF ASC(LEFT$(g_n$(g_n%),1))-64<0      ! F Katastrophe (StÅck kaputt!!)
    LET m$="Achtung! Fehler|in 'a_tonausgabe'|bei Notennr:'"
    LET m$=m$+STR$(g_n%)+"'|StÅck '"+g_fn$+"'ist futsch! /raus!"
    @a_alert(m$,m|)                     ! d
    LET f!=TRUE                         ! Fehlerflag setzen
    GOTO raus_tonausgabe                ! unverrichteter Dinge raus
  ENDIF                                 ! d
  ' ............................................................................
  LET a|=ASC(LEFT$(g_n$(g_n%),1))-64    ! Tonhîhe
  LET b|=VAL(MID$(g_n$(g_n%),2,1))      ! Periode
  LET c|=VAL(MID$(g_n$(g_n%),3,1))      ! - 2 Oktaven?
  LET d|=VAL(RIGHT$(g_n$(g_n%),1))      ! betont, also mit Taktstrich?
  ' ............................................................................
  IF g_n%>1                             ! F Notennr. > 1
    WAVE 0,0                            ! Ton aus
    PAUSE 1                             ! Kurze Pause
  ENDIF                                 ! d
  ' ............................................................................
  @a2_s(g_ls|+d|*2,a|,c|,b|)            ! entgÅltige Tonausgabe
  ' PAUSE g_vz|/2^b|                    ! Pause Abspielgeschw./2^FÑhnchenzahl
  raus_tonausgabe:                      ! d
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE a2_s(ls|,th|,ok|,zt|) !_:
  ' ----------------------------------------------------------------------------
  ' ls|                                 ! LautstÑrke
  ' th|                                 ! Tonhîhe
  ' ok|                                 ! - 2 Oktaven?
  ' zt|                                 ! Zeit (Dauer der Note)
  LOCAL oktave|                         ! Oktavenvariable
  ' ............................................................................
  IF th|=26                             ! F Pause
    IF NOT g_midi!                      ! F kein Midi-Keyboard angeschlossen:
      WAVE 0,0                          ! Ton aus
    ELSE                                ! F Midi-Keyboard angeschlossen
      OUT 3,128,g_mt1|,1                ! alten Ton aus Kanal 1
      OUT 3,128,g_mt1|-24,1             ! alten Taktstrichton aus Kanal 1
      OUT 3,129,g_mt2|,1                ! alten Ton aus Kanal 2
      OUT 3,130,g_perc|                 ! alten Ton aus Kanal 3
      IF ls|>g_ls|                      ! F Taktstrich
        OUT 3,146,g_perc|,1             ! neuen Ton an  Kanal 3
      ENDIF                             ! d
    ENDIF                               ! d
  ELSE                                  ! keine Pause
    IF NOT g_midi!                        ! F kein Midi-Keyboard angeschlossen:
      ' Folgender Befehl ist fÅr Vierteltonmusik gedacht:siehe auch '1_tonhoehe'
      ' Hier klappt's nur mit 2 Oktaven, also nicht jetzt, da 4 Oktaven erlaubt.
      ' SOUND 1,ls|,#(ROUND(125000/fr%(th|+vt|*25))),zt| ! endgÅltige Tonausgabe
      SOUND 1,ls|,th|,g_okt|-2*ok|,zt|    ! jetzige Tonausgabe
    ELSE                                  ! F Midi-Keyboard angeschlossen
      OUT 3,128,g_mt1|,1                  ! alten Ton aus Kanal 1
      OUT 3,129,g_mt2|,1                  ! alten Ton aus Kanal 2
      OUT 3,130,g_perc|                   ! alten Ton aus Kanal 3
      '
      LET oktave|=59-24*ok|               ! F Minuszweioktavenflag gesetzt:
      '                                   ! eben 2 Oktaven abziehen
      LET g_mt1|=oktave|+th|              ! Ton merken
      OUT 3,144,g_mt1|,1                  ! neuen Ton an  Kanal 1
      LET g_mt2|=oktave|+th|              ! Ton merken
      IF ok|=0                            ! F nicht minus 2 Oktaven
        LET g_mt2|=g_mt2|-24              ! 2 Oktaven abziehen
      ENDIF                               ! d
      OUT 3,145,g_mt2|,1                  ! neuen Ton an  Kanal 2
      IF ls|>g_ls|                        ! F Taktstrich
        OUT 3,146,g_perc|,1               ! neuen Ton an  Kanal 3
      ENDIF                               ! d
    ENDIF                                 ! d
  ENDIF                                 ! EFU Pause / keine Pause
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE a_undostueck          !_:
  ' ----------------------------------------------------------------------------
  ' Hier wird das aktuelle StÅck in den Undo-Array kopiert
  ' ............................................................................
  LOCAL i%                      ! NotenzÑhler
  ' ............................................................................
  LET gu_mn%=g_mn%              ! StÅcklÑnge speichern
  FOR i%=1 TO g_mn%             ! ganzes StÅck durch
    LET gu_n$(i%)=g_n$(i%)      ! Note kopieren
  NEXT i%                       ! nÑchste Note
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE a_fehler_abfangen     !_:
  ' ----------------------------------------------------------------------------
  ' Im Falle daû ein Fehler im Programmablauf auftaucht, wird wegen des aller-
  ' ersten Befehls des Programms 'on error gosub a_fehler_abfangen' hierher-
  ' gesprungen. So kann dann der Text erst einmal gerettet werden:
  ' ----------------------------------------------------------------------------
  @a_alert("Fehler im Programm!/Abspeichern!",a|)
  @2_stueck_abspeichern         ! Text schnell noch mal abspeichern
  PRINT CHR$(7);                ! klingeln
  PRINT AT(1,1);ERR$(ERR);" Fatal=";FATAL
  PRINT AT(3,3);"letzte notierte Prozedur: '";g_proctest$;"'"
  STOP                          ! d
  ' ----------------------------------------------------------------------------
RETURN
' ##############################################################################
'  S t Å c k b e a r b e i t u n g :
' ##############################################################################
> PROCEDURE 0_hauptmenue          !_:
  ' ----------------------------------------------------------------------------
  LOCAL i|                              ! ZÑhler fÅr MenÅeintrÑge
  LOCAL m|                              ! Maustastenmerker
  LOCAL a|                              ! Nr. des gewÑhlten MenÅeintrags
  DIM h$(10)                            ! HauptmenÅeintragsliste
  DIM d!(10)                            ! Dummyarray
  ' ............................................................................
  IF NOT g_midi!                        ! F kein Midi-Keyboard angeschlossen:
    WAVE 0,0                            ! Ton aus
  ELSE                                  ! F Midi-Keyboard angeschlossen
    OUT 3,128,g_mt1|,1                  ! alten Ton aus Kanal 1
    OUT 3,128,g_mt1|-24,1               ! alten Taktstrichton aus Kanal 1
    OUT 3,129,g_mt2|,1                  ! alten Ton aus Kanal 2
    OUT 3,130,g_perc|,1                 ! alten Ton aus Kanal 3
  ENDIF                                 ! d
  ' ............................................................................
  RESTORE hauptmenue                    ! Readzeiger auf Position
  REPEAT                                ! Leseschleife
    INC i|                              ! EintragszÑhler erhîhen
    READ h$(i|)                         ! HauptmenÅeintrag lesen
  UNTIL h$(i|)="##"                     ! Raus f nix eingelesen
  DEC i|                                ! Anzahl der HauptmenÅeintrÑge
  ' ............................................................................
  nochmal_hauptmenue:                   ! d
  PRINT AT(1,1);SPACE$(80);             ! 1. Zeile ganz weiû (sieht besser aus)
  PUT 56*8,0,g_prgname$                 ! Programmnamen abbilden
  @a_menue(-1,0,-1,0,0,0,1,0,i|,1,m|,a|,h$(),d!())
  IF a|=0                               ! F Abbruch:
    GOTO raus_hauptmenue                ! d
  ENDIF                                 ! d
  @1_um(a|,m|)                          ! UntermenÅ ausfahren
  IF a|<>i| OR m|=2                     ! F nicht letzten Eintrag gewÑhlt:
    GOTO nochmal_hauptmenue             ! d
  ENDIF                                 ! d
  ' ............................................................................
  raus_hauptmenue:                      ! d
  ERASE h$(),d!()                       ! Arrays lîschen
  PUT 0,0,g_kl$                         ! Klaviatur wiederherstellen
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 1_um(w|,VAR m|)       !_:
  ' ----------------------------------------------------------------------------
  ' w|                                  ! Nr des gewÑhlten Eintrags im HauptmenÅ
  ' m|                                  ! Maustaste
  LOCAL i|                              ! ZÑhler fÅr MenÅeintrÑge
  LOCAL q|                              ! Nr. des gewÑhlten MenÅeintrags
  LOCAL b$                              ! Bildschirmspeichervariable
  DIM m$(11)                            ! MenÅeintragsliste
  DIM k!(11)                            ! Dummyarray
  ' ............................................................................
  SELECT w|                             ! Betrachte Nr. des gewÑhlten Eintrags
  CASE 1                                ! Eintrag Nr. 1:
    RESTORE stueckmenue                 ! Read-Zeiger setzen
  CASE 2                                ! Eintrag Nr. 2:
    RESTORE hauptfile                   ! Read-Zeiger setzen
  CASE 3                                ! Eintrag Nr. 3:
    RESTORE blockmenue                  ! Read-Zeiger setzen
  CASE 4                                ! Eintrag Nr. 4:
    RESTORE parameter                   ! Read-Zeiger setzen
  CASE 5                                ! Eintrag Nr. 5:
    RESTORE menue_exit                  ! Read-Zeiger setzen
  ENDSELECT                             ! Ende der Verzweigung
  ' ............................................................................
  REPEAT                                ! Leseschleife
    INC i|                              ! EintragszÑhler erhîhen
    READ m$(i|)                         ! HauptmenÅeintrag lesen
  UNTIL m$(i|)="##"                     ! Raus f nix eingelesen
  DEC i|                                ! Anzahl der UntermenÅeintrÑge
  ' ............................................................................
  IF w|=4                               ! F Parameter-Rubrik gewÑhlt
    IF g_midi!                          ! F Midi eingeschaltet
      LET m$(3)="Midi ausschalten"      ! d
    ELSE                                ! F Midi ausgeschaltet
      LET m$(3)="Midi einschalten"      ! d
    ENDIF                               ! d
  ENDIF                                 ! d
  ' ............................................................................
  SGET b$                               ! Bildschirm retten
  @a_menue(-1,0,-1,0,0,-1,2+(w|-1)*11,1,1,i|,m|,q|,m$(),d!())
  SPUT b$                               ! Bildschirm wiederherstellen
  ' ............................................................................
  IF m|=2                               ! F Abbruch gewÑhlt:
    GOTO raus_untermenue                ! d
  ENDIF                                 ! d
  @2_analyse(w|,q|)                     ! d
  raus_untermenue:                      ! d
  ERASE m$(),k!()                       ! Arrays lîschen
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 2_analyse(w|,q|)      !_:
  ' ----------------------------------------------------------------------------
  ' w|                                  ! Nr des gewÑhlten Eintrags im HauptmenÅ
  ' q|                                  ! Nr des gewÑhlten Eintrags im UntermenÅ
  ' ............................................................................
  IF w|=1 AND q|=1                      ! d
    ' StÅck auf Disk speichern
    @2_stueck_abspeichern
  ELSE IF w|=1 AND q|=2                 ! d
    ' StÅck von Disk laden
    @2_stueck_laden
  ELSE IF w|=1 AND q|=4                 ! d
    ' StÅck in Hauptfile speichern
    @1_abspeichern
  ELSE IF w|=1 AND q|=5                 ! d
    ' StÅck von Hauptfile laden
    @1_laden
  ELSE IF w|=1 AND q|=7                 ! d
    ' bestimmte StÅcke drucken
    @2_drucken_gewaehlte
  ELSE IF w|=1 AND q|=8                 ! d
    ' bestimmte StÅcke spielen
    @2_spielen_gewaehlte
  ELSE IF w|=2 AND q|=1                 ! d
    ' Hauptfile neuanlegen
    @2_hauptfileneuanlegen
  ELSE IF w|=2 AND q|=2                 ! d
    ' Hauptfile laden
    @2_hauptfile_laden
  ELSE IF w|=2 AND q|=3                 ! d
    ' Hauptfile abspeichern
    @2_save_hauptfile
  ELSE IF w|=2 AND q|=5                 ! d
    ' beliebiges File lîschen
    @2_file_loeschen
  ELSE IF w|=2 AND q|=6                 ! d
    ' File umbenennen
    @2_rename_file
  ELSE IF w|=2 AND q|=8                 ! d
    ' Inhaltsverzeichnis drucken
    @2_inhverz_drucken
  ELSE IF w|=2 AND q|=9                 ! d
    ' Alle StÅcke drucken
    @2_drucken_ab_x_alle
  ELSE IF w|=2 AND q|=10                ! d
    ' Alle StÅcke spielen
    @2_spielen_ab_x_alle
  ELSE IF w|=3 AND q|=1                 ! d
    ' Anfang
    @1_blockmark(1)
  ELSE IF w|=3 AND q|=2                 ! d
    ' Ende
    @1_blockmark(2)
  ELSE IF w|=3 AND q|=3                 ! d
    ' Marken lîschen
    @1_blockmark(3)
  ELSE IF w|=3 AND q|=5                 ! d
    ' kopieren
    @1_block_kopieren
  ELSE IF w|=3 AND q|=6                 ! d
    ' doppelt so schnell
    @3_bl_faehnchen(0)
  ELSE IF w|=3 AND q|=7                 ! d
    ' halb so schnell
    @3_bl_faehnchen(-1)
  ELSE IF w|=3 AND q|=8                 ! d
    ' transponieren
    @3_bl_transponieren
  ELSE IF w|=3 AND q|=10                ! d
    ' lîschen
    @1_block_loeschen
  ELSE IF w|=4 AND q|=1                 ! d
    ' Abspielgeschwindigkeit
    @1_abspielgeschw
  ELSE IF w|=4 AND q|=2                 ! d
    ' Pause zw. den StÅcken
    @1_stueckpause
  ELSE IF w|=4 AND q|=3                 ! d
    ' Midi ein/aus
    @1_midi_ein_aus
  ELSE IF w|=5 AND q|=1                 ! d
    ' Eingabe fortsetzen
  ELSE IF w|=5 AND q|=3                 ! d
    @1_programmende(1)
  ELSE IF w|=5 AND q|=5                 ! d
    @1_programmende(2)
  ENDIF                                 ! d
  ' ----------------------------------------------------------------------------
RETURN
' ------------------------------------------------------------------------------
> PROCEDURE 2_stueck_abspeichern  !_:
  ' ----------------------------------------------------------------------------
  LOCAL ok!                     ! flag fÅr Diskplatz~
  LOCAL i|                      ! NotenzÑhler
  LOCAL j|                      ! öbergabezÑhler
  LOCAL a|                      ! Tonhîhe
  LOCAL b|                      ! Periodendauer
  LOCAL c|                      ! - 2 Oktaven?
  LOCAL e|                      ! + x Oktaven
  LOCAL tz|                     ! TaktnotenzÑhler ('Music-Writer':<=16 Noten/T.)
  LOCAL a$                      ! Speicher fÅr öbergabearrayeintrag, Kanal 1
  LOCAL b$                      ! Speicher fÅr öbergabearrayeintrag, Kanal 2
  LOCAL c$                      ! Speicher fÅr öbergabearrayeintrag, Kanal 3
  LOCAL m$                      ! StÅckname
  LOCAL kl$                     ! Klaviaturnegativ
  DIM t$(13)                    ! Notenbuchstabenarray
  DIM n$(g_os%)                 ! öbergabearray
  ' ............................................................................
  GET 0,0,g_bb%-1,g_mh|-1,kl$   ! Klaviatur mit HauptmenÅtext fotogr.
  PUT 0,0,g_kl$                 ! Klaviatur ohne HauptmenÅtext raus
  PRINT AT(1,1);"GewÑhlt: aktuelles StÅck auf Disk speichern: alter Name: '";
  PRINT g_fn$;"'"               ! bisherigen StÅcknamen angeben
  ' ............................................................................
  @3_dfrei(802,ok!)             ! sind noch 130404 Bytes auf Disk frei?
  IF NOT ok!                    ! F nicht:
    GOTO raus_stueck_abspeichern ! d
  ENDIF                         ! d
  ' ............................................................................
  FILESELECT "A:\*.NTA",m$,m$   ! Fileselectbox
  ' ............................................................................
  IF m$="" OR g_mn%=0           ! F Abbruch gewÑhlt oder keine Note vorhanden
    GOTO raus_stueck_abspeichern ! d
  ELSE IF LEN(m$)>4             ! F Name mehr als 4 Buchstaben lang:
    LET g_fn$=LEFT$(m$,LEN(m$)-4) ! '.EXT' wegschneiden
  ENDIF                         ! d
  ' ............................................................................
  RESTORE tonleiter             ! Lesezeiger setzen
  FOR i|=1 TO 13                ! Alle Tîne durch plus Pause
    READ t$(i|)                 ! Tonbuchstaben ('C'-'H','PP') einlesen
  NEXT i|                       ! nÑchster Ton
  LET g_n$(g_mn%+1)="Z101"      ! Pause mit Taktstrich am Schluû
  FOR i|=1 TO g_mn%+1           ! Alle Noten des aktuellen StÅcks durch
    LET a|=ASC(LEFT$(g_n$(i|),1))-64 ! Tonhîhe
    LET b|=VAL(MID$(g_n$(i|),2,1))   ! Periode, codiert wie in 'Notedita':
    '                                ! 0=1/4,1=1/8,2=1/16,3=1/32,Noteditacodiert
    LET c|=VAL(MID$(g_n$(i|),3,1))   ! - 2 Oktaven?
    LET e|=0                    ! erst mal Basisoktave (4)
    IF a|>12 AND a|<25          ! F obere Oktave
      LET e|=1                  ! merken, daû obere Oktave
      LET a|=a|-12              ! zurechtstutzen fÅr Tonbuchstabenarray
    ELSE IF a|=25               ! F hîchstes C
      LET e|=2                  ! Oktave merken
      LET a|=1                  ! Tonbuchstabencode
    ELSE IF a|=26               ! F Pause
      LET a|=13                 ! 13.Stelle als Buchstabe: t$(13)="PP"
    ENDIF                       ! d
    LET a$=a$+t$(a|)            ! Tonbuchstaben in öbergabestring
    IF a|<>13                   ! F keine Pause
      LET a$=a$+STR$(4-c|*2+e|) ! Oktavennummer (Tonumfang: C2-C6)
    ENDIF                       ! d
    LET a$=a$+STR$(5-b|)        ! Periode, normcodiert:
    '                           ! 5=1/4, 4=1/8, 3=1/16, 2=1/32, normcodiert
    LET b$=b$+"PP"+STR$(5-b|)   ! Pausenstring fÅr Kanal 2
    LET c$=c$+"PP"+STR$(5-b|)   ! Pausenstring fÅr Kanal 3
    INC tz|                     ! TaktzÑhler ('Music-Writer':<=16 Noten/Takt) +1
    IF tz|>15                   ! F 16. Note ohne Taktstrich:
      MID$(g_n$(i|+1),4,1)="1"  ! Taktstrich bei nÑchster Note setzen
    ENDIF                       ! d
    IF VAL(RIGHT$(g_n$(i|+1),1)) ! nÑchste Note mit Taktstrich?
      LET n$(j|)=a$+"|"         ! öbergabe fÅr Kanal 1
      INC j|                    ! ZÑhler fÅr öbergabearray erhîhen
      LET n$(j|)=b$+"|"         ! öbergabe fÅr Kanal 2
      INC j|                    ! ZÑhler fÅr öbergabearray erhîhen
      LET n$(j|)=c$+"|"         ! öbergabe fÅr Kanal 3
      INC j|                    ! ZÑhler fÅr öbergabearray erhîhen
      CLR a$,b$,c$,tz|          ! Speicher fÅr öbergabearrayeintrÑge lîschen
      '                         ! und auch TaktnotenzÑhler lîschen
    ENDIF                       ! d
  NEXT i|                       ! nÑchste Note
  ' ............................................................................
  OPEN "O",#1,m$                ! File îffnen
  FOR i|=0 TO j|                ! Alle normcodierten Zeilen durch
    PRINT #1,n$(i|)             ! Zeile raus
    EXIT IF n$(i|)=""           ! raus f Leerzeile
  NEXT i|                       ! NÑchste Zeile
  CLOSE #1                      ! File schlieûen
  ' ............................................................................
  raus_stueck_abspeichern:      ! d
  PUT 0,0,kl$                   ! Klaviatur mit HauptmenÅtext raus
  ERASE n$()                    ! öbergabearray zerstîren
  ERASE t$()                    ! Notenbuchstabenarray lîschen
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 2_stueck_laden        !_:
  ' ----------------------------------------------------------------------------
  LOCAL i|                      ! NotenpositionszÑhler
  LOCAL m%                      ! Anzahl der zu untersuchenden normcod.Textzln.
  LOCAL m$                      ! StÅckname
  LOCAL kl$                     ! Klaviaturnegativ
  DIM n$(g_os%*3)               ! Zwischenspeicherarray dimensionieren
  ' ............................................................................
  GET 0,0,g_bb%-1,g_mh|-1,kl$   ! Klaviatur mit HauptmenÅtext fotogr.
  PUT 0,0,g_kl$                 ! Klaviatur ohne HauptmenÅtext raus
  PRINT AT(1,1);"GewÑhlt: Einzelnes StÅck von Disk laden: Aktuelles StÅck geht verloren !!"
  ' ............................................................................
  FILESELECT "A:\*.NTA",m$,m$   ! Fileselectbox
  ' ............................................................................
  IF m$="" OR NOT EXIST(m$)     ! F Abbruch gewÑhlt:
    GOTO raus_stueck_laden      ! d
  ELSE IF LEN(m$)>4             ! F Name mehr als 4 Buchstaben lang:
    LET g_fn$=LEFT$(m$,LEN(m$)-4) ! '.EXT' wegschneiden
  ENDIF                         ! d
  @a_undostueck                 ! StÅck vorsichtshalber in Undoarray kopieren
  ' ............................................................................
  OPEN "I",#1,m$                ! File îffnen
  LET i%=-1                     ! bei Null starten
  WHILE NOT EOF(#1)             ! F noch nicht End of file erreicht:
    INC i%                      ! ZeilenzÑhler fÅr normcodierten Array erhîhen
    EXIT IF i%>g_os%*3          ! Raus f Dimensionierungsrahmen gesprengt wÅrde
    LINE INPUT #1,n$(i%)        ! Zeile einlesen
    '    RECALL #1,n$(),-1,dummy% ! Array in den Zwischenspeicherarray laden
  WEND                          ! ende
  CLOSE #1                      ! File schlieûen
  LET i%=0                      ! bei Null starten
  WHILE n$(i%)<>""              ! Schleife zum Auffinden des Arrayendes
    DELETE n$(i%+1)             ! i|+1-ten Eintrag lîschen (2.Stimme)
    DELETE n$(i%+1)             ! i|+1-ten Eintrag lîschen (3.Stimme)
    INC i%                      ! PositionszÑhler erhîhen
  WEND                          ! Ende erreicht
  LET m%=i%-1                   ! Endtaktnummer errechnen
  ' ............................................................................
  @3_rueckc(m%,n$())            ! RÅckcodieren
  IF m%=-1                      ! Katastrophe geschehen:
    GOTO raus_stueck_laden      ! d
  ENDIF                         ! d
  ' ............................................................................
  SPUT g_lb$                            ! Bild von Infotext und Noten reinigen
  IF g_mn%>0                            ! F Åberhaupt was da
    @2_stueck_ganz_zeigen               ! Geladenes StÅck auf Bildschirm
    IF g_mn%=g_os%                      ! F 200 Noten
      LET g_n%=g_mn%                    ! Cursor auf letze Note
    ELSE                                ! d
      LET g_n%=g_mn%+1                  ! Notencursor auf StÅckende: erst hier,
      '                                 ! da in 'geladenes_stueck' for-Schleife
    ENDIF                               ! d
  ELSE                                  ! d
    LET g_n%=1                          ! Endschreibmodus
  ENDIF                                 ! d
  LET g_bla%=0                          ! Blockanfang lîschen
  LET g_ble%=0                          ! Blockende lîschen
  PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9     ! Cusor ein
  ' ............................................................................
  raus_stueck_laden:            ! d
  PUT 0,0,kl$                   ! Klaviatur mit HauptmenÅtext raus
  ERASE n$()                    ! Zwischenspeicherarray lîschen
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 3_rueckc(VAR m%,n$()) !_:
  ' ----------------------------------------------------------------------------
  ' m%                          ! Anzahl der normcodierten Textzeilen, am Ende
  '                             ! jedoch Abbruchflag
  ' n$(g_os%*3)                 ! Zwischenspeicherarray fÅr normcodierten Text
  LOCAL a|                      ! MenÅwahlvariable fÅr Alertbox
  LOCAL i|                      ! TaktzÑhler fÅr normcodierten Text
  LOCAL j|                      ! ZeichenzÑhler fÅr normcodierte Textzeile
  LOCAL ml|                     ! Nummer der 1.Note im Takt merken
  LOCAL k|                      ! Notencode (1-13), 13=Pause, Rest Notenbuchst.
  LOCAL l|                      ! NotenzÑhler fÅr 'Notedita'-cod. Notenarray
  LOCAL o|                      ! Oktavennummer
  LOCAL min_2_okt|              ! Minuszweioktavenflag
  LOCAL obere_okt|              ! untere Oktave (Flag)
  LOCAL p|                      ! Periodencode
  LOCAL a$                      ! Notenbuchstabe oder Kreuz
  LOCAL b$                      ! evtl. (falls a$="#") Notenbuchstabe
  LOCAL l$                      ! einzulesender Notenbuchstabe
  LOCAL p$                      ! Periodenzeichen
  LOCAL m$                      ! MenÅtext
  ' ............................................................................
  FOR i|=0 TO m%                ! Alle Takte durch
    FOR j|=1 TO LEN(n$(i|))-1   ! Alle Zeichen im i|-ten Takt durch (bis auf
      '                         ! Taktstrichzeichen am Ende
      IF j|=1                   ! F noch am Taktanfang:
        LET ml|=l|+1            ! Nummer der 1.Note im Takt merken
      ENDIF                     ! d
      LET a$=MID$(n$(i|),j|,1)  ! j|-tes Zeichen im i|-ten Takt festhalten
      INC j|                    ! ZeichenzÑhler erhîhen
      LET b$=MID$(n$(i|),j|,1)  ! j|-tes Zeichen im i|-ten Takt festhalten
      IF a$="b"                 ! F unerlaubterweise 'b' statt '#':
        @4_btokreuz(a$,b$)      ! aus 'b' '#' machen und b$ entsprechen Ñndern
      ENDIF                     !
      RESTORE tonleiter         ! Lesezeiger setzen
      CLR k|                    ! NotencodezÑhler null setzen
      REPEAT                    ! Leseschleife
        READ l$                 ! Notenbuchstaben einlesen (evtl Kreuz davor)
        INC k|                  ! Notencode erhîhen
        IF k|>13                ! Falsches Zeichen
          LET m$="Codierfehler!|Falsches Zeichen|Taktnr:'"+STR$(i|)+"'"
          LET m$=m$+"/Abbruch"  ! MenÅtext
          @a_alert(m$,a|)       ! Alertbox
          ' PRINT g_n$(l|),l|,"Weiter? a$=";a$;" b$=";b$;" l$=";l$;" n$(";i|;")=";n$(i|) !  Martin Mittelmaier
          EXIT IF a|            ! R f a|
        ENDIF                   ! d
      UNTIL l$=a$ OR l$=a$+b$   ! raus f Note gefunden
      EXIT IF a|                ! R f a|
      IF l$=a$                  ! f nicht beide Zeichen,sondern nur 1 verbraucht
        DEC j|                  ! ZeichenzÑhler erniedrigen
      ENDIF                     ! d
      IF (l$=a$ OR l$=a$+b$) AND (NOT l$="PP")   ! f analysiertes Zeichen eine Note |  Ufnaustr.3 1000 Berlin 21
        INC j|                  ! ZeichenzÑhler erhîhen
        LET o|=VAL(MID$(n$(i|),j|,1)) ! j|-tes Zeichen im i|-ten Takt festh.
        SELECT o|               ! Oktavennummer wird jetzt untersucht:
        CASE 2                  ! F 2. Oktave
          LET min_2_okt|=1      ! Minuszweioktavenflag setzen
          LET obere_okt|=0      ! untere Oktave
        CASE 3                  ! F 3. Oktave
          LET min_2_okt|=1      ! Minuszweioktavenflag setzen
          LET obere_okt|=1      ! Obere Oktave
        CASE 4                  ! F 4. Oktave
          LET min_2_okt|=0      ! Minuszweioktavenflag lîschen
          LET obere_okt|=0      ! untere Oktave
        CASE 5                  ! F 5. Oktave
          LET min_2_okt|=0      ! Minuszweioktavenflag lîschen
          LET obere_okt|=1      ! Obere Oktave
        CASE 6                  ! F 6. Oktave, d.h. das hîchste c
          LET min_2_okt|=0      ! Minuszweioktavenflag lîschen
          LET obere_okt|=2      ! oberobere Oktave
        ENDSELECT               ! d
        INC l|                  ! NotenzÑhler erhîhen
        LET g_n$(l|)=CHR$(64+k|+obere_okt|*12)   ! Code Åberg.
      ELSE IF l$="PP"           ! F Pause:
        INC l|                  ! NotenzÑhler erhîhen
        LET g_n$(l|)=CHR$(64+26)! Pausencode Åbergeben
      ELSE                      ! sonst: UnglÅck
        LET m$="Codierfehler!|Keine Note gefunden!|Taktnr:'"+STR$(i|)+"'"
        LET m$=m$+"/Abbruch!"! MenÅtext
        @a_alert(m$,a|)         ! Alertbox
        EXIT IF a|              ! R f a|
      ENDIF                     ! d
      EXIT IF a|                ! R f a|
      INC j|                    ! ZeichenzÑhler erhîhen
      LET p$=MID$(n$(i|),j|,1)  ! j|-tes Zeichen im i|-ten Takt festhalten
      '                         ! 0=1/4,1=1/8,2=1/16,3=1/32,Noteditacodiert
      '                         ! 5=1/4, 4=1/8, 3=1/16, 2=1/32, normcodiert
      LET p|=VAL(p$)            ! Periodencodierung festhalten
      IF p|=5 OR p|=4 OR p|=3 OR p|=2 ! F 'Notedita'-mîgliche Periodenwerte:
        LET p$=STR$(5-p|)       ! Codieren wie in 'Notedita'
      ELSE                      ! kein 'Notedita'-mîglicher Wert:
        LET m$="Codierfehler!|Periode falsch!|Taktnr:'"+STR$(i|)+"'"
        LET m$=m$+"/8-tel Note!"! MenÅtext
        @a_alert(m$,a|)         ! Alertbox
        LET a|=0                ! Rausflag lîschen, denn:
        LET p$="1"              ! setze einfach 1/8-tel
      ENDIF                     ! d
      EXIT IF a|                ! R f a|
      LET g_n$(l|)=g_n$(l|)+p$  ! Periodencode nach Notenstringarray Åbergeben
      LET g_n$(l|)=g_n$(l|)+STR$(min_2_okt|) ! Minuszweioktavenflag Åbergeben
      LET g_n$(l|)=g_n$(l|)+"0" ! Erst mal keinen Taktstrich Åbergeben
      '      PRINT g_n$(l|),l|,"Weiter? a$=";a$;" b$=";b$;" l$=";l$;" n$(";i|;")=";n$(i|)
    NEXT j|                     ! nÑchstes Zeichen im i|-ten Takt
    IF i|>0                     ! F schîn hîher als erster Takt
      MID$(g_n$(ml|),4,1)="1"   ! erste Note hat Taktstrich
    ENDIF                       ! d
    IF l|+1>g_os%               ! f obere Schranke fÅr Notenanz.Åberschr.w.wÅrde
      LET m$="Codierfehler!|Zuviele Noten!|Taktnr:'"+STR$(i|)+"'"
      LET m$=m$+"/Abbruch"      ! MenÅtext
      @a_alert(m$,a|)           ! Alertbox
      LET a|=0                  ! d
      LET i|=m%                 ! fÅr Abbruch ohne Zerstîrung sorgen
    ENDIF                       ! d
    EXIT IF a|                  ! R f a|
  NEXT i|                       ! nÑchster Takt; Maximum: m%
  IF a|                         ! F Rausflag gesetzt:
    LET m%=-1                   ! öbergaberausflag setzen
  ENDIF                         ! d
  LET g_mn%=l|                  ! maximale Notennr Åbergeben
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 4_btokreuz(VAR y$,z$) !_:
  ' ----------------------------------------------------------------------------
  ' y$                          ! hier steht 'b' statt '#'
  ' z$                          ! hier steht die zu erniedrigende Note ('C'-'H')
  LET y$="#"                    ! d
  IF z$="C"                     ! d
    LET z$="H"                  ! d
  ELSE IF z$="D"                ! d
    LET z$="C"                  ! d
  ELSE IF z$="E"                ! d
    LET z$="D"                  ! d
  ELSE IF z$="F"                ! d
    LET z$="E"                  ! d
  ELSE IF z$="G"                ! d
    LET z$="F"                  ! d
  ELSE IF z$="A"                ! d
    LET z$="G"                  ! d
  ELSE IF z$="H"                ! d
    LET z$="A"                  ! d
  ENDIF                         ! d
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 1_abspeichern         !_:
  ' ----------------------------------------------------------------------------
  ' Ein Notentext wird gespeichert.
  ' ----------------------------------------------------------------------------
  LOCAL z!                              ! Flag fÅr Halbtoncheck
  LOCAL stuecknr|                       ! d
  LOCAL a|                              ! Wahlknopf fÅr Alertbox
  LOCAL m|                              ! Maustastenvar. fÅr MenÅ
  LOCAL s%                              ! ZÑhler fÅr schwarze Tasten
  LOCAL w%                              ! ZÑhler fÅr weiûe Tasten
  LOCAL n%                              ! zÑhler fÅr Notenposition
  LOCAL a$                              ! Zwischenspeicher fÅr Notencode
  LOCAL s$                              ! AbkÅrzungsvariable
  LOCAL kl$                             ! Klaviaturnegativ
  ' ............................................................................
  ' 0.)  H a l b t o n c h e c k :
  ' ............................................................................
  GET 0,0,g_bb%-1,g_mh|-1,kl$   ! Klaviatur mit HauptmenÅtext fotogr.
  PUT 0,0,g_kl$                 ! Klaviatur ohne HauptmenÅtext raus
  PRINT AT(1,1);" GewÑhlt: Abspeichern            " ! Infotext/'Lîschen'lîschen
  ' ............................................................................
  @2_shwtch(s%,w%,z!)                   ! Mehr schwarze als weiûe Tasten ?
  IF z!                                 ! f mehr schwarze als weiûe Tasten:
    @a_alert("Mehr schwarze '"+STR$(s%)+"'|als weiûe Tasten! '"+STR$(w%)+"'/Ok!|Abbruch!",a|)
    IF a|=2                             ! f Abbruch gewÑhlt
      GOTO raus_abspeichern             ! uverrichteter Dinge raus
    ENDIF                               ! d
  ENDIF                                 ! d
  ' ............................................................................
  @2_speichermenu(stuecknr|)            ! groûes MenÅ ausfahren: Stöcknr wÑhlen
  IF stuecknr|=0                        ! F Abbruch gewÑhlt
    GOTO raus_abspeichern               ! uverrichteter Dinge raus
  ENDIF                                 ! d
  ' ............................................................................
  WHILE NOT EXIST(g_hf$)                ! Solange Notenhauptdatei nicht auf Disk
    @a_alert("Diskette mit| Hauptfile|einlegen!/Ok!|Abbruch!",a|)
    IF a|=2                             ! f Abbruch gewÑhlt
      GOTO raus_abspeichern             ! uverrichteter Dinge raus
    ENDIF                               ! d
  WEND                                  ! d6
  ' ............................................................................
  LET g_fn$=MID$(g_stueck$(0),(stuecknr|-1)*8+1,8) ! StÅckname ermitteln
  PRINT AT(50,1);"StÅckname:'";g_fn$;"'"! Infotext
  IF g_fn$="________"                   ! Code fÅr Lîschen
    @2_stueck_loeschen(stuecknr|)       ! d
    GOTO raus_abspeichern               ! raus
  ENDIF                                 ! d
  ' ............................................................................
  g_stueck$(stuecknr|+1)=STRING$(800,"@") ! Speicherstring auffÅllen +1, weil in
  '                                     ! g_stueck$(1) die Datumsliste drin ist.
  FOR n%=1 TO g_mn%                     ! Alle Notenpositionen durch
    MID$(g_stueck$(stuecknr|+1),(n%-1)*4+1,4)=g_n$(n%) ! Notencode Åbergeben
  NEXT n%                               ! nÑchste Notenposition
  ' ............................................................................
  OPEN "U",#1,g_hf$                     ! Datei îffnen 'U'=Update, ja nich 'O'!!
  PRINT #1,g_stueck$(0)                 ! Namenliste abspeichern
  PRINT #1,g_stueck$(1)                 ! Datumliste abspeichern
  SEEK #1,1281+1282+(stuecknr|-1)*802+1 ! Datenzeiger positionieren:
  '                                     ! FÅr 'SEEK' gilt: 0.Position bis
  '                                     ! 160*8-1=1279.Pos. sind Namen, dann
  '                                     ! 1280: LF, und 1281: CR, dann:
  '                                     ! 1282 bis 1281+160*8=2561 sind Datum,
  '                                     ! 2562: LF, und 2563(=1281+1282): CR,
  '                                     ! Wegen LF+CR am Ende jedes Strings im
  '                                     ! Folgenden 802 statt 200*4=800 !
  PRINT #1,g_stueck$(stuecknr|+1)       ! Akt. NotenstÅck abspeichern,+1, da in
  '                                     ! g_stueck$(1) die Datumsliste drin ist.
  CLOSE #1                              ! Datei schlieûen
  ' ............................................................................
  @1_fileselectboxfoto                  ! Fileselectbox fotografieren
  ' ............................................................................
  raus_abspeichern:                     ! Rauslabel
  PUT 0,0,g_kl$                         ! Klaviatur von Infotext reinigen
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 2_shwtch(VAR s%,w%,z!)!_:
  ' ----------------------------------------------------------------------------
  ' Hier wird gecheckt, wieviele der Noten im aktuellen StÅck schwarzen und
  ' wieviele weiûen entsprechen.
  ' ----------------------------------------------------------------------------
  ' z!                          ! Flag: mehr schwarze als weiûe Tasten ? (ja=-1)
  ' s%                          ! ZÑhler fÅr schwarze Tasten
  ' w%                          ! ZÑhler fÅr weiûe Tasten
  LOCAL a|                      ! Tonhîhe
  LOCAL i%                      ! ZÑhler fÅr Noten im aktuellen StÅck
  ' ............................................................................
  FOR i%=1 TO g_mn%             ! Alle Noten durch
    LET a|=ASC(LEFT$(g_n$(i%),1))-64 ! Tonhîhe (1-25)
    SELECT a|                   ! Betrachte die Tonhîhe
    CASE 2,4,7,9,11,14,16,19,21,23 ! f schwarze Taste:
      INC s%                    ! ZÑhler fÅr schwarze Taste erhîhen
    DEFAULT                     ! Ansonsten ist's ja 'ne weiûe Taste:
      INC w%                    ! ZÑhler fÅr weiûe Taste erhîhen
    ENDSELECT                   ! Ende
  NEXT i%                       ! nÑchste Note
  IF s%>w%                      ! F mehr schwarze als weiûe Tasten:
    LET z!=TRUE                 ! d
  ENDIF                         ! d
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 2_speichermenu(VAR w|)!_:
  ' ----------------------------------------------------------------------------
  ' w|                                          ! Wahlvariable
  LOCAL mw|                                     ! Wahlvariablenmerker
  LOCAL m|                                      ! Maustastenvar. fÅr MenÅ
  LOCAL i|                                      ! ZÑhler
  LOCAL b$                                      ! Zwischenspeicherstring
  LOCAL d$                                      ! Datum
  LOCAL i$                                      ! Infotext
  LOCAL c$                                      ! Bildschirmspeichervariable
  ' ............................................................................
  DIM a$(g_stka|)                               ! MenÅeintragsfelderarray dim.
  DIM b$(g_stka|)                               ! MenÅeintragsfelderarray dim.
  DIM a%(g_stka|)                               ! Nummerierungsarray dim.
  ' ............................................................................
  SGET c$                                       ! Bildschirm retten
  ' ............................................................................
  SPUT g_fsb$                                   ! Fileselectbox raus
  PUT 0,0,g_kl$                                 ! Klaviatur ohne HauptmenÅtext
  LET i$=" GewÑhlt: Abspeichern / Lîschen  "    ! Infotext
  LET i$=i$+" B i s h e r i g e r  Name:'"      ! Infotext
  LET i$=i$+g_fn$                               ! Infotext
  FOR i|=1 TO g_stka|                           ! Alle MenÅeintrÑge durch
    IF g_fn$=MID$(g_stueck$(0),(i|-1)*8+1,8) AND g_fn$<>"________" ! FNamen gef.
      LET i$=i$+"' Nr.:'"+STR$(i|)+"'"          ! physikalische Nummer merken
    ENDIF                                       ! d
  NEXT i|                                       ! nÑchster MenÅeintrag
  PRINT AT(1,1);i$;                             ! Infotext anzeigen
  ' ............................................................................
  FOR i|=1 TO g_stka|                           ! Alle MenÅeintrÑge durch
    LET a$(i|)=MID$(g_stueck$(0),(i|-1)*8+1,8)  ! Ins MenÅeintragsfeld kopieren
    LET b$(i|)=a$(i|)                           ! physik. Array in b$() retten
    LET a%(i|)=i|                               ! Nummerierungsarrayeintrag
  NEXT i|                                       ! nÑchster MenÅeintrag
  ' ............................................................................
  QSORT a$(),g_stka|+1,a%()                     ! Sortieren, a$() jetzt logisch
  ' ............................................................................
  '                                             ! 1.) Erst mal den StÅcknamen:
  ' ............................................................................
  @a_menue(0,0,-1,0,-1,-1,4,4,8,20,m|,mw|,a$(),d!()) ! MenÅprozedur aufrufen
  IF mw|=0 OR LEFT$(a$(mw|),2)="-1"             ! F nichts gewÑhlt oder Abbruch:
    LET mw|=0                                   ! f Abbruch (b$(w|)="-1"):mw|=0
    GOTO raus_speichermenue                     ! raus
  ENDIF                                         ! d
  LET w|=a%(mw|)                                ! wirkliche,phys.Wahlnrermitteln
  LET b$(w|)=a$(mw|)                            ! Neuen StÅcknamen an physik.
  '                                             ! Stringarray Åbergeben
  ' ............................................................................
  g_stueck$(0)=""                               ! StÅcknamenteil leer machen
  FOR i|=1 TO g_stka|                           ! Alle StÅcknamen durch
    LET g_stueck$(0)=g_stueck$(0)+b$(i|)        ! neuerEintrag inStÅcknamenliste
  NEXT i|                                       ! nÑchster StÅckname
  ' ............................................................................
  '                                             ! 2.) Datum:
  ' ............................................................................
  '  PRINT AT(1,1);"'";MID$(g_stueck$(1),(w|-1)*8+1,8);"'   "
  IF MID$(g_stueck$(1),(w|-1)*8+1,8)="________" ! F bisher kein Datum:
    LET d$=LEFT$(DATE$,6)+RIGHT$(DATE$,2)       ! '19' von date$ rausschneiden
    MID$(g_stueck$(1),(w|-1)*8+1)=d$            ! Datum Åbergeben
  ENDIF                                         ! d
  ' ............................................................................
  '                                             ! Restarbeit:
  ' ............................................................................
  raus_speichermenue:                           ! Rauslabel
  SPUT c$                                       ! Bildschirm wieder herstellen
  ' ............................................................................
  ERASE a$()                                    ! MenÅeintragsarray lîschen
  ERASE b$()                                    ! MenÅeintragsarray lîschen
  ERASE a%()                                    ! Nummerierungsarray lîschen
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 2_stueck_loeschen(s|) !_:
  ' ----------------------------------------------------------------------------
  ' s|                                  ! StÅcknummer
  ' ............................................................................
  PRINT AT(1,1);" GewÑhlt: Lîschen                " ! Infotext
  LET g_stueck$(s|)=STRING$(800,"@")    ! StÅck mit Leerzeichen fÅllen
  ' ............................................................................
  OPEN "U",#1,g_hf$                     ! Datei îffnen 'U'=Update, ja nich 'O'!!
  PRINT #1,g_stueck$(0)                 ! Namenliste abspeichern
  '                                     ! Datenzeiger positionieren:
  SEEK #1,1281+(s|-1)*802+1             ! positionieren (Erkl. siehe 'laden')
  PRINT #1,g_stueck$(s|)                ! Aktuelles NotenstÅck abspeichern
  CLOSE #1                              ! Datei schlieûen
  ' ............................................................................
  @1_fileselectboxfoto                  ! Fileselectbox fotografieren
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 1_laden               !_:
  ' ----------------------------------------------------------------------------
  ' Ein Notentext wird geladen. Danach wird das NotenstÅck auf den Monitor ge-
  ' bracht.
  ' ----------------------------------------------------------------------------
  LOCAL stuecknr|                       ! d
  LOCAL dummy|                          ! Dummy fÅr Alertbox
  LOCAL n%                              ! zÑhler fÅr Notenposition
  LOCAL a$                              ! Zwischenspeicher fÅr Notencode
  LOCAL s$                              ! AbkÅrzungsvariable
  ' ............................................................................
  @2_lademenue("Laden",stuecknr|)       ! groûes MenÅ ausfahren: Stöcknr wÑhlen
  IF stuecknr|=0                        ! F Abbruch gewÑhlt
    GOTO raus_laden                     ! uverrichteter Dinge raus
  ENDIF                                 ! d
  @a_undostueck                         ! StÅck vorsichtshalber in Undoarray
  ' ............................................................................
  LET g_fn$=MID$(g_stueck$(0),(stuecknr|-1)*8+1,8) ! StÅckname ermitteln
  PRINT AT(50,1);"Neuer StÅckname:'";g_fn$;"'"! Infotext
  ' ............................................................................
  LET s$=g_stueck$(stuecknr|+1)         ! AbkÅrzungsvariable fÅllen +1,weil in
  '                                     ! g_stueck$(1) die Datumsliste drin ist.
  FOR n%=1 TO g_os%                     ! Alle Notenpositionen durch
    LET a$=MID$(s$,(n%-1)*4+1,4)        ! Notencode (= 4 Zeichen) ermitteln
    EXIT IF a$="@@@@"                   ! Raus f Leernote
    LET g_n$(n%)=a$                     ! Notencode Åbergeben
  NEXT n%                               ! nÑchste Notenposition
  LET g_mn%=n%-1                        ! Endnotennr festlegen
  ' ............................................................................
  SPUT g_lb$                            ! Bild von Infotext und Noten reinigen
  IF g_mn%>0                            ! F Åberhaupt was da
    @2_stueck_ganz_zeigen               ! Geladenes StÅck auf Bildschirm
    IF g_mn%=g_os%                      ! F 200 Noten
      LET g_n%=g_mn%                    ! Notencursor auf letzten Note
    ELSE                                ! d
      LET g_n%=g_mn%+1                  ! Notencursor auf StÅckende: erst hier,
      '                                 ! da in 'geladenes_stueck' for-Schleife
    ENDIF                               ! d
  ELSE                                  ! d
    LET g_n%=1                          ! Endschreibmodus
  ENDIF                                 ! d
  LET g_bla%=0                          ! Blockanfang lîschen
  LET g_ble%=0                          ! Blockende lîschen
  PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9     ! Cusor ein
  ' ............................................................................
  raus_laden:                           ! Rauslabel
  PUT 0,0,g_kl$                         ! Klaviatur von Infotext reinigen
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 2_lademenue(i$,VAR w|)!_:
  ' ----------------------------------------------------------------------------
  ' i$                                          ! Name der aufrufenden Prozedur
  ' w|                                          ! Wahlvariable
  LOCAL i|                                      ! ZÑhlvariable
  LOCAL m|                                      ! Maustastenvar. fÅr MenÅ
  LOCAL mw|                                     ! Merker fÅr Wahlvariable
  LOCAL m$                                      ! Merker fÅr Eintragsnamen
  LOCAL c$                                      ! Bildschirmspeichervariable
  DIM a$(g_stka|)                               ! MenÅeintragsfelderarray dim.
  DIM a%(g_stka|)                               ! Nummerierungsarray dim.
  ' ............................................................................
  SGET c$                                       ! Bildschirm retten
  ' ............................................................................
  SPUT g_fsb$                                   ! Fileselectbox raus
  LET i$=" GewÑhlt: "+i$+" "                    ! Infotext
  LET i$=i$+" B i s h e r i g e r  Name:'"      ! Infotext
  LET i$=i$+g_fn$+"'      "                     ! Infotext
  PRINT AT(1,1);i$;                             ! Infotext anzeigen
  ' ............................................................................
  FOR i|=1 TO g_stka|                           ! Alle MenÅeintrÑge durch
    LET a$(i|)=MID$(g_stueck$(0),(i|-1)*8+1,8)  ! Ins MenÅeintragsfeld kopieren
    LET a%(i|)=i|                               ! Nummerierungsarrayeintrag
  NEXT i|                                       ! nÑchster MenÅeintrag
  ' ............................................................................
  QSORT a$(),g_stka|+1,a%()                     ! Sortieren
  ' ............................................................................
  @a_menue(0,0,-1,0,0,-1,4,4,8,20,m|,w|,a$(),d!())! MenÅ aufrufen ohne Darstellung
  IF w|=0 OR a$(w|)="-"                         ! F nichts gewÑhlt oder Abbruch:
    LET w|=0                                    ! f Abbruch (b$(w|)="-1"):mw|=0
    GOTO raus_lademenue                         ! raus
  ENDIF                                         ! d
  ' ............................................................................
  DO                                            ! Schleife fÅr Datumsdarstellung
    ' ..........................................................................
    EXIT IF m|=1 OR w|=0                        ! Raus f linke Maustaste
    ' ..........................................................................
    IF mw|<>0                                   ! F schonmal Datum angeguckt:
      LET a$(mw|)=m$                            ! Letzten Namen wiederherstellen
    ENDIF                                       ! d
    ' ..........................................................................
    LET m$=a$(w|)                               ! Namen retten
    LET mw|=w|                                  ! Wahlnummer retten
    ' ..........................................................................
    LET a$(w|)=MID$(g_stueck$(1),(a%(w|)-1)*8+1,8)! Datum Åbergeben
    ' ..........................................................................
    @a_menue(-1,0,-1,0,0,-1,4,4,8,20,m|,w|,a$(),d!())! MenÅ mit Darstellung
    ' ..........................................................................
  LOOP                                          ! Schleifenende
  ' ............................................................................
  LET w|=a%(w|)                                 ! wirkliche Wahlnummer ermitteln
  ' ............................................................................
  raus_lademenue:                               ! Rauslabel
  SPUT c$                                       ! Bildschirm wieder herstellen
  ' ............................................................................
  ERASE a$()                                    ! MenÅeintragsarray lîschen
  ERASE a%()                                    ! Nummerierungsarray lîschen
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 2_stueck_ganz_zeigen  !_:
  ' ----------------------------------------------------------------------------
  ' Das NotenstÅck im Speicherstring wird auf dem Monitor dargestellt.
  ' ----------------------------------------------------------------------------
  LOCAL b|                             ! Periodendauer
  LOCAL c|                             ! - 2 Oktaven?
  LOCAL d|                             ! Taktstrich?
  LOCAL m|                             ! MenÅvar.
  LOCAL a%                             ! Tonhîhe
  LOCAL m$                             ! MenÅtextvar.
  ' ............................................................................
  FOR g_n%=1 TO g_mn%                  ! Alle Noten durch
    LET a%=ASC(LEFT$(g_n$(g_n%),1))-64 ! Tonhîhe
    IF a%<0                            ! F kaputte Tonhîhe
      LET m$="Achtung! Fehler|in '2_stueck_ganz_zeigen'|bei Notennr:'"
      LET m$=m$+STR$(g_n%)+"'|StÅck '"+g_fn$+"' ist futsch! /raus!"
      @a_alert(m$,m|)                  ! d
      EXIT IF TRUE                     ! unverrichteter Dinge raus
    ENDIF                              ! d
    LET b|=VAL(MID$(g_n$(g_n%),2,1))   ! Periode
    LET c|=VAL(MID$(g_n$(g_n%),3,1))   ! - 2 Oktaven?
    LET d|=VAL(RIGHT$(g_n$(g_n%),1))   ! Taktstrich?
    PUT g_x%(g_n%),g_y%(g_n%),g_nb$(a%,b|,c|,d|),7      ! Note auf Bildschirm
    '                                  ! Schneller als die letzten 5 Zln wÑre:
    '    PUT g_x%(g_n%),g_y%(g_n%),g_nb$(ASC(LEFT$(g_n$(g_n%),1))-64,VAL(MID$(g_n$(g_n%),2,1)),VAL(MID$(g_n$(g_n%),3,1)),VAL(RIGHT$(g_n$(g_n%),1))),7
  NEXT g_n%                            ! NÑchste Note
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 2_drucken_gewaehlte   !_:
  ' ----------------------------------------------------------------------------
  ' Notentexte werden gedruckt; ausgewÑhlte StÅcke
  ' ----------------------------------------------------------------------------
  LOCAL r!                              ! Rausvariable 1
  LOCAL r|                              ! Rausvariable 2
  LOCAL i|                              ! StÅckzÑhler
  LOCAL w|                              ! Wahlvariable fÅrs MenÅ
  LOCAL m_mn%                           ! Merker fÅr letzte Note
  LOCAL m_n%                            ! Merker fÅr Cursorposition
  LOCAL a$                              ! Zwischenspeicher fÅr Notencode
  LOCAL s$                              ! AbkÅrzungsvariable
  LOCAL bld$                            ! Bildschirmrettungsnegativ
  LOCAL name$                           ! StÅckname
  DIM w!(g_stka|)                       ! Auswahlarray, Eintrag=-1,f entspr.
  '                                     ! StÅck ausgewÑhlt worden ist.
  DIM w|(g_stka|)                       ! Alphabetnummerarray lîschen
  DIM m_n$(g_os%)                       ! Zwischenspeicher fÅr akt. StÅck
  ' ............................................................................
  '     1.)  l e t z t e s  S t Å c k  r e t t e n :
  ' ............................................................................
  SGET bld$                             ! Bildschirm retten
  LET name$=g_fn$                       ! Namen retten
  LET m_mn%=g_mn%                       ! letzte Note des akt. StÅcks merken
  LET m_n%=g_n%                         ! Cursorposition des akt. StÅcks merken
  IF m_mn%<>0                           ! F vor Druckbefehl StÅck im Speicher:
    FOR n%=1 TO g_mn%                   ! Alle Noten des akt. StÅcks durch
      LET m_n$(n%)=g_n$(n%)             ! StÅck in Speicherstring
    NEXT n%                             ! nÑchste Note des akt. StÅcks
  ENDIF                                 ! d
  ' ............................................................................
  '     2.)  V o r b e r e i t u n g e n :
  ' ............................................................................
  PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9     ! Cusor aus
  @3_dm("drucken",w|,w!(),w|())         ! groûes MenÅ ausfahren: Stöcke wÑhlen
  IF w|=0                               ! F Abbruch gewÑhlt
    GOTO raus_drucken_gewaehlte         ! uverrichteter Dinge raus
  ENDIF                                 ! d
  FOR i|=1 TO g_stka|                   ! Alle StÅcke durch (physikalisch)
    EXIT IF LEFT$(g_stueck$(i|+1),4)="@@@@" ! raus f leeres StÅck
    IF w!(i|)=TRUE                      ! F StÅck gedruckt werden soll:
      @3_dr_st(i|,w|(i|),r!)            ! Eine Ebene weiter runter zum Drucken
    ENDIF                               ! d
    IF r!=TRUE                          ! F abgebrochen:
      LET r!=FALSE                      ! d
      @a_alert("Ganz abbrechen?/Ja|Nein",r|) ! d
      EXIT IF r|=1                      ! Raus f ja gewÑhlt:
    ENDIF                               ! d
    EXIT IF r|=1                        ! Raus f ja gewÑhlt:
  NEXT i|                               ! nÑchstes StÅck
  ' ............................................................................
  '     4.)  S t Å c k  w i e d e r h e r s t e l l e n :
  ' ............................................................................
  raus_drucken_gewaehlte:               ! Rauslabel
  IF m_mn%<>0                           ! F vor Druckbefehl StÅck im Speicher:
    FOR n%=1 TO m_mn%                   ! Alle Noten des akt. StÅcks durch
      LET g_n$(n%)=m_n$(n%)             ! StÅck von Speicherstring in Arbeitsstr
    NEXT n%                             ! nÑchste Note des akt. StÅcks
  ENDIF                                 ! d
  LET g_fn$=name$                       ! StÅckname wiederherstellen
  LET g_n%=m_n%                         ! Cursor wo er frÅher war
  LET g_mn%=m_mn%                       ! vorher akt. StÅck
  SPUT bld$                             ! Bildschirm wiederherstellen
  ERASE w!()                            ! Wahlarray lîschen
  ERASE w|()                            ! Alphabetnummerarray lîschen
  ERASE m_n$()                          ! Speicherarray lîschen
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 3_dm(z$,VAR w|,w!(),w|())!_:
  ' ----------------------------------------------------------------------------
  ' z$                                          ! Name von aufrufender Prozedur
  ' w|                                          ! Wahlvar.=-1:was gewÑhlt,0:nix
  ' w!()                                        ! Wahlarray
  ' w|()                                        ! Array fÅr alphab. StÅcknr.
  LOCAL i|                                      ! ZÑhlvariable
  LOCAL m|                                      ! Maustastenvar. fÅr MenÅ
  LOCAL c$                                      ! Bildschirmnegativ
  LOCAL i$                                      ! Infotext
  DIM a!(g_stka|)                               ! Eintragswahlfelderarray dim.
  DIM a$(g_stka|)                               ! MenÅeintragsfelderarray dim.
  DIM a%(g_stka|)                               ! Nummerierungsarray dim.
  ' ............................................................................
  SGET c$                                       ! Bildschirm retten
  ' ............................................................................
  SPUT g_fsb$                                   ! Fileselectbox raus
  LET i$=" GewÑhlt: "+z$+" "                    ! Infotext
  PRINT AT(1,1);i$;                             ! Infotext anzeigen
  ' ............................................................................
  FOR i|=1 TO g_stka|                           ! Alle MenÅeintrÑge durch
    LET a$(i|)=MID$(g_stueck$(0),(i|-1)*8+1,8)  ! Ins MenÅeintragsfeld kopieren
    LET a%(i|)=i|                               ! Nummerierungsarrayeintrag
  NEXT i|                                       ! nÑchster MenÅeintrag
  ' ............................................................................
  QSORT a$(),g_stka|+1,a%()                     ! Sortieren, alphabetisch, in
  '                                             ! a%() wird die physikalische
  '                                             ! Nr. mitsortiert.
  ' ............................................................................
  @a_menue(0,0,-1,-1,0,-1,4,4,8,20,m|,w|,a$(),a!())! MenÅ aufrufen ohne Darstellung
  IF w|=0                                       ! f nichts gewÑhlt:
    GOTO raus_druck_menue                       ! d
  ENDIF                                         ! d
  ' ............................................................................
  FOR i|=1 TO g_stka|                           ! Alle StÅcke durch, und zwar in
    '                                           ! alphabetischer Reihenfolge
    IF a!(i|)=TRUE                              ! F StÅck gewÑhlt:
      LET w!(a%(i|))=TRUE                       ! Wahlarray kennzeichnen und
      '                                         ! zwar an der physikalische Nr.
      LET w|(a%(i|))=i|                         ! Alphabetnr. merken
    ELSE                                        ! F StÅck nicht gewÑhlt:
      LET w!(a%(i|))=FALSE                      ! In Wahlarray Åbergeben
    ENDIF                                       ! d
  NEXT i|                                       ! nÑchstes StÅck
  ' ............................................................................
  SPUT c$                                       ! Bildschirm wieder herstellen
  ' ............................................................................
  raus_druck_menue:                             ! d
  ERASE a!()                                    ! MenÅwahlarray lîschen
  ERASE a$()                                    ! MenÅeintragsarray lîschen
  ERASE a%()                                    ! Nummerierungsarray lîschen
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 3_dr_st(i|,a|,VAR z!) !_:
  ' ----------------------------------------------------------------------------
  ' Hier wird ein einzelnes StÅck angezeigt und evtl. gedruckt.
  ' ............................................................................
  ' i|                                  ! physikalische StÅcknummer
  ' a|                                  ! alphabetische StÅcknummer
  ' z!                                  ! Rausflag
  ' ............................................................................
  LOCAL lz|                             ! Nummer der letzten Zeile
  LOCAL m|                              ! MenÅvariable
  LOCAL j|                              ! ZiffernzÑhler fÅr StÅcknummer
  LOCAL n%                              ! zÑhler fÅr Notenposition
  LOCAL y%                              ! y-Startwert fÅr Zeilenradiergummibox
  LOCAL a$                              ! alphab. StÅcknr-/Notencodespeicher
  LOCAL p$                              ! phys. StÅcknrspeicher
  LOCAL name$                           ! d
  LOCAL datu$                           ! Datum
  LOCAL stuecknummer$                   ! physikalische StÅcknummer
  LOCAL menue$                          ! Alertboxtext
  ' ............................................................................
  '     1.)  B i l d - V o r b e r e i t u n g e n :
  ' ............................................................................
  SPUT g_lb$                            ! Lîschbild
  DEFFILL 0                             ! FÅllmuster weiû
  PBOX 0,0,g_bb%-1,g_mh|-2              ! Klaviatur wegradieren
  DEFFILL 1,2,8                         ! FÅllmuster schwarz
  ' ............................................................................
  '     2.)  T i t e l z e i l e  f Å r  d a s  S t Å c k :
  ' ............................................................................
  CLS                                   ! Bildschirm ganz leer
  LET a$=STR$(i|)                       ! StÅcknummer
  DEFTEXT 1,0,0,4                       ! kleine Schrift
  FOR j|=1 TO LEN(a$)                   ! alle Ziffern von i| durch
    TEXT 10,10+j|*6,MID$(a$,j|,1)       ! Ziffern untereinander schreiben
  NEXT j|                               ! nÑchste Ziffer
  GET 10,10,30,50,p$                    ! Nummer fotografieren
  LET a$=STR$(a|)                       ! alphabetische StÅcknummer
  DEFTEXT 1,0,0,4                       ! kleine Schrift
  FOR j|=1 TO LEN(a$)                   ! alle Ziffern von a| durch
    TEXT 10,100+j|*6,MID$(a$,j|,1)      ! Ziffern untereinander schreiben
  NEXT j|                               ! nÑchste Ziffer
  GET 10,100,30,140,a$                  ! Nummer fotografieren
  CLS                                   ! Bildschirm ganz leer
  PUT g_x%(6)+10,g_y%(6)+28,p$          ! physikalische StÅcknummer ausgeben
  PUT g_x%(86)+10,g_y%(86)+28,a$        ! alphabetische StÅcknummer ausgeben
  ' ............................................................................
  '     3.)  g e w Ñ h l t e s  S t Å c k  r a u s f i l t e r n :
  ' ............................................................................
  LET s$=g_stueck$(i|+1)                ! AbkÅrzungsvariable fÅllen +1,weil in
  '                                     ! g_stueck$(1) die Datumsliste drin ist.
  FOR n%=1 TO g_os%                     ! Alle Notenpositionen durch
    LET a$=MID$(s$,(n%-1)*4+1,4)        ! Notencode (= 4 Zeichen) ermitteln
    EXIT IF a$="@@@@"                   ! Raus f Leernote
    LET g_n$(n%)=a$                     ! Notencode Åbergeben
  NEXT n%                               ! nÑchste Notenposition
  LET g_mn%=n%-1                        ! Endnotennr festlegen
  IF g_mn%=0                            ! F Åberhaupt nix da
    GOTO raus_drucke_st                 ! Rauslabel
  ENDIF                                 ! d
  ' ............................................................................
  '     4.)  E n d l i c h  D r u c k b i l d :
  ' ............................................................................
  LET g_fn$=MID$(g_stueck$(0),(i|-1)*8+1,8) ! StÅckname ermitteln
  @4_druckbildhaelfte(1)                ! 1. HÑlfte des StÅcks auf Bildschirm
  LET menue$="'"+g_fn$+"' Wirklich drucken?/Ja|Nein" ! d
  @a_alert(menue$,m|)                   ! d
  IF m|=2                               ! Nein gewÑhlt:
    LET z!=TRUE                         ! Rausvariable setzen
    GOTO raus_drucke_st                 ! raus
  ENDIF                                 ! d
  HIDEM                                 ! Mauspfeil weg
  '                                     ! Folgende Zeile bei PD-Version raus:
  LPRINT CHR$(27);CHR$(106);CHR$(100);  ! r e v e r s e s  the paper,page 140
  IF NOT GEMDOS(17)                     ! F Drucker nicht bereit:
    @a_alert("Drucker nicht bereit!/Aber jetzt!|raus!",m|) ! d
  ENDIF                                 ! d
  IF m|=2                               ! Nein gewÑhlt:
    LET z!=TRUE                         ! Rausvariable setzen
    GOTO raus_drucke_st                 ! raus
  ENDIF                                 ! d
  HARDCOPY                              ! d
  CLS                                   ! Bildschirm lîschen
  @4_druckbildhaelfte(2)                ! 2. HÑlfte des StÅcks auf Bildschirm
  HARDCOPY                              ! d
  CLS                                   ! Bildschirm lîschen
  FOR i|=1 TO 8                         ! Vorschubschleife (*)
    LPRINT                              ! Zeilenvorschub
  NEXT i|                               ! nÑchster Zeilenvorschub
  '  LPRINT CHR$(27);CHR$(74);CHR$(5);     ! Korrekturvorschub n/216 inch
  ' ............................................................................
  raus_drucke_st:                       ! Rauslabel
  ' ----------------------------------------------------------------------------
  ' (*) Zwischen den beiden StÅckhÑlften sind noch ein paar ZeilenvorschÅbe
  '     beim Drucken nîtig, da zwischen den Notenzeilen sonst ja immer eine
  '     ganze Leerzeile ist, hier aber nur die obere MenÅzeile, die etwas
  '     weniger hoch als eine Notenzeile ist.
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 4_druckbildhaelfte(h|)!_:
  ' ----------------------------------------------------------------------------
  LOCAL m|                              ! MenÅvar.
  LOCAL a|                              ! Tonhîhe
  LOCAL b|                              ! Periodendauer
  LOCAL c|                              ! - 2 Oktaven?
  LOCAL d|                              ! Taktstrich?
  LOCAL rest|                           ! Notenzeilenhîhe - MenÅhÅhe
  LOCAL c%                              ! Cursorposition
  LOCAL s%                              ! Startnotennummer
  LOCAL e%                              ! Endnotennummer
  LOCAL n%                              ! Notennummer im zu druckenden StÅckteil
  LOCAL b$                              ! Bildschirmspeicherstring
  LOCAL m$                              ! MenÅtextvar.
  ' ............................................................................
  LET c%=7                              ! Cursorposition am Anfang
  LET s%=1+(h|-1)*(3*34)                ! Startnotennummer festlegen
  IF g_mn%<s%                           ! Endnote des StÅcks < Startnummer:
    GOTO raus_druckbildhaelfte          ! raus
  ENDIF                                 ! d
  IF h|=2                               ! f 2.StÅckhÑlfte angezeigt werden soll:
    LET e%=g_mn%                        ! Endnotennummer festlegen
  ELSE                                  ! f 1.StÅckhÑlfte angezeigt werden soll:
    IF g_mn%<3*34                       ! f Endnote d.StÅcks < 3 Zln voll Noten:
      LET e%=g_mn%                      ! Endnotennummer festlegen
    ELSE                                ! f Endnote d.StÅcks = 3 Zln voll Noten:
      LET e%=3*34                       ! Endnotennummer festlegen
    ENDIF                               ! d
  ENDIF                                 ! d
  ' ............................................................................
  LET b|=VAL(MID$(g_n$(g_mn%),2,1))     ! Periode der letzten Note
  IF b|=3 AND g_mn%>3 AND g_mn%-e%<3    ! F letzte Note 1/32 und > 3 Noten da:
    LET e%=e%-2                         ! Soundmarkierungen beim Absp. weglassen
  ENDIF                                 ! d
  FOR n%=s% TO e%                       ! Alle Noten des StÅckteils durch
    ' ..........................................................................
    IF c%=7 OR c%=87 OR c%=167          ! f Cursor am Zeilenanfang:
      PUT g_x%(c%-1),g_y%(c%-1),g_ln$,7 ! Notenlinien fÅr NotenschlÅssel
      PUT g_x%(c%-2),g_y%(c%-2),g_ln$,7 ! Notenlinien fÅr NotenschlÅssel
      PUT g_x%(c%-2),g_y%(c%-2),g_ns$,7 ! NotenschlÅssel projezieren
      PUT g_x%(c%-2)+3,g_y%(c%-2)+3,g_ns$,7 ! Schatten NotenschlÅssel
    ENDIF                               ! d
    ' ..........................................................................
    PUT g_x%(c%),g_y%(c%),g_ln$         ! Notenlinien fÅr abzubildende Note
    IF ASC(LEFT$(g_n$(n%),1))-64<0      ! F kaputte Tonhîhe
      LET m$="Achtung! Fehler|in '4_druckbildhaelfte'|bei Notennr:'"
      LET m$=m$+STR$(g_n%)+"'|StÅck:'"+g_fn$+"'ist futsch! /raus!"
      @a_alert(m$,m|)                   ! d
      EXIT IF TRUE                      ! unverrichteter Dinge raus
    ENDIF                               ! d
    LET a|=ASC(LEFT$(g_n$(n%),1))-64    ! Tonhîhe
    LET b|=VAL(MID$(g_n$(n%),2,1))      ! Periode
    LET c|=VAL(MID$(g_n$(n%),3,1))      ! - 2 Oktaven?
    LET d|=VAL(RIGHT$(g_n$(n%),1))      ! Taktstrich ?
    PUT g_x%(c%),g_y%(c%),g_nb$(a|,b|,c|,d|),7   ! Note auf Bildschirm
    ' ..........................................................................
    INC c%                              ! Cursorposition erhîhen
    IF c%=41 OR c%=121                  ! f Cursor an Position 41 oder 121
      ADD c%,46                         ! eine Notenzeile Åberspringen
    ENDIF                               ! d
    ' ..........................................................................
  NEXT n%                               ! nÑchste Note des StÅckteils
  ' ............................................................................
  GET 0,g_y%(1),g_bb%-1,g_bh%-1,b$      ! Bild fotografieren
  CLS                                   ! Bildschirm lîschen
  IF h|=1                               ! f 1.StÅckhÑlfte angezeigt werden soll:
    PUT 0,0,b$                          ! Bild wieder projezieren, aber jetzt
    '                                   ! ganz oben anfangen, um nix an Papier
    '                                   ! zu verschenken
  ELSE                                  ! f 2.StÅckhÑlfte angezeigt werden soll:
    LET rest|=g_nzlh|-g_mh|             ! Notenzeilenhîhe - MenÅhÅhe,ErklÑrung:
    PUT 0,rest|,b$                      ! Bild wieder projezieren, aber jetzt
    '                                   ! etwas weiter unten, weil ja immer
    '                                   ! zwischen zwei gefÅllten Notenzeilen
    '                                   ! genau eine Leerzeile der Hîhe
    '                                   ! g_nzlh| sein soll.
  ENDIF                                 ! d
  ' ............................................................................
  raus_druckbildhaelfte:                ! Rauslabel
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 2_spielen_gewaehlte   !_:
  ' ----------------------------------------------------------------------------
  ' Notentexte werden gespielt; ausgewÑhlte StÅcke. Prozedurbau sehr Ñhnlich dem
  ' bei '2_drucken_gewaehlte'.
  ' ----------------------------------------------------------------------------
  LOCAL r!                              ! Rausvariable 1
  LOCAL r|                              ! Rausvariable 2
  LOCAL i|                              ! StÅckzÑhler
  LOCAL w|                              ! Wahlvariable fÅrs MenÅ
  LOCAL m_mn%                           ! Merker fÅr letzte Note
  LOCAL m_n%                            ! Merker fÅr Cursorposition
  LOCAL a$                              ! Zwischenspeicher fÅr Notencode
  LOCAL s$                              ! AbkÅrzungsvariable
  LOCAL bld$                            ! Bildschirmrettungsnegativ
  LOCAL name$                           ! Name des gespielten StÅcks
  DIM w!(g_stka|)                       ! Auswahlarray, Eintrag=-1,f entspr.
  '                                     ! StÅck ausgewÑhlt worden ist.
  DIM w|(g_stka|)                       ! Alphabetnummerarray lîschen
  DIM m_n$(g_os%)                       ! Zwischenspeicher fÅr akt. StÅck
  ' ............................................................................
  '     1.)  l e t z t e s  S t Å c k  r e t t e n :
  ' ............................................................................
  SGET bld$                             ! Bildschirm retten
  LET m_mn%=g_mn%                       ! letzte Note des akt. StÅcks merken
  LET m_n%=g_n%                         ! Cursorposition des akt. StÅcks merken
  LET name$=g_fn$                       ! Namen retten
  IF m_mn%<>0                           ! F vor Druckbefehl StÅck im Speicher:
    FOR n%=1 TO g_mn%                   ! Alle Noten des akt. StÅcks durch
      LET m_n$(n%)=g_n$(n%)             ! StÅck in Speicherstring
    NEXT n%                             ! nÑchste Note des akt. StÅcks
  ENDIF                                 ! d
  ' ............................................................................
  '     2.)  V o r b e r e i t u n g e n :
  ' ............................................................................
  PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9     ! Cusor aus
  @3_dm("abspielen",w|,w!(),w|())       ! groûes MenÅ ausfahren: Stöcke wÑhlen
  IF w|=0                               ! F Abbruch gewÑhlt
    GOTO raus_spielen_gewaehlte         ! uverrichteter Dinge raus
  ENDIF                                 ! d
  FOR i|=1 TO g_stka|                   ! Alle StÅcke durch (physikalisch)
    EXIT IF LEFT$(g_stueck$(i|+1),4)="@@@@"       ! raus f leeres StÅck
    IF w!(i|)=TRUE                                ! F StÅck gespielt werden soll
      LET s$=g_stueck$(i|+1)                      ! StÅck kopieren
      FOR j|=1 TO g_os%                           ! Alle Noten d.i|-ten St.durch
        LET g_n$(j|)=MID$(s$,(j|-1)*4+1,4)        ! ins aktuelle StÅck kopieren
        EXIT IF g_n$(j|)="@@@@"                   ! F leere Note
      NEXT j|                                     ! nÑchste Note
      LET g_mn%=j|-1                              ! letzte Notennummer
      LET g_n%=g_mn%                              ! Cursor auf StÅckende
      SPUT g_lb$                                  ! Bild v.Text, Noten reinigen
      @2_stueck_ganz_zeigen                       ! 'Geladenes' StÅck auf Schirm
      LET g_fn$=MID$(g_stueck$(0),(i|-1)*8+1,8)   ! StÅckname ermitteln
      PRINT AT(1,1);g_fn$;"  phys.Nr.:'";i|;"' "  ! Info
      PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9           ! Cusor ein
      @2_abspielen(1,g_mn%)                       ! StÅck spielen
      PAUSE g_sp%                                 ! Pause
      IF g_midi!                                  ! F Midi ein
        @3_stimme1                                ! Sound fÅr Kanal 1 zufÑllig
        @3_stimme2                                ! Sound fÅr Kanal 2 zufÑllig
      ENDIF                                       ! d
      IF ASC(INKEY$)=27                           ! Raus f Escape-Taste
        LET r!=TRUE                               ! Rausflag setzen
      ENDIF                                       ! d
      EXIT IF r!                                  ! Raus f Abgebrochen
    ENDIF                                         ! d
    IF r!=TRUE                          ! F abgebrochen:
      LET r!=FALSE                      ! d
      @a_alert("Ganz abbrechen?/Ja|Nein",r|) ! d
      EXIT IF r|=1                      ! Raus f ja gewÑhlt:
    ENDIF                               ! d
    EXIT IF r|=1                        ! Raus f ja gewÑhlt:
  NEXT i|                               ! nÑchstes StÅck
  ' ............................................................................
  '     4.)  S t Å c k  w i e d e r h e r s t e l l e n :
  ' ............................................................................
  raus_spielen_gewaehlte:               ! Rauslabel
  IF m_mn%<>0                           ! F vor Druckbefehl StÅck im Speicher:
    FOR n%=1 TO m_mn%                   ! Alle Noten des akt. StÅcks durch
      LET g_n$(n%)=m_n$(n%)             ! StÅck von Speicherstring in Arbeitsstr
    NEXT n%                             ! nÑchste Note des akt. StÅcks
  ENDIF                                 ! d
  LET g_n%=m_n%                         ! Cursor wo er frÅher war
  LET g_mn%=m_mn%                       ! vorher akt. StÅck
  LET g_fn$=name$                       ! Name des aktuellen StÅcks wiederherst.
  SPUT bld$                             ! Bildschirm wiederherstellen
  ERASE w!()                            ! Wahlarray lîschen
  ERASE w|()                            ! Alphabetnummerarray lîschen
  ERASE m_n$()                          ! Speicherarray lîschen
  ' ----------------------------------------------------------------------------
RETURN
' ------------------------------------------------------------------------------
> PROCEDURE 2_hauptfileneuanlegen !_:
  ' ----------------------------------------------------------------------------
  LOCAL ok!                             ! Flag fÅr PrÅfprozedur
  LOCAL a|                              ! Wahlvariable fÅr Alertbox
  LOCAL s%                              ! ZÑhlvariable
  LOCAL schirm$                         ! Bildschirmspeichervariable
  LOCAL kl$                             ! Klaviaturnegativ
  ' ............................................................................
  GET 0,0,g_bb%-1,g_mh|-1,kl$           ! Klaviatur mit HauptmenÅtext fotogr.
  PUT 0,0,g_kl$                         ! Klaviatur ohne HauptmenÅtext raus
  PRINT AT(1,1);"GewÑhlt: Hauptfile neuanlegen (ca 40 s)";
  PRINT " bisher: '";g_hf$;"'"
  @3_dfrei(130404,ok!)                  ! sind noch 130404 Bytes auf Disk frei?
  IF NOT ok!                            ! F nicht:
    GOTO raus_hauptfileneuanlegen       ! d
  ENDIF                                 ! d
  @a_alert("Achtung! Alle StÅcke |im RAM werden gelîscht!/ok!|raus!",a|)
  IF a|=2                               ! F 'raus!' gewÑhlt
    GOTO raus_hauptfileneuanlegen       ! d
  ENDIF                                 ! d
  FILESELECT "A:\*.NTN",m$,m$           ! Fileselectbox
  IF m$=""                              ! F Abbruch gewÑhlt:
    GOTO raus_hauptfileneuanlegen       ! d
  ELSE                                  ! sonst:
    LET g_hf$=RIGHT$(m$,LEN(m$)-3)      ! 'A:\' wegschneiden
  ENDIF                                 ! d
  PRINT AT(65,1);"'";g_hf$;"'"          ! Nochmal Anzeige des Namens
  ' ............................................................................
  LET g_stueck$(0)=STRING$(g_stka|*8,"_")!Inhaltsverz. mit Leerzeichen auffÅllen
  LET g_stueck$(1)=g_stueck$(0)         ! Datumteil
  FOR s%=2 TO g_stka|+1                 ! Alle StÅcke durch
    LET g_stueck$(s%)=STRING$(800,"@")  ! Mit Leerzeichen auffÅllen
  NEXT s%                               ! nÑchstes StÅck
  ' ............................................................................
  @a_alert("GewÑhlt: Hauptfile neuanlegen|Zieldiskette einlegen!|Danach ca 40 Sec. warten!/ok!|raus!",a|)
  IF a|=2                               ! F 'raus!' gewÑhlt
    @a_alert("Hauptfile ist bereits zerstîrt!/ok!",a|)
    @1_fileselectboxfoto                ! Fileselectbox fotografieren
    GOTO raus_hauptfileneuanlegen       ! d
  ENDIF                                 ! d
  ' ............................................................................
  SGET schirm$                          ! Bildschirm retten
  PBOX 0,0,g_bb%-1,g_bh%-1              ! Bildschirm schwarz
  HIDEM                                 ! Mauspfeil weg
  OPEN "O",#1,g_hf$                     ! Hauptnotenfile îffnen
  STORE #1,g_stueck$()                  ! Array abspeichern
  CLOSE #1                              ! File schlieûen
  SPUT schirm$                          ! Bildschirm wieder herstellen
  SHOWM                                 ! Mauspfeil zeigen
  @1_fileselectboxfoto                  ! Fileselectbox fotografieren
  ' ............................................................................
  raus_hauptfileneuanlegen:             ! d
  PUT 0,0,kl$                           ! Klaviatur mit HauptmenÅtext raus
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 3_dfrei(w%,VAR o!)    !_:
  ' ----------------------------------------------------------------------------
  ' Hier wird geprÅft, ob noch w% Bytes auf der Diskette 'zu haben' sind.
  ' ............................................................................
  LOCAL a|                      ! Wahlvariable fÅr's MenÅ
  LOCAL f%                      ! soviel freie Bytes hat's auf der Diskette
  ' ............................................................................
  LET f%=DFREE(0)               ! f% freie Bytes gibt's noch auf der Disk.
  ' ............................................................................
  IF f%>=w%                     ! f mehr als gewÅnscht oder gleichviel Platz:
    LET o!=TRUE                 ! 'Alles ok!' Åbergeben
  ELSE                          ! f weniger als gewÅnscht Platz auf Disk:
    @a_alert("Es sind frei:'"+STR$(f%)+"'|Es braucht aber:'"+STR$(w%)+"'/ok!",a|)
  ENDIF                         ! d
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 2_hauptfile_laden     !_:
  ' ----------------------------------------------------------------------------
  LOCAL dummy|                          ! Dummy fÅr Alertbox
  LOCAL dummy%                          ! Dummy fÅr RECALL-Befehl
  LOCAL m$                              ! Speicher fÅr Filename
  LOCAL b$                              ! Bildspeicher
  ' ............................................................................
  SGET b$                               ! Bild retten
  SPUT g_lb$                            ! Lîschbildschirm
  PRINT AT(1,1);"GewÑhlt: Hauptfile laden (ca 15 Sek.)";
  PRINT " bisher: '";g_hf$;"'"
  ' ............................................................................
  FILESELECT "A:\*.NTN",m$,m$           ! Fileselectbox
  ' ............................................................................
  IF m$="" OR NOT EXIST(m$)             ! F Abbruch gewÑhlt:
    GOTO raus_2_hauptfile_laden         ! d
  ELSE                                  ! sonst:
    LET g_hf$=RIGHT$(m$,LEN(m$)-3)      ! 'A:\' wegschneiden
  ENDIF                                 ! d
  PRINT AT(65,1);"'";g_hf$;"'"          ! Nochmal Anzeige des Namens
  ' ............................................................................
  OPEN "I",#1,g_hf$                     ! Hauptnotenfile îffnen
  RECALL #1,g_stueck$(),-1,dummy%       ! Array laden
  CLOSE #1                              ! File schlieûen
  ' ............................................................................
  @1_fileselectboxfoto                  ! Fileselectbox fotografieren
  ' ............................................................................
  raus_2_hauptfile_laden:               ! d
  SPUT b$                               ! Bild wiederherstellen
  PUT 0,0,kl$                           ! Klaviatur mit HauptmenÅtext raus
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 2_save_hauptfile      !_:
  ' ----------------------------------------------------------------------------
  LOCAL ok!                             ! Flag fÅr PrÅfprozedur
  LOCAL m$                              ! Speicher fÅr Filename
  LOCAL schirm$                         ! Bildschirmspeichervariable
  LOCAL kl$                             ! Klaviaturnegativ
  ' ............................................................................
  GET 0,0,g_bb%-1,g_mh|-1,kl$           ! Klaviatur mit HauptmenÅtext fotogr.
  PUT 0,0,g_kl$                         ! Klaviatur ohne HauptmenÅtext raus
  PRINT AT(1,1);"GewÑhlt: Hauptfile abspeichern (ca 40 s)";
  PRINT " bisher: '";g_hf$;"'"
  @3_dfrei(130404,ok!)                  ! sind noch 130404 Bytes auf Disk frei?
  IF ok!=FALSE                          ! F nicht:
    GOTO raus_save_hauptfile            ! d
  ENDIF                                 ! d
  ' ............................................................................
  FILESELECT "A:\*.NTN",m$,m$           ! Fileselectbox
  ' ............................................................................
  IF m$=""                              ! F Abbruch gewÑhlt:
    GOTO raus_save_hauptfile            ! d
  ELSE                                  ! sonst:
    LET g_hf$=RIGHT$(m$,LEN(m$)-3)      ! 'A:\' wegschneiden
  ENDIF                                 ! d
  PRINT AT(65,1);"'";g_hf$;"'"          ! Nochmal Anzeige des Namens
  ' ............................................................................
  SGET schirm$                          ! Bildschirm retten
  PBOX 0,0,g_bb%-1,g_bh%-1              ! Bildschirm schwarz
  HIDEM                                 ! Mauspfeil weg
  ' ............................................................................
  OPEN "O",#1,g_hf$                     ! Hauptnotenfile îffnen
  STORE #1,g_stueck$()                  ! Array abspeichern
  CLOSE #1                              ! File schlieûen
  ' ............................................................................
  SPUT schirm$                          ! Bildschirm wieder herstellen
  SHOWM                                 ! Mauspfeil zeigen
  ' ............................................................................
  raus_save_hauptfile:                  ! d
  PUT 0,0,kl$                           ! Klaviatur mit HauptmenÅtext raus
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 2_file_loeschen       !_:
  ' ----------------------------------------------------------------------------
  LOCAL a|                              ! fÅr Alertbox
  LOCAL m$                              ! Speicher fÅr Filename
  LOCAL kl$                             ! Klaviaturnegativ
  ' ............................................................................
  GET 0,0,g_bb%-1,g_mh|-1,kl$           ! Klaviatur mit HauptmenÅtext fotogr.
  PUT 0,0,g_kl$                         ! Klaviatur ohne HauptmenÅtext raus
  PRINT AT(1,1);"GewÑhlt: File lîschen!"! Info Åber gewÑhlten Befehl
  ' ............................................................................
  nochmal_file_loeschen:                ! Wiederhol-Label
  FILESELECT "A:\*.*",m$,m$             ! Fileselectbox
  ' ............................................................................
  IF m$="" OR NOT EXIST(m$)             ! F Abbruch gewÑhlt:
    GOTO raus_file_loeschen             ! d
  ELSE                                  ! sonst:
    LET m$=RIGHT$(m$,LEN(m$)-3)         ! 'A:\' wegschneiden
  ENDIF                                 ! d
  @a_alert("Gelîscht wird: '"+m$+"' !/ok!|raus!",a|)
  IF a|=2                               ! F Abbruch gewÑhlt:
    GOTO raus_file_loeschen             ! d
  ENDIF                                 ! d
  PRINT AT(40,1);"'";m$;"'           "  ! Nochmal Anzeige des Namens
  ' ............................................................................
  KILL m$                               ! d
  ' ............................................................................
  GOTO nochmal_file_loeschen            ! Kreislauf, f viel gelîscht werden muû
  ' ............................................................................
  raus_file_loeschen:                   ! d
  PUT 0,0,kl$                           ! Klaviatur mit HauptmenÅtext raus
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 2_rename_file         !_:
  ' ----------------------------------------------------------------------------
  ' Hier wird ein File auf der Diskette umbenannt.
  ' ----------------------------------------------------------------------------
  LOCAL ok!                             ! Flag fÅr PrÅfprozedur
  LOCAL a|                              ! fÅr Alertbox
  LOCAL m$                              ! Speicher fÅr Filename
  LOCAL neu$                            ! Speicher fÅr neuen Namen
  LOCAL kl$                             ! Klaviaturnegativ
  ' ............................................................................
  GET 0,0,g_bb%-1,g_mh|-1,kl$           ! Klaviatur mit HauptmenÅtext fotogr.
  PUT 0,0,g_kl$                         ! Klaviatur ohne HauptmenÅtext raus
  PRINT AT(1,1);"GewÑhlt: File umbenennen! Jetzt: Umzubenennendes File anwÑhlen!";! Info Åber gewÑhlten Befehl
  ' ............................................................................
  FILESELECT "A:\*.*",m$,m$             ! Fileselectbox
  ' ............................................................................
  IF m$="" OR NOT EXIST(m$)             ! F Abbruch gewÑhlt:
    GOTO raus_rename_file               ! d
  ELSE                                  ! sonst:
    LET m$=RIGHT$(m$,LEN(m$)-3)         ! 'A:\' wegschneiden
  ENDIF                                 ! d
  ' ............................................................................
  nochmal_rename_file:                  ! Wiederhol-Label
  PUT 0,0,g_kl$                         ! Klaviatur ohne HauptmenÅtext raus
  PRINT AT(1,1);                        ! Cursor positionieren
  PRINT " Neuer Name: ";                ! Input-Info und Input platzieren
  INPUT neu$                            ! Eingabe des neuen Namens
  IF neu$="-1"                          ! F Abbruch gewÑhlt:
    GOTO raus_rename_file               ! d
  ENDIF                                 ! d
  @3_pruef(neu$,ok!)                    ! öberprÅfung der Eingabe
  IF NOT ok!                            ! F nicht ok:
    IF LEN(neu$)>12                     ! F zu lang
      LET neu$=LEFT$(neu$,12)           ! zurechtstutzen
    ENDIF                               ! d
    @a_alert("'"+neu$+"' ist unmîglicher Dateiname!/ok!|raus!",a|)
    IF a|=1                             ! F Einsicht:
      GOTO nochmal_rename_file          ! Kreislauf
    ELSE                                ! F Abbruch gewÅnscht:
      GOTO raus_rename_file             ! d
    ENDIF                               ! d
  ENDIF                                 ! d
  ' ............................................................................
  @a_alert("GeÑndert wird: '"+m$+"'|zu: '"+neu$+"'!/ok!|raus!",a|)
  IF a|=2                               ! F Abbruch gewÑhlt:
    GOTO raus_rename_file               ! d
  ENDIF                                 ! d
  PUT 0,0,g_kl$                         ! Klaviatur ohne HauptmenÅtext raus
  PRINT AT(1,1);"Jetzt wird umbenannt:  alt:'";m$;"' neu:'";neu$;"'"  ! Nochmal Anzeige der Namen
  ' ............................................................................
  RENAME m$ AS neu$                     ! File umbenennen
  ' ............................................................................
  raus_rename_file:                     ! d
  PUT 0,0,kl$                           ! Klaviatur mit HauptmenÅtext raus
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 3_pruef(n$,VAR o!)    !_:
  ' ----------------------------------------------------------------------------
  ' n$                          ! zu ÅberprÅfender Dateiname
  ' o!                          ! =-1 falls Dateiname ok
  LOCAL fehler!                 ! Flag fÅr 'Fehler gefunden'
  LOCAL i|                      ! ZÑhler fÅr Zeichen
  LOCAL asc|                    ! Ascii-Wert des aktuellen Zeichens
  LOCAL ext$                    ! Extension
  LOCAL name$                   ! Filename ohne Extension
  LOCAL pkt$                    ! Punkt zwischen Filename und Extension
  ' ............................................................................
  '                             ! Dateiname sollte z.B. so aussehen:'NAME.EXT'
  ' ............................................................................
  IF LEN(n$)<5                  ! '.EXT' + ein Zeichen brauchts mindestens
    LET fehler!=TRUE            ! Fehler gefunden
    GOTO raus_pruef             ! d
  ENDIF                         ! d
  ' ............................................................................
  LET ext$=RIGHT$(n$,3)         ! Extension ausschneiden
  LET name$=LEFT$(n$,LEN(n$)-4) ! Name ausschneiden
  LET pkt$=LEFT$(RIGHT$(n$,4),1)! Punkt ausschneiden
  ' ............................................................................
  IF pkt$<>"."                  ! F hier kein Punkt zu sehen:
    LET fehler!=TRUE            ! Fehler gefunden
    GOTO raus_pruef             ! d
  ENDIF                         ! d
  ' ............................................................................
  FOR i|=1 TO LEN(name$)        ! Name durch
    LET asc|=ASC(MID$(name$,i|,1)) ! Ascci-wert festhalten
    IF asc|<65 OR asc|>90       ! F auûerhalb groûer Buchstaben
      IF NOT (asc|>47 AND asc|<58) ! F keine Ziffer:
        LET fehler!=TRUE        ! Fehler gefunden
      ENDIF                     ! d
    ENDIF                       ! d
  NEXT i|                       ! nÑchster Buchstabe des Namens
  ' ............................................................................
  FOR i|=1 TO LEN(ext$)         ! Extension durch
    LET asc|=ASC(MID$(ext$,i|,1)) ! Ascci-wert festhalten
    IF asc|<65 OR asc|>91       ! F auûerhalb groûer Buchstaben
      IF NOT (asc|>47 AND asc|<58) ! F keine Ziffer:
        LET fehler!=TRUE        ! Fehler gefunden
      ENDIF                     ! d
    ENDIF                       ! d
  NEXT i|                       ! nÑchster Buchstabe des Extensions
  ' ............................................................................
  raus_pruef:                   ! d
  IF NOT fehler!                ! F keinen Fehler gefunden
    LET o!=TRUE                 ! RÅckgabeparameter auf 'Alles ok' setzen
  ENDIF                         ! d
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 2_inhverz_drucken     !_:
  ' ----------------------------------------------------------------------------
  ' Hier wird das Inhaltsverzeichnis des Hauptfiles gedruckt, mit Datum,
  ' physikalischer und alphabetischer StÅcknummer und zwar zweispaltig in
  ' Superscript.
  ' ----------------------------------------------------------------------------
  LOCAL i|                              ! ZÑhler fÅr die einzelnen StÅcke
  LOCAL schirm$                         ! Bildschirmspeichervariable
  DIM i$(g_stka|)                       ! Array fÅr die 160 Textzeilen
  ' ............................................................................
  '     1.)  T e x t z e i l e n  k o n s t r u i e r e n :
  ' ............................................................................
  FOR i|=1 TO g_stka|                   ! Alle StÅcke durch, physikalisch
    LET name$=MID$(g_stueck$(0),(i|-1)*8+1,8) ! StÅckname ermitteln
    LET datu$=MID$(g_stueck$(1),(i|-1)*8+1,8) ! Datum ermitteln
    LET alph$=STRING$(3-LEN(STR$(i|)),"0")+STR$(i|) ! Alphabetische StÅcknummer
    LET i$(i|)=name$+" | "+datu$+" | "+alph$+" | " ! Zeile fÅr i|-tes StÅck
  NEXT i|                               ! nÑchstes StÅck
  ' ............................................................................
  QSORT i$(),g_stka|+1                  ! Sortieren, alphabetisch
  ' ............................................................................
  FOR i|=1 TO g_stka|                   ! Alle StÅcke durch, alphabetisch
    LET phys$=STRING$(3-LEN(STR$(i|)),"0")+STR$(i|) ! physikalische StÅcknummer
    LET i$(i|)=i$(i|)+phys$             ! physikalische StÅcknummer dranhÑngen
  NEXT i|                               ! nÑchstes StÅck
  ' ............................................................................
  FOR i|=1 TO g_stka|/2                 ! Alle StÅcke durch, alphabetisch
    LET i$(i|)=i$(i|)+"    "+i$(i|+80)  ! beide Spalten in eine Zeile
  NEXT i|                               ! nÑchstes StÅck
  ' ............................................................................
  '     2.)  A u s d r u c k e n
  ' ............................................................................
  @a_alert("Wirklich drucken?/Ja|Nein",r|) ! d
  IF r|=2                               ! F Abbruch gewÑhlt:
    GOTO raus_inhverz                   ! raus
  ENDIF                                 ! d
  ' ............................................................................
  SGET schirm$                          ! Bildschirm retten
  PBOX 0,0,g_bb%-1,g_bh%-1              ! Bildschirm schwarz
  HIDEM                                 ! Mauspfeil weg
  ' ............................................................................
  LPRINT CHR$(27);CHR$(64);             ! resets the printer
  LPRINT CHR$(27);CHR$(83);CHR$(0);     ! selects superscripts
  '  LPRINT CHR$(27);CHR$(69);             ! selects emphasized printing
  LPRINT CHR$(27);CHR$(51);CHR$(24);    ! sets line spacing to n/216 inch
  LPRINT CHR$(27);CHR$(108);CHR$(10);   ! stets the left margin
  ' ............................................................................
  FOR i|=1 TO g_stka|/2                 ! Alle StÅcke durch, alphabetisch
    LPRINT i$(i|)                       ! Doppelspaltenzeile drucken, also Infos
    '                                   ! fÅr i|-tes  u n d  i|+80-tes StÅck.
  NEXT i|                               ! nÑchstes StÅck
  ' ............................................................................
  SPUT schirm$                          ! Bildschirm wieder herstellen
  SHOWM                                 ! Mauspfeil zeigen
  ' ............................................................................
  raus_inhverz:                         ! Rauslabel
  ERASE i$()                            ! Array fÅr die 160 Textzeilen lîschen
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 2_drucken_ab_x_alle   !_:
  ' ----------------------------------------------------------------------------
  ' Notentexte werden gedruckt; alle StÅcke ab der x-ten Stelle im alphabetisch
  ' geordneten Inhaltsverzeichnis. Auûer Punkt 2.) und Punkt 3.) stimmt diese
  ' Prozedur so ziemlich mit der '2_drucken_gewaehlt' Åberein.
  ' ----------------------------------------------------------------------------
  LOCAL r!                              ! Rausvariable 1
  LOCAL r|                              ! Rausvariable 2
  LOCAL i|                              ! StÅckzÑhler
  LOCAL m_mn%                           ! Merker fÅr letzte Note
  LOCAL m_n%                            ! Merker fÅr Cursorposition
  LOCAL x%                              ! Beginnummer
  LOCAL a$                              ! Zwischenspeicher fÅr Notencode
  LOCAL s$                              ! AbkÅrzungsvariable
  LOCAL bld$                            ! Bildschirmrettungsnegativ
  LOCAL name$                           ! Name des aktuellen StÅcks
  DIM w!(g_stka|)                       ! Auswahlarray, Eintrag=-1,f entspr.
  '                                     ! StÅck ausgewÑhlt worden ist.
  DIM w|(g_stka|)                       ! Alphabetnummerarray lîschen
  DIM m_n$(g_os%)                       ! Zwischenspeicher fÅr akt. StÅck
  DIM a$(g_stka|)                       ! MenÅeintragsfelderarray dim.
  DIM a%(g_stka|)                       ! Nummerierungsarray dim.
  ' ............................................................................
  '     1.)  l e t z t e s  S t Å c k  r e t t e n :
  ' ............................................................................
  SGET bld$                             ! Bildschirm retten
  LET name$=g_fn$                       ! Name des aktuellen StÅcks retten
  LET m_mn%=g_mn%                       ! letzte Note des akt. StÅcks merken
  LET m_n%=g_n%                         ! Cursorposition des akt. StÅcks merken
  IF m_mn%<>0                           ! F vor Druckbefehl StÅck im Speicher:
    FOR n%=1 TO g_mn%                   ! Alle Noten des akt. StÅcks durch
      LET m_n$(n%)=g_n$(n%)             ! StÅck in Speicherstring
    NEXT n%                             ! nÑchste Note des akt. StÅcks
  ENDIF                                 ! d
  ' ............................................................................
  '     2.)  V o r b e r e i t u n g e n :
  ' ............................................................................
  PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9     ! Cusor aus
  PRINT AT(1,1);"Ab welcher Stelle im Inhaltsverz. soll gedruckt werden (raus:'-1') ";
  INPUT x%                              ! Beginnummer
  IF x%<1 OR x%>g_stka|                 ! F Abbruch gewÑhlt
    GOTO raus_drucken_ab_x_alle         ! uverrichteter Dinge raus
  ENDIF                                 ! d
  ' ............................................................................
  '     3.)  D r u c k b i l d e r   h e r s t e l l e n :
  ' ............................................................................
  FOR i|=1 TO g_stka|                           ! Alle MenÅeintrÑge durch
    LET a$(i|)=MID$(g_stueck$(0),(i|-1)*8+1,8)  ! Ins MenÅeintragsfeld kopieren
    LET a%(i|)=i|                               ! Nummerierungsarrayeintrag
  NEXT i|                                       ! nÑchster MenÅeintrag
  ' ............................................................................
  QSORT a$(),g_stka|+1,a%()                     ! Sortieren, alphabetisch, in
  '                                             ! a%() wird die physikalische
  '                                             ! Nr. mitsortiert.
  ' ............................................................................
  FOR i|=x% TO g_stka|                          ! Alle MenÅeintrÑge ab x| durch
    EXIT IF LEFT$(g_stueck$(a%(i|)+1),4)="@@@@" ! raus f leeres StÅck
    '                                           ! in alphabetischer Reihenfolge
    @3_dr_st(a%(i|),i|,r!)                      ! Eine Ebene weiter zum Drucken
    IF r!=TRUE                                  ! F abgebrochen:
      LET r!=FALSE                              ! d
      @a_alert("Ganz abbrechen?/Ja|Nein",r|)    ! d
      EXIT IF r|=1                              ! Raus f ja gewÑhlt:
    ENDIF                                       ! d
    EXIT IF r|=1                                ! Raus f ja gewÑhlt:
  NEXT i|                                       ! nÑchster MenÅeintrag
  ' ............................................................................
  '     4.)  S t Å c k  w i e d e r h e r s t e l l e n :
  ' ............................................................................
  raus_drucken_ab_x_alle:               ! Rauslabel
  IF m_mn%<>0                           ! F vor Druckbefehl StÅck im Speicher:
    FOR n%=1 TO m_mn%                   ! Alle Noten des akt. StÅcks durch
      LET g_n$(n%)=m_n$(n%)             ! StÅck von Speicherstring in Arbeitsstr
    NEXT n%                             ! nÑchste Note des akt. StÅcks
  ENDIF                                 ! d
  LET g_fn$=name$                       ! Name des aktuellen StÅcks wiederherst.
  LET g_n%=m_n%                         ! Cursor wo er frÅher war
  LET g_mn%=m_mn%                       ! vorher akt. StÅck
  SPUT bld$                             ! Bildschirm wiederherstellen
  ERASE w!()                            ! Wahlarray lîschen
  ERASE w|()                            ! Alphabetnummerarray lîschen
  ERASE m_n$()                          ! Speicherarray lîschen
  ERASE a$()                            ! MenÅeintragsarray lîschen
  ERASE a%()                            ! Nummerierungsarray lîschen
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 2_spielen_ab_x_alle   !_:
  ' ----------------------------------------------------------------------------
  ' Notentexte werden gespielt; alle StÅcke ab der x-ten Stelle im alphabetisch
  ' geordneten Inhaltsverzeichnis. Auûer Punkt 2.) und Punkt 3.) stimmt diese
  ' Prozedur so ziemlich mit der '2_drucken_gewaehlt' Åberein.
  ' ----------------------------------------------------------------------------
  LOCAL r!                              ! Rausvariable 1
  LOCAL r|                              ! Rausvariable 2
  LOCAL i|                              ! StÅckzÑhler
  LOCAL m_mn%                           ! Merker fÅr letzte Note
  LOCAL m_n%                            ! Merker fÅr Cursorposition
  LOCAL x%                              ! Beginnummer
  LOCAL a$                              ! Zwischenspeicher fÅr Notencode
  LOCAL s$                              ! AbkÅrzungsvariable
  LOCAL bld$                            ! Bildschirmrettungsnegativ
  LOCAL name$                           ! Namensretter
  DIM w!(g_stka|)                       ! Auswahlarray, Eintrag=-1,f entspr.
  '                                     ! StÅck ausgewÑhlt worden ist.
  DIM w|(g_stka|)                       ! Alphabetnummerarray lîschen
  DIM m_n$(g_os%)                       ! Zwischenspeicher fÅr akt. StÅck
  DIM a$(g_stka|)                       ! MenÅeintragsfelderarray dim.
  DIM a%(g_stka|)                       ! Nummerierungsarray dim.
  ' ............................................................................
  '     1.)  l e t z t e s  S t Å c k  r e t t e n :
  ' ............................................................................
  SGET bld$                             ! Bildschirm retten
  LET m_mn%=g_mn%                       ! letzte Note des akt. StÅcks merken
  LET m_n%=g_n%                         ! Cursorposition des akt. StÅcks merken
  LET name$=g_fn$                       ! Name des aktuellen StÅcks retten
  IF m_mn%<>0                           ! F vor Druckbefehl StÅck im Speicher:
    FOR n%=1 TO g_mn%                   ! Alle Noten des akt. StÅcks durch
      LET m_n$(n%)=g_n$(n%)             ! StÅck in Speicherstring
    NEXT n%                             ! nÑchste Note des akt. StÅcks
  ENDIF                                 ! d
  ' ............................................................................
  '     2.)  V o r b e r e i t u n g e n :
  ' ............................................................................
  PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9     ! Cusor aus
  PRINT AT(1,1);"Ab welcher Stelle im Inhaltsverz. soll gespielt werden (raus:'-1') ";
  INPUT x%                              ! Beginnummer
  IF x%<1 OR x%>g_stka|                 ! F Abbruch gewÑhlt
    GOTO raus_spielen_ab_x_alle         ! uverrichteter Dinge raus
  ENDIF                                 ! d
  ' ............................................................................
  '     3.)  S p i e l b i l d e r   h e r s t e l l e n :
  ' ............................................................................
  FOR i|=1 TO g_stka|                           ! Alle MenÅeintrÑge durch
    LET a$(i|)=MID$(g_stueck$(0),(i|-1)*8+1,8)  ! Ins MenÅeintragsfeld kopieren
    LET a%(i|)=i|                               ! Nummerierungsarrayeintrag
  NEXT i|                                       ! nÑchster MenÅeintrag
  ' ............................................................................
  QSORT a$(),g_stka|+1,a%()                     ! Sortieren, alphabetisch, in
  '                                             ! a%() wird die physikalische
  '                                             ! Nr. mitsortiert.
  ' ............................................................................
  FOR i|=x% TO g_stka|                          ! Alle MenÅeintrÑge ab x| durch
    '                                           ! in alphabetischer Reihenfolge
    LET s$=g_stueck$(a%(i|)+1)                  ! StÅck kopieren
    EXIT IF LEFT$(s$,4)="@@@@"                  ! Raus f leeres StÅck
    FOR j|=1 TO g_os%                           ! Alle Noten des i|-ten St.durch
      LET g_n$(j|)=MID$(s$,(j|-1)*4+1,4)        ! ins aktuelle StÅck kopieren
      EXIT IF g_n$(j|)="@@@@"                   ! F leere Note
    NEXT j|                                     ! nÑchste Note
    LET g_mn%=j|-1                              ! letzte Notennummer
    LET g_n%=g_mn%                              ! Cursor auf StÅckende
    SPUT g_lb$                                  ! Bild v.Text und Noten reinigen
    @2_stueck_ganz_zeigen                       ! 'Geladenes' StÅck auf Schirm
    PRINT AT(1,1);a$(i|);" alph.Nr.:'";i|;"' phys.Nr.:'";a%(i|);"' " ! Info
    PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9           ! Cusor ein
    @2_abspielen(1,g_mn%)                       ! StÅck spielen
    PAUSE g_sp%                                 ! Pause
    IF g_midi!                                  ! F Midi ein
      @3_stimme1                                ! Sound fÅr Kanal 1 zufÑllig
      @3_stimme2                                ! Sound fÅr Kanal 2 zufÑllig
    ENDIF                                       ! d
    EXIT IF ASC(INKEY$)=27                      ! Raus f Escape-Taste
  NEXT i|                                       ! nÑchster MenÅeintrag
  ' ............................................................................
  '     4.)  S t Å c k  w i e d e r h e r s t e l l e n :
  ' ............................................................................
  raus_spielen_ab_x_alle:               ! Rauslabel
  SPUT g_lb$                            ! Bild v.Text und Noten reinigen
  IF m_mn%<>0                           ! F vor Druckbefehl StÅck im Speicher:
    FOR n%=1 TO m_mn%                   ! Alle Noten des akt. StÅcks durch
      LET g_n$(n%)=m_n$(n%)             ! StÅck von Speicherstring in Arbeitsstr
    NEXT n%                             ! nÑchste Note des akt. StÅcks
  ENDIF                                 ! d
  LET g_fn$=name$                       ! Name des aktuellen StÅcks wiederherst.
  LET g_n%=m_n%                         ! Cursor wo er frÅher war
  LET g_mn%=m_mn%                       ! vorher akt. StÅck
  SPUT bld$                             ! Bildschirm wiederherstellen
  ERASE w!()                            ! Wahlarray lîschen
  ERASE w|()                            ! Alphabetnummerarray lîschen
  ERASE m_n$()                          ! Speicherarray lîschen
  ERASE a$()                            ! MenÅeintragsarray lîschen
  ERASE a%()                            ! Nummerierungsarray lîschen
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 3_stimme1             !_:
  ' ----------------------------------------------------------------------------
  REPEAT                        ! Zufallsschleife
    LET i=RANDOM(28)            ! zufÑllig wÑhlen
  UNTIL i=0 OR i=2 OR i=3 OR i=4 OR i=10 OR i=13 OR i=20 OR i=25 OR i=26 OR i=27
  OUT 3,192,i                   ! Sound fÅr Kanal 1 einstellen
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 3_stimme2             !_:
  ' ----------------------------------------------------------------------------
  REPEAT                        ! Zufallsschleife
    LET i=RANDOM(30)            ! zufÑllig wÑhlen
  UNTIL i=7 OR i=8 OR i=15 OR i=18 OR i=23 OR i=24 OR i=29
  OUT 3,193,i                   ! Sound fÅr Kanal 2 einstellen
  ' ----------------------------------------------------------------------------
RETURN
' ------------------------------------------------------------------------------
> PROCEDURE 1_blockmark(i|)       !_:
  ' ----------------------------------------------------------------------------
  ' i|      ! =1: Blockanfang soll gesetzt werden, =2: Blockende
  '           =3: Blockmarken lîschen
  LOCAL alt_ble%                  ! altes Blockende merken
  ' ----------------------------------------------------------------------------
  IF g_n%>g_mn% AND g_mn%>1       ! F Endschreibmodus eingeschaltet,ausschalten:
    PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9 ! Cusor aus
    LET g_n%=g_mn%                ! Cursor auf Notentextende setzen
    PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9 ! Cusor ein
  ENDIF                           ! d
  ' ............................................................................
  IF g_bla%=0 AND g_ble%=0 AND i|=1 ! 1.) F Blockm nicht gesetzt: Blockanfang
    ' ..........................................................................
    '                             ! Blockanfang:
    IF g_n%<g_mn%-3 AND i|=1      ! F Block mindestens 3 Noten lang werden kann:
      LET g_bla%=g_n%             ! Blockanfang setzen
      LET g_ble%=g_mn%            ! Blockende auf Notentextende setzen
      PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9 ! Cusor aus
      IF g_mn%=g_os%              ! F 200 Noten
        LET g_n%=g_mn%            ! Cursor auf letzte Note
      ELSE                        ! sonst:
        LET g_n%=g_mn%+1          ! Endschreibmodus ein, d.h. Cursor>letzte Note
      ENDIF                       ! d
      PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9 ! Cusor ein
      @2_invers(g_bla%,g_mn%)     ! Ab Note g_bla% Rest des NotenstÅcks invers
    ENDIF                         ! d
    ' ..........................................................................
  ELSE IF g_bla%<>0 AND i|=3      ! 2.) F Blockanf.gesetzt:  Blockmarken lîschen
    ' ..........................................................................
    @2_invers(g_bla%,g_ble%)      ! Blockmarkierung lîschen
    LET g_bla%=0                  ! Blockanfang lîschen
    LET g_ble%=0                  ! Blockende lîschen
    ' ..........................................................................
    raus_blockmark:               ! d
    ' ..........................................................................
    ' F Block >= 3 Noten lang und Blanf. gesetzt und Curs<Blende und i|=2:
  ELSE IF g_n%-g_bla%>=3 AND g_bla%<>0 AND g_n%<g_ble% AND i|=2 ! 3.) Blockende
    LET alt_ble%=g_ble%           ! altes Blockende merken
    LET g_ble%=g_n%               ! Blockende setzen
    PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9 ! Cusor aus
    IF g_mn%=g_os%                ! F 200 Noten
      LET g_n%=g_mn%              ! Cursor auf letzte Note
    ELSE                          ! sonst:
      LET g_n%=g_mn%+1            ! Cursorpos hinter Textende (Endschreibmodus)
    ENDIF                         ! d
    PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9 ! Cusor ein
    @2_invers(g_ble%+1,alt_ble%)  ! Ab Note g_ble%+1 Rest invers, da bisher:
    '                             ! ab Note g_bla% Rest invers, ist jetzt der
    '                             ! Blockbereich vollstÑndig markiert
    ' ..........................................................................
  ENDIF                           ! d
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 2_invers(a%,b%)       !_:
  ' ----------------------------------------------------------------------------
  ' Diese Prozedur invertiert den Notentext von einschlieûlich Note a% bis e.b%
  ' und zwar zwischen der 1. und der 5. Notenlinie. WÅrde die ganze Zeile in-
  ' vertiert, kînnte man den Cursor vom Blockbereich am Rand nicht mehr unter-
  ' scheiden.
  ' Man muû 2 FÑlle betrachten:
  ' 1.) Die Noten a% und b% liegen in derselben Zeile:
  '     Also ist von einschl. a% bis einschl. b% ein Rechteck zu invertieren.
  ' 2.) Die Note b% liegt in einer Zeile unterhalb der von a%, dann:
  '   a) Zeile von a% ab a% einschlieûlich invertieren
  '   b) Zeile von b% bis b% einschlieûlich invertieren
  '   c) Zeilen dazwischen - sofern vorhanden - invertieren
  ' ----------------------------------------------------------------------------
  LOCAL za|                     ! Zeile von a%
  LOCAL zb|                     ! Zeile von b%
  LOCAL aktz|                   ! akt. Zeile der Zwischenzeilenschleife (2.c)
  LOCAL o|                      ! Diff. 1.linie v.ob. Zlnrnd (s.a.'Notenlinien')
  LOCAL u|                      ! o|+Diff. 5.Notenlinie von unterem Zeilenrand
  LOCAL a$                      ! Negativstring
  ' ----------------------------------------------------------------------------
  IF a%>b%                      ! F plîdsinnige öbergabewerte:
    GOTO raus_invers            ! hau ab!
  ENDIF                         ! d
  ' ............................................................................
  LET za|=TRUNC((a%-1)/g_npz|)+1! Zeile von a%=tr.(akt.Note-1/Noten proZeile)+1
  LET zb|=TRUNC((b%-1)/g_npz|)+1! Zeile von b%=tr.(akt.Note-1/Noten proZeile)+1
  LET o|=30                     ! Pos. 1.Notenlinie: g_y%(?)+n1y|
  LET u|=o|+19                  ! o|+5.Notenlinie (Diff.von unterem Zeilenrand)
  ' ............................................................................
  IF za|=zb|                    ! 1.) a% und b% liegen in derselben Zeile:
    ' ..........................................................................
    LET x1%=g_x%(a%)            ! links = Start-x-Koord. von Note a%
    LET y1%=g_y%(a%)+o|         ! oben  = Start-y-Koord. von Note a%
    LET x2%=g_x%(b%)+g_nb|-1    ! rechts= Start-x-Koord. Note b% + Notenbr.-1Pkt
    LET y2%=y1%+g_nzlh|-2-u|    ! unten = oben + Zeilenhîhe - 2 (-2=Rand)
    GET x1%,y1%,x2%,y2%,a$      ! Bereich fotografieren
    PUT x1%,y1%,a$,8            ! Bereich invertiert ausgeben
    ' ..........................................................................
  ELSE IF za|<zb|               ! 2.) a% und b% liegen in verschiedenen Zeilen:
    ' ..........................................................................
    '                           ! a) Zeile von a% ab a% einschl. invertieren:
    ' ..........................................................................
    LET x1%=g_x%(a%)            ! links = Start-x-Koord. von Note a%
    LET y1%=g_y%(a%)+o|         ! oben  = Start-y-Koord. von Note a%
    LET x2%=g_bb%-1             ! rechts= Bildschirmbreite - 1 Punkt
    LET y2%=y1%+g_nzlh|-2-u|    ! unten = oben + Zeilenhîhe - 2 (-2=Rand)
    GET x1%,y1%,x2%,y2%,a$      ! Bereich fotografieren
    PUT x1%,y1%,a$,8            ! Bereich invertiert ausgeben
    ' ..........................................................................
    '                           ! b) Zeile von b% bis b% einschl. invertieren:
    ' ..........................................................................
    LET x1%=0                   ! links = 0
    LET y1%=g_y%(b%)+o|         ! oben  = Start-y-Koord. von Note b%
    LET x2%=g_x%(b%)+g_nb|-1    ! rechts= Start-x-K. b% + Notenbreite - 1 Punkt
    LET y2%=y1%+g_nzlh|-2-u|    ! unten = oben + Zeilenhîhe - 2 (-2=Rand)
    GET x1%,y1%,x2%,y2%,a$      ! Bereich fotografieren
    PUT x1%,y1%,a$,8            ! Bereich invertiert ausgeben
    ' ..........................................................................
    '                           ! c) Zeilen dazw.-falls vorhanden-invertieren:
    ' ..........................................................................
    LET aktz|=za|+1             ! Startzeile sei Zeile unter der von der Note a%
    WHILE aktz|<zb|             ! Solange aktz| echt zwischen za| und zb| liegt:
      LET n%=aktz|*g_npz|       ! letzteNote in akt. Zeile=akt.Zle*NotenproZle+1
      LET x1%=0                 ! links = 0
      LET y1%=g_y%(n%)+o|       ! oben  = Start-y-Koord. von Note n%
      LET x2%=g_bb%-1           ! rechts= Bildschirmbreite - 1 Punkt
      LET y2%=y1%+g_nzlh|-2-u|  ! unten = oben + Zeilenhîhe - 2 (-2=Rand)
      GET x1%,y1%,x2%,y2%,a$    ! Bereich fotografieren
      PUT x1%,y1%,a$,8          ! Bereich invertiert ausgeben
      INC aktz|                 ! Aktuelle Zeile um eins erhîhen
    WEND                        ! Schleifenende
    ' ..........................................................................
  ENDIF                         ! EFU a%,b% liegen in gleichen/versch. Zeilen
  '  PRINT AT(1,1);"a%,b%,g_bla%,g_ble%,za|,zb|,aktz|"
  '  PRINT AT(1,2);a%,b%,g_bla%,g_ble%,za|,zb|,aktz|
  '  STOP
  ' ............................................................................
  raus_invers:                  ! d
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 1_block_kopieren      !_:
  ' ----------------------------------------------------------------------------
  ' Der Blockbereich wird an die Stelle vor den Cursor kopiert.
  ' ----------------------------------------------------------------------------
  LOCAL n%                      ! NotenpositionszÑhler
  LOCAL i%                      ! ZÑhler fÅr ZwischenspeicherfÅllschleife
  LOCAL bl_l%                   ! BlocklÑnge
  ' ............................................................................
  LET bl_l%=g_ble%-g_bla%+1     ! BlocklÑnge in Noten (einschl. Blockgrenzen)
  ' ............................................................................
  ' 1.) Raus bei fehlerhaften Voraussetzungen:
  ' ............................................................................
  IF g_mn%+bl_l%>g_os%          ! F neuer Text zu groû wÅrde:
    GOTO raus_block_kopieren    ! raus
  ENDIF                         ! d
  IF g_n%>g_bla% AND g_n%<g_ble%! F Cursor innerhalb vom Block:
    GOTO raus_block_kopieren    ! raus
  ENDIF                         ! d
  IF g_bla%=0 OR g_ble%=0       ! F Blockanfang oder - ende nicht gesetzt:
    GOTO raus_block_kopieren    ! raus
  ENDIF                         ! d
  DIM n$(bl_l%)                 ! Zwischenspeicherarray dimensionieren: Erst
  '                             ! nachdem sichergestellt ist, daû Block fertig.
  ' ............................................................................
  ' 2. Blockbereich in einen Zwischenspeicher:
  ' ............................................................................
  LET n%=bl_l%+1                ! ZÑhler fÅr Zwischenspeicherarray setzen
  FOR i%=g_bla% TO g_ble%       ! Den ganzen Block einschl. Blockgrenzen durch:
    DEC n%                      ! Normalen ZÑhler -1, denn von oben nach unten:
    LET n$(n%)=g_n$(i%)         ! Zwischenspeicherarray fÅllen
  NEXT i%                       ! nÑchste Note im Block
  ' ............................................................................
  ' 3. Den Inhalt des Zwischenspeichers an Position n% einfÅgen:
  ' ............................................................................
  FOR n%=1 TO bl_l%             ! den ganzen Block nochmal durch
    INSERT g_n$(g_n%)=n$(n%)    ! Zwischenspeicherarray an Position n% einfÅgen
  NEXT n%                       ! nÑchste Note im Zwischenspeicherarray
  ' ............................................................................
  ' 4. Den verÑnderten Text darstellen
  ' ............................................................................
  LET g_mn%=g_mn%+bl_l%         ! Neue Endnotennummer festsetzen
  SPUT g_lb$                    ! Bild von Noten reinigen (Lîschbild)
  @2_stueck_ganz_zeigen         ! Geladenes StÅck auf Bildschirm
  IF g_mn%=g_os%                ! F 200 Noten
    LET g_n%=g_mn%              ! Cursor auf letzte Note
  ELSE                          ! d
    LET g_n%=g_mn%+1            ! Notencursor hinter StÅckende: erst hier,
    '                           ! da in 'geladenes_stueck' for-Schleife
  ENDIF                         ! d
  PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9   ! Cusor ein
  LET g_bla%=0                  ! Blockanfang lîschen
  LET g_ble%=0                  ! Blockende lîschen
  ' ............................................................................
  raus_block_kopieren:          ! d
  ERASE n$()                    ! Zwischenspeicherarray lîschen
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 1_block_loeschen      !_:
  ' ----------------------------------------------------------------------------
  ' Die Noten im Blockbereich werden gelîscht. Der Befehl muû bestÑtigt werden.
  ' ----------------------------------------------------------------------------
  LOCAL a|                      ! Wahlvariable fÅr Alertbox
  LOCAL n%                      ! NotenpositionszÑhler
  LOCAL bl_l%                   ! BlocklÑnge
  ' ............................................................................
  IF g_bla%<>0 AND g_ble%<>0    ! F Block bereits vollstÑndig markiert
    @a_alert("Wirklich lîschen?/Ja|Nein",a|)
    IF a|=2                     ! Nein gewÑhlt:
      GOTO raus_block_loeschen  ! raus
    ENDIF                       ! d
    @a_undostueck               ! StÅck vorsichtshalber in Undoarray kopieren
  ENDIF                         ! d
  ' ............................................................................
  IF g_bla%=1 AND g_ble%=g_mn%  ! F ganzes StÅck gelîscht werden soll:
    SPUT g_lb$                  ! Bild von Noten reinigen (Lîschbild)
    LET g_n%=1                  ! Endschreibmodus ein, zusammen mit:
    LET g_mn%=0                 ! Endschreibmodus ein
    PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9   ! Cusor ein
    LET g_bla%=0                ! Blockanfang lîschen
    LET g_ble%=0                ! Blockende lîschen
    GOTO raus_block_loeschen    ! raus
  ELSE IF g_bla%=0 OR g_ble%=0  ! F Blockanfang oder - ende nicht gesetzt:
    GOTO raus_block_loeschen    ! raus
  ENDIF                         ! d
  ' ............................................................................
  '                             ! den ganzen Block durch einschl. Blockgrenzen:
  LET n%=g_ble%                 ! Hinten am Blockende (einschl.) anfangen
  REPEAT                        ! 'FOR n%=g_ble% DOWNTO g_bla%' - Ersatzschleife
    '    PRINT AT(1,1);"Bl.anf.:'";g_bla%;"' Bl.end.:'";g_ble%;"' nÑchste Lîschnote: g_n$(";n%;")='";g_n$(n%);"' g_mn%='";g_mn%;"'  "
    DELETE g_n$(n%)             ! Note innerhalb des Blocks lîschen
    DEC n%                      ! nÑchste Note innerhalb des Blocks
  UNTIL n%=g_bla%-1             ! Raus, f Blockanfang einschlieûlich gekillt
  ' ............................................................................
  LET bl_l%=g_ble%-g_bla%+1     ! BlocklÑnge in Noten (einschl. Blockgrenzen)
  LET g_mn%=g_mn%-bl_l%         ! Neue Endnotennummer festsetzen
  SPUT g_lb$                    ! Bild von Noten reinigen (Lîschbild)
  @2_stueck_ganz_zeigen         ! Geladenes StÅck auf Bildschirm
  LET g_n%=g_mn%                ! Notencursor auf StÅckende: erst hier,
  '                             ! da in 'geladenes_stueck' for-Schleife
  IF g_n%=0                     ! F Keine Note mehr vorhanden (auch g_mn%=0)
    LET g_n%=1                  ! Endschreibmodus ein
  ENDIF                         ! d
  PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9   ! Cusor ein
  LET g_bla%=0                  ! Blockanfang lîschen
  LET g_ble%=0                  ! Blockende lîschen
  ' ............................................................................
  raus_block_loeschen:          ! d
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 3_bl_faehnchen(v!)    !_:
  ' ----------------------------------------------------------------------------
  ' Ein FÑhnchen wird der aktuellen Note hinzugefÅgt oder weggennommen, was
  ' im 1. Teil festgestellt wird. Danach werden im 2. Teil die Ober-
  ' und Untergrenzen der FÑhnchenanzahl einzelner Noten im Block ermittelt.
  ' Falls mehr oder weniger FÑhnchen gewÅnscht werden, als vom Programm her
  ' Åberhaupt mîglich, wird im 3. Teil zum Prozedurende verzweigt. Im 4. Teil
  ' wird dann die Note wie gewÅnscht verÑndert und im 5. Teil neu dargestellt.
  ' ----------------------------------------------------------------------------
  ' v!                              ! =-1 fÅr: ein FÑhnchen weniger
  LOCAL b|                          ! FÑhnchenanzahl irgendeiner Note im Block
  LOCAL max_b|                      ! maximale FÑhnchenanzahl im Block
  LOCAL min_b|                      ! minimale FÑhnchenanzahl im Block
  LOCAL n%                          ! NotennrzÑhler fÅr Blockschleife
  LOCAL f%                          ! FÑhnchendiff. ganzzahlig
  ' ............................................................................
  PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9 ! Cusor aus
  ' ............................................................................
  ' 1. GewÅhnschte FÑhnchenanzahldifferenz ermitteln:
  ' ............................................................................
  IF v!=-1                          ! F ein FÑhnchen weniger verlangt
    LET f%=-1                       ! Differenz = -1
  ELSE                              ! F ein FÑhnchen mehr verlangt
    LET f%=1                        ! Differenz = +1
  ENDIF                             ! d
  ' ............................................................................
  ' 2. Minimale und maximale FÑhnchenanzahl im Block ermitteln:
  ' ............................................................................
  LET min_b|=3                      ! Minimum = hîchstmîgliche FÑhnchenanzahl
  FOR n%=g_bla% TO g_ble%           ! den ganzen Block einschl. Grenzen durch:
    LET b|=VAL(MID$(g_n$(n%),2,1))  ! Periode der aktuellen Blocknote
    IF b|>max_b|                    ! F akt. FÑhnchenanz.>max.FÑhnchenanz.
      LET max_b|=b|                 ! maximale FÑhnchenanz. neu setzen
    ENDIF                           ! d
    IF b|<min_b|                    ! F akt. FÑhnchenanz.<min.FÑhnchenanz.
      LET min_b|=b|                 ! minimale FÑhnchenanz. neu setzen
    ENDIF                           ! d
  NEXT n%                           ! nÑchste Note innerhalb des Blocks
  ' ............................................................................
  ' 3.) Raus, falls gewÅnschte Periodendauer > 1/4 oder < 1/32 sein soll:
  ' ............................................................................
  IF min_b|+f%<0                  ! F weniger als null FÑhnchen gewÅnscht:
    PRINT AT(1,1);"zu lang!"      ! Fehlermeldung
    PAUSE 40                      ! Zeit zum Lesen
    GOTO raus_bl_faehnchen        ! d
  ENDIF                           ! d
  IF max_b|+f%>3                  ! F mehr als vier FÑhnchen gewÅnscht:
    PRINT AT(1,1);"zu kurz!"      ! Fehlermeldung
    PAUSE 40                      ! Zeit zum Lesen
    GOTO raus_bl_faehnchen        ! d
  ENDIF                           ! d
  ' ............................................................................
  ' 4.) FÑhnchenverÑnderschleife
  ' ............................................................................
  FOR n%=g_bla% TO g_ble%           ! den ganzen Block einschl. Grenzen durch:
    LET b|=VAL(MID$(g_n$(n%),2,1))  ! Periode der aktuellen Blocknote
    MID$(g_n$(n%),2,1)=STR$(b|+f%)  ! énderung abspeichern
  NEXT n%                           ! nÑchste Note innerhalb des Blocks
  ' ............................................................................
  ' 5.) GeÑnderten Text darstellen und Blockmarken lîschen:
  ' ............................................................................
  SPUT g_lb$                        ! Bild von Noten reinigen (Lîschbild)
  @2_stueck_ganz_zeigen             ! Geladenes StÅck auf Bildschirm
  LET g_bla%=0                      ! Blockanfang lîschen
  LET g_ble%=0                      ! Blockende lîschen
  ' ............................................................................
  raus_bl_faehnchen:                ! d
  PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9 ! Cusor ein
  PUT 0,0,g_kl$                     ! Klaviatur von Infotext reinigen
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 3_bl_transponieren    !_:
  ' ----------------------------------------------------------------------------
  ' Im 1. Teil wird die neue, gewÅnschte Starthîhe und die alte Starthîhe im
  ' Blockanfang festgestellt. Im 2. Teil werden die Ober- und Untergrenzen
  ' der Tonhîhen innerhalb des Blockbereichs ermittelt. Falls beim gewÅnschten
  ' Transponieren der Tonumfang des Programms gesprengt werden wÅrde, wird
  ' im 3. Teil dann zum Prozedurende verzweigt. Im 4. Teil wird dann trans-
  ' poniert, im 5. Teil das Ergebnis dargestellt.
  ' ----------------------------------------------------------------------------
  LOCAL a|                          ! Tonhîhe irgendeiner Note im Block
  LOCAL max_a|                      ! maximale Tonhîhe im Block
  LOCAL min_a|                      ! minimale Tonhîhe im Block
  LOCAL neu_sh|                     ! neue Starttonîhe
  LOCAL blk_sh|                     ! Starttonhîhe im Block
  LOCAL n%                          ! NotennrzÑhler fÅr Blockschleife
  LOCAL diff|                       ! Transponierdiff. natÅrlich
  LOCAL diff%                       ! Transponierdiff. ganzzahlig
  LOCAL kl$                         ! Klaviaturnegativ
  ' ............................................................................
  GET 0,0,g_bb%-1,g_mh|-1,kl$       ! Klaviatur mit HauptmenÅtext fotografieren
  PUT 0,0,g_kl$                     ! Klaviatur ohne HauptmenÅtext raus
  PRINT AT(1,1);"Neue Anfangsnote eingeben!" ! d
  PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9 ! Cusor aus
  IF g_bla%=0 OR g_ble%=0           ! F Blockanfang oder - ende nicht gesetzt:
    GOTO raus_bl_transponieren      ! raus
  ENDIF                             ! d
  ' ............................................................................
  ' 0.) Auf neue Eingabe warten
  ' ............................................................................
  REPEAT                            ! Warteschleife fÅr Mausklick
  UNTIL MOUSEK                      ! Raus f Mausklick
  PUT 0,0,g_kl$                     ! Klaviatur ohne HauptmenÅtext raus
  LET x%=MOUSEX                     ! x-Koordinate festhalten
  IF MOUSEY>g_mh|                   ! F Maus auf Klaviatur
    GOTO raus_bl_transponieren      ! d
  ENDIF                             ! d
  ' ............................................................................
  ' 1.) Neue Starttonhîhe neu_h| fÅr den Blockbereich feststellen
  ' ............................................................................
  IF x%<g_ptb| OR x%>g_bb%-g_ptb|   ! Pausentaste ?
    PRINT AT(1,1);"zu pausig!"      ! Fehlermeldung
    PRINT CHR$(7);                  ! Gong !
    PAUSE 40                        ! Zeit zum Lesen
    GOTO raus_bl_transponieren      ! d
  ELSE                              ! Notentaste:
    LET neu_sh|=TRUNC((x%-g_ptb|)/g_ntb|)+1! Neue Starttonhîe feststellen
  ENDIF                             ! d
  LET blk_sh|=ASC(LEFT$(g_n$(g_bla%),1))-64 ! Alte Starttonhîhe vom Blockanf.
  ' ............................................................................
  ' 2.) Maximale & min. Tonhîhe (max_a| & min_a|) im Blockbereich feststellen:
  ' ............................................................................
  LET min_a|=25                     ! Minimum = hîchstmîgliche Notenhîhe
  FOR n%=g_bla% TO g_ble%           ! den ganzen Block einschl. Grenzen durch:
    LET a|=ASC(LEFT$(g_n$(n%),1))-64! Tonhîhe der aktuellen Blocknote
    IF a|>max_a| AND NOT a|=26      ! F akt. Tonhîhe(=|=Pause) >maximale Tonhîhe
      LET max_a|=a|                 ! maximale Tonhîhe neu setzen
    ENDIF                           ! d
    IF a|<min_a|                    ! F akt. Tonhîhe < minimale Tonhîhe
      LET min_a|=a|                 ! minimale Tonhîhe neu setzen
    ENDIF                           ! d
  NEXT n%                           ! nÑchste Note innerhalb des Blocks
  ' ............................................................................
  ' 3.) Raus, falls Transponierdifferenz fÅr Tonumfang (c1-c3) zu groû:
  ' ............................................................................
  IF neu_sh|<blk_sh|                ! F nach unten transponiert werden soll:
    LET diff|=blk_sh|-neu_sh|       ! Differenz der Starthîhen=Transponierdiff.
    IF min_a|-diff|<1               ! F minimale Tonhîhe unter c1 tr.wÅrde
      PRINT AT(1,1);"zu tief!"      ! Fehlermeldung
      PRINT CHR$(7);                ! Gong !
      PAUSE 40                      ! Zeit zum Lesen
      GOTO raus_bl_transponieren    ! d
    ENDIF                           ! d
    LET diff%=(-1)*diff|            ! ZukÅnftige Transponierdiff. ganzzahlig
  ELSE IF neu_sh|>blk_sh|           ! F nach oben transponiert werden soll
    LET diff|=neu_sh|-blk_sh|       ! Differenz der Starthîhen=Transponierdiff.
    IF max_a|+diff|>25              ! F maximale Tonhîhe Åber c3 tr.wÅrde
      PRINT AT(1,1);"zu hoch!"      ! Fehlermeldung
      PRINT CHR$(7);                ! Gong !
      PAUSE 40                      ! Zeit zum Lesen
      GOTO raus_bl_transponieren    ! d
    ENDIF                           ! d
    LET diff%=diff|                 ! ZukÅnftige Transponierdiff. ganzzahlig
  ELSE                              ! sonst:
    PRINT AT(1,1);"zu gleich!"      ! Fehlermeldung
    PRINT CHR$(7);                  ! Gong !
    PAUSE 40                        ! Zeit zum Lesen
    GOTO raus_bl_transponieren      ! d
  ENDIF                             ! EFU nach oben / unten transponieren
  ' ............................................................................
  ' 4.) Transponierschleife
  ' ............................................................................
  FOR n%=g_bla% TO g_ble%           ! den ganzen Block einschl. Grenzen durch:
    LET a|=ASC(LEFT$(g_n$(n%),1))-64! Tonhîhe der aktuellen Blocknote
    IF a|<>26                       ! F Note keine Pause:
      MID$(g_n$(n%),1,1)=CHR$(a|+diff%+64)  ! énderung abspeichern
    ENDIF                           ! d
  NEXT n%                           ! nÑchste Note innerhalb des Blocks
  ' ............................................................................
  ' 5.) GeÑnderten Text darstellen und Blockmarken lîschen:
  ' ............................................................................
  SPUT g_lb$                        ! Bild von Noten reinigen (Lîschbild)
  @2_stueck_ganz_zeigen             ! Geladenes StÅck auf Bildschirm
  LET g_bla%=0                      ! Blockanfang lîschen
  LET g_ble%=0                      ! Blockende lîschen
  LET g_n%=g_mn%                    ! Cursor auf letzte Note
  ' ............................................................................
  raus_bl_transponieren:            ! d
  PUT 0,0,kl$                       ! Klaviatur mit HauptmenÅtext raus
  PUT g_x%(g_n%),g_y%(g_n%),g_cs$,9 ! Cusor ein
  PUT 0,0,g_kl$                     ! Klaviatur von Infotext reinigen
  ' ----------------------------------------------------------------------------
RETURN
' ------------------------------------------------------------------------------
> PROCEDURE 1_abspielgeschw       !_:
  ' ----------------------------------------------------------------------------
  LOCAL a                       ! Abspielgeschwindigkeitsfaktor
  LOCAL bld$                    ! Bildschirmnegativ
  ' ............................................................................
  SGET bld$                     ! Bildschirm retten
  PUT 0,0,g_kl$                 ! Klaviatur ohne HauptmenÅtext raus
  nochmal_abspielgeschw:        ! d
  PRINT AT(1,1);"bisher:";g_vz|/8;", 1=ganz schnell, 6=ganz langsam, neu: ";
  INPUT a                       ! Eingabe
  IF a<1 OR a>6                 ! F Frequenz auûerhalb erlaubtem Intervall:
    PUT 0,0,g_kl$               ! Klaviatur ohne HauptmenÅtext raus
    PRINT AT(1,1);"zu extrem!"  ! Fehlermeldung
    PRINT CHR$(7);              ! Gong !
    PAUSE 40                    ! Zeit zum Lesen
    GOTO nochmal_abspielgeschw  ! d
  ENDIF                         ! d
  LET g_vz|=8*a                 ! siehe auch '0_globalvariablen'
  SPUT bld$                     ! Bildschirm wiederherstellen
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 1_stueckpause         !_:
  ' ----------------------------------------------------------------------------
  LOCAL a1                      ! Neue Frequenz fÅr a1
  LOCAL d                       ! Differenz neue und alte Frequenz von a1
  LOCAL bld$                    ! Bildschirmnegativ
  ' ............................................................................
  SGET bld$                     ! Bildschirm retten
  PUT 0,0,g_kl$                 ! Klaviatur ohne HauptmenÅtext raus
  nochmal_stueckpause:          ! d
  PRINT AT(1,1);"bisher StÅckpause: ";g_sp%;" /50-tel Sek., Neue StÅckpause: ";
  INPUT a1                      ! Eingabe
  IF a1<0 OR a1>100             ! F Pause auûerhalb erlaubtem Intervall:
    PUT 0,0,g_kl$               ! Klaviatur ohne HauptmenÅtext raus
    PRINT AT(1,1);"zu extrem!"  ! Fehlermeldung
    PRINT CHR$(7);              ! Gong !
    PAUSE 40                    ! Zeit zum Lesen
    GOTO nochmal_stueckpause    ! d
  ENDIF                         ! d
  LET g_sp%=a1                  ! StÅckpause an Globalvariable Åbergeben
  SPUT bld$                     ! Bildschirm wiederherstellen
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 1_tonhoehe            !_:
  ' ----------------------------------------------------------------------------
  ' Funktionslos, seit 4 Oktaven mîglich, siehe auch Prozedur 'a_2s'
  ' ----------------------------------------------------------------------------
  LOCAL a1                      ! Neue Frequenz fÅr a1
  LOCAL d                       ! Differenz neue und alte Frequenz von a1
  LOCAL bld$                    ! Bildschirmnegativ
  ' ............................................................................
  SGET bld$                     ! Bildschirm retten
  PUT 0,0,g_kl$                 ! Klaviatur ohne HauptmenÅtext raus
  nochmal_tonhoehe:             ! d
  PRINT AT(1,1);"a1 hat bisher die Frequenz: ";fr%(10);", Neue Frequenz fÅr a1: ";
  INPUT a1                      ! Eingabe
  IF a1<100 OR a1>10000         ! F Frequenz auûerhalb erlaubtem Intervall:
    PUT 0,0,g_kl$               ! Klaviatur ohne HauptmenÅtext raus
    PRINT AT(1,1);"zu extrem!"  ! Fehlermeldung
    PRINT CHR$(7);              ! Gong !
    PAUSE 40                    ! Zeit zum Lesen
    GOTO nochmal_tonhoehe       ! d
  ENDIF                         ! d
  SPUT bld$                     ! Bildschirm wiederherstellen
  LET d=a1-fr%(10)              ! Differenz: neue Frequenz/ alte Frequenz von a1
  FOR i|=1 TO 50                ! Alle Frequenzdaten durch
    LET fr%(i|)=fr%(i|)+d       ! neue Frequenzen berechnen
  NEXT i|                       ! nÑchste Note im Frequenzarray
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 1_midi_ein_aus        !_:
  ' ----------------------------------------------------------------------------
  IF g_midi!=FALSE                      ! F bisher aus:
    LET g_midi!=TRUE                    ! Midi ein
  ELSE                                  ! sonst
    LET g_midi!=FALSE                   ! Midi aus
  ENDIF                                 ! d
  ' ----------------------------------------------------------------------------
RETURN
' ------------------------------------------------------------------------------
> PROCEDURE 1_programmende(w|)    !_:
  ' ----------------------------------------------------------------------------
  LOCAL m|                      ! MenÅwahlvariable
  ' w|                          ! Wahlvariable
  ' ............................................................................
  IF w|=1                       ! Edit gewÑhlt:  (Bei PD-Version drauûen !)
    EDIT                        ! d
  ELSE IF w|=2                  ! w|=2, Quit gewÑhlt:
    @a_alert("Wirklich Interpreter verlassen?/Ja|Nein",m|)
    IF m|=1                     ! F 'ja' gewÑhlt:
      QUIT                      ! d
    ENDIF                       ! d
  ENDIF                         ! d
  ' ----------------------------------------------------------------------------
RETURN
' ##############################################################################
'  A l e r t b o x p r o z e d u r e n :
' ##############################################################################
> PROCEDURE a_alert(a1$,VAR w1|)
  t0t|=21
  ' ----------------------------------------------------------------------------
  ' Diese Prozedur entspricht einer Gem-Alertbox, es sind aber viel mehr
  ' EintrÑge mîglich.
  ' Ein AlertÅbergabestring (Bsp.: "Hallo|Du ! Bist Du's ?/Ja|Nein") besteht
  ' aus einem Teil der nur angezeigt wird (der steht vor dem '/') und einem
  ' Teil, bei dem man aus den verschiedenen EintrÑgen auswÑhlen kann (der
  ' steht hinter dem '/'). Beide Teile zusammen dÅrfen hîchstens 20 EintrÑge
  ' haben, die hîchstens 78 Zeichen breit sind
  ' ----------------------------------------------------------------------------
  LOCAL i1%                 ! ZÑhler fÅr Analyse des MenÅeintragsstrings
  LOCAL i1|                 ! ZÑhler fÅr Analyse des MenÅeintragsstrings
  LOCAL j1|                 ! ZÑhler fÅr MenÅeintrage (erst nicht,dann whlb)
  LOCAL l1|                 ! LÑngenmaximum aller EintrÑge
  LOCAL mxb1|               ! Maximum der nur anzuzeigenden MenÅeintrÑge
  LOCAL mxw1|               ! Maximum der wÑhlbaren MenÅeintrÑge
  LOCAL bld1$               ! Bildspeicher
  LOCAL sx1|                ! Start-x-Spalte der EintrÑge
  LOCAL sy1|                ! Start-y-Zeile  der EintrÑge
  ' ............................................................................
  FOR i1%=1 TO LEN(a1$)         ! String durch
    IF MID$(a1$,i1%,1)="|"      ! Grenze errcht
      INC j1|                   ! ZÑhlr erhîh.
    ENDIF                       ! d
    IF MID$(a1$,i1%,1)="/"      ! Grenze errcht
      LET mxb1|=j1|+1           ! Mx nur Bild
      CLR j1|                   ! ZÑhler null
    ENDIF                       ! d
  NEXT i1%                      ! nÑchst Buchst
  LET mxw1|=j1|+1               ! Mx wÑhlbar
  ' ............................................................................
  DIM b1$(mxb1|)        ! Array fÅr MenÅ mit nur angezeigten EintÑgen
  DIM w1$(mxw1|)        ! Array fÅr MenÅ mit wÑhlbaren EintÑgen
  ' ............................................................................
  ' Jetzt werden erst 'mal die NurbildeintrÑge ausgefiltert
  LET j1|=1                                 ! EintragszÑhler 1
  FOR i1|=1 TO LEN(a1$)                     ! aString durch
    LET mi1$=MID$(a1$,i1|,1)                ! akt. Zchn merken
    IF mi1$="|" OR mi1$="/"                 ! Eintragsgrenze errcht
      LET b1$(j1|)=LEFT$(a1$,i1|-1)         ! Nurbildeintrag setzen
      IF l1|<LEN(b1$(j1|))                  ! F neues LÑngenmaximum
        LET l1|=LEN(b1$(j1|))               ! Åbernehmen
      ENDIF                                 ! d
      LET a1$=RIGHT$(a1$,LEN(a1$)-i1|)      ! aString kÅrzen
      CLR i1|                               ! ZeichenzÑhler null
      INC j1|                               ! EintragszÑhlr erhîh.
    ENDIF                                   ! d
    EXIT IF mi1$="/"                        ! MenÅgrenze errcht
  NEXT i1|                                  ! nÑchst Buchst
  LET a1$=RIGHT$(a1$,LEN(a1$)-i1|)          ! aString kÅrzen
  ' ............................................................................
  ' Jetzt werden die WahleintrÑge ausgefiltert
  LET j1|=1                                 ! EintragszÑhler 1
  REPEAT                                    ! aString durch
    INC i1|                                 ! nÑchste Zeichennummer
    LET mi1$=MID$(a1$,i1|,1)                ! akt. Zchn merken
    IF mi1$="|" OR mi1$="/"                 ! Eintragsgrenze errcht
      LET w1$(j1|)=LEFT$(a1$,i1|-1)         ! Wahleintrag setzen
      IF l1|<LEN(w1$(j1|))                  ! F neues LÑngenmaximum
        LET l1|=LEN(w1$(j1|))               ! Åbernehmen
      ENDIF                                 ! d
      LET a1$=RIGHT$(a1$,LEN(a1$)-i1|)      ! aString kÅrzen
      CLR i1|                               ! ZeichenzÑhler null
      INC j1|                               ! EintragszÑhlr erhîh.
    ENDIF                                   ! d
  UNTIL i1|=LEN(a1$)                        ! aString ganz durch
  LET w1$(j1|)=a1$                          ! Wahleintrag setzen
  ' ............................................................................
  IF b1$(1)<>""                             ! d
    LET b1$(1)=LEFT$(b1$(1)+SPACE$(l1|),l1|)! Mit Spaces auffÅllen
  ENDIF                                     ! d
  IF w1$(1)<>""                             ! d
    LET w1$(1)=LEFT$(w1$(1)+SPACE$(l1|),l1|)! Mit Spaces auffÅllen
  ENDIF                                     ! d
  ' ............................................................................
  LET sx1|=ROUND((80-l1|)/2)                ! Startspalte
  LET sy1|=ROUND((22-mxb1|)/2)              ! Startzeile
  ' ............................................................................
  ' Alertausschnitt (Kasten, der der Alertbox entspricht) ausschneiden, retten:
  GET (sx1|-1)*8-1,(sy1|-1)*16,sx1|*8+l1|*8,sy1|*16+(mxb1|+mxw1|)*16,bld1$
  ' ............................................................................
  @a_menue(-1,0,0,0,0,-1,sx1|,sy1|,1,mxb1|,dummy1|,dummy1|,b1$(),d!())
  REPEAT                                    ! Solange neues MenÅ,
    @a_menue(-1,-1,-1,0,0,-1,sx1|,sy1|+mxb1|,1,mxw1|,dummy1|,w1|,w1$(),d!())
  UNTIL w1|<>0                              ! bis Eintrag gewÑhlt
  ' ............................................................................
  PUT (sx1|-1)*8-1,(sy1|-1)*16,bld1$        ! Alertausschnitt zurÅck
  ' ............................................................................
  ERASE b1$()       ! Array fÅr MenÅ mit nur angezeigten EintÑgen
  ERASE w1$()       ! Array fÅr MenÅ mit wÑhlbaren EintÑgen
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE a_menue(ad!,wv!,we1!,wex!,inp!,rmn!,sx|,sy|,sp|,zl|,VAR m|,w|,a$(),a!())
  t0t|=22
  ' ----------------------------------------------------------------------------
  ' Mit dieser Prozedur kann man ein MenÅ erzeugen. Dessen EintrÑge mÅssen
  ' sich im öbergabearray a$() befinden. Welcher Eintrag gewÑhlt wurde,
  ' erfÑhrt man nach Prozedurende im RÅckgabeparametzer w|. Es gibt
  ' einige ZusÑtzliche Einstellungen, die im folgenden aufgelistet sind:
  ' ----------------------------------------------------------------------------
  '
  ' öbergabevariablen:
  '
  ' ad!  = Auch Darstellung des MenÅs ? nein=0, ja=-1
  ' wv!  = Wahlvorschlag (1.Eintrag) ein (-1) oder aus (0)
  ' we1! = wÑhlbare EintrÑge(nur 1) (-1) oder nicht (0: also MenÅ nur abbilden)
  ' wex! = alle (insbes. mehr als ein Eintrag) EintrÑge wÑhlbar ? ja=-1, nein=0
  ' inp! = Input (-1:schlieût bis jetzt wex!=-1 aus!) oder nicht (0)
  ' rmn! = Rahmen (-1) oder nicht (0)
  ' sx|  = Start-x-Koordinate (in Zeichen) von MenÅeintrÑgen links
  ' sy|  = Start-y-Koordinate (in Zeichen) von MenÅeintrÑgen oben
  ' sp|  = Spaltenanzahl der MenÅeintrÑge
  ' zl|  = Zeilenanzahl der MenÅeintrÑge
  ' m|   = Maustastennummer 0=linke, 1=rechte Maustaste
  ' w|   = Wahlnummer des gewÑhlten Eintrages            auch zurÅck !
  ' a$() = Eintragsarray, hier sind alle EintrÑge drin   auch zurÅck !
  ' a!() = Wahlarray hier steht an erster Stelle eine 0, falls der entsprechende
  '        Eintrag in a$() nicht gewÑhlt und -1, falls er gewÑhlt.
  '
  ' ............................................................................
  LOCAL di|        ! Die Anzahl der Spaces, die wegen der Inputfunktion
  '                ! jedem Eintrag hinten drangefÅgt werden (in letzter
  '                ! Procedure wieder abgezogen)
  LOCAL ml|        ! EintragslÑngenmaximum
  ' ............................................................................
  REPEAT            ! Warteschleife fÅr Mauseingabe:
  UNTIL MOUSEK=0    ! Erst Raus,wenn Maus nix mehr meldet,also Puffer leer
  ' ............................................................................
  @a_menueeintraege_maximieren(sp|,zl|,ml|,di|,a$())    ! d
  IF rmn!=-1                                            ! Mit Rahmen
    @a_menuerahmen(ml|,sx|,sy|,sp|,zl|)                 ! d
  ENDIF                                                 ! d
  IF we1!=0 AND ad!                                     ! MenÅ nur anzgen
    @a_menue_anzeigen(ml|,sx|,sy|,sp|,zl|,a$())         ! d
  ELSE IF inp!=0                                        ! WÑhlen oh.Input
    IF ad!                                              ! f auch darstellen
      @a_menue_anzeigen(ml|,sx|,sy|,sp|,zl|,a$())       ! d
    ENDIF                                               ! d
    IF wex!                                             ! F alle EintrÑge wÑhlb.
      @a_eintraege_waehlen(wv!,ml|,sx|,sy|,sp|,zl|,a$(),a!(),m|,w|) ! d
    ELSE                                                ! F nur 1 Eintrag wÑhlb.
      @a_eintrag_waehlen(wv!,ml|,sx|,sy|,sp|,zl|,a$(),m|,w|) ! d
    ENDIF                                               ! d
  ELSE                                                  ! WÑhln mit Input
    IF ad!                                              ! f auch darstellen
      @a_menue_anzeigen(ml|,sx|,sy|,sp|,zl|,a$())       ! d
    ENDIF                                               ! d
    @a_eintrag_waehlen(wv!,ml|,sx|,sy|,sp|,zl|,a$(),m|,w|) ! d
    IF w|<>0                                            ! F Eintrag gew.
      @a_eintraginput(ml|,di|,sx|,sy|,sp|,zl|,m|,w|,a$())  ! d
      IF a$(w|)="        "                              ! F nix eingeg.
        LET w|=0                                        ! Abbruchcode
      ENDIF                                             ! d
    ENDIF                                               ! d
  ENDIF                                                 ! d
  @a_menueeintraege_minus_di8(sp|,zl|,ml|,di|,a$())     ! Inputzusatz wiederweg
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE a_menueeintraege_maximieren(sp3|,zl3|,VAR ml3|,di3|,a3$())
  t2t|=23
  ' ----------------------------------------------------------------------------
  ' Hier werden alle EintrÑge mit Spaces aufgefÅllt, bis sie alle gleich
  ' lang sind.
  ' ----------------------------------------------------------------------------
  '     di3|                        ! ZusÑtzliche Spaces am Ende jedes
  '                                 ! Eintrages, um nachher korrektes
  '                                 ! Input zu ermîglichen
  '                                 ! Diese Variable ist RÅckgabeparameter
  '     ml3|                        ! EintragslÑngenmaximum ist "
  ' ............................................................................
  LOCAL i3|                         ! ZÑhler fÅr EintrÑge
  ' ............................................................................
  LET di3|=1                        ! FÅr Input zusÑtliche di3| Spaces
  LET ml3|=0                        ! EintragslÑngenmaximum null setzen
  ' ............................................................................
  FOR i3|=1 TO sp3|*zl3|            ! Alle EintrÑge durch
    IF LEN(a3$(i3|))>ml3|           ! Falls Eintrag grîûer als bisher
      LET ml3|=LEN(a3$(i3|))        ! Maximum EintraglÑnge neu setzen
    ENDIF                           ! d
  NEXT i3|                          ! nÑchster Eintrag
  ' ............................................................................
  FOR i3|=1 TO sp3|*zl3|                      !Alledurch
    a3$(i3|)=LEFT$(a3$(i3|)+SPACE$(ml3|),ml3|)!AuffÅllen
    a3$(i3|)=a3$(i3|)+SPACE$(di3|)            !fÅr Input
  NEXT i3|                                    ! nÑchster
  ' ............................................................................
  ADD ml3|,di3|                               ! EintragslÑnge anpassen
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE a_menuerahmen(ml4|,sx4|,sy4|,sp4|,zl4|)
  t2t|=24
  ' ----------------------------------------------------------------------------
  ' In dieser Prozedur erhÑlt das kommende MenÅ einen Rahmen.
  ' ----------------------------------------------------------------------------
  LOCAL dx4|        ! Distanz zwischen Rahmen und Eintragsrand in x-Richtung
  LOCAL dy4|        ! Distanz zwischen Rahmen und Eintragsrand in y-Richtung
  LOCAL lx4%        ! Position des Rahmens links
  LOCAL oy4%        ! Position des Rahmens oben
  LOCAL rx4%        ! Position des Rahmens rechts
  LOCAL uy4%        ! Position des Rahmens unten
  ' ............................................................................
  LET dx4|=1                                        ! Randabstand x
  LET dy4|=1                                        ! Randabstand y
  LET lx4%=(sx4|-1)*8-dx4|                          ! Links
  LET oy4%=sy4|*16-dy4|                             ! Oben
  LET rx4%=lx4%+ml4|*sp4|*8+dx4|                    ! Rechts
  LET uy4%=oy4%+zl4|*16+dy4|                        ! Unten
  ' ............................................................................
  BOX lx4%,oy4%,rx4%,uy4%                           ! Rahmen Zeichnen
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE a_menue_anzeigen(ml5|,sx5|,sy5|,sp5|,zl5|,VAR a5$())
  t2t|=25
  ' ----------------------------------------------------------------------------
  ' In dieser Prozedur wird das MenÅ erst einmal nur angezeigt. WÑhlen kann
  ' man hier also noch nicht.
  ' ----------------------------------------------------------------------------
  LOCAL i5|         ! SpaltenzÑhler fÅr Eintragsspalten
  LOCAL j5|         ! ZeilenzÑhler  fÅr Eintragsszeilen
  LOCAL k5|         ! EintragszÑhler
  ' ............................................................................
  FOR i5|=1 TO sp5|         ! Alle Spalten durch
    FOR j5|=1 TO zl5|       ! Alle Zeilen durch
      INC k5|               ! NÑchster Eintrag; Ausgeben:
      PRINT AT(sx5|+(i5|-1)*ml5|,sy5|+j5|);a5$(k5|)
    NEXT j5|                ! NÑchste Zeile
  NEXT i5|                  ! NÑchste Spalte
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE a_eintrag_waehlen(wv!,ml|,sx|,sy|,sp|,zl|,VAR a$(),m|,w|)
  t2t|=26
  ' ----------------------------------------------------------------------------
  ' Diese Prozedur sorgt dafÅr, daû der MenÅeintrag, auf den die Maus gerade
  ' zeigt, invers dargestellt wird. Dabei wird natÅrlich der letzte Eintrag
  ' wieder normal dargestellt. Falls der erste öbergabeparameter wv!
  ' wahr ist, so wird der erste Eintrag beim Aufruf der Prozedur automatisch
  ' invers dargestellt, so daû die Maus gar nicht mehr gebraucht wird. Ein
  ' Druck auf die [Return]-Taste reicht, um den vorgeschlagenen Eintrag als
  ' gewÑhlt zu betrachten und die Prozedur zu verlassen. Statt der [Return]-
  ' Taste kann man auch die linke Maustaste zum entÅltigen wÑhlen benutzen.
  ' ----------------------------------------------------------------------------
  LOCAL mef!               ! Maus nicht auf MenÅeintrag ?
  LOCAL erst!              ! Erster Durchgang ?
  LOCAL bs!                ! Bildschirm schwarz gewesen ?
  LOCAL i|                 ! Hier steht die Eintragsnummer
  LOCAL t%                 ! Zeitmesser fÅr Bildschirmabschaltung
  LOCAL x%                 ! Maus-x-Koordinate
  LOCAL y%                 ! Maus-y-Koordinate
  LOCAL sm%                ! Die Spalte, auf die die Maus gerade zeigt
  LOCAL zm%                ! Die Zeile, auf die die Maus gerade zeigt
  LOCAL ms%                ! Speicher fÅr sm%
  LOCAL mz%                ! Speicher fÅr mz%
  LOCAL st%                ! Spaltenterm
  LOCAL zt%                ! Zeilenterm
  LOCAL mx%                ! Speicher fÅr x-Koordinate
  LOCAL my%                ! Speicher fÅr y-Koordinate
  LOCAL b$                 ! Negativspeicher fÅr Bildschirmrettung
  ' ............................................................................
  LET erst!=TRUE           ! Erster Durchgang
  ' ............................................................................
  REPEAT                   ! Mausabfrageschleife
    ' ..........................................................................
    LET mef!=FALSE         ! Maus ist erst mal evtl. auf MenÅeintrag
    ' ..........................................................................
    IF NOT bs!             ! F Bildschirm nicht schwarz:
      SHOWM                ! Mauszeiger bitte an und zwar immer !!!
    ENDIF                  ! d
    ' ..........................................................................
    LET x%=MOUSEX          ! Maus-x-Koordinate
    LET y%=MOUSEY          ! Maus-y-Koordinate
    ' ..........................................................................
    '                      ! S c h w a r z s c h a l t u n g :
    INC t%                 ! Zeitmesser raufsetzen
    IF t%=20000            ! F Zeit fÅr Bildschirmabschaltung:
      HIDEM                ! Maus weg
      IF bs!=FALSE         ! F Bildschirm bisher noch nicht schwarz
        SGET b$            ! Bildschirm retten
      ENDIF                ! d
      PBOX 0,0,g_bb%-1,g_bh%-1 ! Bildschirm schwarz
      LET bs!=TRUE         ! Bildschirm schwarz merken
      LET t%=0             ! Weiterlaufen ohne Overflow, deshalb null setzen
    ENDIF                  ! d
    IF (mx%<>x% OR my%<>y%) AND bs!=TRUE! F Mausbewegung + Blds.schwarz
      LET t%=0             ! Weiterlaufen ohne Overflow
      LET bs!=FALSE        ! Bildschirm nicht mehr schwarz
      SPUT b$              ! Bildschirm wieder herstellen
      SHOWM                ! Maus her
    ENDIF                  ! d
    LET mx%=MOUSEX         ! X-Koordinate der Maus merken
    LET my%=MOUSEY         ! Y-Koordinate der Maus merken
    ' ..........................................................................
    LET st%=x%-sx|*8                            ! Spaltenterm
    LET zt%=y%-sy|*16                           ! Zeilenterm
    ' Aktuelle Spalte (sm%) und Zeile (zm%) ermitteln:
    LET sm%=TRUNC((st%)/(ml|*8))+1              ! Akt.Spalte
    LET zm%=TRUNC((zt%)/16)+1                   ! Akt.Zeile
    ' ..........................................................................
    ' Beides negativ, f Maus 1 Sp. links oder 1 Zl. oberhalb des MenÅs:
    IF st%<0                                               ! nicht /0
      LET sm%=0                                            ! Simuliere Sp 0
      LET zm%=0                                            ! Simuliere Z 0
      LET mef!=TRUE                                        ! M. n. auf MenÅ
    ENDIF                                                  ! d
    IF zt%<0                                               ! nicht /0
      LET sm%=0                                            ! Simuliere Sp 0
      LET zm%=0                                            ! Simuliere Z 0
      LET mef!=TRUE                                        ! M. n. auf MenÅ
    ENDIF                                                  ! d
    ' ..........................................................................
    IF sm%>sp|             ! Falls Maus rechts der letzten Spalte
      LET sm%=0            ! Simuliere Spalte 0
      LET zm%=0            ! Simuliere Zeile 0
      LET mef!=TRUE        ! Maus ist nicht auf MenÅeintrag
    ENDIF                  ! d
    IF zm%>zl|             ! Falls Maus unterhalb der letzten Zeile
      LET sm%=0            ! Simuliere Spalte 0
      LET zm%=0            ! Simuliere Zeile 0
      LET mef!=TRUE        ! Maus ist nicht auf MenÅeintrag
    ENDIF                  ! d
    ' ..........................................................................
    '    PRINT AT(1,15);sm%,zm%,mef!
    IF erst!=TRUE                                ! F das 1. Mal hier
      LET erst!=FALSE                            ! Durchgangsnummer > 0
      IF wv!=TRUE                                ! MenÅvorschlag: ja
        LET sm%=1                                ! Simuliere Spalte 1
        LET zm%=1                                ! Simuliere Zeile 1
        LET ms%=sm%                              ! jetzige Spalte merken
        LET mz%=zm%                              ! jetzige Zeile merken
        PRINT CHR$(27);CHR$(112);                ! Invers ein
        LET i|=1                                 ! erste Eintragsnummer
        ' LET i|=(sm%-1)*zl|+zm%                 ! alte Eintragsnummer
        PRINT AT(sx|+(sm%-1)*ml|,sy|+zm%);a$(i|)
        PRINT CHR$(27);CHR$(113);                ! Invers aus
      ENDIF                                      ! d
    ELSE                                         ! Falls mind. 1mal durch
      IF mef!=FALSE                              ! Maus ist auf MenÅeintrag
        IF sm%<>ms% OR zm%<>mz%                  ! Falls Sp.od.Zle geÑnd.
          IF ms%<>0 AND mz%<>0                   ! Letzter Eintr. vorhanden
            PRINT CHR$(27);CHR$(113);            ! Invers aus
            LET i|=(ms%-1)*zl|+mz%! alte Eintragsnummer
            PRINT AT(sx|+(ms%-1)*ml|,sy|+mz%);a$(i|)
          ENDIF                                  ! d
          PRINT CHR$(27);CHR$(112);              ! Invers ein
          LET i|=(sm%-1)*zl|+zm%                 ! neue Eintragsnummer
          PRINT AT(sx|+(sm%-1)*ml|,sy|+zm%);a$(i|)
          PRINT CHR$(27);CHR$(113);              ! Invers aus
          LET ms%=sm%                            ! jetzige Spalte merken
          LET mz%=zm%                            ! jetzige Zeile merken
        ENDIF                                    ! EF Sp. oder Zl. geÑndert
      ENDIF                                      ! d
    ENDIF                                        ! d
    ' ..........................................................................
    LET m|=MOUSEK                                ! Maustaste retten
    EXIT IF mef!=TRUE AND m|                     ! Raus f MT neben MenÅfeld
    ' ..........................................................................
  UNTIL mef!=FALSE AND m| AND mz%<>0             ! Raus,f RMT auf MenÅfeld
  ' ............................................................................
  IF mef!=TRUE                                   ! F nicht auf MenÅfeld
    ' ..........................................................................
    LET w|=0                                     ! Kein Eintrag gewÑhlt
    ' ..........................................................................
  ELSE                                           ! F auf MenÅfeld
    ' ..........................................................................
    ' GewÑhlten Eintrag wieder normal darstellen:
    PRINT CHR$(27);CHR$(113);                    ! Invers aus
    LET i|=(ms%-1)*zl|+mz%                       ! alte Eintragsnummer
    PRINT AT(sx|+(ms%-1)*ml|,sy|+mz%);a$(i|)     ! normale Ausgabe
    ' ..........................................................................
    LET w|=i|           ! In den RÅckgabepar.die Nr.d.gewÑhlten Eintrags
    ' ..........................................................................
  ENDIF
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE a_eintraege_waehlen(wv!,ml|,sx|,sy|,sp|,zl|,VAR a$(),a!(),m|,w|)
  t2t|=26
  ' ----------------------------------------------------------------------------
  ' Diese Prozedur sorgt dafÅr, daû der MenÅeintrag, auf den die Maus gerade
  ' zeigt, invers dargestellt wird. Dabei wird natÅrlich der letzte Eintrag
  ' wieder normal dargestellt. Falls der erste öbergabeparameter wv!
  ' wahr ist, so wird der erste Eintrag beim Aufruf der Prozedur automatisch
  ' invers dargestellt, so daû die Maus gar nicht mehr gebraucht wird. Ein
  ' Druck auf die [Return]-Taste reicht, um den vorgeschlagenen Eintrag als
  ' gewÑhlt zu betrachten und die Prozedur zu verlassen. Statt der [Return]-
  ' Taste kann man auch die linke Maustaste zum entÅltigen WÑhlen benutzen.
  ' (Die 'Return'-Taste funktioniert jetzt nicht mehr!)
  ' ----------------------------------------------------------------------------
  LOCAL mef!               ! Maus nicht auf MenÅeintrag ?
  LOCAL erst!              ! Erster Durchgang ?
  LOCAL i|                 ! Hier steht die Eintragsnummer
  LOCAL x%                 ! Maus-x-Koordinate
  LOCAL y%                 ! Maus-y-Koordinate
  LOCAL sm%                ! Die Spalte, auf die die Maus gerade zeigt
  LOCAL zm%                ! Die Zeile, auf die die Maus gerade zeigt
  LOCAL ms%                ! Speicher fÅr sm%
  LOCAL mz%                ! Speicher fÅr mz%
  LOCAL st%                ! Spaltenterm
  LOCAL zt%                ! Zeilenterm
  ' ............................................................................
  LET erst!=TRUE           ! Erster Durchgang
  ' ............................................................................
  grosse_eingabeschleife:  ! Anfang der Hauptschleife
  ' ............................................................................
  REPEAT                   ! Mausabfrageschleife
    ' ..........................................................................
    LET mef!=FALSE         ! Maus ist erst mal evtl. auf MenÅeintrag
    ' ..........................................................................
    SHOWM                  ! Mauszeiger bitte an und zwar immer !!!
    ' ..........................................................................
    LET x%=MOUSEX          ! Maus-x-Koordinate
    LET y%=MOUSEY          ! Maus-y-Koordinate
    ' ..........................................................................
    LET st%=x%-sx|*8                            ! Spaltenterm
    LET zt%=y%-sy|*16                           ! Zeilenterm
    ' Aktuelle Spalte (sm%) und Zeile (zm%) ermitteln:
    LET sm%=TRUNC((st%)/(ml|*8))+1              ! Akt.Spalte
    LET zm%=TRUNC((zt%)/16)+1                   ! Akt.Zeile
    ' ..........................................................................
    ' Beides negativ, f Maus 1 Sp. links oder 1 Zl. oberhalb des MenÅs:
    IF st%<0                                               ! nicht /0
      LET sm%=0                                            ! Simuliere Sp 0
      LET zm%=0                                            ! Simuliere Z 0
      LET mef!=TRUE                                        ! M. n. auf MenÅ
    ENDIF                                                  ! d
    IF zt%<0                                               ! nicht /0
      LET sm%=0                                            ! Simuliere Sp 0
      LET zm%=0                                            ! Simuliere Z 0
      LET mef!=TRUE                                        ! M. n. auf MenÅ
    ENDIF                                                  ! d
    ' ..........................................................................
    IF sm%>sp|             ! Falls Maus rechts der letzten Spalte
      LET sm%=0            ! Simuliere Spalte 0
      LET zm%=0            ! Simuliere Zeile 0
      LET mef!=TRUE        ! Maus ist nicht auf MenÅeintrag
    ENDIF                  ! d
    IF zm%>zl|             ! Falls Maus unterhalb der letzten Zeile
      LET sm%=0            ! Simuliere Spalte 0
      LET zm%=0            ! Simuliere Zeile 0
      LET mef!=TRUE        ! Maus ist nicht auf MenÅeintrag
    ENDIF                  ! d
    ' ..........................................................................
    '    PRINT AT(1,15);sm%,zm%,mef!
    IF erst!=TRUE                                ! F das 1. Mal hier
      LET erst!=FALSE                            ! Durchgangsnummer > 0
      IF wv!=TRUE                                ! MenÅvorschlag: ja
        LET sm%=1                                ! Simuliere Spalte 1
        LET zm%=1                                ! Simuliere Zeile 1
        LET ms%=sm%                              ! jetzige Spalte merken
        LET mz%=zm%                              ! jetzige Zeile merken
        PRINT CHR$(27);CHR$(112);                ! Invers ein
        LET i|=1                                 ! erste Eintragsnummer
        ' LET i|=(sm%-1)*zl|+zm%                 ! alte Eintragsnummer
        PRINT AT(sx|+(sm%-1)*ml|,sy|+zm%);a$(i|) ! Eintrag ausgeben
        PRINT CHR$(27);CHR$(113);                ! Invers aus
      ENDIF                                      ! d
    ELSE                                         ! Falls mind. 1mal durch
      IF mef!=FALSE                              ! Maus ist auf MenÅeintrag
        IF sm%<>ms% OR zm%<>mz%                  ! Falls Sp.od.Zle geÑnd.
          IF ms%<>0 AND mz%<>0                   ! Letzter Eintr. vorhanden
            PRINT CHR$(27);CHR$(113);            ! Invers aus
            LET i|=(ms%-1)*zl|+mz%               ! alte Eintragsnummer
            IF a!(i|)=FALSE                      ! F nicht gewÑhlt:
              PRINT AT(sx|+(ms%-1)*ml|,sy|+mz%);a$(i|)  ! Eintrag ausgeben
            ENDIF                                ! d
          ENDIF                                  ! d
          PRINT CHR$(27);CHR$(112);              ! Invers ein
          LET i|=(sm%-1)*zl|+zm%                 ! neue Eintragsnummer
          PRINT AT(sx|+(sm%-1)*ml|,sy|+zm%);a$(i|)
          PRINT CHR$(27);CHR$(113);              ! Invers aus
          LET ms%=sm%                            ! jetzige Spalte merken
          LET mz%=zm%                            ! jetzige Zeile merken
        ENDIF                                    ! EF Sp. oder Zl. geÑndert
      ENDIF                                      ! d
    ENDIF                                        ! d
    ' ..........................................................................
    LET m|=MOUSEK                                ! Maustaste retten
    IF m|=2                                      ! F rechte Maustaste:
      LET mef!=TRUE                              ! Auch raus
    ENDIF                                        ! d
    EXIT IF mef!=TRUE AND m|                     ! Raus f MT neben MenÅfeld
    ' ..........................................................................
  UNTIL mef!=FALSE AND m| AND mz%<>0             ! Raus,f RMT auf MenÅfeld
  ' ............................................................................
  IF mef!=FALSE                                  ! F auf MenÅfeld
    ' ..........................................................................
    ' GewÑhlten Eintrag merken, d.h. in a!() als gewÑhlt/nicht gew. verzeichnen:
    ' ..........................................................................
    LET i|=(ms%-1)*zl|+mz%                       ! alte Eintragsnummer
    ' ..........................................................................
    IF a!(i|)=TRUE                               ! F bereits gewÑhlt:
      LET a!(i|)=FALSE                           ! Code fÅr 'Eintrag nicht gew.'
      PRINT CHR$(27);CHR$(113);                  ! Invers aus
      PRINT AT(sx|+(ms%-1)*ml|,sy|+mz%);a$(i|)   ! Eintrag ausgeben
    ELSE                                         ! F noch nicht gewÑhlt:
      LET a!(i|)=TRUE                            ! Code fÅr 'Eintrag gewÑhlt'
      PRINT CHR$(27);CHR$(112);                  ! Invers ein
      PRINT AT(sx|+(ms%-1)*ml|,sy|+mz%);a$(i|)   ! Eintrag ausgeben
      LET w|=1                                   ! etwas gewÑhlt
    ENDIF                                        ! EFU bereits gewÑhlt/nicht gew
    ' ..........................................................................
    REPEAT            ! Warteschleife fÅr Mauseingabe:
    UNTIL MOUSEK=0    ! Erst Raus,wenn Maus nix mehr meldet,also Puffer leer
    ' ..........................................................................
    GOTO grosse_eingabeschleife                  ! geh zum Anfang der Hauptschl.
    ' ..........................................................................
  ENDIF                                          ! d
  PRINT CHR$(27);CHR$(113);                      ! Invers aus
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE a_eintraginput(ml7|,di7|,sx7|,sy7|,sp7|,zl7|,m7|,w7|,VAR a7$())
  t2t|=27
  ' ----------------------------------------------------------------------------
  ' Hier kann man in einem MenÅeintrag etwas eingeben.
  ' ----------------------------------------------------------------------------
  LOCAL si7|                ! Spalte fÅr Input
  LOCAL zi7|                ! Zeile fÅr Input
  ' ............................................................................
  '  si7|=TRUNC(w7|/sp7|)+1                       ! Spalte f.Input
  '  PRINT AT(1,1);"w7|,sp7|,si7|,zl7|"           ! Zeile f. Input
  '  PRINT AT(1,2);w7|,sp7|,si7|,zl7|             ! Zeile f. Input
  '  zi7|=w7|-(si7|-1)*zl7|                       ! Zeile f. Input
  ' ..........................................................................
  LET x7%=MOUSEX                                  ! Maus-x-Koordinate
  LET y7%=MOUSEY                                  ! Maus-y-Koordinate
  LET st7%=x7%-sx7|*8                             ! Spaltenterm
  LET zt7%=y7%-sy7|*16                            ! Zeilenterm
  ' Aktuelle Spalte (sm7%) und Zeile (zm7%) ermitteln:
  LET sm7%=TRUNC((st7%)/(ml7|*8))+1               ! Akt.Spalte
  LET zm7%=TRUNC((zt7%)/16)+1                     ! Akt.Zeile
  LET si7|=sm7%                                   ! Var-Type Ñndern
  LET zi7|=zm7%                                   ! Var-Type Ñndern
  ' ............................................................................
  '  PRINT AT(sx7|+(si7|-1)*ml7|-1,sy7|+zi7|);    ! Positionieren
  ' ............................................................................
  LET a$=a7$(w7|)                                 ! Zwischenspeicher
  @a_input(sx7|+(si7|-1)*ml7|,sy7|+zi7|,ml7|-1,m7|,a$)! Eingabe
  LET a7$(w7|)=a$                                 ! RÅckgabe
  '  FORM INPUT ml7|-1 AS a7$(w7|)                ! Eingabe
  ' ............................................................................
  ' Alle Strings wurden, um das Input Åberhaupt zu ermîglichen, um di7|
  ' Spaces am rechten Rand erweitert, das muû auch mit dem geÑngerten
  ' String geschehen. Das passiert in der folgenden Zeile:
  LET a7$(w7|)=a7$(w7|)+SPACE$(di7|)
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE a_input(sp|,zl|,l|,m|,VAR a$)
  ' ----------------------------------------------------------------------------
  ' sp|                                 ! Startspalte der Eingabe
  ' zl|                                 ! Startzeile der Eingabe
  ' l|                                  ! SollÑnge der Eingabe
  ' a$                                  ! Eingabestring,evtl. ist Vorschlag drin
  LOCAL z|                              ! Ascii-Speicher fÅr eingegebenes Zeichn
  LOCAL al|                             ! Aktuelle LÑnge des Eingabestrings
  ' ............................................................................
  LET a$=LEFT$(a$,l|)                   ! öberflÅssiges am Vorschlagstring weg.
  ' ............................................................................
  PRINT AT(sp|,zl|);a$;CHR$(27);CHR$(112);" ";CHR$(27);CHR$(113); ! Cursor ein
  ' ............................................................................
  HIDEM                   ! Mauspfeil weg
  REPEAT                  ! Warteschleife fÅr Mauseingabe:
  UNTIL MOUSEK=0          ! Erst Raus,wenn Maus nix mehr meldet,also Puffer leer
  ' ............................................................................
  DO                                    ! Hauptschleifenanfang
    ' ..........................................................................
    REPEAT                              ! Eingabeschleife
      LET z|=ASC(INKEY$)                ! Zeichen von der Tastatur lesen
      LET m|=MOUSEK                     ! Maustaste retten
      IF MOUSEK                         ! F Maustaste gedrÅckt
        LET z|=13                       ! Tu so, als sei 'Return'-Taste gedrÅckt
      ENDIF                             ! d
    UNTIL z|=8 OR z|=13 OR z|>31        ! Raus f Zeichen eingegeben
    LET al|=LEN(a$)                     ! Aktuelle LÑnge abspeichern
    EXIT IF z|=13                       ! Raus f 'RETURN'-Taste gedrÅckt
    ' ..........................................................................
    IF z|=8 AND al|>0                   ! F 'BACKSPACE'-Taste und String<>leer
      LET a$=LEFT$(a$,al|-1)            ! Backspace ausfÅhren
      DEC al|                           ! Aktuelle StringlÑnge aktualisieren
      PRINT AT(sp|,zl|);a$;CHR$(27);CHR$(112);" ";CHR$(27);CHR$(113);! Zchn raus
      IF al|<l|                         ! F akt. LÑnge < SollÑnge
        PRINT SPACE$(l|-al|)            ! rechts Vom Cursor weiû
      ENDIF                             ! d
    ELSE IF al|<l| AND z|>31            ! F Normale Taste und kleiner MaxlÑnge
      LET a$=a$+CHR$(z|)                ! Eingabestring erweitern
      LET a$=UPPER$(a$)                 ! Nur Groûbuchstaben
      INC al|                           ! Aktuelle StringlÑnge aktualisieren
      PRINT AT(sp|,zl|);a$;CHR$(27);CHR$(112);" ";CHR$(27);CHR$(113);! Zchn raus
      IF al|<l|                         ! F akt. LÑnge < SollÑnge
        PRINT SPACE$(l|-al|)            ! rechts Vom Cursor weiû
      ENDIF                             ! d
    ENDIF                               ! d
    ' ..........................................................................
  LOOP                                  ! Hauptlschleifenende
  ' ............................................................................
  LET a$=a$+SPACE$(l|-al|)              ! Rechts mit Spaces auffÅllen
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE a_menueeintraege_minus_di8(sp8|,zl8|,ml8|,di8|,VAR a8$())
  ' ----------------------------------------------------------------------------
  ' Hier wird die zusÑtzliche LÑnge fÅr Input wieder abgezogen
  ' ----------------------------------------------------------------------------
  LOCAL i8|                         ! ZÑhler fÅr EintrÑge
  ' ............................................................................
  LET di8|=1                        ! FÅr Input zusÑtliche di8| Spaces
  ' ............................................................................
  FOR i8|=1 TO sp8|*zl8|            ! Alle EintrÑge durch
    LET a8$(i8|)=LEFT$(a8$(i8|),ml8|-di8|)  ! InputlÑngenzugabe wieder abziehen
  NEXT i8|                          ! nÑchster Eintrag
  ' ----------------------------------------------------------------------------
RETURN
' ##############################################################################
'  D a t e n
' ##############################################################################
> PROCEDURE 0_menuedaten
  ' ----------------------------------------------------------------------------
  hauptmenue:
  DATA  StÅckmenÅ
  DATA  Hauptfile
  DATA  BlockmenÅ
  DATA  Parameter
  DATA  MenÅ-Exit
  DATA ##
  ' ............................................................................
  stueckmenue:
  DATA StÅck auf Disk speichern
  DATA StÅck von Disk laden
  DATA ----------------------------
  DATA StÅck in Hauptfile speichern
  DATA StÅck von Hauptfile laden
  DATA ----------------------------
  DATA bestimmte StÅcke drucken
  DATA bestimmte StÅcke spielen
  DATA ##
  ' ............................................................................
  hauptfile:
  DATA Hauptfile neuanlegen
  DATA Hauptfile neu laden
  DATA Hauptfile abspeichern
  DATA ----------------------------
  DATA beliebiges Diskfile lîschen
  DATA Diskfile umbenennen
  DATA ----------------------------
  DATA Inhaltsverzeichnis drucken
  DATA Ab x alle StÅcke drucken
  DATA Ab x alle StÅcke spielen
  DATA ##
  ' ............................................................................
  blockmenue:
  DATA Anfang
  DATA Ende
  DATA Marken lîschen
  DATA ------------------
  DATA kopieren
  DATA doppelt so schnell
  DATA halb so schnell
  DATA transponieren
  DATA ------------------
  DATA lîschen
  DATA ##
  ' ............................................................................
  parameter:
  DATA Abspielgeschwindigkeit
  DATA Pause zw. den StÅcken
  DATA Midi ein/aus schalten
  DATA ##
  ' ............................................................................
  menue_exit:
  DATA Eingabe fortsetzen
  DATA ------------------
  DATA Edit
  DATA ------------------
  DATA Quit
  DATA ##
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 0_tonleiterdaten
  tonleiter:
  DATA C,#C,D,#D,E,F,#F,G,#G,A,#A,H,PP
RETURN
> PROCEDURE 0_hilfstext_mit_befehlstabelle
  ' ----------------------------------------------------------------------------
  ' Hier befindet sich bisher nur der Hilfstext, den man Åber die Help-Taste
  ' erreichen kann.
  ' ----------------------------------------------------------------------------
  '
  helptext:
  '
  DATA Prg zum Schreiben von FlîtenstÅcken 'NOTEDITA.GFA' 1.0 |
  DATA
  DATA
  DATA
  DATA
  DATA
  DATA
  DATA
  DATA
  DATA
  DATA ################################################################################
  DATA         | linksoben  | Notentaste | rechtsoben | Notentext  | Cursor   |
  DATA
  DATA         |--------------------------------------------------------------|
  DATA     LMT | Pause      | 1/8 Note   | Pause      | Cursorpos. | Taktstr. |
  DATA         |------------+------------+------------+------------+----------|
  DATA     RMT | HauptmenÅ  | Nur Ton    | Backspace  | Abspielen  | FÑhnchen |
  DATA         |--------------------------------------------------------------|
  DATA ################################################################################
  DATA      'LMT'=linke Maustaste /  'RMT'=rechte Maustaste / 'Taktstr.'=Taktstrich
  DATA ################################################################################
  DATA ############ !!!! Der Verkauf des Programms ist nicht erlaubt  !!!! ############
  DATA ############ Das Programm darf nur unverÑndert weitergegeben werden ############
  DATA ################################################################################
  DATA  ZurÅck zum Editor: Maustaste        /        Autor: M.Mittelmaier   Sommer '89
  DATA **
  '
  '
  '
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 0_frequenzdaten
  frequenzen:
  ' ----------------------------------------------------------------------------
  ' Erst die Halbtonfrequenzen:
  ' ----------------------------------------------------------------------------
  '             c1
  DATA 262
  '             cis1
  DATA 275
  '             d1
  DATA 294
  '             dis1
  DATA 312
  '             e1
  DATA 330
  '             f1
  DATA 350
  '             fis1
  DATA 371
  '             g1
  DATA 393
  '             gis1
  DATA 415
  '             a1
  DATA 440
  '             ais1
  DATA 466
  '             h1
  DATA 495
  '             c2
  DATA 526
  '             cis2
  DATA 558
  '             d2
  DATA 591
  '             dis2
  DATA 625
  '             e2
  DATA 662
  '             f2
  DATA 701
  '             fis2
  DATA 744
  '             g2
  DATA 787
  '             gis2
  DATA 838
  '             a2
  DATA 880
  '             ais2
  DATA 933
  '             h2
  DATA 990
  '             c3
  DATA 1050
  ' ----------------------------------------------------------------------------
  ' Nun die Vierteltonfrequenzen:
  ' ----------------------------------------------------------------------------
  '             c1       + Viertelton
  DATA 268
  '             cis1     + Viertelton
  DATA 282
  '             d1       + Viertelton
  DATA 303
  '             dis1     + Viertelton
  DATA 321
  '             e1       + Viertelton
  DATA 340
  '             f1       + Viertelton
  DATA 360
  '             fis1     + Viertelton
  DATA 382
  '             g1       + Viertelton
  DATA 404
  '             gis1     + Viertelton
  DATA 427
  '             a1       + Viertelton
  DATA 453
  '             ais1     + Viertelton
  DATA 480
  '             h1       + Viertelton
  DATA 510
  '             c2       + Viertelton
  DATA 542
  '             cis2     + Viertelton
  DATA 574
  '             d2       + Viertelton
  DATA 608
  '             dis2     + Viertelton
  DATA 643
  '             e2       + Viertelton
  DATA 681
  '             f2       + Viertelton
  DATA 722
  '             fis2     + Viertelton
  DATA 765
  '             g2       + Viertelton
  DATA 809
  '             gis2     + Viertelton
  DATA 856
  '             a2       + Viertelton
  DATA 906
  '             ais2     + Viertelton
  DATA 961
  '             h2       + Viertelton
  DATA 1020
  '             c3       + Viertelton
  DATA 1082
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 0_daten_fuer_notenschluessel
  ' ----------------------------------------------------------------------------
  notenschluessel:
  DATA 170,169,170,168,167,168,167,169,168,171
  DATA 173,172,173,170,173,167,170,166,169,165
  DATA 167,165,166,165,164,170,165,173,169,175
  DATA 173,175,176,173,177,169,177,166,168,133
  DATA 167,120,172,116,176,115,176,115,178,117
  DATA 180,118,181,122,181,126,180,130,179,133
  DATA 165,146,164,151,164,158,169,160,176,161
  DATA 180,159,180,153,178,149,173,148,168,148
  DATA 167,149,167,154,172,157,174,157,178,157
  DATA -1,-1
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 0_daten_fuer_programmname
  ' ----------------------------------------------------------------------------
  programmname:
  DATA 451,13,452,9,457,4,464,4,467,8
  DATA 467,13,477,3,467,13,478,13,488,7
  DATA 481,11,485,13,498,13,499,8,490,4
  DATA 487,6,489,7,487,9,497,8,504,11
  DATA 517,4,518,12,518,14,515,8,515,8
  DATA 518,9,521,10,525,10,518,10,513,9
  DATA 513,9,511,9,519,14,526,15,537,13
  DATA 540,7,534,6,532,9,541,14,547,14
  DATA 559,9,552,10,552,12,556,14,562,15
  DATA 565,11,559,8,564,10,568,3,565,14
  DATA 565,14,571,13,578,9,579,6,577,4
  DATA 577,4,579,4,580,4,581,4,583,5
  DATA 584,5,580,5,579,5,579,5,579,8
  DATA 579,9,579,11,582,13,586,13,595,12
  DATA 599,6,601,3,601,7,601,13,601,13
  DATA 601,13,602,11,602,8,599,7,596,9
  DATA 596,9,599,8,603,8,606,7,597,6
  DATA 595,6,601,12,603,14,609,13,617,8
  DATA 622,6,629,6,620,6,616,10,616,11
  DATA 621,13,627,12,629,7,629,11,631,13
  DATA 632,13,631,13
  DATA -1,-1
  ' ----------------------------------------------------------------------------
RETURN
' ##############################################################################
'  D o k u m e n t a t i o n :
' ##############################################################################
> PROCEDURE 0_konzept_fuer_das_aussehen_einer_einzelnen_note
  ' ----------------------------------------------------------------------------
  '       Muster einer Note mit Notenhals nach unten:
  ' ----------------------------------------------------------------------------
  '
  '
  '
  '
  '            1
  '    0123456789012345 = n_nb| Notenbsp.: oberes cis (ex. nicht, nur bis c):
  '                          Das cis ist mit der vorherigen Note gebunden,
  '                          betont,erhîht (nicht erhîht wÑre es c) & 1/32 lang.
  '
  '
  '    #############  <-- Obereste Begrenzungslinie
  ' 0   1             <-- 1. Punkt im Notenrechteck=g_y%(?)
  ' 1   2
  ' 2   3
  ' 3   4
  ' 4   5
  ' 5 ++6+1
  ' 6   1
  ' 7   2
  ' 8   3
  ' 9   4
  ' 10  5   ######
  ' 1 ++6+2 #    #    <-- Gebunden mit vorheriger Note ( Box: gd|,gh|,gx|,gy| )
  ' 2   1   ######
  ' 3   2
  ' 4   3
  ' 5   4   ######    <-- Notenkopf ( Pbox: kb|, kh|, kx|, ky| )
  ' 6   5   ######
  ' 7 ++6+3#########  <-- Hilfslinie a2 (line: ha2x|, ha2y|, hd| )
  ' 8   1   ######
  ' 9   2   ######
  ' 20  3  #########  <-- Hilfslinie h2 (line: hh2x|, hh2y|, hd| )
  ' 1   4   #
  ' 2   5   ####      <-- Betonungszeichen ( Pbox: bb|, bh|, bx|, by| )
  ' 3 ++6+4#########  <-- Hilfslinie c3 (line: hc3x|, hc3y|, hd| )
  ' 4   1   ####
  ' 5   2   #         <-- Notenhals ( Line: lx|, lsy|, ley|
  ' 6   3   ######
  ' 7   4   ##  ##     <-- Notenhîhen-Info: Kreuz ( 1.Box: xl|,hb|, hh|, hy|
  ' 8   5   ##  ##                                  2.Box: xr|, "    "    "  )
  ' 9 ++6+5 ##  ##     <-- 1.Notenlinie ( n1y| bei: '1_notenlinien'
  ' 30  1   ######
  ' 1   2   #
  ' 2   3   #   ##
  ' 3   4   #  ##     <-- 32-tel-FÑhnchen ( Line: ax1|,a32y1|,ax2|,a32y2| )
  ' 4   5   # ##      <-- 32-tel-FÑhnchen ( Line: ax1|,b32y1|,bx2|,a32y2| )
  ' 5 ++6+6 ###
  ' 6   1   ##  ##
  ' 7   2   #  ##     <-- 16-tel-FÑhnchen ( Line: ax1|,a16y1|,ax2|,a16y2 )
  ' 8   3   # ##      <-- 16-tel-FÑhnchen ( Line: ax1|,b16y1|,bx2|,a16y2 )
  ' 9   4   ###
  ' 40  5   ##  ##
  ' 1 ++6+7 #  ##     <-- 8-tel-FÑhnchen  ( Line ax1|,a8y1|,ax2|,a8y2 )
  ' 2   1   # ##      <-- 8-tel-FÑhnchen  ( Line ax1|,b8y1|,bx2|,a8y2 )
  ' 3   2   ###
  ' 4   3   ##
  ' 5   4
  ' 6   5
  ' 7 ++6+8      #
  ' 8   1        #
  ' 9   2        #
  ' 50  3        #    <-- Notenhals vom c1
  ' 1   4        #
  ' 2   5        #
  ' 3 ++6+9      #
  ' 4   1        #
  ' 5   2        #
  ' 6   3        #
  ' 7   4   ######
  ' 8   5   ######
  ' 9 ++6+1#########  <-- Hilfslinie c1 (line: hc1x|, hc1y|, hd| ) .
  ' 60  1   ######
  ' 1   2   ######
  ' 2   3
  ' 3   4             <-- falscher Anfang vom gespiegelten Gebundenzei-
  ' 4   5   ######        chen bei '3_gebundenzeichen()'. (*):s.Zeile 66.
  ' 5 ++6+11#    #
  ' 6   1   ######    <-- richtiger Anfang fÅr Gebundenzeichen vom c1. Diff. v.
  ' 7   2                 falschen Anfang bei (*) wird bei '2_noten_foto()' ge-
  ' 8   3                 braucht: ( rga%=-3 ):
  ' 9   4
  ' 70  5
  ' 1 ++6+12
  ' 2 ################# <-- unterste Begrenzungslinie
  ' 3      <-- 1.Pkt d.benachbarten,unt.Notenbereichs=g_y%(?')=g_y%(?)+g_nzlh|
  '            g_nzlh|=73
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 0_konzept_fuer_die_notendarstellung_im_edr
  ' ----------------------------------------------------------------------------
  ' 0.) Der Bildschirm wird unterhalb der Klaviatur in 5 Notenzeilen und 80
  '     Notenspalten aufgebaut. Das Konzept der Notendarstellung soll nun so
  '     aussehen, daû man nur noch die gewÅnschte Notenposition, also eine
  '     dieser Notenspalten bzw. -zeilen angeben muû und die gewÅnschten Eigen-
  '     schaften, wie Hîhe, LÑnge, usw.
  ' 1.) Alle mîglichen Notenformen werden gezeichnet und fotografiert, d.h.
  '     im Array 'g_nb$()' als einzelne Bilder abgespeichert. Die Argumente
  '     dieses Arrays entsprechen den Eigenschaften der entsprechenden Note:
  '     Im 1. Argument steht die Notenhîhe, im 2. die LÑnge dh. die FÑhnchenzahl
  '     im 3. ob gebunden (=1) oder nicht(=0) im 4. ob betont oder nicht.
  ' 2.) Die 'Fotokamera' wird so plaziert, daû spÑter nur noch Spalte und Zeile
  '     einer Note als Argumente fÅr den Put-Befehl zum Projezieren der Photos
  '     angegeben werden mÅssen.
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 0_konzept_zur_speicherung_der_noten
  ' ----------------------------------------------------------------------------
  ' 1.) Wenn man das Programm startet und erst einmal ein neues NotenstÅck
  '     schreibt, werden dessen Noten zunÑchst nur im 'g_n$()'-Array abgelegt.
  ' 2.) Speichert man dieses NotenstÅck nun ab, so wird es nicht als einzelnes
  '     File auf Diskette geschrieben, sondern in das sogenannte 'Hauptfile'
  '     eingebaut. In diesem Hauptfile haben 160 NotenstÅcke zu je 200 Noten
  '     Platz. Beim Speichern und Laden, kann man nun aus diesen 160 StÅcken
  '     eins auswÑhlen, das Åberschrieben bzw. in den g_n$()-Array zur aktuellen
  '     Bearbeitung geladen werden soll. Dabei sind StÅcke mit dem Namen
  '     '________' leer.
  '     Gibt man beim Abspeichern den Leerstring '________'
  '     ein, so wird das entsprechende StÅck im Hauptfile gelîscht.
  ' 3.) Man kann dieses Hauptfile Åber die Prozedur 'ende_file_drck' auf eine
  '     andere Diskette kopieren, bzw. ein neues auf einer Diskette anlegen,
  '     auf welcher sich noch kein Hauptfile befindet.
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 0_zeichenprogramm
  ' ----------------------------------------------------------------------------
  ' Mit diesem Kleinen Programm wurde der NotenschlÅssel fÅr die Druckfunktion
  ' gezeichnet. DafÅr muû es an den Programmanfang, genau hinter der Zeile
  ' '@0_programmbild_malen' verschoben werden. Verwende dazu die Zeile:
  '  @0_zeichnenprogramm
  ' Die durch die linke Maustaste
  ' markierten Punkte werden dann in Form von Datazeilen auf Diskette ge-
  ' speichert und kînnen durch die Funktion 'Merge' vom Editor aus in den
  ' Programmtext aufgenommen werden.
  ' Die Prozedur, die die in den Programmtext bereits aufgenommenen Data-
  ' zeilen verwertet, d.h.`das Bild reproduziert, hat in 'NOTEDITA' den
  ' Namen '1_notenschluessel'.
  ' ............................................................................
  LOCAL m|                      ! Maustaste
  LOCAL r|                      ! MenÅauswahl
  LOCAL a%                      ! Hîchstanzahl aller Punkte
  LOCAL i%                      ! Punkt-/Zeilen-zÑhler
  LOCAL j%                      ! SpaltenzÑhler
  ' ............................................................................
  '                             ! Alles ab hier muû hinter '@0_progra.'
  nochmal_zeichnen:             ! Label
  '  SPUT g_lb$                    ! Lîschbild
  '                             ! Bilderrahmen:
  BOX g_x%(51),g_y%(51),g_x%(51)+2*g_nb|-1,g_y%(51)+g_nzlh|-2
  LET a%=100                    ! Hîchstens hundert Punkte (auch mehr mîglich)
  DIM x%(a%),y%(a%)             ! Koordinatenarray dimensionieren
  LET x%(0)=g_x%(51)            ! x-Startwert festlegen
  LET y%(0)=g_y%(51)            ! y-Startwert festlegen
  REPEAT                        ! Hauptzeichenschleife
    REPEAT                      ! Schleife, um Mauspuffer
    UNTIL MOUSEK=0              ! zu leeren
    REPEAT                      ! Warten auf
      LET m|=MOUSEK             ! Mausklick
    UNTIL m|                    ! d
    PRINT AT(1,1);"i%='";i%;"'" ! d
    INC i%                      ! PunktzÑhler um eins erhîhen
    LET x%(i%)=MOUSEX           ! x-Koordinate vom akt. Pkt. festlegen
    LET y%(i%)=MOUSEY           ! y-Koordinate vom akt. Pkt. festlegen
    IF i%>1                     ! f schon ein Punkt da:
      LINE x%(i%-1),y%(i%-1),x%(i%),y%(i%)  ! Linie vom alten zum akt Punkt
    ENDIF                       ! d
  UNTIL m|=2                    ! Raus ausZeichenschleife,falls rechte Maustaste
  ' ............................................................................
  @a_alert("Nochmal zeichnen?/Ja|Abspeichern",r|) ! d
  IF r|=1                       ! f ja gewÑhlt:
    CLS                         ! Bildschirm lîschen
    LET i%=0                    ! PunktzÑhler null
    ERASE x%(),y%()             ! Punktkoordinatenarrays lîschen
    GOTO nochmal_zeichnen       ! von neuem Zeichnen
  ENDIF                         ! d
  LET a%=i%                     ! Hîchstanzahl der Punkte neu setzen
  ' ............................................................................
  OPEN "O",#1,"NOTENS.LST"      ! File auf Diskette zum schreiben îffnen
  FOR i%=1 TO a%                ! alle Punkte durch
    IF FRAC(j%/5)=0             ! f neuer Zeilenanfang ansteht:
      LET j%=1                  ! SpaltenzÑhler initialisieren
      PRINT #1,                 ! neue Zeile
      PRINT #1,"DATA ";         ! 'DATA' an den Anfang der neuen Zeile
    ELSE                        ! f mitten in Zeile
      INC j%                    ! nur SpaltenzÑhler um eins erhîhen
    ENDIF                       ! d
    IF i%<a% AND j%<5           ! f noch nicht zu Ende und in Zeilenmitte:
      PRINT #1,x%(i%);",";y%(i%);","; ! Koordinaten raus, mit Komma am Schluû
    ELSE                        ! f am Ende oder am Zeilenende
      PRINT #1,x%(i%);",";y%(i%); ! Koordinaten raus, ohne Komma am Schluû
    ENDIF                       ! d
  NEXT i%                       ! nÑchster Punkt
  PRINT #1                      ! neue Zeile
  PRINT #1,"DATA -1,-1"         ! Schluûdaten
  CLOSE #1                      ! File auf Diskette schlieûen
  ' ............................................................................
  EDIT                          ! ZurÅck in den Editor
  ' ----------------------------------------------------------------------------
RETURN
> PROCEDURE 0_ausfuehrliche_befehlsdokumentation_fuer_noteneingabe
  ' ----------------------------------------------------------------------------
  ' Achtung!  Erst Zeilen-, dann Spaltennummer ! ! !
  '
  '
  '              1.Spalte:    2.Spalte:    3.Spalte:    4.Spalte:    5.Spalte:
  '
  '            | linksoben  | Notentaste | rechtsoben | Notentext  | Cursor   |
  '
  '            |--------------------------------------------------------------|
  ' 1  LMT     | Pause      | 1/8 Note   | Pause      | Cursorpos. | Taktstr. |
  '            |------------+------------+------------+------------+----------|
  ' 2  RMT     | HauptmenÅ  | Nur Ton    | Backspace  | Abspielen  | FÑhnchen |
  '            |--------------------------------------------------------------|
  '
  '
  ' ----------------------------------------------------------------------------
  '
  '
  '   Jetzt die 1. Zeile
  '
  '
  ' ----------------------------------------------------------------------------
  '
  '
  '
  ' * S p a l t e  1  : 'l. Pausentaste'    Zeile1: 'LMT'
  '   (linke Pausentaste auf Klaviatur und linke Maustaste)
  '   'Pause':       Funktioniert, wenn kein Blockbereich definiert ist:
  '                  Es wird eine 1/8-tel-Pause dargestellt
  '                  Kann auch mit der Space-Taste produziert werden.
  ' PROCEDURE 1_write(t|,x%)        !_:
  ' ............................................................................
  ' * S p a l t e  2  : 'Notentaste'        Zeile1: 'LMT'
  '   (Notentaste auf Klaviatur und linke Maustaste)
  ' PROCEDURE 1_write(t|,x%)        !_:
  '   '1/8-Note':    Eine der Klaviaturtaste entspr. 1/8-Note wird dargestellt.
  '                  Es handelt sich um einen normalen Halbton.
  '                  Bei MIDI muû noch die 'Alternate'-Taste dazu gedrÅckt wer-
  '                  den.
  ' ............................................................................
  ' * S p a l t e  3  : 'r. Pausentaste'    Zeile1: 'LMT'
  '   (rechte Pausentaste auf Klaviatur und linke Maustaste)
  '   'Pause':       Funktioniert, wenn kein Blockbereich definiert ist:
  '                  Es wird eine 1/8-tel-Pause dargestellt
  '                  Kann auch mit der Space-Taste produziert werden.
  ' PROCEDURE 1_write(t|,x%)        !_:
  ' ............................................................................
  ' * S p a l t e  4  : 'Notentext'         Zeile1: 'LMT'
  '   (Mauspfeil auf Notentext und linke Maustaste)
  ' PROCEDURE 1_neu_cpos(x%,y%)     !_:
  ' Falls Cursor nicht auf Note unter Mauspfeil:
  '   'Cursorpos.': Der Cusor wird auf die Note unter dem Mauspfeil gesetzt.
  ' ............................................................................
  ' * S p a l t e  5  : 'Cursor'         Zeile1: 'LMT'
  ' PROCEDURE 2_takt_setzen   !_:
  ' Falls Cursor auf Note unter Mauspfeil:
  '   'Taktstr.':     Hier gesellt sich zur Note ein Taktstrich, falls vorher
  '                   noch keiner da war. War bereits einer da, so wird er ge-
  '                   lîscht.
  '
  '
  ' ----------------------------------------------------------------------------
  '
  '
  '   Jetzt die 2. Zeile
  '
  '
  ' ----------------------------------------------------------------------------
  '
  '
  ' ............................................................................
  ' * S p a l t e  1  : 'l. Pausentaste'    Zeile2: 'RMT'
  '   (linke Pausentaste auf Klaviatur und rechte Maustaste)
  ' PROCEDURE 0_hauptmenue        !_:
  '    'HauptmenÅ':  Hier kommt man ins HauptmenÅ
  '                  Kann auch mit der 'Esc'-Taste erreicht werden.
  ' ............................................................................
  ' * S p a l t e  2  : 'Notentaste'        Zeile2: 'RMT'
  '   (Notentaste auf Klaviatur und rechte Maustaste)
  ' PROCEDURE 1_nur_ton(x%)         !_:
  '   'Nur Ton': Man hîrt nur eine Note, die wird aber weder dargestellt noch
  '              gespeichert.
  ' ............................................................................
  ' * S p a l t e  3  : 'r. Pausentaste'    Zeile2: 'RMT'
  '   (rechte Pausentaste auf Klaviatur und rechte Maustaste)
  ' PROCEDURE 1_backspace           !_:
  '   'Backspace':   Die Note links vom Cursor wird gelîscht.
  '                  Kann auch mit der linken Space-Taste erreicht werden.
  ' ............................................................................
  ' * S p a l t e  4  : 'Notentext'         Zeile2: 'RMT'
  '   (Mauspfeil auf Notentext und rechte Maustaste)
  ' PROCEDURE 1_spielen(x%,y%)      !_:
  '   'Abspielen':   Alle Noten zwischen und einschlieûlich den Noten unter dem
  '                  Cursor & unter dem Mauspfeil werden nacheinander gespielt.
  ' * Abbruch bei Abspielen: Auf die linke Maustaste drÅcken.
  '   Wenn Noten vom Programm abgespielt werden, kann dies mit der linken
  '   Maustaste abgebrochen werden.
  ' ............................................................................
  ' * S p a l t e  5  : 'Cursor'         Zeile2: 'RMT'
  ' PROCEDURE 1_faehnchen           !_:
  '   'FÑhnchen': Bei der Note unter dem Cursor kommt noch ein FÑhnchen dazu.
  '               Geht das nicht mehr, so fÑngt's wieder bei 0 FÑhnchen an.
  ' ............................................................................
  '
  ' ............................................................................
  '
  '
  '     B e f e h l e,  n u r  Å b e r  T a s t e n  e r r e i c h b a r :
  '
  '
  '     'Control'-Taste:  Cursor eins weiter nach links
  '                       (Ein entsprechender Mausklick wird simuliert)
  '
  '     'Tab'-Taste:      Cursor eins weiter nach rechts
  '                       (Ein entsprechender Mausklick wird simuliert)
  '
  '     'Help'-Taste:     Hilfstext mit BefehlsÅbersicht und allerlei Infos
  '
  '     'a'oder'A':       StÅck von anfang an durchspielen
  ' ............................................................................
RETURN
> PROCEDURE 0_ausfuehrliche_befehlsdukumentation_fuer_hauptmenue
  '
  ' ----------------------------------------------------------------------------
  '
  '
  '
  '     H a u p t m e n Å b e f e h l e :
  '
  '
  ' ----------------------------------------------------------------------------
  '                          Die Unterteilung des HauptmenÅs:
  '  StÅckmenÅ
  '  Hauptfile
  '  BlockmenÅ
  '  Parameter
  '  MenÅ-Exit
  '
  ' ----------------------------------------------------------------------------
  '  stueckmenue:
  ' ----------------------------------------------------------------------------
  ' M e n Å p u n k t :    StÅck auf Disk speichern
  ' PROCEDURE 2_stueck_abspeichern  !_:
  ' * Aktuelles StÅck im RAM wird als einzelnes File vom RAM auf Diskette
  '   abgespeichert.
  ' M e n Å p u n k t :    StÅck von Disk laden
  ' PROCEDURE 2_stueck_laden        !_:
  ' * Ein einzeln auf Diskette abgespeichertes StÅck wird geladen und an die
  '   Stelle des aktuellen StÅcks im RAM gesetzt. Das alte (vorher aktuelle)
  '   StÅck geht dabei verloren (UNDO mîglich).
  ' M e n Å p u n k t :    StÅck in Hauptfile speichern
  ' PROCEDURE 1_abspeichern         !_:
  ' * Der Notentext wird abgespeichert. Wird hierbei als
  ' * Speichername "________" eingegeben, so wird das StÅck,
  '    dessen Name damit Åberschrieben wurde, gelîscht.
  '   Abbruch durch Eingabe von '-1' mîglich.
  ' M e n Å p u n k t :    StÅck von Hauptfile laden
  ' PROCEDURE 1_laden               !_:
  ' * Der Notentext wird geladen.
  '   U n d o - Mîglichkeit !
  ' M e n Å p u n k t :    bestimmte StÅcke drucken
  ' PROCEDURE 2_drucken_gewaehlte   !_:
  ' * Einzelne, gewÑhlte StÅcke drucken.
  '   Abbruch vor jeder Druckseite einzeln od. insgesamt durch Alertbox mîglich.
  ' M e n Å p u n k t :    bestimmte StÅcke spielen
  ' PROCEDURE 2_spielen_gewaehlte   !_:
  ' * Einzelne, gewÑhlte StÅcke spielen.
  '   Abbruch wÑhrend des Spielens durch 'Esc'-Taste.
  ' ----------------------------------------------------------------------------
  '  hauptfile:
  ' ----------------------------------------------------------------------------
  ' M e n Å p u n k t :    Hauptfile neuanlegen
  ' PROCEDURE 2_hauptfileneuanlegen !_:
  ' * Hauptfile auf Diskette und im RAM neuanlegen.
  ' M e n Å p u n k t :    Hauptfile neu laden
  ' PROCEDURE 2_hauptfile_laden     !_:
  ' * Haupfile von Diskette ins RAM laden.
  ' M e n Å p u n k t :    Hauptfile abspeichern
  ' PROCEDURE 2_save_hauptfile      !_:
  ' * Hauptfile vom RAM auf Diskette abspeichern.
  ' M e n Å p u n k t :    beliebiges File lîschen
  ' PROCEDURE 2_file_loeschen       !_:
  ' * File auf Diskette lîschen. Muû bestÑtigt werden.
  ' M e n Å p u n k t :    File umbenennen
  ' PROCEDURE 2_rename_file         !_:
  ' * Name eines Files kann hier geÑndert werden.
  ' M e n Å p u n k t :    Inhaltsverzeichnis drucken
  ' PROCEDURE 2_inhverz_drucken     !_:
  ' * Inhaltsverzeichnis des Hauptfiles drucken.
  ' M e n Å p u n k t :    Alle StÅcke drucken
  ' PROCEDURE 2_drucken_ab_x_alle   !_:
  ' * Ab einer wÑhlbaren Stelle im alphabetisch geordneten Inhaltsverzeichnis
  '   alle restlichen StÅcke drucken. Abbruch durch Eingabe von '-1'.
  '   Abbruch vor jeder Druckseite einzeln od. insgesamt durch Alertbox mîglich.
  ' M e n Å p u n k t :    Alle StÅcke spielen
  ' PROCEDURE 2_spielen_ab_x_alle   !_:
  ' * Ab einer wÑhlbaren Stelle im alphabetisch geordneten Inhaltsverzeichnis
  '   alle restlichen StÅcke spielen. Abbruch durch Eingabe von '-1'.
  '   Abbruch wÑhrend des Spielens durch 'Esc'-Taste.
  ' ----------------------------------------------------------------------------
  '  blockmenue:
  ' ----------------------------------------------------------------------------
  ' M e n Å p u n k t :    Anfang
  ' PROCEDURE 1_blockmark(x%,y%)    !_:
  ' * Blockanfang wird gesetzt und damit das Blockende auf Text-
  '   Ende. Ist Blockanfang schon gesetzt worden,
  '   dann halt Blockende,wenn Blockende auf Blockanfang gesetzt,
  '   dann wird die Blockmarkierung rÅckgÑngig gemacht=gelîscht.
  ' M e n Å p u n k t :    Ende
  ' PROCEDURE 1_blockmark(x%,y%)    !_:
  ' * Blockanfang wird gesetzt und damit das Blockende auf Text-
  '   ende.
  ' M e n Å p u n k t :    kopieren
  ' PROCEDURE 1_block_kopieren      !_:
  ' * Der Block wird vor den Cursor kopiert
  ' M e n Å p u n k t :    doppelt so schnell
  ' PROCEDURE 3_bl_faehnchen(v!,x%) !_:
  ' * Funktioniert, wenn Blockbereich definiert ist:
  '   Es wird Åberall im Block ein FÑhnchen dazugesetzt.
  ' M e n Å p u n k t :    halb so schnell
  ' PROCEDURE 3_bl_faehnchen(v!,x%) !_:
  ' * Funktioniert, wenn Blockbereich definiert ist:
  '   Es wird Åberall im Block ein FÑhnchen weniger dargestellt.
  ' M e n Å p u n k t :    transponieren
  ' PROCEDURE 3_bl_transponieren(x%)!_:
  ' * Block transponieren: gewÅnschte Startnote auf Klaviatur anklicken
  '   Wenn bereits ein Block Åber Blockmarken definiert worden ist, kann der
  '   gesamte Blockbereich um eine gewÅnschte Differenz in der Tonhîhe ver-
  '   schoben werden. Die Differenz errechnet sich dabei folgendermaûen.
  '   Ausgegangen wird von der 1. Note im Blockbereich. Dann klickt man die
  '   gewÅnschte neue Startnote auf der Klaviatur an. Die Differenz dieser
  '   beiden Tîne ist dann die Verschiebedifferenz der Transponierprozedur.
  ' M e n Å p u n k t :    lîschen
  '  PROCEDURE 2_block_loeschen      !_:
  ' * Der Block wird gelîscht. BestÑtigung erforderlich.
  '   U n d o - Mîglichkeit !
  ' ----------------------------------------------------------------------------
  '  parameter:
  ' ----------------------------------------------------------------------------
  ' M e n Å p u n k t :    Abspielgeschwindigkeit
  ' PROCEDURE 1_abspielgeschw       !_:
  ' * Die Abspielgeschwindigkeit kann verÑndert werden.
  ' M e n Å p u n k t :    Pause zw den StÅcken
  ' PROCEDURE 1_stueckpause         !_:
  ' * Pause zwischen den StÅcken beim Abspielen mehrerer StÅcke kann hier ein-
  '   gestellt werden
  ' M e n Å p u n k t :    Tonhîhe
  ' PROCEDURE 1_tonhoehe            !_:
  ' * Die Tonhîhe kann verÑndert werden, nur fÅr einen kleinen Bereich um
  '   440 Hz sinnvoll, da sonst Unstimmigkeiten auftreten.
  ' M e n Å p u n k t :    Midi ein/aus
  ' PROCEDURE 1_midi_ein_aus        !_:
  ' * Hier wird festgelegt, wo die Tonausgabe stattfinden soll und ob ein
  '   Keyboard zur Eingabe verwendbar ist.
  ' ----------------------------------------------------------------------------
  '  menue_exit:
  ' ----------------------------------------------------------------------------
  ' M e n Å p u n k t :    Eingabe fortsetzen
  ' * hier wird nichts gemacht
  ' M e n Å p u n k t :    Edit
  ' PROCEDURE 1_programmende(w|)    !_:
  ' * in den Editor ohne BestÑtigung
  ' M e n Å p u n k t :    Quit
  ' PROCEDURE 1_programmende(w|)    !_:
  ' * Das Programm beenden, BestÑtigung erforderlich.
  ' ----------------------------------------------------------------------------
  '
  ' !! w i c h t i g !!
  '
  ' ----------------------------------------------------------------------------
  ' Ein MenÅ, in dem die aktuellen EintrÑge invers dargestellt werden, kann
  ' durch die linke Maustaste und Mauspfeil auûerhalb der EintrÑge abge-
  ' brochen werden.
  ' Muû in einem MenÅ etwas eingegeben werden, so kann auch hier abgebrochen
  ' werden, nÑmlich indem man einfach nichts eingibt.
  ' ----------------------------------------------------------------------------
RETURN
' ##############################################################################
'  P r o g r a m m t e x t e n d e :
' ##############################################################################
