' ***********************************************************************
' NEWGRAF.LST
' A few routines to fill in the gaps the TOSfunctions GRAF_DRAGBOX,
' GRAF_RUBBERBOX, GRAF_SLIDEBOX leave behind.
' Functions form_dragbox() and form_slidebox() all take (resourcefile)
' OBJECTS as parameters.
' Functions do_dragbox(), do_rubberbox() and do_slidebox() all perform
' similar tasks, but take SCREENCOORDINATES as their parameters.
' With the form_ routines you will have much more freedom in selecting
' the shape (type) of the objects than with the do_ routines. (they
' all draw/move a stippled box rather than a drawing object)
' All functions call (while working) upon routines for you to fill in
' so real time scrolling/updating can be done.
' Furthermore, all functions test the state of the mousebutton and
' exit when this state changes. This makes it possible to have it work
' UNTIL a mousebutton is pressed, rather than released like with TOS.
' (also, the right mousebutton can be used instead of just the left..)
' A demo should show you how they all work.
'
' Theo Ros 24/07/1997
' ***********************************************************************
'
DEFLIST 4
DEFWRD "a-z"
OPTION BASE 0
'
RESERVE 10000
demo_min=0                      ! demo uses this range
demo_max=360
@demo_bar(20,140,240,18,FALSE)
' @demo_drag(20,20,241,100)
REPEAT
  MOUSE mx,my,mk
  IF mk
    ~WIND_UPDATE(3)         ! catch mouse
    DEFMOUSE 3
    '    ~@do_rubberbox(100,10,30,20,400,200,TRUE)
    '    ~@do_dragbox(mx-10,my-10,120,20,10,10,500,300)
    '    ~@do_slidebox(mx,my,20,16,mx,my,200,16,FALSE)
    DEFMOUSE 0
    ~WIND_UPDATE(2)         ! release mouse
  ENDIF
UNTIL mk>1
EDIT
'
' ***********************************************************************
' the demo
' ***********************************************************************
> PROCEDURE demo_bar(x,y,w,h,vertical!)
  '
  ' just some semi-constants for better readability
  barroot=0
  barleft=1
  barpage=2
  barslider=3
  barright=4
  '
  '  ~RSRC_LOAD("g:\ictari\listdemo.rsc")
  '  ~RSRC_GADDR(0,1,slidebar%)
  slidebar%=@form_slidebar_create(3,vertical!)          ! create on the fly
  IF slidebar%>0
    ~@form_slidebar_arrows(slidebar%,barroot,3)         ! both arrows ON
    ~@form_slidebar_set(slidebar%,barroot,x,y,w,h)      ! position the BAR
    '                                                     position the SLIDER
    ' you can set the appearance of any object in the bar
    ' using the functions:
    '   obj_get/set_tedfont() (sliderobject=G_BOXTEXT)
    '   obj_get/set_tedbox()  (sliderobject=G_BOXTEXT)
    '   obj_get/set_boxinfo() (arrows=G_BOXCHAR and pagebox=G_BOX)
    ~@obj_set_tedbox(slidebar%,barslider,2,0,2,-1)
    ~@obj_set_tedfont(slidebar%,barslider,5,0,0,2,1,0)
    IF demo_min>demo_max
      SWAP demo_min,demo_max
    ENDIF
    ~@obj_set_text(slidebar%,barslider,STR$(demo_min)+CHR$(248))
    ~OBJC_DRAW(slidebar%,barroot,9,x-1,y-1,w+2,h+2)
    @demo_build_house(x+w\2,y-50)
    DO
      ~GRAF_MKSTATE(mx,my,mk,switch)
      IF mk=1                   ! demo waits for left mousebutton
        SELECT OBJC_FIND(slidebar%,barroot,9,mx,my)
        CASE barleft
          IF switch AND 3       ! pressed SHIFT?
            @demo_slide(-4,vertical!)
          ELSE
            @demo_slide(-1,vertical!)
          ENDIF
        CASE barpage
          @demo_page(mx,my,vertical!)
        CASE barslider
          ~WIND_UPDATE(3)       ! catch mouse
          DEFMOUSE 3            ! pointing finger
          ~@form_slidebox(slidebar%,barpage,barslider,vertical!)
          DEFMOUSE 0
          ~WIND_UPDATE(2)       ! release mouse
        CASE barright
          IF switch AND 3
            @demo_slide(4,vertical!)
          ELSE
            @demo_slide(1,vertical!)
          ENDIF
        ENDSELECT
      ENDIF
    LOOP UNTIL mk>1
  ENDIF
  ~RSRC_FREE()
  ~MFREE(slidebar%)
  RESERVE
RETURN
> PROCEDURE demo_slide(offset,vertical!)
  LOCAL slider%,newpos,relpos,relsize
  slider%=@form_get_slider(slidebar%,barpage,barslider,vertical!)
  ~@splitval(slider%,relpos,relsize)
  IF vertical!
    slider%=SUCC(OB_H(slidebar%,barpage)-OB_H(slidebar%,barslider))
    MUL offset,@calc_step(demo_min,demo_max,slider%)
  ELSE
    slider%=SUCC(OB_W(slidebar%,barpage)-OB_W(slidebar%,barslider))
    MUL offset,@calc_step(demo_min,demo_max,slider%)
  ENDIF
  newpos=MAX(0,MIN(relpos+offset,1000))
  IF newpos<>relpos
    @form_update_slider(newpos,0,vertical!)
    ~@form_set_slider(slidebar%,barpage,barslider,newpos,relsize,vertical!)
    ~OBJC_DRAW(slidebar%,barpage,9,0,0,0,0)
  ENDIF
RETURN
> PROCEDURE demo_page(mx,my,vertical!)
  ' the 'page' (grey area inside a scrollbar) has been hit
  LOCAL slx,sly
  ~OBJC_OFFSET(slidebar%,barslider,slx,sly)
  IF vertical!
    IF my<sly
      @demo_slide(-4,TRUE)
    ELSE
      @demo_slide(4,TRUE)
    ENDIF
  ELSE
    IF mx<slx
      @demo_slide(-4,FALSE)
    ELSE
      @demo_slide(4,FALSE)
    ENDIF
  ENDIF
RETURN
> PROCEDURE demo_drag(x,y,w,h)
  '
  ' just some semi-constants for better readability
  the_box=0
  the_dragged=1
  IF demo_min>demo_max
    SWAP demo_min,demo_max
  ENDIF
  '
  '  ~RSRC_LOAD("g:\ictari\listdemo.rsc")
  '  ~RSRC_GADDR(0,2,dragbox%)
  dragbox%=@form_dragbox_create(3)
  IF dragbox%>0
    ~@form_dragbox_set(dragbox%,the_box,x,y,w,h)        ! position the BOX
    ' you can set the appearance of any object in the box
    ' using the functions:
    '   obj_get/set_boxinfo() (the_box=G_BOX)
    '   obj_get/set_tedfont() (the_dragged=G_BOXTEXT)
    '   obj_get/set_tedbox()  (the_dragged=G_BOXTEXT)
    '    ~@obj_set_tedbox(dragbox%,the_dragged,5,0,2,-1)
    '    ~@obj_set_tedfont(dragbox%,the_dragged,5,0,0,2,1,0)
    ~@obj_set_tedfont(dragbox%,the_dragged,3,0,0,2,1,0)
    ~@obj_set_text(dragbox%,the_dragged,STR$(demo_min)+CHR$(248))
    ~OBJC_DRAW(dragbox%,the_box,9,0,0,0,0)
    DO
      MOUSE mx,my,mk
      IF mk=1
        SELECT OBJC_FIND(dragbox%,the_box,9,mx,my)
        CASE the_dragged
          ~WIND_UPDATE(3)         ! catch mouse
          DEFMOUSE 4              ! flat hand
          ~@form_dragbox(dragbox%,the_box,the_dragged)
          DEFMOUSE 0
          ~WIND_UPDATE(2)         ! realease mouse
        ENDSELECT
      ENDIF
    LOOP UNTIL mk>1
  ENDIF
  ~RSRC_FREE()
  ~MFREE(dragbox%)
  RESERVE
RETURN
> PROCEDURE demo_build_house(midx,midy)
  ' creates a vector array for rotating demo
  LOCAL pt
  ERASE px(),py(),nx(),ny()             ! demo uses two arrays: px() and py()
  DIM px(11),py(11),nx(10),ny(10)       ! store original coordinates,
  RESTORE small_house                   ! nx() and ny() are used for
  FOR pt=0 TO 10                        ! recalculated coordinates
    READ px(pt),py(pt)
    ADD px(pt),midx-20
    ADD py(pt),midy-30
    nx(pt)=px(pt)
    ny(pt)=py(pt)
  NEXT pt
  px(11)=midx                   ! preserve rotationcentre
  py(11)=midy
  GRAPHMODE 3
  POLYLINE 11,nx(),ny()         ! draw first time
  '
small_house:
  DATA 0,20,20,0,40,20,40,60,20,60,20,40,10,40,10,60,0,60,0,20,40,20
RETURN
> PROCEDURE demo_draw_house(angle)
  LOCAL fsin#,fcos#,tempx,tempy
  fsin#=SINQ(angle)             ! angle is given in DEGREES, not radials
  fcos#=COSQ(angle)
  GRAPHMODE 3
  POLYLINE 11,nx(),ny()         ! erase old house
  FOR angle=0 TO 10             ! calc rotated position
    tempx=px(angle)-px(11)
    tempy=py(angle)-py(11)
    nx(angle)=CINT(tempx*fcos#+tempy*fsin#)+px(11)
    ny(angle)=CINT(tempy*fcos#-tempx*fsin#)+py(11)
  NEXT angle
  POLYLINE 11,nx(),ny()         ! draw new house
RETURN
'
' ***********************************************************************
' the form_.. routines (use objects, rather than screencoordinates)
' ***********************************************************************
> FUNCTION form_slidebox(tree%,obj_frame,obj_slider,vertical!)
' replacement function for GRAF_SLIDEBOX (AES 76), which does
' not allow real_time scrolling and only works when the mouse
' is pressed. With it, you can use sliderbars created in a
' resource editor, or created on the fly with form_slidebar_create()
' form_slidebox() only allows vertical OR horizontal movement.
' if you want to have an object move more freely within a parent
' object, use function form_dragbox()
' when called, the function will exit when current status
' of mousebutton changes.
'
' --> tree%       objecttree both frame and slider object belong to
'     obj_frame&  objectnumber for the sliders parent (pageframe)
'     obj_slider& objectnumber for the slider object
'     vertical!   direction: TRUE=vertical, FALSE=horizontal movement
' <-- newpos&     position of slider, relative to parent (frame) object:
'                 (0: top, 1000: bottom)
'
' Each time the function encounters a new sliderposition, it
' jumps to a routine called PROCEDURE form_update_vslider(new_position)
' when in vertical mode or PROCEDURE form_update_hslider(new_position)
' otherwise, which gives you the opportunity to redraw your display
' for real-time scrolling.
' Again, new_position& ranges from 0 (top) to 1000 (bottom), just
' like window sliders are calculated.
' For your convenience, I've added calc_.. functions to update
' or size your sliders. It is recommended you use function
' calc_display_offset(new_position,display_size,data_size)
' in these procedures called by this function.
'
$F&
LOCAL mstate,mx,my,mb,sx,sy,sw,sh,px,py,pw,ph,pos,maxpos,relpos,offm,switch
~OBJC_OFFSET(tree%,obj_slider,sx,sy)
sw=OB_W(tree%,obj_slider)
sh=OB_H(tree%,obj_slider)
~OBJC_OFFSET(tree%,obj_frame,px,py)
ph=OB_H(tree%,obj_frame)
pw=OB_W(tree%,obj_frame)
CLR relpos
' Bug: in my editor (3.5) MOUSE x,y,k works better than GRAF_MKSTATE()
~GRAF_MKSTATE(mx,my,mb,switch)
mstate=mb
IF vertical!
  IF sh<ph                                    ! slider NOT at maximum size?
    maxpos=py+ph-sh
    offm=my-sy
    relpos=CINT((sy-py)/(maxpos-py)*1000)
    WHILE mb=mstate
      pos=MAX(py,MIN(maxpos,my-offm))
      IF sy<>pos
        OB_Y(tree%,obj_slider)=pos-py         ! update new slider position
        relpos=CINT((pos-py)/(maxpos-py)*1000)
        @form_update_slider(relpos,switch,TRUE)
        ' you could redraw the slider using:
        ' ~OBJC_DRAW(tree%,obj_frame,9,sx-1,MIN(pos,sy)-1,sw+2,sh+ABS(sy-pos)+2)
        ' but this gives a smoother result:
        IF sy<pos                             ! moved down?
          ~OBJC_DRAW(tree%,obj_frame,0,sx-1,sy-1,sw+2,pos-sy+2)
        ELSE
          ~OBJC_DRAW(tree%,obj_frame,0,sx-1,pos+sh-1,sw+2,sy-pos+2)
        ENDIF
        ~OBJC_DRAW(tree%,obj_slider,9,sx-1,pos-1,sw+2,sh+2)
        sy=pos
      ENDIF
      ~GRAF_MKSTATE(mx,my,mb,switch)
    WEND
  ENDIF
ELSE IF sw<pw                                 ! slider NOT at maximum size?
  maxpos=px+pw-sw
  offm=mx-sx
  relpos=CINT((sx-px)/(maxpos-px)*1000)
  WHILE mb=mstate
    pos=MAX(px,MIN(maxpos,mx-offm))
    IF sx<>pos
      OB_X(tree%,obj_slider)=pos-px           ! update new slider position
      relpos=CINT((pos-px)/(maxpos-px)*1000)
      @form_update_slider(relpos,switch,FALSE)
      ' you could redraw the slider using:
      ' ~OBJC_DRAW(tree%,obj_frame,9,MIN(sx,pos)-1,sy-1,sw+ABS(sx-pos)+2,sh+2)
      ' but this gives a smoother result:
      IF sx<pos                               ! moved to right?
        ~OBJC_DRAW(tree%,obj_frame,0,sx-1,sy-1,pos-sx+2,sh+2)
      ELSE
        ~OBJC_DRAW(tree%,obj_frame,0,pos+sw-1,sy-1,sx-pos+2,sh+2)
      ENDIF
      ~OBJC_DRAW(tree%,obj_slider,9,pos-1,sy-1,sw+2,sh+2)
      sx=pos
    ENDIF
    ~GRAF_MKSTATE(mx,my,mb,switch)
  WEND
ENDIF
~EVNT_BUTTON(257,3,mstate)                    ! let AES know status of mouse
RETURN relpos
ENDFUNC
> FUNCTION form_get_slider(tree%,obj_frame,obj_slider,vertical!)
' --> tree%       objecttree both frame and slider object belong to
'     obj_frame&  objectnumber for the sliders parent (pageframe)
'     obj_slider& objectnumber for the slider object
'     vertical!   direction: TRUE=vertical, FALSE=horizontal movement
' <-- combined pixel relative position and size for the box
'     high_word:  position (0-1000),
'     low_word:   size (0-1000) [see function splitval()]
$F%
LOCAL maxsize,size,pos
IF vertical!
maxsize=OB_H(tree%,obj_frame)
size=OB_H(tree%,obj_slider)         ! get height in pixels of slider
pos=OB_Y(tree%,obj_slider)          ! get y position for slider
ELSE
maxsize=OB_W(tree%,obj_frame)
size=OB_W(tree%,obj_slider)         ! get width in pixels of slider
pos=OB_X(tree%,obj_slider)          ! get x position for slider
ENDIF
IF size
IF size<maxsize
  pos=CINT(pos/(maxsize-size)*1000) ! 0=top, 1000=bottom
  size=CINT(size/maxsize*1000)      ! 0=smallest, 1000=maximum size
ELSE
  CLR pos
  size=1000
ENDIF
ELSE
CLR pos
ENDIF
RETURN SHL(pos,16) OR CARD(size)      ! return combined pixel-position/size
ENDFUNC
> FUNCTION form_set_slider(tree%,obj_frame,obj_slider,pos,size,vertical!)
' --> tree%       objecttree both frame and slider object belong to
'     obj_frame&  objectnumber for the sliders parent (pageframe)
'     obj_slider& objectnumber for the slider object
'     pos&        relative position of obj_slider to obj_frame (0-1000)
'                 value is returned by calc_sliderpos()
'     size&       size relative to obj_frame (0-1000)
'                 value is returned by calc_slidersize()
'     vertical!   direction: TRUE=vertical, FALSE=horizontal movement
' <-- combined pixel based position and size for the box
'     high_word:  OB_X or Y, low_word: OB_W or H [see function splitval()]
$F%
LOCAL maxsize
size=MAX(0,MIN(1000,size))
pos=MAX(0,MIN(1000,pos))
IF vertical!
maxsize=OB_H(tree%,obj_frame)
size=CINT(maxsize/1000*size)        ! calc height in pixels of slider
pos=CINT((maxsize-size)/1000*pos)   ! calc y position for slider
OB_H(tree%,obj_slider)=size
OB_Y(tree%,obj_slider)=pos
ELSE
maxsize=OB_W(tree%,obj_frame)
size=CINT(maxsize/1000*size)        ! calc width in pixels of slider
pos=CINT((maxsize-size)/1000*pos)   ! calc x position for slider
OB_W(tree%,obj_slider)=size
OB_X(tree%,obj_slider)=pos
ENDIF
RETURN SHL(pos,16) OR CARD(size)      ! return combined pixel-position/size
ENDFUNC
> FUNCTION form_slidebar_create(font,vertical!)
' builds a 'range' sliderbar objecttree in memory.
' the function returns the address of the objecttree
' needed for OBJC_DRAW() and MFREE().
' This function initializes ALL objects to position
' and size of 0. Therefore, it is essential to use
' function form_slidebar_set() before drawing.
' In order to also use such an object with a slider
' containing text, the sliderbox itself is a
' G_BOXTEXT object, rather than the standard G_BOX.
' The tree created hold a 20 character buffer for
' text you might want to put in.
'
' The slider-objecttree consists of:
' object 0: SLIDEROOT   BOX, WHITE, SHADOWED
' object 1: SLIDELEFT   BOXCHAR, CHR$(4)    if horizontal
'        or SLIDEUP     BOXCHAR, CHR$(1)    if vertical
' object 2: SLIDEPAGE   BOX, pattern 1,2,2
' object 3: SLIDESLIDER BOXTEXT, OPAQUE, WHITE, CENTERED
' object 4: SLIDERIGHT  BOXCHAR, CHR$(3)    if horizontal
'        or SLIDEDOWN   BOXCHAR, CHR$(2)    if vertical
'
' --> font&     the font used for text inside the sliderbox:
'               3: standard charactersize (GRAF_HANDLE(chw,chh,d,d)
'               5: 6*6 charactersize as used for icons
'     vertical! the direction for the bar
' <-- address of slidebar_objecttree
'
$F%
LOCAL obj,tree%,n%
tree%=MALLOC(24*5+28+22)           ! room for objects + strings
IF tree%>0
RESTORE slidebar_objects
FOR obj=0 TO 4
READ n%
OB_NEXT(tree%,obj)=n%
READ n%
OB_HEAD(tree%,obj)=n%
READ n%
OB_TAIL(tree%,obj)=n%
READ n%
OB_TYPE(tree%,obj)=n%
READ n%
OB_FLAGS(tree%,obj)=n%
READ n%
OB_STATE(tree%,obj)=n%
OB_X(tree%,obj)=0
OB_Y(tree%,obj)=0
OB_W(tree%,obj)=0
OB_H(tree%,obj)=0
NEXT obj
OB_SPEC(tree%,0)=&HFF1100           ! SLIDEROOT: white, opaque
OB_SPEC(tree%,2)=&HFF1111           ! SLIDEPAGE: pattern 1,1, opaque
IF vertical!
OB_SPEC(tree%,1)=&H1FF1100        ! SLIDEUP:   arrow UP
OB_SPEC(tree%,4)=&H2FF1100        ! SLIDEDOWN: arrow DOWN
ELSE                                ! horizontal
OB_SPEC(tree%,1)=&H4FF1100        ! SLIDELEFT:  arrow LEFT
OB_SPEC(tree%,4)=&H3FF1100        ! SLIDERIGHT: arrow RIGHT
ENDIF
n%=tree%+5*24                       ! address for tedinfo
OB_SPEC(tree%,3)=n%
LONG{n%}=n%+28                      ! te_ptext
LONG{n%+4}=n%+28+21                 ! te_ptmplt
LONG{n%+8}=n%+28+21                 ! te_pvalid
CARD{n%+12}=MAX(3,MIN(font,5))      ! te_font: 3=standard, 5=small
CARD{n%+14}=0                       ! te_resvd
CARD{n%+16}=2                       ! te_just: 2=centered
CARD{n%+18}=&H1181                  ! te_color: opaque, black
CARD{n%+20}=0                       ! te_resvd2
CARD{n%+22}=-1                      ! te_thickness
CARD{n%+24}=21                      ! te_txtlen: room for 20 chars+NULL
CARD{n%+26}=1                       ! te_tmplen: 0 chars+NULL
CHAR{n%+28}=""                      ! initially no text
CHAR{n%+28+21}=""                   ! no template too
ENDIF
RETURN tree%
'
slidebar_objects:
' OB_NEXT, OB_HEAD, OB_TAIL, OB_TYPE, OB_FLAGS, OB_STATE
DATA -1,1,4,20,0,32
DATA 2,-1,-1,27,64,0
DATA 4,3,3,20,64,0
DATA 2,-1,-1,22,64,0
DATA 0,-1,-1,27,96,0
ENDFUNC
> FUNCTION form_slidebar_arrows(tree%,rootobj,arrows)
' switch ending arrows ON or OFF
' --> tree%     the address of the sliderbar object
'     rootobj&  the rootobject for the sliderbar (usually BOX, SHADOWED)
'     arrows&   -1: arrow inquire, returned value as below
'               bit 0: arrow UP/LEFT on (1) or off (0)
'               bit 1: arrow DOWN/RIGHT on (1) or off (0)
' <-- bitmapvalue reflecting the current state of arrows (0-3)
'
$F&
LOCAL flagsup,flagsdown
IF tree%
IF OB_TAIL(tree%,rootobj)=4         ! root has 4 children?
flagsup=OB_FLAGS(tree%,rootobj+1)
flagsdown=OB_FLAGS(tree%,rootobj+4)
IF arrows<0                       ! inquire?
RETURN (SHR(flagsdown,6) AND &X10) OR (SHR(flagsup,7) AND 1)
ELSE
IF BTST(arrows,0)               ! set UP/LEFT arrow
OB_FLAGS(tree%,rootobj+1)=BCLR(flagsup,7)
ELSE                            ! or hide it
OB_FLAGS(tree%,rootobj+1)=BSET(flagsup,7)
ENDIF
IF BTST(arrows,1)               ! set UP/LEFT arrow
OB_FLAGS(tree%,rootobj+4)=BCLR(flagsdown,7)
ELSE                            ! or hide it
OB_FLAGS(tree%,rootobj+4)=BSET(flagsdown,7)
ENDIF
RETURN (arrows AND 3)
ENDIF
ENDIF
ENDIF
RETURN 0
ENDFUNC
> FUNCTION form_slidebar_set(tree%,rootobj,xbar,ybar,wbar,hbar)
' --> tree%     the address of the sliderbar object
'     rootobj&  the rootobject for the sliderbar (usually BOX, SHADOWED)
'     xbar& ... hbar& are the outer pixeldimensions for the sliderbar
' <-- TRUE      ok
'     FALSE     objecttree does not exist or is incorrect
LOCAL asize,d
IF tree%
IF OB_TAIL(tree%,rootobj)=4                 ! root has 4 children?
~GRAF_HANDLE(d,asize,d,d)                 ! get standard char height
OB_X(tree%,rootobj)=xbar
OB_Y(tree%,rootobj)=ybar
OB_W(tree%,rootobj)=wbar
OB_H(tree%,rootobj)=hbar
IF BYTE{OB_ADR(tree%,rootobj+1)+12}=1     ! arrow object point UP?
FOR d=rootobj+1 TO rootobj+4            ! means arrange VERTICALLY
OB_X(tree%,d)=0
OB_W(tree%,d)=wbar
NEXT d
asize=MIN((hbar-2)\2,asize)             ! calc max arrow size
OB_Y(tree%,rootobj+1)=0                 ! SLIDEUP
OB_H(tree%,rootobj+1)=asize
OB_Y(tree%,rootobj+4)=hbar-asize        ! SLIDEDOWN
OB_H(tree%,rootobj+4)=asize
CLR ybar
IF BTST(OB_FLAGS(tree%,rootobj+1),7)=0  ! arrow UP not hidden?
ADD ybar,asize+1
SUB hbar,asize+1
ENDIF
IF BTST(OB_FLAGS(tree%,rootobj+4),7)=0  ! arrow DOWN not hidden?
SUB hbar,asize+1
ENDIF
hbar=MAX(0,hbar)
OB_Y(tree%,rootobj+2)=ybar              ! SLIDEPAGE
OB_H(tree%,rootobj+2)=hbar
OB_Y(tree%,rootobj+3)=0                 ! SLIDER
OB_H(tree%,rootobj+3)=MIN(hbar,asize)
ELSE                                      ! arrange HORIZONTALLY
FOR d=rootobj+1 TO rootobj+4
OB_Y(tree%,d)=0
OB_H(tree%,d)=hbar
NEXT d
asize=MIN((wbar-2)\2,asize)             ! calc max arrow size
OB_X(tree%,rootobj+1)=0                 ! SLIDELEFT
OB_W(tree%,rootobj+1)=asize
OB_X(tree%,rootobj+4)=wbar-asize        ! SLIDERIGHT
OB_W(tree%,rootobj+4)=asize
CLR xbar
IF BTST(OB_FLAGS(tree%,rootobj+1),7)=0  ! arrow LEFT not hidden?
ADD xbar,asize+1
SUB wbar,asize+1
ENDIF
IF BTST(OB_FLAGS(tree%,rootobj+4),7)=0  ! arrow RIGHT not hidden?
SUB wbar,asize+1
ENDIF
OB_X(tree%,rootobj+2)=xbar              ! SLIDEPAGE
OB_W(tree%,rootobj+2)=wbar
OB_X(tree%,rootobj+3)=0                 ! SLIDER
OB_W(tree%,rootobj+3)=MIN(wbar,asize*3)
ENDIF
RETURN TRUE
ENDIF
ENDIF
RETURN FALSE
ENDFUNC
'
> FUNCTION form_dragbox(tree%,obj_frame,obj_drag)
' replacement function for GRAF_DRAGBOX (AES 71), which does
' not allow real_time scrolling and only works when the mouse
' is pressed. With it, you can use drag objects created in a
' resource editor, or created on the fly , like with the demo-
' function dragbar_create().
' form_dragbox(), unlike GRAF_DRAGBOX(), takes objects as its
' parameters, rather than coordinates. For this reason, it is
' similar to GRAF_SLIDEBOX().
' when called, the function will exit when current status
' of mousebutton changes.
'
' --> tree%       objecttree both frame and drag object belong to
'     obj_frame&  objectnumber for the dragged objects parent (pageframe)
'     obj_drag&   objectnumber for the dragged object
' <-- newpos%     position of dragged object, relative to parent object:
'                 (0: top, 1000: bottom). The high word represents the
'                 objects new horizontal position, the low word is the
'                 objects new vertical position:
'                     new_x=SHR(newpos%,16)
'                     new_y=CARD(newpos%)
'
' Each time the function encounters a new dragposition, it
' jumps to PROCEDURE form_update_drag(new_hpos,new_vpos,switch)
' which gives you the opportunity to redraw your display for
' real-time scrolling or change the contents of the drag object.
' Again, new horizontal and vertical positions range from 0 (top/left)
' to 1000 (bottom/right), just like window sliders are calculated.
' For your convenience, I've added calc_.. functions to update
' or size your sliders and dragboxes. It is recommended you use function
' calc_display_offset(new_position,display_size,data_size)
' in these procedures called by this function.
'
$F%
LOCAL mstate,mx,my,mb,dx,dy,dw,dh,px,py,pw,ph,switch
LOCAL ymax,xmax,rely,relx,posy,posx,offx,offy
~OBJC_OFFSET(tree%,obj_drag,dx,dy)
dw=OB_W(tree%,obj_drag)
dh=OB_H(tree%,obj_drag)
~OBJC_OFFSET(tree%,obj_frame,px,py)
ph=OB_H(tree%,obj_frame)
pw=OB_W(tree%,obj_frame)
CLR relx,rely
~GRAF_MKSTATE(mx,my,mb,switch)
mstate=mb
IF OR(dw<pw,dh<ph)                    ! the_dragged NOT at maximum size?
xmax=px+pw-dw
ymax=py+ph-dh
relx=CINT((dx-px)/(xmax-px)*1000)
rely=CINT((dy-py)/(ymax-py)*1000)
offx=mx-dx
offy=my-dy
WHILE mb=mstate
posx=MAX(px,MIN(xmax,mx-offx))
posy=MAX(py,MIN(ymax,my-offy))
IF OR(dx<>posx,dy<>posy)
OB_X(tree%,obj_drag)=posx-px    ! update position for the_dragged
OB_Y(tree%,obj_drag)=posy-py
relx=CINT((posx-px)/(xmax-px)*1000)
rely=CINT((posy-py)/(ymax-py)*1000)
@form_update_drag(relx,rely,switch)
~OBJC_DRAW(tree%,obj_frame,0,dx-1,dy-1,dw+2,dh+2)
~OBJC_DRAW(tree%,obj_drag,9,posx-1,posy-1,dw+2,dh+2)
dx=posx
dy=posy
ENDIF
~GRAF_MKSTATE(mx,my,mb,switch)
WEND
ENDIF
~EVNT_BUTTON(257,3,mstate)            ! let AES know status of mouse
RETURN SHL(relx,16) OR rely           ! return combined position
ENDFUNC
> FUNCTION form_dragbox_create(font)
' builds a 'range' sliderbar objecttree in memory.
' the function returns the address of the objecttree
' needed for OBJC_DRAW() and MFREE().
' This function initializes ALL objects to position
' and size of 0. Therefore, it is essential to use
' function form_dragbox_set() before drawing.
' In order to also use such an object with a slider
' containing text, the sliderbox itself is a
' G_BOXTEXT object, rather than the standard G_BOX.
' The tree created hold a 20 character buffer for
' text you might want to put in.
'
' The slider-objecttree consists of:
' object 0: DRAGROOT    BOX, WHITE, SHADOWED
' object 1: DRAGPAGE    BOX, pattern 1,2,2
' object 1: DRAGSLIDER  BOXTEXT, OPAQUE, WHITE, CENTERED
'
' --> font&     the font used for text inside the sliderbox:
'               3: standard charactersize (GRAF_HANDLE(chw,chh,d,d)
'               5: 6*6 charactersize as used for icons
' <-- address of slidebar_objecttree
'
$F%
LOCAL obj,tree%,n%,txt%,nul%
tree%=MALLOC(2*24+28+22)              ! room for objects + string
IF tree%>0
OB_NEXT(tree%,0)=-1                 ! parent object the_box
OB_HEAD(tree%,0)=1                  ! number of first child
OB_TAIL(tree%,0)=1                  ! only one child
OB_TYPE(tree%,0)=20                 ! G_BOX
OB_FLAGS(tree%,0)=0                 ! normal
OB_STATE(tree%,0)=32                ! shadowed
OB_SPEC(tree%,0)=&HFF1121           ! pattern 2,1, opaque
OB_X(tree%,0)=0
OB_Y(tree%,0)=0
OB_W(tree%,0)=0
OB_H(tree%,0)=0
'
OB_NEXT(tree%,1)=0                  ! child object the_dragged
OB_HEAD(tree%,1)=-1                 ! no more children
OB_TAIL(tree%,1)=-1                 ! no sub level
OB_TYPE(tree%,1)=22                 ! G_BOXTEXT
OB_FLAGS(tree%,1)=96                ! lastob & touchexit
OB_STATE(tree%,1)=0                 ! normal
n%=tree%+2*24                       ! address for tedinfo
OB_SPEC(tree%,1)=n%
OB_X(tree%,1)=0
OB_Y(tree%,1)=0
OB_W(tree%,1)=0
OB_H(tree%,1)=0
txt%=n%+28                          ! address of first te_ptext
nul%=txt%+22                        ! address of finishing nullbyte
LONG{n%}=n%+28                      ! te_ptext
LONG{n%+4}=n%+28+21                 ! te_ptmplt points to null byte
LONG{n%+8}=n%+28+21                 ! te_pvalid too
CARD{n%+12}=MAX(3,MIN(font,5))      ! te_font: 3=standard, 5=small
CARD{n%+14}=0                       ! te_resvd (te_fontid on AES=>4.1)
CARD{n%+16}=2                       ! te_just: 2=centered
CARD{n%+18}=&H1181                  ! te_color: bbbbttttmpppaaaa
'                                     b=bordercolor (bits 12-15)
'                                     t=textcolor (bits 8-11)
'                                     m=modus (bit 7) 1=opaque, 0=transp.
'                                     p=pattern (bits 4-6)
'                                     a=color of fillarea (bits 0-3)
CARD{n%+20}=0                       ! te_resvd2 (te_fontsize on AES=>4.1)
CARD{n%+22}=-1                      ! te_thickness:
'                                     negative= border INside
'                                     positive= border OUTside
CARD{n%+24}=21                      ! te_txtlen: room for 20 chars+NULL
CARD{n%+26}=1                       ! te_tmplen: 0 chars+NULL
CHAR{txt%}=""                       ! initially no text
CHAR{nul%}=""                       ! no template too
ENDIF
RETURN tree%
ENDFUNC
> FUNCTION form_dragbox_set(tree%,rootobj,xbox,ybox,wbox,hbox)
' --> tree%     the address of the dragbox object
'     rootobj&  the rootobject for the dragbox (usually BOX, SHADOWED)
'     xbox& ... hbox& are the outer pixeldimensions for the dragbox
' <-- TRUE      ok
'     FALSE     objecttree does not exist or is incorrect
LOCAL asize,neww,arrw,farw,d
IF tree%
~GRAF_HANDLE(d,asize,d,d)           ! get standard char height
OB_X(tree%,rootobj)=xbox
OB_Y(tree%,rootobj)=ybox
OB_W(tree%,rootobj)=wbox
OB_H(tree%,rootobj)=hbox
OB_X(tree%,rootobj+1)=0             ! the_dragged, in this demo a
OB_Y(tree%,rootobj+1)=0             ! G_BOXTEXT object
OB_W(tree%,rootobj+1)=MIN(wbox\2,asize*3)
OB_H(tree%,rootobj+1)=MIN(hbox\2,asize)
RETURN TRUE
ENDIF
RETURN FALSE
ENDFUNC
' =======================================================================
' The following procedures are for your drawing code..
' If you use functions form_slidebox() or form_dragbox() above,
' they MUST be present !
' =======================================================================
> PROCEDURE form_update_slider(newpos,switch,vertical!)
' --> newpos&  can be anything from 0 (first position of unit to display)
'              to 1000 (last position to display as seen from the left
'              or top side of workarea). Usage:
'              IF vertical!
'               display_y=@calc_display_offset(newpos,display_size,data_size)
'              ELSE
'               display_x=@calc_display_offset(newpos,display_size,data_size)
'              ENDIF
'     switch&  keystatus: bit 0: right Shift
'                         bit 1: left Shift
'                         bit 2: Control
'                         bit 3: Alternate
'
' PROCEDURE demo_bar() uses this routine to update
' the text in the sliderbox to match the position of
' this slider into the set range demo_min& to demo_max&
' after that, the small house is drawn at the new angle
' parameter vertical! is ignored here:
LOCAL d
d=INT(@calc_range(demo_min,demo_max,newpos))
~@obj_set_text(slidebar%,barslider,STR$(d)+CHR$(248))
@demo_draw_house(d)
'
' if your range are characters "A" to "Z", then ofcourse
' use:   d=INT(@calc_range(ASC("A"),ASC("Z"),newpos))
'        ~@obj_set_text(slidebar%,barslider,CHR$(d))
'
' **************************************************************************
' * MAKE SURE THE NEW TEXT IS NEVER LONGER THAN THE OBJECT CAN HOLD !!     *
' * function form_slidebar_create() allocates a string of 20 bytes, to     *
' * prevent possible text overflow. If you create your own with a slidebar *
' * with a resource editor, put in a placeholder-text long enough to store *
' * the largest possible text your program will use.                       *
' **************************************************************************
RETURN
> PROCEDURE form_update_drag(newxpos,newypos,switch)
' --> newxpos& and newypos&
'             can be anything from 0 (first unit to display)
'             to data_size&-display_size& (last unit to display
'             from top of workarea). Usage:
'             display_x=@calc_display_offset(newxpos,display_size,data_size)
'             display_y=@calc_display_offset(newypos,display_size,data_size)
'     switch& keystatus: bit 0: right Shift
'                        bit 1: left Shift
'                        bit 2: Control
'                        bit 3: Alternate
'
' PROCEDURE demo_drag() uses this routine to update
' the text in the sliderbox to match the position of
' this slider into the set range demo_min& to demo_max&:
LOCAL d
d=INT(@calc_range(demo_min,demo_max,newxpos/2+newypos/2))
~@obj_set_text(dragbox%,the_dragged,STR$(d)+CHR$(248))
RETURN
'
' ***********************************************************************
' the do_.. routines (use screencoordinates, not objects)
' ***********************************************************************
> FUNCTION do_rubberbox(rubx,ruby,wmin,hmin,wmax,hmax,prop!)
' function lets user size a box using the mouse.
' when called, the function will exit when current status
' of mousebutton changes.
' each time new coordinates are met, the function calls
' PROCEDURE do_update_rubber(x,y,neww,newh,switch), so you
' can react to these changes in real time.
' --> rubx& and ruby&   x- and y coordinates of point of origin (left top)
'     wmin& and hmin&   minimal width and height for the box
'     wmax& and hmax&   maximal width and height for the box
'     prop!             TRUE : size of box proportional to wmin& and hmin&
'                              but never bigger than wmax& and hmax& allow
'                       FALSE: draw freehand box up to maximum dimensions
' <-- combined width and height for the box
'     high_word: width, low_word: height [see function splitval()]
$F%
LOCAL mstate,neww,newh,rubw,rubh,mx,my,mb,switch
SHOWM
GRAPHMODE 3
DEFLINE &HFFFFAAAB,1,0,0              ! dotted line
~GRAF_MKSTATE(mx,my,mb,switch)
mstate=mb
IF wmin>wmax
SWAP wmin,wmax
ENDIF
IF hmin>hmax
SWAP hmin,hmax
ENDIF
wmin=MAX(1,wmin)                      ! ensure no 'divide by zero' errors
hmin=MAX(1,hmin)
rubw=MAX(wmin,MIN(wmax,mx-rubx))
IF prop!
rubh=rubw/wmin*hmin
IF rubh>hmax
rubh=hmax
rubw=rubh*wmin/hmin
ENDIF
ELSE
rubh=MAX(hmin,MIN(hmax,my-ruby))
ENDIF
BOX rubx,ruby,rubx+rubw,ruby+rubh
WHILE mb=mstate
~GRAF_MKSTATE(mx,my,mb,switch)
neww=MAX(wmin,MIN(wmax,mx-rubx))
IF prop!
newh=neww/wmin*hmin
IF newh>hmax
newh=hmax
neww=newh*wmin/hmin
ENDIF
ELSE
newh=MAX(hmin,MIN(hmax,my-ruby))
ENDIF
IF OR(rubw<>neww,rubh<>newh)
@do_update_rubber(rubx,ruby,neww,newh,switch)
BOX rubx,ruby,rubx+rubw,ruby+rubh
BOX rubx,ruby,rubx+neww,ruby+newh
rubw=neww
rubh=newh
ENDIF
WEND
~EVNT_BUTTON(257,3,mstate)            ! let AES know status of mouse
BOX rubx,ruby,rubx+rubw,ruby+rubh
RETURN SHL(rubw,16) OR CARD(rubh)
ENDFUNC
> FUNCTION do_dragbox(dragx,dragy,dragw,dragh,bigx,bigy,bigw,bigh)
' function lets user move a box within a frame
' when called, the function will exit when current status
' of mousebutton changes.
' each time new coordinates are met, the function calls
' PROCEDURE do_update_drag(newx,newy,switch), so you
' can react to these changes in real time.
' --> dragx& and dragy&   x- and y coordinates MOVABLE (small) box
'     dragw& and dragh&   width and height of MOVABLE (small) box
'     bigx& and bigy&     x- and y coordinates ENCLOSING  area
'     bigw& and bigh&     width and height of ENCLOSING area
' <-- combined coordinates x and y for the box
'     high_word: x, low_word: y [see function splitval()]
$F%
LOCAL mstate,newx,newy,mx,my,mb,switch,offx,offy
SHOWM
GRAPHMODE 3
DEFLINE &HFFFFAAAB,1,0,0              ! dotted line
~GRAF_MKSTATE(mx,my,mb,switch)
mstate=mb
offx=MOUSEX-dragx
offy=MOUSEY-dragy
xmax=bigx+bigw-dragw
ymax=bigy+bigh-dragh
BOX dragx,dragy,dragx+dragw,dragy+dragh
WHILE mb=mstate
newx=MAX(bigx,MIN(xmax,mx-offx))
newy=MAX(bigy,MIN(ymax,my-offy))
IF OR(dragx<>newx,dragy<>newy)
@do_update_drag(newx,newy,dragw,dragh,switch)
BOX dragx,dragy,dragx+dragw,dragy+dragh
BOX newx,newy,newx+dragw,newy+dragh
dragx=newx
dragy=newy
ENDIF
~GRAF_MKSTATE(mx,my,mb,switch)
WEND
~EVNT_BUTTON(257,3,mstate)            ! let AES know status of mouse
BOX dragx,dragy,dragx+dragw,dragy+dragh
RETURN SHL(dragx,16) OR CARD(dragy)
ENDFUNC
> FUNCTION do_slidebox(slx,sly,slw,slh,bigx,bigy,bigw,bigh,vertical!)
' function lets user move a box vertically OR horizontally
' when called, the function will exit when current status
' of mousebutton changes.
' each time new coordinates are met, the function calls
' PROCEDURE do_update_slider(x,y,w,h,switch,vertical!), so you
' can react to these changes in real time.
' --> slx& and sly&       x- and y coordinates MOVABLE (small) box
'     slw& and slh&       width and height of MOVABLE (small) box
'     bigx& and bigy&     x- and y coordinates ENCLOSING  area
'     bigw& and bigh&     width and height of ENCLOSING area
' <-- combined coordinates x and y for the box
'     high_word: x, low_word: y [see function splitval()]
$F%
LOCAL mstate,newpos,maxpos,mx,my,mb,switch,offm
SHOWM
GRAPHMODE 3
DEFLINE &HFFFFAAAB,1,0,0              ! dotted line
~GRAF_MKSTATE(mx,my,mb,switch)
mstate=mb
IF vertical!
offm=my-sly
maxpos=bigy+bigh-slh
slx=MIN(bigx+bigw-slw,slx)
sly=MIN(maxpos,sly)
BOX slx,sly,slx+slw,sly+slh
WHILE mb=mstate
~GRAF_MKSTATE(mx,my,mb,switch)
newpos=MAX(bigy,MIN(maxpos,my-offm))
IF sly<>newpos
@do_update_slider(slx,newpos,slw,slh,switch,TRUE)
BOX slx,sly,slx+slw,sly+slh
BOX slx,newpos,slx+slw,newpos+slh
sly=newpos
ENDIF
WEND
ELSE
offm=mx-slx
maxpos=bigx+bigw-slw
slx=MIN(maxpos,slx)
sly=MIN(bigy+bigh-slh,sly)
BOX slx,sly,slx+slw,sly+slh
WHILE mb=mstate
~GRAF_MKSTATE(mx,my,mb,switch)
newpos=MAX(bigx,MIN(maxpos,mx-offm))
IF slx<>newpos
@do_update_slider(newpos,sly,slw,slh,switch,FALSE)
BOX slx,sly,slx+slw,sly+slh
BOX newpos,sly,newpos+slw,sly+slh
slx=newpos
ENDIF
WEND
ENDIF
~EVNT_BUTTON(257,3,mstate)            ! let AES know status of mouse
BOX slx,sly,slx+slw,sly+slh
RETURN SHL(slx,16) OR CARD(sly)
ENDFUNC
' =======================================================================
' The following procedures are for your drawing code..
' If you use functions do_rubberbox(), do_slidebox() or do_dragbox()
' above, they MUST be present !
' =======================================================================
> PROCEDURE do_update_rubber(xbox,ybox,wbox,hbox,switch)
' this procedure is called everytime function do_rubberbox()
' encounters new coordinates for the rubberbox.
RETURN
> PROCEDURE do_update_slider(xbox,ybox,wbox,hbox,switch,vertical!)
RETURN
> PROCEDURE do_update_drag(xbox,ybox,wbox,hbox,switch)
RETURN
'
' ***********************************************************************
> FUNCTION splitval(value%,VAR v1,v2)
' splits a combined 4-byte value into two word-integers
v1=SWAP(value%) AND &HFFFF
v2=value% AND &HFFFF
RETURN AND(v1<>0,v2<>0)
ENDFUNC
> FUNCTION calc_max_offset(display_size,data_size)
' returns maximum display offset
' (data unit to display at top of window)
' display_size&       vertical or horizontal window size in units
'                     (can be pixels, or lines or whatever)
' data_size&          size of the total mass of data
'                     (measured in the same units as display_size)
RETURN MAX(0,data_size-display_size)
ENDFUNC
> FUNCTION calc_sliderpos(display_offset,max_offset)
$F&
' calculate new slider position
' display_offset&     number of unit at top of displayed window
' max_offset&         highest possible unit to display at top of window
IF max_offset>0
RETURN CINT(display_offset/max_offset)*1000     ! 0=top, 1000=bottom
ENDIF
RETURN 0
ENDFUNC
> FUNCTION calc_slidersize(display_size,data_size)
' calculates the size of the slider
' 0=very small, 1000 is total frame
$F&
IF data_size>0
RETURN CINT(display_size/data_size*1000)
ENDIF
RETURN 0
ENDFUNC
> FUNCTION calc_display_offset(sliderpos,display_size,data_size)
' sliderpos&          ranges from 0 (top/left) to 1000 (bottom/right)
' display_size&       the number of units (e.g. lines) you can display
' data_size&          the maximum number of units
$F&
IF data_size>display_size
RETURN CINT((sliderpos/1000)*(data_size-display_size))
ENDIF
RETURN 0
ENDFUNC
> FUNCTION calc_range(loval#,hival#,relpos)
' function returns a value belonging to a range of numbers,
' positioned relatively by relpos&.
' relpos& can be anything from 0 (top of range) to 1000
' (bottom of range), and is returned by the slider handling
' routines GRAF_SLIDEBOX, form_slidebox(), form_dragbox()
'
RETURN relpos/1000*ABS(hival#-loval#)+loval#
ENDFUNC
> FUNCTION calc_step(loval#,hival#,bar_size)
' function returns a value denoting the size of a single step
' inside a given range, relative to the full possible slider size.
' -->   bar_size&  SUCC(OB_W(tree%,obj_page)-OB_W(tree%,obj_slider))
'           or     SUCC(OB_H(tree%,obj_page)-OB_H(tree%,obj_slider))
'                  depending on horizontal or vertical movement
'
RETURN bar_size/1000*SUCC(ABS(hival#-loval#))
ENDFUNC
' ***********************************************************************
'
DEFFN obj_is_hidden(tree%,obj)=BTST(OB_FLAGS(tree%,obj),7)
> FUNCTION obj_set_text(tree%,obj,t$)
' function overwrites text in obj& with t$
' NEVER (no, never) set t$ to hold a text LONGER
' than the text the object was intended for !
' a safer way is to not update the text itself,
' but only the pointer to this text, using
' obj_set_textadr()
'
LOCAL adr%,fixadr%
SELECT BYTE(OB_TYPE(tree%,obj))
CASE 26,28,32         ! type G_BUTTON, G_STRING of G_TITLE
CHAR{OB_SPEC(tree%,obj)}=t$
RETURN TRUE
CASE 21,22,29,30      ! tedinfo
CHAR{LONG{OB_SPEC(tree%,obj)}}=t$
RETURN TRUE
CASE 31               ! G_ICON
CHAR{LONG{OB_SPEC(tree%,obj)}+8}=t$
RETURN TRUE
CASE 33               ! G_CICON
adr%=LONG{OB_SPEC(tree%,obj)+8}
IF LEN(t$)<13
t$=LEFT$(t$+STRING$(12,0),12)
BMOVE V:t$,adr%,12
ELSE                ! need to relocate it, so create fixed address
fixadr%=MALLOC(SUCC(LEN(t$)))
IF fixadr%
CHAR{fixadr%}=t$
LONG{adr%}=0
LONG{adr%+4}=CVL("XTXT")
LONG{adr%+8}=fixadr%
RETURN fixadr%  ! keep this value, so you can MFREE it again,
ENDIF             ! or do ~MFREE(@obj_get_textadr(tree%,obj))
ENDIF
DEFAULT
RETURN FALSE
ENDSELECT
RETURN TRUE
ENDFUNC
> FUNCTION obj_get_boxinfo(tree%,obj,VAR fcol,fpat,mode,ccol,bcol,bwidth,char)
' reads in drawing-attributes from a BOXINFO structure
' return: TRUE  --> parameters valid
'         FALSE --> wrong type
'
LOCAL boxinfo%
CLR tfont,tjust,bcolor,bwidth
SELECT BYTE(OB_TYPE(tree%,obj))
CASE 20,25,27             ! van het juiste type?
boxinfo%=OB_SPEC(tree%,obj)
fcol=(boxinfo% AND &X1111)         ! color fillpattern 0-15
fpat=(SHR(boxinfo%,4) AND &X111)   ! fillpattern 0-7
mode=(SHR(boxinfo%,7) AND 1)       ! modus 0=opaque, 1=transparent
ccol=(SHR(boxinfo%,8) AND &X1111)  ! character color 0-15
bcol=(SHR(boxinfo%,12) AND &X1111) ! color box border 0-15
boxinfo%=SWAP(boxinfo%)
bwidth=BYTE(boxinfo%)              ! border 1-127   thickness INSIDE
'                                           128-255 thickness OUTSIDE
char=BYTE(SHR(boxinfo%,8))         ! character for G_BOXCHAR
RETURN TRUE
ENDSELECT
RETURN FALSE
ENDFUNC
> FUNCTION obj_set_boxinfo(tree%,obj,fcol,fpat,mode,ccol,bcol,bwidth,char)
' sets drawing-attributes for a BOXINFO structure
' return: TRUE  --> set
'         FALSE --> wrong type
'
LOCAL boxinfo%
SELECT BYTE(OB_TYPE(tree%,obj))
CASE 20,25,27
boxinfo%=BYTE(char)
boxinfo%=SHL(boxinfo%,8) OR BYTE(bwidth)
boxinfo%=SWAP(boxinfo%)
boxinfo%=OR(boxinfo%,SHL((bcol AND &X1111),12))
boxinfo%=OR(boxinfo%,SHL((ccol AND &X1111),8))
boxinfo%=OR(boxinfo%,SHL((mode AND 1),7))
boxinfo%=OR(boxinfo%,SHL((fpat AND &X111),4))
boxinfo%=OR(boxinfo%,(fcol AND &X1111))
OB_SPEC(tree%,obj)=boxinfo%
RETURN TRUE
ENDSELECT
RETURN FALSE
ENDFUNC
' ======================================================================
' new tedinfo functions to replace the incomplete
' obj_get_tedattr() and obj_set_tedattr() functions.
'
> FUNCTION obj_get_tedfont(tree%,obj,VAR tfont,tfontid,tsize,tjust,tcolor,tmode)
' if your AES version => 4.1 and Speedo GDOS is loaded,
' it is possible to have other fonts in a 'tedinfo' object
' this function will tell you more about it.
' return: TRUE  --> parameters valid
'         FALSE --> wrong object type
'
LOCAL adr%
CLR tfont,tfontid,tsize,tjust,tcolor,tmode
SELECT BYTE(OB_TYPE(tree%,obj))
CASE 21,22,29,30
adr%=OB_SPEC(tree%,obj)             ! pointer to tedinfo
tfont=CARD{adr%+12}                 ! 3=IBM, 5=SMALL (6*6 font)
'  when AES => 4.1 also:              0=GDOS_proportional,
'                                     1=GDOS_monospaced
'                                     2=GDOS_bitmap
IF CARD{LONG{GB+4}}=>&H410          ! AES => 4.1?
tfontid=CARD{adr%+14}
tsize=CARD{adr%+20}               ! size in POINTS
ENDIF
tjust=CARD{adr%+16}                 ! 0=text left, 1=right, 2=centered
tcolor=SHR(CARD{adr%+18},8) AND &HF ! textcolor 0-15
tmode=ABS(BTST(CARD{adr%+18},7))    ! mode: 0=transparent, 1=opaque
RETURN TRUE
ENDSELECT
RETURN FALSE
ENDFUNC
> FUNCTION obj_set_tedfont(tree%,obj,tfont,tfontid,tsize,tjust,tcolor,tmode)
' if your AES version => 4.1 and Speedo GDOS is loaded,
' it is possible to have other fonts in a 'tedinfo' object
' this function will let you set the font attributes.
' return: TRUE  --> ok
'         FALSE --> wrong object type
'
LOCAL adr%,te_color%
SELECT BYTE(OB_TYPE(tree%,obj))
CASE 21,22,29,30
adr%=OB_SPEC(tree%,obj)             ! pointer to tedinfo
IF CARD{LONG{GB+4}}=>&H410          ! AES => 4.1?
'  when AES => 4.1 also:            0=GDOS_proportional,
'                                   1=GDOS_monospaced
'                                   2=GDOS_bitmap
CARD{adr%+12}=MAX(0,MIN(tfont,5)) ! 3=IBM, 5=SMALL (6*6 font)
CARD{adr%+14}=tfontid             ! te_fontid
CARD{adr%+20}=tsize               ! te_fontsize: size in POINTS
ELSE
CARD{adr%+12}=MAX(3,MIN(tfont,5)) ! 3=standard, 5=small font
CARD{adr%+14}=0                   ! te_resvd
CARD{adr%+20}=0                   ! te_resvd2
ENDIF
CARD{adr%+16}=MAX(0,MIN(tjust,2))   ! 0=text left, 1=right, 2=centered
te_color%=CARD{adr%+18} AND &HF07F  ! combine textcolor and mode
te_color%=te_color% OR SHL((tcolor AND &HF),8)
IF tmode                            !  tmode: 0=transparent, 1=opaque
te_color%=BSET(te_color%,7)
ENDIF
CARD{adr%+18}=te_color%
RETURN TRUE
ENDSELECT
RETURN FALSE
ENDFUNC
> FUNCTION obj_get_tedbox(tree%,obj,VAR bcolor,bpattern,bfillcol,bwidth)
' function to get the settings for the box
' attributes in a 'tedinfo' object.
' return: TRUE  --> parameters valid
'         FALSE --> wrong object type
'
LOCAL adr%
CLR bcolor,bpattern,bfillcol,bwidth
SELECT BYTE(OB_TYPE(tree%,obj))
CASE 21,22,29,30
adr%=OB_SPEC(tree%,obj)                 ! pointer to tedinfo
bcolor=SHR(CARD{adr%+18},12) AND &HF    ! color of boundary 0-15
bpattern=SHR(CARD{adr%+18},4) AND &H7   ! fillpattern used 0-7
bfillcol=CARD{adr%+18} AND &HF          ! color of fillpattern 0-15
bwidth=WORD{adr%+22}    ! positive: thickness INSIDE  ( 1 to  127)
'                         negative: thickness OUTSIDE (-1 to -127)
RETURN TRUE
ENDSELECT
RETURN FALSE
ENDFUNC
> FUNCTION obj_set_tedbox(tree%,obj,bcolor,bpattern,bfillcol,bwidth)
' function to change the settings for the box
' attributes in a 'tedinfo' object.
' return: TRUE  --> ok
'         FALSE --> wrong object type
'
LOCAL adr%,te_color%
SELECT BYTE(OB_TYPE(tree%,obj))
CASE 21,22,29,30
adr%=OB_SPEC(tree%,obj)                         ! pointer to tedinfo
te_color%=CARD{adr%+18} AND &HF80
te_color%=te_color% OR SHL((bcolor AND &HF),12) ! color of boundary 0-15
te_color%=te_color% OR SHL((bpattern AND 7),4)  ! fillpattern used 0-7
te_color%=te_color% OR (bfillcol AND &HF)       ! color of fillpattern 0-15
CARD{adr%+18}=te_color%
WORD{adr%+22}=bwidth    ! positive: thickness INSIDE  ( 1 to  127)
'                         negative: thickness OUTSIDE (-1 to -127)
RETURN TRUE
ENDSELECT
RETURN FALSE
ENDFUNC
' ======================================================================
