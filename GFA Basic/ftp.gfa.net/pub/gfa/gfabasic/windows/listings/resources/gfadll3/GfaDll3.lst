/* GFA DLL v3.0.1
/* by Bev Brown
/* Jun.01/97

$LIBRARY gfadll3
$LNK EXE e:\langua~1\gfaw\dll_32\GfaDll3.dll
'
PROCEDURE libmain(inst&,dseg&,hpsz&,lpcmd#)
  DEFINT "a-z"
  bwcchandle& = LoadLibrary("bwcc.dll")
  DLL #1,"bwcc.dll"
    DECL WORD bwccMessageBox(w,l,l,w)
  ENDDLL
  '
  DLL #2,"kernel"
    DECL LONG FindFirstFile(l,l)
    DECL BOOL FindNextFile(l,l)
    DECL BOOL FindClose(l)
    DECL BOOL SetCurrentDirectory(l)
  ENDDLL
  '
  DIM drv_param(25)
  black& = GETNEAREST(0,0,0),white& = GETNEAREST(255,255,255)
  gray& = GETNEAREST(128,128,128),ltgray& = GETNEAREST(192,192,192)
  blue& = GETNEAREST(0,0,255),ltblue& = GETNEAREST(0,255,255)
  red& = GETNEAREST(128,0,0),ltred& = GETNEAREST(255,0,0)
  black = RGB(0,0,0),white = RGB(255,255,255)
  ltgray = RGB(192,192,192),gray = RGB(128,128,128)
  ltblue = RGB(0,255,255),blue = RGB(0,0,255)
  ltred = RGB(255,0,0),red = RGB(128,0,0)
  yellow = RGB(255,255,0),green = RGB(0,128,0)
  dpbstyle = BS_DEFPUSHBUTTON | WS_TABSTOP
  pbstyle = BS_PUSHBUTTON | WS_TABSTOP
  dis_style = pbstyle | WS_DISABLED
  temp = MB_APPLMODAL | MB_DEFBUTTON1
  style0 = WS_BORDER | DS_SYSMODAL | WS_THICKFRAME
  style1 = temp | MB_ICONINFORMATION | MB_OK
  temp = temp | MB_ICONQUESTION
  style2 = temp | MB_YESNO
  style3 = temp | MB_OKCANCEL
  style4 = temp | MB_YESNOCANCEL
  style5 = temp | MB_ABORTRETRYIGNORE
  cr$ = CHR$(13) + CHR$(10)
  @SetFonts
  @drives
  '
  TYPE dta:
  - CHAR*21 fs_DontTouch$
  - BYTE    fs_Attr
  - CARD    fs_Time
  - CARD    fs_Date
  - LONG    fs_Size
  - CHAR*14 fs_Name$
  ENDTYPE
  '
  TYPE FIND_DATA:
  - LONG Attribute
  - CHAR*40 Dummy$
  - CHAR*260 FileName$          /* Win95-File Name
  - CHAR*14 DOSFileName$        /* DOS-File Name
  ENDTYPE
  FIND_DATA:FIND_DATA.
  '
  FILE_ATTRIBUTE_ARCHIVE       = $00000020
  FILE_ATTRIBUTE_DIRECTORY     = $00000010
  FILE_ATTRIBUTE_HIDDEN        = $00000002
  FILE_ATTRIBUTE_NORMAL        = $00000080
  FILE_ATTRIBUTE_READONLY      = $00000001
  FILE_ATTRIBUTE_SYSTEM        = $00000004
  FILE_ATTRIBUTE_TEMPORARY     = $00000100
  FILE_ATTRIBUTE_ATOMIC_WRITE  = $00000200
  FILE_ATTRIBUTE_XACTION_WRITE = $00000400
  '
  RETVAL -1
RETURN
'
PROCEDURE web(flg&)
  ~FreeLibrary(bwcchandle&)
  RETVAL 0
RETURN
'
PROCEDURE SetFonts
  FONT "courier new",WEIGHT FW_NORMAL,HEIGHT 65523,WIDTH 7
  FONT FAMILY FF_ROMAN,CHARSET ANSI_CHARSET
  FONT TO fnt&
  FONT "courier new",WEIGHT FW_BOLD,HEIGHT 65523,WIDTH 7
  FONT FAMILY FF_ROMAN,CHARSET ANSI_CHARSET
  FONT TO fntbold&
  RETVAL 0
RETURN
'
PROCEDURE set_dir(temp$)
  drv = ASC(UPPER$(LEFT$(temp$)))
  CHDRIVE drv
  CHDIR temp$
RETURN
'
PROCEDURE lbutdown(i,j)
  ~SendMessage(DLGITEM(i,j),WM_LBUTTONDOWN,0,0)
  PAUSE 6
  RETVAL 0
RETURN
'
PROCEDURE bell
  LOCAL i
  FOR i = 0 TO 2
    SOUND 3000,0.5
    PAUSE 1
  NEXT i
  RETVAL 0
RETURN
'
PROCEDURE sound
  LOCAL i
  FOR i = 0 TO 2
    SOUND 300,0.5
    PAUSE 1
  NEXT i
  RETVAL 0
RETURN
'
PROCEDURE drives
  LOCAL i
  drv = _DRIVE
  CLR drv_flg!
  FOR i = ASC("A") TO ASC("Z")
    CHDRIVE i
    IF i = _DRIVE THEN  drv_flg = BSET(drv_flg,i - 65)
  NEXT i
  CHDRIVE drv
RETURN
'
PROCEDURE status(b2,h2,pas,info$,bgrnd)
  IF b2 < 558 THEN b2 = 558
  DIALOG #26,(b2 - 558) \ 2,h2,558,64,subtit$,style0,65523,"courier new bold"
    CTEXT "",1000,4,12,548,16
  ENDDIALOG
  DLG FILL 26,bgrnd
  SHOWDIALOG #26
  _WIN$(DLGITEM(26,1000)) = info$
  ~SetFocus(DLGITEM(26,1000))
  PAUSE pas
  CLOSEDIALOG #26
  RETVAL 0
RETURN
'
PROCEDURE Box3D(x1&,y1&,w&,h&,colr,flg|)
  DEFFILL 0
  DEFLINE 0,1
  RGBCOLOR colr
  colx = white,coly = gray
  IF flg| = 2 OR flg| = 4 THEN SWAP colx,coly
  SELECT flg|
  CASE 1,2            /* 1=raised area 2=inset area
    PBOX x1&,y1&,x1& + w&,y1& + h&
    RGBCOLOR colx
    DRAW x1& + 3,y1& + h& - 6 TO x1& + 3,y1& + 3 TO x1& + w& - 6,y1& + 3
    RGBCOLOR coly
    DRAW TO x1& + w& - 6,y1& + h& - 6 TO x1& + 3,y1& + h& - 6
  CASE 3,4            /* 3=raised border 4=inset border
    PBOX x1& + 3,y1& + 3,x1& + w& - 6,y1& + h& - 6
    RGBCOLOR colx
    BOX x1& + 4,y1& + 4,x1& + w& - 7,y1& + h& - 7
    RGBCOLOR coly
    BOX x1& + 3,y1& + 3,x1& + w& - 6,y1& + h& - 6
  ENDSELECT
  RETVAL 0
RETURN
'
PROCEDURE coltext(txt$,colr,x1&,y1&,w&,h&,flg|)
  GRAPHMODE R2_COPYPEN,TRANSPARENT
  RGBCOLOR colr
  DRAWTEXT x1&,y1&,w& + x1&,h& + y1&,txt$,flg|
  RETVAL 0
RETURN
'
PROCEDURE error_handler
  DEFMOUSE 0
  CLOSE
  BEEP
  mess$ = "Error #" + STR$(ERR) + cr$ + ERR$(ERR)
  ~^bwccMessageBox(WIN(0),mess$,subtit$,style1)
  RETVAL 0
RETURN
/*
PROCEDURE drvsel(ptr,b1,h1,a)
  $EXPORT drvsel
  TRY
    temp$ = CHAR{ptr}
    SYSCOL COLOR_GRAYTEXT,white&,0
    FOR i = 0 TO 25
      drv_param(i) = dis_style
      IF BTST(drv_flg,i) THEN drv_param(i) = pbstyle
      IF i = a - 65 THEN drv_param(i) = dpbstyle
    NEXT i
    DIALOG #31,(b1 - 236) \ 2,h1,236,300,temp$,style0,65520,"courier new"
      FOR i = 0 TO 3
        FOR j = 0 TO 6
          x = i * 7 + j
          IF x = 0
            STATIC "Choose",100,2,15,66,20,SS_CENTER | WS_DISABLED
          ELSE IF x = 27
            CONTROL "",IDCANCEL,"BorBtn",pbstyle,10 + 3 * 50,10 + 6 * 36,64,49
          ELSE
            BUTTON "&" + CHR$(x + 64),100 + x,20 + i * 50,10 + j * 36,32,32,drv_param(x - 1)
          ENDIF
        NEXT j
      NEXT i
    ENDDIALOG
    DLG FILL 31,gray
    SHOWDIALOG #31
    ~SetFocus(DLGITEM(31,a + 100 - 64))
    @bell
    CLR drv
    DO
      PEEKEVENT
      SELECT _Mess
      CASE WM_RBUTTONDOWN
        drv = -1
      CASE WM_KEYDOWN
        SELECT _wParam
        CASE 65 TO 90
          temp = _wParam
          IF BTST(drv_flg,temp - 65)
            drv = temp
            @lbutdown(31,100 + drv + 65)
          ENDIF
        ENDSELECT
      CASE WM_SYSKEYDOWN
        SELECT _wParam
        CASE 67,VK_F4
          drv = -1
          @lbutdown(31,IDCANCEL)
        ENDSELECT
      CASE WM_COMMAND
        SELECT _wParam
        CASE 101 TO 126
          drv = _wParam - 100 + 64
        CASE IDCANCEL
          drv = -1
        ENDSELECT
      ENDSELECT
    LOOP UNTIL drv <> 0
    REPEAT
    UNTIL !MOUSEK
    CLOSEDIALOG #31
    SYSCOL COLOR_GRAYTEXT,ltgray&,0
    RETVAL drv
  CATCH
  @error_handler
  drv = -1
  CLOSEDIALOG #31
  SYSCOL COLOR_GRAYTEXT,ltgray&,0
  RETVAL drv
RETURN
/*
PROCEDURE free(b1,h1,a)
  $EXPORT free
  subtit$ = "Free Space"
  temp$ = subtit$ + CHR$(0)
  ptr = V:temp$
  @drvsel(ptr,b1,h1,a)
  IF drv = -1
    BEEP
    pas = 35
    temp$ = "No Drive chosen!"
  ELSE
    IF drv < 67
      @bell
      mess$ = "Insert a disk in Drive " + CHR$(drv) + "!"
      j = ^bwccMessageBox(WIN(0),mess$,subtit$,style3)
      IF j = IDCANCEL
        pas = 35
        temp$ = "Aborted!"
        GOTO abort_free
      ENDIF
    ENDIF
    dfre = DFREE(drv - 64)
    @change_it(dfre)
    pas = 54
    temp$ = "Drive " + CHR$(drv) + ": " + hold$ + " (" + STR$(dfre) + " bytes)"
  ENDIF
  abort_free:
  DEFMOUSE 0
  ~^bwccMessageBox(WIN(0),temp$,subtit$,style1)
  RETVAL 0
RETURN
/*
PROCEDURE input_string(tptr,iptr,pptr,sptr,ln&,b1,h1)
  $EXPORT input_string
  SETFONT fnt&
  temp$ = CHAR{tptr}
  info$ = CHAR{iptr}
  prompt$ = CHAR{pptr}
  prompt$ = prompt$ + " "
  strng$ = CHAR{sptr}
  ww = LEN(prompt$) * 8
  IF b1 < 200 THEN b1 = 200
  IF b1 > _X - 4 THEN b1 = _X - 4
  SYSCOL COLOR_GRAYTEXT,ltred&,0
  DIALOG #29,(_X - b1) \ 2,h1,b1,144,temp$,style0,65523,"courier new"
    CTEXT info$,1000,10,10,b1 - 20,20
    STATIC prompt$,1001,10,40,ww,20,SS_RIGHT | WS_DISABLED
    temp = WS_TABSTOP | WS_BORDER | ES_AUTOVSCROLL
    EDITTEXT "",1002,10 + ww,38,b1 - (20 + ww),20,temp
    CONTROL "",IDOK,"BorBtn",pbstyle,b1 \ 2 - 84,70,64,40
    CONTROL "",IDCANCEL,"BorBtn",pbstyle,b1 \ 2 + 20,70,64,40
  ENDDIALOG
  SENDMESSAGE DLGITEM(29,1002),EM_LIMITTEXT,ln&,0
  _WIN$(DLGITEM(29,1002)) = strng$
  SHOWDIALOG #29
  DLG FILL 29,gray
  @bell
  ~SetFocus(DLGITEM(29,1002))
  finit! = FALSE
  DO
    PEEKEVENT
    SELECT _Mess
    CASE WM_RBUTTONDOWN
      finit! = TRUE
      _WIN$(DLGITEM(29,1002)) = ""
    CASE WM_COMMAND
      SELECT _wParam
      CASE IDOK
        finit! = TRUE
      CASE IDCANCEL
        finit! = TRUE
        _WIN$(DLGITEM(29,1002)) = ""
      ENDSELECT
    CASE WM_SYSKEYDOWN
      SELECT _wParam
      CASE 79
        finit! = TRUE
        @lbutdown(29,IDOK)
      CASE 67,VK_F4
        finit! = TRUE
        _WIN$(DLGITEM(29,1002)) = ""
        @lbutdown(29,IDCANCEL)
      ENDSELECT
    ENDSELECT
  LOOP UNTIL finit!
  REPEAT
  UNTIL !MOUSEK
  strng$ = _WIN$(DLGITEM(29,1002))
  CLOSEDIALOG #29
  SYSCOL COLOR_GRAYTEXT,ltgray&,0
  strng$ = strng$ + CHR$(0)
  CHAR{sptr} = strng$
  RETVAL 0
RETURN
/*
PROCEDURE chk_valu(lo,hi,ptr)
  $EXPORT chk_valu
  subtit$ = "Value Check"
  temp$ = CHAR{ptr}
  IF VAL?(temp$)
    x = VAL(temp$)
    IF x < lo OR x > hi
      BEEP
      temp$ = "Out of Range ..."
      ~^bwccMessageBox(WIN(0),mess$,subtit$,style1)
      flg! = FALSE
    ELSE
      flg! = TRUE
    ENDIF
  ELSE
    BEEP
    temp$ = "Input Error, NOT numeric!"
    ~^bwccMessageBox(WIN(0),mess$,subtit$,style1)
    flg! = FALSE
  ENDIF
  RETVAL flg!
RETURN
/*
PROCEDURE fileselect(ptr,fptr,tptr,eptr,b2,h2,flg&)
  $EXPORT fileselect
  TRY
    IF b2 < 340 THEN b2 = 340
    SELECT flg&
    CASE 1
      fgrnd& = red&,bgrnd = gray
    CASE 2
      fgrnd& = blue&,bgrnd = ltgray
    CASE 3
      fgrnd& = blue&,bgrnd = green
    ENDSELECT
    xpath$ = CHAR{ptr}
    orig_path$ = xpath$
    filename$ = CHAR{fptr}
    subtit$ = CHAR{tptr}
    filter$ = CHAR{eptr}
    stylex = WS_CHILD | WS_VISIBLE
    SYSCOL COLOR_GRAYTEXT,fgrnd&,0
    DIALOG #30,(b2 - 340) \ 2,h2,340,308,subtit$,style0,65524,"courier new"
      STATIC "Folder:",1000,4,6,52,16,WS_DISABLED
      STATIC "",1001,60,4,260,18,WS_BORDER
      temp = stylex | LBS_HASSTRINGS | WS_TABSTOP
      temp = temp | LBS_NOTIFY | WS_BORDER | WS_VSCROLL
      LISTBOX "",1002,4,48,232,236,temp
      STATIC "Drives:",1003,244,54,60,16,WS_DISABLED
      COMBOBOX "",1004,244,72,64,400,temp | CBS_DROPDOWNLIST
      STATIC "FileName:",1005,4,28,66,16,WS_DISABLED
      IF flg& = 1
        temp = stylex | ES_LEFT | WS_BORDER | ES_AUTOHSCROLL | WS_TABSTOP
        EDITTEXT "",1006,72,26,228,18,temp
      ELSE
        temp = stylex | WS_BORDER
        STATIC "",1006,72,26,228,18,temp
      ENDIF
      CONTROL "",IDOK,"BorBtn",dpbstyle,246,156,64,40
      CONTROL "",IDCANCEL,"BorBtn",pbstyle,246,200,64,40
    ENDDIALOG
    DLG FILL 30,bgrnd
    SHOWDIALOG #30
    @FillListBox(30)
    ~SetFocus(DLGITEM(30,1002))
    CLR finit!,flg!
    DO
      PEEKEVENT
      SELECT _Mess
      CASE WM_RBUTTONDOWN
        finit! = TRUE
        _WIN$(DLGITEM(30,1006)) = ""
      CASE WM_SYSKEYDOWN
        SELECT _wParam
        CASE 79
          finit! = TRUE,flg! = TRUE
          @lbutdown(30,IDOK)
        CASE 67,VK_F4
          finit! = TRUE
          @lbutdown(30,IDCANCEL)
          _WIN$(DLGITEM(30,1006)) = ""
        ENDSELECT
      CASE WM_COMMAND
        SELECT _wParam
        CASE 1002
          SELECT HIWORD(_lParam)
          CASE LBN_SELCHANGE
            @get_sel(30)
            _WIN$(DLGITEM(30,1006)) = MID$(txt$(lsel&),50)
          CASE LBN_DBLCLK
            @get_sel(30)
            temp$ = TRIM$(LEFT$(temp$,12))
            IF temp$ = ".."
              xpath$ = LEFT$(xpath$,LEN(xpath$) - 1)
              i = RINSTR(xpath$,"\")
              xpath$ = LEFT$(xpath$,i)
            ELSE IF BTST(temp,4)
              xpath$ = xpath$ + temp$ + "\"
            ENDIF
            @FillListBox(30)
          ENDSELECT
        CASE 1004
          SENDMESSAGE DLGITEM(30,1004),CB_GETCURSEL,0,0,lsel&
          IF lsel& = -1
            BEEP
          ELSE
            temp$ = SPACE$(6)
            SENDMESSAGE DLGITEM(30,1004),CB_GETLBTEXT,lsel&,V:temp$
            drv = ASC(UPPER$(MID$(temp$,3)))
            xpath$ = CHR$(drv) + ":\"
            @FillListBox(30)
          ENDIF
        CASE IDOK
          finit! = TRUE,flg! = TRUE
        CASE IDCANCEL
          finit! = TRUE
          _WIN$(DLGITEM(30,1006)) = ""
        ENDSELECT
      ENDSELECT
      REPEAT
      UNTIL !MOUSEK
    LOOP UNTIL finit!
    CLR test|
    IF flg!
      IF flg& = 3
        filename$ = txt$(lsel&)
      ELSE
        filename$ =  LEFT$(txt$(lsel&),12)
      ENDIF
      IF filename$ = ".." THEN filename$ = ""
      FOR i = 0 TO 4
        IF BTST(txt(lsel&),i) THEN test| = i + 1
      NEXT i
    ENDIF
    xpath$ = xpath$ + CHR$(0)
    filename$ = filename$ + CHR$(0)
    CLOSEDIALOG #30
    SYSCOL COLOR_GRAYTEXT,ltgray&,0
    CHAR{ptr} = xpath$
    CHAR{fptr} = filename$
    RETVAL test|
  CATCH
  CLOSEDIALOG #30
  SYSCOL COLOR_GRAYTEXT,ltgray&,0
  @error_handler
  filename$ = CHR$(0),xpath$ = orig_path$ + CHR$(0)
  CHAR{ptr} = xpath$
  CHAR{fptr} = filename$
  RETVAL 0
RETURN
'
PROCEDURE get_sel(db&)
  SENDMESSAGE DLGITEM(db&,1002),LB_GETCURSEL,0,0,lsel&
  temp$ = txt$(lsel&)
  temp = txt(lsel&)
RETURN
'
PROCEDURE chek_Path_len(ln&)
  hold$ = LOWER$(xpath$)
  IF LEN(hold$) > ln& THEN hold$ = LEFT$(hold$,3) + "..." + RIGHT$(hold$,ln& - 6)
  RETVAL 0
RETURN
'
PROCEDURE FillListBox(db&)
  LOCAL i
  @set_dir(xpath$)
  @chek_Path_len(36)
  _WIN$(DLGITEM(db&,1001)) = hold$
  @get_dir
  SENDMESSAGE DLGITEM(db&,1002),LB_RESETCONTENT,0,0
  SENDMESSAGE DLGITEM(db&,1004),CB_RESETCONTENT,0,0
  FOR i = 0 TO ctr - 1
    IF db& = 23
      temp$ = LEFT$(txt$(i),47)
    ELSE
      temp$ = TRIM$(MID$(txt$(i),50))
    ENDIF
    ~SendMessage(DLGITEM(db&,1002),LB_ADDSTRING,0,temp$)
  NEXT i
  ~SendMessage(DLGITEM(db&,1004),CB_DIR,$4000,CHR$(0))
  ~SendMessage(DLGITEM(db&,1002),LB_SETCURSEL,0,0)
  IF db& <> 28 THEN _WIN$(DLGITEM(db&,1006)) = TRIM$(LEFT$(txt$(0),12))
  RETVAL 0
RETURN
'
PROCEDURE W95GetName(temp$)
  LOCAL SearchHandle&
  xName$ = temp$ + CHR$(0)
  SearchHandle& = ^FindFirstFile(V:xName$,V:FIND_DATA.)
  IF SearchHandle& = -1
    xName$ = ""
  ELSE
    ~^FindClose(SearchHandle&)
    xName$ = ZTRIM$(FIND_DATA.FileName$)
  ENDIF
  RETVAL 0
RETURN
'
PROCEDURE DOSGetName(temp$)
  LOCAL SearchHandle&
  hold$ = temp$ + CHR$(0)
  SearchHandle& = ^FindFirstFile(V:hold$,V:FIND_DATA.)
  IF SearchHandle& = -1
    hold$ = ""
  ELSE
    ~^FindClose(SearchHandle&)
    IF ZTRIM$(FIND_DATA.DOSFileName$) = ""
      hold$ = ZTRIM$(FIND_DATA.FileName$)
    ELSE
      hold$ = ZTRIM$(FIND_DATA.DOSFileName$)
    ENDIF
  ENDIF
  RETVAL 0
RETURN
'
PROCEDURE get_dir
  LOCAL SearchHandle&,temp$,i
  ERASE txt$(),txt()
  DIM txt$(4096),txt(4096)
  CLR ctr
  dta = FGETDTA()
  SearchHandle& = FSFIRST(xpath$ + "*.*",$3F)
  WHILE !SearchHandle& AND ctr < 4096
    tempName$ = {dta}.fs_Name$
    temp = {dta}.fs_Attr
    i = RINSTR(tempName$,".")
    temp$ = RIGHT$(tempName$,i + 1)
    IF tempName$ <> "."
      IF tempName$ = ".." OR BTST(temp,3)
        xName$ = tempName$
      ELSE
        @W95GetName(tempName$)
      ENDIF
      IF BTST(temp,4) OR BTST(temp,3)
        tempName$ = UPPER$(tempName$)
        xName$ = UPPER$(xName$)
        flg! = FALSE
      ELSE
        tempName$ = LOWER$(tempName$)
        xName$ = LOWER$(xName$)
        flg! = TRUE
      ENDIF
      i = RINSTR(tempName$,".")
      test$ = MID$(tempName$,i + 1)
      IF filter$ <> "*" AND flg! AND LOWER$(test$) <> LOWER$(filter$) THEN GOTO bypass
      txt$(ctr) = SPACE$(310)
      txt(ctr) = temp
      LSET txt$(ctr) = tempName$
      IF tempName$ = ".."
        MID$(txt$(ctr),21) = "0"
      ELSE IF BTST(txt(ctr),4)
        MID$(txt$(ctr),17) = "<Dir>"
      ELSE IF BTST(txt(ctr),3)
        MID$(txt$(ctr),16) = "<Name>"
      ELSE
        MID$(txt$(ctr),13) = STR$({dta}.fs_Size,9)
      ENDIF
      i = {dta}.fs_Date
      temp$ = DEC$((i >> 5) & 15,2) + "/" + DEC$(i & 31,2) + "/" + DEC$((i >> 9) + 80,2)
      MID$(txt$(ctr),23) = temp$
      temp$ = DEC$((i >> 11 ),2) + ":" + DEC$((i >> 5 & 63),2) + ":" + DEC$((i & 31) * 2,2)
      MID$(txt$(ctr),32) = temp$
      IF BTST(txt(ctr),5) THEN MID$(txt$(ctr),42) = "A"
      IF BTST(txt(ctr),4) THEN MID$(txt$(ctr),43) = "D"
      IF BTST(txt(ctr),3) THEN MID$(txt$(ctr),44) = "N"
      IF BTST(txt(ctr),2) THEN MID$(txt$(ctr),45) = "S"
      IF BTST(txt(ctr),1) THEN MID$(txt$(ctr),46) = "H"
      IF BTST(txt(ctr),0) THEN MID$(txt$(ctr),47) = "P"
      MID$(txt$(ctr),50) = xName$
      ctr ++
      bypass:
    ENDIF
    SearchHandle& = FSNEXT()
  WEND
  IF ctr THEN QSORT txt$() OFFSET 49,ctr,txt()
  IF ctr = 4096
    @bell
    mess$ = "First 4096 entries only!"
    ~^bwccMessageBox(WIN(0),mess$,subtit$,style1)
  ENDIF
  /* RETVAL 0
RETURN
/*
PROCEDURE meter(x&,y&,mw&,mht&,mfg,bbg,bfg,percent&,msg)
  $EXPORT meter
  SETFONT fntbold&
  IF percent& = 0 AND WIN(20) = 0
    OPENW #20,x&,y&,0,0,WS_VISIBLE
    hw = GetTextExtent(_DC(20),msg,99)
    ht& = HIWORD(hw)
    height& = mht& + ht& / 2 + 6
    CLR line1$,line2$
    IF msg > 0
      height& = height& + ht& * 2
      msg$ = CHAR{msg}
      pos& = INSTR(msg$,"|")
      IF pos& > 0
        height& = height& + ht&
        line1$ = LEFT$(msg$,pos& - 1)
        line2$ = MID$(msg$,pos& + 1)
      ELSE
        line1$ = msg$
      ENDIF
    ENDIF
    ~MoveWindow(WIN(20),x&,y&,mw&,height&,-1)
    mode| = DT_SINGLELINE | DT_CENTER | DT_VCENTER
    @Box3D(0,0,mw&,height&,bbg,1)
    @Box3D(6,height& - (mht& + 3) - 10,mw& - 12,mht& + 6,ltgray,4)
    IF line1$ <> "" THEN @coltext(line1$,bfg,10,ht& / 2,mw& - 20,ht&,mode|)
    IF line2$ <> "" THEN @coltext(line2$,bfg,10,ht& / 2 + ht&,mw& - 20,ht&,mode|)
  ENDIF
  distance& = INT((mw& - 27) * (percent& / 100))
  @Box3D(6,height& - (mht& + 3) - 10,6 + distance&,mht& + 6,gray,3)
  @Box3D(6 + distance&,height& - (mht& + 3) - 10,mw& - 15 - distance&,mht& + 6,ltgray,4)
  @coltext(STR$(percent&) + "%",mfg,9,height& - mht& - 7,mw& - 21,mht& - 6,mode|)
  IF percent& = 100
    @Box3D(6,height& - (mht& + 3) - 10,mw& - 12,mht& + 6,gray,3)
    @coltext("100%",mfg,9,height& - mht& - 7,mw& - 21,mht& - 6,mode|)
    PAUSE 18
    CLOSEW #20
  ENDIF
  RETVAL 0
RETURN
/*
PROCEDURE list(sx,sy,sb,sh,fgrnd,bgrnd,ptr,max_lines)
  $EXPORT list
  filename$ = CHAR{ptr}
  IF !EXIST(filename$)
    BEEP
    mess$ = "Can NOT find " + filename$ + "!"
    ~^bwccMessageBox(WIN(0),mess$,subtit$,style1)
  ELSE
    ERASE txt$()
    DIM txt$(max_lines)
    OPEN "i",#3,filename$
    RECALL #3,txt$(),-1,cnt
    CLOSE #3
    vpos& = 1,hpos& = 1,finit! = FALSE
    TITLEW #1,filename$
    OPENW #1,sx,sy,sb,sh,-1
    SETDC _DC(1)
    SETFONT fnt&
    CLS bgrnd
    WINDGET 7,hb
    WINDGET 14,height&
    scrn_lines& = hb \ height&
    CB WIN(1),0 TO -1,callback
    ~SetScrollRange(WIN(1),SB_VERT,1,cnt - 1,-1)
    ~SetScrollRange(WIN(1),SB_HORZ,1,80,-1)
    RGBCOLOR fgrnd,bgrnd
    @bell
    @text_display
    DO
      PEEKEVENT
      SELECT _Mess
      CASE WM_RBUTTONDOWN
        finit! = TRUE
        REPEAT
        UNTIL !MOUSEK
      CASE WM_KEYDOWN
        @keyboard_routine
      ENDSELECT
      SELECT MENU(1)
      CASE 4
        finit! = TRUE
      CASE 21
        @text_display
      ENDSELECT
    UNTIL finit!
    CLOSEW #1
  ENDIF
  RETVAL 0
RETURN
'
PROCEDURE text_display
  HIDEM
  WINDGET 14,height&
  WINDGET 20,width&
  scrn_lines& = hb \ height&
  y_pos = height&,text_line = vpos& - 1
  WINDGET 6,wb
  max_chr = wb \ width&
  REPEAT
    temp$ = MID$(txt$(text_line),hpos&,max_chr)
    IF LEN(temp$) < wb \ width& - 1 THEN temp$ = temp$ + SPACE$(max_chr - LEN(temp$))
    TEXT 2,y_pos - height&,temp$
    ADD y_pos,height&
    text_line ++
  UNTIL y_pos > hb OR text_line = cnt
  SHOWM
  RETVAL 0
RETURN
'
PROCEDURE callback(handle&,mess&,wparam&,lparam)
  SELECT mess&
  CASE WM_VSCROLL
    vpos& = GetScrollPos(handle&,SB_VERT)
    SELECT wparam&
    CASE SB_LINEUP
      vpos& --
    CASE SB_LINEDOWN
      vpos& ++
    CASE SB_PAGEUP
      SUB vpos&,scrn_lines& - 1
    CASE SB_PAGEDOWN
      ADD vpos&,scrn_lines& - 1
    CASE SB_THUMBTRACK
      vpos& = LOWORD(lparam)
    ENDSELECT
    @check_vpos(handle&)
  CASE WM_HSCROLL
    hpos& = GetScrollPos(handle&,SB_HORZ)
    SELECT wparam&
    CASE SB_LINEUP
      hpos& --
    CASE SB_LINEDOWN
      hpos& ++
    CASE SB_PAGEUP
      SUB hpos&,40
    CASE SB_PAGEDOWN
      ADD hpos&,40
    CASE SB_THUMBTRACK
      hpos& = LOWORD(lparam)
    ENDSELECT
    @check_hpos(handle&)
  ENDSELECT
RETURN
'
PROCEDURE keyboard_routine
  SELECT MENU(12)
  CASE 33 TO 36,38,40
    SELECT _wParam
    CASE VK_PRIOR
      SUB vpos&,scrn_lines& - 1
    CASE VK_NEXT
      ADD vpos&,scrn_lines& - 1
    CASE VK_END
      vpos& = cnt - 1
    CASE VK_HOME
      vpos& = 1
    CASE VK_UP
      vpos& --
    CASE VK_DOWN
      vpos& ++
    ENDSELECT
    @check_vpos(WIN(1))
  CASE 37,39
    SELECT _wParam
    CASE VK_RIGHT
      hpos& ++
    CASE VK_LEFT
      hpos& --
    ENDSELECT
    @check_hpos(WIN(1))
  CASE VK_ESCAPE
    finit! = TRUE
  DEFAULT
    BEEP
  ENDSELECT
  RETVAL 0
RETURN
'
PROCEDURE check_vpos(handle&)
  vpos& = MIN(vpos&,cnt - scrn_lines& + 1)
  vpos& = MAX(vpos&,1)
  ~SetScrollPos(handle&,SB_VERT,vpos&,-1)
  @text_display
  RETVAL 0
RETURN
'
PROCEDURE check_hpos(handle&)
  hpos& = MAX(hpos&,1)
  hpos& = MIN(hpos&,80)
  ~SetScrollPos(handle&,SB_HORZ,hpos&,-1)
  @text_display
  RETVAL 0
RETURN
/*
PROCEDURE create_Sarray
  LOCAL i,j,k,a,start
  ERASE stxt$(),stxt()
  DIM stxt$(4096),stxt(4096)
  CLR start,cnt
  FOR i = 0 TO ctr - 1
    IF mark!(i)
      filename$ = TRIM$(LEFT$(txt$(i),12))
      IF LEFT$(filename$,1) <> "." AND !BTST(txt(i),3)
        stxt$(cnt) = xpath$ + filename$
        stxt(cnt) = txt(i)
        cnt ++
      ENDIF
    ENDIF
  NEXT i
  a = cnt - 1
  next_level:
  CLR saflg!
  FOR k = start TO start + a
    IF BTST(stxt(k),4)
      xpath$ = stxt$(k)
      IF RIGHT$(xpath$) <> "\" THEN xpath$ = xpath$ + "\"
      @get_dir
      IF ctr
        FOR j = 0 TO ctr - 1
          temp$ = TRIM$(LEFT$(txt$(j),12))
          IF LEFT$(temp$,1) <> "." AND !BTST(txt(j),3)
            stxt$(cnt) = xpath$ + temp$
            stxt(cnt) = txt(j)
            IF BTST(stxt(cnt),4) THEN saflg! = TRUE
            cnt ++
          ENDIF
        NEXT j
      ENDIF
    ENDIF
  NEXT k
  IF saflg!
    start = a + 1,a = cnt - start
    GOTO next_level
  ENDIF
  RETVAL 0
RETURN
/*
PROCEDURE kill(ptr,b1,h1)
  $EXPORT kill
  TRY
    xpath$ = CHAR{ptr}
    subtit$ = "Kill File(s)"
    filter$ = "*"
    IF b1 < 340 THEN b1 = 340
    stylex = WS_CHILD | WS_VISIBLE
    SYSCOL COLOR_GRAYTEXT,white&,0
    DIALOG #28,(b1 - 340) \ 2,h1,340,308,subtit$,style0,65524,"courier new"
      STATIC "Folder:",1000,4,6,52,16,WS_DISABLED
      STATIC "",1001,60,4,260,18,WS_BORDER
      temp = stylex | LBS_NOTIFY | LBS_HASSTRINGS | WS_TABSTOP | WS_BORDER | WS_VSCROLL
      LISTBOX "",1002,4,26,220,248,temp | LBS_MULTIPLESEL | LBS_EXTENDEDSEL
      STATIC "Drives:",1003,256,26,72,16,WS_DISABLED
      COMBOBOX "",1004,246,42,72,400,temp | CBS_DROPDOWNLIST
      CONTROL "",IDOK,"BorBtn",dpbstyle,246,156,64,40
      CONTROL "",IDCANCEL,"BorBtn",pbstyle,246,200,64,40
    ENDDIALOG
    DLG FILL 28,ltred
    SHOWDIALOG #28
    @FillListBox(28)
    ~SetFocus(DLGITEM(28,1002))
    CLR finit!,flg!,all_sel!
    DO
      PEEKEVENT
      sel = _Mess
      SELECT sel
      CASE WM_RBUTTONDOWN
        IF _hWnd = DLGITEM(28,1002)
          all_sel! = !all_sel!
          FOR i = 0 TO ctr - 1
            ~SendMessage(DLGITEM(28,1002),LB_SETSEL,all_sel!,i)
          NEXT i
        ELSE
          finit! = TRUE
          @lbutdown(28,IDCANCEL)
        ENDIF
      CASE WM_SYSKEYDOWN
        SELECT _wParam
        CASE 79
          finit! = TRUE,flg! = TRUE
          @lbutdown(28,IDOK)
        CASE 67,VK_F4
          finit! = TRUE
          @lbutdown(28,IDCANCEL)
        ENDSELECT
      CASE WM_COMMAND
        SELECT _wParam
        CASE 1002
          SELECT HIWORD(_lParam)
          CASE LBN_SELCHANGE
            @bell
          CASE LBN_DBLCLK
            @get_sel(28)
            temp$ = TRIM$(LEFT$(temp$,12))
            IF temp$ = ".."
              xpath$ = LEFT$(xpath$,LEN(xpath$) - 1)
              i = RINSTR(xpath$,"\")
              xpath$ = LEFT$(xpath$,i)
            ELSE IF BTST(temp,4)
              xpath$ = xpath$ + temp$ + "\"
            ENDIF
            @FillListBox(28)
          ENDSELECT
        CASE 1004
          temp = SendMessage(DLGITEM(28,1004),CB_GETCURSEL,0,0)
          IF temp = -1
            BEEP
          ELSE
            temp$ = SPACE$(260)
            ~SendMessage(DLGITEM(28,1004),CB_GETLBTEXT,temp,V:temp$)
            temp$ = ZTRIM$(temp$)
            drv = ASC(UPPER$(MID$(temp$,3)))
            xpath$ = CHR$(drv) + ":\"
            @FillListBox(28)
          ENDIF
        CASE IDOK
          finit! = TRUE,flg! = TRUE
        CASE IDCANCEL
          finit! = TRUE
        ENDSELECT
      ENDSELECT
      REPEAT
      UNTIL !MOUSEK
    LOOP UNTIL finit!
    IF flg!
      CLR flg!
      ERASE mark!()
      DIM mark!(ctr - 1)
      FOR i = 0 TO ctr - 1
        status! = SendMessage(DLGITEM(28,1002),LB_GETSEL,i,0)
        mark!(i) = status!
        IF status! THEN flg! = TRUE
      NEXT i
      CLOSEDIALOG #28
      IF flg!
        @create_Sarray
        flg! = FALSE
        IF cnt > 1
          @bell
          mess$ = "Do you wish to confirm each kill?"
          j = ^bwccMessageBox(WIN(0),mess$,subtit$,style2)
          flg! = j - 7
        ENDIF
        FOR i = cnt - 1 DOWNTO 0
          IF flg!
            @bell
            mess$ = "Kill '" + UPPER$(stxt$(i)) + "'? [CANCEL to abort]"
            j = ^bwccMessageBox(WIN(0),mess$,subtit$,style4)
            IF j = IDNO THEN GOTO next_file
            IF j = IDCANCEL THEN GOTO abort_kill
          ENDIF
          @check_attr
          IF !xflg! THEN GOTO next_file
          IF BTST(stxt(i),4)
            RMDIR stxt$(i)
          ELSE
            @reset_Attr
            IF !xflg! THEN GOTO next_file
            KILL stxt$(i)
          ENDIF
          test$ = stxt$(i)
          IF LEN(test$) > 46 THEN test$ = LEFT$(test$,3) + " ... " + RIGHT$(test$,40)
          @status(b1,h1,3,"Deleting ... " + UPPER$(test$) + "!",ltred)
          next_file:
        NEXT i
        abort_kill:
      ENDIF
    ELSE
      CLOSEDIALOG #28
      mess$ = "Nothing chosen or " + subtit$ + " aborted!"
      ~^bwccMessageBox(WIN(0),mess$,subtit$,style1)
    ENDIF
    SYSCOL COLOR_GRAYTEXT,ltgray&,0
    RETVAL 0
  CATCH
  CLOSEDIALOG #28
  SYSCOL COLOR_GRAYTEXT,ltgray,0
  @error_handler
  RETVAL 0
RETURN
'
PROCEDURE check_attr
  xflg! = TRUE
  IF BTST(stxt(i),3)
    mess$ = "'" + UPPER$(stxt$(i)) + "' is the disk's name. It will be ignored!"
    ~^bwccMessageBox(WIN(0),mess$,subtit$,style1)
    xflg! = FALSE
  ELSE IF BTST(stxt(i),2)
    mess$ = "'" + UPPER$(stxt$(i)) + "' is a SYSTEM file. Kill anyways?"
    j = ^bwccMessageBox(WIN(0),mess$,subtit$,style2)
    xflg! = j - 7
  ELSE IF BTST(stxt(i),1)
    mess$ = "'" + UPPER$(stxt$(i)) + "' is a HIDDEN file. Kill anyways?"
    j = ^bwccMessageBox(WIN(0),mess$,subtit$,style2)
    xflg! = j - 7
  ELSE IF BTST(stxt(i),0)
    mess$ = "'" + UPPER$(stxt$(i)) + "' is a READ ONLY file. Kill anyways?"
    j = ^bwccMessageBox(WIN(0),mess$,subtit$,style2)
    xflg! = j - 7
  ENDIF
  RETVAL 0
RETURN
'
PROCEDURE reset_Attr
  xflg! = TRUE
  FOR k = 2 DOWNTO 0
    stxt(k) = BCLR(stxt(i),k)
  NEXT k
  temp$ = stxt$(i) + CHR$(0)
  _DS = HIWORD(V:temp$)
  _DX = LOWORD(V:temp$)
  ~INTR($21,_AH = $43,_AL = 1,_CX = stxt(i))
  IF ODD(_FL)
    SELECT _AX
    CASE 1
      mess$ = "Invalid code!"
    CASE 2
      mess$ = "File not found!"
    CASE 3
      mess$ = "Path not found!"
    CASE 4
      mess$ = "Access denied!"
    ENDSELECT
    BEEP
    ~^bwccMessageBox(WIN(0),mess$,subtit$,style1)
    xflg! = FALSE
  ENDIF
  RETVAL 0
RETURN
/*
PROCEDURE rename(ptr,b1,h1)
  $EXPORT rename
  TRY
    fgrnd = blue,fgrnd2 = ltred,bgrnd = yellow
    xpath$ = CHAR{ptr}
    subtit$ = "ReName File"
    temp$ = subtit$ + CHR$(0)
    filter$ = "*" + CHR$(0)
    xpath$ = xpath$ + CHR$(0)
    filename$ = CHR$(0) + SPACE$(260)
    ptr = V:xpath$,fptr = V:filename$       /* 2 v for rename */
    @fileselect(ptr,fptr,V:temp$,V:filter$,b1,h1,2)
    xpath$ = CHAR{ptr}
    filename$ = CHAR{fptr}
    IF filename$ = ""
      strng$ = "Nothing chosen or " + subtit$ + " aborted!"
    ELSE
      IF test|
        RESTORE mess_data
        FOR i = 1 TO test|
          READ temp$
        NEXT i
        mess$ = UPPER$(filename$) + " is a " + cr$ + temp$ + "." + cr$
        IF test| < 3
          mess$ = mess$ + "Are you sure?"
          j = ^bwccMessageBox(WIN(0),mess$,subtit$,style2)
        ELSE
          mess$ = mess$ + "Cannot " + subtit$ + "!"
          ~^bwccMessageBox(WIN(0),mess$,subtit$,style1)
          j = IDNO
        ENDIF
        IF j = IDNO THEN GOTO abort_rename
      ENDIF
      @chek_Path_len(36)
      info$ = "Location ... " + hold$ + CHR$(0)
      temp$ = subtit$ + " ... " + filename$ + CHR$(0)
      prompt$ = "Enter NEW Filename [max: 12 CHR$]: " + CHR$(0)
      ln& = 12
      strng$ = filename$ + CHR$(0) + SPACE$(12 - LEN(filename$))
      sptr = V:strng$
      @input_string(V:temp$,V:info$,V:prompt$,sptr,ln&,440,h1)
      strng$ = CHAR{sptr}
      IF strng$ = ""
        strng$ = "NO name entered or " + subtit$ + " aborted!"
      ELSE
        IF EXIST(xpath$ + strng$)
          BEEP
          mess$ = UPPER$(strng$) + " already exists! Back it up?"
          j = ^bwccMessageBox(WIN(0),mess$,subtit$,style4)
          DEFMOUSE 2
          IF j = IDYES
            i = INSTR(strng$,".")
            IF i
              hold$ = LEFT$(strng$,i) + "bak"
            ELSE
              hold$ = strng$ + ".bak"
            ENDIF
            IF EXIST(xpath$ + hold$) THEN KILL xpath$ + hold$
            RENAME xpath$ + strng$ AS xpath$ + hold$
          ELSE IF j = IDNO
            KILL xpath$ + strng$
          ELSE
            GOTO abort_rename
          ENDIF
        ENDIF
        RENAME xpath$ + filename$ AS xpath$ + strng$
        strng$ = UPPER$(filename$) + " renamed " + UPPER$(strng$) + "!"
      ENDIF
    ENDIF
    ~^bwccMessageBox(WIN(0),strng$,subtit$,style1)
    abort_rename:
    DEFMOUSE 0
    RETVAL 0
    mess_data:
    DATA read only file,hidden file,system file,disk name,directory
  CATCH
  @error_handler
  RETVAL 0
RETURN
/*
PROCEDURE dir(ptr,b2,h2)
  $EXPORT dir
  TRY
    IF b2 < 452 THEN b2 = 452
    xpath$ = CHAR{ptr}
    orig_path$ = xpath$
    filter$ = "*"
    subtit$ = "Directory [Change - OK in NEW directory]"
    CLR finit!
    stylex = WS_CHILD | WS_VISIBLE
    SYSCOL COLOR_GRAYTEXT,white&,0
    DIALOG #23,(b2 - 452) \ 2,h2,452,364,subtit$,style0,65524,"courier new"
      STATIC "Folder:",1000,4,6,52,16,WS_DISABLED
      STATIC "",1001,60,4,368,18,WS_BORDER
      temp = stylex | LBS_HASSTRINGS | LBS_NOTIFY
      temp = temp | WS_VSCROLL | WS_TABSTOP | WS_BORDER
      LISTBOX "",1002,4,68,350,266,temp
      STATIC "Drives:",1003,372,68,60,16,WS_DISABLED
      COMBOBOX "",1004,372,86,64,400,temp | CBS_DROPDOWNLIST
      STATIC "W95 FileName",1005,4,28,128,16,WS_DISABLED
      EDITTEXT "",1006,4,44,432,18,WS_BORDER | ES_AUTOHSCROLL
      CONTROL "",IDOK,"BorBtn",pbstyle,372,156,64,40
      CONTROL "",IDCANCEL,"BorBtn",pbstyle,372,200,64,40
    ENDDIALOG
    SHOWDIALOG #23
    DLG FILL 23,green
    @FillListBox(23)
    ~SetFocus(DLGITEM(23,1002))
    DO
      PEEKEVENT
      SELECT _Mess
      CASE WM_RBUTTONDOWN
        finit! = TRUE,xpath$ = orig_path$
      CASE WM_SYSKEYDOWN
        SELECT _wParam
        CASE 79
          finit! = TRUE
          @lbutdown(23,IDOK)
        CASE 67,VK_F4
          finit! = TRUE,xpath$ = orig_path$
          @lbutdown(23,IDCANCEL)
        ENDSELECT
      CASE WM_COMMAND
        SELECT _wParam
        CASE 1002
          SELECT HIWORD(_lParam)
          CASE LBN_SELCHANGE
            @get_sel(23)
            _WIN$(DLGITEM(23,1006)) = TRIM$(MID$(temp$,50))
          CASE LBN_DBLCLK
            @get_sel(23)
            temp$ = TRIM$(LEFT$(temp$,12))
            IF temp$ = ".."
              xpath$ = LEFT$(xpath$,LEN(xpath$) - 1)
              i = RINSTR(xpath$,"\")
              xpath$ = LEFT$(xpath$,i)
            ELSE IF BTST(temp,4)
              xpath$ = xpath$ + temp$ + "\"
            ENDIF
            @FillListBox(23)
          ENDSELECT
        CASE 1004
          temp = SendMessage(DLGITEM(23,1004),CB_GETCURSEL,0,0)
          IF temp = -1
            BEEP
          ELSE
            temp$ = SPACE$(6)
            ~SendMessage(DLGITEM(23,1004),CB_GETLBTEXT,temp,V:temp$)
            temp$ = ZTRIM$(temp$)
            drv = ASC(UPPER$(MID$(temp$,3)))
            xpath$ = CHR$(drv) + ":\"
            @FillListBox(23)
          ENDIF
        CASE IDOK
          finit! = TRUE
        CASE IDCANCEL
          finit! = TRUE,xpath$ = orig_path$
        ENDSELECT
      ENDSELECT
      REPEAT
      UNTIL !MOUSEK
    LOOP UNTIL finit!
    CLOSEDIALOG #23
    SYSCOL COLOR_GRAYTEXT,ltgray&,0
    xpath$ = xpath$ + CHR$(0)
    CHAR{ptr} = xpath$
    RETVAL 0
  CATCH
  @error_handler
  CLOSEDIALOG #23
  SYSCOL COLOR_GRAYTEXT,ltgray&,0
  CHAR{ptr} = orig_path$
  RETVAL 0
RETURN
/*
PROCEDURE make(ptr,b1,h1)
  $EXPORT make
  TRY
    IF b1 < 340 THEN b1 = 340
    xpath$ = CHAR{ptr}
    subtit$ = "Create Folder"
    stylex = WS_CHILD | WS_VISIBLE
    SYSCOL COLOR_GRAYTEXT,blue&,0
    DIALOG #21,(b1 - 340) \ 2,h1,340,308,subtit$,style0,65524,"courier new"
      STATIC "Folder:",1000,4,28,52,16,WS_DISABLED
      STATIC "",1001,60,26,260,18,WS_BORDER
      temp = stylex | LBS_NOTIFY | LBS_HASSTRINGS
      temp = temp | WS_TABSTOP | WS_BORDER | WS_VSCROLL
      LISTBOX "",1002,4,48,232,236,temp
      STATIC "Drives:",1003,244,54,60,16,WS_DISABLED
      COMBOBOX "",1004,244,72,64,400,temp | CBS_DROPDOWNLIST
      CTEXT "[Choose a Path for NEW folder]",1005,4,6,330,16
      CONTROL "",IDOK,"BorBtn",dpbstyle,246,156,64,40
      CONTROL "",IDCANCEL,"BorBtn",pbstyle,246,200,64,40
    ENDDIALOG
    SHOWDIALOG #21
    DLG FILL 21,gray
    @FillPathBox
    ~SetFocus(DLGITEM(21,1002))
    CLR finit!,flg!
    DO
      PEEKEVENT
      SELECT _Mess
      CASE WM_RBUTTONDOWN
        finit! = TRUE
        _WIN$(DLGITEM(21,1006)) = ""
      CASE WM_SYSKEYDOWN
        SELECT _wParam
        CASE 79
          finit! = TRUE,flg! = TRUE
          @lbutdown(21,IDOK)
        CASE 67,VK_F4
          finit! = TRUE
          @lbutdown(21,IDCANCEL)
          _WIN$(DLGITEM(21,1006)) = ""
        ENDSELECT
      CASE WM_COMMAND
        SELECT _wParam
        CASE 1002
          SELECT HIWORD(_lParam)
          CASE LBN_SELCHANGE
            @bell
          CASE LBN_DBLCLK
            @get_sel(21)
            temp$ = TRIM$(LEFT$(temp$,12))
            IF temp$ = ".."
              xpath$ = LEFT$(xpath$,LEN(xpath$) - 1)
              i = RINSTR(xpath$,"\")
              xpath$ = LEFT$(xpath$,i)
            ELSE
              xpath$ = xpath$ + temp$ + "\"
            ENDIF
            @FillPathBox
          ENDSELECT
        CASE 1004
          SENDMESSAGE DLGITEM(21,1004),CB_GETCURSEL,0,0,lsel&
          IF lsel& = -1
            BEEP
          ELSE
            temp$ = SPACE$(6)
            SENDMESSAGE DLGITEM(21,1004),CB_GETLBTEXT,lsel&,V:temp$
            drv = ASC(UPPER$(MID$(temp$,3)))
            xpath$ = CHR$(drv) + ":\"
            @FillPathBox
          ENDIF
        CASE IDOK
          finit! = TRUE,flg! = TRUE
        CASE IDCANCEL
          finit! = TRUE
        ENDSELECT
      ENDSELECT
      REPEAT
      UNTIL !MOUSEK
    LOOP UNTIL finit!
    CLOSEDIALOG #21
    IF flg!
      temp$ = subtit$ + CHR$(0)
      @chek_Path_len(62)
      info$ = "Location ... " + hold$ + CHR$(0)
      prompt$ = "[Enter] only aborts: " + CHR$(0)
      ln& = 260
      strng$ = CHR$(0) + SPACE$(ln&)
      sptr = V:strng$
      @input_string(V:temp$,V:info$,V:prompt$,sptr,ln&,b1,h1)
      strng$ = CHAR{sptr}
      IF strng$ = ""
        strng$ = "NO name entered!"
      ELSE
        @bell
        xpath$ = xpath$ + strng$
        MKDIR xpath$
        @chek_Path_len(26)
        strng$ = UPPER$(hold$) + cr$ + " created!"
      ENDIF
    ELSE
      strng$ = "Nothing chosen or " + cr$ + subtit$ + " aborted!"
    ENDIF
    ~^bwccMessageBox(WIN(0),strng$,subtit$,style1)
    SYSCOL COLOR_GRAYTEXT,ltgray&,0
    RETVAL 0
  CATCH
  CLOSEDIALOG #21
  SYSCOL COLOR_GRAYTEXT,ltgray&,0
  @error_handler
  RETVAL 0
RETURN
'
PROCEDURE FillPathBox
  LOCAL i
  @chek_Path_len(36)
  _WIN$(DLGITEM(21,1001)) = hold$
  @get_paths_only
  SENDMESSAGE DLGITEM(21,1002),LB_RESETCONTENT,0,0
  SENDMESSAGE DLGITEM(21,1004),CB_RESETCONTENT,0,0
  FOR i = 0 TO ctr - 1
    temp$ = TRIM$(MID$(txt$(i),13))
    ~SendMessage(DLGITEM(21,1002),LB_ADDSTRING,0,temp$)
  NEXT i
  ~SendMessage(DLGITEM(21,1004),CB_DIR,$4000,CHR$(0))
  RETVAL 0
RETURN
'
PROCEDURE get_paths_only
  LOCAL SearchHandle&,tempName$,temp
  ERASE txt$(),txt()
  DIM txt$(4096),txt(4096)
  CLR ctr
  dta = FGETDTA()
  SearchHandle& = FSFIRST(xpath$ + "*.*",$3F)
  WHILE !SearchHandle& AND ctr < 4096
    tempName$ = {dta}.fs_Name$
    temp = {dta}.fs_Attr
    IF tempName$ <> "." AND BTST(temp,4)
      IF tempName$ = ".."
        xName$ = tempName$
      ELSE
        @W95GetName(tempName$)
      ENDIF
      txt(ctr) = temp
      txt$(ctr) = SPACE$(272)
      LSET txt$(ctr) = UPPER$(tempName$)
      MID$(txt$(ctr),13) = UPPER$(xName$)
      ctr ++
    ENDIF
    SearchHandle& = FSNEXT()
  WEND
  IF ctr THEN QSORT txt$() OFFSET 12,ctr,txt()
  IF ctr = 4096
    @bell
    mess$ = "First 4096 entries only"
    ~^bwccMessageBox(WIN(0),mess$,subtit$,style1)
  ENDIF
  RETVAL 0
RETURN
/*
PROCEDURE copy(ptr,b1,h1)
  $EXPORT copy
  TRY
    ERASE stxt$(),stxt(),dtxt$(),dtxt()
    DIM stxt$(4096),stxt(4096),dtxt$(4096),dtxt(4096)
    xpath$ = CHAR{ptr}
    spath$ = xpath$,dpath$ = xpath$
    filter$ = "*"
    retry:
    subtit$ = "Copy/Move File(s)"
    @copy_setup(b1,h1)
    CLR finit!,flg!,all_sel!
    DO
      PEEKEVENT
      sel = _Mess
      SELECT sel
      CASE WM_RBUTTONDOWN
        IF _hWnd = DLGITEM(27,1003)
          all_sel! = !all_sel!
          FOR i = 0 TO sctr - 1
            ~SendMessage(DLGITEM(27,1003),LB_SETSEL,all_sel!,i)
          NEXT i
          @bytes_marked
        ELSE
          finit! = TRUE
          @lbutdown(27,IDCANCEL)
        ENDIF
      CASE WM_SYSKEYDOWN
        SELECT _wParam
        CASE 79
          finit! = TRUE,flg! = TRUE
          @lbutdown(27,IDOK)
        CASE 67,VK_F4
          finit! = TRUE
          @lbutdown(27,IDCANCEL)
        ENDSELECT
      CASE WM_COMMAND
        SELECT _wParam
        CASE 1003
          SELECT HIWORD(_lParam)
          CASE LBN_SELCHANGE
            @bell
            @bytes_marked
          CASE LBN_DBLCLK
            SENDMESSAGE DLGITEM(27,1003),LB_GETCURSEL,0,0,lsel&
            temp$ = TRIM$(LEFT$(stxt$(lsel&),12))
            temp = stxt(lsel&)
            IF temp$ = ".."
              spath$ = LEFT$(spath$,LEN(spath$) - 1)
              i = RINSTR(spath$,"\")
              spath$ = LEFT$(spath$,i)
              @FillSrcBox
              CLR all_sel!
            ELSE IF BTST(temp,4)
              spath$ = spath$ + temp$ + "\"
              @FillSrcBox
              CLR all_sel!
            ENDIF
            @bytes_marked
          ENDSELECT
        CASE 1005
          SENDMESSAGE DLGITEM(27,1005),CB_GETCURSEL,0,0,lsel&
          IF lsel& = -1
            BEEP
          ELSE
            temp$ = SPACE$(6)
            SENDMESSAGE DLGITEM(27,1005),CB_GETLBTEXT,lsel&,V:temp$
            drv = ASC(UPPER$(MID$(temp$,3)))
            spath$ = CHR$(drv) + ":\"
            @FillSrcBox
            CLR all_sel!
            @bytes_marked
          ENDIF
        CASE 1009
          SELECT HIWORD(_lParam)
          CASE LBN_SELCHANGE
            @bell
          CASE LBN_DBLCLK
            SENDMESSAGE DLGITEM(27,1009),LB_GETCURSEL,0,0,lsel&
            temp$ = TRIM$(LEFT$(dtxt$(lsel&),12))
            temp = dtxt(lsel&)
            IF temp$ = ".."
              dpath$ = LEFT$(dpath$,LEN(dpath$) - 1)
              i = RINSTR(dpath$,"\")
              dpath$ = LEFT$(dpath$,i)
              @FillDstnBox
            ELSE
              dpath$ = dpath$ + temp$ + "\"
              @FillDstnBox
            ENDIF
            @bytes_free
          ENDSELECT
        CASE 1011
          SENDMESSAGE DLGITEM(27,1011),CB_GETCURSEL,0,0,lsel&
          IF lsel& = -1
            BEEP
          ELSE
            temp$ = SPACE$(6)
            SENDMESSAGE DLGITEM(27,1011),CB_GETLBTEXT,lsel&,V:temp$
            drv = ASC(UPPER$(MID$(temp$,3)))
            dpath$ = CHR$(drv) + ":\"
            @FillDstnBox
            @bytes_free
          ENDIF
        CASE IDOK
          finit! = TRUE,flg! = TRUE
          @lbutdown(27,IDOK)
        CASE IDCANCEL
          finit! = TRUE
          @lbutdown(27,IDCANCEL)
        ENDSELECT
      ENDSELECT
      REPEAT
      UNTIL !MOUSEK
    LOOP UNTIL finit!
    check! = CHECK?(27,1012)
    CLOSEDIALOG #27
    IF flg!
      IF !bmark
        BEEP
        mess$ = "NO files marked!"
        ~^bwccMessageBox(WIN(0),mess$,subtit$,style1)
        GOTO abort_copy
      ELSE IF spath$ = dpath$
        BEEP
        mess$ = "Source/Destination are the same!"
        ~^bwccMessageBox(WIN(0),mess$,subtit$,style1)
        GOTO abort_copy
      ELSE IF bmark > dfre
        BEEP
        mess$ = "More bytes marked than space available!"
        j = ^bwccMessageBox(WIN(0),mess$,subtit$,style5)
        IF j = IDRETRY
          GOTO retry
        ELSE IF j = IDABORT
          GOTO abort_copy
        ENDIF
      ENDIF
      DEFMOUSE 2
      ERASE txt$(),txt()
      DIM txt$(4096),txt(4096)
      SWAP stxt$(),txt$()
      SWAP stxt(),txt()
      xpath$ = spath$,ctr = sctr
      @create_Sarray
      FOR i = 0 TO cnt - 1
        dfre = DFREE(ASC(UPPER$(dpath$)) - 64)
        ln& = LEN(spath$)
        temp$ = MID$(stxt$(i),ln& + 1)
        temp1$ = LOWER$(stxt$(i)),temp2$ = LOWER$(dpath$ + temp$)
        IF BTST(stxt(i),4)
          CLR dflg!
          FOR k = 0 TO dctr - 1
            filename$ = TRIM$(LEFT$(dtxt$(k),12))
            IF LOWER$(temp$) = LOWER$(filename$) THEN dflg! = TRUE
            EXIT IF dflg!
          NEXT k
          IF !dflg!
            IF dfre > 1024
              test$ = temp2$
              IF LEN(test$) > 46 THEN test$ = LEFT$(test$,3) + "..." + RIGHT$(test$,40)
              @status(b1,h1,9,"Creating..." + UPPER$(test$) + "!",ltgray)
              MKDIR temp2$
            ELSE
              BEEP
              @status(b1,h1,35,"NOT enough room to create " + temp$ + "!",ltred)
            ENDIF
          ENDIF
        ELSE
          IF EXIST(temp2$)
            DEFMOUSE 0
            @bell
            mess$ = "File already exists! Back it up?"
            j = ^bwccMessageBox(WIN(0),mess$,subtit$,style4)
            DEFMOUSE 2
            IF j = IDCANCEL
              GOTO next_file2
            ELSE IF j = IDYES
              k = INSTR(temp$,".")
              IF k
                hold$ = LEFT$(temp$,k) + "bak"
              ELSE
                hold$ = temp$ + ".bak"
              ENDIF
              IF EXIST(dpath$ + hold$) THEN KILL dpath$ + hold$
              RENAME temp2$ AS dpath$ + hold$
            ENDIF
          ENDIF
          OPEN "i",#2,temp1$
          flen = LOF(#2)
          IF flen > dfre
            DEFMOUSE 0
            BEEP
            @status(b1,h1,35,"NOT enough room to copy " + temp$ + "!",ltred)
            GOTO abort_copy
          ENDIF
          j = flen,buf_size = 32000
          test$ = UPPER$(temp1$)
          IF LEN(test$) > 42 THEN test$ = LEFT$(test$,3) + "..." + RIGHT$(test$,36)
          info$ = "From: " + test$ + "|"
          test$ = UPPER$(temp2$)
          IF LEN(test$) > 42 THEN test$ = LEFT$(test$,3) + "..." + RIGHT$(test$,36)
          info$ = info$ + "To: " + test$ + CHR$(0)
          @meter((b1 - 558) \ 2,h1,558,24,blue,ltblue,ltred,0,V:info$)
          temp$ = SPACE$(buf_size)
          OPEN "o",#3,temp2$
          WHILE flen > buf_size
            BGET #2,V:temp$,buf_size
            BPUT #3,V:temp$,buf_size
            SUB flen,buf_size
            k = (j - flen) * 100 \ j
            IF k < 100 THEN @meter((b1 - 558) \ 2,h1,558,24,blue,ltblue,ltred,k,V:info$)
          WEND
          IF flen
            BGET #2,V:temp$,flen
            BPUT #3,V:temp$,flen
          ENDIF
          @meter((b1 - 558) \ 2,h1,558,24,blue,ltblue,ltred,100,V:info$)
          CLOSE
        ENDIF
        next_file2:
      NEXT i
      IF check!
        FOR i = cnt - 1 DOWNTO 0
          @check_attr
          IF !xflg! THEN GOTO next_file3
          IF BTST(stxt(i),4)
            RMDIR stxt$(i)
          ELSE
            @reset_Attr
            IF !xflg! THEN GOTO next_file3
            KILL stxt$(i)
          ENDIF
          test$ = UPPER$(stxt$(i))
          IF LEN(test$) > 42 THEN test$ = LEFT$(test$,3) + "..." + RIGHT$(test$,36)
          @status(b1,h1,1,"Deleting..." + test$ + "!",ltred)
          next_file3:
        NEXT i
      ENDIF
      bell
      @status(b1,h1,18,"All Done!",ltgray)
    ELSE
      BEEP
    ENDIF
    abort_copy:
    DEFMOUSE 0
    RETVAL 0
  CATCH
  CLOSEDIALOG #27
  @error_handler
  RETVAL 0
RETURN
'
PROCEDURE copy_setup(b2,h2)
  IF b2 < 558 THEN b2 = 558
  stylex = LBS_NOTIFY | LBS_HASSTRINGS | WS_TABSTOP | WS_BORDER | WS_VSCROLL
  DIALOG #27,(b2 - 558) \ 2,h2,558,308,subtit$,style0,65524,"courier new"
    CTEXT "SOURCE [all files]",1000,4,4,268,16
    RTEXT "Folder:",1001,8,20,52,16
    STATIC "",1002,60,20,212,16,WS_BORDER
    LISTBOX "",1003,4,40,268,160,stylex | LBS_MULTIPLESEL | LBS_EXTENDEDSEL
    RTEXT "Drives:",1004,4,236,52,16
    COMBOBOX "",1005,60,232,72,308,stylex | CBS_DROPDOWNLIST
    CTEXT "DESTINATION",1006,274,4,268,16
    RTEXT "Folder:",1007,278,20,52,16
    STATIC "",1008,330,20,212,16,WS_BORDER
    LISTBOX "",1009,278,40,268,160,stylex
    RTEXT "Drives:",1010,418,236,52,16
    COMBOBOX "",1011,474,232,72,308,stylex | CBS_DROPDOWNLIST
    BUTTON "MOVE [Delete Source Files]",1012,(179 ),216,200,16,BS_AUTOCHECKBOX | WS_TABSTOP
    STATIC "",1013,4,194,268,20,SS_CENTER | WS_BORDER
    STATIC "",1014,278,194,268,20,SS_CENTER | WS_BORDER
    CONTROL "",IDOK,"BorBtn",pbstyle,179,236,64,40
    CONTROL "",IDCANCEL,"BorBtn",pbstyle,315,236,64,40
  ENDDIALOG
  DLG FILL 27,ltblue
  @FillSrcBox
  @FillDstnBox
  @bytes_marked
  @bytes_free
  SHOWDIALOG #27
  ~SetFocus(DLGITEM(27,1003))
  RETVAL 0
RETURN
'
PROCEDURE FillSrcBox
  LOCAL i
  xpath$ = spath$
  @set_dir(spath$)
  @change_dir(1003)
  SWAP txt$(),stxt$()
  SWAP txt(),stxt()
  sctr = ctr
  RETVAL 0
RETURN
'
PROCEDURE FillDstnBox
  LOCAL i
  xpath$ = dpath$
  @set_dir(dpath$)
  @change_dir(1009)
  SWAP txt$(),dtxt$()
  SWAP txt(),dtxt()
  dctr = ctr
  RETVAL 0
RETURN
'
PROCEDURE change_dir(item&)
  @chek_Path_len(30)
  _WIN$(DLGITEM(27,item& - 1)) = hold$
  @get_dir
  SENDMESSAGE DLGITEM(27,item&),LB_RESETCONTENT,0,0
  SENDMESSAGE DLGITEM(27,item& + 2),CB_RESETCONTENT,0,0
  FOR i = 0 TO ctr - 1
    temp$ = MID$(txt$(i),50,24) + " " + MID$(txt$(i),13,9)
    ~SendMessage(DLGITEM(27,item&),LB_ADDSTRING,0,temp$)
  NEXT i
  ~SendMessage(DLGITEM(27,item& + 2),CB_DIR,$4000,CHR$(0))
  IF item& = 1003 THEN ~SendMessage(DLGITEM(27,item&),LB_SETCURSEL,0,0)
  RETVAL 0
RETURN
'
PROCEDURE bytes_free
  LOCAL temp$="Free: "
  dfre = DFREE(ASC(UPPER$(dpath$)) - 64)
  @change_it(dfre)
  temp$ = temp$ + hold$ + " [" + STR$(dfre) + " bytes]" + CHR$(0)
  ~SetWindowText(DLGITEM(27,1014),V:temp$)
  RETVAL 0
RETURN
'
PROCEDURE bytes_marked
  LOCAL i,temp,temp$="Marked: "
  CLR bmark
  ERASE mark!()
  DIM mark!(sctr)
  FOR i = 0 TO sctr - 1
    status! = SendMessage(DLGITEM(27,1003),LB_GETSEL,i,0)
    mark!(i) = status!
    IF status!
      temp = VAL(MID$(stxt$(i),13,9))
      IF MID$(stxt$(i),17,5) = "<Dir>" THEN temp = 1024
      ADD bmark,temp
    ENDIF
  NEXT i
  @change_it(bmark)
  temp$ = temp$ + hold$ + " [" + STR$(bmark) + " bytes]" + CHR$(0)
  ~SetWindowText(DLGITEM(27,1013),V:temp$)
  RETVAL 0
RETURN
'
PROCEDURE change_it(temp)
  temp = temp \ 1024
  IF temp > 3000
    temp = temp \ 1024
    hold$ = STR$(temp) + "M"
  ELSE
    hold$ = STR$(temp) + "K"
  ENDIF
RETURN
/*


