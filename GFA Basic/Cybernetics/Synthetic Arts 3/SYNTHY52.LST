' -----------------------------------------------------------------------------'
' SAVE "e:\code\synthy.art\backup.gfa"     ! Un tien vaut mieux que deux tu l'auras
' CHDRIVE "e:"
' CHDIR "e:\code\synthy.art\curent\"
' -----------------------------------------------------------------------------'
'                                                                              '
'  - SYNTHETIC ARTS III -                              - CYBERNETICS 1992 -    '
'                                                                              '
'   Version beta du 08/02/93                                                   '
'                                                                              '
' -----------------------------------------------------------------------------'
$c+
'
'  ALLOCATION MEMOIRE
'
RESERVE 120000
'
INLINE tstmega%,102
oldecran%=XBIOS(3)                              ! INIT EN CAS DE WRONG REZ
DIM sauv&(15)                                   ! PALETTE D'ORIGINE
FOR t&=FALSE TO 15
  sauv&(t&)=DPEEK(ADD(&HFF8240,SHL&(t&,1)))
NEXT t&
oldclv&=PEEK(&H484)
SPOKE &H484,AND(PEEK(&H484),NOT TT?)
'
IF XBIOS(4)<>FALSE                             ! BASSE RES BECAUSE VDI
  ALERT FALSE,"   SYNTHETIC ARTS 3    | |     LOW RES ONLY|   BASSE RESOLUTION  ",1,"   Ok   ",al&
  lib
ENDIF
'
'
aux%=SUB(MALLOC(TRUE),10000)                     ! TEST MEM LIBRE
IF aux%<281500
  ALERT FALSE," |   NOT ENOUGHT MEMORY|  PAS ASSEZ DE MEMOIRE    | ",1,"  Ok  ",al&
  lib
ENDIF
'
ecran%=oldecran%
HIDEM
synt%=TRUE                                      ! MOTIF POUR LINE A
adr%=V:synt%
'
buffer%=MALLOC(aux%)                            ! SECTIONNEMENT BUFFER
'
message%=buffer%
mouse%=ADD(message%,6500)
raster%=ADD(mouse%,64)
raster2%=ADD(raster%,500)
comut%=ADD(raster%,1000)
lp%=ADD(comut%,1000)
gloup%=ADD(lp%,6400)
noclip%=AND(ADD(gloup%,9856),&HFFFFFF00)
ado%=ADD(noclip%,32000)
lst%=ADD(ado%,32000)
undo%=ADD(lst%,32000)
blk%=ADD(undo%,32000)
nbec&=MIN(SUB(DIV(SUB(aux%,249500),32000),1),98)
DIM ec%(nbec&),rvb&(15,nbec&),col&(15),plx&(128),ply&(128),sn&(360),cs&(360),crap&(15),tram|(23,15,15),tram$(23),aero&(15),nec&(5),line%(1),mem&(15),anim&(143),undo&(15),protec&(nbec&),fcx&(3),fcy&(3),savd&(nbec&),pref&(12),full&(3),nom$(nbec&),act&(120)
DIM bt&(39)
FOR t&=FALSE TO nbec&
  ec%(t&)=ADD(blk%,MUL(ADD(t&,1),32000))
  nom$(t&)="IMAGE"+STR$(ADD(t&,1))
NEXT t&
'
ecran%=ADD(ec%(nbec&),32000)
'
ARRAYFILL bt&(),TRUE
ARRAYFILL act&(),TRUE
'
'     68000 CODE
'
INLINE rempl%,248
INLINE retrc%,1712
INLINE codes%,130
INLINE decom%,132
INLINE degtst%,314
INLINE redim%,296
INLINE lpx%,1936
INLINE gund%,290
INLINE mask%,410
INLINE eff%,186
INLINE degrad%,124
INLINE anti%,348
INLINE over%,2796
INLINE reloc%,96
INLINE inter%,3714
INLINE ptst%,138
INLINE loadrouts%,6274
INLINE video%,576
INLINE tiny%,276
INLINE degas%,402
INLINE targa%,1178
'
' @loadinl
'
eff(buffer%,aux%)                               ! ON EFFACE TOUT LE BUFFER
~XBIOS(6,L:buffer%)
~XBIOS(5,L:ecran%,L:ecran%,W:TRUE)
'
a%=inter%                             ! Recherche le d‚but de la table
REPEAT
  ADD a%,2
UNTIL {a%}=&HABCDABCD
table%=ADD(a%,4)
~C:reloc%(L:inter%)
@hide
'
{ADD(table%,56)}=raster%              ! Inits Rasters
{ADD(table%,60)}=raster%
{ADD(table%,64)}=raster2%
'
{ADD(table%,10)}=ecran%               ! Inits Affmouse
{ADD(table%,14)}=ecran%
{ADD(table%,18)}=mouse%
'
CARD{ADD(table%,42)}=FALSE
CARD{ADD(table%,44)}=FALSE
'
'       DATAS
'
INLINE param%,8960
INLINE pan1%,4880
INLINE pan%,1600
INLINE old%,32
INLINE pal_deg%,32
INLINE init_col%,32
'
'
BOUNDARY FALSE                                  ! WORKSTATION PARAMETERS
CLIP FALSE,FALSE,320,200
aclp(TRUE,FALSE,FALSE,319,199)
'
FOR i&=FALSE TO 15                              ! PALETTEs
  FOR t&=FALSE TO nbec&
    rvb&(i&,t&)=INT{ADD(old%,SHL(i&,1))}
  NEXT t&
  mem&(i&)=rvb&(i&,FALSE)
  undo&(i&)=mem&(i&)
NEXT i&
'
FOR t&=FALSE TO 5                               ! TOUCHES ECRAN
  j&=AND(t&,t&<=nbec&)
  nec&(t&)=j&
  IF t&<4
    full&(t&)=j&
  ENDIF
NEXT t&
'
'
BMOVE pan%,ecran%,1600                          ! INIT BARRE SELECTION COULEUR
GET FALSE,FALSE,5,8,fg$
GET 13,FALSE,18,8,fd$
arec(FALSE,FALSE,19,8,15,2)
arec(10,FALSE,19,8,FALSE,FALSE)
BMOVE ecran%,pan%,1600
'
eff(ecran%,32000)
'
FOR t&=FALSE TO 15                              ! CURSEUR COULEUR
  ALINE t&,FALSE,SUB(t&,4),4,t&,65535,FALSE
NEXT t&
GET FALSE,FALSE,10,4,cl$
'
' INITIALISATIONS VARIABLES
'
BMOVE init_col%,V:col&(FALSE),32                ! TABLEAUX CONVERSø SHIFT->VDI
'
eff(ecran%,32000)
~XBIOS(6,L:old%)
'
charg&=1                                        ! INIT VARIABLES
sauv&=1
tsiz&=6
c&=15
img_per_sec&=1
synt2%=-1431655766
adr2%=V:synt2%
spr&=TRUE
grs&=4
lter&=40
hter&=20
endan&=143
sens1&=TRUE
sens2&=TRUE
sens3&=TRUE
sens4&=TRUE
tempaero&=10
delx&=160
dely&=100
xf&=25
yf&=20
endc&=15
htb&=1
lgb&=1
pane2&=TRUE
prg$="END"
mainpath$=CHR$(ADD(65,GEMDOS(25)))+":"+DIR$(ADD(GEMDOS(25),1))+"\"
cpath$=mainpath$+"*.NEO"
spath$=mainpath$+"*.NEO"
ARRAYFILL line%(),TRUE                  ! TABLEAUX
ARRAYFILL crap&(),TRUE
ARRAYFILL aero&(),TRUE
ARRAYFILL pref&(),TRUE
FOR t&=FALSE TO 23                      ! TRAMES & PINCEAUX … ZERO
  tram$(t&)=STRING$(32,MKL$(FALSE))
NEXT t&
FOR t&=FALSE TO 360
  cs&(t&)=ROUND(COSQ(t&)*30000)
  sn&(t&)=ROUND(SINQ(t&)*30000)
NEXT t&
'
blitp&=BTST(XBIOS(64,TRUE),1)           ! BLITTER ?
IF blitp&
  blit&=TRUE
  lkblit
ENDIF
falcon&=TT?
IF OR(TT?,STE?)                         ! STE ?
  ste&=TRUE
  suppal&=15
ELSE
  suppal&=7
ENDIF
IF C:tstmega%()
  oldhz&=AND(C:tstmega%(),&HFF)         ! Si MEGA STE , on passe en 16 Mhz et
  SPOKE &HFFFF8E21,3                    ! on sauve l'ancienne frequence
ENDIF
'
eff(ado%,32)
raster(MKL$(old%)+MKI$(80)+MKL$(ado%)+MKI$(240))
eff(ecran%,32000)
'
led$=SPACE$(46)                         ! ON RECUPERE L'IMG DE LA LED
load("LEDPANO",V:led$,TRUE,fat$)
mouse$=SPACE$(64)
mouse2$=SPACE$(64)
load("MOUSE_1",V:mouse$,FALSE,fat$)
load("MOUSE_2",V:mouse2$,FALSE,fat$)
load("CODECLV",{ADD(table%,78)},FALSE,fat$)
load("DEFAULT",ado%,FALSE,fat$)
BMOVE ado%,V:act&(FALSE),242
BMOVE ADD(ado%,242),V:bt&(FALSE),80
calclav
defmo(V:mouse$,FALSE,FALSE)
mouseoff
'
PRINT CHR$(27)+"b"+CHR$(15)+CHR$(27)+"c"+CHR$(FALSE);
IF EXIST("SYNTHY.INF")                  ! FICHIER INF ?
  load("TXLANG0",message%,FALSE,fat$)
  PRINT AT(11,1);"LOADING PREFERENCES..."
  PRINT AT(9,2);"CHARGEMENT PREFERENCES..."
  fich$="SYNTHY.INF"
  @loadpref
ENDIF
@loadlang
mouseon
'
raster(MKL$(old%))
@hide
eff(ecran%,32000)
@showm
'
a$=@rd$(84,FALSE)+@rd$(84,1)+@rd$(84,2)+@rd$(84,3)+@rd$(84,4)
FOR t&=FALSE TO SUB(LEN(a$),1)
  BYTE{ADD(V:a$,t&)}=SUB(SUB(BYTE{ADD(V:a$,t&)},ROUND(COSQ(ADD(t&,1))*20)),100)
NEXT t&
~@alt(TRUE,TRUE,a$,"   Ok   ",FALSE)
a$=""
'
deb:
ON ERROR GOSUB mist
totalc
@showm
ec&=nec&(cursec&)
reput
note(FALSE)
norm
normpal
pan&=TRUE
ext&=FALSE
'
REPEAT
  SELECT action&
  CASE 0
    demipan
  DEFAULT
    SELECT action&
    CASE 1
      4
    CASE 2
      setco(c&,FALSE)
    CASE 3
      aux&=21
      ed_tr
    CASE 4
      aux&=FALSE
      ed_tr
    CASE 5
      k&=ADD(1,AND(@btc(2),1))
      full
    CASE 6
      mouse
    CASE 7
      ec
    CASE 8
      ac(ec&,cursec&)
      BMOVE ec%(ec&),undo%,32000
    ENDSELECT
    action&=FALSE
    exit&=FALSE
    norm
    reput
    IF otl&=3
      reaf(TRUE)
    ENDIF
  ENDSELECT
UNTIL ext&=TRUE
lib
'
' PROCEDUREs
'
> PROCEDURE demipan
  ms2
  IF y&<100
    exe(pane2&)
    IF exit&=-3
      exit&=FALSE
      97
    ENDIF
  ELSE
    atm0
    normpal
    REPEAT
      ms2
      IF @inp_
        tch&=@inp
        SELECT act&(tch&)
        CASE 62 TO 64
          ordo&=MUL(SUB(act&(tch&),62),50)
          reput
          IF otl&=3
            reaf(TRUE)
          ENDIF
        CASE 3 TO 10
          exit&=-2
          action&=SUB(act&(tch&),2)
        CASE 11 TO 16
          cursec&=SUB(act&(tch&),11)
          changec
          IF otl&=3
            reaf(TRUE)
          ENDIF
          norm
        CASE 17 TO 33
          IF AND(otl&=3,SUB(act&(tch&),17)<>3)
            reput
          ENDIF
          otl&=SUB(act&(tch&),17)
          IF @btc(2)
            SELECT otl&
            CASE 2,7 TO 10
              fld&=TRUE
            DEFAULT
              fld&=FALSE
            ENDSELECT
          ELSE
            fld&=otl&=2
          ENDIF
          normpal
          norm
        CASE 34 TO 43
          controloutil
          normpal
          norm
        CASE 115,83
          IF nom$(ec&)<>""
            fich$=LEFT$(spath$,RINSTR(spath$,"\"))+nom$(ec&)
            eff(ADD(ecran%,27360),4640)
            @psav(ec&)
          ENDIF
        CASE 1
          97
        CASE 44 TO 59
          c&=SUB(act&(tch&),44)
          ppal(c&)
        CASE 0
          affund
        CASE 226
          4
        ENDSELECT
        necho
      ENDIF
      FOR t&=FALSE TO 13
        FOR i&=FALSE TO 1
          IF OR(OR(k&<>2,t&<>13),i&=FALSE)
            icone(ADD(2,MUL(t&,22)),ADD(112,MUL(i&,29)),ADD(22,MUL(t&,22)),ADD(MUL(i&,29),139),1)
          ELSE
            icone(ADD(2,MUL(t&,22)),ADD(112,MUL(i&,29)),ADD(22,MUL(t&,22)),ADD(MUL(i&,29),139),97)
          ENDIF
        NEXT i&
      NEXT t&
      tabicone(FALSE,100,19,9,20,FALSE,15,FALSE,2)
      icone(FALSE,171,319,229,34)
      icone(310,112,319,170,4)
    UNTIL OR(OR(y&<100,ext&),exit&)
  ENDIF
RETURN
> PROCEDURE 97                            ! Appelle ex‚cution outils
  appx(xh&,yh&,xb&,yb&)
  atm0
  k&=FALSE
  exe(FALSE)
RETURN
> PROCEDURE exe(pane&)                    ! Ex‚cution outils
  @hide
  pan&=pane&
  normoutil
  REPEAT
    def1
    defill
    defln
    sensmo(ADD(smodess&,1))
    defmo(V:mouse2$,hotdx&,hotdy&)
    @showm
    ON ADD(otl&,1) GOSUB cr,ligb,f,blk,lpx,aero,pinc,rect,cerc,ell,poly,cbz,text,eras,ent,repl,deg
    IF exit&=1
      exit&=FALSE
    ENDIF
  UNTIL OR(exit&<FALSE,AND(y&>99,pan&))
  phy(ecran%)
  sensmo(ADD(smopanel&,1))
  defmo(V:mouse$,hotpx&,hotpy&)
  def1
  IF exit&=TRUE
    exit&=FALSE
  ENDIF
  totalc
  pan&=TRUE
  normpal
  norm
  IF NOT pane&
    reput
    IF otl&=3
      reaf(TRUE)
    ENDIF
    IF AND(y&<100,NOT pane2&)
      setmo(x&,105)
    ENDIF
  ENDIF
  @showm
RETURN
'
> PROCEDURE icone(xh&,yh&,xb&,yb&,pcd&)
  IF AND(@rectst(x&,y&,xh&,yh&,xb&,yb&),k&)
    IF pcd&<67
      ON pcd& GOSUB stl,cl,scl,4,5,6,r,r,37,10,getcurs,crap,13,14,15,anim,17,18,19,scim,21,pac,23,r,25,effect,ec,sac,28,29,30,savt,loadt,param,35,36,outill,38,39,getcurs,key,42,43,44,gercpt,46,47,48,49,50,11,52,53,54,55,56,57,58,59,60,red,formt,sf
    ELSE
      ON SUB(pcd&,66) GOSUB modf,68,69,70,formt,72,73,74,75,76,77,78,79,80,81,82,83,84,modcall,r,sblk,88,88,88,88,92,93,94,95,96,97,98,99,100,101,102,103,104
    ENDIF
  ENDIF
  CLR xh&,yh&,xb&,yb&,pcd&
RETURN
'
' ==> 86, 24 disponibles dans icones
'
> PROCEDURE lkchargph                     ! Forme le chemin pour le chargement images
  cpath$=@form_path$(cpath$,@rd$(67,charg&))
RETURN
> PROCEDURE lksauvph                      ! Forme le chemin pour la sauvegarde images
  spath$=@form_path$(spath$,@rd$(69,sauv&))
RETURN
> FUNCTION form_path$(a$,b$)              ! Forme un chemin d'apres l'extension
RETURN LEFT$(a$,RINSTR(a$,"."))+b$
ENDFUNC
> PROCEDURE lkblit                        ! Active / d‚sactive le blitter au niveau Bios
IF blitp&
  IF blit&
    ~XBIOS(64,BSET(XBIOS(64,TRUE),FALSE))
  ELSE
    ~XBIOS(64,BCLR(XBIOS(64,TRUE),FALSE))
  ENDIF
ENDIF
RETURN
> PROCEDURE raster(a$)                    ! Fixe les differentes palettes (rasters)
LOCAL t%,t&,i%
BMOVE raster%,comut%,1000
{ADD(table%,60)}=comut%
{ADD(table%,64)}=ADD(comut%,500)
@vs
IF OR(suppal&=14,suppal&=30)
  IF LEN(a$)=<6
    bmov2(CVL(MID$(a$,1,4)),raster%,raster2%)
    CARD{ADD(raster%,32)}=240
    CARD{ADD(raster2%,32)}=240
  ELSE
    t%=raster%
    i%=raster2%
    FOR t&=1 TO LEN(a$) STEP 6
      bmov2(CVL(MID$(a$,t&,4)),t%,i%)
      ADD t%,32
      ADD i%,32
      CARD{t%}=CVI(MID$(a$,ADD(t&,4),2))
      CARD{i%}=CVI(MID$(a$,ADD(t&,4),2))
      ADD t%,2
      ADD i%,2
    NEXT t&
    CARD{SUB(t%,2)}=240
    CARD{SUB(i%,2)}=240
  ENDIF
ELSE
  IF LEN(a$)=<6
    BMOVE CVL(MID$(a$,1,4)),raster%,32
    CARD{ADD(raster%,32)}=240
  ELSE
    t%=raster%
    FOR t&=1 TO LEN(a$) STEP 6
      BMOVE CVL(MID$(a$,t&,4)),t%,32
      ADD t%,32
      CARD{t%}=CVI(MID$(a$,ADD(t&,4),2))
      ADD t%,2
    NEXT t&
    CARD{SUB(t%,2)}=240
  ENDIF
ENDIF
{ADD(table%,60)}=raster%
{ADD(table%,64)}=raster2%
CLR a$,t%,t&,i%
RETURN
> PROCEDURE bmov2(a%,b%,c%)               ! Sous Pcd de raster: deplace les palettes en memoire en gerant les palettes etendues
SELECT suppal&
CASE 14
  FOR bmov2_t%=a% TO ADD(a%,30) STEP 2
    bmov2_t&=INT{bmov2_t%}
    IF AND(&H7000,bmov2_t&)
      IF AND(&H7000,bmov2_t&)=&H5000
        INT{b%}=ADD(bmov2_t&,AND(BTST(bmov2_t&,14),256))
        INT{c%}=SUB(bmov2_t&,BTST(bmov2_t&,12))
      ELSE
        INT{b%}=ADD(bmov2_t&,AND(BTST(bmov2_t&,13),16))
        INT{c%}=ADD(SUB(bmov2_t&,BTST(bmov2_t&,12)),AND(BTST(bmov2_t&,14),256))
      ENDIF
    ELSE
      INT{b%}=bmov2_t&
      INT{c%}=bmov2_t&
    ENDIF
    ADD b%,2
    ADD c%,2
  NEXT bmov2_t%
CASE 30
  FOR bmov2_t%=a% TO ADD(a%,30) STEP 2
    bmov2_t&=INT{bmov2_t%}
    IF AND(&H7000,bmov2_t&)
      IF BTST(bmov2_t&,7)
        INT{b%}=BCLR(ADD(bmov2_t&,AND(BTST(bmov2_t&,13),16)),7)
      ELSE
        INT{b%}=OR(bmov2_t&,AND(BTST(bmov2_t&,13),128))
      ENDIF
      IF BTST(bmov2_t&,3)
        INT{c%}=BCLR(SUB(bmov2_t&,BTST(bmov2_t&,12)),3)
      ELSE
        INT{c%}=OR(bmov2_t&,AND(BTST(bmov2_t&,12),8))
      ENDIF
      IF AND(&H7000,bmov2_t&)=&H5000
        IF BTST(bmov2_t&,11)
          INT{b%}=BCLR(ADD(INT{b%},AND(BTST(bmov2_t&,14),256)),11)
        ELSE
          INT{b%}=OR(INT{b%},AND(BTST(bmov2_t&,14),2048))
        ENDIF
      ELSE
        IF BTST(bmov2_t&,11)
          INT{c%}=BCLR(ADD(INT{c%},AND(BTST(bmov2_t&,14),256)),11)
        ELSE
          INT{c%}=OR(INT{c%},AND(BTST(bmov2_t&,14),2048))
        ENDIF
      ENDIF
    ELSE
      INT{b%}=bmov2_t&
      INT{c%}=bmov2_t&
    ENDIF
    ADD b%,2
    ADD c%,2
  NEXT bmov2_t%
DEFAULT
  BMOVE a%,b%,32
  BMOVE a%,c%,32
ENDSELECT
RETURN
> PROCEDURE calclav
LOCAL i&,t%
eff({ADD(table%,82)},120)
FOR t%={ADD(table%,78)} TO ADD(t%,119)
  BYTE{t%}=2
NEXT t%
FOR i&=FALSE TO 19
  IF bt&(i&)>TRUE
    BYTE{ADD(bt&(i&),{ADD(table%,78)})}=FALSE
  ENDIF
  IF bt&(ADD(i&,20))>TRUE
    BYTE{ADD(bt&(ADD(i&,20)),{ADD(table%,78)})}=1
  ENDIF
NEXT i&
CLR t%,i&
RETURN
'
> PROCEDURE hide                          ! Cache le curseur souris (non systeme)
curson&=FALSE
CARD{ADD(table%,68)}=TRUE
~C:inter%(4)
RETURN
> PROCEDURE showm                         ! Montre le curseur souris (non systeme)
IF curson&=FALSE
  curson&=TRUE
  CARD{ADD(table%,46)}=TRUE
  CARD{ADD(table%,68)}=FALSE
ENDIF
RETURN
> PROCEDURE vs                            ! VBL synchro
IF on&
  CARD{ADD(table%,50)}=TRUE
  REPEAT
  UNTIL CARD{ADD(table%,50)}=FALSE
ELSE
  VSYNC
ENDIF
RETURN
'
' OPTIONS
'
> PROCEDURE 4                     ! Options
LOCAL ext&
appx(310,112,317,168)
tracop
atm0
REPEAT
  ms2
  tabicone(FALSE,FALSE,119,14,120,15,FALSE,11,93)
  tabicone(120,FALSE,99,14,100,15,1,7,94)
  icone(FALSE,180,319,199,10)
  IF @inp_
    ext&=act&(@inp)=61
  ENDIF
UNTIL ext&
appx(FALSE,180,319,199)
normpal
reput
norm
atm0
RETURN
> PROCEDURE tracop                ! Trace les selecteurs correspondant
LOCAL t&,i&,aux&,state&,j&
mouseoff
IF curson&
  state&=TRUE
  @hide
ENDIF
raster(MKL$(old%))
deic2(FALSE,FALSE,319,199)
resx(FALSE,180,319,199)
defx
GRAPHMODE 2
FOR t&=FALSE TO 11
  resicone(FALSE,FALSE,119,14,120,15,FALSE,t&)
  FOR i&=FALSE TO 1
    resicone(120,FALSE,99,14,100,15,i&,t&)
    IF t&<7
      j&=ADD(SHL&(t&,1),i&)
      IF j&<13
        IF pref&(j&)
          appicone(122,2,95,10,100,15,i&,t&)
        ELSE
          resicone(122,2,95,10,100,15,i&,t&)
        ENDIF
        TEXT ADD(130,MUL(i&,100)),ADD(9,MUL(t&,15)),@rd$(5,ADD(j&,3))
      ENDIF
    ENDIF
  NEXT i&
NEXT t&
TEXT 10,25,@rd$(62,@supnb(suppal&))
TEXT 20,192,@rd$(74,FALSE)
IF NOT BTST(PEEK(&HFFFF820A),1)
  appicone(FALSE,FALSE,119,14,120,15,FALSE,2)
ENDIF
IF AND(blitp&,blit&)
  appicone(FALSE,FALSE,119,14,120,15,FALSE,FALSE)
ENDIF
FOR t&=FALSE TO 6
  IF OR(blitp&,t&)
    TEXT 10,ADD(MUL(t&,15),10),@rd$(45,t&)
  ENDIF
  IF t&<3
    TEXT 10,ADD(MUL(ADD(t&,8),15),10),@rd$(5,t&)
  ENDIF
NEXT t&
'
IF state&
  @showm
ENDIF
mouseon
CLR t&,i&,aux&,j&
RETURN
> PROCEDURE 94                    ! Switch bouton de pr‚f‚rence On/Off
LOCAL j&
IF i&<7
  j&=ADD(SHL(i&,1),t&)
  IF j&<13
    pref&(j&)=NOT pref&(j&)
    IF pref&(j&)
      appx(ADD(xh&,2),ADD(yh&,2),SUB(xb&,2),SUB(yb&,2))
    ELSE
      resx(ADD(xh&,2),ADD(yh&,2),SUB(xb&,2),SUB(yb&,2))
    ENDIF
  ENDIF
ENDIF
CLR j&
atm0
RETURN
> PROCEDURE 93                    ! Gestø options
LOCAL j&,a$,al&
SELECT i&
CASE 1,3,5,6,8,10
  appx(xh&,yh&,xb&,yb&)
  SELECT i&
  CASE 5
    95
  CASE 6
    96
  CASE 1
    menupal(20,50,1)
    arec(ADD(xh&,1),ADD(yh&,1),SUB(xb&,1),SUB(yb&,1),2,FALSE)
    tex2(10,ADD(yh&,10),@rd$(62,@supnb(suppal&)))
  CASE 3
    al&=lang&
    lang&=@pop_up(xh&,yb&,56,2,FALSE,@rd$(58,FALSE),TRUE,lang&)
    IF al&<>lang&
      @loadlang
      tracop
    ENDIF
  CASE 8
    info
  CASE 10
    k&=FALSE
    FOR j&=FALSE TO nbec&
      IF savd&(j&)
        k&=TRUE
      ENDIF
    NEXT j&
    IF k&
      al&=@alt(TRUE,TRUE,@rd$(7,FALSE),@rd$(8,FALSE),1)
    ELSE
      al&=FALSE
    ENDIF
    IF al&=FALSE
      lib
    ENDIF
  ENDSELECT
  resx(xh&,yh&,xb&,yb&)
DEFAULT
  SELECT i&
  CASE 0
    IF blitp&
      blit&=NOT blit&
      IF blit&
        appx(xh&,yh&,xb&,yb&)
      ELSE
        resx(xh&,yh&,xb&,yb&)
      ENDIF
    ENDIF
    lkblit
  CASE 2
    SPOKE &HFF820A,BCHG(PEEK(&HFF820A),1)
    IF BTST(PEEK(&HFF820A),1)
      resx(xh&,yh&,xb&,yb&)
    ELSE
      appx(xh&,yh&,xb&,yb&)
    ENDIF
  ENDSELECT
  atm0
ENDSELECT
CLR k&,j&,a$,al&
RETURN
> PROCEDURE 95                    ! Sauvegarde pr‚f‚rences
appx(xh&,yh&,xb&,yb&)
a$=@form_path$(spath$,"INF")
vide$="DEFAULT.INF"
select(ado%,a$,vide$)
IF vide$<>""
  mouseoff
  i%=ADD(ado%,6)
  {ado%}=CVL("PRE2")
  j&=FALSE
  FOR t&=FALSE TO 12                  ! ON SAUVE LES <> RUBRIQUES si PREF(t&)
    IF pref&(t&)
      INC j&
      i2%=i%
      ADD i%,2
      SELECT t&
      CASE 0                          ! TRACK ANIMATION
        {i%}=CVL("ANIM")
        ADD i%,4
        BMOVE V:anim&(FALSE),i%,288
        ADD i%,288
        INT{i%}=deban&
        ADD i%,2
        INT{i%}=endan&
        ADD i%,2
        INT{i%}=anim&
        ADD i%,2
      CASE 1                          ! ECRAN (Protection & Touche)
        {i%}=CVL("ECRA")
        ADD i%,4
        INC nbec&
        BMOVE V:nec&(FALSE),i%,12
        ADD i%,12
        INT{i%}=nbec&
        ADD i%,2
        BMOVE V:protec&(FALSE),i%,SHL&(nbec&,1)
        ADD i%,SHL&(nbec&,1)
        DEC nbec&
        INT{i%}=ecran&
        ADD i%,2
        INT{i%}=mode&
        ADD i%,2
      CASE 2                          ! PALETTES (Tous les ecrans)
        {i%}=CVL("PALT")
        ADD i%,4
        INC nbec&
        INT{i%}=nbec&
        ADD i%,2
        BMOVE V:rvb&(FALSE,FALSE),i%,SHL&(nbec&,5)
        ADD i%,SHL&(nbec&,5)
        DEC nbec&
        INT{i%}=debc&
        ADD i%,2
        INT{i%}=endc&
        ADD i%,2
      CASE 3                          ! LIGNES
        {i%}=CVL("LIGN")
        ADD i%,4
        BMOVE V:line%(FALSE),i%,8
        ADD i%,8
        INT{i%}=debli&
        ADD i%,2
        INT{i%}=endli&
        ADD i%,2
        INT{i%}=htline&
        ADD i%,2
        INT{i%}=line&
        ADD i%,2
      CASE 4                          ! TRAMES (toutes)
        {i%}=CVL("TRME")
        ADD i%,4
        FOR a&=FALSE TO 11
          FOR b&=FALSE TO 15
            FOR i&=FALSE TO 15
              BYTE{i%}=tram|(a&,b&,i&)
              INC i%
            NEXT i&
          NEXT b&
        NEXT a&
        INT{i%}=fill&
        ADD i%,2
        INT{i%}=plein&
        ADD i%,2
      CASE 5                          ! PINCEAUX (tous)
        {i%}=CVL("PINC")
        ADD i%,4
        FOR a&=12 TO 23
          FOR b&=FALSE TO 15
            FOR i&=FALSE TO 15
              BYTE{i%}=tram|(a&,b&,i&)
              INC i%
            NEXT i&
          NEXT b&
        NEXT a&
        INT{i%}=pincmono&
        ADD i%,2
        INT{i%}=half&
        ADD i%,2
      CASE 6                          ! REMPLACEMENT couleurs
        {i%}=CVL("REPL")
        ADD i%,4
        BMOVE V:crap&(FALSE),i%,32
        ADD i%,32
      CASE 7                          ! AEROGRAPHE (couleurs)
        {i%}=CVL("AERO")
        ADD i%,4
        BMOVE V:aero&(FALSE),i%,32
        ADD i%,32
        INT{i%}=multia&
        ADD i%,2
        INT{i%}=forme&
        ADD i%,2
        INT{i%}=tempaero&
        ADD i%,2
      CASE 8
        {i%}=CVL("DIVS")                    ! DIVERS
        ADD i%,4
        INT{i%}=BTST(PEEK(&HFF820A),1)      ! SYNC
        ADD i%,2
        INT{i%}=suppal&                     ! PALETTE STE
        ADD i%,2
        INT{i%}=blit&                       ! BLITTER
        ADD i%,2
        INT{i%}=charg&                      ! FORMAT CHARGEMENT
        ADD i%,2
        INT{i%}=sauv&                       ! FORMAT SAUVEGARDE
        ADD i%,2
        INT{i%}=lang&
        ADD i%,2
        INT{i%}=LEN(cpath$)
        BMOVE V:cpath$,ADD(i%,2),INT{i%}
        ADD i%,AND(ADD(INT{i%},3),&HFFFE)
        INT{i%}=LEN(spath$)
        BMOVE V:spath$,ADD(i%,2),INT{i%}
        ADD i%,AND(ADD(INT{i%},3),&HFFFE)
      CASE 9
        {i%}=CVL("FULL")
        ADD i%,4
        BMOVE V:full&(FALSE),i%,8
        ADD i%,8
        BMOVE V:fcx&(FALSE),i%,8
        ADD i%,8
        BMOVE V:fcy&(FALSE),i%,8
        ADD i%,8
        INT{i%}=delx&
        ADD i%,2
        INT{i%}=dely&
        ADD i%,2
      CASE 10
        {i%}=CVL("CLAV")
        ADD i%,4
        BMOVE V:act&(FALSE),i%,242
        ADD i%,242
        BMOVE V:bt&(FALSE),i%,80
        ADD i%,80
      CASE 11
        {i%}=CVL("MOUS")
        ADD i%,4
        BMOVE V:mouse$,i%,64
        ADD i%,64
        BMOVE V:mouse2$,i%,64
        ADD i%,64
        INT{i%}=hotdx&
        ADD i%,2
        INT{i%}=hotdy&
        ADD i%,2
        INT{i%}=hotpx&
        ADD i%,2
        INT{i%}=hotpy&
        ADD i%,2
        INT{i%}=smopanel&
        ADD i%,2
        INT{i%}=smodess&
        ADD i%,2
        INT{i%}=smoloup&
        ADD i%,2
      CASE 12
        {i%}=CVL("VIDI")
        ADD i%,4
        INT{i%}=debdigi&
        ADD i%,2
        INT{i%}=enddigi&
        ADD i%,2
        INT{i%}=img_per_sec&
        ADD i%,2
      ENDSELECT
      INT{i2%}=SUB(i%,i2%)
    ENDIF
  NEXT t&
  INT{ADD(ado%,4)}=j&
  path("INF")
  inter_off
  BSAVE fich$,ado%,SUB(i%,ado%)
  inter_on
  mouseon
ENDIF
resx(xh&,yh&,xb&,yb&)
RETURN
> PROCEDURE 96                    ! S‚lection pour chargement pr‚f‚rences
appx(xh&,yh&,xb&,yb&)
a$=@form_path$(cpath$,"INF")
vide$="DEFAULT.INF"
select(ado%,a$,vide$)
IF k&
  aux&=lang&
  @loadpref
  IF aux&<>lang&
    @loadlang
  ELSE
    retake2
  ENDIF
ENDIF
tracop
RETURN
> PROCEDURE retake2
BMOVE ecran%,ado%,32000
phy(ado%)
retake
phy(ecran%)
RETURN
> PROCEDURE loadlang              ! Charge fichiers selon la langue
inter_off
openf&=TRUE
load("PARAMB"+STR$(lang&),param%,TRUE,fat$)
load("PANEAU"+STR$(lang&),pan1%,FALSE,fat$)
load("TXLANG"+STR$(lang&),message%,FALSE,fat$)
openf&=FALSE
inter_on
retake2
RETURN
> PROCEDURE loadpref              ! Chargement pr‚f‚rences
LOCAL t&,i&,a&,b&
inter_off
OPEN "i",#1,fich$
openf&=TRUE
IF INP%(#1)=CVL("PRE2")
  mouseoff
  j&=INP&(#1)
  BGET #1,ado%,SUB(LOF(#1),6)
  i%=ado%
  IF j&
    FOR t&=1 TO j&
      i2%=ADD(i%,INT{i%})
      ADD i%,6
      SELECT MKL$({SUB(i%,4)})
      CASE "DIVS"
        IF pref&(8)
          IF XOR(BTST(PEEK(&HFFFF820A),1),INT{i%})
            SPOKE &HFFFF820A,BCHG(PEEK(&HFFFF820A),1)
          ENDIF
          ADD i%,2
          suppal&=MIN(INT{i%},ADD(14,AND(ste&,16)))
          ADD i%,2
          IF blitp&                           ! Blitter on/off
            blit&=INT{i%}
            lkblit
          ENDIF
          ADD i%,2
          charg&=INT{i%}                       ! Format chargement/sauvegarde
          ADD i%,2
          IF AND(nbec&<3,charg&=4)
            charg&=1
          ENDIF
          sauv&=INT{i%}
          ADD i%,2
          IF AND(nbec&<3,OR(sauv&=5,sauv&=6))
            sauv&=1
          ENDIF
          lang&=MIN(1,MAX(FALSE,INT{i%}))
          ADD i%,2
          cpath$=SPACE$(INT{i%})
          BMOVE ADD(i%,2),V:cpath$,INT{i%}
          ADD i%,AND(ADD(INT{i%},3),&HFFFE)
          spath$=SPACE$(INT{i%})
          BMOVE ADD(i%,2),V:spath$,INT{i%}
          ADD i%,AND(ADD(INT{i%},3),&HFFFE)
          lkchargph
          lksauvph
        ENDIF
      CASE "ANIM"
        IF pref&(FALSE)
          BMOVE i%,V:anim&(FALSE),288
          ADD i%,288
          FOR a&=FALSE TO 143
            IF AND(anim&(a&),&HFF)>nbec&
              anim&(a&)=OR(AND(anim&(a&),&HFF00),nbec&)
            ENDIF
          NEXT a&
          deban&=INT{i%}
          ADD i%,2
          endan&=INT{i%}
          ADD i%,2
          anim&=INT{i%}
          ADD i%,2
          mode&=INT{i%}
          ADD i%,2
        ENDIF
      CASE "ECRA"
        IF pref&(1)
          BMOVE i%,V:nec&(FALSE),12
          FOR a&=FALSE TO 5
            nec&(a&)=MIN(nec&(a&),nbec&)
          NEXT a&
          ADD i%,12
          a&=INT{i%}
          ADD i%,2
          BMOVE i%,V:protec&(FALSE),SHL&(MIN(ADD(nbec&,1),a&),1)
          ADD i%,SHL&(a&,1)
          ecran&=MIN(INT{i%},nbec&)
          ADD i%,2
        ENDIF
      CASE "PALT"                          ! PALETTE (toutes)
        IF pref&(2)
          a&=INT{i%}
          ADD i%,2
          BMOVE i%,V:rvb&(FALSE,FALSE),SHL&(MIN(a&,ADD(nbec&,1)),5)
          ADD i%,SHL&(a&,5)
          BMOVE pan%,ADD(ecran%,16000),1600
          arec(MUL(debc&,20),100,ADD(MUL(debc&,20),6),108,debc&,FALSE)
          arec(ADD(MUL(endc&,20),13),100,ADD(MUL(endc&,20),18),108,endc&,FALSE)
          debc&=INT{i%}
          ADD i%,2
          endc&=INT{i%}
          ADD i%,2
          PUT MUL(debc&,20),100,fg$,ADD(1,AND(debc&=FALSE,8))
          PUT ADD(MUL(endc&,20),13),100,fd$,ADD(1,AND(endc&=FALSE,8))
          BMOVE ADD(ecran%,16000),pan%,1600
          ppal(c&)
        ENDIF
      CASE "LIGN"                             ! LIGNES
        IF pref&(3)
          BMOVE i%,V:line%(FALSE),8
          ADD i%,8
          debli&=INT{i%}
          ADD i%,2
          endli&=INT{i%}
          ADD i%,2
          htline&=INT{i%}
          ADD i%,2
          line&=INT{i%}
          ADD i%,2
        ENDIF
      CASE "TRME"                             ! TRAMES (toutes)
        IF pref&(4)
          FOR a&=FALSE TO 11
            FOR b&=FALSE TO 15
              FOR i&=FALSE TO 15
                tram|(a&,b&,i&)=BYTE{i%}
                INC i%
              NEXT i&
            NEXT b&
          NEXT a&
          FOR a&=FALSE TO 11
            deft(a&)
          NEXT a&
          fill&=INT{i%}
          ADD i%,2
          plein&=INT{i%}
          ADD i%,2
        ENDIF
      CASE "PINC"                      ! PINCEAUX (tous)
        IF pref&(5)
          FOR a&=12 TO 23
            FOR b&=FALSE TO 15
              FOR i&=FALSE TO 15
                tram|(a&,b&,i&)=BYTE{i%}
                INC i%
              NEXT i&
            NEXT b&
          NEXT a&
          FOR a&=12 TO 23
            deft(a&)
          NEXT a&
          pincmono&=INT{i%}
          ADD i%,2
          half&=INT{i%}
          ADD i%,2
        ENDIF
      CASE "REPL"                          ! REMPLACEMENT couleurs
        IF pref&(6)
          BMOVE i%,V:crap&(FALSE),32
          ADD i%,32
        ENDIF
      CASE "AERO"                          ! AEROGRAPHE (couleurs)
        IF pref&(7)
          BMOVE i%,V:aero&(FALSE),32
          ADD i%,32
          mutia&=INT{i%}
          ADD i%,2
          forme&=INT{i%}
          ADD i%,2
          tempaero&=INT{i%}
          ADD i%,2
        ENDIF
      CASE "FULL"
        IF pref&(9)
          BMOVE i%,V:full&(FALSE),8
          ADD i%,8
          BMOVE i%,V:fcx&(FALSE),8
          ADD i%,8
          BMOVE i%,V:fcy&(FALSE),8
          ADD i%,8
          delx&=INT{i%}
          ADD i%,2
          dely&=INT{i%}
          ADD i%,2
          FOR i&=FALSE TO 3
            full&(i&)=MIN(full&(i&),nbec&)
          NEXT i&
        ENDIF
      CASE "CLAV"
        IF pref&(10)
          BMOVE i%,V:act&(FALSE),242
          ADD i%,242
          BMOVE i%,V:bt&(FALSE),80
          ADD i%,80
          calclav
        ENDIF
      CASE "MOUS"
        IF pref&(11)
          BMOVE i%,V:mouse$,64
          ADD i%,64
          BMOVE i%,V:mouse2$,64
          ADD i%,64
          hotdx&=INT{i%}
          ADD i%,2
          hotdy&=INT{i%}
          ADD i%,2
          hotpx&=INT{i%}
          ADD i%,2
          hotpy&=INT{i%}
          ADD i%,2
          smopanel&=INT{i%}
          ADD i%,2
          smodess&=INT{i%}
          ADD i%,2
          smoloup&=INT{i%}
          ADD i%,2
          sensmo(smopanel&)
          defmo(V:mouse$,hotpx&,hotpy&)
        ENDIF
      CASE "VIDI"
        IF pref&(12)
          debdigi&=INT{i%}
          ADD i%,2
          enddigi&=INT{i%}
          ADD i%,2
          img_per_sec&=INT{i%}
          ADD i%,2
        ENDIF
      ENDSELECT
      i%=i2%
    NEXT t&
  ENDIF
  mouseon
ELSE
  warningfich(@rd$(60,FALSE))
ENDIF
CLOSE #1
openf&=FALSE
inter_on
CLR a&,b&,i&,t&
RETURN
> PROCEDURE info                  ! Infos
LOCAL t&
@hide
BMOVE ecran%,ado%,32000
deic2(FALSE,FALSE,319,177)
deic2(FALSE,178,319,199)
defx
GRAPHMODE 2
TEXT 10,196,@rd$(42,FALSE)
GRAPHMODE 1
inter_off
load("INFOSCR",lst%,TRUE,fat$)
inter_on
necho
mouseoff
FOR t&=FALSE TO 360
  sn&(t&)=ROUND(SINQ(t&)*100)
NEXT t&
FOR t&=1 TO 15000
  BYTE{ADD(lst%,SUB(t&,1))}=SUB(BYTE{ADD(lst%,SUB(t&,1))},sn&(MOD(t&,360)))
NEXT t&
~C:lst%(L:SUB(ecran%,1440),W:lang&)
FOR t&=FALSE TO 360
  sn&(t&)=ROUND(SINQ(t&)*30000)
NEXT t&
mouseon
necho
k&=FALSE
BMOVE ado%,ecran%,32000
atm0
@showm
CLR t&
RETURN
'
' ACCES DISQUE
'
> PROCEDURE apac                          ! Appel ac (pour appel a partir de boucle principale)
ac(ec&,cursec&)
ec&=nec&(cursec&)
reput
note(FALSE)
normpal
RETURN
> PROCEDURE ac(ec&,VAR cursec&)           ! Gestø disque
LOCAL t&,tch&,ext&
trac_ac
atm0
REPEAT
  ms2
  tabicone(FALSE,FALSE,159,14,FALSE,15,FALSE,11,13)
  tabicone(160,FALSE,159,14,FALSE,15,FALSE,11,57)
  tabicone(FALSE,180,39,19,40,FALSE,5,FALSE,92)
  icone(280,180,319,199,10)
  IF @inp_
    tch&=@inp
    SELECT act&(tch&)
    CASE 11 TO 16
      k&=1
      t&=SUB(act&(tch&),11)
      92
    CASE 61
      ext&=TRUE
    ENDSELECT
  ENDIF
UNTIL ext&
appx(280,180,319,199)
totalc
CLR t&,tch&,ext&
RETURN
> PROCEDURE 92                            ! Gestion touche ecran de 'ac'
IF k&=1
  COLOR 3
  @hide
  BOX ADD(MUL(cursec&,40),2),182,ADD(MUL(cursec&,40),37),197
  cursec&=t&
  appicone(2,182,35,15,40,20,cursec&,FALSE)
  @showm
  ec&=nec&(cursec&)
  atm0
ELSE
  phy(ec%(nec&(t&)))
  raster(MKL$(V:rvb&(FALSE,nec&(t&))))
  atm0
  phy(ecran%)
  raster(MKL$(old%))
ENDIF
RETURN
> PROCEDURE trac_ac                       ! Trace les selecteurs correspondants
LOCAL t&,aux&
raster(MKL$(old%))
@hide
mouseoff
totalc
deic2(FALSE,FALSE,319,199)
defx
GRAPHMODE 2
FOR t&=FALSE TO 11
  aux&=MUL(t&,15)
  IF t&=10
    resx(FALSE,aux&,319,ADD(aux&,14))
  ELSE
    resx(FALSE,aux&,159,ADD(aux&,14))
    resx(160,aux&,319,ADD(aux&,14))
  ENDIF
  SELECT t&
  CASE 0 TO 9
    TEXT 5,ADD(aux&,10),@rd$(1,t&)
    TEXT 165,ADD(aux&,10),@rd$(1,ADD(t&,12))
  CASE 11
    TEXT 5,ADD(aux&,10),@rd$(68,charg&)
    TEXT 165,ADD(aux&,10),@rd$(70,sauv&)
  ENDSELECT
NEXT t&
FOR t&=FALSE TO 7
  resx(MUL(t&,40),180,ADD(MUL(t&,40),39),199)
  IF t&<6
    TEXT ADD(MUL(t&,40),10),191,STR$(ADD(nec&(t&),1))
  ENDIF
NEXT t&
TEXT 5,160,@rd$(80,-digizone&)
appicone(2,182,35,15,40,20,cursec&,FALSE)
TEXT 286,191,@rd$(74,FALSE)
GRAPHMODE 1
mouseon
@showm
CLR aux&,t&
RETURN
> PROCEDURE 13                            ! Gestion icones typ chargement & chargement
LOCAL a$,al$,b&,al&,a&
SELECT i&
CASE 0,1,2,4,6 TO 11
  appx(xh&,yh&,xb&,yb&)
  SELECT i&
  CASE 0
    pdis
  CASE 1
    rnam
  CASE 2                        ! Make directory
    vide$="DEFAULT.DIR"
    select(lst%,cpath$,vide$)
    IF vide$<>""
      MKDIR fich$
    ENDIF
  CASE 4,6,7,8,9                ! Chargement
    inter_off
    GET FALSE,180,319,199,al$
    SELECT AND(i&,charg&<>4)
    CASE 0,4                          ! Chargement simple
      al&=FALSE
      IF charg&<>4
        IF protec&(ec&)
          al&=@alt(TRUE,TRUE,@rd$(18,FALSE),@rd$(19,FALSE),1)
        ELSE
          al&=FALSE
        ENDIF
      ELSE
        al&=FALSE
        FOR b&=FALSE TO 3
          IF protec&(full&(b&))
            al&=TRUE
          ENDIF
        NEXT b&
        IF al&
          al&=@alt(TRUE,TRUE,@rd$(20,FALSE),@rd$(19,FALSE),1)
        ENDIF
      ENDIF
      IF al&=FALSE
        a$=nom$(ec&)
        affile(ec&)
        select(lst%,cpath$,a$)
        IF a$<>""
          nom$(ec&)=a$
          pload(ec&)
        ENDIF
      ENDIF
    CASE 6                            ! Chargement 6 ecrans
      FOR b&=FALSE TO 5
        IF NOT protec&(nec&(b&))
          a$=nom$(nec&(b&))
          affile(nec&(b&))
          select(lst%,cpath$,a$)
          IF a$<>""
            nom$(nec&(b&))=a$
            pload(nec&(b&))
          ENDIF
        ENDIF
      NEXT b&
    CASE 7                            ! Chargement X ecran(s)
      b&=MAX(ec&,AND(debdigi&,digizone&))
      REPEAT
        a$=nom$(b&)
        affile(b&)
        select(lst%,cpath$,a$)
        IF NOT protec&(b&)
          IF a$<>""
            nom$(b&)=a$
            pload(b&)
          ENDIF
        ENDIF
        INC b&
      UNTIL OR(OR(b&>nbec&,a$=""),AND(digizone&,b&>enddigi&))
      PUT FALSE,180,al$
      inter_on
      mouseon
    CASE 8                          ! Chargement par fat
      b&=MAX(ec&,AND(debdigi&,digizone&))
      a$=nom$(b&)
      deic2(FALSE,180,319,199)
      tex2(10,191,@rd$(16,FALSE))
      select(lst%,cpath$,a$)
      IF a$<>""
        ~FSETDTA(ADD(BASEPAGE,128))
        IF FSFIRST(fich$,FALSE)=FALSE
          a&=FALSE
          REPEAT
            IF NOT protec&(b&)
              IF a&=FALSE
                fich$=CHAR{ADD(BASEPAGE,158)}
                affile(b&)
                nom$(b&)=fich$
                fich$=LEFT$(cpath$,RINSTR(cpath$,"\"))+fich$
                pload(b&)
              ENDIF
              a&=FSNEXT()
            ENDIF
            INC b&
          UNTIL OR(OR(OR(b&>nbec&,a&),INP(-2)),AND(digizone&,b&>enddigi&))
          necho
        ENDIF
      ENDIF
    CASE 9
      deic2(FALSE,180,319,199)
      tex2(10,191,@rd$(16,1))
      b&=MAX(ec&,AND(debdigi&,digizone&))
      a$=nom$(b&)
      select(lst%,cpath$,a$)
      IF a$<>""
        IF AND(INSTR(a$,".")<7,INSTR(a$,"."))
          a$=LEFT$(a$,SUB(INSTR(a$,"."),1))
        ELSE
          a$=LEFT$(a$,MIN(5,LEN(a$)))
        ENDIF
        a&=FALSE
        REPEAT
          IF NOT protec&(b&)
            fich$=LEFT$(cpath$,RINSTR(cpath$,"\"))+a$+STRING$(SUB(3,LEN(STR$(a&))),"0")+STR$(a&)
            path(@rd$(69,charg&))
            IF EXIST(fich$)
              affile(b&)
              pload(b&)
              INC b&
            ELSE
              deic2(FALSE,180,319,199)
              tex2(10,195,@rd$(75,FALSE))
            ENDIF
            INC a&
          ELSE
            INC b&
          ENDIF
        UNTIL OR(OR(OR(INP(-2),b&>nbec&),a&>999),AND(digizone&,b&>enddigi&))
      ENDIF
    ENDSELECT
    PUT FALSE,180,al$
    inter_on
  CASE 10
    flipdigizone
  CASE 11                             ! Choix format de chargement
    charg&=@pop_up(140,FALSE,68,11,FALSE,@rd$(16,2),TRUE,charg&)
    deic2(xh&,yh&,xb&,yb&)
    tex2(5,ADD(yh&,10),@rd$(68,charg&))
    lkchargph
  ENDSELECT
  atm0
  IF i&<>10
    resx(xh&,yh&,xb&,yb&)
  ENDIF
ENDSELECT
CLR a$,al$,a&,b&,al&
RETURN
> PROCEDURE affile(ec&)                   ! Affiche barre info sur chargement
LOCAL b&
deic2(FALSE,180,319,199)
IF charg&<>4
  tex2(10,189,@rd$(47,FALSE)+" Nø "+STR$(ADD(ec&,1)))
ELSE
  tex2(10,189,@rd$(47,1))
  FOR b&=FALSE TO 3
    tex2(ADD(200,SHL(b&,5)),189,"Nø"+STR$(ADD(full&(b&),1)))
  NEXT b&
ENDIF
CLR b&
RETURN
> PROCEDURE 57                            ! Gestion icones typ sauvegarde & sauvegarde
LOCAL mode&,al$,a$,b&,a&
SELECT i&
CASE 0,1,4,6 TO 11
  appx(xh&,yh&,xb&,yb&)
  SELECT i&
  CASE 0
    formt
  CASE 1
    @kill
  CASE 4,6 TO 9                        ! Sauvegarde
    IF AND(AND(sauv&<>5,sauv&<>8),i&<>4)   ! Que les ecrans prot‚g‚s ?
      atm0
      mode&=SUB(@alt(TRUE,TRUE," ",@rd$(23,FALSE),FALSE),1)
    ENDIF
    inter_off
    GET FALSE,180,319,199,al$
    necho
    SELECT AND(i&,AND(sauv&<>5,sauv&<>8))  ! Si sauve simple ou ecran overscan
    CASE 0,4                            ! Sauvegarde simple
      a$=nom$(ec&)
      affile2(ec&)
      select(lst%,spath$,a$)
      IF a$<>""
        nom$(ec&)=a$
        psav(ec&)
      ENDIF
    CASE 6                              ! Sauvegarde 6 ecrans
      FOR b&=FALSE TO 5
        IF OR(mode&,protec&(nec&(b&)))
          a$=nom$(nec&(b&))
          affile2(nec&(b&))
          select(lst%,spath$,a$)
          IF a$<>""
            nom$(nec&(b&))=a$
            psav(nec&(b&))
          ENDIF
        ENDIF
      NEXT b&
    CASE 7                              ! Sauvegarde X ecran(s)
      b&=MAX(ec&,AND(debdigi&,digizone&))
      REPEAT
        a$=nom$(b&)
        IF OR(protec&(b&),mode&)
          affile2(b&)
          select(lst%,spath$,a$)
          IF a$<>""
            nom$(b&)=a$
            psav(b&)
          ENDIF
        ENDIF
        INC b&
      UNTIL OR(OR(b&>nbec&,a$=""),AND(b&>enddigi&,digizone&))
      PUT FALSE,180,al$
      inter_on
      mouseon
    CASE 8                            ! Sauvegarde automatique
      b&=MAX(ec&,AND(debdigi&,digizone&))
      a$=nom$(b&)
      select(lst%,spath$,a$)
      IF a$<>""
        REPEAT
          IF OR(protec&(b&),mode&)
            fich$=LEFT$(spath$,RINSTR(spath$,"\"))+nom$(b&)
            affile2(b&)
            psav(b&)
          ENDIF
          INC b&
        UNTIL OR(OR(b&>nbec&,INP(-2)),AND(b&>enddigi&,digizone&))
      ENDIF
      PUT FALSE,180,al$
      inter_on
      mouseon
    CASE 9                            ! Sauvegarde avec compteur
      deic2(FALSE,180,319,199)
      tex2(10,191,@rd$(16,1))
      a$=nom$(ec&)
      select(lst%,spath$,a$)
      IF a$<>""
        IF AND(INSTR(a$,".")<7,INSTR(a$,"."))
          a$=LEFT$(a$,SUB(INSTR(a$,"."),1))
        ELSE
          a$=LEFT$(a$,MIN(5,LEN(a$)))
        ENDIF
        b&=MAX(ec&,AND(debdigi&,digizone&))
        a&=FALSE
        REPEAT
          IF OR(protec&(b&),mode&)
            fich$=LEFT$(spath$,RINSTR(spath$,"\"))+a$+STRING$(SUB(SUB(8,LEN(a$)),LEN(STR$(a&))),"0")+STR$(a&)
            affile2(b&)
            psav(b&)
            INC b&
            INC a&
          ELSE
            INC b&
          ENDIF
        UNTIL OR(OR(OR(INP(-2),b&>nbec&),a&>999),AND(b&>enddigi&,digizone&))
      ENDIF
    ENDSELECT
    PUT FALSE,180,al$
    inter_on
  CASE 10
    flipdigizone
  CASE 11                             ! Choix format de sauvegarde
    sauv&=@pop_up(FALSE,FALSE,70,9,FALSE,@rd$(16,3),TRUE,sauv&)
    deic2(xh&,yh&,xb&,yb&)
    tex2(165,ADD(yh&,10),@rd$(70,sauv&))
    lksauvph
  ENDSELECT
  atm0
  IF i&<>10
    resx(xh&,yh&,xb&,yb&)
  ENDIF
ENDSELECT
RETURN
> PROCEDURE flipdigizone                  ! Affichage touche 'Digizone Off/On'
appx(FALSE,yh&,319,yb&)
digizone&=NOT digizone&
arec(1,ADD(yh&,1),318,SUB(yb&,1),2,FALSE)
tex2(5,ADD(yh&,10),@rd$(80,-digizone&))
atm0
resx(FALSE,yh&,319,yb&)
RETURN
> PROCEDURE affile2(ec&)                  ! Affiche barre info sur sauvegarde
LOCAL b&
deic2(FALSE,180,319,199)
SELECT sauv&
CASE 5
  tex2(10,189,@rd$(48,1))
  FOR b&=FALSE TO 3
    tex2(ADD(200,SHL(b&,5)),189,"Nø"+STR$(ADD(full&(b&),1)))
  NEXT b&
CASE 8
  tex2(10,189,@rd$(83,FALSE)+"  "+@rd$(83,1)+" Nø"+STR$(ADD(nec&(FALSE),1))+"  "+@rd$(83,2)+" Nø"+STR$(ADD(nec&(1),1))+"  "+@rd$(83,3)+" Nø"+STR$(ADD(nec&(2),1)))
DEFAULT
  tex2(10,189,@rd$(48,FALSE)+STR$(ADD(ec&,1)))
ENDSELECT
CLR b&
RETURN
> PROCEDURE pdis                          ! Place disponible sur lecteur courant
LOCAL f%
a&=ASC(LEFT$(UPPER$(spath$),1))
IF AND(AND(a&>64,a&<91),BTST(BIOS(10),SUB(a&,65)))
  SUB a&,65
ELSE
  a&=GEMDOS(25)
ENDIF
inter_off
f%=DFREE(ADD(a&,1))
inter_on
~@alt(TRUE,TRUE,@rd$(12,FALSE)+CHR$(ADD(a&,65))+":|"+STR$(f%)+" "+@rd$(12,1),"    Ok    ",FALSE)
CLR f%
RETURN
> PROCEDURE rnam                          ! Rename file
LOCAL a$
vide$="DEFAULT.PIC"
select(lst%,cpath$,vide$)
IF vide$<>""
  a$=fich$
  vide$="DEFAULT.PIC"
  select(lst%,cpath$,vide$)
  IF vide$<>""
    IF NOT EXIST(fich$)
      inter_off
      NAME a$ AS fich$
      inter_on
    ELSE
      ~@alt(85,70,@rd$(13,FALSE),"    Ok    ",FALSE)
    ENDIF
  ENDIF
ENDIF
CLR a$
RETURN
> PROCEDURE kill                          ! Delete file
LOCAL al&
REPEAT
  vide$="DEFAULT.PIC"
  select(lst%,spath$,vide$)
  IF vide$<>""
    al&=@alt(TRUE,TRUE,@rd$(30,FALSE)+"|"+fich$,@rd$(31,FALSE),1)
    IF al&=FALSE
      inter_off
      KILL fich$
      inter_on
    ENDIF
  ENDIF
UNTIL vide$=""
CLR al&
RETURN
> PROCEDURE formt                         ! Formatage
LOCAL x&,a&,t&,i&,aux2&,y1&,b&,al&,ero&,a$
IF @alt(TRUE,TRUE,@rd$(24,FALSE),@rd$(10,FALSE),1)=FALSE
  @hide
  GET 100,80,219,120,a$
  y1&=@alt(TRUE,TRUE,@rd$(25,FALSE),"   A:   |B:",FALSE)
  b&=ADD(@alt(TRUE,TRUE,@rd$(26,FALSE),"   9   |10",FALSE),9)
  a&=ADD(@alt(TRUE,TRUE,@rd$(27,FALSE),"   80   |81|82",FALSE),80)
  al&=@alt(TRUE,TRUE,@rd$(28,FALSE),@rd$(29,FALSE),FALSE)
  mouseoff
  i&=FALSE
  deic2(100,80,219,120)
  appx(105,85,ADD(106,a&),115)
  deic(192,85,214,115,FALSE)
  appx(192,85,214,115)
  FOR x&=SUB(a&,1) DOWNTO FALSE
    ATEXT 198,98,FALSE,STR$(x&)+SPACE$(-(x&<10))
    ALINE ADD(x&,106),86,ADD(x&,106),114,4,65535,FALSE
    ero&=XBIOS(10,L:ado%,1,FALSE,W:y1&,W:b&,W:x&,W:FALSE,W:1,L:&H87654321,W:&HE5)
    IF AND(al&=1,ero&<>-16)
      ero&=XBIOS(10,L:ado%,1,FALSE,W:y1&,W:b&,W:x&,W:1,W:1,L:&H87654321,W:&HE5)
    ENDIF
    IF ero&=-16 THEN
      mouseon
      ~@alt(TRUE,TRUE,@rd$(55,FALSE),"    Ok    ",FALSE)
      i&=TRUE
    ELSE
      i&=@inp_
    ENDIF
    EXIT IF i&
  NEXT x&
  IF NOT i&
    FOR t&=FALSE TO 10000 STEP 4
      LONG{ADD(ado%,t&)}=FALSE
    NEXT t&
    ~XBIOS(18,L:ado%,L:&H2000000,W:ADD(al&,2),W:FALSE)
    aux2&=MUL(MUL(a&,b&),ADD(al&,1))
    BYTE{ADD(ado%,19)}=AND(aux2&,&HFF)
    BYTE{ADD(ado%,20)}=SHR(AND(aux2&,&HFF00),8)
    BYTE{ADD(ado%,24)}=b&
    ~XBIOS(9,L:ado%,L:FALSE,W:y1&,W:1,W:FALSE,W:FALSE,W:b&)
    ~XBIOS(9,L:ADD(ado%,512),L:FALSE,W:y1&,W:1,W:1,W:FALSE,W:b&)
    mouseon
    k&=FALSE
    ~@alt(TRUE,TRUE,@rd$(12,FALSE)+CHR$(ADD(y1&,65))+": "+STR$(DFREE(ADD(y1&,1)))+" "+@rd$(12,1),"    Ok    ",FALSE)
  ENDIF
  mouseon
  PUT 100,80,a$
  @showm
ENDIF
CLR x&,a&,t&,i&,aux2&,y1&,b&,al&,ero&,a$
RETURN
> PROCEDURE pload(ec&)                    ! Routines de chargement
LOCAL a$,i&,j&,t&
tex2(10,197,fich$)
openf&=TRUE
SELECT charg&
CASE 0
  OPEN "i",#1,fich$                   ! Bit image
  BGET #1,ec%(ec&),MIN(LOF(#1),32000)
  BMOVE deg%,V:rvb&(FALSE,ec&),32
CASE 1
  normalen(2)                         ! Neochrome
CASE 2
  OPEN "i",#1,fich$                   ! ZZ Rought
  INPUT #1,a$
  IF LEFT$(a$,12)="(c)F.MARCHAL"
    i&=VAL(RIGHT$(a$,SUB(LEN(a$),12)))
    BGET #1,V:rvb&(FALSE,ec&),32
    BGET #1,ado%,i&
    d1%=ADD(ADD(ado%,i&),-ODD(i&))
    BGET #1,d1%,MUL(i&,4)
    i&=FALSE
    t&=FALSE
    FOR j&=FALSE TO 156 STEP 4
      FOR d2%=ec%(ec&) TO ADD(ec%(ec&),31840) STEP 160
        IF i&=FALSE
          i&=BYTE{ADD(ado%,t&)}
          a%=LONG{ADD(d1%,MUL(t&,4))}
          INC t&
        ENDIF
        LONG{ADD(d2%,j&)}=a%
        DEC i&
      NEXT d2%
    NEXT j&
    i&=FALSE
    t&=FALSE
  ELSE
    warningfich("ZZ ROUGHT")
  ENDIF
CASE 3
  normalen(1)                         ! Degas
CASE 4
  OPEN "i",#1,fich$
  BGET #1,ado%,2
  IF CARD{ado%}=&H4B44
    BGET #1,ado%,32
    FOR i&=FALSE TO 3
      BMOVE ado%,V:rvb&(FALSE,full&(i&)),32
      eff(ec%(full&(i&)),32000)
    NEXT i&
    ARRAYFILL fcx&(),FALSE
    ARRAYFILL fcy&(),FALSE
    BGET #1,ado%,63020
    consfull(ado%,TRUE)
  ELSE
    warningfich("KID")
  ENDIF
CASE 5
  normalen(8)                         ! Spectrum
CASE 6
  normalen(9)                         ! Img
CASE 7
  normalen(7)                         ! Tiny
CASE 8
  normalen(3)                         ! Art director
CASE 9
  j&=VAL(RIGHT$(fich$,1))             ! Dali
  SELECT j&
  CASE 0 TO 2
    normalen(ADD(j&,4))
  DEFAULT
    warningfich("DALI")
  ENDSELECT
CASE 10
  normalen(10)                        ! Stad
ENDSELECT
savd&(ec&)=FALSE
convert(suppal&,@ana,ec&,FALSE,FALSE)
CLOSE #1
openf&=FALSE
CLR a$,i&,t&,j&
RETURN
> PROCEDURE normalen(num&)
LOCAL l&,i%
OPEN "i",#1,fich$
SELECT num&
CASE 1
  i%=INP&(#1)
  IF AND(AND(i%,&HFF00)<>&H8000,AND(i%,&HFF00))
    l&=TRUE
  ELSE IF AND(i%,&HFF)>2
    l&=TRUE
  ENDIF
ENDSELECT
IF l&=FALSE
  SEEK #1,FALSE
  BGET #1,ado%,LOF(#1)
  ~C:loadrouts%(L:ado%,L:ADD(ado%,52000),L:ADD(ado%,90000),W:num&)
  BMOVE ADD(ado%,52000),ec%(ec&),32000
  BMOVE ADD(ado%,90000),V:rvb&(FALSE,ec&),32
ELSE
  SELECT num&
  CASE 1
    warningfich("DEGAS")
  ENDSELECT
ENDIF
CLR l&,i%
RETURN
> PROCEDURE psav(ec&)                     ! Routines de sauvegarde
LOCAL al&,t%
path(@rd$(69,sauv&))
tex2(10,197,fich$)
IF EXIST(fich$)
  al&=@alt(TRUE,TRUE,@rd$(14,FALSE),@rd$(15,FALSE),1)
ELSE
  al&=FALSE
ENDIF
IF al&=FALSE
  openf&=TRUE
  SELECT sauv&
  CASE 0
    OPEN "o",#1,fich$
    BPUT #1,ec%(ec&),32000
  CASE 1
    OPEN "o",#1,fich$
    eff(ado%,124)
    BMOVE V:rvb&(FALSE,ec&),ADD(ado%,4),32
    BPUT #1,ado%,128
    BPUT #1,ec%(ec&),32000
  CASE 2
    b%=ado%
    a%=lst%
    t&=FALSE
    d1%=ec%(ec&)
    i&=1
    j&=1
    i%=LONG{ec%(ec&)}
    REPEAT
      ADD d1%,160
      t%=LONG{d1%}
      IF t%=i%
        INC j&
      ELSE
        BYTE{a%}=j&
        LONG{b%}=i%
        INC a%
        ADD b%,4
        j&=1
      ENDIF
      IF j&=255
        BYTE{a%}=j&
        LONG{b%}=i%
        INC a%
        ADD b%,4
        j&=FALSE
      ENDIF
      i%=t%
      INC i&
      IF i&=200
        i&=FALSE
        ADD t&,4
        d1%=SUB(ADD(ec%(ec&),t&),160)
      ENDIF
    UNTIL t&=160
    BYTE{a%}=j&
    LONG{b%}=i%
    t&=ADD(SUB(a%,lst%),1)
    OPEN "o",#1,fich$
    PRINT #1,"(c)F.MARCHAL"+STR$(t&)
    BPUT #1,V:rvb&(FALSE,ec&),32
    BPUT #1,lst%,t&
    BPUT #1,ado%,SHL(t&,2)
  CASE 3
    OPEN "o",#1,fich$
    CARD{ado%}=FALSE
    BMOVE V:rvb&(FALSE,ec&),ADD(ado%,2),32
    BPUT #1,ado%,34
    BPUT #1,ec%(ec&),32000
    eff(ado%,32)
    BPUT #1,ado%,32
  CASE 4
    OPEN "o",#1,fich$
    OUT& #1,&H8000
    BPUT #1,V:rvb&(FALSE,ec&),32
    BPUT #1,ADD(ado%,34),C:degas%(L:ec%(ec&),L:ADD(ado%,34))
  CASE 5
    OPEN "o",#1,fich$
    CARD{ado%}=&H4B44
    BMOVE V:rvb&(FALSE,full&(FALSE)),ADD(ado%,2),32
    BPUT #1,ado%,34
    consfull(ado%,FALSE)
    BPUT #1,ado%,63020
  CASE 6
    OPEN "o",#1,fich$
    BPUT #1,V:rvb&(FALSE,ec&),32
    BPUT #1,ec%(ec&),32000
  CASE 7
    t%=C:tiny%(L:ec%(ec&),L:ado%,L:lst%)
    OPEN "o",#1,fich$
    OUT #1,FALSE
    BPUT #1,V:rvb&(FALSE,ec&),32
    OUT& #1,AND(&HFFFF,t%)
    OUT& #1,AND(&HFFFF,DIV(SWAP(t%),2))
    BPUT #1,ado%,AND(t%,&HFFFF)
    BPUT #1,lst%,AND(SWAP(t%),&HFFFF)
  CASE 8
    ~C:targa%(L:ec%(nec&(FALSE)),L:ec%(nec&(1)),L:ec%(nec&(2)),L:gloup%)
    OPEN "o",#1,fich$
    BPUT #1,gloup%,128018
    eff(gloup%,128018)
  ENDSELECT
  CLOSE #1
  openf&=FALSE
  savd&(ec&)=FALSE
ENDIF
CLR al&,t%
RETURN
> FUNCTION ana                            ! Analyse le type de palette (choix de la conversion de palette)
LOCAL flag&,mode&,t&
FOR t&=FALSE TO 15
flag&=OR(flag&,AND(rvb&(t&,ec&),&X100010001000))
NEXT t&
IF flag&
mode&=15
ELSE
mode&=7
ENDIF
flag&=FALSE
FOR t&=FALSE TO 15
flag&=OR(flag&,AND(&H7000,rvb&(t&,ec&)))
NEXT t&
IF flag&
MUL mode&,2
ENDIF
CLR flag&,t&
RETURN mode&
ENDFUNC
'
' OUTILS...
'
> PROCEDURE cr                            ! Crayon
REPEAT
IF k&
  x1&=x&
  y1&=y&
  IF pan&
    clipmo(FALSE,FALSE,319,99)
  ENDIF
  REPEAT
    @hide
    ALINE x&,y&,x1&,y1&,OR(AND(k&=2,debc&),AND(k&<>2,c&)),65535,FALSE
    @showm
    x1&=x&
    y1&=y&
    loupe
    ms
  UNTIL k&=FALSE
  clipmo(FALSE,FALSE,319,199)
  note(TRUE)
ENDIF
ms
loupe
clv
UNTIL OR(AND(y&>99,pan&),exit&)
RETURN
> PROCEDURE ligb                          ! Lignes
r&=ADD(SUB(endc&,debc&),1)
REPEAT
IF k&
  x1&=x&
  y1&=y&
  COLOR col&(c&)
  defln
  aux&=k&
  IF pan&
    clipmo(FALSE,FALSE,319,99)
  ENDIF
  REPEAT
    ms
    @hide
    IF aux&=2
      IF ABS(SUB(y&,y1&))>ABS(SUB(x&,x1&))
        j&=SUB(y&,y1&)
        IF j&=FALSE
          j&=1
        ENDIF
        reel=SUB(x&,x1&)/j&
        reel1=r&/j&
        FOR t&=y1& TO y& STEP SGN(j&)
          aux2&=SUB(t&,y1&)
          prt&=ROUND(aux2&*reel)
          PSET ADD(prt&,x1&),t&,ADD(debc&,reel1*aux2&)
        NEXT t&
      ELSE
        j&=SUB(x&,x1&)
        IF j&=FALSE
          j&=1
        ENDIF
        reel=SUB(y&,y1&)/j&
        reel1=r&/j&
        FOR t&=x1& TO x& STEP SGN(j&)
          aux2&=SUB(t&,x1&)
          prt&=ROUND(aux2&*reel)
          PSET t&,ADD(prt&,y1&),ADD(debc&,reel1*aux2&)
        NEXT t&
      ENDIF
      PSET x&,y&,endc&
    ELSE
      LINE x&,y&,x1&,y1&
    ENDIF
    @showm
    loupe
    move2
    IF k&<>FALSE
      reput
    ELSE
      note(TRUE)
    ENDIF
  UNTIL OR(k&=FALSE,k&=3)
  clipmo(FALSE,FALSE,319,199)
  atm0
ENDIF
ms
loupe
clv
UNTIL OR(AND(y&>99,pan&),exit&)
RETURN
> PROCEDURE f                             ! Peinture
REPEAT
IF k&
  @hide
  defill
  IF k&=2
    IF NOT AND(AND(debc&=FALSE,plein&),fill&)
      DEFFILL col&(debc&)
    ENDIF
  ENDIF
  IF NOT plein&
    IF OR(AND(PTST(x&,y&)<>c&,k&=1),AND(PTST(x&,y&)<>debc&,k&=2))
      FILL x&,y&
    ENDIF
  ELSE
    FILL x&,y&
  ENDIF
  @showm
  note(TRUE)
  atm0
ENDIF
ms
loupe
clv
UNTIL OR(AND(y&>99,pan&),exit&)
RETURN
> PROCEDURE cerc                          ! Cercle (plein & filaire)
REPEAT
IF k&
  x1&=x&
  y1&=y&
  defln
  IF AND(fld&,AND(plein&,NOT fill&))
    COLOR 1
  ELSE
    IF k&=1
      COLOR col&(c&)
      DEFFILL col&(c&)
    ELSE
      COLOR col&(debc&)
      DEFFILL col&(debc&)
    ENDIF
  ENDIF
  IF pan&
    clipmo(FALSE,FALSE,319,99)
  ENDIF
  REPEAT
    ms
    r&=ABS(SUB(x&,x1&))
    @hide
    IF fld&
      PCIRCLE x1&,y1&,r&
      def1
    ELSE
      defln
      CIRCLE x1&,y1&,r&
      def1
      LINE x1&,SUB(y1&,r&),x1&,ADD(y1&,r&)
      LINE SUB(x1&,r&),y1&,ADD(x1&,r&),y1&
    ENDIF
    BOX SUB(x1&,r&),SUB(y1&,r&/1.1),ADD(x1&,r&),ADD(y1&,r&/1.1)
    @showm
    loupe
    move2
    reput
    necho
  UNTIL OR(k&=FALSE,k&=3)
  clipmo(FALSE,FALSE,319,199)
  IF k&=FALSE
    IF @btc(2)
      phy(ecran%)
      REPEAT
        ms
        IF k&=1
          eang&=x&*11.25
        ELSE IF k&=2
          aang&=x&*11.25
        ENDIF
        @hide
        IF fld&
          PCIRCLE x1&,y1&,r&,eang&,aang&
        ELSE
          defln
          CIRCLE x1&,y1&,r&,eang&,aang&
        ENDIF
        def1
        LINE x1&,y1&,ADD(x1&,DIV(r&*cs&(DIV(eang&,10)),30000)),ADD(y1&,DIV(r&/-1.1*sn&(DIV(eang&,10)),30000))
        LINE x1&,y1&,ADD(x1&,DIV(r&*cs&(DIV(aang&,10)),30000)),ADD(y1&,DIV(r&/-1.1*sn&(DIV(aang&,10)),30000))
        @showm
        move2
        reput
        necho
      UNTIL OR(NOT @btc(2),k&=3)
    ELSE
      eang&=FALSE
      aang&=3600
    ENDIF
    IF k&=FALSE
      @hide
      IF fld&
        PCIRCLE x1&,y1&,r&,eang&,aang&
      ELSE
        defln
        CIRCLE x1&,y1&,r&,eang&,aang&
      ENDIF
      @showm
      note(TRUE)
    ENDIF
  ENDIF
  atm0
ENDIF
ms
loupe
clv
UNTIL OR(AND(y&>99,pan&),exit&)
RETURN
> PROCEDURE ell                           ! Ellipse (pleine & filaire)
REPEAT
IF k&
  x1&=x&
  y1&=y&
  aux&=k&
  defln
  IF AND(fld&,AND(plein&,NOT fill&))
    COLOR 1
  ELSE
    IF k&=1
      COLOR col&(c&)
      DEFFILL col&(c&)
    ELSE
      COLOR col&(debc&)
      DEFFILL col&(debc&)
    ENDIF
  ENDIF
  IF pan&
    clipmo(FALSE,FALSE,319,99)
  ENDIF
  REPEAT
    ms
    r&=ABS(SUB(x&,x1&))
    r1&=ABS(SUB(y&,y1&))
    @hide
    IF fld&
      PELLIPSE x1&,y1&,r&,r1&
      def1
    ELSE
      defln
      ELLIPSE x1&,y1&,r&,r1&
      def1
      LINE x1&,SUB(y1&,r1&),x1&,ADD(y1&,r1&)
      LINE SUB(x1&,r&),y1&,ADD(x1&,r&),y1&
    ENDIF
    BOX SUB(x1&,r&),SUB(y1&,r1&),ADD(x1&,r&),ADD(r1&,y1&)
    @showm
    loupe
    ms
    move2
    reput
  UNTIL OR(k&=FALSE,k&=3)
  clipmo(FALSE,FALSE,319,199)
  IF k&=FALSE
    IF @btc(2)
      phy(ecran%)
      REPEAT
        ms
        IF k&=1
          eang&=x&*11.25
        ELSE IF k&=2
          aang&=x&*11.25
        ENDIF
        @hide
        IF fld&
          PELLIPSE x1&,y1&,r&,r1&,eang&,aang&
        ELSE
          defln
          ELLIPSE x1&,y1&,r&,r1&,eang&,aang&
        ENDIF
        def1
        LINE x1&,y1&,ADD(x1&,DIV(r&*cs&(DIV(eang&,10)),30000)),SUB(y1&,DIV(r1&*sn&(DIV(eang&,10)),30000))
        LINE x1&,y1&,ADD(x1&,DIV(r&*cs&(DIV(aang&,10)),30000)),SUB(y1&,DIV(r1&*sn&(DIV(aang&,10)),30000))
        @showm
        move2
        reput
      UNTIL OR(NOT @btc(2),k&=3)
    ELSE
      eang&=FALSE
      aang&=3600
    ENDIF
    IF k&=FALSE
      @hide
      IF fld&
        PELLIPSE x1&,y1&,r&,r1&,eang&,aang&
      ELSE
        defln
        ELLIPSE x1&,y1&,r&,r1&,eang&,aang&
      ENDIF
      @showm
      note(TRUE)
    ENDIF
  ENDIF
  atm0
ENDIF
ms
loupe
clv
UNTIL OR(AND(y&>99,pan&),exit&)
RETURN
> PROCEDURE rect                          ! Rectangle (plein & filaire)
REPEAT
IF k&
  x1&=x&
  y1&=y&
  defln
  IF AND(fld&,AND(plein&,NOT fill&))
    COLOR 1
  ELSE
    IF k&=1
      COLOR col&(c&)
      DEFFILL col&(c&)
    ELSE
      COLOR col&(debc&)
      DEFFILL col&(debc&)
    ENDIF
  ENDIF
  IF fld&
    def2
  ENDIF
  IF pan&
    clipmo(FALSE,FALSE,319,99)
  ENDIF
  REPEAT
    ms
    @hide
    IF fld&
      PBOX x&,y&,x1&,y1&
      IF @btc(2)
        BOX x&,y&,x1&,y1&
      ENDIF
    ELSE
      BOX x&,y&,x1&,y1&
    ENDIF
    @showm
    loupe
    move2
    reput
  UNTIL OR(k&=FALSE,k&=3)
  clipmo(FALSE,FALSE,319,199)
  IF k&=FALSE
    @hide
    IF fld&
      PBOX x&,y&,x1&,y1&
    ELSE
      BOX x&,y&,x1&,y1&
    ENDIF
    note(TRUE)
    @showm
  ENDIF
  atm0
ENDIF
ms
loupe
clv
UNTIL OR(AND(y&>99,pan&),exit&)
RETURN
> PROCEDURE ent                           ! Entourage automatique / lissage
INC ent&
REPEAT
ms
loupe
clv
IF k&
  aux&=k&
  wd
  IF k&=FALSE
    IF aux&=1
      phy(ecran%)
      IF c&=FALSE
        alertpal
        ~@alt(TRUE,112,@rd$(32,FALSE)+"|"+SPACE$(50),"   Ok   ",FALSE)
        normpal1
      ELSE
        crds(ent&,FALSE,SUB(319,ent&),SUB(199,ent&),x1&,y1&)
        crds(ent&,FALSE,SUB(319,ent&),SUB(199,ent&),x&,y&)
        @hide
        mouseoff
        FOR t&=x1& TO x&
          FOR i&=y1& TO y&
            c1&=PTST(t&,i&)
            IF AND(c1&,c1&<>c&)
              FOR i1&=1 TO ent&
                IF AND(C:ptst%(L:ecran%,t&,ADD(i1&,i&))=FALSE,sens4&)
                  PSET t&,ADD(i1&,i&),c&
                ENDIF
                IF AND(C:ptst%(L:ecran%,ADD(i1&,t&),i&)=FALSE,sens3&)
                  PSET ADD(i1&,t&),i&,c&
                ENDIF
                IF AND(C:ptst%(L:ecran%,t&,SUB(i&,i1&))=FALSE,sens2&)
                  PSET t&,SUB(i&,i1&),c&
                ENDIF
                IF AND(C:ptst%(L:ecran%,SUB(t&,i1&),i&)=FALSE,sens1&)
                  PSET SUB(t&,i1&),i&,c&
                ENDIF
              NEXT i1&
            ENDIF
          NEXT i&
          EXIT IF @inp_
        NEXT t&
        necho
        mouseon
        @showm
        IF pan&
          ppal(c&)
          HLINE 192,110,319,FALSE,FALSE,adr%,1
          HLINE 192,111,319,FALSE,FALSE,adr%,1
        ENDIF
      ENDIF
    ELSE
      eff(ado%,32320)
      BMOVE ec%(ec&),ADD(ado%,160),32000
      ~C:anti%(L:ADD(ado%,MUL(ADD(y1&,AND(pan&,ordo&)),160)),L:ADD(ecran%,MUL(y1&,160)),W:x1&,x&,y1&,y&,SUB(13,ent&))
    ENDIF
    note(TRUE)
  ELSE
    atm0
    k&=FALSE
  ENDIF
ENDIF
UNTIL OR(AND(y&>99,pan&),exit&)
DEC ent&
RETURN
> PROCEDURE poly                          ! Polygone (plein & filaire)
REPEAT
IF k&=1
  t&=FALSE
  def2
  IF pan&
    clipmo(FALSE,FALSE,319,99)
  ENDIF
  REPEAT
    ms
    loupe
    IF k&=1
      COLOR col&(c&)
      @hide
      plx&(t&)=x&
      ply&(t&)=y&
      LINE SUB(x&,10),y&,ADD(x&,10),y&
      LINE x&,SUB(y&,5),x&,ADD(y&,5)
      INC t&
      IF t&=127
        k&=2
      ENDIF
      atm0
      @showm
    ENDIF
  UNTIL OR(k&=2,@inp_)
  clipmo(FALSE,FALSE,319,199)
  reput
  plx&(t&)=plx&(FALSE)
  ply&(t&)=ply&(FALSE)
  IF k&=2
    IF fld&
      defill
      POLYFILL ADD(t&,1),plx&(),ply&()
    ELSE
      defln
      POLYLINE ADD(t&,1),plx&(),ply&()
    ENDIF
    note(TRUE)
  ELSE
    necho
  ENDIF
  atm0
ENDIF
ms
loupe
clv
UNTIL OR(AND(y&>99,pan&),exit&)
RETURN
> PROCEDURE cbz                           ! Courbes de bezier
REPEAT
IF k&=1
  IF pan&
    clipmo(FALSE,FALSE,319,99)
  ENDIF
  FOR i&=FALSE TO 3
    REPEAT
      ms
      loupe
    UNTIL k&
    IF k&=1
      plx&(i&)=x&
      ply&(i&)=y&
      plx&(ADD(i&,1))=plx&(FALSE)
      ply&(ADD(i&,1))=ply&(FALSE)
      affpol
      atm0
    ENDIF
    EXIT IF k&=2
  NEXT i&
  reput
  IF i&<>4
    necho
  ELSE
    DEC i&
    @hide
    CURVE plx&(FALSE),ply&(FALSE),plx&(1),ply&(1),plx&(2),ply&(2),plx&(3),ply&(3)
    @showm
    affpol
    atm0
    REPEAT
      ms
      loupe
      IF k&=1
        i%=&HFFFFF
        FOR i&=FALSE TO 3
          j&=SUB(x&,plx&(i&))
          t%=MUL(j&,j&)
          j&=SUB(y&,ply&(i&))
          t%=ADD(t%,MUL(j&,j&))
          IF t%<i%
            i%=t%
            t&=i&
          ENDIF
        NEXT i&
        REPEAT
          ms
          plx&(t&)=x&
          ply&(t&)=y&
          plx&(4)=plx&(FALSE)
          ply&(4)=ply&(FALSE)
          reput
          @hide
          CURVE plx&(FALSE),ply&(FALSE),plx&(1),ply&(1),plx&(2),ply&(2),plx&(3),ply&(3)
          @showm
          loupe
          move2
        UNTIL k&=FALSE
        affpol
      ENDIF
    UNTIL OR(k&=2,@inp_)
    reput
    IF NOT @inp_
      defln
      @hide
      CURVE plx&(FALSE),ply&(FALSE),plx&(1),ply&(1),plx&(2),ply&(2),plx&(3),ply&(3)
      @showm
      note(TRUE)
    ENDIF
    necho
    atm0
  ENDIF
  clipmo(FALSE,FALSE,319,199)
ENDIF
ms
loupe
clv
UNTIL OR(AND(y&>99,pan&),exit&)
RETURN
> PROCEDURE affpol                        ! Sous Pcd de cbz: affichage courbe de bezier
def2
COLOR 1
@hide
FOR a&=FALSE TO i&
aux&=SUB(plx&(a&),2)
aux2&=SUB(ply&(a&),2)
BOX aux&,aux2&,ADD(aux&,4),ADD(aux2&,4)
NEXT a&
@showm
COLOR col&(c&)
defln
RETURN
> PROCEDURE scim                          ! D‚placement de la base ‚cran en demi ecran
LOCAL oldx&,oldy&,a$
IF @btc(2)
~XBIOS(5,L:ec%(ec&),L:TRUE,W:TRUE)
REPEAT
  IF k&=1
    GET FALSE,FALSE,FALSE,199,a$
    RC_COPY ec%(ec&),1,FALSE,319,200 TO ec%(ec&),FALSE,FALSE
    PUT 319,FALSE,a$
    reput
  ELSE IF k&=2
    GET 319,FALSE,319,199,a$
    RC_COPY ec%(ec&),FALSE,FALSE,319,200 TO ec%(ec&),1,FALSE
    PUT FALSE,FALSE,a$
    reput
  ENDIF
  REPEAT
    @vs
    INC oldx&
    k&=@mousek
  UNTIL OR(k&=FALSE,oldx&>30)
UNTIL k&=FALSE
~XBIOS(5,L:ecran%,L:TRUE,W:TRUE)
ELSE
oldx&=x&
oldy&=y&
aux&=NOT ODD(k&)
aux2&=AND(ordo&,15)
clipmo(FALSE,FALSE,319,100)
@hide
setmo(x&,SUB(100,ordo&))
REPEAT
  ms2
  IF aux&
    ordo&=MIN(MAX(ADD(AND(SUB(100,y&),&HFFF0),aux2&),FALSE),100)
  ELSE
    ordo&=SUB(100,y&)
  ENDIF
  reput
  PRINT AT(16,8);"BASE:";ordo&;"  ";
  move2
UNTIL k&=FALSE
clipmo(FALSE,FALSE,319,199)
setmo(oldx&,oldy&)
ENDIF
reput
note(FALSE)
@showm
CLR oldx&,oldy&,a$
RETURN
> PROCEDURE eras                          ! Gomme
def2
@hide
REPEAT
IF k&=1
  IF pan&
    clipmo(FALSE,FALSE,319,99)
  ENDIF
  REPEAT
    ms
    BOX x&,y&,ADD(x&,lter&),ADD(y&,hter&)
    loupe
    arec(x&,y&,ADD(x&,lter&),ADD(y&,hter&),FALSE,FALSE)
  UNTIL k&=FALSE
  clipmo(FALSE,FALSE,319,199)
  note(TRUE)
ENDIF
ms
BOX x&,y&,ADD(x&,lter&),ADD(y&,hter&)
loupe
clv
IF @btc(22)
  prdyn(lter&,hter&)
ENDIF
reput
UNTIL OR(AND(y&>99,pan&),exit&)
DEFLINE 1
RETURN
> PROCEDURE repl                          ! Remplacement couleurs
REPEAT
ms
clv
loupe
IF k&=1
  @hide
  wd
  IF k&=FALSE
    mouseoff
    phy(ecran%)
    ~C:rempl%(L:ADD(ecran%,MUL(y1&,160)),L:V:crap&(FALSE),W:x1&,y1&,ADD(x&,1),ADD(y&,1))
  ENDIF
  mouseon
  necho
  note(TRUE)
  @showm
ENDIF
UNTIL OR(AND(y&>99,pan&),exit&)
RETURN
> PROCEDURE pinc                          ! Pinceaux
LOCAL spr$,aux%,t&,i&,a&,bl&
@hide
spr$=""
a&=ADD(pinc&,12)
FOR t&=FALSE TO 15
aux%=FALSE
FOR i&=FALSE TO 15
  IF tram|(a&,i&,t&)
    aux%=BSET(aux%,SUB(15,i&))
  ENDIF
NEXT i&
spr$=spr$+MKI$(NOT aux%)+MKI$(aux%)
NEXT t&
FOR t&=15 DOWNTO FALSE
FOR i&=FALSE TO 15
  EXIT IF tram|(a&,t&,i&)
NEXT i&
IF i&<16
  EXIT IF tram|(a&,t&,i&)
ENDIF
NEXT t&
bl&=t&
FOR t&=15 DOWNTO FALSE
FOR i&=FALSE TO 15
  EXIT IF tram|(a&,i&,t&)
NEXT i&
IF i&<16
  EXIT IF tram|(a&,i&,t&)
ENDIF
NEXT t&
j&=t&
defmo(V:spr$,FALSE,FALSE)
clipmo(FALSE,FALSE,SUB(319,bl&),199)
@showm
REPEAT
ms
clv
loupe
IF k&
  y&=MIN(y&,SUB(SUB(199,AND(100,pan&)),j&))
  x1&=x&
  y1&=y&
  clipmo(FALSE,FALSE,SUB(319,bl&),SUB(SUB(199,AND(100,pan&)),j&))
  IF half&
    aux&=k&
    REPEAT
      ms
      @hide
      FOR t&=FALSE TO 15
        FOR i&=FALSE TO 15
          IF tram|(a&,t&,i&)
            IF aux&=1
              b&=SUB(PTST(ADD(t&,x&),ADD(i&,y&)),1)
              IF b&<debc&
                b&=debc&
              ENDIF
              PSET ADD(t&,x&),ADD(i&,y&),b&
            ELSE
              b&=ADD(PTST(ADD(t&,x&),ADD(i&,y&)),1)
              IF b&>endc&
                b&=endc&
              ENDIF
              PSET ADD(t&,x&),ADD(i&,y&),b&
            ENDIF
          ENDIF
        NEXT i&
      NEXT t&
      @showm
      loupe
    UNTIL k&=FALSE
  ELSE
    IF pincmono&
      REPEAT
        ms
        IF @btc(2)
          x1&=x&
          y1&=y&
        ENDIF
        @hide
        FOR t&=FALSE TO 15
          FOR i&=FALSE TO 15
            IF tram|(a&,t&,i&)
              ALINE ADD(t&,x1&),ADD(i&,y1&),ADD(t&,x&),ADD(y&,i&),c&,65535,FALSE
            ENDIF
          NEXT i&
        NEXT t&
        @showm
        x1&=x&
        y1&=y&
        loupe
      UNTIL k&=FALSE
    ELSE
      REPEAT
        ms
        IF @btc(2)
          x1&=x&
          y1&=y&
        ENDIF
        @hide
        FOR t&=FALSE TO 15
          FOR i&=FALSE TO 15
            IF tram|(a&,t&,i&)
              ALINE ADD(t&,x1&),ADD(i&,y1&),ADD(t&,x&),ADD(y&,i&),tram|(a&,t&,i&),65535,FALSE
            ENDIF
          NEXT i&
        NEXT t&
        @showm
        x1&=x&
        y1&=y&
        loupe
      UNTIL k&=FALSE
    ENDIF
  ENDIF
  note(TRUE)
  clipmo(FALSE,FALSE,SUB(319,bl&),199)
ENDIF
UNTIL OR(AND(y&>99,pan&),exit&)
clipmo(FALSE,FALSE,319,199)
defmo(V:mouse$,hotpx&,hotpy&)
CLR spr$,t&,i&,aux%,a&,bl&
RETURN
> PROCEDURE aero                          ! Aerographe
@hide
IF forme&
def1
IF NOT multia&
  REPEAT
    ms
    ELLIPSE x&,y&,xf&,xf&
    loupe
    move2
    reput
    clv
    IF @btc(22)
      parc(xf&)
    ELSE IF k&=1
      r%=MUL(xf&,xf&)
      COLOR col&(c&)
      IF pan&
        clipmo(FALSE,FALSE,319,99)
      ENDIF
      REPEAT
        ms
        xr&=MUL(RAND(xf&),SUB(MUL(RAND(2),2),1))
        yr&=MUL(RAND(xf&),SUB(MUL(RAND(2),2),1))
        IF ADD(MUL(xr&,xr&),MUL(yr&,yr&))<=r%
          PLOT ADD(x&,xr&),ADD(y&,yr&)
        ENDIF
        FOR t&=FALSE TO MUL(SUB(20,tempaero&),200)
        NEXT t&
      UNTIL k&=FALSE
      clipmo(FALSE,FALSE,319,199)
      COLOR 1
      note(TRUE)
    ENDIF
  UNTIL OR(AND(y&>99,pan&),exit&)
ELSE
  REPEAT
    ms
    ELLIPSE x&,y&,xf&,xf&
    loupe
    move2
    reput
    clv
    IF @btc(22)
      parc(xf&)
    ELSE IF k&=1
      r%=MUL(xf&,xf&)
      IF pan&
        clipmo(FALSE,FALSE,319,99)
      ENDIF
      REPEAT
        ms
        j&=RAND(16)
        IF aero&(j&)
          COLOR col&(j&)
          xr&=MUL(RAND(xf&),SUB(MUL(RAND(2),2),1))
          yr&=MUL(RAND(xf&),SUB(MUL(RAND(2),2),1))
          IF ADD(MUL(xr&,xr&),MUL(yr&,yr&))<=r%
            PLOT ADD(x&,xr&),ADD(y&,yr&)
          ENDIF
        ENDIF
        FOR t&=FALSE TO MUL(SUB(20,tempaero&),200)
        NEXT t&
      UNTIL k&=FALSE
      clipmo(FALSE,FALSE,319,199)
      COLOR 1
      note(TRUE)
    ENDIF
  UNTIL OR(AND(y&>99,pan&),exit&)
ENDIF
ELSE
def2
IF multia&
  REPEAT
    ms
    BOX x&,y&,SUB(ADD(x&,xf&),1),SUB(ADD(y&,yf&),1)
    loupe
    move2
    reput
    clv
    IF @btc(22)
      prdyn(xf&,yf&)
    ELSE IF k&=1
      def1
      IF pan&
        clipmo(FALSE,FALSE,319,99)
      ENDIF
      REPEAT
        ms
        cl&=RAND(16)
        IF aero&(cl&)
          COLOR col&(cl&)
          PLOT ADD(x&,RAND(xf&)),ADD(y&,RAND(yf&))
          FOR t&=FALSE TO MUL(SUB(20,tempaero&),200)
          NEXT t&
        ENDIF
      UNTIL k&=FALSE
      clipmo(FALSE,FALSE,319,199)
      note(TRUE)
      def2
    ENDIF
  UNTIL OR(AND(y&>99,pan&),exit&)
ELSE
  REPEAT
    ms
    BOX x&,y&,SUB(ADD(x&,xf&),1),SUB(ADD(y&,yf&),1)
    loupe
    move2
    reput
    clv
    IF @btc(22)
      prdyn(xf&,yf&)
    ELSE IF k&=1
      def1
      IF pan&
        clipmo(FALSE,FALSE,319,99)
      ENDIF
      REPEAT
        ms
        COLOR col&(c&)
        PLOT ADD(x&,RAND(xf&)),ADD(y&,RAND(yf&))
        FOR t&=FALSE TO MUL(SUB(20,tempaero&),200)
        NEXT t&
      UNTIL k&=FALSE
      clipmo(FALSE,FALSE,319,199)
      note(TRUE)
      def2
    ENDIF
  UNTIL OR(AND(y&>99,pan&),exit&)
ENDIF
ENDIF
RETURN
> PROCEDURE text                          ! Texte
REPEAT
ms
clv
loupe
IF k&=1
  @hide
  ~@input(1,1,TRUE,38,texty$)
  texty$=TRIM$(texty$)
  IF LEN(texty$)
    DEFTEXT 1,styl&,FALSE,tsiz&
    DEFTEXT col&(c&)
    ~XBIOS(5,L:ado%,L:TRUE,W:TRUE)
    atm0
    IF pan&
      clipmo(FALSE,FALSE,319,99)
    ENDIF
    REPEAT
      ms
      IF pan&
        BMOVE ADD(ec%(ec&),MUL(ordo&,160)),ado%,16000
      ELSE
        BMOVE ec%(ec&),ado%,32000
      ENDIF
      TEXT x&,y&,texty$
      BMOVE ado%,ecran%,ADD(16000,AND(NOT pan&,16000))
      loupe
    UNTIL k&
    clipmo(FALSE,FALSE,319,199)
    ~XBIOS(5,L:ecran%,L:TRUE,W:TRUE)
    IF k&=2
      reput
    ELSE
      note(TRUE)
    ENDIF
    atm0
    k&=FALSE
  ENDIF
  @showm
ENDIF
UNTIL OR(AND(pan&,y&>99),exit&)
RETURN
> PROCEDURE deg                           ! Degrade automatique
LOCAL a$,degtx%
'
a$=SPACE$(2600)               ! Construction d'une table des carres
degtx%=V:a$
FOR t&=-320 TO 320
{degtx%}=MUL(t&,t&)
ADD degtx%,4
NEXT t&
degtx%=ADD(V:a$,1280)
REPEAT
ms
clv
loupe
IF k&
  a&=k&         ! On note le bouton d'appel
  wd
  IF k&=FALSE
    phy(ecran%)
    mouseoff
    @hide                ! Test l'image et construit les listes
    aux%=C:degtst%(L:ecran%,L:ado%,W:x1&,W:y1&,W:ADD(x&,1),W:ADD(y&,1),W:debc&,W:endc&)
    nb2&=AND(aux%,&H7FFF)                   ! Nombre de points de depart
    nb&=SWAP(AND(aux%,&H7FFF0000))          ! Nombre de points d'arrivee
    IF OR(nb&=FALSE,nb2&=FALSE)             ! Si pas de points de depart
      alertpal
      IF nb&=FALSE
        ~@alt(TRUE,112,@rd$(33,FALSE)+"|"+SPACE$(50),"   Ok   ",FALSE)
      ELSE IF nb2&=FALSE
        ~@alt(TRUE,112,@rd$(33,1)+"|"+SPACE$(50),"   Ok   ",FALSE)
      ENDIF
      normpal1
    ELSE
      IF OR(BTST(aux%,31),BTST(aux%,15))
        alertpal
        IF BTST(aux%,31)
          ~@alt(TRUE,112,@rd$(34,FALSE)+"|"+SPACE$(50),"   Ok   ",FALSE)
        ENDIF
        IF BTST(aux%,15)
          ~@alt(TRUE,112,@rd$(35,FALSE)+"|"+SPACE$(50),"   Ok   ",FALSE)
        ENDIF
        normpal1
      ENDIF
      DEC nb&
      DEC nb2&
      mouseoff
      j&=ADD(SHL&(SUB(endc&,debc&),1),1)    ! Quelques pr‚calculs
      x2&=ADD(debc&,1)
      al&=TRUE                              ! Flag de sortie
      FOR t&=x1& TO x&
        FOR i&=y1& TO y&
          IF OR(a&=1,PTST(t&,i&))
            d1%=C:degrad%(L:ado%,W:nb&,W:t&,W:i&,L:degtx%)  ! Point le plus proche de l'ensemble de d‚part
            IF d1%
              d2%=C:degrad%(L:lst%,W:nb2&,W:t&,W:i&,L:degtx%) ! Point le plus proche de l'ensemble d'arriv‚e
              IF d2%
                idk&=ROUND(j&/(1+SQR(d2%/d1%)))
                IF AND(XOR(EVEN(t&),EVEN(i&)),ODD(idk&))  ! Effet de tramage
                  idk&=SHR&(idk&,1)
                  PSET t&,i&,MIN(ADD(idk&,x2&),endc&)
                ELSE
                  PSET t&,i&,ADD(SHR&(idk&,1),debc&)
                ENDIF
              ELSE
                PSET t&,i&,endc&
              ENDIF
            ELSE
              PSET t&,i&,debc&
            ENDIF
          ENDIF
          IF @inp_
            necho
            alertpal
            al&=@alt(TRUE,112,SPACE$(50)+@rd$(36,FALSE),@rd$(10,FALSE),1)
            normpal1
            mouseoff
          ENDIF
          EXIT IF al&=FALSE
        NEXT i&
        EXIT IF al&=FALSE
      NEXT t&
    ENDIF
    note(TRUE)
    mouseon
    @showm
    k&=FALSE
  ENDIF
ENDIF
UNTIL OR(AND(y&>99,pan&),exit&)
CLR a$,degtx%
RETURN
> PROCEDURE wd                            ! Selection d'un bloc image
LOCAL state&
IF curson&
state&=TRUE
@hide
ENDIF
x1&=x&
y1&=y&
def2
IF pan&
clipmo(FALSE,FALSE,319,99)
ENDIF
REPEAT
ms
BOX x&,y&,x1&,y1&
loupe
move2
reput
UNTIL OR(k&=FALSE,k&=3)
clipmo(FALSE,FALSE,319,199)
IF x&<x1&
SWAP x&,x1&
ENDIF
IF y&<y1&
SWAP y&,y1&
ENDIF
IF k&=3
atm0
ENDIF
IF state&
@showm
ENDIF
CLR state&
RETURN
> PROCEDURE prdyn(VAR t&,i&)              ! Redimensionnement outil rectangulaire
phy(ecran%)
x1&=x&
y1&=y&
REPEAT
ms
t&=ABS(SUB(x&,x1&))
i&=ABS(SUB(y&,y1&))
PRINT AT(1,1);"X<->:";t&;" Y<->:";i&;"   ";
BOX x1&,y1&,x&,y&
IF k&
  x1&=x&
  y1&=y&
ENDIF
move2
reput
UNTIL NOT @btc(22)
RETURN
> PROCEDURE parc(VAR t&)                  ! Redimensionnement outil circulaire
phy(ecran%)
x1&=x&
y1&=y&
a$=@rd$(54,FALSE)
REPEAT
ms
t&=ABS(SUB(x&,x1&))
PRINT AT(1,1);a$;t&;"   ";
ELLIPSE x1&,y1&,t&,t&
IF k&
  x1&=x&
  y1&=y&
ENDIF
move2
reput
UNTIL NOT @btc(22)
RETURN
> PROCEDURE alertpal                      ! Palette pour boite d'alerte en plein ecran dessin
IF pan&
raster(MKL$(V:rvb&(FALSE,ec&))+MKI$(112)+MKL$(old%)+MKI$(55)+MKL$(V:rvb&(FALSE,ec&))+MKI$(240))
ELSE
raster(MKL$(V:rvb&(FALSE,ec&))+MKI$(112)+MKL$(old%)+MKI$(55)+MKL$(V:rvb&(FALSE,ec&))+MKI$(240))
ENDIF
RETURN
'
' LOUPE DYNAMIQUE
'
> PROCEDURE loupe
LOCAL state&
IF pan&
IF curson&
  @vs
  IF falcon&
    @vs
  ELSE
    REPEAT
    UNTIL ADD(ADD(PEEK(&HFF8209),SHL(PEEK(&HFF8207),8)),SWAP(PEEK(&HFF8205)))>=ADD(ecran%,18560)
  ENDIF
  ~C:inter%(4)
ENDIF
BMOVE ADD(ecran%,MUL(MAX(SUB(y&,7),FALSE),160)),ADD(lp%,3000),2400
SELECT x&
CASE 0 TO 23
  IF y&<7
    RC_COPY ADD(lp%,3000),FALSE,FALSE,ADD(25,x&),ADD(11,y&) TO lp%,SUB(23,x&),SUB(7,y&)
  ELSE
    RC_COPY ADD(lp%,3000),FALSE,FALSE,ADD(25,x&),15 TO lp%,SUB(23,x&),FALSE
  ENDIF
CASE 296 TO 319
  IF y&<7
    RC_COPY ADD(lp%,3000),SUB(x&,23),FALSE,SUB(47,SUB(x&,296)),ADD(11,y&) TO lp%,FALSE,SUB(7,y&)
  ELSE
    RC_COPY ADD(lp%,3000),SUB(x&,23),FALSE,SUB(47,SUB(x&,296)),15 TO lp%,FALSE,FALSE
  ENDIF
DEFAULT
  IF y&<7
    RC_COPY ADD(lp%,3000),SUB(x&,23),FALSE,48,ADD(11,y&) TO lp%,FALSE,SUB(7,y&)
  ELSE
    RC_COPY ADD(lp%,3000),SUB(x&,23),FALSE,48,15 TO lp%,FALSE,FALSE
  ENDIF
ENDSELECT
~C:lpx%(L:lp%,L:ADD(ecran%,17760),W:x&,W:ADD(y&,AND(ordo&,pan&)))
ELSE
IF @btc(21)
  phy(noclip%)
  IF curson&
    state&=TRUE
    @hide
  ENDIF
  tch&=AND(y&<100,140)
  BMOVE ADD(ecran%,MUL(tch&,160)),gloup%,9600
  eff(ADD(ecran%,MUL(tch&,160)),9600)
  IF tch&
    HLINE FALSE,140,319,15,FALSE,adr%,1
    HLINE 91,172,95,15,FALSE,adr%,1
    HLINE 91,168,95,15,FALSE,adr%,1
  ELSE
    HLINE FALSE,59,319,15,FALSE,adr%,1
    HLINE 91,31,95,15,FALSE,adr%,1
    HLINE 91,27,95,15,FALSE,adr%,1
  ENDIF
  SELECT x&
  CASE 0 TO 23
    IF y&<7
      RC_COPY ecran%,FALSE,FALSE,ADD(25,x&),ADD(11,y&) TO lp%,SUB(23,x&),SUB(7,y&)
    ELSE
      RC_COPY ecran%,FALSE,SUB(y&,7),ADD(25,x&),MIN(15,SUB(207,y&)) TO lp%,SUB(23,x&),FALSE
    ENDIF
  CASE 296 TO 319
    IF y&<7
      RC_COPY ecran%,SUB(x&,23),FALSE,SUB(47,SUB(x&,296)),ADD(11,y&) TO lp%,FALSE,SUB(7,y&)
    ELSE
      RC_COPY ecran%,SUB(x&,23),SUB(y&,7),SUB(47,SUB(x&,296)),MIN(15,SUB(207,y&)) TO lp%,FALSE,FALSE
    ENDIF
  DEFAULT
    IF y&<7
      RC_COPY ecran%,SUB(x&,23),FALSE,48,ADD(11,y&) TO lp%,FALSE,SUB(7,y&)
    ELSE
      RC_COPY ecran%,SUB(x&,23),SUB(y&,7),48,MIN(15,SUB(207,y&)) TO lp%,FALSE,FALSE
    ENDIF
  ENDSELECT
  ~C:lpx%(L:lp%,L:ADD(ecran%,MUL(ADD(tch&,DIV(tch&,140)),160)),W:x&,W:y&)
  IF state&
    @showm
  ENDIF
  @vs
  BMOVE ecran%,noclip%,32000
  IF state&
    @hide
  ENDIF
  BMOVE gloup%,ADD(ecran%,MUL(tch&,160)),9600
  IF state&
    @showm
  ENDIF
ELSE
  phy(ecran%)
ENDIF
ENDIF
CLR state&
RETURN
'
' LOUPE STATIQUE
'
> PROCEDURE lpx                          ! Permet de placer la loupe statique
def2
nbx&=DIV(320,grs&)
nby&=DIV(160,grs&)
@hide
REPEAT
ms
crds2(FALSE,FALSE,SUB(320,nbx&),SUB(200,nby&),x&,y&)
BOX x&,y&,SUB(ADD(x&,nbx&),1),SUB(ADD(y&,nby&),1)
loupe
move2
reput
IF k&=1
  phy(ecran%)
  note(TRUE)
  IF pan&
    crds(FALSE,FALSE,SUB(320,nbx&),SUB(SUB(200,ordo&),nby&),x&,y&)
  ENDIF
  lp
  reput
  IF pan&
    norm
    y&=199
  ENDIF
ENDIF
clv
UNTIL OR(AND(y&>99,pan&),exit&)
reput
DEFLINE 1
RETURN
> PROCEDURE lp                           ! Loupe statique
raster(MKL$(V:rvb&(FALSE,ec&)))
lpx&=x&
lpy&=ADD(y&,AND(ordo&,pan&))
DEFLINE 1
CLIP FALSE,FALSE TO 319,199
aclp(TRUE,FALSE,FALSE,319,199)
@hide
eff(ecran%,32000)
RC_COPY ec%(ec&),lpx&,lpy&,nbx&,nby& TO ecran%,FALSE,FALSE
zoom
note2
tralp
@showm
atm0
REPEAT
ms2
IF y&<40
  icone(FALSE,FALSE,79,39,51)
  tabicone(80,21,14,18,15,FALSE,15,FALSE,70)
  tabicone(80,FALSE,59,9,60,10,7,1,6)
  clv2
ELSE
  aclp(FALSE,FALSE,FALSE,319,199)
  sensmo(ADD(smoloup&,1))
  clipmo(FALSE,FALSE,MUL(SUB(nbx&,1),grs&),ADD(MUL(SUB(nby&,1),grs&),40))
  spr(SUB(grs&,grille&))
  CARD{ADD(table%,6)}=2
  CARD{ADD(table%,86)}=TRUE
  k&=FALSE
  ON ADD(otll&,1) GOSUB plot,line,fill,r,box,box
  CARD{ADD(table%,86)}=FALSE
  CARD{ADD(table%,6)}=1
  sensmo(ADD(smopanel&,1))
  clipmo(FALSE,FALSE,319,199)
  aclp(TRUE,FALSE,FALSE,319,199)
  defmo(V:mouse$,hotpx&,hotpy&)
  @hide
  ATEXT 264,3,FALSE,"        "
  @showm
ENDIF
UNTIL OR(ext&,exit&)
ext&=FALSE
defmo(V:mouse2$,hotdx&,hotdy&)
@hide
IF OR(NOT @btc(2),exit&)
RC_COPY ecran%,FALSE,FALSE,nbx&,nby& TO ec%(ec&),lpx&,lpy&
ENDIF
COLOR 1
DEFLINE -43690
atm0
IF pan&
normpal1
ENDIF
RETURN
> PROCEDURE spr(t&)                      ! Cree un curseur souris carre
LOCAL i&,t%,aux%
t%=mouse%
t&=MIN(SUB(t&,1),16)
aux%=SUB(BSET(FALSE,t&),1)
FOR i&=FALSE TO SUB(t&,1)
CARD{t%}=NOT aux%
ADD t%,2
CARD{t%}=aux%
ADD t%,2
NEXT i&
IF t%<ADD(mouse%,64)
FOR t%=t% TO ADD(mouse%,60) STEP 4
  {t%}=&HFFFF0000
NEXT t%
ENDIF
CARD{ADD(table%,42)}=SUB(16,t&)
CARD{ADD(table%,44)}=FALSE
CLR t&,t%,i&,aux%
RETURN
> PROCEDURE tralp                        ! Affiche menu loupe
LOCAL state&
state&=curson&
IF curson&
@hide
ENDIF
deic(80,FALSE,319,39,FALSE)
HLINE 80,20,319,15,FALSE,adr%,1
HLINE 80,32,319,15,FALSE,adr%,1
FOR j&=FALSE TO 15
aux&=ADD(MUL(j&,15),80)
arec(ADD(aux&,1),21,ADD(aux&,14),31,j&,FALSE)
IF j&<15
  ALINE ADD(aux&,15),20,ADD(aux&,15),39,15,65535,1
ENDIF
NEXT j&
FOR j&=FALSE TO 7
aux&=ADD(MUL(AND(j&,3),60),80)
aux2&=MUL(SHR(j&,2),10)
BOX aux&,aux2&,ADD(60,aux&),ADD(aux2&,10)
ATEXT ADD(aux&,4),ADD(aux2&,3),FALSE,@rd$(2,j&)
NEXT j&
ATEXT ADD(MUL(c&,15),82),33,FALSE,""
ATEXT ADD(MUL(c2&,15),88),33,FALSE,"^"
ATEXT 220,13,FALSE,STR$(grs&)
aux&=ADD(MUL(AND(otll&,3),60),82)
aux2&=ADD(MUL(SHR(otll&,2),10),2)
arec(aux&,aux2&,ADD(aux&,56),ADD(aux2&,6),15,2)
IF NOT grille&
arec(262,12,317,18,15,2)
ENDIF
IF state&
@showm
ENDIF
RETURN
> PROCEDURE 6                            ! Choix grossissement-Grille-Outil
LOCAL j&
j&=ADD(AND(t&,3),SHL&(i&,2))
IF j&<>3
SELECT j&
CASE 0,1,2,4,5
  otll&=j&
CASE 6
  @hide
  RC_COPY ecran%,FALSE,FALSE,nbx&,nby& TO ec%(ec&),lpx&,lpy&
  @showm
  grs&=ADD(@pop_up(xh&,yh&,57,14,FALSE,@rd$(11,FALSE),FALSE,SUB(grs&,4)),4)
  nbx&=DIV(320,grs&)
  nby&=DIV(160,grs&)
  aclp(TRUE,FALSE,FALSE,319,199)
  IF ADD(lpx&,nbx&)>319
    lpx&=SUB(320,nbx&)
  ENDIF
  IF ADD(lpy&,nby&)>199
    lpy&=SUB(200,nby&)
  ENDIF
  @hide
  eff(ecran%,32000)
  RC_COPY ec%(ec&),lpx&,lpy&,nbx&,nby& TO ecran%,FALSE,FALSE
  zoom
  note2
  @showm
DEFAULT
  grille&=NOT grille&
  zoom
  note2
ENDSELECT
tralp
atm0
ENDIF
CLR j&
RETURN
> PROCEDURE 11                           ! D‚placement loupe ou sortie
IF k&=1
ext&=TRUE
ELSE
@hide
x1&=x&
y1&=y&
setmo(lpx&,lpy&)
RC_COPY ecran%,FALSE,FALSE,nbx&,nby& TO ec%(ec&),lpx&,lpy&
REPEAT
  ms
  crds(FALSE,FALSE,SUB(320,nbx&),SUB(200,nby&),x&,y&)
  RC_COPY ec%(ec&),x&,y&,nbx&,nby& TO ecran%,FALSE,FALSE
  ATEXT 264,3,FALSE,STR$(x&)+" "+STR$(y&)+"  "
UNTIL k&=FALSE
lpx&=x&
lpy&=y&
zoom
note2
ATEXT 264,3,FALSE,"        "
x&=FALSE
setmo(x1&,y1&)
@showm
ENDIF
RETURN
> PROCEDURE 70                           ! Gestø curseurs couleur courante
IF k&=1
c&=t&
ELSE
c2&=t&
ENDIF
tralp
atm0
RETURN
> PROCEDURE plot                         ! Crayon loupe
LOCAL l&
l&=SUB(SUB(grs&,2),grille&)
REPEAT
IF k&
  clipmo(FALSE,40,MUL(SUB(nbx&,1),grs&),ADD(MUL(SUB(nby&,1),grs&),40))
  REPEAT
    tex&=OR(AND(ODD(k&),c&),AND(k&=2,c2&))
    @hide
    arec(x&,y&,ADD(x&,l&),ADD(y&,l&),tex&,FALSE)
    PSET x10&,y10&,tex&
    @showm
    if
    IF @btc(2)
      atm0
    ENDIF
    msl
  UNTIL k&=FALSE
  note2
  clipmo(FALSE,FALSE,MUL(SUB(nbx&,1),grs&),ADD(MUL(SUB(nby&,1),grs&),40))
ENDIF
clv2
if
msl
UNTIL OR(y&<40,exit&)
CLR l&
RETURN
> PROCEDURE line                         ! Ligne loupe
LOCAL l&
l&=SUB(SUB(grs&,2),grille&)
REPEAT
IF k&
  clipmo(FALSE,40,MUL(SUB(nbx&,1),grs&),ADD(MUL(SUB(nby&,1),grs&),40))
  x3&=x10&
  y3&=y10&
  IF k&=1
    c3&=c&
  ELSE
    c3&=c2&
  ENDIF
  REPEAT
    msl
    @hide
    IF AND(y10&=y3&,x10&=x3&)
      aux&=MUL(x3&,grs&)
      prt&=ADD(MUL(y3&,grs&),40)
      arec(aux&,prt&,ADD(aux&,l&),ADD(prt&,l&),c3&,FALSE)
      PSET x3&,y3&,c3&
    ELSE IF ABS(SUB(y10&,y3&))>ABS(SUB(x10&,x3&))
      j&=SUB(y10&,y3&)
      i&=SUB(x10&,x3&)
      FOR t&=y3& TO y10& STEP SGN(j&)
        prt&=MUL(ADD(ROUND(MUL(SUB(t&,y3&),i&)/j&),x3&),grs&)
        aux&=ADD(MUL(t&,grs&),40)
        arec(prt&,aux&,ADD(prt&,l&),ADD(aux&,l&),c3&,FALSE)
        PSET DIV(prt&,grs&),t&,c3&
      NEXT t&
    ELSE
      j&=SUB(x10&,x3&)
      i&=SUB(y10&,y3&)
      FOR t&=x3& TO x10& STEP SGN(j&)
        prt&=ADD(MUL(ADD(ROUND(MUL(SUB(t&,x3&),i&)/j&),y3&),grs&),40)
        aux&=MUL(t&,grs&)
        arec(aux&,prt&,ADD(aux&,l&),ADD(prt&,l&),c3&,FALSE)
        PSET t&,DIV(SUB(prt&,40),grs&),c3&
      NEXT t&
    ENDIF
    @showm
    if
    IF k&<>FALSE
      @hide
      BMOVE ADD(ado%,6400),ADD(ecran%,6400),25600
      RC_COPY ado%,FALSE,FALSE,nbx&,nby& TO ecran%,FALSE,FALSE
      @showm
    ELSE
      note2
    ENDIF
  UNTIL OR(k&=FALSE,k&=3)
  clipmo(FALSE,FALSE,MUL(SUB(nbx&,1),grs&),ADD(MUL(SUB(nby&,1),grs&),40))
  atm0
ENDIF
clv2
if
msl
UNTIL OR(y&<40,exit&)
CLR l&
RETURN
> PROCEDURE fill                         ! Peinture loupe
LOCAL l&
l&=SUB(SUB(grs&,2),grille&)
REPEAT
IF k&
  IF k&=1
    DEFFILL col&(c&),2,8
  ELSE
    DEFFILL col&(c2&),2,8
  ENDIF
  @hide
  CLIP FALSE,FALSE,nbx&,nby&
  FILL x10&,y10&
  CLIP FALSE,FALSE,320,200
  zoom
  @showm
  atm0
ENDIF
clv2
if
msl
UNTIL OR(y&<40,exit&)
CLR l&
RETURN
> PROCEDURE box                          ! Boite loupe (pleine & filaire)
LOCAL l&
l&=SUB(SUB(grs&,2),grille&)
DEFLINE 1
REPEAT
IF k&
  IF k&=1
    c3&=c&
  ELSE
    c3&=c2&
  ENDIF
  COLOR col&(c3&)
  DEFFILL col&(c3&),2,8
  x1&=x&
  y1&=y&
  x2&=x10&
  y2&=y10&
  clipmo(FALSE,40,MUL(SUB(nbx&,1),grs&),ADD(MUL(SUB(nby&,1),grs&),40))
  REPEAT
    @hide
    IF otll&=5
      PBOX x1&,y1&,ADD(x&,l&),ADD(y&,l&)
    ELSE
      BOX x1&,y1&,ADD(x&,l&),ADD(y&,l&)
    ENDIF
    @showm
    if
    msl
    @hide
    BMOVE ADD(ado%,6400),ADD(ecran%,6400),25600
    @showm
  UNTIL OR(k&=FALSE,k&=3)
  clipmo(FALSE,FALSE,MUL(SUB(nbx&,1),grs&),ADD(MUL(SUB(nby&,1),grs&),40))
  IF k&=FALSE
    @hide
    IF otll&=5
      PBOX x10&,y10&,x2&,y2&
    ELSE
      BOX x10&,y10&,x2&,y2&
    ENDIF
    zoom
    @showm
  ENDIF
  atm0
ENDIF
clv2
if
msl
UNTIL OR(y&<40,exit&)
CLR l&
RETURN
> PROCEDURE if                           ! Gestø sprite loupe
LOCAL l2&
l2&=SHR(l&,1)
IF @btc(20)
@hide
ALINE ADD(x&,l2&),40,ADD(x&,l2&),199,3,65535,2
HLINE FALSE,ADD(y&,l2&),319,3,2,adr%,1
ATEXT 264,3,FALSE,STR$(ADD(x10&,lpx&))+" "+STR$(ADD(y10&,lpy&))+"  "
move3(x&,y&,k&)
ALINE ADD(x&,l2&),40,ADD(x&,l2&),199,3,65535,2
HLINE FALSE,ADD(y&,l2&),319,3,2,adr%,1
@showm
ELSE
move3(x&,y&,k&)
ENDIF
CLR l2&
RETURN
> PROCEDURE zoom                         ! Affichage loupe
LOCAL al$,get%,state&
state&=curson&
IF state&
@hide
ENDIF
mouseoff
eff(lp%,6400)
FOR j&=FALSE TO SUB(nbx&,1)
RC_COPY ecran%,j&,FALSE,1,nby& TO lp%,MUL(j&,grs&),FALSE
NEXT j&
SELECT grs&
CASE 4,5
RC_COPY lp%,FALSE,FALSE,319,nby& TO lp%,1,FALSE,7
RC_COPY lp%,FALSE,FALSE,318,nby& TO lp%,SUB(grs&,3),FALSE,7
CASE 6 TO 9
RC_COPY lp%,FALSE,FALSE,319,nby& TO lp%,1,FALSE,7
RC_COPY lp%,FALSE,FALSE,318,nby& TO lp%,2,FALSE,7
RC_COPY lp%,FALSE,FALSE,SUB(325,grs&),nby& TO lp%,SUB(grs&,5),FALSE,7
CASE 10 TO 17
RC_COPY lp%,FALSE,FALSE,319,nby& TO lp%,1,FALSE,7
RC_COPY lp%,FALSE,FALSE,318,nby& TO lp%,2,FALSE,7
RC_COPY lp%,FALSE,FALSE,316,nby& TO lp%,4,FALSE,7
RC_COPY lp%,FALSE,FALSE,SUB(328,grs&),nby& TO lp%,SUB(grs&,9),FALSE,7
ENDSELECT
IF grille&
RC_COPY lp%,FALSE,FALSE,319,nby& TO lp%,1,FALSE,7
ELSE
al$=STRING$(40,MKL$(FALSE))
get%=V:al$
ENDIF
prt%=lp%
FOR t%=ADD(ecran%,6400) TO ADD(ADD(ecran%,6400),MUL(MUL(grs&,SUB(nby&,1)),160)) STEP MUL(grs&,160)
FOR i%=t% TO ADD(t%,MUL(SUB(grs&,2),160)) STEP 160
  BMOVE prt%,i%,160
NEXT i%
IF grille&
  BMOVE prt%,i%,160
ELSE
  BMOVE get%,i%,160
ENDIF
ADD prt%,160
NEXT t%
note2
mouseon
IF state&
@showm
ENDIF
CLR al$,get%,state&
RETURN
> PROCEDURE note2                        ! Gestø Undo loupe
LOCAL state&
state&=curson&
IF curson&
@hide
ENDIF
BMOVE ado%,lst%,32000
BMOVE ecran%,ado%,32000
IF state&
@showm
ENDIF
CLR state&
RETURN
> PROCEDURE clv2                         ! Test touche sous outils loupe
IF @inp_
tch&=@inp
SELECT act&(tch&)
CASE 0
  @hide
  ~C:gund%(L:ado%,L:lst%,W:199)
  BMOVE ADD(ado%,6400),ADD(ecran%,6400),25600
  RC_COPY ado%,FALSE,FALSE,nbx&,nby& TO ecran%,FALSE,FALSE
  @showm
CASE 3 TO 10
  action&=SUB(act&(tch&),2)
  exit&=-2
CASE 2
  IF y&>nby&
    @hide
    c&=PTST(x10&,y10&)
    tralp
    @showm
  ENDIF
CASE 44 TO 59
  IF @btc(2)
    c2&=SUB(act&(tch&),44)
  ELSE
    c&=SUB(act&(tch&),44)
  ENDIF
  tralp
CASE 61
  exit&=1
  ext&=TRUE
ENDSELECT
necho
ENDIF
RETURN
> PROCEDURE msl                          ! Test souris en tenant compte rapport grs
ms
x&=SUB(x&,MOD(x&,grs&))
y&=SUB(y&,MOD(SUB(y&,40),grs&))
x10&=DIV(x&,grs&)
y10&=DIV(SUB(y&,40),grs&)
CARD{ADD(table%,74)}=x&
CARD{ADD(table%,76)}=y&
RETURN
> PROCEDURE move3(x&,y&,k&)              ! Attend mouvement ou tch avec gestø shifts
LOCAL xm&,ym&,km&
xm&=x&
ym&=y&
km&=k&
necho
REPEAT
msl
UNTIL OR(OR(OR(x&<>xm&,y&<>ym&),km&<>k&),@inp_)
CLR x&,y&,k&,xm&,ym&,km&
RETURN
'
' GESTø DE BLOCKS
'
> PROCEDURE blk                           ! Block
LOCAL t%,x1&,y1&,y2&,x2&,aux&
def2
REPEAT
IF open&
  IF NOT pan&
    reaf(FALSE)
  ENDIF
  gblk
ELSE
  REPEAT
    ms
    loupe
    clv
  UNTIL OR(OR(k&,AND(y&>99,pan&)),exit&)
  x1&=x&
  y1&=y&
  IF k&=1
    @hide
    totalc
    SELECT lasso&
    CASE 1
      aux&=1
      j&=AND(pan&,ordo&)
      INT{ado%}=x&
      INT{ADD(ado%,2)}=ADD(y&,j&)
      PLOT x&,y&
      IF pan&
        clipmo(FALSE,FALSE,319,99)
      ENDIF
      t%=ADD(ado%,4)
      sx&=319
      sy&=199
      x2&=FALSE
      y2&=FALSE
      REPEAT
        @showm
        ms
        loupe
        move2
        INT{t%}=x&
        INT{ADD(t%,2)}=ADD(y&,j&)
        ADD t%,4
        IF x&<sx&
          sx&=x&
        ENDIF
        IF y&<sy&
          sy&=y&
        ENDIF
        IF x&>x2&
          x2&=x&
        ENDIF
        IF y&>y2&
          y2&=y&
        ENDIF
        INC aux&
        @hide
        DRAW  TO x&,y&
      UNTIL OR(OR(k&=FALSE,aux&=2000),k&=3)
      clipmo(FALSE,FALSE,319,199)
      IF k&<>3
        {t%}={ado%}
        LINE x&,y&,INT{ado%},SUB(INT{ADD(ado%,2)},j&)
        eff(blk%,32000)
        ~XBIOS(5,L:blk%,L:TRUE,W:TRUE)
        APOLY ado%,aux&,FALSE TO 199,15,1,adr%,1
        ~XBIOS(5,L:ecran%,L:TRUE,W:TRUE)
        BMOVE blk%,lst%,32000
        RC_COPY ec%(ec&),FALSE,FALSE,320,200 TO blk%,FALSE,FALSE,1
        BMOVE blk%,ado%,32000
        lgb&=ADD(SUB(x2&,sx&),1)
        htb&=ADD(SUB(y2&,sy&),1)
        IF take&
          RC_COPY lst%,FALSE,FALSE,320,200 TO ec%(ec&),FALSE,FALSE,4
          reput
          note(TRUE)
          mod&=TRUE
        ENDIF
        RC_COPY blk%,sx&,ADD(sy&,j&),lgb&,htb& TO blk%,FALSE,FALSE
      ENDIF
      reput
    CASE 0
      wd
      IF k&=FALSE
        sx&=x1&
        sy&=y1&
        lgb&=ADD(SUB(x&,x1&),1)
        htb&=ADD(SUB(y&,y1&),1)
        RC_COPY ecran%,sx&,sy&,lgb&,htb& TO blk%,FALSE,FALSE
        IF take&
          ym&=AND(ordo&,pan&)
          ~XBIOS(5,L:ec%(ec&),L:TRUE,W:TRUE)
          BMOVE ec%(ec&),undo%,32000
          mod&=TRUE
          arec(x1&,ADD(y1&,ym&),x&,ADD(y&,ym&),FALSE,FALSE)
          ~XBIOS(5,L:ecran%,L:TRUE,W:TRUE)
          reput
        ENDIF
      ENDIF
    CASE 2
      IF PTST(x&,y&)
        phy(ecran%)
        eff(blk%,32000)
        BMOVE ecran%,lst%,32000
        INT{ado%}=x&
        INT{ADD(ado%,2)}=y&
        INT{ADD(ado%,4)}=TRUE
        t%=ADD(ado%,6)
        sx&=319
        lgb&=FALSE
        sy&=199
        htb&=FALSE
        REPEAT
          SUB t%,6
          x2&=INT{t%}
          y2&=INT{ADD(t%,2)}
          IF INT{ADD(t%,4)}         ! Si demande recherche gauche
            REPEAT
              DEC x2&
              EXIT IF x2&=TRUE
            UNTIL C:ptst%(L:ecran%,x2&,y2&)=FALSE
            INC x2&
          ENDIF
          x1&=x2&
          IF y2&>FALSE
            IF C:ptst%(L:ecran%,x2&,SUB(y2&,1))
              INT{t%}=x2&
              INT{ADD(t%,2)}=SUB(y2&,1)
              INT{ADD(t%,4)}=TRUE
              ADD t%,6
            ENDIF
          ENDIF
          IF y2&<SUB(199,AND(pan&,100))
            IF C:ptst%(L:ecran%,x2&,ADD(y2&,1))
              INT{t%}=x2&
              INT{ADD(t%,2)}=ADD(y2&,1)
              INT{ADD(t%,4)}=TRUE
              ADD t%,6
            ENDIF
          ENDIF
          INC x2&
          IF y2&=FALSE
            REPEAT
              IF AND(C:ptst%(L:ecran%,x2&,ADD(y2&,1)),C:ptst%(L:ecran%,SUB(x2&,1),ADD(y2&,1))=FALSE)
                INT{t%}=x2&
                INT{ADD(t%,2)}=ADD(y2&,1)
                INT{ADD(t%,4)}=FALSE
                ADD t%,6
              ENDIF
              INC x2&
            UNTIL OR(C:ptst%(L:ecran%,x2&,y2&)=FALSE,x2&=320)
          ELSE IF y2&=SUB(199,AND(pan&,100))
            REPEAT
              IF AND(C:ptst%(L:ecran%,x2&,SUB(y2&,1)),C:ptst%(L:ecran%,SUB(x2&,1),SUB(y2&,1))=FALSE)
                INT{t%}=x2&
                INT{ADD(t%,2)}=SUB(y2&,1)
                INT{ADD(t%,4)}=FALSE
                ADD t%,6
              ENDIF
              INC x2&
            UNTIL OR(C:ptst%(L:ecran%,x2&,y2&)=FALSE,x2&=320)
          ELSE
            REPEAT
              IF AND(C:ptst%(L:ecran%,x2&,SUB(y2&,1)),C:ptst%(L:ecran%,SUB(x2&,1),SUB(y2&,1))=FALSE)
                INT{t%}=x2&
                INT{ADD(t%,2)}=SUB(y2&,1)
                INT{ADD(t%,4)}=FALSE
                ADD t%,6
              ENDIF
              IF AND(C:ptst%(L:ecran%,x2&,ADD(y2&,1)),C:ptst%(L:ecran%,SUB(x2&,1),ADD(y2&,1))=FALSE)
                INT{t%}=x2&
                INT{ADD(t%,2)}=ADD(y2&,1)
                INT{ADD(t%,4)}=FALSE
                ADD t%,6
              ENDIF
              INC x2&
            UNTIL OR(C:ptst%(L:ecran%,x2&,y2&)=FALSE,x2&=320)
          ENDIF
          DEC x2&
          IF sx&>x1&
            sx&=x1&
          ENDIF
          IF x2&>lgb&
            lgb&=x2&
          ENDIF
          IF y2&>htb&
            htb&=y2&
          ELSE IF y2&<sy&
            sy&=y2&
          ENDIF
          ~XBIOS(5,L:blk%,L:TRUE,W:TRUE)
          HLINE x1&,y2&,x2&,15,FALSE,adr%,1
          ~XBIOS(5,L:ecran%,L:TRUE,W:TRUE)
          HLINE x1&,y2&,x2&,FALSE,FALSE,adr%,1
          EXIT IF @inp_
        UNTIL t%=ado%
        IF NOT @inp_
          IF NOT take&
            BMOVE lst%,ecran%,32000
          ELSE
            note(TRUE)
          ENDIF
          RC_COPY lst%,FALSE,FALSE,320,SUB(200,AND(pan&,100)) TO blk%,FALSE,FALSE,1
          SUB lgb&,SUB(sx&,1)
          SUB htb&,SUB(sy&,1)
          RC_COPY blk%,sx&,sy&,lgb&,htb& TO blk%,FALSE,FALSE
        ELSE
          lgb&=1
          htb&=1
          k&=3
          necho
        ENDIF
      ELSE
        k&=3
      ENDIF
    ENDSELECT
    IF pan&
      affpar
      aclp(TRUE,FALSE,FALSE,319,99)
    ENDIF
    @showm
    IF k&=3
      reput
      atm0
      k&=FALSE
    ELSE
      open&=TRUE
      reaf(FALSE)
      gblk
    ENDIF
  ELSE IF k&=2
    mouseoff
    sx&=x1&
    sy&=y1&
    entry&=TRUE
    open&=TRUE
    k&=2
    setmo(sx&,sy&)
    CARD{ADD(table%,8)}=1
    gblk
  ENDIF
ENDIF
UNTIL OR(pan&,exit&)
CLR x1&,y1&,x2&,y2&,t%,aux&
RETURN
> PROCEDURE gblk                          ! Gestø block une fois ouvert
mask
REPEAT
ms
loupe
clv
IF OR(k&,entry&)
  mouseon
  entry&=FALSE
  IF NOT mod&
    BMOVE ec%(ec&),undo%,32000
  ELSE
    mod&=FALSE
  ENDIF
  IF AND(AND(x&>=sx&,y&>=sy&),AND(x&<ADD(sx&,lgb&),y&<ADD(sy&,htb&)))
    x1&=SUB(x&,sx&)
    y1&=SUB(y&,sy&)
    BMOVE ec%(ec&),ado%,32000
    aux2&=FALSE
    @hide
    def2
    IF pan&
      clipmo(FALSE,FALSE,319,99)
    ENDIF
    REPEAT
      ms
      put
      IF k&=3
        @hide
        IF pan&
          BMOVE ecran%,ADD(ec%(ec&),MUL(ordo&,160)),16000
        ELSE
          BMOVE ecran%,ec%(ec&),32000
        ENDIF
        @showm
        IF grp&=2
          ~C:mask%(L:ec%(ec&),L:lst%)
        ENDIF
        mod&=TRUE
      ENDIF
      IF AND(NOT @btc(2),k&<>FALSE)
        @hide
        BOX SUB(x&,x1&),SUB(y&,y1&),SUB(ADD(lgb&,SUB(x&,x1&)),1),SUB(ADD(htb&,SUB(y&,y1&)),1)
        @showm
      ENDIF
      loupe
    UNTIL k&=FALSE
    clipmo(FALSE,FALSE,319,199)
    sx&=SUB(x&,x1&)
    sy&=SUB(y&,y1&)
    put
    @showm
    BOX sx&,sy&,SUB(ADD(lgb&,sx&),1),SUB(ADD(htb&,sy&),1)
  ELSE
    open&=FALSE
    reput
    x&=sx&
    y&=sy&
    x1&=FALSE
    y1&=FALSE
    IF k&=1
      IF mod&
        SWAP ecran%,ec%(ec&)
        put
        SWAP ecran%,ec%(ec&)
        reput
      ELSE
        put
        note(TRUE)
      ENDIF
      mod&=FALSE
    ENDIF
    atm0
  ENDIF
ENDIF
UNTIL OR(OR(AND(y&>99,pan&),open&=FALSE),exit&)
atm0
k&=FALSE
RETURN
> PROCEDURE put                           ! Affiche le block
LOCAL state&
ordoh&=AND(ordo&,pan&)
IF SUB(x&,x1&)<FALSE
a&=FALSE
deca&=SUB(x1&,x&)
ELSE
a&=SUB(x&,x1&)
deca&=FALSE
ENDIF
IF SUB(y&,y1&)<FALSE
b&=FALSE
decb&=SUB(y1&,y&)
ELSE
b&=SUB(y&,y1&)
decb&=FALSE
ENDIF
IF ADD(lgb&,a&)>319
lgba&=SUB(320,a&)
ELSE
lgba&=lgb&
ENDIF
IF ADD(ADD(htb&,b&),ordoh&)>199
htba&=SUB(200,ADD(b&,ordoh&))
ELSE
htba&=htb&
ENDIF
aux%=ADD(ado%,MUL(ordoh&,160))
IF grp&=2
BMOVE ADD(ec%(ec&),MUL(ordoh&,160)),aux%,ADD(16000,AND(NOT pan&,16000))
RC_COPY lst%,a&,ADD(b&,ordoh&),SUB(lgba&,deca&),SUB(htba&,decb&) TO aux%,a&,b&
RC_COPY blk%,deca&,decb&,SUB(lgba&,deca&),SUB(htba&,decb&) TO aux%,a&,b&,1
RC_COPY ec%(ec&),a&,ADD(b&,ordoh&),SUB(lgba&,deca&),SUB(htba&,decb&) TO aux%,a&,b&,7
ELSE
IF ADD(ADD(MUL(htb&,160),aux2&),MUL(ordoh&,160))>32000
  bl4&=SUB(32000,ADD(aux2&,MUL(ordoh&,160)))
ELSE
  bl4&=MUL(htb&,160)
ENDIF
BMOVE ADD(ADD(ec%(ec&),aux2&),MUL(ordoh&,160)),ADD(aux%,aux2&),bl4&
IF grp&=1
  RC_COPY lst%,deca&,decb&,SUB(lgba&,deca&),SUB(htba&,decb&) TO aux%,a&,b&,1
  RC_COPY blk%,deca&,decb&,SUB(lgba&,deca&),SUB(htba&,decb&) TO aux%,a&,b&,7
ELSE
  RC_COPY blk%,deca&,decb&,SUB(lgba&,deca&),SUB(htba&,decb&) TO aux%,a&,b&
ENDIF
ENDIF
state&=curson&
IF curson&
@hide
ENDIF
BMOVE aux%,ecran%,ADD(16000,AND(NOT pan&,16000))
IF state&
@showm
ENDIF
aux2&=MUL(b&,160)
CLR state&
RETURN
> PROCEDURE modcall
mod(TRUE)
RETURN
> PROCEDURE mod(mode&)                    ! Choix deformatø de block
LOCAL state&
IF curson&
state&=TRUE
@hide
ENDIF
totalc
BMOVE ecran%,lst%,32000
eff(ecran%,32000)
def1
RC_COPY blk%,FALSE,FALSE,lgb&,htb& TO ecran%,FALSE,FALSE
FOR bl&=FALSE TO 7
deic(MUL(bl&,40),180,ADD(MUL(bl&,40),39),199,FALSE)
ATEXT ADD(MUL(bl&,40),3),184,FALSE,@rd$(6,bl&)
NEXT bl&
@showm
raster(MKL$(V:rvb&(FALSE,ec&))+MKI$(179)+MKL$(old%)+MKI$(240))
atm0
REPEAT
ms2
tabicone(FALSE,180,39,19,40,FALSE,7,FALSE,67)
icone(FALSE,FALSE,319,179,10)
UNTIL ext&
@hide
ext&=FALSE
BMOVE lst%,ecran%,32000
reaf(mode&)
IF mode&
norm
normpal
ENDIF
IF state&
@showm
ENDIF
k&=TRUE
atm0
k&=FALSE
CLR mode&
RETURN
> PROCEDURE modf                          ! Deformatø de block
LOCAL al$
@hide
GET FALSE,180,319,199,al$
raster(MKL$(V:rvb&(FALSE,ec&)))
eff(ado%,32000)
RC_COPY blk%,FALSE,FALSE,lgb&,htb& TO ado%,FALSE,FALSE
eff(ecran%,32000)
GRAPHMODE 3
atm0
COLOR 1
@def2
SELECT t&
CASE 0
PRINT AT(1,24);"X1:";lgb&;"  X2:";
PRINT AT(1,25);"Y1:";htb&;"  Y2:";
REPEAT
  ms
  BOX FALSE,FALSE,x&,y&
  PRINT AT(14,24);x&;"  X1/X2:";LEFT$(STR$(x&/lgb&),5);SPACE$(5);
  PRINT AT(14,25);y&;"  Y1/Y2:";LEFT$(STR$(y&/htb&),5);SPACE$(5);
  move2
  BOX FALSE,FALSE,x&,y&
UNTIL k&
reel=lgb&/x&
FOR t&=FALSE TO x&
  RC_COPY ado%,reel*t&,FALSE,1,htb& TO ecran%,t&,FALSE
NEXT t&
BMOVE ecran%,ado%,32000
reel=htb&/y&
FOR t&=FALSE TO y&
  BMOVE ADD(ado%,MUL(t&*reel,160)),ADD(ecran%,MUL(t&,160)),160
NEXT t&
IF y&<199
  eff(ADD(ecran%,MUL(y&,160)),SUB(32000,MUL(y&,160)))
ENDIF
atm0
atm
IF CARD{ADD(table%,8)}=2
  lgb&=ADD(x&,1)
  htb&=ADD(y&,1)
  RC_COPY ecran%,FALSE,FALSE,lgb&,htb& TO blk%,FALSE,FALSE
ENDIF
CASE 1
FOR t&=FALSE TO SUB(lgb&,1)
  RC_COPY ado%,t&,FALSE,1,htb& TO ecran%,SUB(SUB(lgb&,t&),1),FALSE
NEXT t&
atm
IF CARD{ADD(table%,8)}=2
  RC_COPY ecran%,FALSE,FALSE,lgb&,htb& TO blk%,FALSE,FALSE
ENDIF
CASE 2
FOR t&=FALSE TO SUB(htb&,1)
  BMOVE ADD(ado%,MUL(t&,160)),ADD(ecran%,MUL(SUB(SUB(htb&,1),t&),160)),160
NEXT t&
atm
IF CARD{ADD(table%,8)}=2
  RC_COPY ecran%,FALSE,FALSE,lgb&,htb& TO blk%,FALSE,FALSE
ENDIF
CASE 3
x1&=DIV(lgb&,2)
y1&=DIV(htb&,2)
a&=-x1&
b&=-y1&
REPEAT
  teta&=ROUND(x&*1.125)
  plx&(FALSE)=DIV(SUB(MUL(cs&(teta&),a&),MUL(sn&(teta&),b&)),30000)
  ply&(FALSE)=DIV(ADD(MUL(sn&(teta&),a&),MUL(cs&(teta&),b&)),30000)
  plx&(1)=DIV(SUB(MUL(cs&(teta&),x1&),MUL(sn&(teta&),b&)),30000)
  ply&(1)=DIV(ADD(MUL(sn&(teta&),x1&),MUL(cs&(teta&),b&)),30000)
  plx&(2)=DIV(SUB(MUL(cs&(teta&),x1&),MUL(sn&(teta&),y1&)),30000)
  ply&(2)=DIV(ADD(MUL(sn&(teta&),x1&),MUL(cs&(teta&),y1&)),30000)
  plx&(3)=DIV(SUB(MUL(cs&(teta&),a&),MUL(sn&(teta&),y1&)),30000)
  ply&(3)=DIV(ADD(MUL(sn&(teta&),a&),MUL(cs&(teta&),y1&)),30000)
  plx&(4)=plx&(FALSE)
  ply&(4)=ply&(FALSE)
  FOR t&=FALSE TO 4
    ADD plx&(t&),160
    ADD ply&(t&),100
  NEXT t&
  POLYLINE 5,plx&(),ply&()
  PRINT AT(1,25);"ROTATION:";teta&;"  ";
  move2
  ms2
  eff(ecran%,32000)
UNTIL k&
bl&=cs&(teta&)
bl2&=sn&(teta&)
lg&=a&
ht&=b&
t&=MUL(DIV(SUB(lgb&,1),16),8)
FOR g%=ado% TO ADD(ado%,MUL(SUB(htb&,1),160)) STEP 160
  FOR i%=g% TO ADD(g%,t&) STEP 8
    a%=LONG{i%}
    b%=LONG{ADD(i%,4)}
    IF OR(a%,b%)
      ADD lg&,16
      FOR j&=FALSE TO 15
        aux&=OR(SHL(AND(a%,1),1),AND(SWAP(a%),1))
        aux&=OR(aux&,OR(SHL(AND(b%,1),3),SHL(AND(SWAP(b%),1),2)))
        a%=SHR(a%,1)
        b%=SHR(b%,1)
        IF b&
          x&=ROUND(SUB(MUL(lg&,bl&),MUL(ht&,bl2&))/30000)
          y&=ROUND(ADD(MUL(lg&,bl2&),MUL(ht&,bl&))/30000)
          IF AND(AND(x&>-160,x&<160),AND(y&>-100,y&<100))
            PSET ADD(x&,160),ADD(y&,100),aux&
          ENDIF
        ENDIF
        DEC lg&
      NEXT j&
    ENDIF
    ADD lg&,16
  NEXT i%
  lg&=a&
  INC ht&
  EXIT IF @inp_
NEXT g%
IF NOT @inp_
  atm0
  atm
  IF CARD{ADD(table%,8)}=2
    redim(ecran%)
    RC_COPY ecran%,x1&,y1&,lgb&,htb& TO blk%,FALSE,FALSE
  ENDIF
ENDIF
CASE 4
REPEAT
  ms
  i&=((SUB(320,lgb&)/320)*x&)
  t&=SUB(320,i&)
  FOR j&=TRUE TO FALSE
    LINE i&,FALSE,ADD(lgb&,i&),FALSE
    LINE t&,htb&,SUB(t&,lgb&),htb&
    LINE i&,FALSE,SUB(t&,lgb&),htb&
    LINE ADD(i&,lgb&),FALSE,t&,htb&
  NEXT j&
UNTIL k&
eff(ecran%,32000)
reel=SUB(SUB(t&,lgb&),i&)/htb&
FOR j&=FALSE TO htb&
  RC_COPY ado%,FALSE,j&,lgb&,1 TO ecran%,ADD(reel*j&,i&),j&
NEXT j&
DEC j&
atm0
atm
IF CARD{ADD(table%,8)}=2
  redim(ecran%)
  RC_COPY ecran%,x1&,y1&,lgb&,htb& TO blk%,FALSE,FALSE
ENDIF
CASE 5
REPEAT
  ms
  i&=((SUB(200,htb&)/200)*y&)
  t&=SUB(200,i&)
  FOR j&=TRUE TO FALSE
    LINE FALSE,i&,FALSE,ADD(htb&,i&)
    LINE lgb&,t&,lgb&,SUB(t&,htb&)
    LINE FALSE,i&,lgb&,SUB(t&,htb&)
    LINE FALSE,ADD(i&,htb&),lgb&,t&
  NEXT j&
UNTIL k&
eff(ecran%,32000)
reel=SUB(SUB(t&,htb&),i&)/lgb&
FOR j&=FALSE TO lgb&
  RC_COPY ado%,j&,FALSE,1,htb& TO ecran%,j&,ADD(reel*j&,i&)
NEXT j&
DEC j&
atm0
atm
IF CARD{ADD(table%,8)}=2
  redim(ecran%)
  RC_COPY ecran%,x1&,y1&,lgb&,htb& TO blk%,FALSE,FALSE
ENDIF
CASE 7
prt&=FALSE
reel=SUB(200,htb&)/640
REPEAT
  ms
  eff(ecran%,32000)
  SELECT prt&
  CASE 0
    ampli=reel*x&
    PRINT AT(1,25);"AMPLI:";ampli;
  CASE 1
    freq=ADD(25,DIV(x&,4))/ADD(x&,1)
    PRINT AT(1,25);"FREQ:";freq;
  CASE 2
    point&=x&
    PRINT AT(1,25);"PHASE:";point&;
  CASE 3
    PRINT AT(1,25);"......"
  DEFAULT
    prt&=FALSE
  ENDSELECT
  IF k&=2
    INC prt&
    atm0
  ENDIF
  t1=DIV(sn&(MOD(point&,360))*ampli,30000)+ampli
  FOR t&=4 TO lgb& STEP 4
    t=DIV(sn&(MOD(ADD(point&,freq*t&),360))*ampli,30000)+ampli
    ALINE SUB(t&,4),t1,t&,t,15,65535,FALSE
    t1=t
  NEXT t&
  move2
  ms
UNTIL k&=1
eff(ecran%,32000)
FOR t&=FALSE TO lgb&
  RC_COPY ado%,t&,FALSE,1,htb& TO ecran%,t&,DIV(sn&(MOD(ADD(point&,freq*t&),360))*ampli,30000)+ampli
NEXT t&
atm0
atm
IF CARD{ADD(table%,8)}=2
  ADD htb&,ampli*2
  RC_COPY ecran%,FALSE,FALSE,lgb&,htb& TO blk%,FALSE,FALSE
ENDIF
CASE 6
prt&=FALSE
reel=SUB(320,lgb&)/640
REPEAT
  ms
  eff(ecran%,32000)
  SELECT prt&
  CASE 0
    ampli=reel*x&
    PRINT AT(1,25);"AMPLI:";ampli;
  CASE 1
    freq=ADD(25,DIV(x&,4))/ADD(x&,1)
    PRINT AT(1,25);"FREQ:";freq;
  CASE 2
    point&=x&
    PRINT AT(1,25);"PHASE:";point&;
  CASE 3
    PRINT AT(1,25);"......";
  DEFAULT
    prt&=FALSE
  ENDSELECT
  IF k&=2
    INC prt&
    atm0
  ENDIF
  t1=DIV(sn&(MOD(point&,360))*ampli,30000)+ampli
  FOR t&=4 TO htb& STEP 4
    t=DIV(sn&(MOD(ADD(point&,freq*t&),360))*ampli,30000)+ampli
    ALINE t1,SUB(t&,4),t,t&,15,65535,FALSE
    t1=t
  NEXT t&
  ms
UNTIL k&=1
eff(ecran%,32000)
FOR t&=FALSE TO htb&
  RC_COPY ado%,FALSE,t&,lgb&,1 TO ecran%,DIV(sn&(MOD(ADD(point&,freq*t&),360))*ampli,30000)+ampli,t&
NEXT t&
atm0
atm
IF CARD{ADD(table%,8)}=2
  ADD lgb&,ampli*2
  RC_COPY ecran%,FALSE,FALSE,lgb&,htb& TO blk%,FALSE,FALSE
ENDIF
ENDSELECT
echo_off
GRAPHMODE 1
eff(ecran%,32000)
RC_COPY blk%,FALSE,FALSE,lgb&,htb& TO ecran%,FALSE,FALSE
PUT FALSE,180,al$
CLR al$
raster(MKL$(V:rvb&(FALSE,ec&))+MKI$(179)+MKL$(old%)+MKI$(240))
k&=TRUE
atm0
k&=FALSE
@showm
RETURN
> PROCEDURE sblk                          ! Sauve block
appx(xh&,yh&,xb&,yb&)
PRINT AT(1,1);@rd$(76,ADD(k&=1,1))
vide$="DEFAULT.BLK"
IF k&=1
spath$=@form_path$(spath$,"BLK")
select(ado%,spath$,vide$)
lksauvph
IF vide$<>""
  path("BLK")
  LONG{lst%}=1396853580
  CARD{ADD(lst%,4)}=lgb&
  CARD{ADD(lst%,6)}=htb&
  prt%=ADD(lst%,8)
  FOR t%=blk% TO ADD(ADD(MUL(DIV(lgb&,16),8),4),blk%) STEP 4
    FOR i%=t% TO ADD(t%,MUL(SUB(htb&,1),160)) STEP 160
      LONG{prt%}=LONG{i%}
      ADD prt%,4
    NEXT i%
  NEXT t%
  BSAVE fich$,lst%,SUB(prt%,lst%)
  mask
ENDIF
ELSE
cpath$=@form_path$(cpath$,"BLK")
select(ado%,cpath$,vide$)
lkchargph
IF vide$<>""
  BLOAD fich$,lst%
  IF LONG{lst%}=1396853580
    lgb&=CARD{ADD(lst%,4)}
    htb&=CARD{ADD(lst%,6)}
    prt%=ADD(lst%,8)
    FOR t%=blk% TO ADD(ADD(MUL(DIV(lgb&,16),8),4),blk%) STEP 4
      FOR i%=t% TO ADD(t%,MUL(SUB(htb&,1),160)) STEP 160
        LONG{i%}=LONG{prt%}
        ADD prt%,4
      NEXT i%
    NEXT t%
  ELSE
    warningfich(@rd$(61,FALSE))
  ENDIF
ENDIF
ENDIF
reput
reaf(TRUE)
RETURN
> PROCEDURE redim(blk2%)                  ! Redimmensionne block
IF bkl2%=blk%
BMOVE blk2%,ado%,32000
eff(blk2%,32000)
RC_COPY ado%,FALSE,FALSE,lgb&,htb& TO blk2%,FALSE,FALSE
ENDIF
t%=C:redim%(L:blk2%)
IF INT{t%}=TRUE
x1&=FALSE
y1&=FALSE
lgb&=1
htb&=1
LONG{blk2%}=FALSE
ELSE
x1&=INT{ADD(t%,4)}
lgb&=ADD(SUB(INT{ADD(t%,6)},x1&),1)
y1&=INT{t%}
htb&=ADD(SUB(INT{ADD(t%,2)},y1&),1)
ENDIF
CLR blk2%
RETURN
> PROCEDURE mask                          ! Construit le mask selon le mode
IF grp&=1
~C:mask%(L:blk%,L:lst%)
ELSE IF grp&=2
~C:mask%(L:ec%(ec&),L:lst%)
ENDIF
RETURN
> PROCEDURE reaf(mode&)                   ! Reaffiche le block selon conjoncture
LOCAL state&
IF open&
state&=curson&
reput
mask
x&=sx&
y&=sy&
x1&=FALSE
y1&=FALSE
BMOVE ec%(ec&),ado%,32000
aux2&=FALSE
def2
put
aclp(TRUE,FALSE,FALSE,319,SUB(199,AND(pan&,100)))
IF curson&
  @hide
ENDIF
BOX sx&,sy&,SUB(ADD(sx&,lgb&),1),SUB(ADD(sy&,htb&),1)
IF mode&
  totalc
ENDIF
IF state&
  @showm
ENDIF
ENDIF
CLR state&,mode&
RETURN
'
' EDITEUR DE TRAMES
'
> PROCEDURE ed_tr                 ! Editeur de trame & pinceau
LOCAL ext&,t&,a&,x1&,y1&
raster(MKL$(V:rvb&(FALSE,ec&)))
x1&=aux&=21
y1&=ADD(tramm&,AND(12,x1&))
a&=15
mouseoff
@hide
eff(ecran%,28160)
DEFLINE 1
ALINE FALSE,175,319,175,15,65535,FALSE
deic(FALSE,FALSE,112,112,FALSE)
deic(FALSE,120,112,170,FALSE)
ATEXT 204,MUL(a&,10),1,CHR$(4)
eff(ADD(ecran%,28160),3840)
deic(FALSE,192,192,199,FALSE)
DEFFILL 1,4
ATEXT 240,165,FALSE,@rd$(5,SUB(7,x1&))
FOR t&=FALSE TO 15
IF t&<12
  ALINE ADD(MUL(t&,16),16),192,ADD(MUL(t&,16),16),199,15,65535,FALSE
  DEFFILL 1,tram$(ADD(t&,AND(x1&,12)))
  PBOX MUL(t&,16),176,ADD(MUL(t&,16),15),191
ENDIF
HLINE FALSE,MUL(t&,7),112,15,FALSE,adr%,1
ALINE MUL(t&,7),FALSE,MUL(t&,7),112,15,65535,1
deic(160,MUL(t&,10),200,ADD(MUL(t&,10),8),t&)
NEXT t&
FOR t&=FALSE TO 8
deic(220,MUL(t&,18),319,ADD(MUL(t&,18),15),FALSE)
ATEXT 224,ADD(MUL(t&,18),6),FALSE,@rd$(FALSE,t&)
NEXT t&
deic(192,175,242,199,FALSE)
deic(242,175,292,199,FALSE)
deic(292,175,319,199,FALSE)
ATEXT 245,180,FALSE,@rd$(46,FALSE)
ATEXT 195,180,FALSE,@rd$(46,1)
ATEXT 295,180,FALSE,@rd$(74,FALSE)
ATEXT ADD(MUL(tramm&,16),6),193,FALSE,"^"
test
comflip
@showm
atm0
REPEAT
ms2
IF AND(x&<112,y&<112)
  CARD{ADD(table%,6)}=2
  spr(8)
  CARD{ADD(table%,86)}=TRUE
  REPEAT
    x&=SUB(x&,MOD(x&,7))
    y&=SUB(y&,MOD(y&,7))
    x10&=DIV(x&,7)
    y10&=DIV(y&,7)
    CARD{ADD(table%,74)}=x&
    CARD{ADD(table%,76)}=y&
    IF k&
      tram|(y1&,x10&,y10&)=AND(ODD(k&),a&)
      @hide
      PSET ADD(x10&,MUL(tramm&,16)),ADD(y10&,176),AND(ODD(k&),a&)
      arec(ADD(x&,1),ADD(y&,1),ADD(x&,6),ADD(y&,6),AND(a&,ODD(k&)),FALSE)
      @showm
    ENDIF
    ms2
    IF inp_
      ext&=act&(@inp)=61
    ENDIF
  UNTIL OR(OR(x&>111,y&>111),ext&)
  CARD{ADD(table%,86)}=FALSE
  CARD{ADD(table%,6)}=1
  defmo(V:mouse$,hotpx&,hotpy&)
  test
ELSE
  tabicone(160,FALSE,40,9,FALSE,10,FALSE,15,31)
  tabicone(220,2,99,15,FALSE,18,FALSE,8,29)
  tabicone(FALSE,176,15,23,16,FALSE,11,FALSE,30)
  icone(192,175,241,199,32)
  icone(242,175,291,199,33)
  icone(292,175,319,199,10)
ENDIF
IF @inp_
  ext&=act&(@inp)=61
ENDIF
UNTIL ext&
CLR ext&,t&,a&,x1&,y1&
RETURN
> PROCEDURE comflip               ! Trace la trame dans la fenetre d'‚ditø
LOCAL state&,t&,i&
state&=curson&
IF curson&
@hide
ENDIF
mouseoff
FOR t&=FALSE TO 15
FOR i&=FALSE TO 15
  arec(ADD(MUL(t&,7),1),ADD(MUL(i&,7),1),ADD(MUL(t&,7),6),ADD(MUL(i&,7),6),tram|(y1&,t&,i&),FALSE)
  PSET ADD(t&,MUL(tramm&,16)),ADD(176,i&),tram|(y1&,t&,i&)
NEXT i&
NEXT t&
IF state&
@showm
ENDIF
mouseon
CLR state&,t&,i&
RETURN
> PROCEDURE test                  ! Affiche la trame avec un box
LOCAL state&
state&=curson&
IF curson&
@hide
ENDIF
deft(y1&)
DEFFILL 1,tram$(y1&)
PBOX 1,121,111,169
IF state&
@showm
ENDIF
CLR state&
RETURN
> PROCEDURE deft(y1&)             ! Forme trame sous format Gem … partir des tableaux
LOCAL b&,l&,i&,aux%
tram$(y1&)=""
FOR b&=FALSE TO 3
FOR l&=FALSE TO 15
  aux%=FALSE
  FOR i&=FALSE TO 15
    aux%=OR(aux%,AND(SHR(32768,i&),BTST(tram|(y1&,i&,l&),b&)))
  NEXT i&
  tram$(y1&)=tram$(y1&)+MKI$(aux%)
NEXT l&
NEXT b&
CLR y1&,b&,l&,i&,aux%
RETURN
> PROCEDURE 28                    ! Operations sur trame (flips...)
LOCAL i%,j&,t&,x2&,y2&
SELECT i&
CASE 0
FOR t&=FALSE TO 7
  FOR j&=FALSE TO 15
    aux&=tram|(y1&,t&,j&)
    tram|(y1&,t&,j&)=tram|(y1&,SUB(15,t&),j&)
    tram|(y1&,SUB(15,t&),j&)=aux&
  NEXT j&
NEXT t&
CASE 1
FOR t&=FALSE TO 7
  FOR j&=FALSE TO 15
    aux&=tram|(y1&,j&,t&)
    tram|(y1&,j&,t&)=tram|(y1&,j&,SUB(15,t&))
    tram|(y1&,j&,SUB(15,t&))=aux&
  NEXT j&
NEXT t&
CASE 2
FOR t&=FALSE TO 15
  FOR j&=FALSE TO 15
    tram|(y1&,j&,t&)=SUB(15,tram|(y1&,j&,t&))
  NEXT j&
NEXT t&
CASE 3
FOR j&=FALSE TO 15
  plx&(j&)=tram|(y1&,j&,FALSE)
NEXT j&
FOR j&=FALSE TO 14
  FOR t&=FALSE TO 15
    tram|(y1&,t&,j&)=tram|(y1&,t&,ADD(j&,1))
  NEXT t&
NEXT j&
FOR j&=FALSE TO 15
  tram|(y1&,j&,15)=plx&(j&)
NEXT j&
CASE 4
FOR j&=FALSE TO 15
  plx&(j&)=tram|(y1&,j&,15)
NEXT j&
FOR j&=14 DOWNTO FALSE
  FOR t&=FALSE TO 15
    tram|(y1&,t&,ADD(j&,1))=tram|(y1&,t&,j&)
  NEXT t&
NEXT j&
FOR j&=FALSE TO 15
  tram|(y1&,j&,FALSE)=plx&(j&)
NEXT j&
CASE 5
FOR j&=FALSE TO 15
  plx&(j&)=tram|(y1&,15,j&)
NEXT j&
FOR j&=14 DOWNTO FALSE
  FOR t&=FALSE TO 15
    tram|(y1&,ADD(j&,1),t&)=tram|(y1&,j&,t&)
  NEXT t&
NEXT j&
FOR j&=FALSE TO 15
  tram|(y1&,FALSE,j&)=plx&(j&)
NEXT j&
CASE 6
FOR j&=FALSE TO 15
  plx&(j&)=tram|(y1&,FALSE,j&)
NEXT j&
FOR j&=FALSE TO 14
  FOR t&=FALSE TO 15
    tram|(y1&,j&,t&)=tram|(y1&,ADD(j&,1),t&)
  NEXT t&
NEXT j&
FOR j&=FALSE TO 15
  tram|(y1&,15,j&)=plx&(j&)
NEXT j&
CASE 7
FOR t&=FALSE TO 15
  FOR j&=FALSE TO 15
    tram|(y1&,t&,j&)=FALSE
  NEXT j&
NEXT t&
CASE 8
@hide
BMOVE ecran%,ado%,32000
@showm
i%=@on_screen
@hide
IF i%<>TRUE
  x2&=AND(SWAP(i%),&HFFF)
  y2&=AND(i%,&HFF)
  FOR t&=FALSE TO 15
    FOR j&=FALSE TO 15
      tram|(y1&,t&,j&)=PTST(ADD(t&,x2&),ADD(j&,y2&))
    NEXT j&
  NEXT t&
ENDIF
BMOVE ado%,ecran%,32000
@showm
ENDSELECT
test
comflip
atm0
CLR t&,j&,x2&,y2&,k&,i%
RETURN
> PROCEDURE 29                    ! Gestø curseur de selectø de la trame ‚dit‚e
@hide
ATEXT ADD(SHL&(tramm&,4),6),193,FALSE," "
tramm&=t&
y1&=ADD(tramm&,AND(12,x1&))
ATEXT ADD(SHL&(tramm&,4),6),193,FALSE,"^"
@showm
comflip
test
atm0
RETURN
> PROCEDURE 30                    ! Gestø curseur couleur courante de l'‚diteur
@hide
ATEXT 204,MUL(a&,10),1," "
a&=i&
ATEXT 204,MUL(a&,10),1,CHR$(4)
@showm
RETURN
> PROCEDURE savt
spath$=@form_path$(spath$,"TRM")
vide$="DEFAULT.TRM"
select(ado%,spath$,vide$)
lksauvph
IF k&
path("TRM")
{ado%}=CVL("TRAMES")
prt%=ADD(ado%,4)
FOR t&=FALSE TO 15
  FOR i&=FALSE TO 15
    BYTE{prt%}=tram|(y1&,t&,i&)
    INC prt%
  NEXT i&
NEXT t&
BSAVE fich$,ado%,260
ENDIF
RETURN
> PROCEDURE loadt
cpath$=@form_path$(cpath$,"TRM")
vide$="DEFAULT.TRM"
select(ado%,cpath$,vide$)
lkchargph
IF vide$<>""
BLOAD fich$,ado%
IF {ado%}<>CVL("TRAMES")
  warningfich(@rd$(59,FALSE))
ELSE
  prt%=ADD(ado%,4)
  FOR t&=FALSE TO 15
    FOR i&=FALSE TO 15
      tram|(y1&,t&,i&)=BYTE{prt%}
      INC prt%
    NEXT i&
  NEXT t&
  comflip
  test
ENDIF
ENDIF
RETURN
'
' ECRANS (Screen manager-Animatø)
'
> PROCEDURE affbar                        ! Affichage la barre de s‚lection en bas de l'‚cran
LOCAL t&,state&
IF curson&
state&=TRUE
@hide
ENDIF
deic2(220,180,259,199)
deic2(260,180,279,199)
deic2(280,180,319,199)
defx
GRAPHMODE 2
FOR t&=FALSE TO 10
deic2(MUL(t&,20),180,ADD(MUL(t&,20),19),199)
IF t&<6
  TEXT ADD(MUL(t&,20),3),191,STR$(ADD(nec&(t&),1))
ENDIF
NEXT t&
TEXT 126,191,CHR$(4)
TEXT 166,191,CHR$(3)
TEXT 142,191,STR$(ADD(ecran&,1))
TEXT 181,191,"Dsk"
TEXT 204,191,"VC"
TEXT 222,191,@rd$(44,FALSE)
TEXT 286,191,"EXIT"
TEXT 261,191,@rd$(21,ADD(1,mode&))
GRAPHMODE 1
appx(ADD(MUL(cursec&,20),2),182,ADD(MUL(cursec&,20),17),197)
IF state&
@showm
ENDIF
CLR t&,state&
RETURN
> PROCEDURE ec                            ! Gestion ecran
LOCAL oldec&
oldec&=-20                            ! Force l'affichage
@hide
def1
eff(ecran%,32000)
trac(oldec&)
affbar
@showm
atm0
REPEAT
ms2
tabicone(FALSE,FALSE,79,49,80,60,3,2,52)
tabicone(FALSE,50,79,10,80,60,3,2,78)
tabicone(FALSE,180,19,19,20,FALSE,5,FALSE,53)
tabicone(120,180,19,19,20,FALSE,2,FALSE,102)
icone(180,180,199,199,14)
icone(200,180,219,199,54)
icone(220,180,259,199,58)
icone(280,180,319,199,10)
icone(260,180,279,199,103)
IF @inp_
  tch&=@inp
  SELECT act&(tch&)
  CASE 11 TO 16
    cursec&=SUB(act&(tch&),11)
    affbar
  CASE 61
    ext&=TRUE
  ENDSELECT
ENDIF
UNTIL ext&
appx(280,180,319,199)
ec&=nec&(cursec&)
ext&=FALSE
atm0
retake
BMOVE ec%(ec&),undo%,32000
RETURN
> PROCEDURE 103                           ! Gestø mode reduction
appx(xh&,yh&,xb&,yb&)
mode&=NOT mode&
oldec&=-20
trac(oldec&)
affbar
atm0
RETURN
> PROCEDURE 102                           ! Gestion du nø d'‚cran
LOCAL ic&
appx(xh&,yh&,xb&,yb&)
SELECT t&
CASE 1
vide$=""
ecran&=MAX(MIN(SUB(@input(1,1,FALSE,1,vide$),1),nbec&),FALSE)
trac(oldec&)
CASE 2
IF k&=1
  REPEAT
    IF ADD(ecran&,11)<nbec&
      INC ecran&
      trac(oldec&)
    ENDIF
    ms2
  UNTIL k&=FALSE
ELSE
  ecran&=MIN(ADD(ecran&,12),nbec&)
  trac(oldec&)
  atm0
ENDIF
CASE 0
IF k&=1
  REPEAT
    IF ecran&>FALSE
      DEC ecran&
      trac(oldec&)
    ENDIF
    ms2
  UNTIL k&=FALSE
ELSE
  ecran&=MAX(SUB(ecran&,12),FALSE)
  trac(oldec&)
  atm0
ENDIF
ENDSELECT
resx(xh&,yh&,xb&,yb&)
CLR ic&,k&,x&
RETURN
> PROCEDURE pal_ec                        ! Fixe la palette du screeen mananger en tenant compte du mode de reductø
LOCAL ras$,t&,j&
IF mode&
ras$=MKL$(pal_deg%)+MKI$(180)
ELSE
FOR j&=FALSE TO 8 STEP 4
  t&=ADD(j&,ecran&)
  EXIT IF t&>nbec&
  ras$=ras$+MKL$(V:rvb&(FALSE,t&))+MKI$(ADD(51,j&=FALSE))+MKL$(old%)+MKI$(9)
NEXT j&
ENDIF
raster(ras$+MKL$(old%)+MKI$(240))
CLR ras$,t&,j&
RETURN
> PROCEDURE 78                            ! Protect On/Off & gestø curseur digitalisation
LOCAL aux&
j&=ADD(ADD(t&,SHL(i&,2)),ecran&)
IF nbec&>=j&
IF @btc(2)
  protec&(j&)=NOT protec&(j&)
  IF protec&(j&)
    atex(ADD(xh&,2),ADD(yh&,2),FALSE,"*")
  ELSE
    atex(ADD(xh&,2),ADD(yh&,2),FALSE," ")
  ENDIF
ELSE
  IF k&=1
    IF j&<=enddigi&
      aux&=SUB(debdigi&,ecran&)
      IF AND(aux&>TRUE,aux&<12)
        atex(ADD(MUL(AND(aux&,3),80),56),ADD(52,MUL(SHR&(aux&,2),60)),FALSE," ")
      ENDIF
      atex(ADD(xh&,56),ADD(yh&,2),FALSE,CHR$(4))
      debdigi&=j&
    ENDIF
  ELSE IF k&=2
    IF AND(j&<=nbec&,j&=>debdigi&)
      aux&=SUB(enddigi&,ecran&)
      IF AND(aux&>TRUE,aux&<12)
        atex(ADD(MUL(AND(aux&,3),80),62),ADD(52,MUL(SHR&(aux&,2),60)),FALSE," ")
      ENDIF
      atex(ADD(xh&,62),ADD(yh&,2),FALSE,CHR$(3))
      enddigi&=j&
    ENDIF
  ENDIF
ENDIF
ENDIF
atm0
RETURN
> PROCEDURE retake                        ! Reprend le bitmap du panel avec les nouvelles touches ecrans
@hide
ppan
defx
GRAPHMODE 2
FOR t&=FALSE TO 2
FOR i&=FALSE TO 1
  arec(ADD(MUL(t&,22),223),ADD(142,MUL(i&,14)),ADD(MUL(t&,22),241),ADD(MUL(i&,14),152),2,FALSE)
  TEXT ADD(226,MUL(t&,22)),ADD(149,MUL(i&,14)),STR$(ADD(nec&(ADD(t&,MUL(i&,3))),1))
NEXT i&
NEXT t&
GRAPHMODE 1
IF pane2&
resx(288,141,308,168)
ELSE
appx(288,141,308,168)
ENDIF
retpan
@showm
RETURN
> PROCEDURE trac(VAR oldec&)              ! Trace les ‚crans
LOCAL state&,j&,a$,t&,t%,l&
IF oldec&<>ecran&
IF curson&
  state&=TRUE
  @hide
ENDIF
pal_ec
IF AND(ABS(SUB(oldec&,ecran&))<2,nbec&>11)
  IF ADD(oldec&,1)=ecran&
    BMOVE ADD(ecran%,40),ecran%,7960
    RC_COPY ecran%,FALSE,60,80,50 TO ecran%,240,FALSE
    BMOVE ADD(ecran%,9640),ADD(ecran%,9600),7960
    RC_COPY ecran%,FALSE,120,80,50 TO ecran%,240,60
    BMOVE ADD(ecran%,19240),ADD(ecran%,19200),7960
    ~C:retrc%(L:ec%(ADD(ecran&,11)),L:ADD(ecran%,19320),L:V:rvb&(FALSE,ADD(ecran&,11)),mode&)
  ELSE
    BMOVE ADD(ecran%,19200),ADD(ecran%,19240),7960
    RC_COPY ecran%,240,60,80,50 TO ecran%,FALSE,120
    BMOVE ADD(ecran%,9600),ADD(ecran%,9640),7960
    RC_COPY ecran%,240,FALSE,80,50 TO ecran%,FALSE,60
    BMOVE ecran%,ADD(ecran%,40),7960
    ~C:retrc%(L:ec%(ecran&),L:ecran%,L:V:rvb&(FALSE,ecran&),mode&)
  ENDIF
ELSE
  eff(ecran%,28800)
  FOR j&=FALSE TO 2
    deic(TRUE,ADD(50,MUL(j&,60)),320,ADD(58,MUL(j&,60)),FALSE)
  NEXT j&
ENDIF
FOR j&=FALSE TO 11
  t&=ADD(j&,ecran&)
  IF protec&(t&)
    a$="* Nø"
  ELSE
    a$="  Nø"
  ENDIF
  a$=a$+STR$(ADD(t&,1),2)
  IF OR(OR(full&(FALSE)=t&,full&(1)=t&),OR(full&(2)=t&,full&(3)=t&))
    a$=a$+" f "
  ELSE
    a$=a$+"   "
  ENDIF
  a$=a$+CHR$(SUB(32,AND(28,t&=debdigi&)))+CHR$(SUB(32,AND(29,t&=enddigi&)))
  ATEXT ADD(MUL(AND(j&,3),80),2),ADD(52,MUL(SHR(j&,2),60)),FALSE,a$
  IF OR(ABS(SUB(ecran&,oldec&))>1,nbec&<12)
    ~C:retrc%(L:ec%(t&),L:ADD(ADD(ecran%,MUL(AND(j&,3),40)),MUL(SHR(j&,2),9600)),L:V:rvb&(FALSE,t&),mode&)
  ENDIF
  EXIT IF t&=nbec&
NEXT j&
arec(141,181,158,198,2,FALSE)
defx
GRAPHMODE 2
TEXT 144,191,STR$(ADD(ecran&,1))
GRAPHMODE 1
oldec&=ecran&
IF state&
  @showm
ENDIF
ENDIF
CLR state&,j&,t&,a$,t%,l&
RETURN
> PROCEDURE 52                            ! Attributø ecran / visualistø ecran
LOCAL a&,l&,a$
a&=ADD(ADD(ecran&,t&),SHL&(i&,2))
IF a&<=nbec&
IF k&=2
  see(a&)
  pal_ec
ELSE
  IF @btc(2)
    FOR l&=FALSE TO 5
      EXIT IF ADD(l&,a&)>nbec&
      nec&(l&)=ADD(a&,l&)
    NEXT l&
  ELSE
    nec&(cursec&)=a&
  ENDIF
ENDIF
affbar
ENDIF
atm0
CLR a&,l&,k&,a$
RETURN
> PROCEDURE 53                            ! Curseur touche
cursec&=t&
affbar
atm0
RETURN
> PROCEDURE 14                            ! Appel ac
appx(xh&,yh&,xb&,yb&)
ac(nec&(cursec&),cursec&)
affbar
oldec&=-20
trac(oldec&)
atm0
k&=FALSE
RETURN
> PROCEDURE see(a&)
phy(ec%(a&))
raster(MKL$(V:rvb&(FALSE,a&)))
IF @btc(2)
~XBIOS(5,L:ec%(a&),L:TRUE,W:TRUE)
GET FALSE,FALSE,319,7,a$
PRINT AT(1,1);nom$(a&);
atm0
PUT FALSE,FALSE,a$
~XBIOS(5,L:ecran%,L:TRUE,W:TRUE)
ELSE
atm0
ENDIF
phy(ecran%)
CLR a&
RETURN
> PROCEDURE 54                            ! Digitalisation
LOCAL t&,t%,ret&,i&,j&
appx(xh&,yh&,xb&,yb&)
IF @btc(2)
@hide
eff(ecran%,28800)
@showm
raster(MKL$(old%))
img_per_sec&=ADD(@alt(TRUE,TRUE,@rd$(85,FALSE)+STR$(24/2^SUB(img_per_sec&,1)),"24|12|6|3|1.5|0.75",FALSE),1)
ELSE
t%=ado%
FOR t&=debdigi& TO enddigi&
  IF protec&(t&)=FALSE
    {t%}=ec%(t&)
    ADD t%,4
  ENDIF
  {t%}=FALSE
NEXT t&
IF t%=ado%
  raster(MKL$(old%))
  @hide
  eff(ecran%,28800)
  @showm
  ~@alt(TRUE,TRUE,@rd$(81,FALSE),"   Ok   ",FALSE)
ELSE
  atm0
  raster(MKL$(pal_deg%))
  @vs
  @vs
  ret&=C:video%(L:ado%,W:k&=2,W:img_per_sec&,L:lst%)
  SELECT ret&
  CASE -1
    raster(MKL$(old%))
    @hide
    eff(ecran%,28800)
    @showm
    ~@alt(TRUE,TRUE,@rd$(86,FALSE),"   Ok   ",FALSE)
  CASE -2
  DEFAULT
    CARD{ADD(table%,8)}=FALSE
    i&=FALSE
    FOR t&=debdigi& TO enddigi&
      IF protec&(t&)=FALSE
        IF ec&=t&
          BMOVE ec%(ec&),undo%,32000
        ENDIF
        BMOVE pal_deg%,V:rvb&(FALSE,t&),32
        plx&(i&)=t&
        INC i&
      ENDIF
    NEXT t&
    IF AND(AND(i&>1,k&=2),SUB(i&,ret&))
      FOR t&=2 TO SUB(i&,ret&)
        FOR j&=i& DOWNTO 1
          plx&(j&)=plx&(SUB(j&,1))
        NEXT j&
        plx&(FALSE)=plx&(i&)
      NEXT t&
      BMOVE V:ec%(FALSE),lst%,400
      i&=FALSE
      FOR t&=debdigi& TO enddigi&
        IF protec&(t&)=FALSE
          ec%(t&)={ADD(lst%,SHL(plx&(i&),2))}
          INC i&
        ENDIF
      NEXT t&
    ENDIF
  ENDSELECT
ENDIF
ENDIF
oldec&=-20                            ! Force l'affichage
trac(oldec&)
resx(xh&,yh&,xb&,yb&)
atm0
CLR t&,t%,ret&,i&,j&
RETURN
'
> PROCEDURE 58                            ! Animation
LOCAL ext&
@hide
BMOVE ecran%,ado%,32000
appx(xh&,yh&,xb&,yb&)
tracanim
atm0
REPEAT
ms2
tabicone(FALSE,FALSE,19,17,20,18,19,8,59)
tabicone(FALSE,180,79,19,80,FALSE,3,FALSE,72)
IF @inp_
  ext&=act&(@inp)=61
ENDIF
UNTIL ext&
@hide
raster(MKL$(V:rvb&(FALSE,ecran&))+MKI$(179)+MKL$(old%)+MKI$(240))
BMOVE ado%,ecran%,32000
pal_ec
@showm
CLR k&,ext&
RETURN
> PROCEDURE tracanim                      ! Affiche la piste d'animatø
LOCAL a&,b&
@hide
eff(ecran%,32000)
raster(MKL$(old%))
def1
FOR a&=FALSE TO 3
deic2(MUL(a&,80),180,ADD(MUL(a&,80),79),199)
NEXT a&
deic2(FALSE,175,319,179)
defx
GRAPHMODE 2
TEXT 10,191,@rd$(50,FALSE)
TEXT 82,191,@rd$(49,-anim&)
TEXT 170,191,@rd$(17,FALSE)
TEXT 250,191,"EXIT"
GRAPHMODE 1
FOR a&=FALSE TO 15
aux&=MUL(a&,20)
FOR b&=FALSE TO 8
  aux2&=MUL(b&,18)
  BOX aux&,aux2&,ADD(aux&,18),ADD(aux2&,10)
  ATEXT ADD(aux&,2),ADD(aux2&,2),FALSE,STR$(ADD(AND(anim&(ADD(a&,SHL&(b&,4))),255),1))
NEXT b&
NEXT a&
ATEXT ADD(MUL(AND(endan&,15),20),3),ADD(MUL(SHR&(endan&,4),18),12),FALSE,CHR$(3)
ATEXT ADD(MUL(AND(deban&,15),20),3),ADD(MUL(SHR&(deban&,4),18),12),FALSE,CHR$(4)
@showm
CLR a&,b&
RETURN
> PROCEDURE 72                            ! Gestø barre option anim (prg-anim bouclee/anim avant arriere-anim-exit)
appx(xh&,yh&,xb&,yb&)
SELECT t&
CASE 0
anim
CASE 1
atm0
anim&=NOT anim&
deic2(xh&,yh&,xb&,yb&)
tex2(82,191,@rd$(49,-anim&))
CASE 2
atm0
IF @edit_prg
  prg
ENDIF
tracanim
CASE 3
ext&=TRUE
ENDSELECT
atm0
resx(xh&,yh&,xb&,yb&)
RETURN
> PROCEDURE 59                            ! Parametrages track
LOCAL y2&
y2&=ADD(SHL&(i&,4),t&)
IF MOD(y&,18)>10
IF k&=1
  atex(ADD(MUL(AND(deban&,15),20),3),ADD(MUL(SHR&(deban&,4),18),12),FALSE," ")
  deban&=MIN(SUB(endan&,1),y2&)
  atex(ADD(MUL(AND(deban&,15),20),3),ADD(MUL(SHR&(deban&,4),18),12),FALSE,CHR$(4))
ELSE
  atex(ADD(MUL(AND(endan&,15),20),3),ADD(MUL(SHR&(endan&,4),18),12),FALSE," ")
  endan&=MAX(y2&,ADD(deban&,1))
  atex(ADD(MUL(AND(endan&,15),20),3),ADD(MUL(SHR&(endan&,4),18),12),FALSE,CHR$(3))
ENDIF
atm0
k&=FALSE
ELSE
IF k&=1
  REPEAT
    ms2
    nummer&=DIV(MUL(x&,ADD(nbec&,1)),320)
    atex(ADD(MUL(t&,20),2),ADD(MUL(i&,18),2),FALSE,STR$(ADD(nummer&,1))+SPACE$(AND(1,nummer&<9)))
  UNTIL k&=FALSE
  anim&(y2&)=OR(nummer&,AND(anim&(y2&),&HFF00))
  setmo(xh&,yh&)
ELSE
  see(AND(anim&(y2&),&HFF))
  raster(MKL$(old%))
ENDIF
ENDIF
CLR y2&
RETURN
> PROCEDURE anim                          ! Animatø (play track)
LOCAL a&,b&
atm0
a&=deban&
IF anim&=FALSE
REPEAT
  phy(ec%(AND(anim&(a&),&HFF)))
  raster(MKL$(V:rvb&(FALSE,AND(anim&(a&),&HFF))))
  INC a&
  IF a&>endan&
    a&=deban&
  ENDIF
  FOR b&=FALSE TO SUB(50,SHR&(AND(anim&(a&),&HFF00),8))
    EXIT IF OR(@mousek,@inp_)
    @vs
  NEXT b&
UNTIL OR(@mousek,@inp_)
ELSE
y2&=1
REPEAT
  phy(ec%(AND(anim&(a&),&HFF)))
  raster(MKL$(V:rvb&(FALSE,AND(anim&(a&),&HFF))))
  ADD a&,y2&
  IF OR(a&=endan&,a&=deban&)
    y2&=-y2&
  ENDIF
  FOR b&=FALSE TO SUB(50,SHR&(AND(anim&(a&),&HFF00),8))
    EXIT IF OR(@mousek,@inp_)
    @vs
  NEXT b&
UNTIL OR(@mousek,@inp_)
ENDIF
phy(ecran%)
raster(MKL$(old%))
necho
atm0
CLR a&,b&
RETURN
> PROCEDURE prg                           ! Analyse syntaxique du programme
LOCAL a$,b$,t&,error&,l&,flag&,vit&,a&,deb&,arr&,i&,last&
'
deic2(FALSE,180,319,199)
tex2(10,195,@rd$(17,1))
ARRAYFILL anim&(),FALSE
a$=UPPER$(prg$)                     ! Tout en majuscule
l&=INSTR(a$,"END")                  ! RepŠre la fin du programme
IF l&=FALSE                         ! Si pas de fin => syntax error
eff(ecran%,28800)
PRINT AT(1,1);@rd$(17,2)
PRINT @rd$(17,7)
~@inp
ELSE
i&=FALSE                          ! Indice sur tableau anim
FOR t&=1 TO SUB(l&,1)
  SELECT MID$(a$,t&,3)
  CASE "FOR"                      ! Boucle
    ADD t&,2
    flag&=FALSE
    REPEAT
      INC t&
      SELECT TRIM$(MID$(a$,t&,1))
      CASE "0" TO "9"
        IF flag&
          ananum(MID$(a$,t&),t&,arr&,error&)
        ELSE
          ananum(MID$(a$,t&),t&,deb&,error&)
        ENDIF
      CASE "T"
        IF MID$(a$,t&,2)="TO"
          flag&=TRUE
          ADD t&,2
        ELSE
          error&=TRUE
        ENDIF
      ENDSELECT
      error&=OR(error&,t&>=l&)
    UNTIL OR(MID$(a$,t&,1)="!",error&)         ! Si fin ou erreur
    IF AND(NOT error&,NOT flag&)
      error&=TRUE
    ENDIF
    IF NOT error&
      IF arr&<>deb&
        FOR a&=deb& TO arr& STEP SGN(SUB(arr&,deb&))
          attrib(i&,a&,vit&,error&)
          INC i&
        NEXT a&
      ELSE
        attrib(i&,deb&,vit&,error&)
        INC i&
      ENDIF
    ENDIF
    INC t&
  CASE "SEQ"
    ADD t&,2
    REPEAT
      INC t&
      b$=MID$(a$,t&,1)
      SELECT b$
      CASE "0" TO "9"
        ananum(MID$(a$,t&),t&,aux&,error&)
        attrib(i&,aux&,vit&,error&)
        INC i&
      ENDSELECT
    UNTIL OR(OR(b$="!",error&),t&>=l&)
  CASE "REM"
    ADD t&,2
    REPEAT
      INC t&
      b$=MID$(a$,t&,1)
    UNTIL OR(b$="!",t&>=l&)
  CASE "VIT"
    ananum(MID$(a$,t&),t&,vit&,error&)
  ENDSELECT
  EXIT IF error&
NEXT t&
IF error&
  ARRAYFILL anim&(),FALSE
  eff(ecran%,28800)
  SELECT AND(error&,&HFF)
  CASE 3
    PRINT AT(1,1);@rd$(17,3);SHR&(AND(error&,&HFF00),8);@rd$(17,4)
  CASE 2
    PRINT AT(1,1);@rd$(17,5)
  DEFAULT
    PRINT AT(1,1);@rd$(17,6)
  ENDSELECT
  PRINT @rd$(17,7)
  ~@inp
ELSE
  endan&=MAX(last&,ADD(deban&,1))
ENDIF
ENDIF
CLR a$,b$,t&,error&,l&,flag&,vit&,a&,deb&,arr&,i&,last&
RETURN
> PROCEDURE ananum(a$,VAR t&,a&,error&)   ! Determine le nombre stockee dans la chaine … la position courante (li‚ … prg)
LOCAL i&,b$
i&=1
b$=MID$(a$,1,1)
WHILE AND(OR(ASC(b$)<48,ASC(b$)>57),i&<=LEN(a$))
INC i&
b$=MID$(a$,i&,1)
WEND
SELECT b$
CASE "0" TO "9"
a&=FALSE
WHILE AND(AND(AND(ASC(MID$(a$,i&,1))>=48,ASC(MID$(a$,i&,1))<=57),MID$(a$,i&,1)<>"!"),ADD(i&,t&)=<l&)
  a&=ADD(MUL(a&,10),SUB(ASC(MID$(a$,i&,1)),48))
  INC i&
WEND
ADD t&,SUB(i&,1)
DEFAULT
error&=TRUE
ENDSELECT
CLR i&,b$
RETURN
> PROCEDURE attrib(i&,t&,vit&,VAR error&) ! Fixe un num‚ro d'‚cran sur la case animatø courante (li‚ … prg)
DEC t&
IF AND(AND(i&<144,t&=<nbec&),t&>TRUE)
anim&(i&)=OR(t&,SHL&(vit&,8))
last&=i&
ELSE IF i&>143
error&=2
ELSE
error&=OR(3,SHL&(ADD(t&,1),8))
ENDIF
RETURN
> FUNCTION edit_prg                       ! Edition du programme
LOCAL tch&,ext&,edit&,max&,t&,curs&,a$
raster(MKL$(old%))
inter_off
FOR t&=FALSE TO 3
deic2(MUL(t&,80),180,ADD(MUL(t&,80),79),189)
deic2(MUL(t&,80),190,ADD(MUL(t&,80),79),199)
tex2(ADD(MUL(t&,80),3),187,@rd$(72,max&))
INC max&
tex2(ADD(MUL(t&,80),3),197,@rd$(72,max&))
INC max&
NEXT t&
tex2(245,197,"MAX: "+STR$(ADD(nbec&,1)))
affprg
curs
max&=MAX(DIV(SUB(LEN(prg$),1),40),FALSE)
REPEAT
IF INP(-2)
tch&=INP(2)
SELECT tch&
CASE 200
  IF curs&>FALSE
    curs
    DEC curs&
    curs
  ELSE
    IF edit&>FALSE
      curs
      BMOVE ecran%,ADD(ecran%,1280),26880
      DEC edit&
      PRINT AT(1,1);MID$(prg$,ADD(MUL(edit&,40),1),38)
      curs
    ENDIF
  ENDIF
CASE 208
  IF curs&<MIN(21,SUB(max&,edit&))
    curs
    INC curs&
    curs
  ELSE
    IF edit&<max&
      curs
      INC edit&
      BMOVE ADD(ecran%,1280),ecran%,26880
      curs&=MIN(curs&,SUB(max&,edit&))
      IF max&<ADD(edit&,21)
        PRINT AT(1,ADD(SUB(max&,edit&),2));SPACE$(38);
      ELSE
        PRINT AT(1,22);MID$(prg$,ADD(MUL(edit&,40),841),38)
      ENDIF
      curs
    ENDIF
  ENDIF
  ' CASE 199
  ' IF LEN(prg$)<32000
  '  curs
  '  prg$=prg$+SPACE$(38)+"! "
  '  INC max&
  ' curs&=FALSE
  ' edit&=max&
  ' affprg
  ' curs
  ' ENDIF
CASE 210
  IF LEN(prg$)<32000
    curs
    IF curs&<21
      t%=ADD(ecran%,MUL(curs&,1280))
      BMOVE t%,ADD(t%,1280),SUB(ADD(ecran%,26880),t%)
    ENDIF
    prg$=MID$(prg$,1,MUL(ADD(edit&,curs&),40))+SPACE$(38)+"! "+MID$(prg$,ADD(MUL(ADD(edit&,curs&),40),1))
    PRINT AT(1,ADD(curs&,1));SPACE$(38)
    INC max&
    curs
  ENDIF
CASE 127
  IF AND(max&>FALSE,DIV(LEN(prg$),40)<>ADD(edit&,curs&))
    curs
    IF curs&<>21
      t%=ADD(ecran%,MUL(curs&,1280))
      BMOVE ADD(t%,1280),t%,SUB(ADD(ecran%,26880),t%)
    ENDIF
    DEC max&
    prg$=MID$(prg$,1,MUL(ADD(edit&,curs&),40))+MID$(prg$,ADD(MUL(ADD(edit&,curs&),40),41))
    IF max&<ADD(edit&,21)
      PRINT AT(1,ADD(SUB(max&,edit&),2));SPACE$(38);
    ELSE
      PRINT AT(1,22);MID$(prg$,ADD(MUL(edit&,40),841),38)
    ENDIF
    curs&=MIN(curs&,SUB(max&,edit&))
    curs
  ENDIF
CASE 205,32,13
  curs
  a$=MID$(prg$,ADD(MUL(ADD(edit&,curs&),40),1),38)
  ~@input(1,ADD(curs&,1),TRUE,37,a$)
  FOR t&=1 TO LEN(a$)
    IF MID$(a$,t&,1)="!"
      MID$(a$,t&,1)=" "
    ENDIF
  NEXT t&
  a$=TRIM$(a$)
  MID$(prg$,ADD(MUL(ADD(edit&,curs&),40),1),40)=a$+SPACE$(SUB(38,LEN(a$)))+"! "
  affprg
  curs
CASE 187
  appx(FALSE,180,79,189)
  vide$="DEFAULT.APR"
  spath$=@form_path$(spath$,"APR")
  select(lst%,spath$,vide$)
  lksauvph
  IF vide$<>""
    OPEN "o",#1,fich$
    OUT% #1,CVL("APRG")
    BPUT #1,V:prg$,LEN(prg$)
    CLOSE #1
  ENDIF
  resx(FALSE,180,79,189)
CASE 188
  appx(FALSE,190,79,199)
  vide$="DEFAULT.APR"
  cpath$=@form_path$(cpath$,"APR")
  select(lst%,cpath$,vide$)
  lkchargph
  IF vide$<>""
    OPEN "i",#1,fich$
    IF INP%(#1)=CVL("APRG")
      t&=SUB(LOF(#1),4)
      prg$=SPACE$(t&)
      BGET #1,V:prg$,t&
      max&=MAX(DIV(SUB(LEN(prg$),1),40),FALSE)
      edit&=FALSE
      curs&=FALSE
      affprg
      curs
    ELSE
      warningfich(@rd$(79,FALSE))
    ENDIF
    CLOSE #1
  ENDIF
  resx(FALSE,190,79,199)
CASE 189
  appx(80,180,159,189)
  al&=@alt(TRUE,TRUE,@rd$(78,FALSE),@rd$(10,FALSE),1)
  IF al&=FALSE
    prg$="END"+SPACE$(36)+"!"
    curs&=FALSE
    edit&=FALSE
    max&=1
    affprg
    curs
  ENDIF
  resx(80,180,159,189)
ENDSELECT
ENDIF
UNTIL OR(tch&=196,tch&=225)
inter_on
RETURN tch&=196
ENDFUNC
> PROCEDURE affprg                        ! R‚affiche la page courante du prg (li‚ … edit_buffer)
LOCAL a&,t&
eff(ecran%,28800)
a&=ADD(MUL(edit&,40),1)
FOR t&=1 TO 22
PRINT AT(1,t&);MID$(prg$,a&,38)
ADD a&,40
EXIT IF a&>=LEN(prg$)
NEXT t&
CLR a&,t&
RETURN
> PROCEDURE curs                          ! Affiche curseur (d‚pend de edit_prg)
arec(FALSE,SHL&(curs&,3),319,ADD(SHL&(curs&,3),7),15,2)
RETURN
'
' GESTION DES PARAMETRAGES
'
> PROCEDURE param
SELECT otl&
CASE 1,2,7 TO 11
IF fld&
icone(FALSE,175,191,199,36)
icone(200,175,258,199,79)
icone(260,175,319,199,80)
ELSE
tabicone(8,174,17,8,19,FALSE,15,FALSE,42)
tabicone(8,184,17,13,19,FALSE,2,FALSE,39)
tabicone(255,184,17,13,19,FALSE,2,FALSE,23)
tabicone(65,184,61,13,63,FALSE,2,FALSE,77)
ENDIF
CASE 3
tabicone(2,174,52,10,55,FALSE,2,FALSE,82)
tabicone(2,186,53,10,55,FALSE,2,FALSE,83)
tabicone(170,174,47,10,49,FALSE,1,FALSE,84)
icone(270,186,317,196,61)
icone(170,186,217,196,85)
icone(219,186,266,196,87)
CASE 5
cpt(200,190,1,20,FALSE,2,tempaero&)
icone(FALSE,190,98,199,47)
icone(100,190,198,199,48)
tabicone(FALSE,171,19,10,20,FALSE,15,FALSE,49)
CASE 6
icone(FALSE,175,191,192,44)
icone(200,175,258,192,81)
icone(260,175,319,192,73)
CASE 12
tabicone(2,174,77,13,79,15,4,1,68)
cpt(81,187,4,32,FALSE,2,tsiz&)
CASE 14
tabicone(FALSE,174,24,11,26,FALSE,11,FALSE,17)
tabicone(2,187,77,10,79,FALSE,3,FALSE,18)
CASE 15
tabicone(FALSE,188,19,11,20,FALSE,15,FALSE,12)
ENDSELECT
norm
atm0
RETURN
> PROCEDURE 36                            ! TRAMES
xtram&=SHR&(x&,4)
RETURN
> PROCEDURE 79
plein&=NOT plein&
RETURN
> PROCEDURE 80
fill&=NOT fill&
RETURN
> PROCEDURE 23                            ! LIGNES
endli&=t&
RETURN
> PROCEDURE 39
debli&=t&
RETURN
> PROCEDURE 42
htline&=t&
RETURN
> PROCEDURE 77
LOCAL x1&,bl&
x1&=t&
IF k&=1
line&=x1&
ELSE IF x1&
DEC x1&
def1
@hide
FOR bl&=FALSE TO 15
deic(MUL(bl&,20),150,ADD(MUL(bl&,20),19),170,-BTST(line%(x1&),SUB(15,bl&)))
NEXT bl&
atm0
@showm
REPEAT
ms2
tabicone(FALSE,150,19,20,20,FALSE,15,FALSE,56)
icone(FALSE,FALSE,319,150,10)
icone(FALSE,170,319,199,10)
UNTIL ext&
ext&=FALSE
ENDIF
atm0
CLR k&,x1&,bl&
RETURN
> PROCEDURE 56
IF ODD(k&)
line%(x1&)=BSET(line%(x1&),SUB(15,t&))
ELSE
line%(x1&)=BCLR(line%(x1&),SUB(15,t&))
ENDIF
@hide
arec(ADD(xh&,1),ADD(yh&,1),SUB(xb&,1),SUB(yb&,1),-ODD(k&),FALSE)
@showm
affpar
atm0
RETURN
> PROCEDURE 44                            ! PINCEAU
eff(ADD(ecran%,30720),1120)
pinc&=SHR&(x&,4)
RETURN
> PROCEDURE 81
pincmono&=NOT pincmono&
RETURN
> PROCEDURE 47                            ! AEROGRAPHE
multia&=NOT multia&
RETURN
> PROCEDURE 48
forme&=NOT forme&
RETURN
> PROCEDURE 49
aero&(t&)=NOT aero&(t&)
RETURN
> PROCEDURE 73
half&=NOT half&
RETURN
> PROCEDURE crap                          ! REMPLACE COULEURS
LOCAL aux&,aux2&,c&
aux&=MUL(t&,20)
@hide
setmo(MUL(ADD(crap&(t&),1),19),195)
REPEAT
ms2
aux2&=SUB(DIV(x&,19),1)
crap&(t&)=aux2&
c&=aux2&
ppal(c&)
IF aux2&=TRUE
ATEXT ADD(aux&,5),190,1,"-"
ELSE
arec(ADD(aux&,1),189,ADD(aux&,17),198,aux2&,FALSE)
ENDIF
move2
UNTIL k&=FALSE
@showm
setmo(ADD(aux&,5),195)
CLR aux&,aux2&,c&
RETURN
> PROCEDURE 17                            ! ENTOURE AUTOMATIQUEMENT
ent&=t&
RETURN
> PROCEDURE 18
SELECT t&
CASE 0
sens1&=NOT sens1&
CASE 1
sens2&=NOT sens2&
CASE 2
sens3&=NOT sens3&
DEFAULT
sens4&=NOT sens4&
ENDSELECT
RETURN
> PROCEDURE 82                            ! BLOCKs
grp&=t&
reaf(FALSE)
RETURN
> PROCEDURE 83
lasso&=t&
RETURN
> PROCEDURE 84
take&=-t&
RETURN
> PROCEDURE red
appx(xh&,yh&,xb&,yb&)
BMOVE blk%,ado%,32000
eff(blk%,32000)
RC_COPY ado%,FALSE,FALSE,lgb&,htb& TO blk%,FALSE,FALSE
redim(blk%)
RC_COPY blk%,x1&,y1&,lgb&,htb& TO blk%,FALSE,FALSE
norm
mask
IF open&
ADD sx&,x1&
ADD sy&,y1&
reaf(TRUE)
ENDIF
RETURN
> PROCEDURE 68                            ! TEXTE
LOCAL j&
j&=ADD(t&,SHL&(i&,2))
SELECT j&
CASE 0,1,3
styl&=BCHG(styl&,j&)
DEFAULT
IF NOT BTST(styl&,SUB(6,j&))
styl&=BCHG(styl&,j&)
ENDIF
ENDSELECT
CLR j&
RETURN
'
' GESTION PANNEAU ICONES & AFFICHAGE DES ECRANS DE PARAMETRAGE
'
> PROCEDURE stl
LOCAL al&
p&=TRUE
aux&=ADD(t&,MUL(i&,14))
IF aux&<17
IF AND(otl&<>3,aux&=3)
IF open&
  reaf(TRUE)
ELSE
  mask
ENDIF
ELSE IF AND(AND(otl&=3,aux&<>3),open&)
reput
ENDIF
ENDIF
SELECT ADD(MUL(SUB(MIN(k&,2),1),100),aux&)
CASE 0,1,3 TO 6,100,101,103 TO 106,14 TO 15,114 TO 115
fld&=FALSE
CASE 2,102,107 TO 110
fld&=TRUE
CASE 17 TO 27,113,117 TO 127
p&=FALSE
IF aux&<24
appx(xh&,yh&,xb&,yb&)
ENDIF
SELECT aux&
CASE 17 TO 23
ON SUB(aux&,16) GOSUB apac,full,scim,ed_tr,ed_tr,ec,mouse
reput
CASE 13
IF protec&(ec&)
  al&=SUB(@alt(TRUE,112,@rd$(18,FALSE),@rd$(31,FALSE),1),1)
ELSE
  al&=TRUE
ENDIF
IF al&
  BMOVE ec%(ec&),undo%,32000
  IF pane2&
    eff(ADD(ec%(ec&),MUL(ordo&,160)),16000)
  ELSE
    eff(ec%(ec&),32000)
  ENDIF
  reput
ENDIF
CASE 24 TO 26
IF k&=1
  cursec&=ADD(AND(y&>154,3),SUB(aux&,24))
  changec
ELSE
  a&=ADD(AND(y&>154,3),SUB(aux&,24))
  @hide
  apps(ADD(MUL(MOD(a&,3),22),222),ADD(141,MUL(DIV(a&,3),14)),ADD(MUL(MOD(a&,3),22),242),ADD(MUL(DIV(a&,3),14),153),4)
  @showm
  atm0
  IF @btc(2)
    vide$=""
    nec&(a&)=MAX(MIN(SUB(@input(1,1,FALSE,1,vide$),1),nbec&),FALSE)
    ec&=nec&(cursec&)
    IF cursec&=a&
      reput
    ENDIF
    retake
  ELSE
    REPEAT
      ms2
    UNTIL k&
    IF AND(AND(x&>221,y&>140),AND(x&<286,y&<169))
      b&=ADD(AND(y&>154,3),DIV(SUB(x&,220),22))
      IF protec&(nec&(b&))
        al&=@alt(TRUE,112,@rd$(18,FALSE),@rd$(38,FALSE),1)
      ELSE
        al&=FALSE
      ENDIF
      IF al&=FALSE
        BMOVE ec%(nec&(a&)),ec%(nec&(b&)),32000
        BMOVE V:rvb&(FALSE,nec&(a&)),V:rvb&(FALSE,nec&(b&)),32
        IF ec&=nec&(b&)
          reput
        ENDIF
      ENDIF
    ENDIF
  ENDIF
  atm0
  k&=FALSE
ENDIF
CASE 27
pane2&=NOT pane2&
retake
ENDSELECT
IF otl&=3
reaf(TRUE)
ENDIF
IF aux&<24
resx(xh&,yh&,xb&,yb&)
ENDIF
DEFAULT
fld&=FALSE
ENDSELECT
IF p&
otl&=aux&
ENDIF
norm
normpal
k&=TRUE
atm0
k&=FALSE
CLR al&
RETURN
> PROCEDURE affpar
LOCAL aux&,t&,state&
IF curson&
state&=TRUE
@hide
ENDIF
def1
SELECT otl&
CASE 1,2,7 TO 10,11
IF fld&
eff(ADD(ecran%,27360),4640)
deic(260,175,319,199,FALSE)
DEFFILL 1,4
FOR aux&=FALSE TO 11
  DEFFILL ,tram$(aux&)
  BOX SHL&(aux&,4),175,ADD(SHL&(aux&,4),16),199
  PBOX ADD(SHL&(aux&,4),1),176,ADD(SHL&(aux&,4),15),198
NEXT aux&
defill
PBOX 201,176,257,198
BOX 200,175,258,199
ATEXT 264,185,FALSE,@rd$(51,ADD(1,fill&))
ELSE
dec(3)
appicone(8,184,17,13,19,FALSE,debli&,FALSE)
appicone(255,184,17,13,19,FALSE,endli&,FALSE)
appicone(8,174,17,8,19,FALSE,htline&,FALSE)
aux&=ADD(MUL(line&,63),65)
apps(aux&,184,ADD(aux&,61),197,4)
COLOR 2
IF htline&>7
  DEFLINE 1,15,FALSE,FALSE
ELSE
  DEFLINE FALSE,ADD(AND(MUL(htline&,2),htline&>2),AND(htline&<3,ADD(MUL(htline&,2),1))),FALSE,FALSE
ENDIF
CLIP 66,185,125,195
LINE 66,190,125,190
totalc
def1
ALINE 129,190,188,190,1,line%(FALSE),FALSE
ALINE 192,190,250,190,1,line%(1),FALSE
ENDIF
CASE 3
dec(2)
appicone(2,174,53,10,55,FALSE,grp&,FALSE)
appicone(2,186,53,10,55,FALSE,lasso&,FALSE)
tex2(271,181,STR$(lgb&)+"/"+STR$(htb&))
IF take&
appx(219,174,266,184)
ELSE
appx(170,174,217,184)
ENDIF
CASE 5
eff(ADD(ecran%,27360),4640)
dcpt(200,190,tempaero&,"")
deic(FALSE,190,98,199,FALSE)
deic(100,190,198,199,FALSE)
BMOVE pan%,ADD(ecran%,27520),1600
FOR aux&=FALSE TO 15
IF aero&(aux&)
  ATEXT ADD(MUL(aux&,20),8),183,FALSE,CHR$(1)
ENDIF
NEXT aux&
ATEXT 10,193,FALSE,@rd$(51,-multia&)
ATEXT 110,193,FALSE,@rd$(52,-NOT forme&)
CASE 15
eff(ADD(ecran%,27360),4640)
BMOVE pan%,ADD(ecran%,27520),1600
COLOR 1
def1
FOR t&=FALSE TO 15
aux&=MUL(t&,20)
BOX aux&,188,ADD(aux&,18),199
IF crap&(t&)=TRUE
  ATEXT ADD(aux&,5),190,1,"-"
ELSE
  arec(ADD(aux&,1),189,ADD(aux&,17),198,crap&(t&),FALSE)
ENDIF
NEXT t&
CASE 6
eff(ADD(ecran%,27360),4640)
COLOR 1
DEFFILL 1,4
FOR aux&=FALSE TO 11
DEFFILL ,tram$(ADD(12,aux&))
BOX SHL&(aux&,4),175,ADD(SHL&(aux&,4),16),192
PBOX ADD(SHL&(aux&,4),1),176,ADD(SHL&(aux&,4),15),191
NEXT aux&
ATEXT ADD(SHL(pinc&,4),4),194,FALSE,CHR$(1)
deic(200,175,258,192,FALSE)
deic(260,175,319,192,FALSE)
ATEXT 263,182,FALSE,@rd$(53,ADD(half&,1))
ATEXT 203,182,FALSE,@rd$(51,ADD(pincmono&,1))
CASE 12
dec(1)
FOR aux&=FALSE TO 4
IF BTST(styl&,aux&)
  appicone(2,174,77,10,79,13,AND(aux&,3),SHR&(aux&,2))
ENDIF
NEXT aux&
ATEXT 113,190,FALSE,STR$(tsiz&)
CASE 14
dec(FALSE)
appicone(4,174,24,11,26,FALSE,ent&,FALSE)
IF sens1&
appx(2,187,79,197)
ENDIF
IF sens2&
appx(81,187,158,197)
ENDIF
IF sens3&
appx(160,187,237,197)
ENDIF
IF sens4&
appx(239,187,316,197)
ENDIF
DEFAULT
eff(ADD(ecran%,27360),4640)
ENDSELECT
IF state&
@showm
ENDIF
CLR aux&,t&,state&
RETURN
> PROCEDURE changec
ec&=nec&(cursec&)
reput
IF pan&
normpal
ELSE
raster(MKL$(V:rvb&(FALSE,ec&)))
ENDIF
note(FALSE)
RETURN
> PROCEDURE ppan
~C:codes%(L:pan1%,L:ADD(ecran%,17600),W:60)
RETURN
> PROCEDURE retpan
i%=ADD(pan1%,2480)
FOR t%=ADD(ecran%,22560) TO ADD(ecran%,27352) STEP 8
LONG{i%}=LONG{t%}
ADD i%,4
NEXT t%
RETURN
> PROCEDURE dec(k&)
HLINE FALSE,171,319,FALSE,FALSE,adr%,1
~C:decom%(L:ADD(param%,MUL(k&,2240)),L:ADD(ecran%,27520))
CLR k&
RETURN
'
' FULL
'
> PROCEDURE tfull(t&)             ! Affiche les 4 ecrans en normal screen
IF ADD(fcx&(FALSE),delx&)>319
fcx&(FALSE)=SUB(319,delx&)
ENDIF
IF ADD(fcy&(FALSE),dely&)>199
fcy&(FALSE)=SUB(199,dely&)
ENDIF
IF fcx&(1)>delx&
fcx&(1)=delx&
ENDIF
IF ADD(fcy&(1),dely&)>199
fcy&(1)=SUB(199,dely&)
ENDIF
IF ADD(fcx&(2),delx&)>319
fcx&(2)=SUB(319,delx&)
ENDIF
IF fcy&(2)>dely&
fcy&(2)=dely&
ENDIF
IF fcx&(3)>delx&
fcx&(3)=delx&
ENDIF
IF fcy&(3)>dely&
fcy&(3)=dely&
ENDIF
@hide
RC_COPY ec%(full&(FALSE)),fcx&(FALSE),fcy&(FALSE),delx&,dely& TO ecran%,FALSE,FALSE
RC_COPY ec%(full&(1)),fcx&(1),fcy&(1),SUB(320,delx&),dely& TO ecran%,delx&,FALSE
RC_COPY ec%(full&(2)),fcx&(2),fcy&(2),delx&,SUB(200,dely&) TO ecran%,FALSE,dely&
RC_COPY ec%(full&(3)),fcx&(3),fcy&(3),SUB(320,delx&),SUB(200,dely&) TO ecran%,delx&,dely&
@showm
calcfull
@hide
PRINT AT(2,2);"X:";larg0&;
PRINT AT(2,3);"Y:";ht0&;
PRINT AT(2,4);ADD(full&(FALSE),1);
PRINT AT(33,2);"X:";larg1&;
PRINT AT(33,3);"Y:";ht1&;
PRINT AT(33,4);ADD(full&(1),1);
PRINT AT(2,22);"X:";larg2&;
PRINT AT(2,23);"Y:";ht2&;
PRINT AT(2,24);ADD(full&(2),1);
PRINT AT(33,22);"X:";larg3&;
PRINT AT(33,23);"Y:";ht3&;
PRINT AT(33,24);ADD(full&(3),1);
IF t&
ALINE delx&,FALSE,delx&,199,15,65535,2
HLINE FALSE,dely&,319,15,2,adr%,1
ENDIF
@showm
CLR t&
RETURN
> PROCEDURE calcfull              ! Calcule le fenetrage selon decalages ecran
newdelx&=ADD(delx&,MAX(fcx&(FALSE),fcx&(2)))
newdely&=ADD(dely&,MAX(fcy&(FALSE),fcy&(1)))
IF fcx&(2)>fcx&(FALSE)
offx2&=FALSE
offx0&=SUB(fcx&(2),fcx&(FALSE))
ELSE
offx0&=FALSE
offx2&=SUB(fcx&(FALSE),fcx&(2))
ENDIF
larg0&=ADD(delx&,fcx&(FALSE))
larg2&=ADD(delx&,fcx&(2))
ht0&=ADD(dely&,fcy&(FALSE))
ht1&=ADD(dely&,fcy&(1))
IF fcy&(1)>fcy&(FALSE)
offy1&=FALSE
offy0&=SUB(fcy&(1),fcy&(FALSE))
ELSE
offy0&=FALSE
offy1&=SUB(fcy&(FALSE),fcy&(1))
ENDIF
IF SUB(ADD(200,newdely&),fcy&(2))<274
ht2&=SUB(200,fcy&(2))
ELSE
ht2&=SUB(274,newdely&)
ENDIF
IF SUB(ADD(200,newdely&),fcy&(3))<274
ht3&=SUB(200,fcy&(3))
ELSE
ht3&=SUB(274,newdely&)
ENDIF
IF ADD(SUB(320,fcx&(3)),newdelx&)<448
larg3&=SUB(320,fcx&(3))
ELSE
larg3&=SUB(448,newdelx&)
ENDIF
IF ADD(SUB(320,fcx&(1)),newdelx&)<448
larg1&=SUB(320,fcx&(1))
ELSE
larg1&=SUB(448,newdelx&)
ENDIF
RETURN
> PROCEDURE consfull(base%,mode&) ! Calcule image fullscreen
mouseoff
calcfull
IF NOT mode&
eff(base%,63020)
ENDIF
IF mode&
FOR i&=FALSE TO SUB(ht0&,1)
RC_COPY ADD(ado%,MUL(ADD(i&,offy0&),230)),offx0&,FALSE,larg0&,1 TO ec%(full&(FALSE)),FALSE,i&
NEXT i&
FOR i&=FALSE TO SUB(ht1&,1)
RC_COPY ADD(ado%,MUL(ADD(i&,offy1&),230)),newdelx&,FALSE,larg1&,1 TO ec%(full&(1)),fcx&(1),i&
NEXT i&
FOR i&=FALSE TO SUB(ht2&,1)
RC_COPY ADD(ado%,MUL(ADD(i&,newdely&),230)),offx2&,FALSE,larg2&,1 TO ec%(full&(2)),FALSE,ADD(fcy&(2),i&)
NEXT i&
FOR i&=FALSE TO SUB(ht3&,1)
RC_COPY ADD(ado%,MUL(ADD(i&,newdely&),230)),newdelx&,FALSE,larg3&,1 TO ec%(full&(3)),fcx&(3),ADD(fcy&(3),i&)
NEXT i&
ELSE
FOR i&=FALSE TO SUB(ht0&,1)
RC_COPY ec%(full&(FALSE)),FALSE,i&,larg0&,1 TO ADD(base%,MUL(ADD(i&,offy0&),230)),offx0&,FALSE
NEXT i&
FOR i&=FALSE TO SUB(ht1&,1)
RC_COPY ec%(full&(1)),fcx&(1),i&,larg1&,1 TO ADD(base%,MUL(ADD(i&,offy1&),230)),newdelx&,FALSE
NEXT i&
FOR i&=FALSE TO SUB(ht2&,1)
RC_COPY ec%(full&(2)),FALSE,ADD(fcy&(2),i&),larg2&,1 TO ADD(base%,MUL(ADD(i&,newdely&),230)),offx2&,FALSE
NEXT i&
FOR i&=FALSE TO SUB(ht3&,1)
RC_COPY ec%(full&(3)),fcx&(3),ADD(fcy&(3),i&),larg3&,1 TO ADD(base%,MUL(ADD(i&,newdely&),230)),newdelx&,FALSE
NEXT i&
ENDIF
mouseon
CLR base%,mode&
RETURN
> PROCEDURE full                  ! Fullscreen
LOCAL a$
IF TT?
atm0
~@alt(TRUE,112,@rd$(77,FALSE),"    Ok    ",FALSE)
ELSE IF nbec&<3
atm0
~@alt(TRUE,112,@rd$(39,FALSE),"    Ok    ",FALSE)
ELSE
raster(MKL$(V:rvb&(FALSE,full&(FALSE))))
IF k&=1
a%=ADD(AND(ado%,&HFFFFFF00),256)
eff(a%,63500)
consfull(ADD(a%,196),FALSE)
phy(a%)
b&=PEEK(&HFF820A)
IF C:tstmega%()
  SPOKE &HFFFF8E21,FALSE
ENDIF
@vs
a$=SPACE$(64)
bmov2(V:rvb&(FALSE,ec&),V:a$,ADD(V:a$,32))
~C:over%(L:V:a$)
SPOKE &HFF820A,b&
phy(ecran%)
IF C:tstmega%()
  SPOKE &HFFFF8E21,3
ENDIF
ELSE
@hide
eff(ecran%,32000)
@showm
tfull(TRUE)
atm0
necho
REPEAT
  ms2
  IF k&=1
    x1&=x&
    y1&=y&
    setmo(delx&,dely&)
    REPEAT
      ms
      delx&=x&
      dely&=y&
      tfull(NOT @btc(2))
    UNTIL k&=FALSE
    tfull(TRUE)
    setmo(x1&,y1&)
  ENDIF
  IF k&=2
    icone(FALSE,FALSE,SUB(delx&,1),SUB(dely&,1),88)
    icone(delx&,FALSE,319,SUB(dely&,1),89)
    icone(FALSE,dely&,SUB(delx&,1),199,90)
    icone(delx&,dely&,319,199,91)
  ENDIF
  IF @btc(2)
    tfull(FALSE)
    k&=CARD{ADD(table%,8)}
    REPEAT
    UNTIL OR(OR(NOT @btc(2),k&<>CARD{ADD(table%,8)}),@inp_)
    tfull(TRUE)
  ENDIF
  IF @inp_
    tch&=@inp
    SELECT act&(tch&)
    CASE 11 TO 16
      @hide
      ALINE FALSE,182,319,182,15,65535,FALSE
      ALINE FALSE,183,319,183,FALSE,65535,FALSE
      PRINT AT(1,24);@rd$(82,FALSE)
      PRINT AT(1,25);@rd$(82,1);SUB(act&(tch&),10);
      vide$=""
      full&(SUB(act&(tch&),11))=MAX(MIN(SUB(@input(1,1,FALSE,1,vide$),1),nbec&),FALSE)
      tfull(TRUE)
      raster(MKL$(V:rvb&(FALSE,full&(FALSE))))
      @showm
    DEFAULT
      ext&=TRUE
    ENDSELECT
  ENDIF
UNTIL ext&
ext&=FALSE
necho
ENDIF
ENDIF
CLR a$
RETURN
> PROCEDURE 88                    ! Decalage d'1 ecran
j&=SUB(pcd&,88)
x1&=x&
y1&=y&
setmo(SUB(319,fcx&(j&)),SUB(199,fcy&(j&)))
tfull(FALSE)
a&=ADD(SUB(xb&,xh&),1)
b&=ADD(SUB(yb&,yh&),1)
REPEAT
ms
x2&=SUB(319,x&)
y2&=SUB(199,y&)
IF ADD(x2&,a&)>319
x2&=SUB(320,a&)
setmo(SUB(319,x2&),y&)
ENDIF
IF ADD(y2&,b&)>199
y2&=SUB(200,b&)
setmo(x&,SUB(199,y2&))
ENDIF
fcx&(j&)=x2&
fcy&(j&)=y2&
calcfull
@hide
RC_COPY ec%(full&(j&)),x2&,y2&,a&,b& TO ecran%,xh&,yh&
SELECT j&
CASE 0
PRINT AT(2,2);"X:";larg0&;
PRINT AT(2,3);"Y:";ht0&;
PRINT AT(2,4);ADD(full&(FALSE),1);
CASE 1
PRINT AT(33,2);"X:";larg1&;
PRINT AT(33,3);"Y:";ht1&;
PRINT AT(33,4);ADD(full&(1),1);
CASE 2
PRINT AT(2,22);"X:";larg2&;
PRINT AT(2,23);"Y:";ht2&;
PRINT AT(2,24);ADD(full&(2),1);
DEFAULT
PRINT AT(33,22);"X:";larg3&;
PRINT AT(33,23);"Y:";ht3&;
PRINT AT(33,24);ADD(full&(3),1);
ENDSELECT
@showm
UNTIL k&=FALSE
tfull(TRUE)
setmo(x1&,y1&)
RETURN
'
' SETCOLOR & COLOR
'
> PROCEDURE cl                    ! Proc‚dure testant la barre de couleur iconique
IF k&=2                       ! Si touche droite:
IF OR(t&=endc&,t&=debc&)    !   Si flŠche
col(t&)                   !     Proc‚dure move flŠche
ELSE                        !   Sinon
setco(t&,TRUE)            !     On paramŠtre la couleur
ENDIF                       !
ELSE                          ! Sinon (flŠche gauche)
c&=t&                       !   on fixe la couleur courante
ENDIF                         ! Finsi
norm                          ! R‚affiche le panneau d'icones & l'image
atm0                          ! Attend que la touche soit relach‚e
k&=FALSE                      ! Force variable touche … z‚ro
RETURN
> PROCEDURE setco(cursc&,mode&)   ! Proc‚dure de param‚trage des couleurs
LOCAL pal$,a&,j&,r&,aux&,aux2&,aux3&
pal$=SPACE$(32)
aux&=DIV(290,ADD(suppal&,1))
r&=SUB(aux&,3)
BMOVE old%,V:pal$,32
'
setcopal
@hide
reput
eff(ADD(ecran%,27360),4640)
BMOVE pan%,ADD(ecran%,16000),1600
deic2(FALSE,168,319,198)
deic2(FALSE,80,319,99)
defx
GRAPHMODE 2
FOR a&=FALSE TO 4
FOR j&=FALSE TO 1
resicone(5,173,58,8,62,13,a&,j&)
TEXT ADD(8,MUL(a&,62)),ADD(179,MUL(j&,13)),@rd$(4,ADD(ADD(a&,MUL(5,j&)),5))
NEXT j&
resicone(5,83,58,8,62,FALSE,a&,FALSE)
TEXT ADD(8,MUL(a&,62)),89,@rd$(4,a&)
NEXT a&
GRAPHMODE 1
ppal(cursc&)
cltrac
@showm
'
REPEAT
ms2
tabicone(FALSE,100,19,9,20,FALSE,15,FALSE,25)
tabicone(5,173,58,8,62,13,4,1,15)
tabicone(5,83,58,8,62,FALSE,4,FALSE,75)
icone(FALSE,110,319,167,74)
icone(FALSE,199,319,199,10)
icone(FALSE,FALSE,319,79,10)
IF @inp_
tch&=@inp
SELECT act&(tch&)
CASE 0
  FOR a&=FALSE TO 15
    SWAP undo&(a&),rvb&(a&,ec&)
  NEXT a&
  cltrac
  setcopal
CASE 44 TO 59
  cursc&=SUB(act&(tch&),44)
  ppal(cursc&)
  cltrac
CASE 61
  ext&=TRUE
ENDSELECT
ENDIF
UNTIL ext&
atm0
normpal
IF mode&
norm
reput
IF otl&=3
reaf(TRUE)
ENDIF
ENDIF
'
CLR pal$,r&,aux&,aux2&,cursc&,k&,ext&,a&,j&,mode&
RETURN
> PROCEDURE oldoverdascrine       ! S‚lection en mode superpalette
LOCAL t&,i&,j&,r&,v&,b&,sauv$,sauv2&,sauv2$,a%,a2%,a3%,a4%,t%,i%,coul%,coul2%
IF suppal&=30
~@alt(TRUE,112,@rd$(63,FALSE),"   Ok   ",FALSE)
ELSE
IF C:tstmega%()
SPOKE &HFFFF8E21,FALSE
ENDIF
sauv$=SPACE$(68)                    ! Espaces pour sauvegarde palette
sauv2$=SPACE$(68)
IF blitp&                           ! Blitter off
~XBIOS(64,BCLR(XBIOS(64,TRUE),FALSE))
ENDIF
atm0
@hide
BMOVE ecran%,ado%,32000
eff(lst%,32000)
raster(MKL$(lst%))
a%=ADD(lst%,68)
a2%=ADD(lst%,8068)
a3%=ADD(lst%,20000)
a4%=ADD(lst%,26000)
t%=ADD(lst%,30000)
FOR t&=FALSE TO 15
PRINT AT(1,1);t&;" ";
FOR i&=FALSE TO 6
  CARD{t%}=CARD{ADD(ecran%,MUL(i&,160))}
  ADD t%,2
NEXT i&
ADD t%,2
NEXT t&
eff(ecran%,32000)
ATEXT FALSE,1,1,"R:    V:    B:"
SELECT suppal&
CASE 7
ADD a%,2
FOR j&=FALSE TO 7
  FOR i&=FALSE TO 7
    FOR t&=FALSE TO 7
      CARD{a%}=ADD(ADD(SHL(j&,8),SHL(i&,4)),t&)
      ADD a%,2
    NEXT t&
    ADD a%,12
    CARD{a%}=1911
    ADD a%,2
    CARD{a%}=3
    ADD a%,4
  NEXT i&
NEXT j&
FOR t&=FALSE TO 319
  CARD{a3%}=DIV(t&,40)
  ADD a3%,2
NEXT t&
FOR t&=FALSE TO 199
  CARD{a4%}=DIV(MOD(t&,24),3)
  ADD a4%,2
  CARD{a4%}=DIV(t&,24)
  ADD a4%,2
NEXT t&
FOR t&=FALSE TO 7
  arec(MUL(t&,40),8,ADD(MUL(t&,40),39),199,ADD(t&,1),FALSE)
NEXT t&
CASE 14
FOR j&=FALSE TO 14
  r&=SHL(SHR(j&,1),8)
  r2&=ADD(r&,AND(ODD(j&),256))
  FOR i&=FALSE TO 14
    v&=SHL(SHR(i&,1),4)
    v2&=ADD(v&,AND(ODD(i&),16))
    CARD{a%}=FALSE
    CARD{a2%}=FALSE
    ADD a%,2
    ADD a2%,2
    FOR t&=FALSE TO 14
      IF AND(AND(BTST(j&,FALSE),BTST(t&,FALSE)),NOT BTST(i&,FALSE))
        CARD{a%}=ADD(ADD(r2&,v&),SHR(t&,1))
        CARD{a2%}=ADD(ADD(r&,v&),SUB(SHR(t&,1),ODD(t&)))
      ELSE
        CARD{a%}=ADD(ADD(r&,v2&),SHR(t&,1))
        CARD{a2%}=ADD(ADD(r2&,v&),SUB(SHR(t&,1),ODD(t&)))
      ENDIF
      ADD a%,2
      ADD a2%,2
    NEXT t&
    CARD{a%}=1
    CARD{a2%}=1
    ADD a%,2
    ADD a2%,2
  NEXT i&
NEXT j&
FOR t&=FALSE TO 319
  CARD{a3%}=MIN(DIV(t&,21),14)
  ADD a3%,2
NEXT t&
FOR t&=FALSE TO 225
  CARD{a4%}=MOD(t&,15)
  ADD a4%,2
  CARD{a4%}=DIV(t&,15)
  ADD a4%,2
NEXT t&
FOR t&=FALSE TO 14
  arec(MUL(t&,21),8,ADD(MUL(t&,21),20),199,ADD(t&,1),FALSE)
NEXT t&
arec(315,8,319,199,15,FALSE)
CASE 15
FOR j&=FALSE TO 15
  r&=OR(SHL(SHR(j&,1),8),AND(ODD(j&),&H800))
  FOR i&=FALSE TO 15
    v&=OR(OR(SHL(SHR(i&,1),4),AND(ODD(i&),&H80)),r&)
    FOR t&=FALSE TO 15
      CARD{a%}=OR(v&,OR(SHR(t&,1),AND(ODD(t&),8)))
      ADD a%,2
    NEXT t&
    CARD{a%}=1
    ADD a%,2
  NEXT i&
NEXT j&
FOR t&=FALSE TO 319
  CARD{a3%}=DIV(t&,20)
  ADD a3%,2
NEXT t&
FOR t&=FALSE TO 255
  CARD{a4%}=AND(t&,15)
  ADD a4%,2
  CARD{a4%}=SHR(t&,4)
  ADD a4%,2
NEXT t&
FOR t&=FALSE TO 15
  arec(MUL(t&,20),8,ADD(MUL(t&,20),19),199,t&,FALSE)
NEXT t&
ENDSELECT
@showm
j&=FALSE                                    ! Pointeur scroll en nb de lignes
raster(MKL$(old%)+MKI$(1)+MKL$(old%)+MKI$(7)+MKL$(old%)+MKI$(240)) ! Construit curseur haut
CARD{ADD(raster%,2)}=&H700
CARD{ADD(raster%,4)}=&H70
CARD{ADD(raster%,8)}=&H137
CARD{ADD(raster%,36)}=&H700
CARD{ADD(raster%,38)}=&H70
CARD{ADD(raster%,42)}=&H137
BMOVE raster%,lst%,68                       ! Init 1er curseur haut
a%=lst%                                     ! 1er pointeur rasters
a3%=ADD(lst%,20000)
a4%=ADD(lst%,26000)
sauv2&=INT{ADD(a%,6596)}                    ! Sauve curseur bas
CARD{ADD(a%,6596)}=FALSE                    ! Curseur bas
{ADD(table%,60)}=lst%                       ! 1er pointeur raster
IF suppal&=14
a2%=ADD(lst%,8000)                        ! 2em pointeur raster (scroll)
BMOVE raster%,a2%,68                      ! Init 2em Curseur coul haut
{ADD(table%,64)}=a2%                      ! 2em Pointeur raster
ENDIF
REPEAT
move2
ms
@vs
IF suppal&<>7
  IF AND(y&=FALSE,j&>FALSE)
    @vs
    REPEAT
      @vs
      ms
      DEC j&
      REPEAT
      UNTIL ADD(ADD(PEEK(&HFF8209),SHL(PEEK(&HFF8207),8)),SWAP(PEEK(&HFF8205)))>=ADD(ecran%,1920)
      bmov(V:sauv$,a%)
      SUB a%,34
      bmov(a%,V:sauv$)
      bmov(raster%,a%)
      {ADD(table%,60)}=a%
      IF suppal&=15
        REPEAT
        UNTIL {ADD(table%,56)}>=ADD(a%,6630)
        CARD{ADD(a%,6630)}=sauv2&
        sauv2&=INT{ADD(a%,6596)}
        CARD{ADD(a%,6596)}=FALSE
      ELSE
        bmov(V:sauv2$,a2%)
        SUB a2%,34
        bmov(a2%,V:sauv2$)
        bmov(raster%,a2%)
        {ADD(table%,64)}=a2%
      ENDIF
    UNTIL OR(y&<>FALSE,j&=FALSE)
  ELSE IF AND(y&=199,OR(AND(j&<33,suppal&=14),AND(j&<64,suppal&=15)))
    REPEAT
      @vs
      ms
      INC j&
      REPEAT
      UNTIL ADD(ADD(PEEK(&HFF8209),SHL(PEEK(&HFF8207),8)),SWAP(PEEK(&HFF8205)))>=ADD(ecran%,1920)
      bmov(V:sauv$,a%)
      ADD a%,34
      bmov(a%,V:sauv$)
      bmov(raster%,a%)
      {ADD(table%,60)}=a%
      IF suppal&=15
        REPEAT
        UNTIL {ADD(table%,56)}>=ADD(a%,6596)
        CARD{ADD(a%,6562)}=sauv2&
        sauv2&=INT{ADD(a%,6596)}
        CARD{ADD(a%,6596)}=FALSE
      ELSE
        bmov(V:sauv2$,a2%)
        ADD a2%,34
        bmov(a2%,V:sauv2$)
        bmov(raster%,a2%)
        {ADD(table%,64)}=a2%
      ENDIF
    UNTIL OR(y&<>199,OR(AND(j&=33,suppal&=14),AND(j&=64,suppal&=15)))
  ENDIF
ENDIF
IF y&>7
  b&=CARD{ADD(ADD(x&,x&),a3%)}
  i&=ADD(SUB(y&,8),j&)
  ADD i&,i&
  ADD i&,i&
  v&=CARD{ADD(i&,a4%)}
  r&=CARD{ADD(ADD(i&,2),a4%)}
  i%=ADD(ecran%,168)
  FOR t&=FALSE TO 2
    SELECT t&
    CASE 0
      t%=ADD(ADD(lst%,30000),SHL&(SHL&(r&,2),2))
    CASE 1
      t%=ADD(ADD(lst%,30000),SHL&(SHL&(v&,2),2))
    DEFAULT
      t%=ADD(ADD(lst%,30000),SHL&(SHL&(b&,2),2))
    ENDSELECT
    CARD{i%}=CARD{t%}
    CARD{ADD(i%,160)}=CARD{ADD(t%,2)}
    CARD{ADD(i%,320)}=CARD{ADD(t%,4)}
    CARD{ADD(i%,480)}=CARD{ADD(t%,6)}
    CARD{ADD(i%,640)}=CARD{ADD(t%,8)}
    CARD{ADD(i%,800)}=CARD{ADD(t%,10)}
    CARD{ADD(i%,960)}=CARD{ADD(t%,12)}
    ADD i%,26
  NEXT t&
  SELECT suppal&
  CASE 7
    coul%=OR(b&,OR(SHL&(v&,4),SHL&(r&,8)))
  CASE 14
    coul%=SHL&(AND(r&,14),7)
    coul%=ADD(ADD(ADD(coul%,SHL&(AND(v&,14),3)),SHR&(b&,1)),AND(ODD(v&),16))
    coul2%=ADD(SHL&(AND(r&,14),7),AND(ODD(r&),256))
    coul2%=ADD(ADD(coul2%,SHL&(AND(v&,14),3)),SUB(SHR&(b&,1),ODD(b&)))
    CARD{a2%}=coul2%
  CASE 15
    coul%=OR(SHL&(AND(r&,14),7),AND(ODD(r&),&H800))
    coul%=OR(coul%,OR(SHL&(AND(v&,14),3),AND(ODD(v&),&H80)))
    coul%=OR(coul%,OR(SHR&(b&,1),AND(ODD(b&),8)))
  ENDSELECT
  CARD{a%}=coul%
ENDIF
UNTIL k&
IF k&=1
fixc(suppal&,ec&,cursc&,FALSE,b&)
fixc(suppal&,ec&,cursc&,1,v&)
fixc(suppal&,ec&,cursc&,2,r&)
ENDIF
@hide
BMOVE ado%,ecran%,32000               ! Restaure ‚cran
@showm
{ADD(table%,56)}=raster%              ! R‚inits Rasters
{ADD(table%,60)}=raster%
{ADD(table%,64)}=raster2%
setcopal
lkblit                                ! Blitter on
IF C:tstmega%()
SPOKE &HFFFF8E21,3
ENDIF
ENDIF
CLR t&,i&,j&,r&,v&,b&,sauv$,sauv2$,sauv2&,a%,a2%,a3%,a4%,coul%,coul2%
RETURN
> PROCEDURE bmov(a%,b%)           ! Emulation bmove (pour eviter les sautillements)
{b%}={a%}
{ADD(b%,4)}={ADD(a%,4)}
{ADD(b%,8)}={ADD(a%,8)}
{ADD(b%,12)}={ADD(a%,12)}
{ADD(b%,16)}={ADD(a%,16)}
{ADD(b%,20)}={ADD(a%,20)}
{ADD(b%,24)}={ADD(a%,24)}
{ADD(b%,28)}={ADD(a%,28)}
{ADD(b%,32)}={ADD(a%,32)}
{ADD(b%,36)}={ADD(a%,36)}
{ADD(b%,40)}={ADD(a%,40)}
{ADD(b%,44)}={ADD(a%,44)}
{ADD(b%,48)}={ADD(a%,48)}
{ADD(b%,52)}={ADD(a%,52)}
{ADD(b%,56)}={ADD(a%,56)}
{ADD(b%,60)}={ADD(a%,60)}
{ADD(b%,64)}={ADD(a%,64)}
RETURN
> PROCEDURE cltrac                ! Retrace les potentiometres
LOCAL b&,j&,nb2&,aux2&,state&,aux3&
IF curson&
state&=TRUE
@hide
ENDIF
deic2(FALSE,110,319,167)
GRAPHMODE 2
FOR b&=FALSE TO 2
nb2&=@renc(suppal&,ec&,cursc&,b&)
aux3&=ADD(MUL(b&,18),113)
FOR j&=FALSE TO suppal&
aux2&=ADD(MUL(j&,aux&),5)
IF j&=nb2&
  apps(aux2&,aux3&,ADD(r&,aux2&),ADD(aux3&,15),SUB(10,MUL(b&,3)))
ELSE
  resx(aux2&,aux3&,ADD(r&,aux2&),ADD(aux3&,15))
ENDIF
NEXT j&
appx(299,aux3&,315,ADD(aux3&,15))
TEXT 301,ADD(aux3&,10),nb2&
NEXT b&
GRAPHMODE 1
IF state&
@showm
ENDIF
CLR b&,j&,nb2&,aux2&,state&,aux3&
RETURN
> PROCEDURE 74                    ! Test potentiometres RVB
REPEAT
tabicone(5,113,r&,15,aux&,18,suppal&,2,21)
ms
UNTIL OR(NOT @rectst(x&,y&,xh&,yh&,xb&,yb&),k&=FALSE)
atm0
k&=FALSE
RETURN
> PROCEDURE 21                    ! Fixe un potentiometre R , V ou  B
LOCAL aux3&
nb2&=@renc(suppal&,ec&,cursc&,i&)
IF nb2&<>t&
aux3&=ADD(MUL(i&,18),113)
nopal
@hide
deic2(ADD(MUL(aux&,nb2&),5),aux3&,ADD(ADD(r&,MUL(aux&,nb2&)),5),ADD(aux3&,15))
arec(301,ADD(aux3&,1),314,ADD(aux3&,14),2,FALSE)
GRAPHMODE 2
TEXT 301,ADD(MUL(i&,18),124),t&
GRAPHMODE 1
apps(xh&,yh&,xb&,yb&,SUB(10,MUL(i&,3)))
@showm
fixc(suppal&,ec&,cursc&,i&,t&)
savd&(ec&)=TRUE
setcopal
ENDIF
CLR aux3&
RETURN
> PROCEDURE setcopal              ! Init palette pour s‚lecteur
CARD{V:pal$}=rvb&(cursc&,ec&)
raster(MKL$(V:rvb&(FALSE,ec&))+MKI$(80)+MKL$(old%)+MKI$(20)+MKL$(V:rvb&(FALSE,ec&))+MKI$(10)+MKL$(old%)+MKI$(89)+MKL$(V:pal$)+MKI$(240))
RETURN
> PROCEDURE 25                    ! Slide flŠche ou assigne curseur couleur
IF k&=2
IF OR(t&=debc&,t&=endc&)
col(t&)
ENDIF
ELSE
cursc&=t&
ppal(cursc&)
cltrac
setcopal
ENDIF
atm0
RETURN
> PROCEDURE 75                    ! Fonctions de l'‚diteur de palettes (haut)
LOCAL a$,b&
appx(xh&,yh&,xb&,yb&)
SELECT t&
CASE 0
raster(MKL$(V:rvb&(FALSE,ec&)))
phy(ec%(ec&))
atm0
phy(ecran%)
CASE 1
raster(MKL$(V:rvb&(FALSE,ec&)))
phy(ec%(ec&))
a$=SPACE$(32)
BMOVE V:rvb&(FALSE,ec&),V:a$,32
REPEAT
ms
@vs
IF k&=2
  b&=rvb&(endc&,ec&)
  BMOVE V:rvb&(debc&,ec&),V:rvb&(ADD(debc&,1),ec&),SHL&(SUB(endc&,debc&),1)
  rvb&(debc&,ec&)=b&
ELSE
  b&=rvb&(debc&,ec&)
  BMOVE V:rvb&(ADD(debc&,1),ec&),V:rvb&(debc&,ec&),SHL&(SUB(endc&,debc&),1)
  rvb&(endc&,ec&)=b&
ENDIF
raster(MKL$(V:rvb&(FALSE,ec&)))
IF SHR(x&,3)
  FOR b&=1 TO SHR(x&,3)
    @vs
    k&=@mousek
    EXIT IF k&=FALSE
  NEXT b&
ENDIF
UNTIL k&=FALSE
BMOVE V:a$,V:rvb&(FALSE,ec&),32
phy(ecran%)
CASE 2                        ! Load palette
inter_off
vide$="DEFAULT.INF"
cpath$=@form_path$(cpath$,"PAL")
select(ado%,cpath$,vide$)
lkchargph
IF vide$<>""
nopal
OPEN "i",#1,fich$
openf&=TRUE
BGET #1,V:rvb&(FALSE,ec&),32
CLOSE #1
openf&=FALSE
ENDIF
inter_on
convert(suppal&,@ana,ec&,FALSE,FALSE)
CASE 3                        ! Save palette
b&=@pop_up(120,112,73,2,1,@rd$(73,2),TRUE,2)
SELECT b&
CASE 0,1
inter_off
vide$="DEFAULT.PAL"
IF b&
  spath$=@form_path$(spath$,"S")
ELSE
  spath$=@form_path$(spath$,"PAL")
ENDIF
select(ado%,spath$,vide$)
lksauvph
IF vide$<>""
  OPEN "o",#1,fich$
  openf&=TRUE
  SELECT b&
  CASE 0
    BPUT #1,V:rvb&(FALSE,ec&),32
  CASE 1
    PRINT #1;"        dc.w    $";
    FOR b&=FALSE TO 15
      PRINT #1;HEX$(rvb&(b&,ec&));
      IF b&<>15
        PRINT #1;",";
      ENDIF
    NEXT b&
    PRINT #1
  ENDSELECT
  CLOSE #1
  openf&=FALSE
ENDIF
inter_on
ENDSELECT
CASE 4                        ! Undo palette
FOR b&=FALSE TO 15
SWAP undo&(b&),rvb&(b&,ec&)
NEXT b&
cltrac
atm0
ENDSELECT
setcopal
resx(xh&,yh&,xb&,yb&)
CLR a$,b&
RETURN
> PROCEDURE 15                    ! Fonctions de l'‚diteur de palettes (bas)
LOCAL test&,j&,b&
appx(xh&,yh&,xb&,yb&)
ARRAYFILL plx&(),TRUE
IF i&=FALSE
nopal
SELECT t&
CASE 0
SWAP rvb&(debc&,ec&),rvb&(endc&,ec&)
IF @btc(2)
  plx&(debc&)=endc&
  plx&(endc&)=debc&
  @hide
  ~C:rempl%(L:ec%(ec&),L:V:plx&(FALSE),L:FALSE,320,200)
  @showm
ENDIF
i&=OR(endc&=cursc&,debc&=cursc&)
CASE 1                              ! Rotation Droite
IF debc&<>endc&
  b&=rvb&(endc&,ec&)
  BMOVE V:rvb&(debc&,ec&),V:rvb&(ADD(debc&,1),ec&),SHL(SUB(endc&,debc&),1)
  rvb&(debc&,ec&)=b&
  IF @btc(2)
    j&=ADD(SUB(endc&,debc&),1)
    FOR b&=debc& TO endc&
      plx&(b&)=ADD(MOD(ADD(SUB(b&,debc&),1),j&),debc&)
    NEXT b&
    @hide
    ~C:rempl%(L:ec%(ec&),L:V:plx&(FALSE),L:FALSE,320,200)
    @showm
  ENDIF
  i&=AND(cursc&>=debc&,cursc&<=endc&)
  IF k&=1
    atm0
  ENDIF
ENDIF
CASE 2                              ! Rotation Gauche
IF debc&<>endc&
  b&=rvb&(debc&,ec&)
  BMOVE V:rvb&(ADD(debc&,1),ec&),V:rvb&(debc&,ec&),SHL(SUB(endc&,debc&),1)
  rvb&(endc&,ec&)=b&
  IF @btc(2)
    j&=ADD(SUB(endc&,debc&),1)
    FOR b&=debc& TO endc&
      plx&(b&)=ADD(MOD(ADD(SUB(b&,debc&),SUB(j&,1)),j&),debc&)
    NEXT b&
    @hide
    ~C:rempl%(L:ec%(ec&),L:V:plx&(FALSE),L:FALSE,320,200)
    @showm
  ENDIF
  i&=AND(cursc&>=debc&,cursc&<=endc&)
  IF k&=1
    atm0
  ENDIF
ENDIF
CASE 3                              ! Inverse
FOR b&=FALSE TO SHR(SUB(endc&,debc&),1)
  SWAP rvb&(ADD(b&,debc&),ec&),rvb&(SUB(endc&,b&),ec&)
NEXT b&
IF @btc(2)
  FOR b&=debc& TO endc&
    plx&(b&)=b&
  NEXT b&
  FOR b&=FALSE TO SHR(SUB(endc&,debc&),1)
    SWAP plx&(ADD(b&,debc&)),plx&(SUB(endc&,b&))
  NEXT b&
  @hide
  ~C:rempl%(L:ec%(ec&),L:V:plx&(FALSE),L:FALSE,320,200)
  @showm
ENDIF
i&=AND(cursc&>=debc&,cursc&<=endc&)
CASE 4                              ! Lum + / Lum -
FOR j&=FALSE TO 2
  b&=@renc(suppal&,ec&,cursc&,j&)
  IF k&=1
    IF b&>FALSE
      DEC b&
    ENDIF
  ELSE
    IF b&<suppal&
      INC b&
    ENDIF
  ENDIF
  fixc(suppal&,ec&,cursc&,j&,b&)
NEXT j&
i&=TRUE
ENDSELECT
IF i&
cltrac
ENDIF
IF OR(AND(AND(t&<>1,t&<>2),k&<>2),t&=4)
atm0
ENDIF
k&=FALSE
ELSE
SELECT t&
CASE 0                      ! Choix du mode palette
test&=suppal&
menupal(xh&,yb&,TRUE)
IF test&<>suppal&
  aux&=DIV(290,ADD(suppal&,1))
  r&=SUB(aux&,3)
  cltrac
ENDIF
CASE 1                      ! Selection super palette
test&=rvb&(cursc&,ec&)
oldoverdascrine
IF test&<>rvb&(cursc&,ec&)
  cltrac
ENDIF
atm0
k&=FALSE
CASE 2                      ! D‚grad‚
nopal
IF SUB(endc&,debc&)>1
  degd(debc&,endc&)
  cltrac
ENDIF
CASE 3                      ! Mise en Memoire
IF k&=1
  FOR b&=FALSE TO 15
    mem&(b&)=rvb&(b&,ec&)
  NEXT b&
ELSE
  mem&=rvb&(cursc&,ec&)   ! Mise en memoire d'1 couleur
ENDIF
CASE 4                      ! Assignation de la memoire palette
IF @btc(2)
  FOR b&=FALSE TO nbec&
    BMOVE V:mem&(FALSE),V:rvb&(FALSE,b&),32
  NEXT b&
ELSE
  nopal
  IF k&=1
    FOR b&=FALSE TO 15
      rvb&(b&,ec&)=mem&(b&)
    NEXT b&
  ELSE
    rvb&(cursc&,ec&)=mem&     ! Assignation d'1 couleur en memoire
  ENDIF
ENDIF
cltrac
ENDSELECT
ENDIF
setcopal
BMOVE ADD(ec%(ec&),MUL(ordo&,160)),ecran%,12800
atm0
resx(xh&,yh&,xb&,yb&)
CLR test&,j&,b&
RETURN
> PROCEDURE degd(a&,b&)           ! Degrade la palette courante entre a& & b&
LOCAL i&,t&,reel
FOR j&=FALSE TO 2
i&=@renc(suppal&,ec&,a&,j&)
reel=SUB(@renc(suppal&,ec&,b&,j&),i&)/SUB(b&,a&)
FOR t&=a& TO b&
fixc(suppal&,ec&,t&,j&,ADD(i&,ROUND(reel*SUB(t&,a&))))
NEXT t&
NEXT j&
CLR a&,b&,i&,t&,reel
RETURN
> PROCEDURE col(t&)               ! Gestø fleches couleurs
@hide
BMOVE pan%,ADD(ecran%,16000),1600
COLOR 1
REPEAT
ms2
crds2(FALSE,FALSE,300,200,x&,y&)
BOX x&,100,ADD(x&,19),109
BMOVE pan%,ADD(ecran%,16000),1600
UNTIL k&=FALSE
IF AND(t&=debc&,OR(t&<>FALSE,endc&<>FALSE))
arec(MUL(debc&,20),100,ADD(MUL(debc&,20),6),108,debc&,FALSE)
debc&=ROUND(x&/20)
IF debc&>endc&
debc&=endc&
ENDIF
PUT MUL(debc&,20),100,fg$,ADD(1,AND(debc&=FALSE,8))
ELSE
arec(ADD(MUL(endc&,20),13),100,ADD(MUL(endc&,20),18),108,endc&,FALSE)
endc&=ROUND(x&/20)
IF debc&>endc&
endc&=debc&
ENDIF
PUT ADD(MUL(endc&,20),13),100,fd$,ADD(1,AND(endc&=FALSE,8))
ENDIF
BMOVE ADD(ecran%,16000),pan%,1600
ppal(cursc&)
@showm
CLR t&
RETURN
> PROCEDURE nopal                 ! Gestø undo palette
BMOVE V:rvb&(FALSE,ec&),V:undo&(FALSE),32
RETURN
> FUNCTION renc(suppal&,scrine&,i&,c&)     ! Fournit la valeur R ou V ou B d'un registre de couleur en tenant compte du mode palette utilis‚
LOCAL l&,t&,c2&
l&=rvb&(i&,scrine&)
c2&=SHL(c&,2)
SELECT suppal&
CASE 7,15
t&=SHR&(AND(l&,SHL&(suppal&,c2&)),c2&)
IF suppal&>=15
t&=SUB(AND(ADD(t&,t&),15),BTST(t&,3))
ENDIF
CASE 14
t&=SUB(SHL&(SHR&(AND(l&,SHL&(7,c2&)),c2&),1),BTST(l&,ADD(12,c&)))
CASE 30
t&=SHL&(SHR&(AND(l&,SHL&(15,c2&)),c2&),1)
t&=AND(SUB(t&,BTST(t&,4)),15)
t&=SUB(SHL&(t&,1),BTST(l&,ADD(12,c&)))
ENDSELECT
CLR c&,i&,l&,suppal&,scrine&,c2&
RETURN t&
ENDFUNC
> PROCEDURE fixc(suppal&,scrine&,i&,t&,j&) ! Fixe la valeur R ou V ou B d'un registre de couleur en tenant compte du mode palette utilis‚
LOCAL l&,c2&
l&=rvb&(i&,scrine&)
c2&=SHL&(t&,2)
SELECT suppal&
CASE 7,15
IF suppal&=15
j&=ROR&(j&,1)
IF BTST(j&,15)
j&=AND(BSET(j&,3),15)
ELSE
j&=AND(BCLR(j&,3),15)
ENDIF
ENDIF
l&=OR(AND(l&,NOT SHL&(suppal&,c2&)),SHL&(j&,c2&))
CASE 30
j&=ROR&(j&,1)
IF BTST(j&,15)
l&=BSET(l&,ADD(t&,12))
ELSE
l&=BCLR(l&,ADD(t&,12))
ENDIF
j&=ROR&(j&,1)
IF BTST(j&,15)
j&=AND(BSET(j&,3),15)
ELSE
j&=AND(BCLR(j&,3),15)
ENDIF
l&=OR(AND(l&,NOT SHL&(15,c2&)),SHL&(j&,c2&))
CASE 14
j&=ROR&(j&,1)
l&=OR(AND(l&,NOT SHL&(7,c2&)),SHL&(j&,c2&))
IF BTST(j&,15)
l&=BSET(l&,ADD(t&,12))
ELSE
l&=BCLR(l&,ADD(t&,12))
ENDIF
ENDSELECT
rvb&(i&,scrine&)=l&
CLR i&,t&,j&,l&,scrine&,suppal&
RETURN
> PROCEDURE menupal(x&,y&,sens&)           ! Choix du mode palette
LOCAL choice&,a&
SELECT @pop_up(x&,y&,62,ADD(2,AND(ste&,2)),sens&," ",TRUE,@supnb(suppal&))
CASE 0
choice&=7
CASE 1
choice&=14
CASE 2
choice&=15
CASE 3
choice&=30
ENDSELECT
IF AND(choice&<15,14<suppal&)
IF @alt(TRUE,120,@rd$(9,FALSE),@rd$(10,FALSE),1)=FALSE
convert(choice&,suppal&,FALSE,nbec&,TRUE)
suppal&=choice&
ENDIF
ELSE IF AND(suppal&=14,choice&>14)
convert(choice&,suppal&,FALSE,nbec&,TRUE)
suppal&=choice&
ELSE
IF suppal&<choice&
IF @alt(TRUE,120,@rd$(22,FALSE),@rd$(22,1),FALSE)=1
convert(choice&,suppal&,FALSE,nbec&,FALSE)
ENDIF
ENDIF
suppal&=choice&
ENDIF
IF NOT BTST(suppal&,FALSE)
BMOVE raster%,raster2%,500
ENDIF
CARD{ADD(table%,52)}=NOT BTST(suppal&,FALSE)
nopal
FOR a&=FALSE TO 15
mem&(a&)=rvb&(a&,ec&)
NEXT a&
CLR choice&,a&
RETURN
> PROCEDURE convert(choice&,suppal&,off&,nb&,keep&)  ! Conversø de pals (d'un mode pal … l'autre)
LOCAL l&,b&
IF AND(choice&<15,14<suppal&)
FOR l&=FALSE TO 15
FOR b&=off& TO ADD(off&,nb&)
rvb&(l&,b&)=@ste_stf(rvb&(l&,b&))
NEXT b&
NEXT l&
ELSE IF AND(choice&>14,suppal&<15)
IF suppal&=14
FOR l&=FALSE TO 15
FOR b&=off& TO ADD(off&,nb&)
  rvb&(l&,b&)=@stf_ste(rvb&(l&,b&))
NEXT b&
NEXT l&
ELSE
FOR l&=FALSE TO 15
FOR b&=off& TO ADD(off&,nb&)
  rvb&(l&,b&)=AND(rvb&(l&,b&),&X11101110111)
NEXT b&
NEXT l&
ENDIF
ELSE IF AND(NOT keep&,choice&>suppal&)
IF choice&=14
keep&=&X11101110111
ELSE
keep&=&HFFF
ENDIF
FOR l&=FALSE TO 15
FOR b&=off& TO ADD(off&,nb&)
rvb&(l&,b&)=AND(rvb&(l&,b&),keep&)
NEXT b&
NEXT l&
ENDIF
CLR l&,b&,choice&,suppal&,nb&,off&,keep&
RETURN
> FUNCTION stf_ste(nb&)                   ! Conversø stf -> ste
LOCAL a&
a&=OR(OR(AND(BTST(nb&,12),8),AND(BTST(nb&,13),128)),AND(BTST(nb&,14),2048))
RETURN OR(AND(nb&,&HFFF),a&)
ENDFUNC
> FUNCTION ste_stf(nb&)                   ! Conversø ste -> stf
LOCAL a&
a&=OR(OR(AND(BTST(nb&,3),4096),AND(BTST(nb&,7),8192)),AND(BTST(nb&,11),16384))
IF AND(nb&,&HF)=&HF
a&=BCLR(a&,12)
ENDIF
IF AND(nb&,&HF0)=&HF0
a&=BCLR(a&,13)
ENDIF
IF AND(nb&,&HF00)=&HF00
a&=BCLR(a&,14)
ENDIF
a&=OR(a&,AND(nb&,&X11101110111))
RETURN a&
ENDFUNC
> FUNCTION supnb(choice&)                 ! Gestø choix -> mode palette (suppal&)
SELECT choice&
CASE 7
RETURN 0
CASE 14
RETURN 1
CASE 15
RETURN 2
CASE 30
RETURN 3
ENDSELECT
ENDFUNC
'
' GESTION SOURIS & CLAVIER
'
> PROCEDURE mouse                         ! Parametrage souris & acces parametrage clavier
LOCAL t&,i&,ext&
@hide
eff(ADD(ecran%,27360),4640)
raster(MKL$(old%))
deic2(FALSE,FALSE,319,179)
defx
GRAPHMODE 2
FOR i&=FALSE TO 2
FOR t&=FALSE TO 5
resicone(5,112,25,15,30,20,t&,i&)
TEXT ADD(MUL(t&,30),13),ADD(MUL(i&,20),122),STR$(ADD(t&,1))
NEXT t&
NEXT i&
deic2(FALSE,180,229,199)
deic2(230,180,319,199)
appx(185,112,310,168)
tracmo(35,3,FALSE)
tracmo(195,3,1)
TEXT 30,98,@rd$(37,FALSE)
TEXT 190,98,@rd$(37,1)
TEXT 190,122,@rd$(37,3)
TEXT 190,142,@rd$(37,4)
TEXT 190,162,@rd$(37,5)
TEXT 100,192,@rd$(37,2)
TEXT 260,192,@rd$(74,FALSE)
BMOVE ecran%,ado%,32000
GRAPHMODE 1
affshow
@showm
REPEAT
ms2
tabicone(5,112,25,15,30,20,5,2,43)
icone(FALSE,180,229,199,41)
icone(38,6,117,85,40)
icone(198,6,277,85,40)
icone(230,180,319,199,10)
IF @inp_
ext&=act&(@inp)=61
ENDIF
UNTIL ext&
appx(230,180,319,199)
k&=TRUE
@atm0
k&=FALSE
norm
CLR t&,i&,ext&
RETURN
> FUNCTION on_screen                      ! Prise sur ecran (curseur & trame)
LOCAL aux&,tlp&,i%,t%,prt%
@hide
BMOVE ec%(ec&),ecran%,32000
aux&=FALSE
eff(lp%,5120)
BOX ADD(TRUE,AND(aux&,240)),TRUE,ADD(80,AND(aux&,240)),80
clipmo(FALSE,FALSE,304,184)
atm0
@showm
REPEAT
ms
IF XOR(aux&=TRUE,x&<160)
@hide
aux&=NOT aux&
BMOVE ec%(ec&),ecran%,12960
BOX ADD(TRUE,AND(aux&,240)),TRUE,ADD(80,AND(aux&,240)),80
@showm
ENDIF
i%=ADD(ecran%,AND(aux&,120))
BMOVE ADD(lp%,2560),lp%,2560
@hide
FOR tlp&=FALSE TO 15
RC_COPY ecran%,ADD(x&,tlp&),y&,1,16 TO lp%,MUL(tlp&,5),FALSE
NEXT tlp&
@showm
RC_COPY lp%,FALSE,FALSE,80,16 TO lp%,1,FALSE,7
RC_COPY lp%,FALSE,FALSE,80,16 TO lp%,2,FALSE,7
prt%=lp%
FOR t%=i% TO ADD(i%,12000) STEP 800
BMOVE prt%,t%,40
BMOVE prt%,ADD(t%,160),40
BMOVE prt%,ADD(t%,320),40
BMOVE prt%,ADD(t%,480),40
BMOVE ADD(lp%,2560),ADD(t%,640),40
ADD prt%,160
NEXT t%
UNTIL k&
clipmo(FALSE,FALSE,319,199)
CLR tlp&,aux&,i%,t%,prt%
IF k&=1
RETURN ADD(SWAP(x&),y&)
ELSE
RETURN TRUE
ENDIF
ENDFUNC
> PROCEDURE 43                            ! Gestion icones sensibilit‚s souris
@hide
BMOVE ado%,ecran%,32000
SELECT i&
CASE 0
smopanel&=t&
sensmo(ADD(t&,1))
CASE 1
smodess&=t&
CASE 2
smoloup&=t&
ENDSELECT
affshow
@showm
atm0
RETURN
> PROCEDURE affshow                       ! Affichage parametres souris
appicone(5,112,25,15,30,20,smopanel&,FALSE)
appicone(5,112,25,15,30,20,smodess&,1)
appicone(5,112,25,15,30,20,smoloup&,2)
arec(ADD(MUL(hotdx&,5),199),ADD(MUL(hotdy&,5),7),ADD(MUL(hotdx&,5),201),ADD(MUL(hotdy&,5),9),4,FALSE)
arec(ADD(MUL(hotpx&,5),39),ADD(MUL(hotpy&,5),7),ADD(MUL(hotpx&,5),41),ADD(MUL(hotpy&,5),9),4,FALSE)
RETURN
> PROCEDURE tracmo(x&,y&,nb&)             ! Affiche un curseur souris grossi
LOCAL state&,t&,i&,aux&,t%
IF curson&
state&=TRUE
@hide
ENDIF
deic2(x&,y&,ADD(x&,85),ADD(y&,85))
appx(ADD(x&,2),ADD(y&,2),ADD(x&,83),ADD(y&,83))
FOR t&=FALSE TO 15
IF nb&
t%={ADD(V:mouse2$,SHL&(t&,2))}
ELSE
t%={ADD(V:mouse$,SHL&(t&,2))}
ENDIF
FOR i&=FALSE TO 15
aux&=OR(-BTST(t%,SUB(15,i&)),SHL&(-BTST(t%,SUB(31,i&)),1))
arec(ADD(MUL(i&,5),ADD(x&,3)),ADD(MUL(t&,5),ADD(y&,3)),ADD(MUL(i&,5),ADD(x&,6)),ADD(MUL(t&,5),ADD(y&,6)),aux&,FALSE)
NEXT i&
NEXT t&
IF state&
@showm
ENDIF
CLR t&,i&,state&,t%,aux&,nb&,x&,y&
RETURN
> PROCEDURE getcurs                       ! Prise sur ecran / gestø point chaud
IF k&=1
raster(MKL$(V:rvb&(FALSE,ec&)))
i%=@on_screen
@hide
IF i%<>TRUE
x2&=AND(SWAP(i%),&HFFF)
y2&=AND(y&,&HFF)
RC_COPY ecran%,x2&,y2&,16,16 TO ecran%,FALSE,FALSE
IF xh&=198
t%=V:mouse2$
ELSE
t%=V:mouse$
ENDIF
i%=ecran%
FOR t&=FALSE TO 15
FOR j&=FALSE TO 15
SELECT PTST(t&,j&)
CASE 0
CASE 15
PSET t&,j&,3
DEFAULT
PSET t&,j&,1
ENDSELECT
NEXT j&
NEXT t&
FOR t&=FALSE TO 15
CARD{t%}=NOT CARD{i%}
CARD{ADD(t%,2)}=CARD{ADD(i%,2)}
ADD t%,4
ADD i%,160
NEXT t&
BMOVE ado%,ecran%,32000
IF xh&=38
defmo(V:mouse$,hotpx&,hotpy&)
tracmo(35,3,FALSE)
ELSE
tracmo(195,3,1)
ENDIF
BMOVE ecran%,ado%,32000
ELSE
BMOVE ado%,ecran%,32000
ENDIF
raster(MKL$(old%))
ELSE
@hide
BMOVE ado%,ecran%,32000
IF xh&=198
hotdx&=DIV(SUB(x&,198),5)
hotdy&=DIV(SUB(y&,6),5)
ELSE
hotpx&=DIV(SUB(x&,38),5)
hotpy&=DIV(SUB(y&,6),5)
defmo(V:mouse$,hotpx&,hotpy&)
ENDIF
atm0
ENDIF
affshow
@showm
RETURN
'
> PROCEDURE key                           ! Redef curseurs - Appel redef clavier
LOCAL total1&,total2&,total3&,nb1&,nb2&,nb3&,t%,ext&
@hide
totalc
appx(xh&,yh&,xb&,yb&)
atm0
inter_off
eff(lst%,32000)
load("KEYBOAR",lst%,TRUE,fat$)
eff(ADD(lst%,9120),16000)
~XBIOS(5,L:lst%,L:ecran%,W:TRUE)
deic2(230,70,319,179)
deic2(FALSE,110,229,114)
deic2(FALSE,155,229,159)
deic2(230,180,319,199)
tex2(260,192,@rd$(74,FALSE))
aff_sel(FALSE,70,64,FALSE,total1&)
aff_sel(FALSE,115,65,FALSE,total2&)
aff_sel(FALSE,160,66,FALSE,total3&)
~XBIOS(5,L:ecran%,L:ecran%,W:TRUE)
BMOVE lst%,ecran%,32000
load("TOUCHE1",V:plx&(FALSE),FALSE,fat$)
load("TOUCHE2",V:ply&(FALSE),FALSE,fat$)
inter_on
BMOVE {ADD(table%,78)},ADD(lst%,11200),120
FOR t%={ADD(table%,78)} TO ADD(t%,119)
BYTE{t%}=2
NEXT t%
eff({ADD(table%,82)},120)
@showm
REPEAT
ms2
icone(230,180,319,199,10)
IF NOT ext&
IF @inp_
DEFFILL 8,2,8
a&=@inp
@hide
FILL plx&(a&),ply&(a&)
@showm
action(a&)
ELSE
IF @gest_sel(FALSE,70,64,nb1&,total1&)
@hide
IF total1&<>65
DEFFILL 4,2,8
FOR t&=1 TO 114
SELECT t&
CASE 55,69,70,73,76,79,81,84 TO 95
DEFAULT
IF act&(t&)=total1&
  FILL plx&(t&),ply&(t&)
ENDIF
ENDSELECT
NEXT t&
ATEXT FALSE,60,FALSE,@rd$(71,FALSE)+@rd$(64,total1&)
ENDIF
atm0
BMOVE lst%,ecran%,11200
total1&=TRUE
@showm
ENDIF
IF @gest_sel(FALSE,115,65,nb2&,total2&)
@hide
DEFFILL 4,2,8
t&=bt&(total2&)
IF t&<>TRUE
FILL plx&(t&),ply&(t&)
ENDIF
ATEXT FALSE,60,FALSE,@rd$(71,FALSE)+@rd$(65,total2&)
atm0
BMOVE lst%,ecran%,11200
total2&=TRUE
@showm
ENDIF
IF @gest_sel(FALSE,160,66,nb3&,total3&)
@hide
DEFFILL 4,2,8
t&=bt&(ADD(total3&,20))
IF t&<>TRUE
FILL plx&(t&),ply&(t&)
ENDIF
ATEXT FALSE,60,FALSE,@rd$(71,FALSE)+@rd$(66,total3&)
atm0
BMOVE lst%,ecran%,11200
total3&=TRUE
@showm
ENDIF
icone(FALSE,FALSE,181,56,98)
ENDIF
atm0
ENDIF
UNTIL ext&
appx(230,180,319,199)
BMOVE ADD(lst%,11200),{ADD(table%,78)},120
necho
k&=TRUE
@atm0
k&=FALSE
@hide
BMOVE ado%,ecran%,32000
affshow
@showm
CLR total1&,total2&,total3&,nb1&,nb2&,nb3&,t%,ext&
RETURN
> PROCEDURE 98
LOCAL a&
a&=@scan
IF a&
action(a&)
ENDIF
RETURN
> PROCEDURE action(a&)
LOCAL t&,flag&
@hide
DEFFILL 4,2,8
FOR t&=FALSE TO 39
EXIT IF bt&(t&)=a&
NEXT t&
IF t&=40
IF act&(a&)<>TRUE
FOR t&=1 TO 114
IF AND(act&(a&)=act&(t&),t&<>a&)
SELECT t&
CASE 55,69,70,73,76,79,81,84 TO 95
DEFAULT
FILL plx&(t&),ply&(t&)
ENDSELECT
ENDIF
NEXT t&
ATEXT FALSE,60,FALSE,@rd$(64,act&(a&))+" "+CHR$(3)
ELSE
ATEXT FALSE,60,FALSE,CHR$(3)
ENDIF
ELSE
IF t&>19
ATEXT FALSE,60,FALSE,@rd$(66,SUB(t&,20))+" "+CHR$(3)
ELSE
ATEXT FALSE,60,FALSE,@rd$(65,t&)+" "+CHR$(3)
ENDIF
ENDIF
@showm
atm0
REPEAT
ms2
IF @gest_sel(FALSE,70,64,nb1&,total1&)
atex(FALSE,60,FALSE,CHR$(3)+" "+@rd$(64,total1&))
FOR t&=FALSE TO 39
IF bt&(t&)=a&
bt&(t&)=TRUE
ENDIF
NEXT t&
act&(a&)=OR(total1&,total1&=65)              ! Si total1&=65: deselect touche
total1&=TRUE
k&=TRUE
BYTE{ADD(ADD(lst%,11200),a&)}=2
ENDIF
IF @gest_sel(FALSE,115,65,nb2&,total2&)
atex(FALSE,60,FALSE,CHR$(3)+" "+@rd$(65,total2&))
IF bt&(total2&)<>TRUE
BYTE{ADD(ADD(lst%,11200),bt&(total2&))}=2
ENDIF
bt&(total2&)=a&
act&(a&)=TRUE
BYTE{ADD(ADD(lst%,11200),a&)}=FALSE
total2&=TRUE
ENDIF
IF @gest_sel(FALSE,160,66,nb3&,total3&)
atex(FALSE,60,FALSE,CHR$(3)+" "+@rd$(66,total3&))
IF bt&(ADD(total3&,20))<>TRUE
BYTE{ADD(ADD(lst%,11200),bt&(ADD(total3&,20)))}=2
ENDIF
bt&(ADD(total3&,20))=a&
act&(a&)=TRUE
BYTE{ADD(ADD(lst%,11200),a&)}=1
total3&=TRUE
ENDIF
UNTIL OR(k&,@inp_)
atm0
@hide
BMOVE lst%,ecran%,11200
@showm
k&=FALSE
CLR t&
RETURN
> PROCEDURE rech(x&,y&)                   ! Recheche recursive des coordonnees de la touche
PSET x&,y&,7
IF y&=<miny&
miny&=y&
IF OR(x&<minx&,oldy&>y&)
minx&=x&
oldy&=y&
ENDIF
ENDIF
IF PTST(ADD(x&,1),y&)=10
rech(ADD(x&,1),y&)
ENDIF
IF PTST(SUB(x&,1),y&)=10
rech(SUB(x&,1),y&)
ENDIF
IF PTST(x&,ADD(y&,1))=10
rech(x&,ADD(y&,1))
ENDIF
IF PTST(x&,SUB(y&,1))=10
rech(x&,SUB(y&,1))
ENDIF
CLR x&,y&
RETURN
> FUNCTION scan
LOCAL minx&,miny&,old&,t&
@hide
IF PTST(x&,y&)=10                   ! Si on est sur une touche
minx&=319                         !
miny&=199                         !
rech(x&,y&)                       ! Cherche les coords
FOR t&=1 TO 114                   ! pour d‚terminer le scancode
EXIT IF AND(plx&(t&)=minx&,ply&(t&)=miny&)
NEXT t&
CLR minx&,miny&,old&
@showm
RETURN t&
ELSE
CLR minx&,miny&,old&,t&
@showm
RETURN FALSE
ENDIF
ENDFUNC
> FUNCTION inp_                           ! Emulation INP(-2): renvoie l'etat de disponibilite d'un caractere au clavier
RETURN CARD{ADD(table%,4)}<>FALSE
ENDFUNC
> FUNCTION inp                            ! Emulation INP(2): renvoie le scan code de la touche appuyee
LOCAL key&
IF on&
REPEAT
UNTIL @inp_
key&=CARD{ADD(table%,4)}
CARD{ADD(table%,4)}=FALSE
RETURN key&
ELSE
RETURN INP(2)
ENDIF
ENDFUNC
> FUNCTION btc(nb&)                       ! Emulation touche type 'Control': renvoie de l'etat d'un touche
IF bt&(nb&)<>TRUE
RETURN BYTE{ADD({ADD(table%,82)},bt&(nb&))}<>FALSE
ELSE
RETURN FALSE
ENDIF
ENDFUNC
'
' PROCEDURES INTERFACE UTILISATEUR (Affichage,Gestø Boites...)
'
> PROCEDURE normoutil
CLIP FALSE,FALSE,320,200
ACLIP TRUE,FALSE,FALSE,319,199
IF pane&
affpar
normpal1
eff(ADD(ecran%,17600),9920)
COLOR 1
BOX 91,138,95,142
BOX -1,110,192,170
BOX 194,120,319,170
ATEXT 200,124,FALSE,@rd$(43,FALSE)+STR$(ADD(ec&,1))+" "
ATEXT 200,140,FALSE,nom$(ec&)
ATEXT 200,132,FALSE,@fixoutil$(@rd$(3,otl&))
CLIP FALSE,FALSE TO 319,99
ACLIP TRUE,FALSE,FALSE,319,99
ELSE
raster(MKL$(V:rvb&(FALSE,ec&)))
totalc
reput
ENDIF
RETURN
> PROCEDURE normpal                       ! Palette demi ‚cran outil inactif
SELECT otl&
CASE 0,1,3,4,11,12,13,14,16
raster(MKL$(V:rvb&(FALSE,ec&))+MKI$(109)+MKL$(old%)+MKI$(220))
CASE 7,8,9,10
IF fld&
raster(MKL$(V:rvb&(FALSE,ec&))+MKI$(109)+MKL$(old%)+MKI$(64)+MKL$(V:rvb&(FALSE,ec&))+MKI$(240))
ELSE
raster(MKL$(V:rvb&(FALSE,ec&))+MKI$(109)+MKL$(old%)+MKI$(220))
ENDIF
DEFAULT
raster(MKL$(V:rvb&(FALSE,ec&))+MKI$(109)+MKL$(old%)+MKI$(63)+MKL$(V:rvb&(FALSE,ec&))+MKI$(240))
ENDSELECT
RETURN
> PROCEDURE normpal1                      ! Palette demi ‚cran outil actif
IF pan&
SELECT otl&
CASE 0,1,3,4,11,12,13,14,16
raster(MKL$(V:rvb&(FALSE,ec&))+MKI$(171)+MKL$(old%)+MKI$(220))
CASE 7,8,9,10
IF fld&
raster(MKL$(V:rvb&(FALSE,ec&)))
ELSE
raster(MKL$(V:rvb&(FALSE,ec&))+MKI$(171)+MKL$(old%)+MKI$(220))
ENDIF
DEFAULT
raster(MKL$(V:rvb&(FALSE,ec&)))
ENDSELECT
ELSE
raster(MKL$(V:rvb&(FALSE,ec&)))
ENDIF
RETURN
> PROCEDURE norm                          ! Affichage panneau + param‚trages
norm1
affpar
RETURN
> PROCEDURE norm1                         ! Affichage panneau seul
LOCAL state&
IF curson&
state&=TRUE
@hide
ENDIF
ppal(c&)
ppan
IF AND(fld&=TRUE,otl&<>2)
PUT ADD(MUL(otl&,22),5),133,led$
ENDIF
appx(ADD(MUL(MOD(otl&,14),22),2),ADD(MUL(DIV(otl&,14),29),112),ADD(MUL(MOD(otl&,14),22),22),ADD(MUL(DIV(otl&,14),29),139))
appx(ADD(MUL(MOD(cursec&,3),22),222),ADD(141,MUL(DIV(cursec&,3),14)),ADD(MUL(MOD(cursec&,3),22),242),ADD(MUL(DIV(cursec&,3),14),153))
IF state&
@showm
ENDIF
CLR state&
RETURN
'
> PROCEDURE inter_off                     ! Interuptø off
LOCAL t&
IF on&
ms2
OUT 4,18
OUT 4,&H13
vide_clv
~C:inter%(2)
OUT 4,&H11
OUT 4,8
on&=FALSE
VSYNC
FOR t&=FALSE TO 28 STEP 4
SLPOKE ADD(t&,&HFFFF8240),{ADD(old%,t&)}
NEXT t&
' vide_clv
SETMOUSE x&,y&,FALSE
FOR t&=FALSE TO 19
IF bt&(t&)>TRUE
BYTE{ADD(bt&(t&),{ADD(table%,82)})}=FALSE
ENDIF
NEXT t&
ENDIF
CLR t&
RETURN
> PROCEDURE inter_on                      ! Interupø on
IF NOT on&
OUT 4,18
OUT 4,&H13
~C:inter%(1)
OUT 4,&H11
OUT 4,8
on&=TRUE
CARD{ADD(table%,8)}=FALSE
vide_clv
ENDIF
RETURN
> PROCEDURE select(e%,VAR acp$,acf$)      ! S‚lecteur d'objets
LOCAL t&,state2&
IF on&
inter_off
state2&=TRUE
ENDIF
BMOVE ecran%,e%,32000
OPENW FALSE
mouseon
SHOWM
~FSEL_INPUT(acp$,acf$,k&)
IF k&=FALSE
acf$=""
ENDIF
HIDEM
CLOSEW FALSE
BMOVE e%,ecran%,32000
fich$=LEFT$(acp$,RINSTR(acp$,"\"))+acf$
totalc
IF state2&
inter_on
ENDIF
atm0
CLR e%,t&,k&,state2&
RETURN
> PROCEDURE warningfich(a$)               ! Boite d'alerte pour type de fichier incorects
LOCAL zozi$
zozi$=SPACE$(1000)
BMOVE raster%,V:zozi$,1000
raster(MKL$(old%))
DEFMOUSE FALSE
~@alt(TRUE,TRUE,@rd$(40,FALSE)+a$,"    Ok    ",FALSE)
BMOVE V:zozi$,raster%,1000
CLR a$,zozi$
RETURN
'
> PROCEDURE tabicone(offx&,offy&,l&,h&,mlx&,mly&,nbx_ic&,nby_ic&,pcd&)
LOCAL tabaux&,tabaux2&,t&,i&
FOR t&=FALSE TO nbx_ic&
FOR i&=FALSE TO nby_ic&
tabaux&=ADD(offx&,MUL(mlx&,t&))
tabaux2&=ADD(offy&,MUL(mly&,i&))
icone(tabaux&,tabaux2&,ADD(tabaux&,l&),ADD(tabaux2&,h&),pcd&)
NEXT i&
NEXT t&
CLR offx&,offy&,h&,l&,mlx&,mly&,nbx_ic&,nby_ic&,tabaux&,tabaux2&,pcd&
RETURN
> PROCEDURE appicone(x&,y&,l&,h&,mlx&,mly&,nbx_ic&,nby_ic&)
LOCAL aux&,aux2&
aux&=ADD(x&,MUL(mlx&,nbx_ic&))
aux2&=ADD(y&,MUL(mly&,nby_ic&))
appx(aux&,aux2&,ADD(aux&,l&),ADD(aux2&,h&))
CLR x&,y&,h&,l&,mlx&,mly&,nbx_ic&,nby_ic&,aux&,aux2&
RETURN
> PROCEDURE resicone(x&,y&,l&,h&,mlx&,mly&,nbx_ic&,nby_ic&)
LOCAL aux&,aux2&
aux&=ADD(x&,MUL(mlx&,nbx_ic&))
aux2&=ADD(y&,MUL(mly&,nby_ic&))
resx(aux&,aux2&,ADD(aux&,l&),ADD(aux2&,h&))
CLR x&,y&,h&,l&,mlx&,mly&,nbx_ic&,nby_ic&,aux&,aux2&
RETURN
> PROCEDURE apps(x&,y&,x2&,y2&,c&)        ! Dessine une boite en contours 3 couleurs
LOCAL state&
state&=curson&
IF curson&
@hide
ENDIF
ALINE x&,y&,x&,y2&,ADD(c&,2),65535,FALSE
ALINE x2&,y&,x2&,y2&,c&,65535,FALSE
HLINE x&,y&,x2&,ADD(c&,2),FALSE,adr%,1
HLINE x&,y2&,x2&,c&,FALSE,adr%,1
PSET x2&,y&,ADD(c&,1)
PSET x&,y2&,ADD(c&,1)
IF state&
@showm
ENDIF
CLR x&,y&,x2&,y2&,c&,state&
RETURN
> PROCEDURE appx(x&,y&,x2&,y2&)           ! Affiche contour boutton appuy‚
LOCAL state&
state&=curson&
IF curson&
@hide
ENDIF
ALINE x&,y&,x&,y2&,3,65535,FALSE
ALINE x2&,y&,x2&,y2&,1,65535,FALSE
HLINE x&,y&,x2&,3,FALSE,adr%,1
HLINE x&,y2&,x2&,1,FALSE,adr%,1
PSET x2&,y&,2
PSET x&,y2&,2
IF state&
@showm
ENDIF
CLR x&,y&,x2&,y2&,state&
RETURN
> PROCEDURE resx(x&,y&,x2&,y2&)           ! Affiche contour boutton non appuy‚
LOCAL state&
state&=curson&
IF curson&
@hide
ENDIF
ALINE x&,y&,x&,y2&,1,65535,FALSE
ALINE x2&,y&,x2&,y2&,3,65535,FALSE
HLINE x&,y&,x2&,1,FALSE,adr%,1
HLINE x&,y2&,x2&,3,FALSE,adr%,1
PSET x2&,y&,2
PSET x&,y2&,2
IF state&
@showm
ENDIF
CLR x&,y&,x2&,y2&
RETURN
> PROCEDURE deic(x1&,y1&,x2&,y2&,c&)      ! Boite monochrome avec fond couleur
arec(x1&,y1&,x2&,y2&,c&,FALSE)
COLOR 1
BOX x1&,y1&,x2&,y2&
CLR x1&,y1&,x2&,y2&,c&
RETURN
> PROCEDURE deic2(x1&,y1&,x2&,y2&)        ! Boite 3 couleurs
IF x1&>x2&
SWAP x1&,x2&
ENDIF
IF y1&>y2&
SWAP y1&,y2&
ENDIF
arec(x1&,y1&,x2&,y2&,2,FALSE)
resx(x1&,y1&,x2&,y2&)
CLR x1&,y1&,x2&,y2&
RETURN
> PROCEDURE arec(x1&,y1&,x2&,y2&,c&,mode&)! A_rectangle plein
LOCAL state&
IF curson&
state&=TRUE
@hide
ENDIF
ARECT x1&,y1&,x2&,y2&,c&,mode&,adr%,1
IF state&
@showm
ENDIF
CLR x1&,y1&,x2&,y2&,c&,mode&,state&
RETURN
> PROCEDURE aclp(mode&,x1&,y1&,x2&,y2&)   ! Mise en place du clip
CLIP x1&,y1& TO x2&,y2&
ACLIP mode&,x1&,y1&,x2&,y2&
CLR mode&,x1&,y1&,x2&,y2&
RETURN
> PROCEDURE totalc                        ! Clip en plein ‚cran
CLIP FALSE,FALSE TO 319,199
ACLIP TRUE,FALSE,FALSE,320,200
RETURN
> PROCEDURE atex(x&,y&,m&,a$)             ! Procedure affichage text
LOCAL state&
IF curson&
@hide
state&=TRUE
ENDIF
ATEXT x&,y&,m&,a$
IF state&
@showm
ENDIF
CLR x&,y&,m&,a$,state&
RETURN
> PROCEDURE tex2(x&,y&,a$)                ! Affichage text en gris et mode or
LOCAL state&
IF curson&
@hide
state&=TRUE
ENDIF
defx
GRAPHMODE 2
TEXT x&,y&,a$
GRAPHMODE 1
IF state&
@showm
ENDIF
CLR x&,y&,m&,a$,state&
RETURN
'
> PROCEDURE aff_sel(x1&,y1&,mes&,nb&,VAR t&)     ! Affichage Selecteur (multi menu)
LOCAL a$
deic2(x1&,y1&,ADD(x1&,199),ADD(y1&,39))
appx(ADD(x1&,2),ADD(y1&,2),ADD(x1&,197),ADD(y1&,37))
deic2(ADD(x1&,200),y1&,ADD(x1&,214),ADD(y1&,19))
deic2(ADD(x1&,200),ADD(y1&,20),ADD(x1&,214),ADD(y1&,39))
deic2(ADD(x1&,215),y1&,ADD(x1&,229),ADD(y1&,39))
defx
GRAPHMODE 2
TEXT ADD(x1&,205),ADD(y1&,10),CHR$(1)
TEXT ADD(x1&,205),ADD(y1&,32),CHR$(2)
TEXT ADD(x1&,220),ADD(y1&,20),CHR$(5)
GRAPHMODE 1
aff_sr
CLR x1&,y1&,mes&,nb&,a$
t&=TRUE
RETURN
> FUNCTION gest_sel(x1&,y1&,mes&,VAR nb&,total&) ! Gestion selecteur (attention effet de bord)
LOCAL off&,a$,oldoff&,t&,ext&
oldoff&=SUB(total&,nb&)
IF @rectst(x&,y&,x1&,y1&,ADD(x1&,199),ADD(y1&,39))
off&=MAX(DIV(SUB(y&,ADD(y1&,5)),6),FALSE)
FOR t&=FALSE TO 4
EXIT IF @rd$(mes&,ADD(t&,nb&))="~"
NEXT t&
IF t&<>5
off&=MIN(SUB(t&,1),off&)
ELSE
off&=MIN(off&,4)
ENDIF
IF total&=TRUE
arecs(off&)
ELSE
IF off&<>oldoff&
arecs(oldoff&)
arecs(off&)
ENDIF
ENDIF
total&=ADD(nb&,off&)
IF k&
arecs(off&)
ext&=TRUE
ENDIF
ELSE
IF total&<>TRUE
arecs(oldoff&)
ENDIF
IF @rectst(x&,y&,ADD(x1&,200),y1&,ADD(x1&,229),ADD(y1&,39))
off&=oldoff&
icone(ADD(x1&,200),y1&,ADD(x1&,214),ADD(y1&,19),99)
icone(ADD(x1&,200),ADD(y1&,20),ADD(x1&,214),ADD(y1&,39),100)
icone(ADD(x1&,215),y1&,ADD(x1&,229),ADD(y1&,39),101)
ENDIF
total&=TRUE
ENDIF
CLR a$,off&,oldoff&,t&
RETURN ext&
ENDFUNC
> PROCEDURE arecs(off&)                   ! Affichage rectangle pour s‚lecteur
LOCAL state&
IF curson&
state&=TRUE
@hide
ENDIF
ARECT ADD(x1&,4),ADD(ADD(y1&,5),MUL(off&,6)),ADD(x1&,195),ADD(ADD(y1&,10),MUL(off&,6)),15,2,adr%,1
IF state&
@showm
ENDIF
CLR state&,off&
RETURN
> PROCEDURE 99                            ! Ascenseur haut
appx(xh&,yh&,xb&,yb&)
REPEAT
ms2
IF nb&>FALSE
DEC nb&
aff_sr
ENDIF
UNTIL k&<2
atm0
resx(xh&,yh&,xb&,yb&)
RETURN
> PROCEDURE 100                           ! Ascenseur bas
appx(xh&,yh&,xb&,yb&)
REPEAT
ms2
IF @rd$(mes&,ADD(nb&,1))<>"~"
INC nb&
aff_sr
ENDIF
UNTIL k&<2
atm0
resx(xh&,yh&,xb&,yb&)
RETURN
> PROCEDURE 101                           ! Coulisse
LOCAL oldx&,oldy&
oldx&=x&
oldy&=y&
t&=FALSE
REPEAT
INC t&
UNTIL @rd$(mes&,t&)="~"
IF t&>5
@hide
appx(xh&,yh&,xb&,yb&)
REPEAT
ms2
aff_sr
nb&=ROUND(SUB(t&,5)*y&/200)
move2
UNTIL k&=FALSE
resx(xh&,yh&,xb&,yb&)
@showm
ENDIF
setmo(oldx&,oldy&)
RETURN
> PROCEDURE aff_sr                        ! Affichage selection
LOCAL state&,t&
IF curson&
state&=TRUE
@hide
ENDIF
arec(ADD(x1&,3),ADD(y1&,3),ADD(x1&,196),ADD(y1&,36),FALSE,FALSE)
FOR t&=FALSE TO 4
a$=@rd$(mes&,ADD(nb&,t&))
EXIT IF a$="~"
ATEXT ADD(x1&,7),ADD(ADD(y1&,5),MUL(t&,6)),FALSE,a$
NEXT t&
IF state&
@showm
ENDIF
CLR state&,t&
RETURN
> PROCEDURE dcpt(x&,y&,dep&,mes$)         ! Affiche compteur
LOCAL state&
state&=curson&
IF curson&
@hide
ENDIF
deic(x&,y&,ADD(x&,98),ADD(y&,9),FALSE)
deic(ADD(x&,25),y&,ADD(x&,75),ADD(y&,9),FALSE)
ATEXT ADD(x&,8),ADD(y&,1),1,CHR$(4)
ATEXT ADD(x&,83),ADD(y&,1),1,CHR$(3)
ATEXT ADD(x&,32),ADD(y&,3),FALSE,STR$(dep&)
ATEXT ADD(x&,101),ADD(y&,3),FALSE,mes$
IF state&
@showm
ENDIF
CLR x&,y&,dep&,mes$,state&
RETURN
> PROCEDURE cpt(t&,i&,dep&,fin&,pause&,stp&,VAR nummer&)  ! GŠre compteur
DEC stp&
icone(ADD(t&,25),i&,ADD(t&,75),ADD(i&,9),46)
icone(t&,i&,ADD(t&,24),ADD(i&,9),45)
icone(ADD(t&,76),i&,ADD(t&,98),ADD(i&,9),45)
CLR t&,i&,dep&,fin&,pause&,stp&
RETURN
> PROCEDURE gercpt                                        ! GŠre compteur
LOCAL z&
k&=@mousek
IF xh&=t&
IF k&=2
IF nummer&>dep&
DEC nummer&
ENDIF
atm0
ELSE
IF nummer&>=ADD(dep&,stp&)
SUB nummer&,stp&
ENDIF
ENDIF
ELSE
IF k&=2
IF nummer&<fin&
INC nummer&
ENDIF
atm0
ELSE
IF nummer&=<SUB(fin&,stp&)
ADD nummer&,stp&
ENDIF
ENDIF
ENDIF
FOR z&=FALSE TO pause&
@vs
NEXT z&
@hide
ATEXT ADD(t&,32),ADD(i&,3),FALSE,STR$(nummer&)+SPACE$(SUB(5,LEN(STR$(nummer&))))
@showm
k&=FALSE
CLR z&
RETURN
> PROCEDURE 46                            ! GŠre compteur
vide$=""
nummer&=MIN(MAX(@input(1,1,FALSE,3,vide$),dep&),fin&)
ATEXT ADD(t&,32),ADD(i&,3),FALSE,STR$(nummer&,5)
RETURN
> FUNCTION input(x1&,y1&,nb&,lim&,VAR nom$) ! Entr‚e clavier ‚tendue
LOCAL x2&,y2&,t&,curs&,tch&,state&,al$,k&,state2&
IF curson&
@hide
state&=TRUE
ENDIF
IF on&
inter_off
state2&=TRUE
ENDIF
GET SHL&(SUB(x1&,1),3),SHL&(SUB(y1&,1),3),319,SHL&(y1&,3),al$
tch&=FALSE
curs&=FALSE
ARRAYFILL plx&(),32
FOR t&=1 TO MIN(LEN(nom$),ADD(lim&,1))
plx&(SUB(t&,1))=ASC(MID$(nom$,t&,1))
NEXT t&
HIDEM
REPEAT
nom$=""
FOR t&=FALSE TO lim&
nom$=nom$+CHR$(plx&(t&))
NEXT t&
PRINT AT(x1&,y1&);nom$;
PRINT CHR$(27)+"e";
PRINT AT(ADD(curs&,x1&),y1&);
tch&=INP(2)
PRINT CHR$(27)+"f";
IF nb&
t&=TRUE
SELECT tch&
CASE 32 TO 47,58 TO 126
INSERT plx&(curs&)=tch&
t&=FALSE
CASE 203
IF curs&>FALSE
DEC curs&
ENDIF
CASE 205
t&=FALSE
CASE 226
REPEAT
MOUSE x2&,y2&,k&
x2&=ADD(ROUND(x2&*0.6968),32)
PRINT AT(ADD(curs&,x1&),y1&);CHR$(x2&);
UNTIL k&
INSERT plx&(curs&)=x2&
t&=FALSE
ENDSELECT
IF t&=FALSE
IF curs&<lim&
INC curs&
ENDIF
ENDIF
ENDIF
SELECT tch&
CASE 8
IF curs&>FALSE
DEC curs&
plx&(ADD(lim&,1))=32
DELETE plx&(curs&)
ENDIF
CASE 27
ARRAYFILL plx&(),32
curs&=FALSE
CASE 48 TO 57
INSERT plx&(curs&)=tch&
IF curs&<lim&
INC curs&
ENDIF
CASE 127
plx&(ADD(lim&,1))=32
DELETE plx&(curs&)
ENDSELECT
UNTIL tch&=13
PUT SHL&(SUB(x1&,1),3),SHL&(SUB(y1&,1),3),al$
IF state2&
inter_on
ENDIF
IF state&
@showm
ENDIF
CLR t&,x1&,y1&,x2&,y2&,curs&,tch&,state&,al$,k&,state2&
IF nb&
RETURN TRUE
ELSE
RETURN VAL(nom$)
ENDIF
ENDFUNC
> PROCEDURE necho                         ! Vide buffer clavier
REPEAT
IF @inp_
~@inp
ENDIF
UNTIL @inp_=FALSE
RETURN
> PROCEDURE 10                            ! Drapeau de sortie … vrai
ext&=TRUE
RETURN
> PROCEDURE vide_clv                      ! Vide le buffer clavier du systŠme
LOCAL t%
t%=XBIOS(14,1)
INT{ADD(t%,6)}=INT{ADD(t%,8)}
IF NOT TT?
SLPOKE ADD(XBIOS(&H22),&H6C),FALSE
ENDIF
CLR t%
RETURN
'
> PROCEDURE ms                            ! RelŠve les coords souris avec gestø shifts
x&=CARD{table%}
y&=CARD{ADD(table%,2)}
k&=CARD{ADD(table%,8)}
IF @btc(FALSE)
CARD{ADD(table%,22)}=FALSE
ELSE
CARD{ADD(table%,22)}=TRUE
ENDIF
IF @btc(1)
CARD{ADD(table%,24)}=FALSE
ELSE
CARD{ADD(table%,24)}=TRUE
ENDIF
IF OR(k&=1,k&=2)
k&=AND(NOT k&,3)
ENDIF
RETURN
> PROCEDURE setmo(x&,y&)                  ! Fixe la souris sur une position
CARD{table%}=x&
CARD{ADD(table%,2)}=y&
RETURN
> PROCEDURE clipmo(x1&,y1&,x2&,y2&)       ! Clip souris (limite mvts souris)
CARD{ADD(table%,26)}=x1&
CARD{ADD(table%,28)}=y1&
CARD{ADD(table%,30)}=x2&
CARD{ADD(table%,32)}=y2&
IF NOT @rectst(CARD{table%},CARD{ADD(table%,2)},x1&,y1&,x2&,y2&)
CARD{table%}=MAX(MIN(CARD{table%},x2&),x1&)
CARD{ADD(table%,2)}=MAX(MIN(CARD{ADD(table%,2)},y2&),y1&)
ENDIF
CLR x1&,y1&,x2&,y2&
RETURN
> PROCEDURE ms2                           ! RelŠve les coords souris
x&=CARD{table%}
y&=CARD{ADD(table%,2)}
k&=CARD{ADD(table%,8)}
CARD{ADD(table%,22)}=TRUE
CARD{ADD(table%,24)}=TRUE
IF OR(k&=1,k&=2)
k&=AND(NOT k&,3)
ENDIF
RETURN
> PROCEDURE move2                         ! Attend mouvement ou tch avec gestø shifts
necho
REPEAT
UNTIL OR(OR(OR(x&<>CARD{table%},y&<>CARD{ADD(table%,2)}),k&<>@mousek),@inp_)
RETURN
> PROCEDURE mouseoff                      ! Souris off
OUT 4,18
RETURN
> PROCEDURE mouseon                       ! Souris on
OUT 4,8
RETURN
> PROCEDURE atm0                          ! Attend relachement click souris
IF k&
IF on&
REPEAT
UNTIL CARD{ADD(table%,8)}=FALSE
ELSE
REPEAT
UNTIL MOUSEK=FALSE
ENDIF
ENDIF
RETURN
> PROCEDURE atm                           ! Attend click souris
REPEAT
UNTIL CARD{ADD(table%,8)}
RETURN
> PROCEDURE defmo(a%,x&,y&)               ! Redef curseur souris (non systeme)
BMOVE a%,mouse%,64
CARD{ADD(table%,42)}=x&
CARD{ADD(table%,44)}=y&
CLR a%,x&,y&
RETURN
> PROCEDURE echo_off
WHILE @inp_
~@inp
WEND
RETURN
'
> PROCEDURE r                             ! Rien
RETURN
> PROCEDURE crds(x1&,y1&,x2&,y2&,VAR x&,y&)
IF x&<x1&
x&=x1&
ELSE IF x&>x2&
x&=x2&
ENDIF
IF y&<y1&
y&=y1&
ELSE IF y&>y2&
y&=y2&
ENDIF
CLR x1&,y1&,x2&,y2&
RETURN
> PROCEDURE crds2(x1&,y1&,x2&,y2&,VAR x&,y&)
LOCAL k&
IF x&<x1&
x&=x1&
k&=TRUE
ELSE IF x&>x2&
x&=x2&
k&=TRUE
ENDIF
IF y&<y1&
y&=y1&
k&=TRUE
ELSE IF y&>y2&
y&=y2&
k&=TRUE
ENDIF
IF k&
setmo(x&,y&)
ENDIF
CLR x1&,y1&,x2&,y2&,k&
RETURN
> PROCEDURE eff(deb%,l%)                  ! Efface une zone m‚moire
~C:eff%(L:deb%,L:l%)
CLR deb%,l%
RETURN
> PROCEDURE def1                          ! Mode ligne normale
DEFLINE 1,1,FALSE,FALSE
RETURN
> PROCEDURE def2                          ! Mode ligne pointill‚e
COLOR 1
DEFLINE -52428,1,FALSE,FALSE
RETURN
> PROCEDURE defx                          ! Mode texte pour affichage sur boites
DEFTEXT 6,1,,4
RETURN
> PROCEDURE clv                           ! Gestion clavier (raccourcis...)
LOCAL al$,state&
IF @inp_
phy(ecran%)
IF curson&
state&=TRUE
@hide
ENDIF
tch&=@inp
SELECT act&(tch&)
CASE 62 TO 64
IF pan&
ordo&=MUL(SUB(act&(tch&),62),50)
reput
IF otl&=3
reaf(TRUE)
ENDIF
ENDIF
CASE 60
ctrlpal
CASE 2                              ! Prend couleur sur ecran
IF otl&<>13
@hide
c&=PTST(x&,y&)
IF pan&
ppal(c&)
ELSE
ctrlpal
ENDIF
ENDIF
@showm
CASE 11 TO 16                       ! Change ecran
@hide
cursec&=SUB(act&(tch&),11)
changec
IF pan&
normoutil
ENDIF
IF otl&=3
reaf(FALSE)
ENDIF
@showm
CASE 17 TO 33                       ! Change outil
IF AND(otl&=3,SUB(act&(tch&),17)<>3)
reput
ENDIF
otl&=SUB(act&(tch&),17)
IF @btc(2)
SELECT otl&
CASE 2,7 TO 10
fld&=TRUE
DEFAULT
fld&=FALSE
ENDSELECT
ELSE
fld&=otl&=2
ENDIF
exit&=1
IF pan&
normoutil
ELSE
GET FALSE,FALSE,319,7,al$
ATEXT FALSE,FALSE,FALSE,@fixoutil$(@rd$(3,otl&))
phytchoff
PUT FALSE,FALSE,al$
ENDIF
CASE 34 TO 43
controloutil
normoutil
IF otl&=3
reaf(FALSE)
ENDIF
CASE 1                                      ! Retour panneau
IF NOT pan&
exit&=TRUE
ELSE
exit&=-3
ENDIF
CASE 3 TO 10                                ! Go to fontions
exit&=-2
action&=SUB(act&(tch&),2)
CASE 44 TO 59                               ! Change couleur
c&=SUB(act&(tch&),44)
IF pan&
ppal(c&)
ELSE
ctrlpal
ENDIF
CASE 0                                      ! Undo
affund
ENDSELECT
IF state&
@showm
ENDIF
IF @btc(21)
phy(noclip%)
ENDIF
ENDIF
CLR al$,state&
RETURN
> PROCEDURE controloutil
LOCAL j&
j&=SUB(act&(tch&),34)
SELECT otl&
CASE 15
SELECT j&
CASE 0
FOR j&=FALSE TO 15
crap&(j&)=MIN(ADD(j&,1),15)
NEXT j&
CASE 1
FOR j&=FALSE TO 15
crap&(j&)=MAX(SUB(j&,1),FALSE)
NEXT j&
CASE 9
ARRAYFILL crap&(),TRUE
ENDSELECT
CASE 14
SELECT j&
CASE 0
sens1&=NOT sens1&
CASE 1
sens2&=NOT sens2&
CASE 2
sens3&=NOT sens3&
CASE 3
sens4&=NOT sens4&
CASE 4
ent&=MOD(ADD(ent&,11),12)
CASE 5
ent&=MOD(ADD(ent&,1),12)
ENDSELECT
CASE 12
SELECT j&
CASE 0 TO 4
SELECT j&
CASE 0,1,3
styl&=BCHG(styl&,j&)
DEFAULT
IF NOT BTST(styl&,SUB(6,j&))
styl&=BCHG(styl&,j&)
ENDIF
ENDSELECT
CASE 6
tsiz&=ADD(MOD(ADD(SUB(tsiz&,4),1),29),4)
CASE 5
tsiz&=ADD(MOD(ADD(SUB(tsiz&,4),28),29),4)
CASE 7
vide$=""
tsiz&=MIN(MAX(@input(1,1,FALSE,3,vide$),4),32)
ENDSELECT
CASE 6
SELECT j&
CASE 0
pinc&=MOD(ADD(pinc&,11),12)
CASE 1
pinc&=MOD(ADD(pinc&,1),12)
CASE 2
pincmono&=NOT pincmono&
CASE 3
half&=NOT half&
ENDSELECT
CASE 5
SELECT j&
CASE 0
multia&=NOT multia&
CASE 1
forme&=NOT forme&
CASE 2
tempaero&=ADD(MOD(ADD(SUB(tempaero&,1),19),20),1)
CASE 3
tempaero&=ADD(MOD(ADD(SUB(tempaero&,1),1),20),1)
CASE 4
vide$=""
tempaero&=MIN(MAX(@input(1,1,FALSE,3,vide$),1),20)
ENDSELECT
CASE 3
SELECT j&
CASE 0 TO 2
grp&=j&
CASE 3 TO 5
lasso&=SUB(j&,3)
CASE 6
take&=NOT take&
CASE 7
BMOVE blk%,ado%,32000
eff(blk%,32000)
RC_COPY ado%,FALSE,FALSE,lgb&,htb& TO blk%,FALSE,FALSE
redim(blk%)
RC_COPY blk%,x1&,y1&,lgb&,htb& TO blk%,FALSE,FALSE
mask
IF open&
ADD sx&,x1&
ADD sy&,y1&
ENDIF
CASE 8
mod(FALSE)
ENDSELECT
CASE 1,2,7 TO 11
IF fld&
SELECT j&
CASE 0
xtram&=MOD(ADD(xtram&,11),12)
CASE 1
xtram&=MOD(ADD(xtram&,1),12)
CASE 2
plein&=NOT plein&
CASE 3
fill&=NOT fill&
ENDSELECT
ELSE
SELECT j&
CASE 0
debli&=MOD(ADD(debli&,1),3)
CASE 1
endli&=MOD(ADD(endli&,1),3)
CASE 2 TO 4
line&=SUB(j&,2)
CASE 5
htline&=AND(ADD(htline&,15),15)
CASE 6
htline&=AND(ADD(htline&,1),15)
CASE 9
htline&=FALSE
debli&=FALSE
endli&=FALSE
line&=FALSE
ENDSELECT
ENDIF
CASE 3
ENDSELECT
CLR j&
RETURN
> FUNCTION fixoutil$(a$)
IF AND(fld&,otl&<>2)
SELECT lang&
CASE 1
a$="FILLED "+a$
CASE 0
a$=a$+" PLEIN"
IF otl&=9
a$=a$+"E"
ENDIF
CASE 2
a$=a$+" GEFšLLT"
ENDSELECT
ENDIF
RETURN a$
ENDFUNC
> PROCEDURE phytchoff
OUT 4,18
tch&=PEEK(&HFFFC02)
REPEAT
UNTIL PEEK(&HFFFC02)<>tch&
OUT 4,8
RETURN
> PROCEDURE ctrlpal
LOCAL al$
IF NOT pan&
GET FALSE,100,319,109,al$
ppal(c&)
phytchoff
PUT FALSE,100,al$
CLR al$
ENDIF
RETURN
> PROCEDURE affund                        ! Affiche le undo (en ‚changeant les ‚crans)
IF AND(otl&=3,open&)
open&=FALSE
ENDIF
IF OR(NOT pane&,otl&=4)
~C:gund%(L:ec%(ec&),L:undo%,W:199)
ELSE
~C:gund%(L:ADD(ec%(ec&),MUL(ordo&,160)),L:ADD(undo%,MUL(ordo&,160)),W:99)
ENDIF
reput
RETURN
> PROCEDURE ppal(c&)                      ! Affiche la barre palette
LOCAL state&
IF curson&
state&=TRUE
@hide
ENDIF
BMOVE pan%,ADD(ecran%,16000),1600
PUT ADD(MUL(c&,20),4),102,cl$
IF state&
@showm
ENDIF
CLR c&,state&
RETURN
> PROCEDURE note(mode&)                   ! Reprend l'image de travail
LOCAL state&
IF curson&
state&=curson&
@hide
ENDIF
BMOVE ec%(ec&),undo%,32000
IF pan&
BMOVE ecran%,ADD(ec%(ec&),MUL(ordo&,160)),16000
ELSE
BMOVE ecran%,ec%(ec&),32000
ENDIF
IF state&
@showm
ENDIF
savd&(ec&)=OR(savd&(ec&),mode&)
CLR state&,mode&
RETURN
> PROCEDURE reput                         ! R‚affiche image de travail
LOCAL state&
state&=curson&
IF curson&
@hide
ENDIF
IF pan&
BMOVE ADD(ec%(ec&),MUL(ordo&,160)),ecran%,16000
ELSE
BMOVE ec%(ec&),ecran%,32000
ENDIF
IF state&
@showm
ENDIF
CLR state&
RETURN
> PROCEDURE path(a$)                      ! Mise auto des extension fichiers
l&=RINSTR(fich$,".")
l2&=RINSTR(fich$,"\")
IF AND(l&,l&>l2&)
fich$=MID$(fich$,1,l&)+a$
ELSE
fich$=fich$+"."+a$
ENDIF
CLR a$
RETURN
> PROCEDURE phy(adr%)                     ! Fixe phybase
SPOKE &HFF8201,SWAP(AND(adr%,&HFF0000))
SPOKE &HFF8203,SHR(AND(adr%,&HFF00),8)
CLR adr%
RETURN
'
> PROCEDURE defill                        ! Active les param‚trages remplissage
IF plein&
IF fill&
trame$=""
FOR t%=V:tram$(xtram&) TO ADD(V:tram$(xtram&),30) STEP 2
trame$=trame$+MKI$(OR(OR(INT{t%},INT{ADD(t%,32)}),OR(INT{ADD(t%,64)},INT{ADD(t%,96)})))
NEXT t%
DEFFILL col&(c&),trame$
ELSE
DEFFILL 1,tram$(xtram&)
ENDIF
DEFFILL ,4
ELSE
DEFFILL col&(c&),2,8
ENDIF
RETURN
> PROCEDURE defln                         ! Active les param‚trages ligne
IF fld&
defill
def1
ELSE
IF line&=FALSE
DEFLINE FALSE,ADD(AND(MUL(htline&,2),htline&>2),AND(htline&<3,ADD(MUL(htline&,2),1))),debli&,endli&
ELSE
DEFLINE -line%(SUB(line&,1)),1,debli&,endli&
ENDIF
ENDIF
RETURN
'
> PROCEDURE lib                           ! Lib‚ration de la m‚moire et fin
' OPEN "o",#1,"e:\code\synthy.art\curent\ext.ess\def_clv.bin"
' BPUT #1,V:act&(FALSE),242
' BPUT #1,V:bt&(FALSE),80
' CLOSE #1
'
~MFREE(buffer%)
inter_off
IF C:tstmega%()
SPOKE &HFFFF8E21,oldhz&
ENDIF
VSYNC
FOR t&=FALSE TO 15
SDPOKE ADD(&HFFFF8240,SHL&(t&,1)),sauv&(t&)
NEXT t&
~XBIOS(5,L:oldecran%,L:oldecran%,W:TRUE)
mouseon
SPOKE &H484,oldclv&
' BLOAD "e:\code\synthy.art\curent\fichiers.inl\inters2.inl",inter%
' BLOAD "e:\code\synthy.art\curent\col.inl",pan%
EDIT
RETURN
> PROCEDURE mist                          ! Traitements des erreurs
er&=ERR
'
IF openf&
CLOSE #1
openf&=FALSE
IF er&=37
KILL fich$
ENDIF
ENDIF
'
necho
inter_on
necho
raster(MKL$(old%))
mouseon
'
SELECT er&
CASE -33
a$=@rd$(41,FALSE)
CASE 37
a$=@rd$(41,1)
CASE -8 TO -2,-10,-11,-36 TO -13
a$=@rd$(41,2)
DEFAULT
a$=@rd$(41,3)+STR$(er&)
ENDSELECT
IF er&<>-13
~@alt(TRUE,112,a$,"    Ok    ",FALSE)
ENDIF
RESUME deb
'
RETURN
> PROCEDURE load(a$,adr2%,charg2&,VAR fat$) ! Fonction load (fichiers internes)
LOCAL lenght%,t%,l%,al$
'
IF NOT EXIST("ART_LGHT.DAT")          ! On v‚rifie la pr‚sence de art_lght.dat
REPEAT
vide$="ART_LGHT.DAT"
al$=mainpath$+"*.DAT"
select(lst%,al$,vide$)
mainpath$=LEFT$(al$,RINSTR(al$,"\"))
al$=LEFT$(mainpath$,1)
IF AND(al$>="A",al$=<"Z")
CHDRIVE al$+":"
ENDIF
CHDIR mainpath$
UNTIL EXIST("ART_LGHT.DAT")
ENDIF
'
a$=CHR$(5)+TRIM$(UPPER$(MID$(a$,1,7)))
a$=a$+SPACE$(SUB(8,LEN(a$)))
openf&=TRUE
OPEN "i",#1,"ART_LGHT.DAT"            ! On charge
IF charg2&
fat$=SPACE$(1344)
BGET #1,V:fat$,1344
ENDIF
t%=V:fat$
l%=1344
FOR t%=t% TO ADD(t%,1332) STEP 12
lenght%={ADD(t%,8)}
EXIT IF a$=CHAR{t%}
ADD l%,lenght%
NEXT t%
IF t%<>ADD(V:al$,1344)
RELSEEK #1,SUB(l%,AND(charg2&,1344))
BGET #1,adr2%,lenght%
ENDIF
CLOSE #1
openf&=FALSE
'
CLR l%,lenght%,a$,al$,adr2%,t%,charg2&
'
RETURN
> PROCEDURE sensmo(sens&)                 ! Fixe la sensibilit‚ de la souris
CARD{ADD(table%,34)}=sens&
CARD{ADD(table%,36)}=sens&
CLR sens&
RETURN
'
' FONCTIONS
'
> FUNCTION rd$(a&,b&)                     ! Fonction READ (gestion messages)
LOCAL i%,a$
i%=message%
ADD i%,CARD{ADD(i%,SHL(a&,1))}
a&=CARD{ADD(ADD(i%,2),SHL(b&,2))}
ADD i%,CARD{ADD(i%,SHL(b&,2))}
FOR b&=1 TO a&
a$=a$+CHR$(BYTE{i%})
INC i%
NEXT b&
CLR i%,a&,b&
RETURN a$
ENDFUNC
> FUNCTION alt(x1&,y1&,lin$,but$,ac&)     ! Boite d'alerte
'
LOCAL x&,y&,haut&,larg&,lgbut&,t&,i&,j&,k&,nb&,a$,state&,oldsens&,ms$,state2&,al$
'
IF on&=FALSE
inter_on
state2&=TRUE
ENDIF
'
ms$=SPACE$(64)
BMOVE mouse%,V:ms$,64
defmo(V:mouse$,hotpx&,hotpy&)
oldsens&=CARD{ADD(table%,34)}
sensmo(ADD(smopanel&,1))
mouseon                       ! Reinitialise la souris
IF curson&
@hide
state&=TRUE
ENDIF
totalc                        ! et le clip line A au cas ou
'
larg&=150                     ! largeur min
haut&=40                      ! hauteur min
j&=20
FOR t&=1 TO LEN(lin$)         ! D‚termination de la largeur
IF MID$(lin$,t&,1)="|"
j&=20
ADD haut&,7
ENDIF
ADD j&,6
larg&=MAX(larg&,j&)
NEXT t&
'
j&=FALSE
FOR t&=1 TO LEN(but$)        ! Determination largeur des bouttons
FOR i&=t& TO LEN(but$)     ! nombre de bouttons et largeur couverte
EXIT IF MID$(but$,i&,1)="|"
NEXT i&
j&=MAX(j&,SUB(i&,t&))
IF i&<>ADD(LEN(but$),1)
INC nb&
t&=i&
ENDIF
NEXT t&
lgbut&=ADD(MUL(j&,6),10)      ! Largeur boutton
larg&=MAX(larg&,ADD(MUL(ADD(nb&,1),ADD(lgbut&,5)),10)) !=> largeur boite
larg&=MIN(larg&,319)
'
IF x1&=TRUE                   ! Si x=-1: centrage automatique horizontal
x1&=SHR(SUB(320,larg&),1)
ENDIF
IF y1&=TRUE                   ! Si y=-1: centrage automatique vertical
y1&=SHR(SUB(200,haut&),1)
ENDIF
'
GET x1&,y1&,ADD(x1&,larg&),ADD(y1&,haut&),al$  ! Sauve bitmap avant affichage
deic2(x1&,y1&,ADD(x1&,larg&),ADD(y1&,haut&))
'
GRAPHMODE 2
defx
'
j&=ADD(y1&,8)
FOR t&=1 TO LEN(lin$)         ! Affichage text
FOR i&=t& TO LEN(lin$)
EXIT IF MID$(lin$,i&,1)="|"
NEXT i&
a$=MID$(lin$,t&,SUB(i&,t&))
TEXT ADD(SHR(SUB(larg&,MUL(LEN(a$),6)),1),x1&),j&,a$
t&=i&
ADD j&,7
NEXT t&
'
j&=ADD(x1&,5)
haut&=SUB(ADD(y1&,haut&),15)
'
FOR t&=FALSE TO nb&
resx(j&,haut&,ADD(j&,lgbut&),ADD(haut&,10))
IF t&=ac&
resx(SUB(j&,1),SUB(haut&,1),ADD(ADD(j&,1),lgbut&),ADD(haut&,11))
ENDIF
IF t&=nb&
i&=ADD(LEN(but$),1)
ELSE
i&=INSTR(but$,"|")
ENDIF
a$=LEFT$(but$,SUB(i&,1))
TEXT ADD(j&,SHR(SUB(lgbut&,MUL(LEN(a$),6)),1)),ADD(haut&,7),a$
IF t&<>nb&
but$=RIGHT$(but$,SUB(LEN(but$),i&))
ENDIF
ADD j&,ADD(lgbut&,5)
NEXT t&
'
GRAPHMODE 1
'
@showm
'
j&=FALSE
REPEAT
ms2
FOR t&=FALSE TO nb&
i&=ADD(ADD(x1&,5),MUL(t&,ADD(lgbut&,5)))
icone(i&,haut&,ADD(i&,lgbut&),ADD(haut&,10),10)
IF t&=ac&
IF @inp_
j&=@inp
ENDIF
ENDIF
IF ext&
appx(i&,haut&,ADD(i&,lgbut&),ADD(haut&,10))
REPEAT
ms2
UNTIL OR(k&=FALSE,@rectst(x&,y&,i&,haut&,ADD(i&,lgbut&),ADD(haut&,10))=FALSE)
IF k&
resx(i&,haut&,ADD(i&,lgbut&),ADD(haut&,10))
ext&=FALSE
ENDIF
ENDIF
EXIT IF ext&
NEXT t&
UNTIL OR(ext&,OR(j&=28,j&=114))
'
necho
atm0
'
@hide
PUT x1&,y1&,al$       ! Restaure ecran
IF state&
@showm
ENDIF
sensmo(oldsens&)
BMOVE V:ms$,mouse%,64
IF state2&
inter_off
ENDIF
'
CLR x&,y&,haut&,larg&,lgbut&,i&,j&,al$,x1&,y1&,k&,nb&,ac&,but$,lin$,ext&,a$,state&,oldsens&,ms$,state2&
'
RETURN t&
'
ENDFUNC
> FUNCTION pop_up(x1&,y1&,mes&,nb&,sens&,title$,mode&,old&)  ! Menu pop up
'
LOCAL t&,lg&,aux&,selec&,al$,x2&,y2&,ext&
'
@hide
IF sens&=FALSE                        ! Si sens&=0 : d‚terminatø auto du
sens&=ADD(MUL(y1&>100,2),1)         ! sens de d‚roulement du menu
ENDIF
FOR t&=FALSE TO SUB(nb&,1)            ! D‚termine la largeur du menu d'aprŠs
lg&=MAX(lg&,ADD(MUL(LEN(@rd$(mes&,t&)),SUB(8,AND(sens&,2))),10)) ! les largeurs des textes
NEXT t&
lg&=MAX(lg&,ADD(MUL(LEN(title$),SUB(8,AND(sens&,2))),10)) ! les largeurs des textes
x2&=ADD(x1&,lg&)                      ! Coords max de la boite
SUB lg&,2
y2&=ADD(y1&,MUL(sens&,ADD(MUL(nb&,ADD(10,AND(mode&,5))),18)))
IF y1&>y2&
SWAP y1&,y2&
ENDIF
'
GET x1&,y1&,x2&,y2&,al$               ! On sauve le bitmap
'
IF mode&
deic2(x1&,y1&,x2&,y2&)                ! Boite principale
defx                                  ! Mode texte
GRAPHMODE 2                           ! Mode d'affichage pour le texte
ELSE
deic(x1&,y1&,x2&,y2&,FALSE)
ENDIF
'
FOR t&=FALSE TO SUB(nb&,1)            ! Affichage des boutons
selec&=@calcpos(t&)
IF mode&
appx(ADD(x1&,2),SUB(selec&,1),ADD(x1&,lg&),ADD(selec&,15))
deic2(ADD(x1&,2),selec&,ADD(x1&,lg&),ADD(selec&,14))
TEXT ADD(x1&,6),ADD(selec&,10),@rd$(mes&,t&)
ELSE
ATEXT ADD(x1&,5),ADD(selec&,1),1,@rd$(mes&,t&)
ENDIF
NEXT t&
IF mode&
TEXT ADD(SHR(SUB(lg&,MUL(LEN(title$),6)),1),x1&),SUB(ADD(selec&,AND(sens&=1,25)),AND(sens&=TRUE,6)),title$
GRAPHMODE 1                         ! Mode graphmode normal
ELSE
ATEXT ADD(SHR(SUB(lg&,SHL(LEN(title$),3)),1),x1&),SUB(ADD(selec&,AND(sens&=1,14)),AND(sens&=TRUE,11)),1,title$
ENDIF
'
selec&=TRUE                           ! Init s‚lection
@showm
REPEAT
ms2
IF k&=FALSE
FOR t&=FALSE TO SUB(nb&,1)
aux&=@calcpos(t&)
EXIT IF @rectst(x&,y&,x1&,aux&,x2&,ADD(aux&,ADD(9,AND(mode&,5))))
NEXT t&
IF t&<>nb&
ext&=1
selec&=t&
ELSE
ext&=TRUE
ENDIF
ELSE
FOR t&=FALSE TO SUB(nb&,1)
aux&=@calcpos(t&)
EXIT IF @rectst(x&,y&,x1&,aux&,x2&,ADD(aux&,ADD(9,AND(mode&,5))))
NEXT t&
IF t&<>nb&
IF selec&<>t&
@hide
IF selec&<>TRUE
aux&=@calcpos(selec&)
IF mode&
resx(ADD(x1&,2),aux&,ADD(x1&,lg&),ADD(aux&,14))
ELSE
arec(ADD(x1&,2),aux&,ADD(x1&,lg&),ADD(aux&,9),15,2)
ENDIF
ENDIF
aux&=@calcpos(t&)
IF mode&
appx(ADD(x1&,2),aux&,ADD(x1&,lg&),ADD(aux&,14))
ELSE
arec(ADD(x1&,2),aux&,ADD(x1&,lg&),ADD(aux&,9),15,2)
ENDIF
@showm
selec&=t&
ENDIF
ELSE IF selec&<>TRUE
aux&=@calcpos(selec&)
@hide
IF mode&
resx(ADD(x1&,2),aux&,ADD(x1&,lg&),ADD(aux&,14))
ELSE
arec(ADD(x1&,2),aux&,ADD(x1&,lg&),ADD(aux&,9),15,2)
ENDIF
@showm
selec&=TRUE
ENDIF
ENDIF
UNTIL ext&
'
@hide
PUT x1&,y1&,al$                       ! Restore bitmap
@showm
'
CLR t&,lg&,aux&,x1&,y1&,x2&,y2&,sens&,mes&,al$,title$,mode&
'
IF ext&=TRUE                          ! Retourne les valeurs
RETURN old&
ELSE
RETURN selec&
ENDIF
'
ENDFUNC
> FUNCTION calcpos(elem&)                 ! Sous pcd pour pop_up
RETURN ADD(MAX(y1&,MUL(-sens&,y2&)),MUL(sens&,ADD(MUL(ADD(elem&,-(sens&=TRUE)),ADD(10,AND(mode&,5))),3)))
ENDFUNC
> FUNCTION rectst(x&,y&,x1&,y1&,x2&,y2&)  ! Rec intersec
RETURN NOT OR(OR(x&<x1&,x&>x2&),OR(y&<y1&,y&>y2&))
ENDFUNC
> FUNCTION mousek                         ! Renvoie l'‚tat des boutons souris
LOCAL k&
k&=CARD{ADD(table%,8)}
IF OR(k&=1,k&=2)
k&=AND(NOT k&,3)
ENDIF
RETURN k&
ENDFUNC
'
' PROCEDURE loadinl
' BLOAD "e:\code\synthy.art\curent\fichiers.inl\repl.inl",rempl%
' BLOAD "e:\code\synthy.art\curent\fichiers.inl\reduct.inl",retrc%
' BLOAD "e:\code\synthy.art\curent\fichiers.inl\pan.inl",codes%
' BLOAD "e:\code\synthy.art\curent\fichiers.inl\decomp.inl",decom%
' BLOAD "e:\code\synthy.art\curent\fichiers.inl\testdeg.inl",degtst%
' BLOAD "e:\code\synthy.art\curent\fichiers.inl\redim.inl",redim%
' BLOAD "e:\code\synthy.art\curent\fichiers.inl\loupe.inl",lpx%
' BLOAD "e:\code\synthy.art\curent\fichiers.inl\gundo.inl",gund%
' BLOAD "e:\code\synthy.art\curent\fichiers.inl\mask.inl",mask%
' BLOAD "e:\code\synthy.art\curent\fichiers.inl\eff.inl",eff%
' BLOAD "e:\code\synthy.art\curent\fichiers.inl\degrade.inl",degrad%
' BLOAD "e:\code\synthy.art\curent\fichiers.inl\anti.inl",anti%
' BLOAD "e:\code\synthy.art\curent\fichiers.inl\over.inl",over%
' BLOAD "e:\code\synthy.art\curent\fichiers.inl\testmega.inl",tstmega%
' BLOAD "e:\code\synthy.art\curent\fichiers.inl\relocat.inl",reloc%
' BLOAD "e:\code\synthy.art\curent\fichiers.inl\inters.inl",inter%
' BLOAD "e:\code\synthy.art\curent\fichiers.inl\ptst.inl",ptst%
' RETURN
