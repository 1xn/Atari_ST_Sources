
                Title...........: EXTRA Version 1.00
                Author..........: Martin Cubitt
                Date written....: 9th February 1993
                Description.....: An extension to STOS BASIC.
        
------------------------------------------------------------------------------
        
                        Modification List
                        =================

                Title...........: EXTRA Version 1.01
                Programmer......: Martin Cubitt
                Date............: 19th February 1993
                Description.....: Power command fixed to work (for reasonable
                                  values!)


                Title...........: EXTRA Version 1.02
                Programmer......: Martin Cubitt
                Date............: 21st February 1993
                Description.....:  1) 'extra' command bug fixed when Control+C
                                  was pressed.
                                   2) 'cartridge input' command bug fixed
                                  when value stored in variable.
        
                Title...........: EXTRA Version 1.03
                Programmer......: Martin Cubitt
                Date............: 25th June 1993
                Description.....:  1) 'extra' command changed to allow text to
                                  roll with key press mid-point.
                                   2) 'disc size' function added.
              
                Title...........: EXTRA Version 1.04
                Programmer......: Martin Cubitt
                Date............: 29th June 1993
                Description.....:  1) 'gemdos version$' command fixed to give
                                  correct gemdos version not the hex value of
                                  it, ie 0.15 now reads 0.21 (correct).

                Title...........: EXTRA Version 1.10
                Programmer......: Martin Cubitt
                Date............: 2nd July 1993
                Description.....:  1) 'depack tiny' command added
                                   2) 'disc used' function added
                                   3) 'disc free' function added
                                   4) 'disc size' function amended

                Title...........: EXTRA Version 1.11
                Programmer......: Martin Cubitt
                Date............: 4th July 1993
                Description.....:  1) 'ndrv' command bug fixed
                                  when value stored in variable.
   
                Title...........: EXTRA Version 1.20
                Programmer......: Martin Cubitt
                Date............: 10th July 1993
                Description.....:  1) 'drvmap' command removed due to fact
                                  it exists in STOS anyway - whoops!
                                   2) 'mem size' command added.
     
                Title...........: EXTRA Version 1.30
                Programmer......: Martin Cubitt
                Date............: 11th July 1993
                Description.....:  1) 'vtab' function added
                                   2) 'ltab' function added

                Title...........: EXTRA Version 1.40
                Programmer......: Martin Cubitt
                Date............: 16th July 1993
                Description.....:  1) 'blur' command added

                Title...........: EXTRA Version 1.50
                Programmer......: Martin Cubitt
                Date............: 17th July 1993
                Description.....:  1) 'convert iff' command added
                                   2) 'deshade' command added

                Title...........: EXTRA Version 1.51
                Programmer......: Martin Cubitt
                Date............: 21st July 1993
                Description.....:  1) 'deshade' command changed to include
                                  another parameter for which colour to
                                  ignore

                Title...........: EXTRA Version 1.60
                Programmer......: Martin Cubitt
                Date............: 21st July 1993
                Description.....:  1) 'set printer data' command added
                                   2) 'setup of printer' command added

                Title...........: EXTRA Version 1.61
                Programmer......: Martin Cubitt
                Date............: 22nd July 1993
                Description.....:  1) 'media status' command changed so that
                                  a word value is returned, not a longword
                                  value

                Title...........: EXTRA Version 1.70
                Programmer......: Martin Cubitt
                Date............: 25th July 1993
                Description.....:  1) 'depack degas' command added but not
                                  working - yet!
                                   2) 'blur' and 'deshade' commands changed
                                  to use improved code for plotting etc
                                   3) minor code efficiency alterations made
                                   4) 'blur' parameter sequence changed -
                                  Important - SEE BELOW!!!
                                   5) bug in compiler part of 'power'
                                  function fixed
                                   6) 'visible input$' function added at
                                  request of Tony Greenwood

                Title...........: EXTRA Version 1.80
                Programmer......: Martin Cubitt
                Date............: 8th August 1993
                Description.....:  1) 'blacken' command added
                                   2) 'whiten' command added
                                   3) 'pal inverse' command added
                                   4) 'fmt text' function added
                                   5) minor code efficiency alterations made

                Title...........: EXTRA Version 1.85
                Programmer......: Martin Cubitt
                Date............: 12th August 1993
                Description.....:  1) 'hertz change' command added

                Title...........: EXTRA Version 1.86
                Programmer......: Martin Cubitt
                Date............: 12th September 1993
                Description.....:  1) 'hertz change' command removed due to
                                  clash with missing link extension
                                   2) 'set screen hz' command replaces above
                                   3) 'screen hz' function added
                                   4) 'mem size' function removed because it
                                  did not give correct figure and also to make
                                  room for 'screen hz'
                                   NOTE: Due to STOS errors it was
                                  necessary to swap some commands around,
                                  you should re-enter the commands. Ones
                                  affected are 'whiten' and 'blacken'. I hope
                                  no more were affected! Sorry about that.

                Title...........: EXTRA Version 1.87
                Programmer......: Martin Cubitt
                Date............: 11th October 1993
                Description.....:  1) 'fmt text' command bug fixed where
                                  character codes were 10,13 but should have
                                  been 13,10.

                Title...........: EXTRA Version 1.90
                Programmer......: Martin Cubitt
                Date............:  6th November 1993
                Description.....:  1) 'depack degas' command removed due to
                                  fact that missing link ext. has it now.
                                   2) 'hrev' command added at request of
                                  Les Greenhalgh. This horizontally flips a
                                  string variable holding a screen$.
                                   3) 'opaque screen' command added at request
                                  of Les again. Same as screen$(screen)=var$
                                  but overwrites existing position on screen.

                Title...........: EXTRA Version 1.91
                Programmer......: Martin Cubitt
                Date............: 27th November 1993
                Description.....:  1) 'os version$' bug fixed.
                                   2) 'gemdos version$' bug fixed.

                Title...........: EXTRA Version 1.91a
                Programmer......: Martin Cubitt
                Date............: 27th November 1993
                Description.....:  1) string handling corrected but due to
                                  STOS bugs still need to handle strings
                                  carefully within your program. See
                                  comment at end of document.
                                   2) 'vrev' command added. As per 'hrev' but
                                  reverse image vertically. Cheers Les!
                                   3) 'setup of printer' bug fixed.
                                   4) 'hrev', 'vrev' and 'opaque screen'
                                  changed so that the string name is passed
                                  and not varptr(string name).
                                   5) some code improvement.

                Title...........: EXTRA Version 1.92
                Programmer......: Martin Cubitt
                Date............: 13th March 1994
                Description.....:  1) Minor code improvement.
                                   2) 'visible input$' function bug fixed.
                                   3) some cookie commands removed due to
                                      requirement for better and more
                                      useful commands.
                                      Those removed:
                                        _fdc
                                        _fpu
                                        _frb
                                        _swi
                                   4) 'disc spt' command added which returns
                                      the number of sectors per track on a
                                      disc.

                Title...........: EXTRA Version 2.00
                Programmer......: Martin Cubitt
                Date............:  2nd April 1994, 17th April 1994
                Description.....:  1) 'ppsc' command added. Thanks to Deano
                                      and Tony for their help in testing this
                                      command.
                                   2) 'desquash' command added. Allows data
                                      files packed with ICE 2.4 or 
                                      Atomik 3.5 to be unpacked.
                                   3) 'pload' command added. Allows partial
                                      loading of a file.
				   4) 'mem config' command added. Returns
				      memory configuration in Kilobytes,
				      so a 2 meg machine is 2048.
				   5) 'disable mouse' command added.
				   6) 'enable mouse' command added.

                Title...........: EXTRA Version 2.01
                Programmer......: Martin Cubitt
                Date............:  8th May 1994
                Description.....:  1) 'fmt disc' command compiler bug fixed
				      and extra parm added.
				   2) 'cpy disc' command compiler bug fixed
				      and extra parm added. Also copies
				      correct sectors/track - not only 9!

------------------------------------------------------------------------------

        The EXTRA extension gives you even more power when using STOS, and
includes some very powerful commands.

        Although the new commands have had some heavy duty testing nobody can
account for every possibility. If you find a bug let me know. Indeed, write to
me if you have any ideas for new commands. My 68000 programming is limited, I
am a BASIC man really, but I'll do my best! You may think that some of the new
commands could be modified or maybe some of them are totally useless. If
enough people say that a particular command is useless then I may consider
removing it to allow more space for a command which would be more useful. My
address can be found at the base of this document.


        The new commands in brief:-

        extra...........: Information
        lextra..........: Print information 
   L=fmt text(s,e,d,c,w): Format text
        gemdos version$.: GEMDOS version
        os version$.....: OS version
        power (A,B).....: A ^ B
        cartridge input.: Get incoming data
        cookie _cpu.....: Delve into cookie jar, return _cpu
        cookie _mch.....: Delve into cookie jar, return _mch
        cookie _snd.....: Delve into cookie jar, return _snd
        cookie _vdo.....: Delve into cookie jar, return _vdo
        left shift key..: Press=true,else false
        right shift key.: Press=true
        cntrl key.......: Press=true
        alt key.........: Press=true
        caps lock ......: True if on,else false
        caps lock on....: Set caps lock on
        caps lock off...: Set Caps lock off
        set printer data A: Configure printer to A
        setup of printer: Returns printer configuration data
        prntr...........: Printer on-line? t/f
        ndrv............: No. of drives
        media status....: Chk disc chg sts
        write protected.: Disc write-prot? t/f
        disc sides (A)..: No. sides on disc
        disc tracks (A).: No. tracks on disc
        disc spt(A).....: No. sectors/track
        disc verify on..: Set verify on
        disc verify off.: Set verify off
        disc size (A)...: Retrieve original size of disc
        disc free (A)...: Retrieve amount free on disc
        disc used (A)...: Retrieve actual amount used on disc
       fmt disc A,B,buff: Formats drive,nsides using buffer
       cpy disc A,B,buff: Copy A to B, using buffer
        screen dump.....: Print screen
        H=screen hz.....: Return screen Hz
        set screen hz...: Toggle screen Hz
        depack tiny A,B.: Depack tiny bank to other bank
        vtab (X)........: Tab to column on screen
        ltab (X)........: Tab to column on printer
        blur (8 parms)..: Blur portion of screen
        convert iff S,D,P: Convert uncompressed IFF image to normal
        whiten..........: Turn palette to white
        blacken.........: Turn palette to black
        pal inverse.....: Inverse palette
        deshade A,B,C...: Change colours not B to C in addr A
        hrev varptr(S$).: Horizontally flip screen
        vrev varptr(S$).: Vertically flip screen
    A$=visible input$(A): Input A number of characters into A$
   opaque screen s,x,y,v: Opaque version of screen$
        ppsc (parms)....: Pixel Perfect screen copy
        desquash addr...: Depack Ice 2.4/Atomik 3.5
       pload f$,addr,len: Partially load a file
	=mem config.....: Memory configuration
	disable mouse...: Turn off mouse
	enable mouse....: Turn on mouse


(t/f = true or false is returned as per STOS standard)


Total new commands in EXTRA = 56

------------------------------------------------------------------------------
        
        Breakdown of the new commands:-

        extra...........: Information
        
        Input:  none

        Output: none

                This command is provided for the programmer as a quick
        reminder of the format of a command. I think that all new extensions
        should provide this facility.

                Note that you must press a key to continue, this is to stop
        STOS scrolling up the text before you can read it all.

        E.g.
                 extra
        
------------------------------------------------------------------------------
 
        lextra..........: Print information 
        
        Input:  none

        Output: none
        
                This command will print out the format of the commands to your
        printer. A hard copy for your quick and easy reference.
        
        E.g.
                 lextra

------------------------------------------------------------------------------
        
        prntr...........: Printer on-line? t/f
                
        Input:  none

        Output: true (-1) or false (0)
        
                This returns a value true or false. If the printer is on-line
        then 'true' is returned, otherwise the result is false.

        E.g.
                 if prntr then lprint "Message"

                 10 if prntr then goto 40
                 20 print "Printer not connected"
                 30 end
                 40 lprint "Message"

                 if not(prntr) then print "Error, printer not on-line"

------------------------------------------------------------------------------
        
        screen dump.....: Print screen
        
        Input:  none

        Output: none
        
                Dumps the current screen onto your printer. Note that it does
        not take account of what resolution you are in or how your printer is
        set up. Therefore you should check this manually to ensure the
        desired result is achieved.

        E.g.
                 screen dump

                 10 if DUMP$="Y" then screen dump

------------------------------------------------------------------------------
        
        ndrv............: No. of drives
        
        Input:  none

        Output: Number of drives attached
        
                This returns the number of active drives attached to the
        system (not including the imaginary B drive on single drive systems).
        It has the value 0,1 or 2.

        E.g.
                 10 print "You have ";ndrv;" drives attached!"
        
------------------------------------------------------------------------------

        H=screen hz.....: Return screen Hz

        Input:  None

        Output: integer, 50 for 50Hz or 60 for 60Hz

                This function returns the current screen frequency based
on 50 - 50Hz and 60 - 60Hz. A normal television can only cope with 50Hz
but monitors and some t.v./monitors allow 60Hz which improves the screen
image definition. The screen hz function may be used in conjunction with
set screen hz so you know exactly what frequency you are changing to.

        E.g.
                 H=screen hz

                 10 mode 1 : key off :  curs off : flash off
                 20 centre "Set monitor frequency..."
                 30 locate 0,11
                 40 centre "Press '5' for 50Hz, '6' for 60Hz"
                 50 print
                 60 centre "or a mouse key to end"
                 70 repeat
                 80 : K=instr("56",inkey$)
                 90 : while K=1
                100 : : while screen hz=60
                110 : : : set screen hz
                120 : : wend
                130 : : K=0 
                140 : wend
                150 : while K=2
                160 : : while screen hz=50
                170 : : : set screen hz
                180 : : wend
                190 : : K=0 
                200 : wend
                210 until mouse key
                220 default
                230 end
               
------------------------------------------------------------------------------
        
        media status....: Chk disc chg sts
        
        Input:  none

        Output: Media status 0,1 or 2 of current drive
                
                This uses the BIOS function 9 and the machine has a guess if
        the floppy disc in the current drive is the same as the last time an
        I/O operation occurred.

                Possible values are:

        0       -       Disc has not been replaced
        1       -       Status uncertain. Checked on next read or write.
        2       -       Disc has been removed or had a boot sector update.

                The method the ST uses to obtain this information may be of
        some interest to a curious few.

                The ST drives have small light-emitting diodes and matching
        photoreceptors which can tell if there is something in between
        blocking the light. This facility is normally used to determine if a
        disc is write protected. If light travels through, the disc is write
        protected otherwise it is not. If a disc is removed from the drive,
        the light will be blocked while the disc is removed and then the
        light will become unblocked as there is no disc there. The ST system
        monitors the light status at a such a rate that it is fast enough to
        catch any change. If a transition has been noticed the media status is
        set to 1, indicating an unsure condition.
                If a read or write operation is performed while the status is
        unsure, the serial number is checked on the disc. If it does not match
        the previous discs serial number an error (-14) is issued. If the two
        serial numbers are the same the media status will be set to 0, which
        indicates a safe status.

        E.g.
                 10 MEDIACH=media status
                 20 inc MEDIACH
                 30 on MEDIACH goto 40,60,80
                 40 print "Disc has definitely not been changed."
                 50 goto 100
                 60 print "Disc may have changed!"
                 70 goto 100
                 80 print "Disc has definitely changed or a boot sector";
                 90 print " has been written."
                100 end

                 print media status

------------------------------------------------------------------------------
        
        write protected.: Disc write-prot? t/f
        
        Input:  none

        Output: True if disc in current drive is write protected, else false.

                Note that this option will not work on every Atari! Sorry, but
        it has to delve around in the operating system which can be anywhere!

                If it does not give you the correct information please be
        kind enough to tell me about your ST and give me the results of the
        following command:-
                                10 OS=leek($4F2)         :rem os header
                                20 print OS,hex$(OS)
                                30 print hex$(deek(OS))  :rem os_entry
                                40 print hex$(deek(OS+2)):rem os_version
                                50 end
                It is os_entry that I am particularly interested in as it is
        this value (the low byte actually) which determines where the
        write protect value is held. Why oh why can't Atari supply a disc to
        the public domain with the various os values for all versions of TOS?

                Anyhow, back to the command!

                When it works (!) it returns one of two values. The result
        will be true (-1) if the disc in the current drive IS write protected
        or it will return false (0) if it is NOT write protected.

        E.g.
                 10 while write protected
                 20 : print "Disc is write protected"
                 30 : print "Change disc or remove tab then press spacebar"
                 40 : repeat
                 50 : until inkey$=" "
                 60 wend
                 70 end
        
------------------------------------------------------------------------------
        
        disc sides (A)..: No. sides on disc
        
        Input:  drive to examine (0 for A or 1 for B)

        Output: number of sides of disc

                This allows you to interrogate how many sides a disc contains.
        Its use is limited unless you are doing some fancy disc work.

        E.g.
                 print disc sides(0)

                 10 for DR=0 to 1
                 20 : print "Drive ";chr$(65+DR);" has ";
                 30 : print disc sides(DR);" sides."
                 40 next DR
                 50 end
                
------------------------------------------------------------------------------
        
        disc tracks (A).: No. tracks on disc

        Input:  drive to examine (0 for A or 1 for B)

        Output: number of tracks of disc

                This allows you to interrogate how many tracks a disc
        contains per side. Its use is limited unless you are doing some fancy
        disc work.

        E.g.
                 print disc tracks(0)

                 10 for DR=0 to 1
                 20 : print "Drive ";chr$(65+DR);" has ";
                 30 : print disc tracks(DR);" tracks per side."
                 40 next DR
                 50 end 

------------------------------------------------------------------------------
        
        disc spt (A).: No. sector/track on disc

        Input:  drive to examine (0 for A or 1 for B)

        Output: number of sectors per track for disc

                This allows you to interrogate how many sectors per track
        a disc contains.

        E.g.
                 print disc spt(0)

                 10 for DR=0 to 1
                 20 : print "Drive ";chr$(65+DR);" has ";
                 30 : print disc spt(DR);" sectors per track."
                 40 next DR
                 50 end 
                
------------------------------------------------------------------------------
        
        disc verify on..: Set verify on
        
        Input:  none

        Output: none
                
                This sets a system flag to verify discs when a write operation
        is performed. It defaults to on when the system is turned on. It means
        that a sector is read immediately after a write to verify that the
        information was written correctly.

                Setting the verify on means that writes are slow but safe!

        E.g.
                 10 disc verify on
                 20 save "SERIOUS.DAT"  :rem Important file
                 30 end

                 disc verify on

------------------------------------------------------------------------------
        
        disc verify off.: Set verify off
        
        Input:  none

        Output: none
                
                The opposite to disc verify on. This command speeds up write
        by almost two and a half times. After a write operation no read
        follows so this saves time. I suggest that you only use this if you do
        not mind too much if you lose your data (then why are you saving it?)
        or if you have a decent back up or indeed if your discs are of a very
        high quality.

        E.g.
                 10 disc verify off
                 20 save "TRASH.DAT"    :rem Old tosh!
                 30 disc verify on      :rem better to put it back afterwards!
                 40 end

------------------------------------------------------------------------------
        
      fmt disc A,B,buff: Formats drive,nsides,buffer address
        
        Input:  destination drive and number of sides to format. Also needs
		an address of a buffer at least 10000 bytes big.

        Output: none

                This powerful command will format a disc in drive 0 (A) or
        drive 1 (B). You can select either 1 or 2 sides for the disc format.
        Most ST systems now have dual drives capable of viewing 2 sides.
                The format is a standard no-nonsense one and has proved to
        be reliable thus far.

                It goes without saying (but just in case...) that formatting
        a disc wipes off the existing data. Write protect your STOS disc to
        save you sending me a death threat!

        E.g.
                 10 rem Format disc in drive DR with SD sides
		 15 reserve as work 5,10000
                 20 fmt disc DR,SD,start(5)
                 30 print "Done!"
                 40 end
        
------------------------------------------------------------------------------
        
       cpy disc A,B,buff: Copy A to B, using buffer
        
        Input:  source and destination drives. Buffer address at least
		6200 bytes big.

        Output: none

                This will copy the disc in the source drive to that in the
        destination drive. These drives must be different and therefore have
        the value 0,1 (A->B) or 1,0 (B->A).

                The disc formats must be the same for the copy to take place.
        Any errors will halt the process. Note that the number of sectors
        per track must be less than 12 and the bytes per sector must not
        exceed 512.

                It will not copy discs which have an strange format or which
        have some form of copy protection. If it is copy protected it is not
        supposed to be copied!

        E.g.
                 10 rem Copy A to B
		 15 reserve as work 5,6200
                 20 cpy disc 0,1,start(5)
                 30 print "Done!"
                 40 end

------------------------------------------------------------------------------
       pload f$,addr,len: Partially load a file

        Input:  filename$, address to load to, # of bytes to load

        Output: none

                This command enables you to load the first few bytes of a
        file rather than having to load the entire lot. This is useful where
        you wish to interrogate the first few bytes to examine if, for
        example, the file was packed.

                The file name string MUST be terminated by a null, ie you
        must +chr$(0) to the variable. Note that there is only internal
	error checking so you must ensure that the file exists or
	nothing will be loaded.

        E.g.
                pload FILE$,start(5),12

                 10 TEMP$=space$(12) : rem space for header
                 20 FILE$="FILE.DAT"+chr$(0)
                 30 pload FILE$,varptr(TEMP$),12
                 40 end

        The PLOAD and DESQUASH commands can be used together to gain
        maximum performance. In the following example, a few bytes of
        a file are loaded so that the header can be interrogated.
        If the file is ICE packed then the original size of the file
        is held at the offset position of 8 whereas the Atomik offset
        is the more common 4.

                 10 TEMP$=space$(12) : rem space for header
                 20 FILE$="FILE.DAT"+chr$(0)
                 30 pload FILE$,varptr(TEMP$),12
                 40 OSIZE=0 : rem Original size
                 50 if left$(TEMP$,4)="ICE!" then
                         OSIZE=leek(varptr(TEMP$)+8)
                 60 if left$(TEMP$,4)="ATM5" then
                         OSIZE=leek(varptr(TEMP$)+4)
                 70 if OSIZE>0 then 100
                 80 print "Not a recognised packed file type."
                 90 goto 130
                100 reserve as work 5,OSIZE
                110 bload FILE$,5
                120 desquash start(5)
                130 end

------------------------------------------------------------------------------
        
        left shift key..: Press=true,else false
        
        Input:  none

        Output: true if pressed, false if not

                Check to see status of this key. If pressed a true (-1) value
        is returned otherwise a false (0) value is returned.

        E.g.
                 10 if left shift key then ?"Left Shift Key!"
                 20 goto 10

------------------------------------------------------------------------------
        
        right shift key.: Press=true
                
        Input:  none

        Output: true if pressed, false if not

                Check to see status of this key. If pressed a true (-1) value
        is returned otherwise a false (0) value is returned.

        E.g.
                 10 if right shift key then ?"Right Shift Key!"
                 20 goto 10
        
------------------------------------------------------------------------------
        
        cntrl key.......: Press=true
        
        Input:  none

        Output: true if pressed, false if not

                Check to see status of the control key. If pressed a
        true (-1) value is returned otherwise a false (0) value is returned.

        E.g.
                 10 if  cntrl key then ?"Control Key!"
                 20 goto 10

------------------------------------------------------------------------------
        
        alt key.........: Press=true
                
        Input:  none

        Output: true if pressed, false if not

                Check to see status of the alternate key. If pressed a
        true (-1) value is returned otherwise a false (0) value is returned.

        E.g.
                 10 if alt key then ?"Alternate Key!"
                 20 goto 10
        
------------------------------------------------------------------------------
        
        caps lock ......: True if on,else false
        
        Input:  none

        Output: status of the caps lock key, true if on or false if not

                This merely check the status of the Caps Lock key. If Caps
        Lock is on the the returned value will be true (-1) otherwise if
        the Caps Lock is off it will return false (0).

        E.g.
                 10 if caps lock then print "Caps Lock on!"
                 20 if not(caps lock) then print "Caps lock off!"
                 30 goto 10

------------------------------------------------------------------------------
        
        caps lock on....: Set caps lock on
        
        Input:  none

        Output: none

                This command will turn the Caps Lock on regardless of its
        previous setting. It is useful if upper case characters are to be
        entered.

        E.g.
                 caps lock on

                 10 caps lock on
                 20 input "Post Code:";PC$
                 30 end

------------------------------------------------------------------------------
        
        caps lock off...: Set Caps lock off
        
        Input:  none

        Output: none
        
                This command will turn the Caps Lock off regardless of its
        previous setting. It is useful if lower case characters are to be
        entered.

        E.g.
                 caps lock off

                 10 caps lock off
                 20 input "Name of person:";NM$
                 30 end
        
------------------------------------------------------------------------------
        
        gemdos version$.: GEMDOS version
        
        Input:  none

        Output: your version of GEMDOS (string)

                This returns a five character string 'xx.xx'. You may like to
        convert the value to decimal by:-
                                        GEMD#=val(gemdos version$)

        E.g.
                 print gemdos version$  

                 10 print "GEMDOS version:";gemdos version$
                
------------------------------------------------------------------------------
        
        os version$.....: OS version
        
        Input:  none

        Output: your version of TOS (string)

                This will return your TOS version as a five character string.
        Like the gemdos version$ command you may like to convert the value to
        a numeric:-
                OS#=val(os version$)

        E.g.
                 10 OS#=val(os version$)
                 20 if OS#=1 then OS$="1.00" 
                 30 if OS#=1.2 then OS$="1.02 (Blitter)"
                 40 if OS#=1.4 then OS$="1.04 (Rainbow)"
                 50 if OS#=1.6 then OS$="1.06 (STe)"
                 60 if OS#=1.62 then OS$="1.62 (STe without the bugs!)"
                 70 if OS#>=2 and OS#<3 then OS$=os version$+" (Mega STe)"
                 80 if OS#>=3 and OS#<4 then OS$=os version$+" (TT)"
                 90 if OS#>=4 then OS$=os version$+" (Falcon?)"
                100 print "TOS ";OS$
                110 end

------------------------------------------------------------------------------
        
	mem config......: Memory configuration

	Input:  none

        Output: Size, in kilobytes, of your computer system.

                This returns your memory configuration as an integer in
	kilobytes.

                 print mem config

        E.g.
		 10 print "Your memory configuration"
		 20 print "is";mem config;"K."
		 30 end

------------------------------------------------------------------------------
        
        power (A,B).....: A ^ B
        
        Input:  two positive integers

        Output: the value of A to the power of B

                "Why?", you cry, "what about the ^ function?". Yes I know but
        would you trust it 100%? Try entering the following:-

                                                10 P=5^2
                                                20 print "5^2 is ";5^2
                                                30 print "5^2 is ";P

                The first result gives you the correct result of 25. The
        second will give you 24. This is a bad error if you need to use the
        power function.

                I have written a command to replace it. It works well for
        values which do not get too near the maximum a STOS integer can
        hold ($7fffffff). It is a lot quicker than using ^ too!

        E.g.
                 10 for LOOP=1 to 20
                 20 : STP=2 ^ LOOP
                 30 : XP=power (2,LOOP)
                 40 : print "For 2 ^";LOOP;":-"
                 50 : print "  STOS=";STP;" or ";2 ^ LOOP
                 60 : print "  EXTRA=";XP
                 70 next LOOP
                 80 end

------------------------------------------------------------------------------

        cartridge input.: Get incoming data
        
        Input:  none

        Output: value of data coming into the machine via the cartridge port

                Use this to create some fab disco effects! If you have STOS
        Maestro (or indeed any sound sampler) plug it in (WITH THE COMPUTER
        TURNED OFF!!!) then insert your STOS disc and turn your ST on. You
        can then write a program which uses the value coming in from the
        cartridge port to determine which colour changes and to what value.
        This means the screen flashes in time to the music (if like me you
        attach your CD player to the sample cartridge). 

                The returned value is 0-255 but you should subtract 127 from
        the value so that 0 (zero) becomes a stable point.

        E.g.
                 10 repeat
                 20 : CP=cartridge input-127
                 30 : if CP<0 then colour 0,abs(CP)
                 40 : if CP>=0 then colour 1,CP
                 50 until mouse key

------------------------------------------------------------------------------

        Cookies...

                The 'Cookie Jar' is an area Atari set up to allow for
        programmers to utilise a part of hardware which certain machines have.
        For example, using the _SND cookie you can see if the machine has a
        STe style DMA sound chip. If it has you may utilise this chip in your
        program.

                Not all of the cookies are available on all machines. You must
        monitor for errors when using the cookie commands. If an error does
        occur, presume that the cookie and therefore the hardware does not
        exist.

                The value are all correct as far as I trust. Expect the Falcon
        to have a value of 3 where 0-ST, 1-STe and 2-TT. Mind you with Atari
        you never know...

------------------------------------------------------------------------------

        cookie _cpu.....: Delve into cookie jar, return _cpu
        
        Input:  none

        Output: cookie jar value (see below)

                The _cpu cookie return the CPU (central processing unit) of
        your ST. For the ST/STe this will normally be 68000.

------------------------------------------------------------------------------
!REMOVED!
        cookie _fdc.....: Delve into cookie jar, return _fdc
        
        Input:  none

        Output: cookie jar value (see below)

                The value has two parts to it. The high byte returns the
        value of the highest density floppy unit installed in the system.
        The values:-
                        0       360Kb/720Kb     (double density)
                        1       1.44Mb          (high density)
                        2       2.88Mb          (extra-high density)

                The low three bytes tell you about the origin of the unit.
        The value 'ATC' indicates an Atari line-fit or retro-fitted unit.

------------------------------------------------------------------------------
!REMOVED!
        cookie _fpu.....: Delve into cookie jar, return _fpu
        
        Input:  none

        Output: cookie jar value (see below)

                This tells you if a floating point unit is present on the
        machine. The high word should be tested for the following bits:

                        0       I/O mapped 68881
                        1       68881/68882
                        2       if bit 1 = 0 then 68881, otherwise 68882
                        3       68040 internal floating point support

------------------------------------------------------------------------------
!REMOVED!
        cookie _frb.....: Delve into cookie jar, return _frb
        
        Input:  none

        Output: cookie jar value (see below)

                This will tell you (if you have a TT) if a 'fast RAM buffer' is
        available.

------------------------------------------------------------------------------

        cookie _mch.....: Delve into cookie jar, return _mch
        
        Input:  none

        Output: cookie jar value (see below)

                This gives you a minor and major number as follows:-

                Major   Minor   Machine
                0       0       520/1040 or Mega ST
                1       0       STe
                1       16      Mega STe
                2       0       TT

------------------------------------------------------------------------------

        cookie _snd.....: Delve into cookie jar, return _snd
        
        Input:  none

        Output: cookie jar value (see below)

                The result of this should be bit tested:-

                0       1 if ST style GI/Yamaha chip available
                1       1 is STe style DMA sound chip available

------------------------------------------------------------------------------
!REMOVED!
        cookie _swi.....: Delve into cookie jar, return _swi
        
        Input:  none

        Output: cookie jar value (see below)

                This gives the internal configuration switches!

------------------------------------------------------------------------------

        cookie _vdo.....: Delve into cookie jar, return _vdo

        Input:  none

        Output: cookie jar value (see below)

                This gives the major and minor part number of your video
        shifter chip.

                Major   Minor   Machine
                0       0       ST
                1       0       STe
                2       0       TT

------------------------------------------------------------------------------

        disc size (A)...: Retrieve original disc size

        Input:  drive to examine (0 = A, 1 = B, etc etc)

        Output: original size of disc in bytes

                Command dedicated to Paul Archer!

                This command retrieves the size of the disc with no data.

        E.g.
                 print disc size(0)

                 10 DS=disc size(drive)
                 20 DF=dfree
                 30 print "Total size of disc ...:";using "##########";DS
                 40 print "Amount used ..........:";using "##########";DS-DF
                 50 print "Amount free ..........:";using "##########";DF
                 60 end             

------------------------------------------------------------------------------

        disc free (A)...: Retrieve amount free on disc

        Input:  drive to examine (0 = A, 1 = B, etc etc)

        Output: amount of bytes free on disc

                This command retrieves the amount of space (in bytes) on a 
                disc. Is is the same as 'dfree' but allows you identify a
                particular drive, not necessarily the current one.

        E.g.
                 print disc free(1)

                 10 DF=disc free(1)
                 20 print "Amount free ..........:";using "##########";DF
                 30 end             

------------------------------------------------------------------------------

        disc used (A)...: Retrieve actual amount used on disc

        Input:  drive to examine (0 = A, 1 = B, etc etc)

        Output: actual number of bytes used on disc

                This command retrieves the size the used portion of a disc. 
        However, as it is the true amount (formatted size - free bytes) it
        does not necessarily equal the sum total of files on the disc. If
        in STOS you enter 'dir' the amount used refers to that directory
        in data, not on the entire disc and not including directory
        information which must be stored on the disc. This is why it
        appears to be incorrect!

        E.g.
                 print disc used(0)

                 10 DU=disc size(0)
                 20 print "Amount used ..........:";using "##########";DU
                 30 end             

------------------------------------------------------------------------------

        depack tiny A,B.: Depack tiny bank to other bank

        Input:  actual addresses for source and destination banks

        Output: none

                This command will unpack a .TN? format picture. The
        destination bank must be a reserved bank of $8000 bytes size or
        the physical, logical or background screen. Note that if you unpack
        to a memory bank the palette will not be stored in that bank. If
        you want to copy the physical palette to the screen bank you must
        copy colours 0-15 (low res) or 0-3 (med res) to the offset 32000
        within your bank.

        E.g.
                 depack tiny start(5),physic

                 10 reserve as work 5,$8000
                 20 FILE$="PIC.TNY"
                 30 bload FILE$,5
                 40 depack tiny start(5),physic
                 50 end

------------------------------------------------------------------------------

        vtab (X)........: Tab to column on screen

        Input:  Column to tab to (0-132)

        Output: to screen/printer/string

                This function is a more true version of the tab command than
        the one provided by STOS. The STOS tab command moves the cursor
        right by the value, from where ever the cursor was.

                The VTAB function moves the cursor to the selected column.
        It does so by repositioning the cursor to the start of the line and
        then using ASCII value 9 to move the cursor right by the required
        value. Because of this it probably will not work on your printer.
        This is because most printer use this code to skip to the next
        predefined tabulation value, not necessarily one place to the right.

        E.g.
                 print vtab(5);"Name";vtab(20);"Score"

                 10 print vtab(0);"Loop";vtab(20);"Loop x Loop"
                 20 for LOOP=1 to 10
                 30 print vtab(0);using "##";LOOP;vtab(20);using "###";LOOP
                    * LOOP
                 40 next LOOP
                 50 end             

------------------------------------------------------------------------------

        ltab (X)........: Tab to column on line printer

        Input:  Column to tab to (0-132)

        Output: to screen/printer/string

                This function is a more true version of the tab command than
        the one provided by STOS. The STOS tab command moves the cursor
        right by the value, from where ever the cursor was.

                The LTAB function moves the cursor to the selected column.
        It does so by repositioning the cursor to the start of the line and
        then using ASCII value 32 to move the cursor right by the required
        value. Using code 32 means it will work on a printer but using it
        on a screen means that characters on the line upto the column will
        be erased.

        E.g.
                 lprint ltab(5);"Name";ltab(20);"Score"

                 10 lprint ltab(0);"Loop";ltab(20);"Loop x Loop"
                 20 for LOOP=1 to 10
                 30 lprint ltab(0);using "##";LOOP;ltab(20);using "###";LOOP
                    * LOOP
                 40 next LOOP
                 50 end             

------------------------------------------------------------------------------

        blur (8 parms)..: Blur portion of screen

        Input:  destination address, top left corner x, y,
                        block size x, y, factor x, y, blur type

        Output: none

                (Note that versions <1.70 used block size and factor size
in opposite sequence. Any blur command before this will need these two sets
of parameters (4 in all) swapped over)

                This command will 'blur' a portion of the screen or screen
bank. It may be used to emulate the blur used on television when trying to
hide a persons identity or in games to distort a picture and to see how
quickly or just how distorted the picture can be before someone correctly
identifies the distorted image.

                This command ONLY WORKS IN LOW RESOLUTION!

                The destination must be an actual address (so for bank 5
use start(5) not 5).

                The top left corner identifies the pixel position (x,y) of
where the distortion is to take place.

                The block size x,y is the area of the screen to blur. If
this was 16 x 16 and the factor was 2 x 2 there would be 8 x 8 blocks in
the blurred portion of the screen.

                The factor x,y is the new pixel size. For example, a value
of 2,2 will create a block of 2 x 2 pixels.

                The blur type can be a value 1 - 5 (any other value uses
blur type 1). It tells the command which pixel to use to get the colour of
the resulting block:-

                1 - top left pixel      (x,y)
                2 - top right pixel     (x+x factor,y)
                3 - centre pixel        (x+x factor/2,y+y factor/2)
                4 - bottom left pixel   (x,y+y factor)
                5 - bottom right pixel  (x+x factor,y+y factor)

        E.g.
                 blur physic,0,0,320,200,2,2,1

                 10 mode 0:key off:curs off:flash off
                 20 FILE$="PIC.NEO"
                 30 load FILE$
                 40 blur physic,0,0,320,200,2,2,3
                 50 end

------------------------------------------------------------------------------

       convert iff S,D,P: Convert uncompressed IFF image to normal


        Input:  source address, destination address, palette flag (0 or 1)

        Output: none

                This command converts an uncompressed IFF image to the
address given. This address may be physic, logic, back or the actual address
of a screen bank. The palette flag may be 0-do not set palette or 1-set
palette.

        E.g.
                 convert iff start(5),physic,1

                 10 mode 0:key off:curs off:flash off
                 20 FILE$="PIC.IFF"
                 30 reserve as work 5,$8000
                 40 bload FILE$,5
                 50 convert iff start(5),physic,1
                 60 end

------------------------------------------------------------------------------

        deshade A,B,C...: Change colours not B to C in addr A

        Input:  screen address, colour to ignore, selected colour

        Output: none

                This command changes all colours (except a selected one) at an
address to the selected colour. Its primary use is freeing the other colours
from a digitised or scanned picture. These types of image use shading to get a
good effect but this uses all of the 16 colours. Generally use colour 0 as the
one to ignore.

                Running this command over a screen (using a value of 1 for a
scanned image or 15 for a video digitised image) should do the trick. In the
case of a scanned image you may want to change colour 1 to $0 so that it is
blank rather than a grey shade.

                If you were scanning in your drawings to colour in this will
allow you to redefine the other colours to pretty ones (ie red, yellow, green
etc) instead of grey shades.
        
        E.g.
                 deshade physic,0,1

                 10 mode 0:key off:curs off:flash off
                 20 FILE$="SCANPIC.NEO"
                 30 reserve as screen 5
                 40 load FILE$,5
                 50 deshade start(5),0,1
                 60 screen copy 5 to physic
                 70 colour 1,$0
                 80 end

------------------------------------------------------------------------------

        set printer data A: Configure printer to A

        Input:  printer data (see below)

        Output: none

                This command allows you to set up the Atari/printer
configuration.

                The data is made of flags using bits.

                Bit     If clear (0)            If set (1)
                 0      Dot matrix              Daisy Wheel
                 1      Monochrome              Colour
                 2      Atari Mode              'Epson' compatible
                 3      Draft quality           Final quality
                 4      Parallel port           Serial (RS-232) port
                 5      Continuous              Single sheet

                For your knowledge, bit 0 is the furthest to the right of
a value given in binary. The value is preceded with a % to signify that
it is a binary one. So, %10011 would mean that bits 0,1 and 4 are set.

                You can set the value to any combination of the above. To
do this you MUST use every bit (set or clear) to change any one.

                So 'set printer data %101100' will set the printer to
dot matrix, monochrome, Epson compatible, Final quality, parallel and
single sheet.
                If you only want to change an individual bit then you must
use the 'setup of printer' command to get the original value, use 'or' to
set your bit and then use 'set printer data'. See below for details.

        E.g.
                 set printer data %101100

                 10 set printer data %101100
                 20 end

                To set an individual bit or bits:

                 10 rem Set bit 1 leaving others unchanged
                 20 PS=setup of printer
                 30 PS=PS or %000010
                 40 set printer data PS
                 50 end

------------------------------------------------------------------------------

        setup of printer: Returns printer configuration data

        Input:  none

        Output: printer data (see below)

                This command returns the Atari/printer configuration.

                The data is made of flags using bits.

                Bit     If clear (0)            If set (1)
                 0      Dot matrix              Daisy Wheel
                 1      Monochrome              Colour
                 2      Atari Mode              'Epson' compatible
                 3      Draft quality           Final quality
                 4      Parallel port           Serial (RS-232) port
                 5      Continuous              Single sheet

                For your knowledge, bit 0 is the furthest to the right of
a value given in binary. The value is preceded with a % to signify that
it is a binary one. So, %10011 would mean that bits 0,1 and 4 are set.

        E.g.
                 PS=setup of printer

                 10 print setup of printer
                 20 end

------------------------------------------------------------------------------

        hrev S$.........: Horizontally flip screen

        Input:  string containing screen

        Output: none

                This command will take a screen which has been created in a
        string variable (using S$=screen$()) and flip the image horizontally.

        E.g.
                 hrev S$

                 10 reserve as screen 5
                 20 FILE$="PIC.PI1"
                 30 load FILE$,5
                 40 S$=screen$(5,0,0 to 320,200)
                 50 hrev S$
                 60 screen$(physic,0,0)=S$
                 70 end

------------------------------------------------------------------------------

        A$=visible input$(A): Input A number of characters into A$

        Input:  Number of characters to input (1-5000)

        Output: String variable

                This function is an improved version of the input$(n) command
provided by STOS. The difference is that the text you enter is shown on the
screen as you enter it. Like the STOS function Backspace is the only control
key active. Pressing RETURN will end the input before all of the characters
have been entered, in this instance trailing spaces are added to the end of
the string to ensure a constant sized variable.
 
        E.g.
                 A$=visible input$(10)

                 10 mode 1 : key off
                 20 print "Enter name (upto 12) characters";
                 30 NAME$=visible input$(12)
                 40 end

------------------------------------------------------------------------------

        whiten..........: Turn palette to white

        Input:  None

        Output: None

                A command to turn the screen white. This has the same effect
as palette $777,$777,$777 etc. Is is quicker to type in and also much quicker
in processing time.
 
        E.g.
                 whiten

                 10 mode 1 : key off : curs off : flash off
                 20 for LOOP=0 to 15
                 30 pen LOOP
                 40 print "Colour";LOOP
                 50 next LOOP
                 60 wait vbl
                 70 whiten
                 80 end

------------------------------------------------------------------------------

        blacken.........: Turn palette to black

        Input:  None

        Output: None

                A command to turn the screen black. This has the same effect
as palette $0,$0,$0 etc. Is is quicker to type in and also much quicker in
processing time.
 
        E.g.
                 blacken

                 10 mode 1 : key off : curs off : flash off
                 20 for LOOP=0 to 15
                 30 pen LOOP
                 40 print "Colour";LOOP
                 50 next LOOP
                 60 wait vbl
                 70 blacken
                 80 end


------------------------------------------------------------------------------

        pal inverse.....: Inverse palette

        Input:  None

        Output: None

                A command to turn the inverse the palette. This goes through all
of the 16 colours (regardless of what resolution mode you are in) and inverses
all of the bits for that colour, black become white and vice versa.
 
        E.g.
                 pal inverse

                 10 mode 1 : key off : curs off : flash off
                 20 for LOOP=0 to 15
                 30 pen LOOP
                 40 print "Colour";LOOP
                 50 next LOOP
                 60 wait vbl
                 70 pal inverse
                 80 wait 100
                 90 pal inverse
                100 end

------------------------------------------------------------------------------

        L=fmt text(s,e,d,c,w): Format text

        Input:  Source addr start,addr end,dest addr,high char,width

        Output: Length of new data

                This function was created when I received a text document which
contained some non-ASCII characters, preventing me viewing it correctly. I
wrote a STOS routine to format the text so that it was more readable. The
routine was very slow so I wrote this command.

                You need two memory banks, the second one being about one and a
half as big as the first (to accommodate any possible extra character codes).
Load your file into bank one. Then, using the function and its parameters, you
can create a new ASCII file which contains only selected characters and is
formatted to a selected width.

                The source address is the actual address value (not bank number)
of the first memory bank. The address end is the start address plus the size of
the file loaded, ie the last address to check. The destination address is the
actual address of the second bank. The high character value is used to decide
your range of character to include. I use upto 126 as the values after this tend
to be special foreign and border symbols. For your information the lowest value
selected is 32, space. All values below this are control codes which are not
pure ASCII therefore. The width parameter is used to determine how wide the new
text will be. This may be in the range 10 to 160 inclusive. Note that if a
word spills over to the next line no hyphen is used. I decided on this simple
wrapping method as is saves processing time and basically does the job.

                The returned value gives the length of the new file. This is
necessary when saving the new file. A value of -1 is returned in case of a
parameter error.

        E.g.
                 L=fmt text(start(5),start(5)+S,start(6),126,80)

                 10 mode 1 : key off : curs off : flash off
                 20 reserve as work 5,100000
                 30 reserve as work 6,150000
                 40 bload "TEXTFILE.TXT",5
                 50 SIZE=4500 : rem Size of TEXTFILE.TXT
                 60 L=fmt text(start(5),start(5)+SIZE,start(6),126,80)
                 70 if L<0 then 100
                 80 bsave "FORMAT.TXT",start(6) to start(6)+L
                 90 print "Done!"
                100 end

------------------------------------------------------------------------------

        set screen hz...: Toggle screen Hz

        Input:  None

        Output: None

                This command does the same job as the frequency command but
the difference is you can compile it. I do not know why Francois Lionet did
not allow the frequency command to compile but this command should sort that
problem out.

                DO NOT USE THIS COMMAND ON A STANDARD TV. If your television
is capable of displaying the higher frequency you are okay but from what I
have read using it on a television that cannot support it could do damage to
the television if used for long periods. The best thing is to enter the
command and if your screen looks as though it is jumping around rather than
a steady picture, press F1 to re-enter the command getting things back to
normal again.

        E.g.
                set screen hz

                 10 mode 1 : key off :  curs off : flash off
                 20 centre "Test monitor..."
                 30 locate 0,11
                 40 centre "Press left mouse key to toggle frequency"
                 50 print
                 60 centre "or right mouse key to end"
                 70 repeat
                 80 : MK=mouse key
                 90 : while MK=1
                100 : : set screen hz
                110 : : MK=0
                120 : wend
                130 until MK=2
                140 default
                150 end

------------------------------------------------------------------------------

        opaque screen s,x,y,v: Opaque version of screen$

        Input:  screen addr, x coord, y coord, S$

        Output: none

                This command will take a screen which has been created in a
        string variable (using S$=screen$()) and display it in the
        requested position exactly as screen$()=S$ would do BUT the image
        is not merged with the background. Instead it overwrites anything
        underneath, similarly to screen copy.

                Note that the x coordinates must be a multiple of 16.

        E.g.
                 opaque screen physic,16,32,S$

                 10 reserve as screen 5
                 20 FILE$="PIC.PI1"
                 30 load FILE$,5
                 40 S$=screen$(5,0,0 to 320,200)
                 50 opaque screen physic,0,0,S$
                 60 end

------------------------------------------------------------------------------

        vrev S$.........: Vertically flip screen

        Input:  string containing screen

        Output: none

                This command will take a screen which has been created in a
        string variable (using S$=screen$()) and flip the image vertically.

        E.g.
                 vrev S$

                 10 reserve as screen 5
                 20 FILE$="PIC.PI1"
                 30 load FILE$,5
                 40 S$=screen$(5,0,0 to 320,200)
                 50 vrev S$
                 60 screen$(physic,0,0)=S$
                 70 end

------------------------------------------------------------------------------

        ppsc (parms)....: Pixel perfect screen copy

        Input:  9 parameters. Source screen address, destination screen
                address, X1, Y1, X2, Y2, X3, Y3, number of planes

        Output: none

                This command is basically the same as the STOS screen
        copy command. There is, however, no word boundary limit so you
        can copy precise pixels. There is also a parameter to hold the
        number of planes to copy. There is NO validation in the command
        so it is up to the programmer to ensure that the parameters
        are valid. The number of planes may be 1 to 4, where 1 only
        copies the first plane and is therefore faster. Due to the
        nature of the command it is not terribly fast, so use this
        command carefully.

        E.g.
                 ppsc start(5),physic,3,0,164,100,6,10,4

                 10 reserve as screen 5
                 20 FILE$="PIC.PI1"
                 30 load FILE$,5
                 40 ppsc start(5),physic,3,0,164,100,6,10,4
                 50 end

------------------------------------------------------------------------------

        desquash addr...: Desquash ICE 2.4/Atomik 3.5

        Input:  Source (and destination) address

        Output: none

                This will depack a file which has been packed with the
        ICE PACKER v2.4 or Atomik 3.5, the best data file packers that you
        can use. See PLOAD command for best way to use this command. I did
        incorporate an LHZ (as in JAM 4.0) algorithm but the unpacking is
        very slow and the packer is less common for data files on the ST.

		If the bank you try to unsquash is not one of the
	recognised types of packed file no unpacking will take place.

        E.g.
                 desquash start(5)

                 10 FILE$="INFO.DAT"
                 20 SIZE=val(mid$(dir first$(FILE$,0),13,8))
                 30 reserve as work 5,SIZE
                 40 bload FILE$,5
                 50 OSIZE=leek(start(5)+8) : rem get original size
                 60 reserve as work 6,OSIZE
                 70 copy start(5),start(5)+length(5) to start(6)
                 80 deice start(6) : rem Bank 6 now has unpacked data
                 90 end

------------------------------------------------------------------------------

        disable mouse....: Turn off mouse

        Input:  none

        Output: none

		This command turns off mouse reporting to the system. This
	will actually improve the speed of the system slightly. It also
	means that if a user moves the mouse while a STOS sample is
	playing you will not get that distorted sound common with this
	situation.

		A similar command is available in another extension but
	that extension does not work in high resolution.

		Note that if you disable the mouse it is important to
	enable it again (see below) on exit from STOS or the user will
	be unabel to use the mouse from the desktop!


        E.g.
                 disable mouse

                 10 disable mouse
                 20 print "Ha, try moving the mouse now!"
                 30 end

------------------------------------------------------------------------------

        enable mouse......: Turn on mouse

        Input:  none

        Output: none

		This command turns on mouse reporting to the system. This
	should be used if the disable mouse command has been used.

		A similar command is available in another extension but
	that extension does not work in high resolution.


        E.g.
                 enable mouse

                 10 enable mouse
                 20 print "Okay, have it your way - move the mouse"
                 30 end

------------------------------------------------------------------------------

==============================================================================

This extension has been written using the following aids:-

        Devpac 3 (HiSoft) and their informative (if a little errorish) manual.

        STOS Newsletter (issues 8 and 9 etc) R.I.P.

        STOS itself

        The Concise Atari ST 68000 Programmer's Guide (Glentop)

        Introducing ATARI ST Machine Code (zzSoft)

        50's and 60's sounds on Breeze AM.

        From and including version 1.91 I had access to The Game Maker's
        Manual - thanks to Deano!

	From and including version 2.00 The Atari Compendium, used for
	correct mouse disabling/enabling.

------------------------------------------------------------------------------

        A small note on string handling within this STOS extension.

        Because I have been unable to get any CORRECT information on string
        handling within a STOS extension (stored values corrupt easily) I
        have written this small routines which you should incorporate into
        your BASIC program. Call these routines to use the commands which
        use strings. These are:

                        os version$
                        gemdos version$
                        visible input$()

        I have written a small program to demonstrate the above commands
        together but you can, of course, separate them if you only use
        some of the above commands in your program.

        10 mode 1 : key off
        20 hide

        30 gosub 50000 : rem Get TOS version
        40 A$=BUGFIX_DEST$

        50 gosub 51000 : rem Get GEMDOS version
        60 B$=BUGFIX_DEST$

        70 BUGFIX_SIZE=5
        75 print "Enter";BUGFIX_SIZE;" (or less) char string:";
        80 gosub 52000 : rem Get Visible input
        90 C$=BUGFIX_DEST$

        91 print : print 
        100 print "A$";vtab(10);"B$";vtab(20);"C$"
        110 print A$;vtab(10);B$;vtab(20);C$
        120 stop
 
        49997 rem *****************************
        49998 rem * Get TOS version           *
        49999 rem *****************************
        50000 BUGFIX_SIZE=5
        50010 BUGFIX_DEST$=string$("0",BUGFIX_SIZE)
        50020 BUGFIX_SIZE=(BUGFIX_SIZE+1)/2*2 : rem Ensure the
                size is an even value
        50030 BUGFIX_SOURCE$=os version$
        50040 copy varptr(BUGFIX_SOURCE$),varptr(BUGFIX_SOURCE$)+
                BUGFIX_SIZE to varptr(BUGFIX_DEST$)
        50050 return 

        50997 rem *****************************
        50998 rem * Get GEMDOS version        *
        50999 rem *****************************
        51000 BUGFIX_SIZE=5
        51010 BUGFIX_DEST$=string$("0",BUGFIX_SIZE)
        51020 BUGFIX_SIZE=(BUGFIX_SIZE+1)/2*2 : rem Ensure the
                 size is an even value
        51030 BUGFIX_SOURCE$=gemdos version$
        51040 copy varptr(BUGFIX_SOURCE$),varptr(BUGFIX_SOURCE$)+
                BUGFIX_SIZE to varptr(BUGFIX_DEST$)
        51050 return 

        51996 rem *****************************
        51997 rem * Visible input (pass size  *
        51998 rem * in var BUGFIX_SIZE)       *
        51999 rem *****************************
        52000 BUGFIX_DEST$=space$(BUGFIX_SIZE)
        52010 BUGFIX_SIZE1=(BUGFIX_SIZE+1)/2*2 : rem Ensure the
                 size is an even value
        52020 BUGFIX_SOURCE$=visible input$(BUGFIX_SIZE)
        52030 copy varptr(BUGFIX_SOURCE$),varptr(BUGFIX_SOURCE$)+
                BUGFIX_SIZE1 to varptr(BUGFIX_DEST$)
        52040 return 

-----------------------------------------------------------------------------

About the author...

Name..................: Martin Cubitt
Sex...................: Male
Date of Birth.........: 18th Jan 1969
Address...............: 14 Deepdene Avenue
                        Rayleigh
                        Essex
                        SS6 9LG
                        England
Brief computer history: At age of 12/13 borrowed VIC20 and Atari 400.
                        Taught myself BASIC.
                        Dabbled with machine code.
                        Got given VIC20 and borrowed C64.
                        Dabbled a little wore with 6502 machine code.
                        Still never had an assembler! All assembly
                        done manually by me via a book.
                        Got an Einstein.
                        Dabbled with Z80 machine code. Still no
                        assembler.
                        Borrowed Amstrad PCW and dabbled...
                        Took (and passed) 'A' level computer science.
                        Started work (computer operator) on a System 38.
                        Splashed out (1987) on an Atari ST.
                        Bought STOS BASIC.
                        Dabbled with 68000 using a copy of Devpac given
                        away on ST Format.
                        Became analyst programmer at work using a
                        language called RPG III, still on IBM System 38.
                        Bought VIDI-ST - excellent!
                        In 1989 brought STe with 2MB. (Good move!)
                        TOS 1.6 (buggy!) - bad move.
                        Bought Devpac 2.
                        Now coding RPG 400 at work.
                        Bought VIDICHROME - never worked properly - 
                         rubbish!
                        Bought Devpac 3 (the best!)
                        Wrote replacement file selector (in STOS)
                        Wrote my largest 68000 piece of code - this
                        extension.
                        Wanting to buy Falcon - too expensive!
                        Still updating this extension (7 Aug 93)
                        Contacted HiSoft and the writer of UVK for advice
                        on TOS/GEMDOS versions - hence version 1.91!
                        Bought VIDI ST (12) - blooming excellent!
                        After much hassle wrote ppsc command.

        If you have any comments (good or bad) please do write to me and let
me know your thoughts on this extension, or about computers in general.

        I do not care how young or old you are, inexperienced or (dare I say
it) experienced if you have a query then let me know! No promises though!

        If you have any questions about the new commands, or indeed about
STOS commands in general, please do not hesitate to contact me and I will
do my best to help you.

        If you require a reply to any query you have please do not forget
to include a stamped addressed envelope for return.


        Get The STOSSER Disczine - a must for all STOS users
                                              ---

	Avaiable on the 20th of every month from any decent PD library.
