	11 .	Routines additionnelles


	11.1 Macros


		Les macro-instructions sont träs utiles pour rendre un code plus 
lisible, elles augmentent la portabilitÇ mais il faut les utiliser Ö bon es-
cient sinon on grossit la taille du code gÇnÇrÇ de faáon dÇmesurÇe : Çtu-
dier si un BSR ne serait pas aussi efficace.
		Les macros prennent parfois des paramätres en entrÇe : ils sont 
\1 pour le premier, \2 pour le second et ainsi de suite.

save:
	Cette macro sert Ö sauvegarder un ou plusieurs registres sur la pile. Il 
faut prÇciser la taille des registres : mot ou mot long.
	exemple : save.w d0/d5 ou bien save.l d0-a6

load:
	Cette macro vient en complÇment de la prÇcÇdente : elle permet de re-
charger des registres stockÇs sur la pile, prÇcisez ici aussi la taille des re-
gistres.
	exemple : load.w d0/d5 ou bien load.l d0-a6

appel:
	Cette macro permet d'appeler une fonction bios, xbios ou autre en une 
seule ligne :
	exemple :
	 appel dos,7,2 : fera un appel Ö la fonction 7 du DOS en restaurant la 
pile le 2 octets (1 mot) apräs l'appel. C'est Çquivalent aux 3 lignes de co-
de suivantes :

		move.w #7,-(sp)
		trap #dos
		addq.l #2,sp

SYNCHRO_GEM:
	Permet de se synchroniser avec le GEM avant de sortir d'un program-
me. Vide les buffers clavier en attente, synchronisation trame verticale.

RESOLUT:
	Permet de changer de rÇsolution, en prenant quatre paramätres :
		\1 : le mode vidÇo parmi :
			- res64048016
			- res640480256	
			- res320480tc
			- res32020016		: compatible basse
			- res32024016
			- res32048016
			- res320240256
			- res320240tc
		\2 : le type de rÇsolution => 0:ST / 3:FALCON
		\3 : l'adresse de l'Çcran logique
		\4 : l'adresse de l'Çcran physique

MOUSEOFF:
	Permet de cacher la souris.

MOUSEON:
	Permet de montrer la souris si elle a ÇtÇ cachÇe avec mouseoff par 
exemple.

FILE_OPEN:
	permet d'ouvrir un fichier en lecture, Çcriture en un seul appel : 3 para-
mätre :
		\1 : read (lecture seule) /write (crÇation ou efface s'il existe) / 
read_write (lecture ou Çcriture : Ö associer avec des fseek)
		\2 : nom du fichier soit dans un registre (a0-a6) soit un label : 
pour un pea.
		\3 : registre de destination pour le handle ou le code d'erreur en 
retour.

RESERVE_SCREENS:
	permet de rÇserver un certain nombre d'Çcrans et de changer de rÇsolu-
tion. (pour un swapping d'Çcrans d'une dÇmo par exemple) Les deux pa-
ramätres sont :
		\1 : nombre d'Çcrans
		\2 : resolution (cf. RESOLUT)
	Doivent àtre dÇfinies aussi les 3 constantes suivantes :
		x_max_p : nombre de pixels horizontaux
		y_max_p : nombre de pixels verticaux
		nb_bits_per_pix : nombre de bits pour un pixel dans la rÇsolu-
tion spÇcifiÇe.

	Les x adresse (x * 1.L) des Çcrans seront disponibles dans un tableau 
commenáant au label ecrans. Ces Çcrans seront alignÇs sur des multiples 
de 256 octets.

CHANGE_RESOLUT:
	Cette macro est la màme que RESERVE_SCREENS avec unique-
ment la partie changement de rÇsolution, sans rÇservation d'Çcran.

RESTORE_SCREENS:
	Cette macro restaure l'adresse et la rÇsolution de l'Çcran apräs l'usage 
de CHANGE_RESOLUT.

COLOR256:	
	Cette macro permet de mettre la couleur du fond Ö une certaine couleur 
si vous àtes en mode 256 couleurs. Si le flag FLG_INIBE_COLOR est 
dÇfini, le changement ne sera pas effectuÇ. Cette macro est utile pour es-
timer un temps machine en phase dÇbug et on dÇfinit le flag quand on ne 
veut plus de changement.

COLOR:
	Identique a la macro COLOR256 mais en 16 couleurs ici.

ZILOGR:
	Ceci sert Ö lire un registre du Zilog prÇsent sur le Falcon. Les 3 para-
mätres sont :
		\1 : registre du Zilog
		\2 : registre de destination de lecture
		\3 : canal : 'A' ou 'B'

ZILOGW:
	Ceci sert Ö Çcrire un registre du Zilog prÇsent sur le Falcon. Les 3 para-
mätres sont :
		\1 : registre du Zilog
		\2 : octet Ö t Çcrire
		\3 : canal : 'A' ou 'B'

COPY_STRING:
	Träs utile lors de la manipulation de chaånes de texte pour copier une 
chaåne d'une adresse vers une autre. Les 3 paramätres sont :
		\1 : adresse de la chaåne source pointÇe par une registre.
		\2 : adresse de destination pointÇe par une registre.
		\3 : octet qui marque la fin de la chaåne source : lui aussi sera 
copiÇ.

COPY_STRING_0:
	Idem Ö COPY_STRING mais pour le cas träs frÇquent d'une chaåne 
terminÇe par un 0. Ne prend que 2 paramätres :
		\1 : adresse de la chaåne source pointÇe par une registre.
		\2 : adresse de destination pointÇe par une registre.


Les macros suivantes sont des fonctions systäme mises en macro car el-
les sont souvent utilisÇes.

CRAWCIN:
	Attend une touche au clavier et la renvoie dans d0.

SUPEXEC:
	Execute une fonction superviseur dont l'adresse est dans : \1 et qui se 
termine par un rts.

VSYNC:
	Synchronisation avec le balayage vertical.

VSETMODE:
	Change de mode vidÇo.

CCONWS:
	Affiche une chaåne Ö l'Çcran en mode terminal: \1 adresse de la chaåne.

FATTRIB:
	Lit est modifie les attributs d'un fichier : \1 attribut, \2 flag, \3 nom du 
fichier.

FDELETE:
	Efface un fichier : \1 nom du fichier.

FREAD:
	Lecture d'un fichier :	
		\1 : adresse du buffer.
		\2 : longueur Ö lire
		\3 : handle du fichier

FWRITE:
	êcriture d'un fichier :	
		\1 : adresse du buffer.
		\2 : longueur Ö Çcrire
		\3 : handle du fichier

FSEEK:
	DÇplacement du pointeur de lecture/Çcriture dans un fichier.
		\1 : mode : 0:depuis le dÇbut 1:depuis l'endroit courant 2:depuis 
la fin
		\2 : handle du fichier
		\3 : offset dans le fichier

FCLOSE:
	Fermeture d'un fichier dont le handle est : \1.

FSFIRST:
	Trouve le premier ficher correspondant aux attributs :
		\1 : attributs du chier
		\2 : pointeur sur une chaåne reprÇsentant le masque du nom du 
fichier.
	Le rÇsultat sera dans le buffer DTA courant.

FSNEXT:
	Trouve le fichier suivant correspondant aux critäres spÇcifiÇs avec 
FSFIRST.
	Le rÇsultat sera dans le buffer DTA courant.

DGETDRV:
	Donne le lecteur courant dans d0.

DSETDRV:
	Change le lecteur courant Ö celui spÇcifiÇ dans \1.

DGETPATH:
	Recherche du chemin courant sur le lecteur spÇcifiÇ :
		\1 : lecteur dont on veut le chemin courant.
		\2 : tampon oó stocker le chemin en retour.

DSETPATH:
	Change le chemin par dÇfaut sur le lecteur courant Ö celui spÇcifiÇ dans 
\1.

FSETDTA:
	Change l'adresse du buffer DTA Ö l'adresse spÇcifiÇe dans \1.

FGETDTA:
	RÇcupäre d'adresse du DTA courant dans d0.

MALLOC:
	Alloue la quantitÇ de mÇmoire \1 et retourne dans d0 l'adresse.

MXALLOC:
	Permet d'allouer de la mÇmoire en choisissant son type :
		\1 : type de mÇmoire : 
			RAM_ST		: ST - Ram uniquement
			RAM_TT		: TT - Ram uniquement
			RAM_ST_TT	: si possible ST - Ram sinon TT - Ram
			RAM_TT_ST 	: si possible TT - Ram sinon ST - Ram
		\2 : quantitÇ en octets

MFREE:
	LibÇration d'un bloc de mÇmoire allouÇ quel que soit son type. \1 poin-
te sur le dÇbut du bloc.

SUPER:
	Passe en mode superviseur si \1=0 ou bien dÇtermine en quel mode on 
se trouve (User ou Superviseur) si \1=1.

USER:
	Passe du mode Superviseur en mode User.


	11.2 Librairies Çtendues


	Ce sont des fonctions dont se sert le noyau Visual. Vous pouvez y faire 
appel pour votre gestion systäme, l'ensemble des routines qui peuvent 
àtre utiles Ö un programmeur averti en GEM y sont prÇsentes.
	Certaines de ces fonctions sont implantÇes en fonction des dÇfinitions 
placÇes dans le fichier .DEF. Reportez-vous Ö la section concernant le fi-
chier .DEF pour plus de renseignement.

GWVA_COUNT_BYTES_0:
	EntrÇe		a0.l	= pointeur.
	Sortie		d0.l	= longueur de la chaåne.

	Retourne dans d0.l la longueur de la chaåne pointÇe en son dÇbut par 
a0.l et terminÇe par un 0.

GWVA_COUNT_BYTES:
	EntrÇe		a0.l	= pointeur,
			d1.b	= valeur de fin de chaåne.
	Sortie		d0.l	= longueur de la chaåne.

	Retourne dans d0.l la longueur de la chaåne pointÇe en son dÇbut par 
a0.l et terminÇe par l'octet contenu dans d1.b.

GWVA_APP_OBJ_STORE_CURRENT_PATH:
	EntrÇe		a0.l	= pointeur
	Sortie

	Stocke Ö l'adresse pointÇe par a0.l le chemin complet courant sous le 
format suivant :
	X:\PATH\		X est l'unitÇ et PATH le chemin entier par ex. 
\TOOLS\COMMS\

GWVA_APP_OBJ_SET_PATH:
	EntrÇe		a0.l	= pointeur
	Sortie

	Change le chemin et le lecteur courant pour qu'il soit celui spÇcifiÇ par 
la chaåne pointÇe par a0.l et terminÇ par un 0. Par ex. X:\PATH\

GWVA_APP_OBJ_SEARCH_SYSTEM_COOKIES:
	EntrÇe
	Sortie

	Cette fonction sert Ö l'initialisation pour chercher les cookies par dÇ-
faut, vous ne devriez pas vous en servir autrement qu'en exemple.
	Fonction Ö appeler par un SUPEXEC.

GWVA_APP_OBJ_SEARCH_ONE_COOKIE:
	EntrÇe		Dans GWVA_APP_OBJ_SEARCH_IN_OUT
	Sortie		Dans GWVA_APP_OBJ_SEARCH_IN_OUT

	Recherche d'un cookie.
	Il faut spÇcifier dans GWVA_APP_OBJ_SEARCH_IN_OUT la 
chaåne de 4 caractäres identifiant le cookie et on aura en sortie dans le 
màme pointeur soit 0.l s'il n'a pas ÇtÇ trouvÇ soit un pointeur sur le mot 
long suivant la chaåne qui Çtait cherchÇe.
	Fonction Ö appeler par un SUPEXEC.

GWVA_APP_OBJ_SEARCH_ONE_XBRA:
	EntrÇe		Dans GWVA_APP_OBJ_SEARCH_IN_OUT
	Sortie		Dans GWVA_APP_OBJ_SEARCH_IN_OUT

	Cette fonction permet de rechercher une routine XBRA pour un vec-
teur donnÇ.
	Indiquez dans GWVA_APP_OBJ_SEARCH_IN_OUT le vecteur 
(exemple : $44e.l), et indiquez dans 
GWVA_APP_OBJ_SEARCH_IN_OUT+4 le texte du vecteur (exemple 
"XHDI").
	En retour, vous recevrez dans 
GWVA_APP_OBJ_SEARCH_IN_OUT un pointeur sur le mot long 
apräs la chaåne textuelle demandÇe ou 0.L si la chaåne reste introuvable.
	Fonction Ö appeler par un SUPEXEC si une adresse de base se situe 
dans une zone inaccessible en mode user.

GWVA_APP_OBJ_INSTALL_ONE_XBRA:
	EntrÇe		Dans GWVA_APP_OBJ_SEARCH_IN_OUT
	Sortie		Dans GWVA_APP_OBJ_SEARCH_IN_OUT

	Cette routine permet d'insÇrer facilement une routine XBRA dans un 
vecteur systäme.
	PrÇcisez dans GWVA_APP_OBJ_SEARCH_IN_OUT le vecteur oó 
installer la routine, et prÇcisez dans 
GWVA_APP_OBJ_SEARCH_IN_OUT+4 un pointeur sur la nouvelle 
routine (les trois mots longs qui la prÇcäde doivent àtre : XBRA, "TEXT" 
et 0.L)
	Vous aurez en retour dans GWVA_APP_OBJ_SEARCH_IN_OUT un 
0.L si l'installation s'est passÇe correctement.
	Fonction Ö appeler par un SUPEXEC si une adresse de base se situe 
dans une zone inaccessible en mode user.

GWVA_APP_OBJ_REMOVE_ONE_XBRA:
	EntrÇe		Dans GWVA_APP_OBJ_SEARCH_IN_OUT
	Sortie		Dans GWVA_APP_OBJ_SEARCH_IN_OUT

	Cette routine permet de supprimer facilement une routine XBRA dans 
un vecteur systäme.
	PrÇcisez dans GWVA_APP_OBJ_SEARCH_IN_OUT le vecteur oó 
se trouve la routine Ö dÇsinstaller et prÇcisez dans 
GWVA_APP_OBJ_SEARCH_IN_OUT+4 le texte correspondant Ö la 
routine XBRA Ö dÇsinstaller.
	Vous recevrez en retour dans GWVA_APP_OBJ_SEARCH_IN_OUT 
soit -1 si la routine n'a pas ÇtÇ trouvÇe, ou 0.L si la routine a ÇtÇ correcte-
ment enlevÇe.
	Fonction Ö appeler par un SUPEXEC si une adresse de base se situe 
dans une zone inaccessible en mode user.

GWVA_SHOW_MENU:
	EntrÇe		a0.l	= pointeur du menu
	Sortie		

	Affiche une barre de menu en haut de l'Çcran avec dans a0.l le pointeur 
sur son arbre.

GWVA_HIDE_MENU:
	EntrÇe		a0.l	= pointeur du menu
	Sortie		

	Permet de cacher un menu (avant de faire un PEXEC en systäme mo-
notÉche par exemple) en passant dans a0.l l'adresse de l'arbre du menu.

GWVA_CHECK_MENU:
	EntrÇe		a0.l	= pointeur du menu
			d0.w	= numÇro du menu
			d1.w	= effacer le tag (0), afficher le tag (1)
	Sortie		

	Permet de tagger un ÇlÇment de menu en passant dans a0.l l'adresse de 
l'arbre menu dans d0.w le numÇro du menu et dans d1.w soit 0 pour effa-
cer le tag soit 1 pour l'afficher.

GWVA_GREY_MENU:
	EntrÇe		a0.l	= pointeur du menu
			d0.w	= numÇro du menu
			d1.w	= griser(0), dÇ-griser (1)
	Sortie		

	Permet de griser un ÇlÇment de menu en passant dans a0.l l'adresse de 
l'arbre menu, dans d0.w le numÇro du menu et dans d1.w soit 0 pour le 
griser soit 1 pour l'Çtat normal.

GWVA_FIND_FATHER_OBJECT:
	EntrÇe		a0.l	= pointeur du menu
			d0.w	= numÇro de l'objet
	Sortie		a0.l	= pointeur sur le päre
			d0.w	= numÇro du päre
			d7.w	= 0 si le numÇro du päre est valide, -1 sinon

	Cette routine permet de trouver le päre d'un objet dans un formulaire 
en connaissant son fils. Indiquez dans a0.l le pointeur sur l'arbre formu-
laire contenant l'objet, et dans d0.w le numÇro du fils dont on cherche le 
päre.

GWVA_ENABLE_DISABLE_OBJECT:
	EntrÇe		d0.w	= numÇro de l'arbre formulaire
			d1.w	= numÇro de l'objet dans l'arbre
			d2.w	= nouvel Çtat  : 0=activÇ 1=dÇsactivÇ
	Sortie

	Permet de changer l'Çtat (activÇ/dÇsactivÇ) d'un objet dans un formulai-
re.

GWVA_SHOW_HIDE_TREE:
	EntrÇe		d0.w	= numÇro de l'arbre formulaire
			d1.w	= numÇro de l'objet dans l'arbre
			d2.w	= nouvel Çtat : 0=normal 1=cachÇ
	Sortie

	Permet de cacher ou non un objet et ses fils dans un formulaire.

RSC_ALERT_BOX:
	EntrÇe		d0.w	= numÇro de l'alert-box dans le ressource
			d1.w	= numÇro du bouton par dÇfaut : gauche(1), mi-
lieu(2), droite(3)
	Sortie		d0.w	= numÇro du bouton sÇlectionnÇ

	La faáon la plus simple de faire une boåte d'alerte dans un programme, 
c'est de l'inclure dans le ressource puis d'appeler cette routine avec com-
me paramätres :
	On a en retour dans d0.w le numÇro du bouton choisi finalement.

ALERT_BOX:
	EntrÇe		a0.l	= pointeur sur une chaåne d'alerte
			d0.w	= numÇro du bouton par dÇfaut gauche(1), mi-
lieu(2), droite(3)
	Sortie		d0.w	= numÇro du bouton sÇlectionnÇ

	CrÇe une boite d'alerte GEM. La chaåne d'alerte Ö le format :
	"[numÇro boite 
d'alerte][ligne1|ligne2|...|ligne5][bouton1|bouton2|bouton3]",0
	Le numÇro de la boite peut aller de 0 Ö 3 (jusqu'Ö 5 sur l'AES 4.1.)

RETURN_TREE_OBJ_PTR:
	EntrÇe		a0.l	= pointeur,
			d0.w	= numÇro de l'arbre.
	Sortie		Dans (a0.l)

	Cette fonction va stocker dans le mot long pointÇ par a0.l l'adresse de 
base du formulaire dont le numÇro de l'arbre est spÇcifiÇ dans d0.w.

GWVA_PRG_MODAL_FORM:
	EntrÇe		d0.w	= numÇro de l'arbre
	Sortie		d0.w	= numÇro de l'objet

	Cette fonction permet d'appeler un formulaire d'une faáon bloquante, 
en passant dans d0.w le numÇro de l'arbre, on rÇcupäre en retour dans 
d0.w le numÇro de l'objet exit ou touch-exit qui a ÇtÇ clickÇ.

RETURN_FORM_OBJ_SCULPTURE:
	EntrÇe		d0.w	= numÇro de l'arbre
	Sortie		a0.l	= pointeur sur l'objet
			d0.w	= bord gauche
			d1.w	= bord haut
			d2.w	= bord droit
			d3.w	= bord bas

	Cette fonction permet de connaåtre la taille des sculptures additionnel-
les d'un formulaire.

RETURN_OBJ_IN_FORM_OBJ_PTR:
	EntrÇe		d0.w	= numÇro du formulaire
			d1.w	= numÇro de l'objet
	Sortie	 	a1.l	= pointeur sur l'objet

	Cette fonction permet de retourner un pointeur sur un objet dans un 
formulaire.

RETURN_TEXT_OBJ_IN_FORM_OBJ_PTR:
	EntrÇe		d0.w	= numÇro du formulaire
			d1.w	= numÇro de l'objet
	Sortie		a1.l	= pointeur sur le champs texte.

	Cette fonction, parmi les plus utilisÇes, permet de retourner un poin-
teur sur le texte d'un objet quelque soit son type (bouton, texte ...)
	A n'utiliser que pour des objets contenant du texte.

AFFICH_HEXA:
	EntrÇe		d0.l	=donnÇe
			d1.b	=nombre de bits Ö afficher (jusqu'Ö 32)
	Sortie

	Affichage sur le terminal d'un registre en mode hexadÇcimal.

STOCK_HEXA:
	EntrÇe		a1.l	= adresse de destination pour le stockage
			d0.w	= donnÇe
			d1.b	= nombre de bits Ö prendre en compte dans d0 
(8/16/32)
	Sortie		Dans (a1.l)

	Routine de transformation du contenu d'un registre en chaåne ASCII, et 
stockage.
	En sortie on a la propriÇtÇ suivante :  (a1-1)=0.b

HEXA2VALUE:
	EntrÇe		a0.l	= pointeur sur la chaåne
			d0.w	= octet reprÇsentant le marqueur de fin de chaåne
	Sortie		d1.l	= valeur convertie
			d7.w	= erreur de traitement si d7=-1

	Cette fonction transforme une chaåne ASCII en valeur hexadÇcimale :
	En sortie on a la propriÇtÇ suivante  : (a0-1)=d0 si d7=0

STOCK_DECI:
	EntrÇe		a1.l	= destination oó stocker le chiffre en dÇcimal signÇ
			d0.l	= valeur Ö traiter
	Sortie		Dans (a1.l)

	Une des fonctions les plus utilisÇes : conversion d'une valeur dÇcimale 
en chaåne ASCII, et stockage.
	En sortie on a la propriÇtÇ suivante  : (a1-1)=0.b

DECI2VALUE:
	EntrÇe		a0.l	= pointeur sur la chaåne
			d0.b	= octet de fin de chaåne
	sortie		d1.l	= valeur convertie
			d7.w	= erreur de conversion si d7=-1

	Transforme une chaåne ASCII en une valeur dÇcimale.
	En sortie on a la propriÇtÇ suivante  : (a0-1)=d0 si d7=0

FILE_SELECTOR:
	EntrÇe		a0.l	= texte d'explication (35 caractäres maximum)
			a1.l	= masque (exemple *.ASC,*.SP) (18 caractäres 
maximum)
			a2.l	= ancien chemin (X:\PATH) pour le remettre ou 
bien 0.l si aucun
	Sortie		a0.l	= nom du fichier sÇlectionnÇ (8+1+3 caractäres : 
EX.PRG)
			a1.l	= chemin du fichier sÇlectionnÇ (C:\AUTO\)
			a2.l	= chemin+nom de fichier sÇlectionnÇ (C:\AU-
TO\EX.PRG)
			d0.w	= si d0=0 l'utilisateur a annulÇ si d0<0 alors erreur 
DOS.

	Appelle le sÇlecteur de fichier GEM.

SAVE_PALETTES:
	EntrÇe
	Sortie

	Sauvegarde la palette physique 16 et 256 couleurs dans un BSS.

RESTORE_PALETTES:
	EntrÇe
	Sortie

	Sert pour restaure les 2 palettes physique sauvÇes avec SAVE_PA-
LETTES.

GET_FILE_LENGTH:
	EntrÇe		a0.l	= pointeur sur une chaåne reprÇsentant le nom du 
fichier.
	Sortie		d0.l	= longueur du fichier demandÇ (d0<0 si fichier non 
trouvÇ)

	Permet de se renseigner sur la longueur d'un fichier.

LOAD_FILE_IN_MEM:
	EntrÇe		a0.l	= pointe sur une chaåne reprÇsentant le nom du fi-
chier
			d0.w	= mode d'allocation de la mÇmoire (cf. macro 
MXALLOC)
	Sortie		a0.l	= pointeur sur la zone de mÇmoire allouÇe
			d0.l	= longueur de la zone allouÇe, identique Ö la taille 
fichier
				(d0<0 si fichier non trouvÇ)

	Permet de charger un fichier en mÇmoire en s'occupant de rien d'autre 
que le nom complet du fichier et dans quel type de mÇmoire on veut qu'il 
soit charger.
	Cette fonction nÇcessite que LIB_FLENGTH soit dÇfini dans le fichier 
.DEF de l'application.

RS232_SEND_STRING_WITH_TIMEOUT:
	EntrÇe		a0.l	= pointeur sur le buffer
			d0.l	= longueur de la chaåne
			d1.w	= numÇro du port BIOS
			d2.l	= timeout en 1/200s au bout duquel il faut ressortir 
si le buffer de sortie 
				est plein et ne s'est pas vidÇ.
	Sortie

	Permet d'envoyer une chaåne de caractäres sur un port BIOS sans res-
ter bloquÇ si le buffer de sortie ne se vide pas.

RS232_SEND_STRING_WITHOUT_CONTROL:
	EntrÇe		a0.l	= pointeur sur le buffer
			d0.l	= longueur de la chaåne
			d1.w	= numÇro du port BIOS
	Sortie

	Permet d'envoyer une chaåne de caractäres sur un port BIOS sans vÇri-
fication de timeout (plus rapide mais bloquante si le port est saturÇ).

RS232_TEST_IF_CHAR_PRESENT:
	EntrÇe		d0.w	= port sortie
	Sortie		d7.w	= 0=(au moins 1 car prÇsent) -1=(aucun car prÇ-
sent)

	Teste un port BIOS pour savoir s'il y a au moins un caractäre en atten-
te de lecture.

RS232_GET_AVAILABLE_CHARS:
	EntrÇe		a0.l	= adresse d'un buffer oó seront stockÇs les caractä-
res
			d0.l	=nombre maximum de caractäres Ö capturer (lon-
gueur de votre buffer Ö 
				priori)
			d1.w	= port BIOS
	Sortie		d0.l	= nombre d'octets effectivement capturÇs

	Permet de lire un certain nombre d'octets sur un port BIOS.

GWVA_GET_FORMATED_DATE:
	EntrÇe		a1.l	= pointeur
	Sortie		Dans (a1.l)

	Stocke dans le buffer pointÇ par a1.l une chaåne ASCII reprÇsentant la 
date courante formatÇe comme suit : "JJ/MM/AAAA" exemple : 
29/06/1995

GWVA_GET_FORMATED_TIME:
	EntrÇe		a1.l	= pointeur
	Sortie		Dans (a1.l)

	Stocke dans le buffer pointÇ par a1.l une chaåne ASCII reprÇsentant 
l'heure courante formatÇe comme suit : "HH:MM:SS" exemple : 
19:20:00

GWVA_GET_200HZ_COUNTER:	
	EntrÇe
	Sortie		Dans GWVA_CUR_200HZ_COUNTER

	Stocke le compteur 200 hertz dans le pointeur 
GWVA_CUR_200HZ_COUNTER. ExÇcutez cette routine en supervi-
seur ou avec un SUPEXEC.

GWVA_GET_200HZ_DELAY_SINCE_LAST_CALL:
	EntrÇe		Dans GWVA_OLD_200HZ_COUNTER
	Sortie		d0.l	= dÇlai en 1/200s entre deux appels

	Permet de savoir combien de temps s'est ÇcoulÇ entre deux instants 
donnÇs.
	Commencez par faire un "clr.l GWVA_OLD_200HZ_COUNTER" 
avant votre premier appel. Puis Ö chaque fois que vous appellerez cette 
routine vous obtiendrez dans d0.l le nombre de fois 1/200 seconde qui sÇ-
pare votre appel Ö cette routine du prÇcÇdent.


	11.3 Librairie de relocation de ressource


Cette librairie permet d'avoir son ressource en mÇmoire (entendez en 
DATA dans votre exÇcutable) et de le reloger en passant dans a0.l 
l'adresse de dÇbut.
Cette routine est exÇcutÇe par le Visual Assembleur au lancement du 
programme si vous le dÇfinissez comme tel dans le fichier .OBJ de votre 
application (bit 0 de GWVA_APP_OBJ_FLAGS). Vous devez alors aus-
si placer MDL_RELOCATE_RSC dans le fichier .DEF.


	11.4 Librairie d'appels XHDI


Cette librairie regroupe l'ensemble des appels XHDI qui vous sont of-
ferts. Ils dÇpendent grandement du driver de disque utilisÇ, alors com-
mencez par tester la version du driver avant de faire des appels.
En premier lieu, vous devez initialiser les routines en faisant :
		JSR XH_LOCATE_DRIVER
En retour dans d7.w : 0 si le driver XHDI est prÇsent, -1 sinon


	11.5 Librairie de recherche rÇcursive de 
fichiers


Cette librairie contient une routine qui permet de rechercher un ou plu-
sieurs fichiers Ö travers une arborescence, Çventuellement rÇcursivement, 
en spÇcifiant uniquement un chemin de dÇpart et un masque de recher-
che.
Pour ce fair, vous devez dÇclarer le label suivant : LIB_RECURSI-
VE_FILE_SEARCH.
Un simple saut Ö la routine SEARCH_FILE_RECURSIVELY suffira 
Ö lancer la recherche, qui ressortira quand tous les fichiers auront ÇtÇ exa-
minÇs. Une routine dont vous spÇcifiez l'adresse sera appelÇe chaque fois 
qu'un fichier rencontrÇ correspondra aux critäres que vous avez fixÇs.

	Paramätres d'entrÇe :
		a0.l	= pointeur sur une chaåne donnant le chemin de dÇpart de 
recherche.
			Exemple : U:\PATH
		a1.l	= pointeur sur un masque multiple terminÇ par deux 0.b
			(maximum 100 caractäres)
			Exemple : *.F?D 0 AZERTY.* 0 *.MOD 0 0
		a2.l	= adresse de la routine oó sauter
		d0.w	= 0 recherche normale dans le rÇpertoire spÇcifiÇ, 1 re-
cherche rÇcursive.

	Paramätres de sortie :
		d7.w	= 0 =OK -2=bad path -1=user stop(vous avez rendu d0<0 
lors de
			l'appel Ö votre routine)

	Appel de votre routine :
		EntrÇe	a0	: pointeur sur un nom de fichier rÇpondant 
aux critäres que
					vous avez donnÇs. Exemple : U:\PATH\FI-
LE.EXT
		Sortie		faites un rts avec d0=0 = continue ou bien d0=-1 
arràte la
				recherche. cf ci dessus d7=-1


	11.6 Librairie pour le multi-formulaire


Dans ce fichier, sont regroupÇs les trois routines pour la gestion des 
sauvegardes des formulaires. Ces routines ont ÇtÇ prÇcÇdemment dÇcrites 
dans les mÇthodes des fenàtres formulaires.
