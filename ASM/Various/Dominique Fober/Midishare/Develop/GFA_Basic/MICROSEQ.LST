$m40000  ! Instructions destin‚es au compilateur
$RC&    ! (m40000) => RESERVE 40000 ko
$P<     !
$S& S   !
'
'
initialize       ! initialise les variables et les ressources, menus...
main             ! boucle principale
'
> PROCEDURE lisez_moi
  '
  ' -> voir aussi la proc‚dure @lisez_moi_midishare
  '
  '
  ' ------------------------------------------------------------------------
  '                    MIDI SHARE Application MICROSEQ
  ' ------------------------------------------------------------------------
  '
  '
  ' MICROSEQ: Un exemple d'application midishare sous GFA Basic
  '
  '
  ' Microseq est un s‚quenceur "minimaliste". Il permet d'enregistrer, et
  ' de jouer une s‚quence midi. Il sauve et charge les fichiers au format
  ' Midishare (.MSH).
  ' Tant que la s‚quence n'est pas effac‚e ("CLR"), les ‚vŠnements enregistr‚s
  ' ou les s‚quences charg‚es sont "merg‚es" avec la s‚quence en m‚moire.
  '
  ' Ce programme peut etre compil‚ puis charg‚ en accessoire. Dans ce cas,
  ' l'appui de la touche ALTERNATE lorsque l'on ferme la fenetre de l'accessoire
  ' permet de conserver la s‚quence courante en m‚moire, et de jouer ou
  ' d'enregistrer aprŠs fermeture de la fenetre.
  '
  '
  '
  ' -----------------------------------
  ' FONCTIONNEMENT INTERNE DE MICROSEQ:
  ' -----------------------------------
  '
  ' AprŠs initialisation, la boucle principale attend une action de
  ' l'utilisateur ou un ‚vŠnement midishare.
  '
  ' L'appui de la touche PLAY d‚clenche l'envoi un ‚vŠnement priv‚ "must_play%"
  ' dans lequel se trouve l'adresse du premier ‚vŠnement de la s‚quence …
  ' jouer, et place le drapeau play_flag! sur TRUE. On va utiliser cet
  ' ‚vŠnement must_play% comme une alarme, qui nous indiquera qu'il y a un ou
  ' plusieurs ‚vŠnements de la s‚quence … jouer.
  '
  ' Cet ‚vŠnement must_play% est r‚cup‚r‚ dans la proc‚dure traite_events()
  ' On envoie alors tous les ‚vŠnements de la s‚quence dont la date
  ' coincide(*) avec l'‚vŠnement must_play% re‡u, puis, s'il reste des ‚vŠnements
  ' dans la s‚quence, on renvoie … midishare une nouvelle alarme must_play%
  ' pour la date du prochain ‚vŠnement s‚quence … jouer, etc...
  '
  ' Le type de l'‚vŠnement priv‚ varie de 19 … 28. Il est en fait incr‚ment‚
  ' … chaque nouvel appui de la touche "PLAY". Ceci ‚vite d'‚ventuels problŠmes
  ' si l'utilisateur stoppe puis relance la lecture de la s‚quence trŠs
  ' rapidement. En effet, il est impossible d'acc‚der … un ‚vŠnement aprŠs
  ' l'avoir envoy‚ … MIDISHARE. l' ‚vŠnement must_play% peut etre re‡u aprŠs
  ' l'appui de la touche STOP puis PLAY. D'o— risque de confusion entre
  ' diff‚rents ‚vŠnements must_play% correspondants … des PLAY successifs.
  '
  ' En comparant le type de l'‚vŠnement must_play% de r‚f‚rence et celui
  ' de l'‚vŠnement must_play% re‡u on ‚limine tout risque de confusion, les
  ' ‚vŠnements must_play% re‡us de type ant‚rieurs au must_play% actuel ‚tant
  ' ignor‚s.
  '
  ' Les proc‚dures What_do_i et set_what_do_i permettent de lire et d'‚crire
  ' dans cet ‚vŠnement priv‚ l'adresse de l'‚vŠnement de la s‚quence
  ' … jouer.
  '
  ' La s‚quence midishare: Une s‚quence midishare est en fait un ‚vŠnement
  ' de type particulier. Midishare classe au fur … mesure qu'il les re‡oit
  ' les ‚vŠnements de la s‚quence par ordre chronologique. Chaque ‚vŠnement
  ' de la s‚quence pointe sur l'‚vŠnement suivant. Le dernier ‚vŠnement pointe
  ' sur 0.
  '
  ' Le chargement et la sauvegarde de la s‚quence utilise le programme
  ' MSH_SERV.PRG dont le chemin d'acces est pr‚cis‚ dans la proc‚dure
  ' Init_variables.
  '
  '
  ' (*)En fait, afin d'optimiser la lecture de la s‚quence, on va ‚mettre
  ' les notes de la s‚quence comprises dans la fenetre temporelle d‚finie
  ' dans la proc‚dure init_variables. Voir pour cel… la proc‚dure traite_events
  '
  '
  '   ------------------------------------------------------------------------
  '           REMARQUES CONCERNANT LES RESSOURCES ET LE GFA BASIC
  '   ------------------------------------------------------------------------
  '
  '   Il semblerait que le GFA BASIC g‚nŠre des interf‚rences avec le GEM.
  '   Ainsi, la pr‚sence d'un accessoire programm‚ sous GFA basic provoque
  '   des anomalies … l'affichage: texte ou icone passant partiellement en
  '   inversion vid‚o, effacement de zones ou se situe la souris...
  '
  '   AprŠs diff‚rents essais, il apparait que ces problŠmes sont propres
  '   aux version 3.xx du GFA (le GFA 2.0 fonctionne parfaitement).
  '   L'interf‚rence se produit lorsque le programme intercepte les ‚venements
  '   TIMER, ce qui est indispensable pour pouvoir fonctionner en multitaches.
  '   avec MIDISHARE et les accessoires du bureau.
  '
  '   Une simple boucle do loop avec un appel ON MENU (ou EVENT_MULTI, qui
  '   a la meme fonction) produit ce ph‚nomŠne.
  '
  '   AprŠs info auprŠs de Micro Applications qui distribue le GFA basic,
  '   Ce bug est connu et "devrait" etre corrig‚ dans la version 3.7
  '   qui est actuellement en pr‚paration.
  '
  '
  '   ------------------------------------------------------------------------
  '           @ GRAME 1989/90, Yann Orlarey et Herv‚ Lequay
  '                          Dominique Fober (Atari ST)
  '
  '                    Version GFA Basic v 3.07 / 3.5
  '   ------------------------------------------------------------------------
  '
RETURN
'
> PROCEDURE initialize
  '
  ' /****************************************************************************/
  ' /*                                  INITIALIZE                              */
  ' /*--------------------------------------------------------------------------*/
  ' /* Initialisations g‚n‚rales ( ressources , fenˆtre, Midi)                  */
  ' /*                                                                          */
  ' /* Les paramŠtres de l'appel :                                              */
  ' /* ---------------------------                                              */
  ' /*                                                                          */
  ' /*          aucun                                                           */
  ' /*                                                                          */
  ' /****************************************************************************/
  '
  ~FRE(0)              ! garbage collect de la m‚moire
  RESERVE 40000
  appl_name$="Microseq"+CHR$(0)! … modifier selon le nom de votre application
  want_filter=TRUE
  my_refnum&=-1
  '
  gl_apid%=APPL_INIT()
  DEFFILL 1,2,4
  PBOX 0,19,639,399
  DEFFILL 1,0
  ~GRAF_MOUSE(0,0)
  wi_handle&=-1                        ! fenetre ferm‚e
  SHOWM
  '
  IF @init_midishare=0                 ! interfa‡age impossible
    ~APPL_EXIT()
    EDIT
  ENDIF
  '
  init_var_rsc               ! initialise les variables objets du fichier RSC
  '
  ~RSRC_FREE()                         ! libŠre les ressources de la m‚moire
  IF NOT @set_up_rsc("microseq.RSC")   ! charge les ressources, menus...
    IF gl_apid%=0
      ~APPL_EXIT()
      EDIT
    ENDIF
  ENDIF
  '
  IF gl_apid%=0                        !
    IF NOT @open_appl                  ! ouverture de l'application
      EDIT
    ENDIF
  ENDIF
  '
  '
RETURN
'
> FUNCTION set_up_midi
'
' /****************************************************************************/
' /*                                 SETUP MIDI                               */
' /*--------------------------------------------------------------------------*/
' /* V‚rifie la pr‚sence de MidiShare, la possibilit‚ d'ouverture Midi, et    */
' /* installe la proc‚dure d'alarme qui sera appel‚e par MidiShare lors des   */
' /* changements de statut des applications ou des ports.                     */
' /*                                                                          */
' /* Les paramŠtres de l'appel :                                              */
' /* ---------------------------                                              */
' /*                                                                          */
' /*          aucun                                                           */
' /*                                                                          */
' /****************************************************************************/
'
IF NOT @midi_share                    ! V‚rifie la pr‚sence de MidiShare
  RETURN @alert_user(-4)
ENDIF
IF my_refnum&<>-1
  RETURN TRUE                         ! l'application est dej… ouverte
ENDIF
'
my_refnum&=@midi_open(appl_name$)     ! Ouvre l'application pour MidiShare
IF my_refnum&=-1                      ! V‚rifie que tout s'est bien pass‚
  RETURN @alert_user(-5)
ENDIF
IF (want_filter)
  @install_filter                     ! Installe le filtre de r‚ception
ENDIF
'
@midi_connect(0,my_refnum&,TRUE)      ! Connecte l'entr‚e de l'appl. aux entr‚es physiques
@midi_connect(my_refnum&,0,TRUE)      ! Connecte la sortie de l'appl. aux sorties physiques
'
RETURN TRUE
'
ENDFUNC
'
> PROCEDURE main
'
' Boucle principale. On traite les ‚vŠnements clavier, souris et aes
' … chaque passage sur ON MENU, puis on traite les ‚vŠnements midi re‡us
'
LOCAL done_flag!
'
ON MENU KEY GOSUB traite_clavier         ! comme son nom l'indique
ON MENU BUTTON 1,1,1 GOSUB traite_souris ! manipulation des objets RSC
ON MENU MESSAGE GOSUB traite_aes         ! gestion de la fenetre
ON MENU GOSUB traite_aes                 ! gestion de la barre de menu
'
WHILE NOT done_flag!
  ON MENU 2
  '
  @receive_events(my_refnum&) ! on va voir s'il y a des ‚vŠnements re‡us
  '                           ! il est recommand‚ d'ins‚rer des
  '                           ! Gosub @receive_events dans les boucles
  '                           ! externes … la boucle principale
  '                           ! (voir proc‚dure "show_info")
  ' /...
  ' .../
  '
WEND
'
' On s'en va ...
'
~MFREE(msh_mem%)            ! libŠre la m‚moire allou‚e par InitMidiShare
IF want_filter
  ~MFREE(my_filter%)        ! libŠre la m‚moire allou‚e pour les filtres
ENDIF
'
RETURN
'
> PROCEDURE init_var_rsc
'
' D‚finition des variables du fichier RSC
'
LET main_form%=0
LET play%=2
LET rec%=3
LET stop%=4
LET clr%=5
LET info%=6
LET count%=7
'
LET info_form%=1
LET ok_info%=36
'
LET menu1%=2
LET menu_info%=7
'
RETURN
'
> FUNCTION set_up_rsc(rscname$)
'
' /****************************************************************************/
' /*                             SET UP RESSOURCES                            */
' /*--------------------------------------------------------------------------*/
' /* Chargement des ressources                                                */
' /* Installation de la barre de menus                                        */
' /*                                                                          */
' /* Les paramŠtres de l'appel :                                              */
' /* ---------------------------                                              */
' /*                                                                          */
' /*          rscName$ :     nom du fichier de ressources                      */
' /*                                                                          */
' /****************************************************************************/
'
'
'
IF RSRC_LOAD(rscname$)
'
IF RSRC_GADDR(0,main_form%,adr_rsc%)=0    ! formulaire principal
  RETURN @alert_user(-2)
ENDIF
IF RSRC_GADDR(0,menu1%,adr_menu%)=0       ! menu
  RETURN @alert_user(-2)
ENDIF
IF RSRC_GADDR(0,info_form%,adr_about%)=0  ! formulaire "info"
  RETURN @alert_user(-2)
ENDIF
IF gl_apid%=0                             ! si l'application n'est pas
  ~MENU_BAR(adr_menu%,1)                  ! lanc‚e en accessoire
ELSE
  menu_id%=MENU_REGISTER(gl_apid%,"  Microseq")
ENDIF
RETURN TRUE
ELSE
RETURN @alert_user(-1)
ENDIF
ENDFUNC
'
> PROCEDURE init_variables
'
' Initialisation des variables utilis‚es par l'application
' ATTENTION il faut ‚galement penser … lib‚rer les ‚vŠnements et
' les s‚quences Midishare lorsque l'on quitte l'application
' voir procedure "free_variables"
'
LOCAL drive
'
main_wind_valide!=TRUE
play_flag!=FALSE
rec_flag!=FALSE
'
must_play%=@midi_new_ev(20)        ! cr‚e un ‚vŠnement de type priv‚ 20
my_seq%=@midi_new_seq              ! cr‚e une s‚quence de pointeur my_seq%
count_of_events%=0                 ! nombre d'‚v‚nements re‡us
old_count%=0                       ! pour savoir s'il a chang‚
'
fenetre_temp%=200                  ! fenetre temporelle 200 ms
@make_path
'
flag_init!=TRUE
'
RETURN
'
> PROCEDURE free_variables
'
' => libŠre les ‚vŠnements midishare utilis‚s par l'application
'
' (Cette proc‚dure est appel‚e par la proc‚dure @close_app)
'
@midi_free_seq(my_seq%)
@midi_free_ev(must_play%)
'
flag_init!=FALSE
'
RETURN
'
> PROCEDURE traite_souris
'
' /****************************************************************************
' *                                  TRAITE SOURIS                           *
' *--------------------------------------------------------------------------*
' * Proc‚dure charg‚e du suivi de la souris dans la boucle principale        *
' *                                                                          *
' * Les paramŠtres de l'appel :                                              *
' * ---------------------------                                              *
' *          aucun                                                           *
' *                                                                          *
' ***************************************************************************/
'
LOCAL object&,state&,shift!
'
IF WIND_FIND(MENU(10),MENU(11))=wi_handle& ! si c'est sur la fenetre de l'application
IF main_wind_valide!
  shift!=(BIOS(11,-1)=2)       ! d‚tecte si la touche shift est enfonc‚e
  object&=OBJC_FIND(adr_rsc%,0,5,MENU(10),MENU(11))    ! quel objet ?
  IF object&<>-1 AND AND(OB_FLAGS(adr_rsc%,object&),1) ! si selectionnable
    state&=OB_STATE(adr_rsc%,object&)                  ! -> quel ‚tat
    '                                                  !(activ‚?, non activ‚?)
    SELECT object&
      '
    CASE play%
      play_seq
      '
    CASE rec%
      rec_seq
      '
    CASE stop%
      stop_seq
      '
    CASE clr%
      clear_seq
      '
    CASE info%
      show_info
    ENDSELECT
  ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE traite_clavier
'
' Cette proc‚dure permet de traiter l'appui d'une touche du clavier
' Par exemple, l'appui sur ESCAPE fermera l'application
'
LOCAL state&,ascii|,clavier|
state&=MENU(13)               ! flags ‚tat des touches CTRL,ALT et SHIFT...
ascii|=BYTE(MENU(14))         ! Code ascii du caractŠre
clavier|=SHR(MENU(14),8)      ! code clavier du caractŠre
'
SELECT ascii|
'
CASE 27       ! touche ESCAPE -> on s'en va
'
~WIND_CLOSE(wi_handle&)
~WIND_DELETE(wi_handle&)
wi_handle&=-1
@close_appl
IF gl_apid%=0
  done_flag!=TRUE
ENDIF
'
CASE 42       ! touche *
rec_seq
'
CASE 13       ! touche ENTER
IF main_wind_valide!
  play_seq
ELSE
  on_sort!=TRUE
ENDIF
'
CASE 32       ! touche ESPACE
stop_seq
'
ENDSELECT
'
' /...
' Autres traitements associ‚s au clavier
' .../
'
RETURN
'
> PROCEDURE display_count
@ob_ecrit_val(adr_rsc%,count%,count_of_events%)
old_count%=count_of_events%
~OBJC_DRAW(adr_rsc%,count%,1,xdesk&,ydesk&,wdesk&,hdesk&)
RETURN
'
> PROCEDURE receive_events(refnum&)
' Cette proc‚dure permet de traiter les ‚vŠnements midi re‡us
' Refnum& est l'identificateur midishare de l'application
' (voir set_up_midi)
'
LOCAL n%,e%
'
n%=@midi_count_evs(refnum&)          ! nbre d'‚v‚nements re‡us
IF rec_flag! AND n% AND offset_rec%=0
offset_rec%=@midi_get_time         ! offset de d‚but de l'enregistrement
ENDIF
WHILE n%>0                           ! tant qu'il en reste … traiter
e%=@midi_get_ev(refnum&)           ! r‚cupŠrer l'‚v‚nement
IF play_flag!
  traite_event(e%,refnum&)           ! traitement de l'‚vŠnement recu
  @midi_free_ev(e%)                  ! libŠre l'‚vŠnement
ELSE IF rec_flag!                    ! Enregistrement en cours
  set_event_date(e%,@event_date(e%)-offset_rec%) ! => date depuis debut rec
  @midi_add_seq(my_seq%,e%)          ! on l'envoie dans la s‚quence
  INC count_of_events%
ELSE                               ! ni play ni record
  midi_free_ev(e%)                 ! on libŠre l'‚v‚nement
ENDIF
DEC n%                             ! et un ‚vŠnement de moins … traiter!...
WEND
' => Ne jamais essayer d'acc‚der … un ‚vŠnement aprŠs l'avoir envoy‚
' a midishare par un @midi_send, @midi_send_im ou @midi_send_at !!
IF rec_flag! AND count_of_events%<>old_count%
@display_count
ENDIF
RETURN
'
> PROCEDURE traite_event(event%,refnum&)
LOCAL e%,alarm%,date_max%
'
' Cette proc‚dure va effectuer le traitement des ‚vŠnements MIDI re‡us.
'
IF @event_type(event%)=@event_type(must_play%) ! event = evenement must play?
e%=@what_do_i(event%)        ! quel ‚vŠnement doit on jouer ?
'
' On d‚finie une date maximale jusqu'… laquelle on emet les ‚vŠnements
' de la s‚quence en cours. Au del…, on enverra une alarme must_play%
' pour ‚mettre ces ‚vŠnements ult‚rieurement
'
date_max%=@midi_get_time-offset_play%+fenetre_temp%
'
' Tant qu'il reste un ‚vŠnement … jouer et que sa date est inf‚rieure
' … date_max, on en envoie une copie, et on passe au suivant...
'
DO WHILE e% AND @event_date(e%)<date_max%
  @midi_send_at(refnum&,@midi_copy_ev(e%),@event_date(e%)+offset_play%+fenetre_temp%)
  e%=@seq_next(e%) ! et on passe … l'‚vŠnement suivant
LOOP
'
IF e%                               ! s'il reste un ‚vŠnement … jouer
  alarm%=@midi_copy_ev(must_play%)  ! on recopie l'‚vŠnement must_play
  set_what_do_i(alarm%,e%) ! dans lequel on pointe le prochain ev … jouer
  midi_send_at(refnum&,alarm%,@event_date(e%)+offset_play%)! et on envoie
ELSE  ! il n'y a plus d'‚vŠnement … jouer dans la s‚quence
  play_flag!=FALSE
  IF main_wind_valide!
    ~OBJC_CHANGE(adr_rsc%,play%,0,xdesk&,ydesk&,wdesk&,hdesk&,BCLR(OB_STATE(adr_rsc%,play%),0),1)
  ENDIF
ENDIF
ENDIF
'
RETURN
'
> PROCEDURE play_seq               ! d‚clenche la lecture
LOCAL e%,alarm%
'
IF NOT (play_flag! OR rec_flag!) ! si pas de play ou de rec en cours
~OBJC_CHANGE(adr_rsc%,play%,0,xdesk&,ydesk&,wdesk&,hdesk&,BSET(OB_STATE(adr_rsc%,play%),0),1)
offset_play%=@midi_get_time    ! d‚termine l'offset de d‚but de la s‚quence
e%=@seq_first(my_seq%)         ! e% = premier ‚vŠnement de la s‚quence
IF e%                          ! s'il existe (s‚quence non vide)
  '
  set_event_type(must_play%,19+(@event_type(must_play%-19)+1) MOD 10)
  alarm%=@midi_copy_ev(must_play%)! on recopie un ‚vŠnement must_play
  set_what_do_i(alarm%,e%) !dans lequel on place pointeur evenement … jouer
  midi_send_at(my_refnum&,alarm%,@event_date(e%)+offset_play%) !on envoie
  play_flag!=TRUE
ELSE                 ! s‚quence vide -> on fait juste clignoter la touche
  PAUSE 4
  @wait_release
  ~OBJC_CHANGE(adr_rsc%,play%,0,xdesk&,ydesk&,wdesk&,hdesk&,BCLR(OB_STATE(adr_rsc%,play%),0),1)
ENDIF
ENDIF
'
RETURN
'
> PROCEDURE rec_seq            ! d‚clenche l'enregistrement
IF NOT (rec_flag! OR play_flag!)
rec_flag!=TRUE             ! flag utilis‚ dans traite_event
~OBJC_CHANGE(adr_rsc%,rec%,0,xdesk&,ydesk&,wdesk&,hdesk&,BSET(OB_STATE(adr_rsc%,rec%),0),1)
ENDIF
RETURN
'
> PROCEDURE stop_seq        ! stoppe l'enregistrement et la lecture en cours
LOCAL i|
~OBJC_CHANGE(adr_rsc%,stop%,0,xdesk&,ydesk&,wdesk&,hdesk&,BSET(OB_STATE(adr_rsc%,stop%),0),1)
'
~OBJC_CHANGE(adr_rsc%,rec%,0,xdesk&,ydesk&,wdesk&,hdesk&,BCLR(OB_STATE(adr_rsc%,rec%),0),1)
~OBJC_CHANGE(adr_rsc%,play%,0,xdesk&,ydesk&,wdesk&,hdesk&,BCLR(OB_STATE(adr_rsc%,play%),0),1)
play_flag!=FALSE
rec_flag!=FALSE
offset_rec%=0
FOR i|=0 TO 15 ! -> on envoie des all_note_off sur les 16 canaux midi
@midi_send_at(my_refnum&,@event_all_notes_off(i|),@midi_get_time+fenetre_temp%*2)
NEXT i|
PAUSE 4
@wait_release
~OBJC_CHANGE(adr_rsc%,stop%,0,xdesk&,ydesk&,wdesk&,hdesk&,BCLR(OB_STATE(adr_rsc%,stop%),0),1)
RETURN
'
> PROCEDURE clear_seq           ! efface la s‚quence my_seq%
IF NOT (play_flag! OR rec_flag!) ! si pas de lecture ni d'enregistrement
~OBJC_CHANGE(adr_rsc%,clr%,0,xdesk&,ydesk&,wdesk&,hdesk&,BSET(OB_STATE(adr_rsc%,clr%),0),1)
midi_clear_seq(my_seq%)        ! en cours
~OBJC_CHANGE(adr_rsc%,clr%,0,xdesk&,ydesk&,wdesk&,hdesk&,BCLR(OB_STATE(adr_rsc%,clr%),0),1)
count_of_events%=0
@display_count
ENDIF
RETURN
'
> PROCEDURE show_info
'
' Affichage du formulaire informations
'
LOCAL x%,y%,w%,h%
LOCAL on_sort!,save$
main_wind_valide!=FALSE                      ! ‚vite interf‚rences
'                                            ! avec la fenetre principale
@ob_ecrit_txt(adr_about%,3,STR$(@midi_get_version/100))
'
~WIND_UPDATE(3)
~FORM_CENTER(adr_about%,x%,y%,w%,h%)
GET x%,y%,x%+w%,y%+h%,save$
~OBJC_DRAW(adr_about%,0,5,x%,y%,w%,h%)
'
ON MENU BUTTON 1,1,1 GOSUB traite_souris_info ! traitement souris sp‚cifique
DO                                            ! … ce formulaire
ON MENU
@receive_events(my_refnum&) ! on va voir s'il y a des ‚vŠnements re‡us
LOOP UNTIL on_sort!
'
ON MENU BUTTON 1,1,1 GOSUB traite_souris      ! on restore le branchement
~OBJC_CHANGE(adr_about%,ok_info%,0,x%,y%,w%,h%,&H30,0)
PUT x%,y%,save$
~WIND_UPDATE(2)
main_wind_valide!=TRUE
RETURN
'
> PROCEDURE traite_souris_info
'
' Proc‚dure de traitement des ‚vŠnements souris dans la proc‚dure
' show_info
'
SELECT OBJC_FIND(adr_about%,0,10,MENU(10),MENU(11))
'
CASE ok_info%
on_sort!=TRUE
ENDSELECT
'
RETURN
'
> PROCEDURE set_what_do_i(must_play%,event%)
'
' Un ‚vŠnement de type priv‚ contient 4 champs de 4 octets d'usage libre
'
' On aurait pu aussi ‚crire dans le champs Num‚ro 2:
' ex: LPOKE LPEEK(must_play%+12)+4,event%
'
LPOKE LPEEK(must_play%+12),event%
RETURN
'
> FUNCTION what_do_i(must_play%)
'
' Voir proc‚dure set_what_do_i()
' On aurait alors lu le champs num‚ro 2:
' ex: LPEEK((LPEEK(must_play%+12)+4)
'
RETURN LPEEK(LPEEK(must_play%+12))
ENDFUNC
'
'
' ***************************************************************************
' ************* Atari utilities: gestion des fenetres et des ressources *****
' ***************************************************************************
'
> PROCEDURE wait_release
WHILE MOUSEK
WEND
RETURN
'
> FUNCTION alert_user(errindex&)           ! Signale une erreur … l'utilisateur
LOCAL message$,ret
'
message$="| Erreur  "+CHR$(errindex&)
SELECT errindex&
'
CASE -1
message$=" | Fichier de ressources | introuvable !"
CONT
'
CASE -2
message$=" | Fichier de ressources | probablement endommag‚ !"
~RSRC_FREE()
CONT
'
CASE -3
message$=" | Il n'y a plus de | fen"+CHR$(210)+"tre disponible !"
CONT
'
CASE -4
message$=" | MidiShare | n'est pas install‚ !"
CONT
'
CASE -5
message$=" | Il n'y a plus d'application | MidiShare disponible !"
CONT
'
CASE -6
message$=" | Il n'y a plus d'‚vŠnement   | MidiShare disponible !"
CONT
'
CASE -7
message$="Erreur de lecture | du fichier"
CONT
'
CASE -8
message$="Erreur d'‚criture | du fichier"
CONT
'
CASE -9
message$="Plus d'‚vŠnement | Midishare disponible"
CONT
'
CASE -10
message$="erreur de format | du fichier"
CONT
'
CASE -14
message$=" Fichier | inexistant..."
'
ENDSELECT
ALERT 3,message$,1,"OK",ret
RETURN FALSE
ENDFUNC
'
> PROCEDURE traite_aes
'
' Cette proc‚dure gŠre les messages en provenance de l'AES:
' => d‚placement, fermeture ou rafraichissement de la fenetre, etc...
'
SELECT MENU(1)    ! Selon le message renvoy‚ par l'AES
'
CASE 20               ! WM_REDRAW -> il faut redessiner la fenetre
IF MENU(4)=wi_handle&
@do_redraw(MENU(5),MENU(6),MENU(7),MENU(8))
ENDIF
CONT
'
CASE 21               ! WM_TOPPED -> fenetre activ‚e
IF MENU(4)=wi_handle&
main_wind_valide!=TRUE
~WIND_SET(wi_handle&,10,ret&,ret&,ret&,ret&)
ELSE
main_wind_valide!=FALSE
ENDIF
CONT
'
CASE 22               ! WM_CLOSED -> fenetre ferm‚e (on s'en va)
IF MENU(4)=wi_handle&
~WIND_CLOSE(wi_handle&)
~WIND_DELETE(wi_handle&)
wi_handle&=-1
@close_appl
IF gl_apid%=0
done_flag!=TRUE  ! done_flag! est utilis‚ dans la proc‚dure "main"
ENDIF
ENDIF
CONT
'
CASE 28               ! WM_MOVED -> fenetre d‚plac‚e
IF MENU(4)=wi_handle&
~WIND_SET(wi_handle&,5,MENU(5),MENU(6),MENU(7),MENU(8))
~WIND_GET(wi_handle&,5,xdesk&,ydesk&,wdesk&,hdesk&)
@update_window
ENDIF
CONT
'
CASE 41               ! AC_CLOSE -> on ferme un accessoire
IF (MENU(4)=menu_id%) AND (wi_handle&<>-1)
wi_handle&=-1
~WIND_DELETE(wi_handle&)
@close_appl
ENDIF
CONT
'
CASE 40               ! AC_OPEN -> on ouvre un accessoire
IF MENU(5)=menu_id% ! Attention, erreur sur la doc GFA 3.0
IF wi_handle&=-1  ! c'est bien MENU(5) et non MENU(4) qui
~@open_appl     ! retourne menu_id%
ELSE
TOPW #(W_INDEX(#wi_handle&))
ENDIF
ENDIF
CONT
'
CASE 10               ! MN_SELECTED -> menu s‚lectionn‚
@do_command(MENU(0),MENU(4))
CONT
'
CASE 29                             ! WM_NEWTOP
'
ENDSELECT
RETURN
'
> PROCEDURE update_window
~WIND_GET(wi_handle&,4,xwork&,ywork&,wwork&,hwork&)
CLIP xwork&,ywork&,wwork&,hwork&-1
OB_X(adr_rsc%,0)=xwork&
OB_Y(adr_rsc%,0)=ywork&
RETURN
'
> PROCEDURE do_redraw(xr&,yr&,wr&,hr&)
LOCAL x2&,y2&,w2&,h2&
'
~WIND_GET(wi_handle&,11,x2&,y2&,w2&,h2&)
~WIND_UPDATE(1)
WHILE w2&<>0 AND h2&<>0
IF RC_INTERSECT(xr&,yr&,wr&,hr&,x2&,y2&,w2&,h2&)
~OBJC_DRAW(adr_rsc%,0,5,x2&,y2&,w2&,h2&)
ENDIF
~WIND_GET(wi_handle&,12,x2&,y2&,w2&,h2&)
WEND
~WIND_UPDATE(0)
RETURN
'
> FUNCTION open_appl
IF @set_up_midi                         ! ouverture MidiShare
IF @set_up_windows                    ! initialisations fenˆtre
IF NOT (flag_init!)
init_variables
ENDIF
RETURN TRUE
ENDIF
ENDIF
@close_appl
RETURN FALSE
ENDFUNC
'
> PROCEDURE close_appl
LOCAL ret%
'
'
IF gl_apid%<>0                         ! si l'application est en accessoire
IF @midi_share AND my_refnum&<>-1    ! si MidiShare est toujours install‚
IF NOT BTST(BIOS(11,-1),3)         ! si alternate non appuy‚e
free_variables
@midi_close(my_refnum&)            ! ferme l'application MidiShare
my_refnum&=-1
ELSE
ENDIF
ENDIF
ELSE
IF my_refnum&<>-1                    ! si l'appl MidiShare est install‚e
free_variables
@midi_close(my_refnum&)            ! ferme l'application MidiShare
ENDIF
~MENU_BAR(adr_menu%,0)           ! supprime la barre des menus
~RSRC_FREE()                     ! libŠre les ressources
~APPL_EXIT()                     ! Quitte l'application
ENDIF
RETURN
'
> FUNCTION set_up_windows
'
' /****************************************************************************/
' /*                             Setup windows                                */
' /*--------------------------------------------------------------------------*/
' /* Ouvre la fenˆtre                                                         */
' /*                                                                          */
' /* Les paramŠtres de l'appel :                                              */
' /* ---------------------------                                              */
' /*                                                                          */
' /*          aucun                                                           */
' /*                                                                          */
' /****************************************************************************/
LOCAL ret&
'
~FORM_CENTER(adr_rsc%,xdesk&,ydesk&,ret&,ret&)
~WIND_CALC(0,11,xdesk&,ydesk&,OB_W(adr_rsc%,0),OB_H(adr_rsc%,0),ret&,ret&,wdesk&,hdesk&)
~GRAF_GROWBOX(xdesk&+wdesk&/2,ydesk&+hdesk&/2,40,40,xdesk&,ydesk&,wdesk&,hdesk&)
wi_handle&=WIND_CREATE(11,xdesk&,ydesk&,wdesk&,hdesk&)
~WIND_SET(wi_handle&,2,CARD(SWAP(V:appl_name$)),CARD(V:appl_name$),ret&,ret&)
~WIND_SET(wi_handle&,12,xdesk&,ydesk&,wdesk&,hdesk&)
~WIND_OPEN(wi_handle&,xdesk&,ydesk&,wdesk&,hdesk&)
@update_window
RETURN TRUE
ENDFUNC
'
> PROCEDURE do_command(menu&,item&)
'
' /****************************************************************************
' *                                   DO COMMAND                              *
' *---------------------------------------------------------------------------*
' * Execution des commandes du menu. Ici on se contente de g‚rer l'item       *
' * Informations .                                                            *
' *                                                                           *
' * Les paramŠtres de l'appel :                                               *
' * ---------------------------                                               *
' *                                                                           *
' *          menu :     le titre du menu s‚lectionn‚.                         *
' *          item :     l'item de ce menu s‚lectionn‚.                        *
' *                                                                           *
' ****************************************************************************/
'
~MENU_TNORMAL(adr_menu%,menu&,1)
SELECT item&
CASE 3
@show_info
CONT
'
' /*-----------*/
ENDSELECT
RETURN
'
> FUNCTION ob_lit_val(arbre%,objet%)
'
' Permet de lire la valeur affich‚e par un objet RSC
'
LOCAL txt$,i|,a|
DO
a|=PEEK(LPEEK(OB_SPEC(arbre%,objet%))+i|)
EXIT IF a|=0
txt$=txt$+CHR$(a|)
INC i|
LOOP
RETURN VAL(txt$)
ENDFUNC
'
> PROCEDURE ob_ecrit_val(arbre%,objet%,valeur%)
'
' Permet d'‚crire une valeur … afficher par un objet RSC
'
LOCAL txt$,i|
txt$=" "+STR$(valeur%)+" "+CHR$(0)
FOR i|=1 TO LEN(txt$)
POKE LPEEK(OB_SPEC(arbre%,objet%))+i|-1,ASC(MID$(txt$,i|,1))
NEXT i|
RETURN
'
> FUNCTION ob_lit_txt$(arbre%,objet%)
'
' Permet de lire un texte affich‚ par un objet RSC
'
LOCAL txt$,i|,a|
DO
a|=PEEK(LPEEK(OB_SPEC(arbre%,objet%))+i|)
EXIT IF a|=0
txt$=txt$+CHR$(a|)
INC i|
LOOP
RETURN txt$
ENDFUNC
'
> PROCEDURE ob_ecrit_txt(arbre%,objet%,txt$)
'
' Permet d'‚crire un texte … afficher par un objet RSC
'
LOCAL i|
FOR i|=1 TO LEN(txt$)
POKE LPEEK(OB_SPEC(arbre%,objet%))+i|-1,ASC(MID$(txt$,i|,1))
NEXT i|
RETURN
'
'
' *************************************************************************
' ******* Proc‚dures et fonction sp‚cifiques au GFA Basic     *************
' ******* permettant la manipulation des ‚vŠnements MIDISHARE *************
' *************************************************************************
'
' ------------------------- Fonctions d'acces aux filtres ----------------
'
> PROCEDURE install_filter
'
' /****************************************************************************
' *                               InstallFilter                               *
' *---------------------------------------------------------------------------*
' * Cette proc‚dure d‚finit les valeurs du filtre de l'application. Un filtre *
' * est compos‚ de trois parties, qui sont trois tableaux de bool‚ens :       *
' *                                                                           *
' *          un tableau de 256 bits pour les ports Midi accept‚s              *
' *          un tableau de 256 bits pour les types d'‚v‚nements accept‚s      *
' *          un tableau de  16 bits pour les canaux Midi accept‚s             *
' *                                                                           *
' * Dans le code ci dessous, le filtre est param‚tr‚ pour accepter n'importe  *
' * quel type d'‚v‚nement.                                                    *
' *                                                                           *
' * Les paramŠtres de l'appel :                                               *
' * ---------------------------                                               *
' *                                                                           *
' *          aucun                                                            *
' *                                                                           *
' ****************************************************************************/
'
LOCAL i&
'
my_filter%=MALLOC(256+16)
FOR i&=0 TO 256
@accept_bit(my_filter%+32,i&)       ! accepte tous les types d'‚v‚nements
@accept_bit(my_filter%,i&)          ! en provenance de tous les ports
NEXT i&
'
FOR i&=0 TO 16
@accept_bit(my_filter%+64,i&)       ! et sur tous les canaux Midi
NEXT i&
'
@midi_set_filter(my_refnum&,my_filter%) ! installe le filtre
RETURN
'
'
' *********** Fonctions retournant des ‚vŠnements  divers ********************
' (program change, all_notes_off, controlleurs...)
'
' Attention, les canaux midi vont de 0 … 15 !...
'
' Ex: pour affecter le program 15 au canal midi 3:
' midi_send_im(@event_pgrm_change(2,15))
'
> FUNCTION event_pgrm_change(midi_chan|,num_program|)
LOCAL e%
e%=@midi_new_ev(5)
IF e%
set_event_chan(e%,midi_chan|)
POKE e%+12,num_program|
ENDIF
RETURN e%
'
ENDFUNC
'
> FUNCTION event_ctrl_change(midi_chan|,num_ctrl|,valeur|)
LOCAL e%
e%=@midi_new_ev(4)
IF e%
set_event_chan(e%,midi_chan|)
POKE e%+12,num_ctrl|
POKE e%+13,valeur|
ENDIF
RETURN e%
'
ENDFUNC
'
> FUNCTION event_system_reset
LOCAL e%
e%=@midi_new_ev(16)
RETURN e%
'
ENDFUNC
'
> FUNCTION event_ctrl_reset(midi_chan|)
LOCAL e%
e%=@midi_new_ev(4)
IF e%
set_event_chan(e%,midi_chan|)
POKE e%+12,&H79
ENDIF
RETURN e%
'
ENDFUNC
'
> FUNCTION event_all_notes_off(midi_chan|)
LOCAL e%
e%=@midi_new_ev(4)
IF e%
set_event_chan(e%,midi_chan|)
POKE e%+12,&H7B
ENDIF
RETURN e%
'
ENDFUNC
'
> FUNCTION event_pitch_bend(midi_chan|,valeur%)
'
' valeur% = valeur de pitchbend de 0 … 32639
'
' VALEUR    DECIMALE    HEXADECIMALE    BINAIRE        RESULTAT
' ------------------------------------------------------------------------
' min:        0            0000           0          => pitch bend en bas
' max:      32639          7F7F     111111101111111  => pitch bend en haut
' med:      16384          4000     100000000000000  => pitch bend au milieu
'
LOCAL e%
e%=@midi_new_ev(7)
IF e%
set_event_chan(e%,midi_chan|)
POKE e%+12,BYTE(valeur%)
POKE e%+13,BYTE(SHR(valeur%,8))
ENDIF
RETURN e%
'
ENDFUNC
'
' ---------------- Fonctions relative … la gestion des s‚quences ---------
'
> FUNCTION seq_first(seq_ptr%)
' -> retourne le premier ‚vŠnement de la sequence "seq_ptr%"
'
' Remarque:
' si la s‚quence est vide, @seq_first(seq_ptr%) = 0
'
RETURN LPEEK(seq_ptr%)
ENDFUNC
'
> FUNCTION seq_next(event%)
' -> retourne l'‚vŠnement suivant de la s‚quence
'
' Les ‚vŠnements d'une s‚quence sont chain‚s les uns derriŠre les autres
' par ordre chronologique.
' evenement_suivant% = @seq_next(evŠnement_courant%)
'
' remarque: si last% est le dernier ‚vŠnement d'une s‚quence,
' @seq_next%(last%) retournera 0 (pas d'‚vŠnement suivant)
'
RETURN LPEEK(event%)
ENDFUNC
'
> PROCEDURE make_path
LOCAL drive
drive=GEMDOS(&H19)
path$=CHR$(ASC("a")+drive)+":"+DIR$(drive+1)+"\*.MSH"           ! Chemin d'accŠs aux s‚quences
RETURN
'
> PROCEDURE make_new_path(file$)
LOCAL pos
pos=RINSTR(file$,"\")
path$=LEFT$(file$,pos)+"*.msh"
RETURN
'
> PROCEDURE charge_seq(seq_ptr%) ! charge une s‚quence midishare
LOCAL file$
FILESELECT path$,"",file$
IF file$<>"" AND file$<>"\"
@make_new_path(file$)
ENDIF
RETURN
'
> PROCEDURE write_event(e%)
LOCAL n%,i%
BPUT #0,e%+4,8           ! donn‚es communes … tous les ‚v‚nements
n%=@midi_count_fields(e%)-1
OUT #0,n%
FOR i%=0 TO n%
OUT #0,@midi_get_field(e%,i%)
NEXT i%
RETURN
'
> PROCEDURE sauve_seq(seq_ptr%)
LOCAL file$,e%
'
e%=@seq_first(seq_ptr%)
IF (e%)
FILESELECT path$,"",file$
IF file$<>"" AND file$<>"\"
@make_new_path(file$)
OPEN "O",#0,file$
WHILE (e%)
@write_event(e%)
e%=@seq_next(e%)
WEND
CLOSE #0
ENDIF
ENDIF
RETURN
'
' **************************************************************************
' **************** Les fonctions d'interfa‡age de MidiShare ****************
' **************************************************************************
'
> PROCEDURE lisez_moi_midi_share
'
'
' MIDISHARE est un module logiciel con‡u sp‚cialement pour permettre le
' fonctionnement et le d‚veloppement d'applications Midi dans un contexte
' multi-tƒches et temps r‚el.
'
' MIDISHARE prend en charge la plupart des problŠmes sp‚cifiques li‚s au
' d‚veloppement d'applications Midi: gestion des flux Midi, gestion du
' temp, gestion des tƒches. En outre, MIDISHARE permet le fonctionnement
' simultan‚ de ces applications, ainsi que l'‚tablissement de connections
' Midi virtuelles entre celles-ci.
' ------------------------------------------------------------------------
'  		            c GRAME 1989, 1990, 1991, 1992
' 	          [Yann Orlarey, Herv‚ Lequay, Dominique fober]						
' ------------------------------------------------------------------------
'
'
' Le pr‚sent fichier doit etre ins‚r‚ dans tout programme utilisant les
' fonctions de MidiShare.
' Il d‚crit les points d'entr‚e de MidiShare, ainsi que les structures
' de donn‚es et les constantes utilis‚es. Le code MidiShare proprement
' dit est contenu dans le fichier MIDSHARE.PRG, qui doit etre plac‚
' dans un dossier Auto. Au d‚marrage de la machine, ce code est charg‚
' en m‚moire, il est ancr‚ au vecteur $94 (trap 5). Toutes les
' proc‚dures et fonctions d‚finies ci-dessous se servent de cette "ancre"
' pour acc‚der au code.
'
' ___________________________________________________________________________
'
'       TYPES D'EVENEMENTS
' ___________________________________________________________________________
'
' Constantes d‚finissant les types d'‚v‚nements manipul‚s par MidiShare.
' Cette typologie inclut bien entendu les diff‚rents types Midi, mais
' aussi d'autres cat‚gories d'‚v‚nements, en particulier les Notes, les
' Streams, les Process et les types Priv‚s. Ces codes sont … utiliser
' entre autre avec la fonction midi_new_ev.
' ***************************************************************************
'
' type_note        = 0       ! note avec hauteur, v‚locit‚ et dur‚e en ms
'
' type_key_on      = 1       ! Note On avec hauteur et v‚locit‚
' type_key_off     = 2       ! Note Off avec hauteur et v‚locit‚
' type_key_press   = 3       ! Poly KeyPress avec hauteur et pression
' type_ctrl_change = 4       ! Control Change avec controleur et valeur
' type_prog_change = 5       ! Program Change avec num‚ro de programme
' type_chan_press  = 6       ! Channel Pressure avec pression
' type_pitch_wheel = 7       ! Pitch Wheel avec LSB et MSB
' type_song_pos    = 8       ! Song Position Pointer avec LSB et MSB
' type_song_sel    = 9       ! Song Select avec num‚ro de song
' type_clock       = 10      ! Timing Clock
' type_start       = 11      ! Start
' type_continue    = 12      ! Continue
' type_stop        = 13      ! Stop
' type_tune        = 14      ! Tune Request
' type_active_sens = 15      ! Active Sensing
' type_reset       = 16      ! System Reset
' type_sys_ex      = 17      ! System Exclusive de longueur variable
' type_stream      = 18      ! Flot Midi quelconque de longueur variable
' type_private     = 19      ! 19...127  ‚v‚nement priv‚ … usage libre
' type_process     = 128     ! ‚vŠnement priv‚ servant au MidiCall
' type_dprocess    = 129     ! ‚vŠnement priv‚ servant au midi_dtask
' typeQuarterFrame = 130     ! ‚v‚nement de synchronisation MTC
' typeCtrl14b      = 131     ! controleur 14 bits
' typeNonRegParam  = 132     ! non registered parameter
' typeRegParam     = 133     ! registered parameter
'
' Tous les ‚vŠnements suivants sont des ‚vŠnements de la norme MIDIFILE.
'
' typeSeqNum       = 134     ! num‚ro de s‚quence
' typeText         = 135     ! ‚v‚nement texte
' typeCopyright    = 136     ! message copyright
' typeSeqName      = 137     ! nom de s‚quence ou de piste
' typeInstrName    = 138     ! nom d'instrument
' typeLyric        = 139     ! paroles d‚stin‚es … etre chant‚es
' typeMarker       = 140     ! marqueur
' typeCuePoint     = 141     ! cue point
' typeChanPrefix   = 142     ! Midi Channel Prefix
' typeEndTrack     = 143     ! fin de piste
' typeTempo        = 144     ! changement de tempo
' typeSMPTEOffset  = 145     ! offset smpte
' typeTimeSign     = 146     ! indication de mesure
' typeKeySign      = 147     ! signature tonale
' typeSpecific     = 148     ! m‚ta evt sp‚cifique … un s‚quenceur
'
' typeReserved     = 149..254! reserved for future extensions
'
' type_dead        = 255     ! ‚vŠnement priv‚ invalid‚
'
'
' ***************************************************************************
'       CODES MIDI
' ___________________________________________________________________________
' Constantes d‚finissant les codes de statut Midi.
' ***************************************************************************
'
' note_off     = &H80
' note_on      = &H90
' poly_touch   = &HA0
' control_chg  = &HB0
' program_chg  = &HC0
' after_touch  = &HD0
' pitch_bend   = &HE0
' sysreal_time = &HF0
' sys_ex       = &HF0
' undef_1      = &HF1
' song_pos     = &HF2
' song_sel     = &HF3
' undef_2      = &HF4
' undef_3      = &HF5
' tune         = &HF6
' end_sys_x    = &HF7
' m_clock      = &HF8
' undef_4      = &HF9
' m_start      = &HFA
' m_cont       = &HFB
' m_stop       = &HFC
' undef_5      = &HFD
' act_sense    = &HFE
' m_reset      = &HFF
'
'
' ***************************************************************************
'       PORTS MIDI
' __________________________________________________________________________
' Constantes d‚finissant les ports Modem et Printer.
' ***************************************************************************
'
' port_modem   = 0
' port_printer = 1
'
'
' ***************************************************************************
'       CODES D'ERREURS
' __________________________________________________________________________
' Constantes d‚finissant les codes d'erreurs renvoy‚s par certaine
' fonctions de MidiShare.
' ***************************************************************************
'
' midi_err_space   = -1        ! plus de place dans la freeList
' midi_err_refnum  = -2        ! mauvais numero de reference
' midi_err_badtype = -3        ! mauvais type d'‚v‚nement
' midi_err_index   = -4        ! mauvais index d'acces … un ‚v‚nement
'
'
' ****************************************************************************
' 							SYNCHRONISATION CODES								
' ****************************************************************************
'
' MIDISyncExternal = &H8000     ! bit-15 for external synchronisation
' MIDISyncAnyPort  = &H4000     ! bit-14 for synchronisation on any port
'
'
' **************************************************************************
'       CODES D'APPLICATIONS
' __________________________________________________________________________
' Constantes d‚finissant les codes de modification du statut des
' applications. Codes utilis‚s pour signaler … une application, toute
' modification survenue aux autres applications (ouverture, connexion,
' d‚connexion...). Ce code est toujours fourni avec le num‚ro de
' r‚f‚rence de l'application modifi‚e sous la forme d'un long:
' $rrrrcccc (r= refnum, c=code)
' ***************************************************************************
'
'
' midi_open_appl     = 1
' midi_close_appl    = 2
' midi_chg_name      = 3
' midi_chg_connect   = 4
' midi_open_modem    = 5
' midi_close_modem   = 6
' midi_open_printer  = 7
' midi_close_printer = 8
'
'
' **************************************************************************
'       STRUCTURES DES EVENEMENTS
' __________________________________________________________________________
' Tous les ‚v‚nements sont construits … l'aide d'une ou plusieurs
' cellules de taille fixe (16 octets). La plupart ne n‚cessitent
' qu'une seule cellule. D'autres, comme les System Exclusive n‚cessitent
' plusieurs cellules chain‚es.
' ***************************************************************************
'
' /*----------------Cellule d'extension d'un System Exclusive---------------*/
' offset        contenu         type            signification
'   0            link           long       lien de chainage cellule suivante
'   4            data           byte       12 octets de donn‚es
'
' /*----------------Cellule d'extension d'un Private------------------------*/
' offset        contenu         type            signification
'   0            ptr1           long       pointeurs … utiliser librement
'   4            ptr2           long       par l'application
'   8            ptr3           long
'   12           ptr4           long
'
' /*----------------Cellule d'un ‚v‚nement normal---------------------------*/
' offset        contenu         type            signification
'   0            link           long       chainage: adresse de l'evt  suivant
'   4            date           long       date de l'‚v‚nement en ms
'   8            ev_type        byte       type de l'‚v‚nement
'   9            refNum         byte       num‚ro de r‚f‚rence de l'application
'  10            port           byte       port Midi
'  11            chan           byte       canal Midi
' puis selon le type de l'‚v‚nement:
' ----------------------------------- pour un ‚v‚nement de type note:
'  12            pitch          byte       hauteur de la note
'  13            vel            byte       sa v‚locit‚
'  14            dur            word       sa dur‚e
' ----------------------------------- pour un autre message Midi:
'  12            data 1         byte       les octets de donn‚e au format
'  13            data 2         byte       de la norme Midi
'  14            data 3         byte
'  15            data 4         byte
' ----------------------------------- pour un systŠme exclusive:
'  12            linkSE         long       pointeur extension system exclusive
' ----------------------------------- pour un message priv‚:
'  12            linkST         long       pointeur extension msg priv‚
' ----------------------------------- pour MidiFile time signature:
'  12            numerateur     byte       le num‚rateur
'  13            denominateur   byte       d‚nominateur comme puissance n‚g. de 2
'  14            nClocks        byte       nombre  de clocks Midi par battue
'  15            n32nd          byte       nombre de 32nd notes par noire
' ----------------------------------- pour MidiFile key signature:
'  12            ton            byte       0: key of C, 1: 1 sharp -1: 1 flat etc...
'  13            mode           byte       0: major 1: minor
'  14            unused         word       inutilis‚
' ----------------------------------- pour MidiFile sequence number:
'  12            number         word       num‚ro de la s‚quence
'  14            unused         word       inutilis‚
' ----------------------------------- pour MidiFile tempo:
'  12            tempo          long       en microsec par Midi quarter note
'
'
' /*----------------En tete de s‚quence-------------------------------------*/
' offset        contenu         type            signification
'   0            first          long       ptr sur le premier ‚vt de la s‚quence
'   4            last           long       ptr sur le dernier ‚vt de la s‚quence
'   8            undef1         long       r‚serv‚
'   12           undef2         long       r‚serv‚
'
'
' /*----------------Filtres Midi--------------------------------------------*/
' offset        contenu         type            signification
'   0            port[16]       word       ports 0 … 255 : 256 bits
'  32            ev_type[16]    word       types 0 … 255 : 256 bits
'  64            channel        word       canaux 0 … 15 :  16 bits
'  80            unused         word       r‚serv‚
'
' /*----------------Nom d'application Midi Share----------------------------*/
' doit etre au format 'C' standard c'est … dire, doit se terminer par un
' z‚ro (indicateur de fin de chaine). De plus, il ne doit pas exc‚der
' 32 caractŠres ( '0' inclus).
'
'
' /*----------------Infos de synchronisation -------------------------------*/
' offset        contenu         type            signification
'   0            time           long       date courante
'   4            reenter        long       nombre de r‚entrance de l'horloge
'   8            mode           word       mode de synchronisation
'  10            locked         byte       synchro locked
'  11            port           byte       port de synchronisation
'  12            start          long       date de d‚but de synchronisation
'  16            stop           long       date de fin de synchronisation
'  20            offset         long       offset de la synchro
'  24            speed          long       sa vitesse
'  28            breaks         long       nombre de ruptures de synchro
'  32            format         word       format de la synchro
'
' /*----------------Location smpte -----------------------------------------*/
' offset        contenu         type            signification
'   0            format         word       0:24f/s, 1:25f/s, 2:30DFf/s, 3:30f/s
'   2            heures         word       0..23
'   4            minutes        word       0..59
'   6            secondes       word       0..59
'   8            frames         word       0..30 (according to format)
'  10            fracs          word       0..99 (1/100 of frames)
'
'
' ****************************************************************************
' ----------------------------------------------------------------------------
'
'       D‚finition des fonctions et proc‚dures d'appel … Midishare
'
' Le code de MidiShare proprement dit est charg‚ par MIDSHARE.PRG.
' Les fonctions et proc‚dures d‚finies ci-dessous donnent accŠs au
' code r‚sident de MidiShare par l'interm‚diaire d'un sous-programme
' assembleur rang‚ dans la variable 'msh_adr%' et contenant le code
' suivant:      addq.l #4,sp
'               trap   #5
'               subq.l #4,sp
'               rts
' Ce code permet de formatter les paramŠtres pass‚s en argument aux
' fonctions et proc‚dures d'appel … MidiShare. L'appel des fonctions
' r‚sidentes de MidiShare se fait ensuite comme pour les appels
' systŠme (gemdos, bios, xbios): les paramŠtres sont pouss‚s sur la
' pile, puis le num‚ro de la fonction, enfin le programme effectue un
' saut vectoris‚ … l'adresse point‚e par &H94 (vecteur du trap 5 en
' principe inutilis‚, point d'ancrage de MidiShare qui contient l'adresse
' d'une routine de dispatch qui r‚alise l'appel effectif de la fonction).
' Le vecteur &H94 est initialis‚ au chargement par MIDSHARE.PRG.
' La variable 'msh_adr%' doit etre initialis‚e par le programme appelant
' avant toute utilisation des fonctions ou proc‚dures d‚finies ci-dessous,
' grace … l'appel pr‚alable de la proc‚dure 'init_midishare'.
'
' Pour plus d'infos sur les proc‚dures suivantes,
' voir la documentation d‚veloppeur MIDISHARE ou l'accessoire MIDIHELP
'
'
' ***************************************************************************
'
' (@) GRAME 1989, Yann Orlarey, Herv‚ Lequay, Dominique Fober
'
' ***************************************************************************
RETURN
'
' ---------------------- initialisation de MidiShare ----------------------
'
> FUNCTION init_midishare
LOCAL midi_dispatch%,a$
msh_mem%=MALLOC(36)
IF msh_mem%
RESTORE msh_data
FOR i%=0 TO 8
READ midi_dispatch%
LPOKE msh_mem%+(i%*4),midi_dispatch%
NEXT i%
msh_adr%=msh_mem%
msh_set_alarm%=msh_mem%+4
msh_alarm%=msh_mem%+16
ENDIF
RETURN (msh_mem%)
'
msh_data:
DATA &H4E464E75
DATA &H202F0004,&H41FA0014,&H20804E75
DATA &H202F0006,&H41FA0008,&H20502080
DATA &H4E750000,&H00000000
'
ENDFUNC
'
' -------------------- AccŠs … l'environnement ----------------------------
'
> FUNCTION midi_get_version
LOCAL v%
v%=C:msh_adr%(0)
RETURN (DPEEK(VARPTR(v%)+2))
ENDFUNC
'
> FUNCTION midi_count_appls
LOCAL c%
c%=C:msh_adr%(1)
RETURN (DPEEK(VARPTR(c%)+2))
ENDFUNC
'
> FUNCTION midi_get_ind_appl(index&)
LOCAL r%
r%=C:msh_adr%(2,index&)
RETURN (DPEEK(VARPTR(r%)+2))
ENDFUNC
'
> FUNCTION midi_get_named_appl(midi_name$)
LOCAL r%
r%=C:msh_adr%(3,L:VARPTR(midi_name$))
RETURN (DPEEK(VARPTR(r%)+2))
ENDFUNC
'
' --------------------- Synchronisation smpte ------------------------------
'
> PROCEDURE midi_get_sync_info(info$)
~C:msh_adr%(&H39,L:VARPTR(info$))  ! info est une chaine d'au moins 34 caractŠres
RETURN
'
> PROCEDURE midi_set_sync_mode(mode&)
~C:msh_adr%(&H3A,refnum&)
RETURN
'
> FUNCTION midi_get_ext_time(void)
RETURN (C:msh_adr%(&H3E))
ENDFUNC
'
> FUNCTION midi_int_2_ext_time(time%)
RETURN (C:msh_adr%(&H3F,L:time%))
ENDFUNC
'
> FUNCTION midi_ext_2_int_time(time%)
RETURN (C:msh_adr%(&H40,L:time%))
ENDFUNC
'
> PROCEDURE midi_time_2_smpte(time%,format&,loc%)
~C:msh_adr%(&H41,L:time%,format&,L:VARPTR(loc%))
RETURN
'
> FUNCTION midi_smpte_2_time(loc%)
RETURN (C:msh_adr%(&H42,L:VARPTR(loc%)))
ENDFUNC
'
' --------------------- Ouverture / Fermeture ------------------------------
'
> FUNCTION midi_open(midi_name$)
LOCAL r%
r%=C:msh_adr%(4,L:VARPTR(midi_name$))
RETURN (DPEEK(VARPTR(r%)+2))
ENDFUNC
'
> PROCEDURE midi_close(refnum&)
~C:msh_adr%(5,refnum&)
RETURN
'
' ----------------- Configuration de l'application ------------------------
'
> FUNCTION midi_get_name(refnum&)
RETURN (C:msh_adr%(6,refnum&))
ENDFUNC
'
> PROCEDURE midi_set_name(refnum&,midi_name$)
~C:msh_adr%(7,refnum&,L:VARPTR(midi_name$))
RETURN
'
> FUNCTION midi_get_info(refnum&)
RETURN (C:msh_adr%(8,refnum&))
ENDFUNC
'
> PROCEDURE midi_set_info(refnum&,info_ptr%)
~C:msh_adr%(9,refnum&,L:info_ptr%)
RETURN
'
> FUNCTION midi_get_filter(refnum&)
RETURN (C:msh_adr%(&HA,refnum&))
ENDFUNC
'
> PROCEDURE midi_set_filter(refnum&,filter_ptr%)
~C:msh_adr%(&HB,refnum&,L:filter_ptr%)
RETURN
'
'
' ------------------------- Connexions internes --------------------------
'
> PROCEDURE midi_connect(src&,dest&,state!)
~C:msh_adr%(&H10,src&,dest&,state!)
RETURN
'
> FUNCTION midi_is_connected(src&,dest&)
LOCAL state!
state!=C:msh_adr%(&H11,src&,dest&)
RETURN (state!)
ENDFUNC
'
' ------------------------ Gestion des ports midi -----------------------
'
> FUNCTION midi_get_port_state(port&)
LOCAL state!
state!=C:msh_adr%(&H12,port&)
RETURN (state!)
ENDFUNC
'
> PROCEDURE midi_set_port_state(port&,state!)
~C:msh_adr%(&H13,port&,state!)
RETURN
'
' -------------------------- Gestion des ‚v‚nements ----------------------
'
> FUNCTION midi_free_space
RETURN (C:msh_adr%(&H14))
ENDFUNC
'
> FUNCTION midi_new_cell
RETURN (C:msh_adr%(&H33))
ENDFUNC
'
> PROCEDURE midi_free_cell(event_ptr%)
~C:msh_adr%(&H34,L:event_ptr%)
RETURN
'
> FUNCTION midi_total_space
RETURN (C:msh_adr%(&H35))
ENDFUNC
'
> FUNCTION midi_new_ev(type&)
RETURN (C:msh_adr%(&H15,type&))
ENDFUNC
'
> FUNCTION midi_copy_ev(event_ptr%)
RETURN (C:msh_adr%(&H16,L:event_ptr%))
ENDFUNC
'
> PROCEDURE midi_free_ev(event_ptr%)
~C:msh_adr%(&H17,L:event_ptr%)
RETURN
'
> PROCEDURE midi_set_field(event_ptr%,field%,val%)
~C:msh_adr%(&H3B,L:event_ptr%,L:field%,L:val%)
RETURN
'
> FUNCTION midi_get_field(event_ptr%,field%)
RETURN (C:msh_adr%(&H3C,L:event_ptr%,L:field%))
ENDFUNC
'
> PROCEDURE midi_add_field(event_ptr%,val%)
~C:msh_adr%(&H1A,L:event_ptr%,L:val%)
RETURN
'
> FUNCTION midi_count_fields(event_ptr%)
RETURN (C:msh_adr%(&H3D,L:event_ptr%))
ENDFUNC
'
' ------------------------- Gestion des s‚quences -------------------------
'
> FUNCTION midi_new_seq
RETURN (C:msh_adr%(&H1D))
ENDFUNC
'
> PROCEDURE midi_add_seq(seq_ptr%,event_ptr%)
~C:msh_adr%(&H1E,L:seq_ptr%,L:event_ptr%)
RETURN
'
> PROCEDURE midi_free_seq(seq_ptr%)
~C:msh_adr%(&H1F,L:seq_ptr%)
RETURN
'
> PROCEDURE midi_clear_seq(seq_ptr%)
~C:msh_adr%(&H20,L:seq_ptr%)
RETURN
'
' --------------------------------- Date courante -------------------------
'
> FUNCTION midi_get_time
RETURN (C:msh_adr%(&H22))
ENDFUNC
'
' ------------------------------- Emissions Midi --------------------------
'
> PROCEDURE midi_send_im(refnum&,event_ptr%)
~C:msh_adr%(&H23,refnum&,L:event_ptr%)
RETURN
'
> PROCEDURE midi_send(refnum&,event_ptr%)
~C:msh_adr%(&H24,refnum&,L:event_ptr%)
RETURN
'
> PROCEDURE midi_send_at(refnum&,event_ptr%,date%)
~C:msh_adr%(&H25,refnum&,L:event_ptr%,L:date%)
RETURN
'
' ------------------------------ Receptions Midi --------------------------
'
> FUNCTION midi_count_evs(refnum&)
RETURN (C:msh_adr%(&H26,refnum&))
ENDFUNC
'
> FUNCTION midi_get_ev(refnum&)
RETURN (C:msh_adr%(&H27,refnum&))
ENDFUNC
'
> FUNCTION midi_avail_ev(refnum&)
RETURN (C:msh_adr%(&H28,refnum&))
ENDFUNC
'
> PROCEDURE midi_flush_evs(refnum&)
~C:msh_adr%(&H29,refnum&)
RETURN
'
' ---------------------------- Boite aux lettres --------------------------
'
> FUNCTION midi_read_sync(adr_mem%)
RETURN (C:msh_adr%(&H2A,L:adr_mem%))
ENDFUNC
'
> FUNCTION midi_write_sync(adr_mem%,val%)
RETURN (C:msh_adr%(&H2B,L:adr_mem%,L:val%))
ENDFUNC
'
' ---------------------------- Controle MidiShare ------------------------
'
> FUNCTION midi_share
LOCAL is!
LOCAL stack_ptr%,strg_ptr%
'
stack_ptr%=BIOS(&H20,L:0)
strg_ptr%=LPEEK(&H94)-18
IF (LPEEK(strg_ptr%)=&H4D494449) AND (LPEEK(strg_ptr%+4)=&H53484152) AND (DPEEK(strg_ptr%+8)=&H4500)
is!=TRUE
ELSE
is!=FALSE
ENDIF
~BIOS(&H20,L:stack_ptr%)
RETURN (is!)
ENDFUNC
'
' ------------------------- Fonctions d'acces aux filtres ----------------
> PROCEDURE accept_bit(adr%,n&)
LOCAL offset&
offset&=n&
DIV offset&,8
POKE adr%+offset&,BSET(PEEK(adr%+offset&),MOD(n&,8))
RETURN
'
> PROCEDURE reject_bit(adr%,n&)
LOCAL offset&
offset&=n&
DIV offset&,8
POKE adr%+offset&,BCLR(PEEK(adr%+offset&),MOD(n&,8))
RETURN
'
> PROCEDURE invert_bit(adr%,n&)
LOCAL offset&
offset&=n&
DIV offset&,8
POKE adr%+offset&,BCHG(PEEK(adr%+offset&),MOD(n&,8))
RETURN
'
> FUNCTION is_accepted_bit(adr%,n&)
LOCAL offset&
offset&=n&
DIV offset&,8
RETURN BTST(PEEK(adr%+offset&),MOD(n&,8))
ENDFUNC
'
'
' ---------------------- Lecture des attributs d'un event ----------------
'
> FUNCTION event_link(event%)       ! retourne le lien de chainage
RETURN LPEEK(event%)
ENDFUNC
'
> FUNCTION event_date(event%)       ! retourne la date en ms (4 octets)
RETURN LPEEK(event%+4)              ! attention... 4 octets (mot long)
ENDFUNC
'
> FUNCTION event_type(event%)       ! retourne le type
RETURN PEEK(event%+8)               ! ex= 1 si key on
ENDFUNC                             !     2 si key off etc...
'
> FUNCTION event_refnum(event%)     ! retourne le numero de l'application source
RETURN PEEK(event%+9)
ENDFUNC
'
> FUNCTION event_port(event%)       ! retourne le num‚ro de port midi
RETURN PEEK(event%+10)
ENDFUNC
'
> FUNCTION event_chan(event%)       ! retourne le canal midi
RETURN PEEK(event%+11)
ENDFUNC
'
' Pour un ‚v‚nement de type note:
'
> FUNCTION event_pitch(event%)      ! retourne la hauteur de la note
RETURN PEEK(event%+12)
ENDFUNC
'
> FUNCTION event_velo(event%)       ! retourne la v‚locit‚
RETURN PEEK(event%+13)
ENDFUNC
'
> FUNCTION event_len(event%)        ! retourne la longueur de la note
RETURN DPEEK(event%+14)             ! attention... 2 octets
ENDFUNC
'
'
' --------------- Modification des attributs d'un event --------------------------
'
> PROCEDURE set_event_link(event%,next%)  ! modification du lien de
LPOKE event%,date%                      ! chainage d'un ‚v‚nement
RETURN
'
> PROCEDURE set_event_date(event%,date%)  ! affecte la date en ms (4 octets)
LPOKE event%+4,date%                      ! attention... 4 octets (mot long)
RETURN
'
> PROCEDURE set_event_type(event%,type|)  ! affecte le type … l'event
POKE event%+8,type|                       ! ex= 1 si key on
RETURN                                    !     2 si key off etc...
'
> PROCEDURE set_event_refnum(event%,ref_num|) ! affecte le numero de l'application source
POKE event%+9,refnum|
RETURN
'
> PROCEDURE set_event_port(event%,port|)   ! affecte le num‚ro de port midi
POKE event%+10,port|
RETURN
'
> PROCEDURE set_event_chan(event%,chan|)   ! affecte le canal midi
POKE event%+11,chan|
RETURN
'
' Pour un ‚v‚nement de type note:
'
> PROCEDURE set_event_pitch(event%,pitch|) ! change la hauteur de la note
POKE event%+12,pitch|
RETURN
'
> PROCEDURE set_event_velo(event%,velo|)   ! change la v‚locit‚
POKE event%+13,velo|
RETURN
'
> PROCEDURE set_event_len(event%,len%)     ! change la longueur de la note
DPOKE event%+14,len%                       ! attention, 2 octets
RETURN
