$m40000  ! Instructions destin‚es au compilateur
$RC&    ! (m40000) => RESERVE 40000 ko
$P<     !
$S& S   !
'
'
initialize       ! initialise les variables et les ressources, menus...
main             ! boucle principale
'
'
'
> PROCEDURE lisez_moi
  ' ------------------------------------------------------------------------
  '                    MIDI SHARE Application SKELETON
  ' ------------------------------------------------------------------------
  '
  ' -> voir ‚galement la proc‚dure @lisez_moi_midishare
  '
  '
  '  Skeleton est un squelette pour d‚velopper vos propres applications
  '  Midishare en GFA Basic.
  '
  '  Skeleton se contente d'envoyer une note lorsque l'on clique sur le
  '  bouton "skeleton", et d'‚mettre des notes dont la hauteur d‚pend
  '  de la v‚locit‚ des notes re‡ues.
  '
  '  Les points qui peuvent ˆtre facilement modifi‚s sont les suivants :
  '
  '  - La constante ApplName : le nom de l'application pour MidiShare
  '
  '  - ReceiveEvents : qui traite tous les ‚v‚nements re‡us et qui r‚alise
  '    ici un simple MidiThru.
  '
  '  - La constante wantRealTime : quand elle vaut 1, ReceiveEvents est
  '    appel‚e sous interruption et fonctionne donc en temps r‚el; quand
  '    elle vaut 0, ReceiveEvents est appel‚e dans la boucle principale.
  '
  '  - La constante wantFilter : quand elle vaut 1, un filtre sur les entr‚es
  '    Midi est install‚, quand elle vaut 0, aucun filtre n'est install‚ et
  '    l'application re‡oit tous les ‚v‚nements.
  '
  '  - InstallFilter : qui configure le filtre d'entr‚e
  '
  '  - La fichier de ressource qui d‚finit le contenu de la fenˆtre de
  '    l'application
  '
  '  - les traitements associ‚s aux ‚vŠnements midi re‡us (traite_event())
  '    et aux ‚vŠnements souris et clavier (traite_souris, traite_clavier)
  '
  '
  '
  '   ------------------------------------------------------------------------
  '           REMARQUES CONCERNANT LES RESSOURCES ET LE GFA BASIC
  '   ------------------------------------------------------------------------
  '
  '   Il semblerait que le GFA BASIC g‚nŠre des interf‚rences avec le GEM.
  '   Ainsi, la pr‚sence d'un accessoire programm‚ sous GFA basic provoque
  '   des anomalies … l'affichage: texte ou icone passant partiellement en
  '   inversion vid‚o, effacement de zones ou se situe la souris...
  '
  '   AprŠs diff‚rents essais, il apparait que ces problŠmes sont propres
  '   aux version 3.xx du GFA (le GFA 2.0 fonctionne parfaitement).
  '   L'interf‚rence se produit lorsque le programme intercepte les ‚venements
  '   TIMER, ce qui est indispensable pour pouvoir fonctionner en multitaches.
  '   avec MIDISHARE et les accessoires du bureau.
  '
  '   Une simple boucle do loop avec un appel ON MENU (ou EVENT_MULTI, qui
  '   a la meme fonction) produit ce ph‚nomŠne.
  '
  '   AprŠs info auprŠs de Micro Applications qui distribue le GFA basic,
  '   Ce bug est connu et "devrait" etre corrig‚ dans la version 3.7
  '   qui est actuellement en pr‚paration.
  '
  '   ------------------------------------------------------------------------
  '           @ GRAME 1989/90, Yann Orlarey, Herv‚ Lequay, Dominique Fober
  '
  '                    Version GFA Basic 3.07 / 3.5
  '   ------------------------------------------------------------------------
  '
RETURN
'
> PROCEDURE initialize
  '
  ' /****************************************************************************/
  ' /*                                  INITIALIZE                              */
  ' /*--------------------------------------------------------------------------*/
  ' /* Initialisations g‚n‚rales ( ressources , fenˆtre, Midi)                  */
  ' /*                                                                          */
  ' /* Les paramŠtres de l'appel :                                              */
  ' /* ---------------------------                                              */
  ' /*                                                                          */
  ' /*          aucun                                                           */
  ' /*                                                                          */
  ' /****************************************************************************/
  '
  ~FRE(0)              ! garbage collect de la m‚moire
  RESERVE 40000
  appl_name$="Echo"+CHR$(0)! … modifier selon le nom de votre application
  want_filter=TRUE
  my_refnum&=-1
  '
  gl_apid%=APPL_INIT()
  DEFFILL 1,2,4
  PBOX 0,19,639,399
  DEFFILL 1,0
  ~GRAF_MOUSE(0,0)
  wi_handle&=-1                        ! fenetre ferm‚e
  SHOWM
  '
  IF @init_midishare=0                 ! interfa‡age impossible
    @alert_user(-7)
    ~APPL_EXIT()
    EDIT
  ENDIF
  '
  init_var_rsc               ! initialise les variables objets du fichier RSC
  '
  IF NOT @set_up_rsc("MSECHO.RSC")   ! charge les ressources, menus...
    IF gl_apid%=0
      ~APPL_EXIT()
      EDIT
    ENDIF
  ENDIF
  '
  init_variables
  '
  IF gl_apid%=0                        !
    IF NOT @open_appl                  ! ouverture de l'application
      EDIT
    ENDIF
  ENDIF
  '
RETURN
'
> FUNCTION set_up_midi
'
' /****************************************************************************/
' /*                                 SETUP MIDI                               */
' /*--------------------------------------------------------------------------*/
' /* V‚rifie la pr‚sence de MidiShare, la possibilit‚ d'ouverture Midi, et    */
' /* installe la proc‚dure d'alarme qui sera appel‚e par MidiShare lors des   */
' /* changements de statut des applications ou des ports.                     */
' /*                                                                          */
' /* Les paramŠtres de l'appel :                                              */
' /* ---------------------------                                              */
' /*                                                                          */
' /*          aucun                                                           */
' /*                                                                          */
' /****************************************************************************/
'
IF NOT @midi_share                    ! V‚rifie la pr‚sence de MidiShare
  RETURN @alert_user(-4)
ENDIF
IF my_refnum&<>-1
  RETURN TRUE                         ! l'application est dej… ouverte
ENDIF
'
my_refnum&=@midi_open(appl_name$)     ! Ouvre l'application pour MidiShare
IF my_refnum&=-1                      ! V‚rifie que tout s'est bien pass‚
  RETURN @alert_user(-5)
ENDIF
IF (want_filter)
  @install_filter                     ! Installe le filtre de r‚ception
ENDIF
'
@midi_connect(0,my_refnum&,TRUE)      ! Connecte l'entr‚e de l'appl. aux entr‚es physiques
@midi_connect(my_refnum&,0,TRUE)      ! Connecte la sortie de l'appl. aux sorties physiques
'
RETURN TRUE
'
ENDFUNC
'
> PROCEDURE main
'
' Boucle principale. On traite les ‚vŠnements clavier, souris et aes
' … chaque passage sur ON MENU, puis on traite les ‚vŠnements midi re‡us
'
LOCAL done_flag!
'
ON MENU KEY GOSUB traite_clavier         ! comme son nom l'indique
ON MENU BUTTON 1,1,1 GOSUB traite_souris ! manipulation des objets RSC
ON MENU MESSAGE GOSUB traite_aes         ! gestion de la fenetre
ON MENU GOSUB traite_aes                 ! gestion de la barre de menu
'
WHILE NOT done_flag!
  ON MENU 2
  '
  @receive_events(my_refnum&) ! on va voir s'il y a des ‚vŠnements re‡us
  '                           ! il est recommand‚ d'ins‚rer des
  '                           ! Gosub @receive_events dans les boucles
  '                           ! externes … la boucle principale
  '                           ! (voir proc‚dure "show_info")
WEND
'
' On s'en va ...
'
~MFREE(msh_mem%)            ! libŠre la m‚moire allou‚e par InitMidiShare
IF want_filter
  ~MFREE(my_filter%)        ! libŠre la m‚moire allou‚e pour les filtres
ENDIF
'
RETURN
'
> PROCEDURE init_var_rsc
'
' D‚finition des variables du fichier RSC
'
LET form1%=0
LET off%=4
LET echo%=5
LET on%=6
LET delay%=8
LET dplus%=9
LET dmoins%=10
LET amortissement%=14
LET aplus%=15
LET amoins%=16
'
LET menu2%=1
LET infos%=7
'
LET form3%=2
LET version%=3
LET ok%=36
LET echo_version%=39
RETURN
'
> PROCEDURE init_variables
echo_on=TRUE
echo_delay=@ob_lit_val(adr_rsc%,delay%)
echo_amort=@ob_lit_val(adr_rsc%,amortissement%)
RETURN
'
> FUNCTION set_up_rsc(rscname$)
'
' /****************************************************************************/
' /*                             SET UP RESSOURCES                            */
' /*--------------------------------------------------------------------------*/
' /* Chargement des ressources                                                */
' /* Installation de la barre de menus                                        */
' /*                                                                          */
' /* Les paramŠtres de l'appel :                                              */
' /* ---------------------------                                              */
' /*                                                                          */
' /*          rscName$ :     nom du fichier de ressources                      */
' /*                                                                          */
' /****************************************************************************/
'
'
'
IF RSRC_LOAD(rscname$)
'
IF RSRC_GADDR(0,form1%,adr_rsc%)=0    ! formulaire principal
  RETURN @alert_user(-2)
ENDIF
IF RSRC_GADDR(0,menu2%,adr_menu%)=0        ! menu
  RETURN @alert_user(-2)
ENDIF
IF RSRC_GADDR(0,form3%,adr_about%)=0  ! formulaire "information"
  RETURN @alert_user(-2)
ENDIF
IF gl_apid%=0                             ! si l'application n'est pas
  ~MENU_BAR(adr_menu%,1)                  ! lanc‚e en accessoire
ELSE
  menu_id%=MENU_REGISTER(gl_apid%,"  Echo")
ENDIF
RETURN TRUE
ELSE
RETURN @alert_user(-1)
ENDIF
ENDFUNC
'
> PROCEDURE wait_release
WHILE MOUSEK
WEND
RETURN
'
> PROCEDURE traite_souris
'
' /****************************************************************************
' *                                  TRAITE SOURIS                           *
' *--------------------------------------------------------------------------*
' * Proc‚dure charg‚e du suivi de la souris dans la boucle principale        *
' *                                                                          *
' * Les paramŠtres de l'appel :                                              *
' * ---------------------------                                              *
' *          aucun                                                           *
' *                                                                          *
' ***************************************************************************/
'
LOCAL object&,state&,shift!,ret%,note%,first_click&
'
first_click&=TRUE
IF WIND_FIND(MENU(10),MENU(11))=wi_handle& ! si c'est sur la fenetre de l'application
shift!=(BIOS(11,-1)=2)       ! d‚tecte si la touche shift est enfonc‚e
object&=OBJC_FIND(adr_rsc%,0,5,MENU(10),MENU(11))    ! quel objet ?
IF object&<>-1 AND AND(OB_FLAGS(adr_rsc%,object&),1) ! si selectionnable
  state&=OB_STATE(adr_rsc%,object&)                  ! -> quel ‚tat
  '                                                  !(activ‚?, non activ‚?)
  SELECT object&
    '
  CASE on%
    IF NOT echo_on
      echo_on=TRUE
      ~OBJC_CHANGE(adr_rsc%,off%,0,xdesk&,ydesk&,wdesk&,hdesk&,BCLR(OB_STATE(adr_rsc%,off%),0),1)
      ~OBJC_CHANGE(adr_rsc%,on%,0,xdesk&,ydesk&,wdesk&,hdesk&,BSET(OB_STATE(adr_rsc%,on%),0),1)
    ENDIF
  CASE off%
    IF echo_on
      echo_on=FALSE
      ~OBJC_CHANGE(adr_rsc%,on%,0,xdesk&,ydesk&,wdesk&,hdesk&,BCLR(OB_STATE(adr_rsc%,on%),0),1)
      ~OBJC_CHANGE(adr_rsc%,off%,0,xdesk&,ydesk&,wdesk&,hdesk&,BSET(OB_STATE(adr_rsc%,off%),0),1)
    ENDIF
  CASE echo%
    @show_info
    '
  CASE dplus%
    ~OBJC_CHANGE(adr_rsc%,dplus%,0,xdesk&,ydesk&,wdesk&,hdesk&,BSET(OB_STATE(adr_rsc%,dplus%),0),1)
    WHILE MOUSEK
      IF echo_delay<999
        INC echo_delay
        @ob_ecrit_val(adr_rsc%,delay%,echo_delay)
        ~OBJC_DRAW(adr_rsc%,delay%,1,xdesk&,ydesk&,wdesk&,hdesk&)
      ENDIF
      IF first_click&
        PAUSE 7
        first_click&=FALSE
      ENDIF
    WEND
    ~OBJC_CHANGE(adr_rsc%,dplus%,0,xdesk&,ydesk&,wdesk&,hdesk&,BCLR(OB_STATE(adr_rsc%,dplus%),0),1)
    '
  CASE dmoins%
    ~OBJC_CHANGE(adr_rsc%,dmoins%,0,xdesk&,ydesk&,wdesk&,hdesk&,BSET(OB_STATE(adr_rsc%,dmoins%),0),1)
    WHILE MOUSEK
      IF echo_delay>1
        DEC echo_delay
        @ob_ecrit_val(adr_rsc%,delay%,echo_delay)
        ~OBJC_DRAW(adr_rsc%,delay%,1,xdesk&,ydesk&,wdesk&,hdesk&)
      ENDIF
      IF first_click&
        PAUSE 7
        first_click&=FALSE
      ENDIF
    WEND
    ~OBJC_CHANGE(adr_rsc%,dmoins%,0,xdesk&,ydesk&,wdesk&,hdesk&,BCLR(OB_STATE(adr_rsc%,dmoins%),0),1)
    '
  CASE aplus%
    ~OBJC_CHANGE(adr_rsc%,aplus%,0,xdesk&,ydesk&,wdesk&,hdesk&,BSET(OB_STATE(adr_rsc%,aplus%),0),1)
    WHILE MOUSEK
      IF echo_amort<127
        INC echo_amort
        @ob_ecrit_val(adr_rsc%,amortissement%,echo_amort)
        ~OBJC_DRAW(adr_rsc%,amortissement%,1,xdesk&,ydesk&,wdesk&,hdesk&)
      ENDIF
      IF first_click&
        PAUSE 7
        first_click&=FALSE
      ENDIF
    WEND
    ~OBJC_CHANGE(adr_rsc%,aplus%,0,xdesk&,ydesk&,wdesk&,hdesk&,BCLR(OB_STATE(adr_rsc%,aplus%),0),1)
    '
  CASE amoins%
    ~OBJC_CHANGE(adr_rsc%,amoins%,0,xdesk&,ydesk&,wdesk&,hdesk&,BSET(OB_STATE(adr_rsc%,amoins%),0),1)
    WHILE MOUSEK
      IF echo_amort>1
        DEC echo_amort
        @ob_ecrit_val(adr_rsc%,amortissement%,echo_amort)
        ~OBJC_DRAW(adr_rsc%,amortissement%,1,xdesk&,ydesk&,wdesk&,hdesk&)
      ENDIF
      IF first_click&
        PAUSE 7
        first_click&=FALSE
      ENDIF
    WEND
    ~OBJC_CHANGE(adr_rsc%,amoins%,0,xdesk&,ydesk&,wdesk&,hdesk&,BCLR(OB_STATE(adr_rsc%,amoins%),0),1)
    '
  ENDSELECT
ENDIF
ENDIF
RETURN
'
> PROCEDURE traite_clavier
'
' Cette proc‚dure permet de traiter l'appui d'une touche du clavier
' Par exemple, l'appui sur ESCAPE fermera l'application
'
LOCAL state&,ascii|,clavier|,i
state&=MENU(13)               ! flags ‚tat des touches CTRL,ALT et SHIFT...
ascii|=BYTE(MENU(14))         ! Code ascii du caractŠre
clavier|=SHR(MENU(14),8)      ! code clavier du caractŠre
'
SELECT ascii|
'
CASE 27       ! touche ESCAPE -> on s'en va
'
~WIND_CLOSE(wi_handle&)
~WIND_DELETE(wi_handle&)
wi_handle&=-1
@close_appl
IF gl_apid%=0
  done_flag!=TRUE
ENDIF
'
' /...
' Autres traitements associ‚s au clavier
' .../
'
ENDSELECT
'
RETURN
'
> PROCEDURE receive_events(refnum&)
'
' Cette proc‚dure permet de traiter les ‚vŠnements midi re‡us
' refnum& est l'identificateur midishare de l'application
' (voir set_up_midi)
'
LOCAL e%
'
IF echo_on
DO
  e%=@midi_get_ev(refnum&)
  EXIT IF e%=0
  traite_event(e%,refnum&)
  @midi_free_ev(e%)
LOOP
ELSE
@midi_flush_evs(refnum&)
ENDIF
RETURN
'
> PROCEDURE traite_event(event%,refnum&)
LOCAL e%,date%,vel,delay
'
' il n'y a pas ici de controle de type pour les ‚v‚nements
' parce que tous les ‚v‚nements autres que les notes et
' les keyOn sont filtr‚s en entr‚e par le filtre de l'application
'
vel=@event_velo(event%)                    ! v‚locit‚ de l'‚v‚nement
date%=@event_date(event%)                  ! sa date
delay=echo_delay*10
WHILE vel>echo_amort
e%=@midi_copy_ev(event%)                 ! on copie l'‚v‚nement
vel=vel-echo_amort                       ! nouvelle v‚locit‚
date%=date%+delay                        ! nouvelle date
IF e%
  @set_event_velo(e%,vel)
  @set_event_type(e%,0)
  @set_event_len(e%,echo_delay-1)
  @midi_send_at(refnum&,e%,date%)        ! et on envoie l'‚v‚nement
ENDIF
WEND
RETURN
'
> PROCEDURE show_info
'
' Affichage du formulaire informations
'
LOCAL x%,y%,w%,h%
LOCAL on_sort!,save$,version$
main_wind_valide!=FALSE                      ! ‚vite interf‚rences
'                                            ! avec la fenetre principale
@ob_ecrit_txt(adr_about%,version%,STR$(@midi_get_version/100))
@ob_ecrit_txt(adr_about%,echo_version%,"1.00")
'
~WIND_UPDATE(3)
~FORM_CENTER(adr_about%,x%,y%,w%,h%)
GET x%,y%,x%+w%,y%+h%,save$
~OBJC_DRAW(adr_about%,0,5,x%,y%,w%,h%)
'
ON MENU KEY GOSUB traite_key_info
ON MENU BUTTON 1,1,1 GOSUB traite_souris_info ! traitement souris sp‚cifique
DO                                            ! … ce formulaire
ON MENU
@receive_events(my_refnum&) ! on va voir s'il y a des ‚vŠnements re‡us
LOOP UNTIL on_sort!
'
ON MENU KEY GOSUB traite_clavier
ON MENU BUTTON 1,1,1 GOSUB traite_souris      ! on restore le branchement
~OBJC_CHANGE(adr_about%,ok_info%,0,x%,y%,w%,h%,&H30,0)
PUT x%,y%,save$
~WIND_UPDATE(2)
main_wind_valide!=TRUE
RETURN
'
> PROCEDURE traite_key_info
LOCAL ascii|
ascii|=BYTE(MENU(14))         ! Code ascii du caractŠre
'
IF ascii|=13
on_sort!=TRUE
ENDIF
RETURN
'
> PROCEDURE traite_souris_info
'
' Proc‚dure de traitement des ‚vŠnements souris dans la proc‚dure
' show_info
'
SELECT OBJC_FIND(adr_about%,0,10,MENU(10),MENU(11))
'
CASE info_ok%
on_sort!=TRUE
ENDSELECT
'
RETURN
'
' ***************************************************************************
' ************* Atari utilities: gestion des fenetres et des ressources *****
' ***************************************************************************
'
> FUNCTION alert_user(errindex&)           ! Signale une erreur … l'utilisateur
LOCAL message$,ret
'
SELECT errindex&
'
CASE -1
message$=" | Fichier de ressources | introuvable !"
CONT
'
CASE -2
message$=" | Fichier de ressources | probablement endommag‚ !"
~RSRC_FREE()
CONT
'
CASE -3
message$=" | Il n'y a plus de | fen"+CHR$(210)+"tre disponible !"
CONT
'
CASE -4
message$=" | MidiShare | n'est pas install‚ !"
CONT
'
CASE -5
message$=" | Il n'y a plus d'application | MidiShare disponible !"
CONT
'
CASE -6
message$=" | Il n'y a plus d'‚v‚nement   | MidiShare disponible !"
CONT
'
CASE -7
message$="Plus de m‚moire | disponible !"
CONT
'
ENDSELECT
ALERT 3,message$,1,"OK",ret
RETURN FALSE
ENDFUNC
'
> PROCEDURE traite_aes
'
' Cette proc‚dure gŠre les messages en provenance de l'AES:
' => d‚placement, fermeture ou rafraichissement de la fenetre, etc...
'
SELECT MENU(1)    ! Selon le message renvoy‚ par l'AES
'
CASE 20               ! WM_REDRAW -> il faut redessiner la fenetre
IF MENU(4)=wi_handle&
@do_redraw(MENU(5),MENU(6),MENU(7),MENU(8))
ENDIF
CONT
'
CASE 21               ! WM_TOPPED -> fenetre activ‚e
IF MENU(4)=wi_handle&
main_wind_valide!=TRUE
~WIND_SET(wi_handle&,10,ret&,ret&,ret&,ret&)
ELSE
main_wind_valide!=FALSE
ENDIF
CONT
'
CASE 22               ! WM_CLOSED -> fenetre ferm‚e (on s'en va)
IF MENU(4)=wi_handle&
~WIND_CLOSE(wi_handle&)
~WIND_DELETE(wi_handle&)
wi_handle&=-1
@close_appl
IF gl_apid%=0
  done_flag!=TRUE  ! done_flag! est utilis‚ dans la proc‚dure "main"
ENDIF
ENDIF
CONT
'
CASE 28               ! WM_MOVED -> fenetre d‚plac‚e
IF MENU(4)=wi_handle&
~WIND_SET(wi_handle&,5,MENU(5),MENU(6),MENU(7),MENU(8))
~WIND_GET(wi_handle&,5,xdesk&,ydesk&,wdesk&,hdesk&)
@update_window
ENDIF
CONT
'
CASE 41               ! AC_CLOSE -> on ferme un accessoire
IF (MENU(4)=menu_id%) AND (wi_handle&<>-1)
wi_handle&=-1
~WIND_DELETE(wi_handle&)
@close_appl
ENDIF
CONT
'
CASE 40               ! AC_OPEN -> on ouvre un accessoire
IF MENU(5)=menu_id% ! Attention, erreur sur la doc GFA 3.0
IF wi_handle&=-1  ! c'est bien MENU(5) et non MENU(4) qui
  ~@open_appl     ! retourne menu_id%
ELSE
  TOPW #(W_INDEX(#wi_handle&))
ENDIF
ENDIF
CONT
'
CASE 10               ! MN_SELECTED -> menu s‚lectionn‚
@do_command(MENU(0),MENU(4))
CONT
'
CASE 29                             ! WM_NEWTOP
'
ENDSELECT
RETURN
'
> PROCEDURE update_window
~WIND_GET(wi_handle&,4,xwork&,ywork&,wwork&,hwork&)
CLIP xwork&,ywork&,wwork&,hwork&-1
OB_X(adr_rsc%,0)=xwork&
OB_Y(adr_rsc%,0)=ywork&
RETURN
'
> PROCEDURE do_redraw(xr&,yr&,wr&,hr&)
LOCAL x2&,y2&,w2&,h2&
'
~WIND_GET(wi_handle&,11,x2&,y2&,w2&,h2&)
~WIND_UPDATE(1)
WHILE w2&<>0 AND h2&<>0
IF RC_INTERSECT(xr&,yr&,wr&,hr&,x2&,y2&,w2&,h2&)
~OBJC_DRAW(adr_rsc%,0,5,x2&,y2&,w2&,h2&)
ENDIF
~WIND_GET(wi_handle&,12,x2&,y2&,w2&,h2&)
WEND
~WIND_UPDATE(0)
RETURN
'
> FUNCTION open_appl
IF @set_up_midi                         ! ouverture MidiShare
IF @set_up_windows                    ! initialisations fenˆtre
RETURN TRUE
ENDIF
ENDIF
@close_appl
RETURN FALSE
ENDFUNC
'
> PROCEDURE close_appl
LOCAL ret%
'
'
IF gl_apid%<>0                         ! si l'application est en accessoire
IF @midi_share AND my_refnum&<>-1    ! si MidiShare est toujours install‚
IF NOT BTST(BIOS(11,-1),3)         ! si alternate non appuy‚e
@midi_close(my_refnum&)            ! ferme l'application MidiShare
my_refnum&=-1
ENDIF
ENDIF
ELSE
IF my_refnum&<>-1                    ! si l'appl MidiShare est install‚e
@midi_close(my_refnum&)            ! ferme l'application MidiShare
ENDIF
~MENU_BAR(adr_menu%,0)           ! supprime la barre des menus
~RSRC_FREE()                     ! libŠre les ressources
~APPL_EXIT()                     ! Quitte l'application
ENDIF
RETURN
'
> FUNCTION set_up_windows
'
' /****************************************************************************/
' /*                             Setup windows                                */
' /*--------------------------------------------------------------------------*/
' /* Ouvre la fenˆtre                                                         */
' /*                                                                          */
' /* Les paramŠtres de l'appel :                                              */
' /* ---------------------------                                              */
' /*                                                                          */
' /*          aucun                                                           */
' /*                                                                          */
' /****************************************************************************/
LOCAL ret&
'
~FORM_CENTER(adr_rsc%,xdesk&,ydesk&,ret&,ret&)
~WIND_CALC(0,11,xdesk&,ydesk&,OB_W(adr_rsc%,0),OB_H(adr_rsc%,0),ret&,ret&,wdesk&,hdesk&)
~GRAF_GROWBOX(xdesk&+wdesk&/2,ydesk&+hdesk&/2,40,40,xdesk&,ydesk&,wdesk&,hdesk&)
wi_handle&=WIND_CREATE(11,xdesk&,ydesk&,wdesk&,hdesk&)
~WIND_SET(wi_handle&,2,CARD(SWAP(V:appl_name$)),CARD(V:appl_name$),ret&,ret&)
~WIND_SET(wi_handle&,12,xdesk&,ydesk&,wdesk&,hdesk&)
~WIND_OPEN(wi_handle&,xdesk&,ydesk&,wdesk&,hdesk&)
@update_window
RETURN TRUE
ENDFUNC
'
> PROCEDURE do_command(menu%,item)
'
' /****************************************************************************
' *                                   DO COMMAND                              *
' *---------------------------------------------------------------------------*
' * Execution des commandes du menu. Ici on se contente de g‚rer l'item       *
' * Informations .                                                            *
' *                                                                           *
' * Les paramŠtres de l'appel :                                               *
' * ---------------------------                                               *
' *                                                                           *
' *          menu :     le titre du menu s‚lectionn‚.                         *
' *          item :     l'item de ce menu s‚lectionn‚.                        *
' *                                                                           *
' ****************************************************************************/
'
SELECT item
CASE 3
@show_info
CONT
'
' /*-----------*/
ENDSELECT
~MENU_TNORMAL(adr_menu%,menu%,1)
RETURN
'
> FUNCTION ob_lit_val(arbre%,objet%)
'
' Permet de lire la valeur affich‚e par un objet RSC
'
LOCAL txt$,i|,a|
DO
a|=PEEK(LPEEK(OB_SPEC(arbre%,objet%))+i|)
EXIT IF a|=0
txt$=txt$+CHR$(a|)
INC i|
LOOP
RETURN VAL(txt$)
ENDFUNC
'
> PROCEDURE ob_ecrit_val(arbre%,objet%,valeur%)
'
' Permet d'‚crire une valeur … afficher par un objet RSC
'
LOCAL txt$,i|
txt$=STR$(valeur%)+" "+CHR$(0)
FOR i|=1 TO LEN(txt$)
POKE LPEEK(OB_SPEC(arbre%,objet%))+i|-1,ASC(MID$(txt$,i|,1))
NEXT i|
RETURN
'
> FUNCTION ob_lit_txt$(arbre%,objet%)
'
' Permet de lire un texte affich‚ par un objet RSC
'
LOCAL txt$,i|,a|
DO
a|=PEEK(LPEEK(OB_SPEC(arbre%,objet%))+i|)
EXIT IF a|=0
txt$=txt$+CHR$(a|)
INC i|
LOOP
RETURN txt$
ENDFUNC
'
> PROCEDURE ob_ecrit_txt(arbre%,objet%,txt$)
'
' Permet d'‚crire un texte … afficher par un objet RSC
'
LOCAL i
FOR i=1 TO LEN(txt$)
POKE LPEEK(OB_SPEC(arbre%,objet%))+i-1,ASC(MID$(txt$,i,1))
NEXT i
RETURN
'
'
'
' ---------- Proc‚dures et fonctions relatives aux filtres MIDISHARE ---------
'
> PROCEDURE install_filter
'
' /****************************************************************************
' *                               InstallFilter                               *
' *---------------------------------------------------------------------------*
' * Cette proc‚dure d‚finit les valeurs du filtre de l'application. Un filtre *
' * est compos‚ de trois parties, qui sont trois tableaux de bool‚ens :       *
' *                                                                           *
' *          un tableau de 256 bits pour les ports Midi accept‚s              *
' *          un tableau de 256 bits pour les types d'‚v‚nements accept‚s      *
' *          un tableau de  16 bits pour les canaux Midi accept‚s             *
' *                                                                           *
' * Dans le code ci dessous, le filtre est param‚tr‚ pour accepter n'importe  *
' * quel type d'‚v‚nement.                                                    *
' *                                                                           *
' * Les paramŠtres de l'appel :                                               *
' * ---------------------------                                               *
' *                                                                           *
' *          aucun                                                            *
' *                                                                           *
' ****************************************************************************/
'
LOCAL i&
'
my_filter%=MALLOC(256+16)
FOR i&=0 TO 1
@accept_bit(my_filter%+32,i&)       ! accepte les notes et les keyOn
@accept_bit(my_filter%,i&)          ! accepte les ports 0 et 1
NEXT i&
FOR i&=2 TO 256
@reject_bit(my_filter%+32,i&)       ! filtre tous les autres types d'‚v‚nements
@accept_bit(my_filter%,i&)          ! accepte tous les ports
NEXT i&
'
FOR i&=0 TO 16
@accept_bit(my_filter%+64,i&)       ! et tous les canaux Midi
NEXT i&
'
@midi_set_filter(my_refnum&,my_filter%) ! installe le filtre
RETURN
'
' **************************************************************************
' **************** Les fonctions d'interfa‡age de MidiShare ****************
' **************************************************************************
'
> PROCEDURE lisez_moi_midi_share
'
'
' MIDISHARE est un module logiciel con‡u sp‚cialement pour permettre le
' fonctionnement et le d‚veloppement d'applications Midi dans un contexte
' multi-tƒches et temps r‚el.
'
' MIDISHARE prend en charge la plupart des problŠmes sp‚cifiques li‚s au
' d‚veloppement d'applications Midi: gestion des flux Midi, gestion du
' temp, gestion des tƒches. En outre, MIDISHARE permet le fonctionnement
' simultan‚ de ces applications, ainsi que l'‚tablissement de connections
' Midi virtuelles entre celles-ci.
' ------------------------------------------------------------------------
'  		            c GRAME 1989, 1990, 1991, 1992
' 	          [Yann Orlarey, Herv‚ Lequay, Dominique fober]						
' ------------------------------------------------------------------------
'
'
' Le pr‚sent fichier doit etre ins‚r‚ dans tout programme utilisant les
' fonctions de MidiShare.
' Il d‚crit les points d'entr‚e de MidiShare, ainsi que les structures
' de donn‚es et les constantes utilis‚es. Le code MidiShare proprement
' dit est contenu dans le fichier MIDSHARE.PRG, qui doit etre plac‚
' dans un dossier Auto. Au d‚marrage de la machine, ce code est charg‚
' en m‚moire, il est ancr‚ au vecteur $94 (trap 5). Toutes les
' proc‚dures et fonctions d‚finies ci-dessous se servent de cette "ancre"
' pour acc‚der au code.
'
' ___________________________________________________________________________
'
'       TYPES D'EVENEMENTS
' ___________________________________________________________________________
'
' Constantes d‚finissant les types d'‚v‚nements manipul‚s par MidiShare.
' Cette typologie inclut bien entendu les diff‚rents types Midi, mais
' aussi d'autres cat‚gories d'‚v‚nements, en particulier les Notes, les
' Streams, les Process et les types Priv‚s. Ces codes sont … utiliser
' entre autre avec la fonction midi_new_ev.
' ***************************************************************************
'
' type_note        = 0       ! note avec hauteur, v‚locit‚ et dur‚e en ms
'
' type_key_on      = 1       ! Note On avec hauteur et v‚locit‚
' type_key_off     = 2       ! Note Off avec hauteur et v‚locit‚
' type_key_press   = 3       ! Poly KeyPress avec hauteur et pression
' type_ctrl_change = 4       ! Control Change avec controleur et valeur
' type_prog_change = 5       ! Program Change avec num‚ro de programme
' type_chan_press  = 6       ! Channel Pressure avec pression
' type_pitch_wheel = 7       ! Pitch Wheel avec LSB et MSB
' type_song_pos    = 8       ! Song Position Pointer avec LSB et MSB
' type_song_sel    = 9       ! Song Select avec num‚ro de song
' type_clock       = 10      ! Timing Clock
' type_start       = 11      ! Start
' type_continue    = 12      ! Continue
' type_stop        = 13      ! Stop
' type_tune        = 14      ! Tune Request
' type_active_sens = 15      ! Active Sensing
' type_reset       = 16      ! System Reset
' type_sys_ex      = 17      ! System Exclusive de longueur variable
' type_stream      = 18      ! Flot Midi quelconque de longueur variable
' type_private     = 19      ! 19...127  ‚v‚nement priv‚ … usage libre
' type_process     = 128     ! ‚vŠnement priv‚ servant au MidiCall
' type_dprocess    = 129     ! ‚vŠnement priv‚ servant au midi_dtask
' typeQuarterFrame = 130     ! ‚v‚nement de synchronisation MTC
' typeCtrl14b      = 131     ! controleur 14 bits
' typeNonRegParam  = 132     ! non registered parameter
' typeRegParam     = 133     ! registered parameter
'
' Tous les ‚vŠnements suivants sont des ‚vŠnements de la norme MIDIFILE.
'
' typeSeqNum       = 134     ! num‚ro de s‚quence
' typeText         = 135     ! ‚v‚nement texte
' typeCopyright    = 136     ! message copyright
' typeSeqName      = 137     ! nom de s‚quence ou de piste
' typeInstrName    = 138     ! nom d'instrument
' typeLyric        = 139     ! paroles d‚stin‚es … etre chant‚es
' typeMarker       = 140     ! marqueur
' typeCuePoint     = 141     ! cue point
' typeChanPrefix   = 142     ! Midi Channel Prefix
' typeEndTrack     = 143     ! fin de piste
' typeTempo        = 144     ! changement de tempo
' typeSMPTEOffset  = 145     ! offset smpte
' typeTimeSign     = 146     ! indication de mesure
' typeKeySign      = 147     ! signature tonale
' typeSpecific     = 148     ! m‚ta evt sp‚cifique … un s‚quenceur
'
' typeReserved     = 149..254! reserved for future extensions
'
' type_dead        = 255     ! ‚vŠnement priv‚ invalid‚
'
'
' ***************************************************************************
'       CODES MIDI
' ___________________________________________________________________________
' Constantes d‚finissant les codes de statut Midi.
' ***************************************************************************
'
' note_off     = &H80
' note_on      = &H90
' poly_touch   = &HA0
' control_chg  = &HB0
' program_chg  = &HC0
' after_touch  = &HD0
' pitch_bend   = &HE0
' sysreal_time = &HF0
' sys_ex       = &HF0
' undef_1      = &HF1
' song_pos     = &HF2
' song_sel     = &HF3
' undef_2      = &HF4
' undef_3      = &HF5
' tune         = &HF6
' end_sys_x    = &HF7
' m_clock      = &HF8
' undef_4      = &HF9
' m_start      = &HFA
' m_cont       = &HFB
' m_stop       = &HFC
' undef_5      = &HFD
' act_sense    = &HFE
' m_reset      = &HFF
'
'
' ***************************************************************************
'       PORTS MIDI
' __________________________________________________________________________
' Constantes d‚finissant les ports Modem et Printer.
' ***************************************************************************
'
' port_modem   = 0
' port_printer = 1
'
'
' ***************************************************************************
'       CODES D'ERREURS
' __________________________________________________________________________
' Constantes d‚finissant les codes d'erreurs renvoy‚s par certaine
' fonctions de MidiShare.
' ***************************************************************************
'
' midi_err_space   = -1        ! plus de place dans la freeList
' midi_err_refnum  = -2        ! mauvais numero de reference
' midi_err_badtype = -3        ! mauvais type d'‚v‚nement
' midi_err_index   = -4        ! mauvais index d'acces … un ‚v‚nement
'
'
' ****************************************************************************
' 							SYNCHRONISATION CODES								
' ****************************************************************************
'
' MIDISyncExternal = &H8000     ! bit-15 for external synchronisation
' MIDISyncAnyPort  = &H4000     ! bit-14 for synchronisation on any port
'
'
' **************************************************************************
'       CODES D'APPLICATIONS
' __________________________________________________________________________
' Constantes d‚finissant les codes de modification du statut des
' applications. Codes utilis‚s pour signaler … une application, toute
' modification survenue aux autres applications (ouverture, connexion,
' d‚connexion...). Ce code est toujours fourni avec le num‚ro de
' r‚f‚rence de l'application modifi‚e sous la forme d'un long:
' $rrrrcccc (r= refnum, c=code)
' ***************************************************************************
'
'
' midi_open_appl     = 1
' midi_close_appl    = 2
' midi_chg_name      = 3
' midi_chg_connect   = 4
' midi_open_modem    = 5
' midi_close_modem   = 6
' midi_open_printer  = 7
' midi_close_printer = 8
'
'
' **************************************************************************
'       STRUCTURES DES EVENEMENTS
' __________________________________________________________________________
' Tous les ‚v‚nements sont construits … l'aide d'une ou plusieurs
' cellules de taille fixe (16 octets). La plupart ne n‚cessitent
' qu'une seule cellule. D'autres, comme les System Exclusive n‚cessitent
' plusieurs cellules chain‚es.
' ***************************************************************************
'
' /*----------------Cellule d'extension d'un System Exclusive---------------*/
' offset        contenu         type            signification
'   0            link           long       lien de chainage cellule suivante
'   4            data           byte       12 octets de donn‚es
'
' /*----------------Cellule d'extension d'un Private------------------------*/
' offset        contenu         type            signification
'   0            ptr1           long       pointeurs … utiliser librement
'   4            ptr2           long       par l'application
'   8            ptr3           long
'   12           ptr4           long
'
' /*----------------Cellule d'un ‚v‚nement normal---------------------------*/
' offset        contenu         type            signification
'   0            link           long       chainage: adresse de l'evt  suivant
'   4            date           long       date de l'‚v‚nement en ms
'   8            ev_type        byte       type de l'‚v‚nement
'   9            refNum         byte       num‚ro de r‚f‚rence de l'application
'  10            port           byte       port Midi
'  11            chan           byte       canal Midi
' puis selon le type de l'‚v‚nement:
' ----------------------------------- pour un ‚v‚nement de type note:
'  12            pitch          byte       hauteur de la note
'  13            vel            byte       sa v‚locit‚
'  14            dur            word       sa dur‚e
' ----------------------------------- pour un autre message Midi:
'  12            data 1         byte       les octets de donn‚e au format
'  13            data 2         byte       de la norme Midi
'  14            data 3         byte
'  15            data 4         byte
' ----------------------------------- pour un systŠme exclusive:
'  12            linkSE         long       pointeur extension system exclusive
' ----------------------------------- pour un message priv‚:
'  12            linkST         long       pointeur extension msg priv‚
' ----------------------------------- pour MidiFile time signature:
'  12            numerateur     byte       le num‚rateur
'  13            denominateur   byte       d‚nominateur comme puissance n‚g. de 2
'  14            nClocks        byte       nombre  de clocks Midi par battue
'  15            n32nd          byte       nombre de 32nd notes par noire
' ----------------------------------- pour MidiFile key signature:
'  12            ton            byte       0: key of C, 1: 1 sharp -1: 1 flat etc...
'  13            mode           byte       0: major 1: minor
'  14            unused         word       inutilis‚
' ----------------------------------- pour MidiFile sequence number:
'  12            number         word       num‚ro de la s‚quence
'  14            unused         word       inutilis‚
' ----------------------------------- pour MidiFile tempo:
'  12            tempo          long       en microsec par Midi quarter note
'
'
' /*----------------En tete de s‚quence-------------------------------------*/
' offset        contenu         type            signification
'   0            first          long       ptr sur le premier ‚vt de la s‚quence
'   4            last           long       ptr sur le dernier ‚vt de la s‚quence
'   8            undef1         long       r‚serv‚
'   12           undef2         long       r‚serv‚
'
'
' /*----------------Filtres Midi--------------------------------------------*/
' offset        contenu         type            signification
'   0            port[16]       word       ports 0 … 255 : 256 bits
'  32            ev_type[16]    word       types 0 … 255 : 256 bits
'  64            channel        word       canaux 0 … 15 :  16 bits
'  80            unused         word       r‚serv‚
'
' /*----------------Nom d'application Midi Share----------------------------*/
' doit etre au format 'C' standard c'est … dire, doit se terminer par un
' z‚ro (indicateur de fin de chaine). De plus, il ne doit pas exc‚der
' 32 caractŠres ( '0' inclus).
'
'
' /*----------------Infos de synchronisation -------------------------------*/
' offset        contenu         type            signification
'   0            time           long       date courante
'   4            reenter        long       nombre de r‚entrance de l'horloge
'   8            mode           word       mode de synchronisation
'  10            locked         byte       synchro locked
'  11            port           byte       port de synchronisation
'  12            start          long       date de d‚but de synchronisation
'  16            stop           long       date de fin de synchronisation
'  20            offset         long       offset de la synchro
'  24            speed          long       sa vitesse
'  28            breaks         long       nombre de ruptures de synchro
'  32            format         word       format de la synchro
'
' /*----------------Location smpte -----------------------------------------*/
' offset        contenu         type            signification
'   0            format         word       0:24f/s, 1:25f/s, 2:30DFf/s, 3:30f/s
'   2            heures         word       0..23
'   4            minutes        word       0..59
'   6            secondes       word       0..59
'   8            frames         word       0..30 (according to format)
'  10            fracs          word       0..99 (1/100 of frames)
'
'
' ****************************************************************************
' ----------------------------------------------------------------------------
'
'       D‚finition des fonctions et proc‚dures d'appel … Midishare
'
' Le code de MidiShare proprement dit est charg‚ par MIDSHARE.PRG.
' Les fonctions et proc‚dures d‚finies ci-dessous donnent accŠs au
' code r‚sident de MidiShare par l'interm‚diaire d'un sous-programme
' assembleur rang‚ dans la variable 'msh_adr%' et contenant le code
' suivant:      addq.l #4,sp
'               trap   #5
'               subq.l #4,sp
'               rts
' Ce code permet de formatter les paramŠtres pass‚s en argument aux
' fonctions et proc‚dures d'appel … MidiShare. L'appel des fonctions
' r‚sidentes de MidiShare se fait ensuite comme pour les appels
' systŠme (gemdos, bios, xbios): les paramŠtres sont pouss‚s sur la
' pile, puis le num‚ro de la fonction, enfin le programme effectue un
' saut vectoris‚ … l'adresse point‚e par &H94 (vecteur du trap 5 en
' principe inutilis‚, point d'ancrage de MidiShare qui contient l'adresse
' d'une routine de dispatch qui r‚alise l'appel effectif de la fonction).
' Le vecteur &H94 est initialis‚ au chargement par MIDSHARE.PRG.
' La variable 'msh_adr%' doit etre initialis‚e par le programme appelant
' avant toute utilisation des fonctions ou proc‚dures d‚finies ci-dessous,
' grace … l'appel pr‚alable de la proc‚dure 'init_midishare'.
'
' Pour plus d'infos sur les proc‚dures suivantes,
' voir la documentation d‚veloppeur MIDISHARE ou l'accessoire MIDIHELP
'
'
' ***************************************************************************
'
' (@) GRAME 1989, Yann Orlarey, Herv‚ Lequay, Dominique Fober
'
' ***************************************************************************
RETURN
'
' ---------------------- initialisation de MidiShare ----------------------
'
> FUNCTION init_midishare
LOCAL midi_dispatch%,a$
msh_mem%=MALLOC(36)
IF msh_mem%
RESTORE msh_data
FOR i%=0 TO 8
READ midi_dispatch%
LPOKE msh_mem%+(i%*4),midi_dispatch%
NEXT i%
msh_adr%=msh_mem%
msh_set_alarm%=msh_mem%+4
msh_alarm%=msh_mem%+16
ENDIF
RETURN (msh_mem%)
'
msh_data:
DATA &H4E464E75
DATA &H202F0004,&H41FA0014,&H20804E75
DATA &H202F0006,&H41FA0008,&H20502080
DATA &H4E750000,&H00000000
'
ENDFUNC
'
' -------------------- AccŠs … l'environnement ----------------------------
'
> FUNCTION midi_get_version
LOCAL v%
v%=C:msh_adr%(0)
RETURN (DPEEK(VARPTR(v%)+2))
ENDFUNC
'
> FUNCTION midi_count_appls
LOCAL c%
c%=C:msh_adr%(1)
RETURN (DPEEK(VARPTR(c%)+2))
ENDFUNC
'
> FUNCTION midi_get_ind_appl(index&)
LOCAL r%
r%=C:msh_adr%(2,index&)
RETURN (DPEEK(VARPTR(r%)+2))
ENDFUNC
'
> FUNCTION midi_get_named_appl(midi_name$)
LOCAL r%
r%=C:msh_adr%(3,L:VARPTR(midi_name$))
RETURN (DPEEK(VARPTR(r%)+2))
ENDFUNC
'
' --------------------- Synchronisation smpte ------------------------------
'
> PROCEDURE midi_get_sync_info(info$)
~C:msh_adr%(&H39,L:VARPTR(info$))  ! info est une chaine d'au moins 34 caractŠres
RETURN
'
> PROCEDURE midi_set_sync_mode(mode&)
~C:msh_adr%(&H3A,refnum&)
RETURN
'
> FUNCTION midi_get_ext_time(void)
RETURN (C:msh_adr%(&H3E))
ENDFUNC
'
> FUNCTION midi_int_2_ext_time(time%)
RETURN (C:msh_adr%(&H3F,L:time%))
ENDFUNC
'
> FUNCTION midi_ext_2_int_time(time%)
RETURN (C:msh_adr%(&H40,L:time%))
ENDFUNC
'
> PROCEDURE midi_time_2_smpte(time%,format&,loc%)
~C:msh_adr%(&H41,L:time%,format&,L:VARPTR(loc%))
RETURN
'
> FUNCTION midi_smpte_2_time(loc%)
RETURN (C:msh_adr%(&H42,L:VARPTR(loc%)))
ENDFUNC
'
' --------------------- Ouverture / Fermeture ------------------------------
'
> FUNCTION midi_open(midi_name$)
LOCAL r%
r%=C:msh_adr%(4,L:VARPTR(midi_name$))
RETURN (DPEEK(VARPTR(r%)+2))
ENDFUNC
'
> PROCEDURE midi_close(refnum&)
~C:msh_adr%(5,refnum&)
RETURN
'
' ----------------- Configuration de l'application ------------------------
'
> FUNCTION midi_get_name(refnum&)
RETURN (C:msh_adr%(6,refnum&))
ENDFUNC
'
> PROCEDURE midi_set_name(refnum&,midi_name$)
~C:msh_adr%(7,refnum&,L:VARPTR(midi_name$))
RETURN
'
> FUNCTION midi_get_info(refnum&)
RETURN (C:msh_adr%(8,refnum&))
ENDFUNC
'
> PROCEDURE midi_set_info(refnum&,info_ptr%)
~C:msh_adr%(9,refnum&,L:info_ptr%)
RETURN
'
> FUNCTION midi_get_filter(refnum&)
RETURN (C:msh_adr%(&HA,refnum&))
ENDFUNC
'
> PROCEDURE midi_set_filter(refnum&,filter_ptr%)
~C:msh_adr%(&HB,refnum&,L:filter_ptr%)
RETURN
'
'
' ------------------------- Connexions internes --------------------------
'
> PROCEDURE midi_connect(src&,dest&,state!)
~C:msh_adr%(&H10,src&,dest&,state!)
RETURN
'
> FUNCTION midi_is_connected(src&,dest&)
LOCAL state!
state!=C:msh_adr%(&H11,src&,dest&)
RETURN (state!)
ENDFUNC
'
' ------------------------ Gestion des ports midi -----------------------
'
> FUNCTION midi_get_port_state(port&)
LOCAL state!
state!=C:msh_adr%(&H12,port&)
RETURN (state!)
ENDFUNC
'
> PROCEDURE midi_set_port_state(port&,state!)
~C:msh_adr%(&H13,port&,state!)
RETURN
'
' -------------------------- Gestion des ‚v‚nements ----------------------
'
> FUNCTION midi_free_space
RETURN (C:msh_adr%(&H14))
ENDFUNC
'
> FUNCTION midi_new_cell
RETURN (C:msh_adr%(&H33))
ENDFUNC
'
> PROCEDURE midi_free_cell(event_ptr%)
~C:msh_adr%(&H34,L:event_ptr%)
RETURN
'
> FUNCTION midi_total_space
RETURN (C:msh_adr%(&H35))
ENDFUNC
'
> FUNCTION midi_new_ev(type&)
RETURN (C:msh_adr%(&H15,type&))
ENDFUNC
'
> FUNCTION midi_copy_ev(event_ptr%)
RETURN (C:msh_adr%(&H16,L:event_ptr%))
ENDFUNC
'
> PROCEDURE midi_free_ev(event_ptr%)
~C:msh_adr%(&H17,L:event_ptr%)
RETURN
'
> PROCEDURE midi_set_field(event_ptr%,field%,val%)
~C:msh_adr%(&H3B,L:event_ptr%,L:field%,L:val%)
RETURN
'
> FUNCTION midi_get_field(event_ptr%,field%)
RETURN (C:msh_adr%(&H3C,L:event_ptr%,L:field%))
ENDFUNC
'
> PROCEDURE midi_add_field(event_ptr%,val%)
~C:msh_adr%(&H1A,L:event_ptr%,L:val%)
RETURN
'
> FUNCTION midi_count_fields(event_ptr%)
RETURN (C:msh_adr%(&H3D,L:event_ptr%))
ENDFUNC
'
' ------------------------- Gestion des s‚quences -------------------------
'
> FUNCTION midi_new_seq
RETURN (C:msh_adr%(&H1D))
ENDFUNC
'
> PROCEDURE midi_add_seq(seq_ptr%,event_ptr%)
~C:msh_adr%(&H1E,L:seq_ptr%,L:event_ptr%)
RETURN
'
> PROCEDURE midi_free_seq(seq_ptr%)
~C:msh_adr%(&H1F,L:seq_ptr%)
RETURN
'
> PROCEDURE midi_clear_seq(seq_ptr%)
~C:msh_adr%(&H20,L:seq_ptr%)
RETURN
'
' --------------------------------- Date courante -------------------------
'
> FUNCTION midi_get_time
RETURN (C:msh_adr%(&H22))
ENDFUNC
'
' ------------------------------- Emissions Midi --------------------------
'
> PROCEDURE midi_send_im(refnum&,event_ptr%)
~C:msh_adr%(&H23,refnum&,L:event_ptr%)
RETURN
'
> PROCEDURE midi_send(refnum&,event_ptr%)
~C:msh_adr%(&H24,refnum&,L:event_ptr%)
RETURN
'
> PROCEDURE midi_send_at(refnum&,event_ptr%,date%)
~C:msh_adr%(&H25,refnum&,L:event_ptr%,L:date%)
RETURN
'
' ------------------------------ Receptions Midi --------------------------
'
> FUNCTION midi_count_evs(refnum&)
RETURN (C:msh_adr%(&H26,refnum&))
ENDFUNC
'
> FUNCTION midi_get_ev(refnum&)
RETURN (C:msh_adr%(&H27,refnum&))
ENDFUNC
'
> FUNCTION midi_avail_ev(refnum&)
RETURN (C:msh_adr%(&H28,refnum&))
ENDFUNC
'
> PROCEDURE midi_flush_evs(refnum&)
~C:msh_adr%(&H29,refnum&)
RETURN
'
' ---------------------------- Boite aux lettres --------------------------
'
> FUNCTION midi_read_sync(adr_mem%)
RETURN (C:msh_adr%(&H2A,L:adr_mem%))
ENDFUNC
'
> FUNCTION midi_write_sync(adr_mem%,val%)
RETURN (C:msh_adr%(&H2B,L:adr_mem%,L:val%))
ENDFUNC
'
' ---------------------------- Controle MidiShare ------------------------
'
> FUNCTION midi_share
LOCAL is!
LOCAL stack_ptr%,strg_ptr%
'
stack_ptr%=BIOS(&H20,L:0)
strg_ptr%=LPEEK(&H94)-18
IF (LPEEK(strg_ptr%)=&H4D494449) AND (LPEEK(strg_ptr%+4)=&H53484152) AND (DPEEK(strg_ptr%+8)=&H4500)
is!=TRUE
ELSE
is!=FALSE
ENDIF
~BIOS(&H20,L:stack_ptr%)
RETURN (is!)
ENDFUNC
'
' ------------------------- Fonctions d'acces aux filtres ----------------
> PROCEDURE accept_bit(adr%,n&)
LOCAL offset&
offset&=n&
DIV offset&,8
POKE adr%+offset&,BSET(PEEK(adr%+offset&),MOD(n&,8))
RETURN
'
> PROCEDURE reject_bit(adr%,n&)
LOCAL offset&
offset&=n&
DIV offset&,8
POKE adr%+offset&,BCLR(PEEK(adr%+offset&),MOD(n&,8))
RETURN
'
> PROCEDURE invert_bit(adr%,n&)
LOCAL offset&
offset&=n&
DIV offset&,8
POKE adr%+offset&,BCHG(PEEK(adr%+offset&),MOD(n&,8))
RETURN
'
> FUNCTION is_accepted_bit(adr%,n&)
LOCAL offset&
offset&=n&
DIV offset&,8
RETURN BTST(PEEK(adr%+offset&),MOD(n&,8))
ENDFUNC
'
'
' ---------------------- Lecture des attributs d'un event ----------------
'
> FUNCTION event_link(event%)       ! retourne le lien de chainage
RETURN LPEEK(event%)
ENDFUNC
'
> FUNCTION event_date(event%)       ! retourne la date en ms (4 octets)
RETURN LPEEK(event%+4)              ! attention... 4 octets (mot long)
ENDFUNC
'
> FUNCTION event_type(event%)       ! retourne le type
RETURN PEEK(event%+8)               ! ex= 1 si key on
ENDFUNC                             !     2 si key off etc...
'
> FUNCTION event_refnum(event%)     ! retourne le numero de l'application source
RETURN PEEK(event%+9)
ENDFUNC
'
> FUNCTION event_port(event%)       ! retourne le num‚ro de port midi
RETURN PEEK(event%+10)
ENDFUNC
'
> FUNCTION event_chan(event%)       ! retourne le canal midi
RETURN PEEK(event%+11)
ENDFUNC
'
' Pour un ‚v‚nement de type note:
'
> FUNCTION event_pitch(event%)      ! retourne la hauteur de la note
RETURN PEEK(event%+12)
ENDFUNC
'
> FUNCTION event_velo(event%)       ! retourne la v‚locit‚
RETURN PEEK(event%+13)
ENDFUNC
'
> FUNCTION event_len(event%)        ! retourne la longueur de la note
RETURN DPEEK(event%+14)             ! attention... 2 octets
ENDFUNC
'
'
' --------------- Modification des attributs d'un event --------------------------
'
> PROCEDURE set_event_link(event%,next%)  ! modification du lien de
LPOKE event%,date%                      ! chainage d'un ‚v‚nement
RETURN
'
> PROCEDURE set_event_date(event%,date%)  ! affecte la date en ms (4 octets)
LPOKE event%+4,date%                      ! attention... 4 octets (mot long)
RETURN
'
> PROCEDURE set_event_type(event%,type|)  ! affecte le type … l'event
POKE event%+8,type|                       ! ex= 1 si key on
RETURN                                    !     2 si key off etc...
'
> PROCEDURE set_event_refnum(event%,ref_num|) ! affecte le numero de l'application source
POKE event%+9,refnum|
RETURN
'
> PROCEDURE set_event_port(event%,port|)   ! affecte le num‚ro de port midi
POKE event%+10,port|
RETURN
'
> PROCEDURE set_event_chan(event%,chan|)   ! affecte le canal midi
POKE event%+11,chan|
RETURN
'
' Pour un ‚v‚nement de type note:
'
> PROCEDURE set_event_pitch(event%,pitch|) ! change la hauteur de la note
POKE event%+12,pitch|
RETURN
'
> PROCEDURE set_event_velo(event%,velo|)   ! change la v‚locit‚
POKE event%+13,velo|
RETURN
'
> PROCEDURE set_event_len(event%,len%)     ! change la longueur de la note
DPOKE event%+14,len%                       ! attention, 2 octets
RETURN
