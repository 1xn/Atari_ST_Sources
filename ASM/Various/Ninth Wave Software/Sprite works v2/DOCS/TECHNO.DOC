  
 
 
                         Technical Manual
                         ----------------
 
 
This  document is intended to teach you how to get the  best  from 
GFA BASIC,  from using the extension kit to using GEMDOS and  your 
own INLINE commands.
 
 
     Contents                        Section
 
     The Basics ....................... 1
        Variables
        Reserving Memory
        INLINEs
        Speed Improvements
        Screen Syncronisation
     Getting Started .................. 2
        Setting Up The Screens
        Simplifying Commands
        Using Interrupts
        Printing With Screen Switching
     Using Sprites .................... 3
        Using The Sprite Handler
        Non-erasable Sprites
     Using Maps ....................... 4
        Non-scrolling Maps
        Scrolling Maps
     Using Samples And Protracker ..... 5
     Using BIOS, XBIOS And GEMDOS ..... 6
        Useful Commands
        Error Reports
     Writing Your Own Commands ........ 7
     Using Commands In 68000 .......... 8
     The Screen Layout ................ 9
     STE Commands ..................... 10
        Checking for an STE
        Blitter misconceptions
        Hardware scrolling
        DMA sound
        Extended palette

-------------------------------------------------------------------
 
THE BASICS                                                        1
 
Up until now I have taken it that you have understood most of  the 
commands  and example files,  but maybe I have taken too much  for 
granted.  Described here will be some of the essential things that 
you should know.
 
1.1 Variables

There  are four types of numerical variable in GFA Basic  :  byte, 
word, long and real, each of which are signified by a symbol which 
follows the variable. NEVER use real numbers if at all possible as 
they are very slow.  Always stick to the other three types, a long 
variable  (short for long word) is a four byte integer and a  word 
is a two byte integer. A little quirk that you need to remember is 
that  GFA  always needs to handle minus numbers  (byte  being  the 
exception) which limits the range of these numbers.  The following 
shows  the ranges and the symbols that should follow the  variable 
to signify what type they are.
 
     var#      real number, no range
     var|      byte value, 0 to 255
     var&      word value, -32768 to +32767
     var%      long value, -2147483648 to +2147483647
 
NOTE: Although you would think that a variable assigned to a DPEEK
would need a word (&), if the value is greater then +32767 it will 
not  be treated as a minus number and so a long (%) variable  must 
be used. You can overcome this problem by reading the address with 
var&=WORD{address%} which can read a negative value.

As  the  default  all of the programs on the disk  have  the  word 
definition  as the default variable by having DEFWRD "a-z" at  the 
start  of the code.  This means that if a variable has  no  symbol 
then GFA takes it as a word.  Without this definition the  default 
would be a real number which of course we don't want, now that the 
word  variable is the default any real variable must have  a  hash 
(#) symbol after it.

This  is mainly for vanities sake as a few hundred lines  of  code 
with  & symbols all over the place can look quite  messy,  and  it 
also saves on typing !

Throughout  this documentation it should be taken that a  variable 
without any symbol is a word variable.
  
1.2 Reserving memory

Reserving memory can be achieved in three different ways : malloc, 
strings and arrays. 

Malloc  can be difficult to use as GFA programs allocate  all  the 
memory available when they are run.  This means that you must work 
out  how much memory the program will use and free  the  remaining 
memory with RESERVE so that malloc will work. When the program has 
finished  you  then have the bother to free all  the  memory  that 
you've used.

Example:  RESERVE 20000            ! Let GFA have 20k
          buffer%=MALLOC(40000)    ! Malloc a 40k buffer
          '
          ' All code, arrays and strings must total less
          ' than the reserved 20k.
          '
          ~MFREE(buffer%)          ! Give back the 40k
          RESERVE                  ! Unreserve the 20k
          END
      
Strings  can cause many problems when storing  information  within 
them as GFA moves strings around in memory which seems to be  part 
of its memory management.  Some Sprite Works commands need a fixed 
address for things such as graphics pointers,  and so if a  string 
is  moved the command may produce corrupt output or even  crash  ! 
Strings  also  have the disadvantage of having a maximum  size  of 
32767 bytes.

Example:  buffer$=SPACE$(20000)    ! Reserve 20k
          buffer%=V:buffer$        ! Point to start of text

The final way,  by array,  is the best method to use. As mentioned 
earlier, GFA snatches all the available memory when the program is 
run. This memory is used for code, strings and arrays. There is no 
limit  on the size and arrays to not move so you can be sure  that 
data will stay where you put it.

Example:  DIM buffer|(40000)       ! Reserve 40k 
          buffer%=V:buffer|(0)     ! Point to first element

You  will notice that a byte (|) assignment has been used for  the 
DIM,  if a word assignment had been used, DIM buffer&(40000), then 
80,000 bytes would of been allocated.

In  all the examples you will see that the address of  the  buffer 
needs to be stored in a long variable (%).  The actual  assignment 
is  made  using  the  VARPTR command  which  stands  for  VARiable 
PoinTeR.  In the case of the strings and arrays the VARPTR is used 
to  find  the first byte of the reserved  memory.  Throughout  the 
documentation and programs the shorthand version of VARPTR us used 
which is written V:.

1.3 INLINEs
 
INLINE  statements are commonly used to store the data within  the 
program.  The advantage is that once compiled it provides a single 
program without the need to load any extra files. The disadvantage 
is that the basic programs can become quite large.

NOTE:  If saving the program as a list the INLINE data WILL NOT BE 
SAVED, and so must be reloaded once a program is merged.
 
If you do not want to use the INLINE,  then define a space for the 
data as described in (2) and BLOAD the data into the program.
 
NOTE:  You can load ANYTHING into an INLINE statement,  it does'nt 
have to be a .INL file.  In a number of the example files  palette 
data is loaded into them.
 
1.4 Speed improvements

Remember  that speed is very important,   so always use the MUL  ,  
DIV,  INC,  DEC,  ADD  and  SUB commands wherever  you  are  using 
integers.           

Even  when  you are using real numbers you can still  make  a  30% 
speed saving by using the MUL var,n and DIV var,n or up to 50%  by 
using ADD var,n and SUB var,n.

Instead  of using PEEK and POKE replace them with  BYTE{},  WORD{} 
and LONG{} commands which in most cases are alot faster, up to ten 
times in some cases ! The only reason I have used PEEK and POKE in 
the documentation and programs is to avoid confusing you.

     Replacement PEEK    ->   var|=BYTE{address%}
                 POKE    ->   BYTE{address%}=var|
                 DPEEK   ->   var=WORD{address%}
                 DPOKE   ->   WORD{address%}=var
                 LPEEK   ->   var%=LONG{address%}
                 LPOKE   ->   LONG{address%}=var%

These  commands  only work in user mode so if you  need  to  write 
values  to system variables or hardware registers then  you  still 
need to use SPOKE, SDPOKE and SLPOKE.

1.5 Screen syncronisation

A number of terms are abbreviated which deal with  synchronisation 
of  the screen display,  common terms being VSYNC,  WVBI  or  VBL. 
These stand for Vertical SYNCronisation,  Wait for Vertical  Blank 
Interrupt  and Vertical BLank.  Vertical blank is defined  as  the 
point  at which the electron beam of the television  has  finished 
the  current  scan  and is just about to start to  scan  the  next 
picture.  As  this  occurs every 50th of a second  it  provides  a 
stable means of syncronisation.  An interrupt occurs at this  time 
to  carry out specific system tasks such as setting a  new  screen 
address or palette,  updating mouse and timers. 

When  screen switching is used one of the syncronisation  commands 
needs  to  be  used just after setting the  physical  and  logical 
screens.  This insures that the screens have successfully  swapped 
and  that the back screen is in memory and the fore screen is  the 
current visible screen.

------------------------------------------------------------------ 

GETTING STARTED                                                  2
 
1 Setting up the screens
 
Most  of the time,  especially if you are writing a game you  will 
want  two workscreens.  These are printed on  alternativately  and 
switched  on  the VBL to avoid any flicker.  There  is  a  program 
called  SETUP.GFA  in the example folder which  sets  the  screens 
ready for use. The program is as follows :
 
     DEFWRD "a-z"
     store_palette
     initialise
     set_screens
     ON ERROR GOSUB error
     ON BREAK GOSUB break
     '
     ' Put your program here
     '
     reset
     END
     '
     > PROCEDURE store_palette
     > PROCEDURE restore_palette
     > PROCEDURE set_screens
     > PROCEDURE swap_screens
     > PROCEDURE error
     > PROCEDURE break
     > PROCEDURE reset
     > PROCEDURE initialise

The program first sets word variables as the default,  stores  the 
palette  then  initialises  all the data that  is  needed  by  the 
program.  Within  the initialise procedure you should declare  all 
your INLINEs,  setup arrays and load any data. The two workscreens 
are  then created with the variables back% and fore%  pointing  to 
the logical and physical screens respectively.  Any graphics  that 
are  drawn by GFA will be drawn on the logical screen and so  must 
either be copied to the physical screen or can be made visible  by 
calling the swap_screens procedure.

When  dealing with screen switching and any Sprite Works  commands 
that  are  interrupt driven then it is important  to  restore  the 
original screen pointers and disable the interrupts before  ending 
the  program.  If  an error or break occurs then  the  program  is 
likely to crash, so an ON ERROR and ON BREAK are set up. 

The current procedures are as follows :

     PROCEDURE store_palette
       INLINE old_pal%,32
       FOR a|=0 to 30 STEP 2
         DPOKE old_pal%+a|,DPEEK(&HFFFF8240+a|)
       NEXT a|
     RETURN

The  store  palette procedure has a 32 byte buffer  inside  it  to 
store the current palette.  The colours are read directly from the 
hardware  registers  $FFFF8240-$FFFF825E  and are  stored  in  the 
buffer.

     PROCEDURE restore_palette
       ~XBIOS(6,L:old_pal%)
     RETURN

The restore palette procedure uses a single eXtended BIOS  command 
to set the old palette. See section 6 for more details.

     PROCEDURE set_screens
       res|=XBIOS(4)
       DIM bs|(32256)
       real%=XBIOS(2)
       back%=(V:bs|(0)+255) AND &HFFFF00
       fore%=real%
       ~XBIOS(5,l:back%,L:fore%,0)
       CLS
       BMOVE back%,fore%,32000
     RETURN

The set_screens procedure first reads the current resolution  with 
the  XBIOS(4)  command.  A  32k buffer is  then  created  and  the 
physical  screen  address is stored.  The next  line  creates  the 
background screen address by obtaining the buffer address,  adding 
255  and then clearing the first byte.  Clearing the byte  ensures 
that the address is on a 256 byte boundary which is a  requirement 
for  a screen address*.  The foreground screen is then set  to  the 
current  screen and then the logical and physical screens are  set 
and the computer is forced into low resolution.  The clear  screen 
then  affects  the  background  screen  which  is  copied  to  the 
foreground screen.

*NOTE: The STE can handle a word aligned screen and doesn't need  a 
256 byte aligned screen as on the ST.  As an array is always  word 
aligned you only need to state back%=V:bs|(0).

     PROCEDURE swap_screens
       SWAP fore%,back%
       ~C:swap_sync%(0,L:back%,L:fore%)
     RETURN

The  swap_screens  procedure first swaps over the  foreground  and 
background  pointers then the physical screen switch  occurs  with 
the  swap_sync command.  The swap_sync delay is currently  set  at 
zero  which  is equivalent to one VSYNC.  It will quite  often  be 
necessary  to set the speed to 2 or 3 which will make  the  screen 
switching occur 17 or 13 times a second.

     PROCEDURE initialise
       INLINE wvbi%,230
       counter_on%=wvbi%
       counter_off%=wvbi%+4
       wait%=wvbi%+8
       swap_sync%=wvbi%+12
       ~C:counter_on%()
     RETURN

The initialise procedure is for you to expand on.  All the  INLINE 
routines  and  assignments  that  you need can  be  kept  in  this 
procedure.  All  the array dimensioning and initial  file  loading 
should be here as well. The final command in this procedure is the 
counter_on  command,  it  starts the 50Hz frame  counter  that  is 
required by the swap_sync command. If you do not start the counter 
then  the swap_sync command will freeze the program and you  won't 
be able to exit !

     PROCEDURE reset
       ~C:counter_off%()
       ~XBIOS(5,L:real%,L:real%,res|)
       restore_palette
     RETURN

It  is the job of the reset procedure to reset all  the  interrupt 
driven routines,  restore the original screen address,  resolution 
and palette.

     PROCEDURE error
       reset
     RETURN

When an error occurs the reset procedure is called and the program 
exits.  If you are in GFA then you should get an error report, but 
if you have compiled the code then you will get an error code. You 
may wish to add the line PRINT ERR$(ERR) and set errors on (E$) in 
the  compiler so that a description of the error is  printed  when 
the program crashes.

     PROCEDURE break
       reset
       END
     RETURN

The  break procedure does the same jop as the error procedure  but 
has an END statement to make sure the program actually stops !

2 Simplifying commands
 
GFA Basic does allow you to make new commands which do not need to 
be told whether parameters are words or long words.  Unfortunately 
these have to be linked at compile time, therefore you can not run 
the  commands  from the basic interpreter.  This  means  that  the 
commands  have  to  be loaded into  INLINE  statements.  The  dis-
advantage of this is that commands become 'messy' to use.
 
Take for example the mapper command, if this were a linked command 
it would be of the form :
 
     mapper(x,y,width,height,map%,gfx%,screen%)
 
But this command would only work once compiled,  however it  would 
not need the machine code routine loaded into an INLINE statement.
 
By  using  the INLINE statement the above command  is  transformed 
into the following:
 
     INLINE mapper%,834
     ~C:mapper%(x,y,width,height,L:map%,L:gfx%,L:screen%)
 
But there is a way to transform the commands into an easier  form. 
This is by defining a procedure which takes care of the long  word 
(L:)  definitions.  This also has the advantage of taking care  of 
the  parameters which do not change.  For the mapper  command  the 
only  parameters  which  change are the x,y  coordinates  and  the 
screen  address  (if  screen switching  is  used).  Therefore  the 
following procedure can be written :
 
     PROCEDURE mapper(VAR x,y,screen%)
       ~C:mapper%(x,y,20,12,L:map%,L:gfx%,L:screen%)
     RETURN
 
Now  all  you  do  when  you want to print  the  map  is  to  say, 
mapper(x,y,screen%) which is alot easier to remember and tidier to 
write. The VAR in the parameter line is used to tell the procedure 
to use the variables passed to it and not to create  new ones.

NOTE:  VAR only allows you to pass variable names and NOT physical 
values or strings. Passing a physical value will report an error.
 
For  more examples of this simplification check out  the  programs 
TEXT, TEXT_PRO and KOPY in the examples folder.
 
3 Using interrupts
 
There    are   eleven  commands  which  when  executed   set    up  
interrupts  which allow the commands to be  automatically  called, 
ten  of these must be switched  off before the program exits  (the 
exception  is  FADE_TO which automatically switches  itself  off).  
These commands are the mouse controller, joystick controller, chip 
music player,  sample player,  palette  switcher,  rasters,  frame 
counter, border removal, screen splitter and protracker player.
 
The  commands should ideally be switched off in the reverse  order 
that  they were switched on.  This is certainly the case with  the 
sample player,  frame counter and border commands which patch into 
the  VBL interrupt at location $70.  If the commands are  switched 
off in the wrong order then you may end up crashing the computer.

The  frame  counter is compatible with the sample player  and  the 
border  commands,  but if you want the latter two to run  together 
then make sure that you use SAMPLAY+.  See SAMPLAY+ in the  manual 
for more details. 

NOTE:  It  doesn't matter if you call a command to switch  off  an 
interrupt that hasn't been set as it will simply ignore it.

All  of  the commands use the VBL interrupt (of  which  there  are 
several)  to execute themselves.  The highest priority  interrupt, 
the one which gets executed first,  is pointed to by the value  in 
location  $70.  This is the interrupt used by the  sample  player, 
frame counter,  protracker and border removal commands.  The  next 
set  of  interrupts  come in the form of the  VBL  list  which  is 
between  locations  $4CE and $4EA.  Generally  the  location  $4CE 
points to the routine which handles the GEM mouse pointer, this is 
the  first routine to be executed in the VBL list.  The  interrupt 
commands use the following entries :

     Location  Command
     
     $4CE      Palette switcher/Rasters (Normally GEM mouse)
     $4D2      Joystick/Mouse controller
     $4D6      Free
     $4DA      Chip music players
     $4DE      Palette fader
     $4E2      Free
     $4E6      Free
     $4EA      Palette switcher/Rasters

You  will see that the palette switcher and rasters  actually  use 
two  locations,  $4CE  and $4EA.  The palette switcher  or  raster 
routine is at $4CE and the mouse routine that was originally there 
is moved to the last entry, $4EA. This stops the mouse interfering 
with the timing because it is executed after the palette  switcher 
or raster routines have finished. 

Those Sprite Works commands that have no parameters can be  placed 
in  the  free  locations  of  the  VBL  list  and  they  will   be 
automatically  called every 50th of a second.  See the BANNER  and 
BIG_BAN programs for an example.

NOTE:  Some resident programs such as software screen accelerators 
or  accessories may use some of the VBL list entries.  If  one  of 
these  entries is written over it may switch of the routine or  at 
worst  crash  the computer.  Generally it is best to work  with  a 
'clean' system free of any resident programs or accessories. There 
are a number of programs in the PD that allow you to check whether 
any programs are using system vectors such as PROFILE or SYSINFO.
 
The sound sample commands :  SAMPLAY,  SAMPLAY+ and PROTRACKER all 
require the Sprite Works mouse command if the mouse is to be used. 
The  normal  mouse  controller  will interfere  to  much  the  the 
critical timing of the commands. 

The  higher  priority  interrupt  commands  :   palette  switcher, 
rasters,  border removal and the above sound sample all require  a 
slightly more careful setup.  The command that is called last will 
be the first executed. The sample commands will switch off many of 
the interrupts, therefore these should be called BEFORE the border 
removal, palette switcher and raster commands.

NOTE:  There  is a special condition when  using  samples,  border 
removal and palette switching. You should call the commands in the 
order,   samples,   borders  then  palette  switcher.  If  palette 
switching occures on lines 226-229 then it will interfere with the 
border  command and you will lose your lower border.  There is  no 
solution  to this except that you must make sure that the  palette 
switch never occurs between lines 226-229. 

The  screen  splitting command for STE hardware is the  most  time 
critical  of  all the commands.  As it actually writes  new  video 
addresses,  screen  variables and changes the palette all  on  one 
scan line it is very susceptible to 'glitching' which most of  the 
time  causes the lower portion of the screen to  shake.  To  avoid 
this  happening  make sure that you have no resident  programs  or 
accessories  which  may  be  patching  themselves  in  to  certain 
interrupts  and use the Sprite Works joystick and mouse  commands. 
Also, don't worry to much if it glitches only occasionally as this 
is  probably GFA interefering with it and when compiled it  should 
be fine.

4 Printing with screen switching
 
One problem that you will notice with screen switching is that the 
computer  will  often  print/draw on the  wrong  screen.  Any  GEM 
command  such  as PRINT,  LINE,  DRAW,  GET or PUT will  take  the 
current  screen  from the location $44E which is part of  the  STs 
system variables.  Before you use any of these commands you should 
put  the  screen address into location $44E by using a  long  poke 
which must be in supervisor mode as it is in a restricted area  of 
memory.
 
Therefore  to print a box on the background screen you  would  use 
the following:
 
     SLPOKE $44e,back%
     BOX .......
 
You  may  need to update the graphics on both the  background  and 
foreground  screens if the graphics are not  continually  updated. 
If,  for  example,  you were printing your score using  the  basic 
PRINT  command only when the score is changed then you would  need 
to write the following :
 
     SLPOKE $44e,back%
     PRINT  .....              ! Draw on back screen
     SLPOKE $44e,fore%
     PRINT  .....              ! And on current screen
 
If  however,  you were printing the score every time  around  your 
game loop then you will only need print on the background screen.

-------------------------------------------------------------------
 
USING SPRITES                                                     3
 
There  are  two forms of printing sprites,  one is to  print  each 
sprite  in turn without saving the background and the other is  to 
print all the sprites in one go while handling the erasing of  the 
last printed sprites.
 
If  your game continually updates the background such as with  the 
mapper  commands  then  the  sprites will be  erased  by  the  map 
printing commands. This means that the sprites do not need to have 
the background saved and so each sprite can be printed  separately 
and do not need a sprite handler. If however the background is not 
continually updated then a sprite handler must be used.
 
1) Using the sprite handler
 
The sprite handler commands are the hardest to understand,  mainly 
because  there are so many parameters to the sprite  records.  The 
records  (one per sprite) are 26 bytes long and contain the  mode, 
graphics pointer,  frame,  x, y, width, height, size and two erase 
buffer pointers.  In the SPRITES.GFA example there are a number of 
procedures  to help with maintaining sprites (the same  procedures 
are also in SPRITES.LST).  These do not have to be used,  but  are 
provided to make your life alot easier when first using sprites.
  
     PROCEDURE setup_sprites
       nspr=5
       DIM records|(26*nspr)
       records%=V:records|(0)
       DIM sb|(1552*nspr)
       sprite_buffer%=V:sb|(0)
       '
       setup_sprite( See below )
       '
       buffer_size%=sprite_buffer%-V:sb|(0)
     RETURN

Call this procedure at the beginning of your program to initialise 
buffer  space  for your sprites and to set the  records  for  each 
sprite.  The  maximum number of sprites that you will be using  at 
one  time  is defined by the variable nspr.  By default  a  buffer 
space  of  1552  bytes is allocated  to  every  sprite,  which  is 
equivalent to a 32x32 sprite. When the procedure has been executed 
the  variable  buffer_size% holds the actual size  of  the  buffer 
used,  if this size is different to that already stated in the DIM 
statement  then  you can insert your own value to  save  a  little 
extra memory.

     PROCEDURE set_sprite(sprite,mode,graphics,width,height)
       LOCAL width,size,o%,erase%
       o%=records%+(sprite*26)
       IF width=16
         width=0
         size=10*height
         erase%=(16*height)+8
       ELSE
         width=1
         size=20*height
         erase%=(24*height)+8
       ENDIF
       DPOKE o%,mode
       LPOKE o%+2,graphics
       DPOKE o%+12,width
       DPOKE o%+14,height
       DPOKE o%+16,size
       LPOKE o%+18,sprite_buffer%
       ADD sprite_buffer%,erase%
       LPOKE o%+22,sprite_buffer%
       ADD sprite_buffer%,erase%
     RETURN
      
This  is  the  routine which is called  within  the  setup_sprites 
procedure.  You supply the sprite number,  the mode,  which is the 
default   to  whether  the sprite is switched on  or  off  (1 &  0 
respectively),  the address  of the sprite graphics and the  width 
and  height of the sprite.   This address will either be  the  16x 
sprite bank or the 32x sprite bank. As you can see, this procedure 
takes care of calculating how much memory each sprite uses and how 
much of the sprite buffer to use.
 
     PROCEDURE sprite_on(number)
       LOCAL o%
       o%=ADD(records%,MUL(number,26))
       DPOKE o%,1
     RETURN

This  procedure switches the specified sprite mode on so  that  it 
will be printed by the print_sprites command. 
 
     PROCEDURE sprite_off(number)
       LOCAL o%
       o%=ADD(records%,MUL(number,26))
       DPOKE o%,0
     RETURN

Switches  the  specified sprite mode off so that it  will  not  be 
printed by the print_sprites command.
 
     PROCEDURE sprite(number,frame,x,y)
       LOCAL o%
       o%=ADD(records%,MUL(number,26))
       DPOKE ADD(o%,6),frame
       DPOKE ADD(o%,8),x
       DPOKE ADD(o%,10),y
     RETURN
           
Sets the specified sprites frame and x/y coordinates.
 
     PROCEDURE get_xy(number,VAR x,y)
       LOCAL o% 
       o%=ADD(records%,MUL(number,26))
       x=DPEEK(ADD(o%,8))
       y=DPEEK(ADD(o%,10))
     RETURN
     
Gets   the sprites x and y coordinates.   The values are  returned  
in  the  variables x and y,  these are the values  passed  to  the 
procedure and NOT new variable.  Eg, get_xy(1,a,b) will return the 
x and y coords of sprite 1 in variables a and b respectively.
 
     PROCEDURE get_frame(number,VAR frame)
       LOCAL o%
       o%=ADD(records%,MUL(number,26))
       frame=DPEEK(ADD(o%,6))
     RETURN

Returns  the sprites frame number in the variable frame.  As  with 
the last procedure,  the variable frame is the variable passed  to 
the procedure,  not a new one.  Eg, get_frame(2,f) will return the 
frame of sprite 2 in variable f.
 
     PROCEDURE clear_sprite(number)
       LOCAL o%
       o%=ADD(records%,MUL(number,26))
       DPOKE LPEEK(ADD(o%,18)),0
       DPOKE LPEEK(ADD(o%,22)),0
     RETURN

If you change the background while printing then you must use this 
command  to  clear  the erase buffers otherwise  the  sprite  will 
replace the wrong graphics when erased.
 
When  you come to using the sprite handler commands you will  need 
to lay your program out in the following manner :
 
     REPEAT
        swap_screens
        ~C:erase_sprites(nspr,L:records%)
        '
        ' program control
        '
        ~C:print_sprites(nspr,L:records%,L:back%)
     UNTIL finished
 
This shows the main game loop,  the screen must be swapped  before 
the sprites are erased and printed otherwise the sprites will  not 
be correctly erased (try it and see !).  The erase_sprites command 
should  be used straight after the swap_screens which then  allows 
you to change any of the background graphics without it corrupting 
the sprite commands.
 
NOTE:  You   must  have  only ONE erase_sprites  command  and  ONE 
print_sprites command.  Also do not change the number nspr as  the 
game is playing,  but instead allocate a maximum number of sprites 
when you call setup_sprites then simply switch the sprites on  and 
off when needed. If you do change nspr as the game is running then 
it  is  likely that some corruption will be left behind  when  the 
sprites are erased.
 
2) Non-erasable sprites
 
The  easiest sprites to use as they require no setting up at  all. 
Simple call the print_sprite command with the frame,  x, y, width, 
height, graphics address and screen address. These are used in the 
example games PLATFORM and RACER as the background is  continually 
redrawn, thus erasing the old sprites.
 
The print_sprite command is also faster than the sprite handler as 
the  handler  wastes  time  in saving  the  background  ready  for 
erasing.

A typical game loop will look like the following :

      REPEAT
        swap_screens
        print background
        '
        ' program control
        '
        print sprites
     UNTIL finished

Unlike the last example game loop,  it doesn't matter too much  on 
the  order  that  the commands  are  carried  out.  Generally  the 
swap_screens will be followed by redrawing the  background,  which 
may  consist of the mapper or v_mapper commands.  The sprites  are 
then  printed  individually,  in any order,  by  the  print_sprite 
command.

You can set a clipping window for these sprites and for the sprite 
handler with the clip_sprites command.  Simply supply the  minimum 
x, y and the maximum x, y pixel coordinates. The minimum x must be 
divisable by 16 and the maximum x divisable by 16 minus 1.
 
     ie, For full screen clipping
 
     ~C:clip_sprites%(0,0,319,199)
 
------------------------------------------------------------------
 
USING MAPS                                                       4
 
1) NON-SCROLLING MAPS
 
The first map  designer allows  you to design  screens up to 20x12
made up of 16x16 blocks.   Each location of the screen is a 16 bit 
word value, the top 6 bits are the flag bits and the lower 10 bits
are the block number.  This theoretically allows you  up  to  1024 
sprites although the map designer will only take up to 720.
 
Non-scrolling  maps have the advantage of using relatively  little 
memory  and  are ideal when a large number of screens  are  needed 
within  a  map,  such as a puzzle game with each  screen  being  a 
level.
 
The  flag bits are used to give attributes to a map  location,  in 
the example game SLUG BLAST,  two bits are used to make a location 
solid  or semi-solid.  A solid location can be  walked  upon,  and 
cannot be walked into or fired through.  A semi-solid location can 
be walked upon and can also be walked and fired through.  How  you 
use the flag bits is completely up to you and you may want to  add 
attributes such as locations which are climbable, icy or killer.
 
Given an x and y pixel coordinate you will want to find out  which 
flags the corresponding map location has. To find the map location 
you can use the locate command,  when you supply the  x,y,  screen 
number and map data address it will return the address of the  map 
location that the x/y pixel lies on.
 
     Eg. var%=C:locate%(x,y,screen number,L:map)
 
The variable var% will now point to the location, this can then be 
read to find the sprite number and flags.
 
     Eg. bits%=DPEEK(var%)          ! Read map location
         sprite%=bits% AND $3FF     ! Leave bits 0-9, block number
         flags%=bits% AND $FC00     ! Leave bits 10-15, flags

     (Speed tip: Instead of DPEEK use bits%=WORD{var%})
 
By  writing  back to this location with DPOKE you can  change  the 
sprite or the flags.
 
The  flag bits can be tested by using AND or BTST,  the  following 
example shows how these are used in the SLUG BLAST game.
 
     A solid location has bit 10 set ($400 hex). By supplying
     the x/y coords from below the players feet we can call
     locate to get the address of the map location then test
     bit 10 to see if the block is solid.
 
     location%=C:locate%(px,py+32,screen,L:map%)
     flags%=DPEEK(location%) AND $FC00
 
     IF BTST(flags%,10)=-1
          STANDING ON SOLID
     ELSE
          NOT STANDING ON SOLID, ACTIVATE FALLING
     ENDIF
 
     alternatively,
 
     IF (flags% AND $400)>0
          STANDING ON SOLID
     ELSE
          NOT STANDING ON SOLID, ACTIVATE FALLING
     ENDIF
        
In  the game SLUG BLAST,  six map locations are calculated  around 
the  player  at the head,  middle and feet on the left  and  right 
sides.  Should  the player move slightly off the screen  then  the 
corresponding  values  are  set  to  zero  which  avoids   reading 
incorrect values.
 
The  example  game only calls the print_map command  whenever  the 
players enters a new screen,  for this reason the sprites must  be 
erased  by the sprite handler before they are  reprinted.  If  you 
wanted  background  animation,  say flickering  lights  or  moving 
platforms,   then you would change the corresponding block  sprite 
numbers  of  the map locations you wish to animate and  call   the  
print_map command  each time around the game loop.  This will mean 
that  the whole  screen  will  be  reprinted,   thus  erasing  the  
sprites,  therefore  the  sprite handler is not  needed.   As  the 
sprite  handler needs alot of setting up and memory  reserved  for 
the  erase  buffers  it will be more advantageous  to  print  each 
sprite  separately  using print_sprite which is  faster  than  the 
print_sprites routine.
 
2) SCROLLING MAPS
 
Scrolling maps take up over twice the memory of non-scrolling maps 
but  have the advantage of being faster,  ideal for action  games. 
Unlike  the non-scrolling map,  only one map can be handled  at  a 
time  but  can be as large as memory may  permit.  Flags  are  not 
contained within the map data as all 16 bits are needed, therefore 
flags are given a separate file with each byte relating to a  four 
byte  map location.   This allows 8 flag bits which lets you  give 
attributes  to each map location.  In the racing game there are  6 
flag bits used :   Mud,   Flag, Gas, Finish, Killer and Marker and 
in the platform game only two flags are used : Solid and Token.
 
Maps  designed  with the second map designer can be  printed  with 
either   MAPPER,   V_MAPPER  or  STE_MAPPER  commands.   The  only 
difference  is  that the MAPPER command needs a different  set  of 
preshifted  graphics.  The  vertical map printer can actually give 
horizontal   scrolling,  although it will be 16 pixel scrolling  !  
Far  to jerky for scroll-as-you-move  type  maps,   but ideal  for 
burst scrolling  when  you reach the edge of the screen,  a method 
which the game Cannon Fodder uses.
 
Both  commands will normally be called each time around  the  game 
loop  which  means that any sprites will continually  get  erased, 
therefore  no sprite handler is needed.  This also allows  you  to 
create background animation by changing the map location sprites.
 
You  can change the map location by using the  command  change_map 
which takes the x,y coordinate in pixels,  the new sprite and  the 
address of the map data.
 
  Example. At pixel location 160,80 of a map is a graphic of an
           off switch, sprite number 14. You want to change the
           switch to an on type, sprite number 15.
 
           ~C:change_map%(160,80,15,L:map%)
 
In  the  example  game PLATFORM this command is  used  to  replace 
collectable  tokens with a piece of wall and in the game RACER  it 
is used to replace flags and gas by a piece of track.
 
To  find  the  flags for a given x and y  coordinate  the  command 
locate_flag  is  used.  Similar  to the locate  command  for  non-
scrolling maps,  it takes the x,y pixel coordinate, the address of 
the  map  data and the address of the flag data.  It  returns  the 
address of the map location flags which can be read or written too 
with PEEK or POKE.
 
  Example. The platform game checks the flags for a collectable
           token and if found resets the flag and changes the
           map location sprite to a wall. The TOKEN bit is the
           2nd flag bit.
 
     ' First get flag address of location near players waist   
     flag_location%=C:locate_flag%(px,py+24,L:map%,L:flags%)
     flags=PEEK(flag_location%)                 ! Read flags
     IF (flags AND 2)>0                         ! Test TOKEN bit
         POKE flag_location%,0                  ! Reset TOKEN bit
         ~C:change_map%(px,py+24,11,L:map%)     ! Change into wall
     ENDIF

There  are  three  ways  in which  you  can  change  graphics  for 
animation purposes.  Two methods are by changing the map locations 
to  point  to different sprite blocks and the third method  is  to 
change the actual graphics data.

Method 1 :  If you only require to change one or two graphics then 
you can use the change_map command. This method was just mentioned 
to  change a graphic of a switch from off to on.  This is  not  so 
much for animation but for one off changes,  making things  appear 
or disappear on the map.

Method  2 :  If you have a number of graphics that you  constantly 
want animated then use the animate_map command.  The advantage  of 
this command is that once set up it can handle complex  animations 
of any length of sprite blocks and at any speed.

Method 3 : If some cases you may have hundreds of map locations to 
animate  but the actual block number is common to all of  the.  In 
this  case it is much faster to actually shift the  graphics  data 
around  so  there are no changes made to the  map  data.  As  each 
graphic block uses 128 bytes we can easily calculate the  position 
of any sprite block.  Say for example we have a platform game with 
lots of spinning coins, moving conveyor belts and flashing lights. 
Each  object  has  a  key block  number  which  is  the  currently 
displayed block on the map and a range of blocks which are  copied 
to the key block in turn.  You can find an example of this in  the 
example game in the SOURCE\PLATFORM folder.

------------------------------------------------------------------
 
USING SAMPLES AND PROTRACKER                                     5
 
The sample playing command has the big advantage of using far less 
processor   time  than  most  other  sample   players,   but   the 
disadvantage of overshooting the end of the sample. The reason for 
this  is  that  the sample player only checks to  see  if  it  has 
finished the sample every 1/50th of a second. If you are playing a 
sample  at  7.5  KHz then the sample will have  played  150  bytes 
during  1/50th of a second.  If the sample does overshoot then  it 
will  probably 'click',  to avoid this you can pad out the end  of 
the  sample  with a number of zeroes (150 in  this  case).  For  a 
sample  being played at just 2.5 KHz then you should only need  an 
extra  50  bytes,  but  a sample at 15 KHz will  need  300  bytes. 
Alternatively  you can pass the sample length with the  number  of 
bytes already subtracted from it.
 
The maximum number of bytes that a sample can overshoot by is:

     frequency/50 bytes

The  sample  player is for playing signed  samples,  if  a  sample 
sounds distorted it is probably an unsigned sample. If this is the 
case use the sam_convert command to change the sample,  this is  a 
non-destructive  convertion  and if called twice will  return  the 
sample to its original condition.

The  protracker player has full compatibility  with  non-interrupt 
Sprite  Works commands and some interrupt  commands.  Only  higher 
priority  interrupts such as rasters,  border removal  and  screen 
splitter  can  not be used.  Remember that the ST  playback  takes 
slightly more CPU time than the STE playback so if you are writing 
something on the STE you must remember that if you want it to  run 
on  an  ST then the maximum frequency should  not  exceed  14.5kHz 
otherwise the computer will lock-up.

Generally  the protracker is intended to be used on title  screens 
where  only keyboard or mouse monitoring is used with  maybe  some 
graphics changing on the screen.  With a frequency of around 12kHz 
you  can  do this with no problems.  However should you  which  to 
actually play music in-game then much lower frequencies of  6-9Khz 
should be used, even then it is best that this is limited to games 
which are not very CPU hungry,  such as puzzle games. If the music 
module has very 'clean' samples then even playing something as low 
as 6kHz on the STE can sound exceptable (not the ST !).

In  the protracker examples a fade_out_module procedure  has  been 
included which reduces the volumes of each channel by brute force. 
If  the  frequency  is above 12kHz you may  find  that  it  sounds 
strange  as  it  fades out because the volumes are  reset  by  the 
protracker player before GFA has time to write over them.

Sometimes  you  may  find a module that  doesn't  play  which  may 
possibly  be because it has a slightly different format.  In  this 
case  you should load the file into a protracker editor and  check 
that  it plays OK.  If it does then resave the music file and  you 
should find that it now plays.

------------------------------------------------------------------
 
USING BIOS, XBIOS AND GEMDOS                                     6

1) Useful Commands
 
There  are many shortcuts and useful commands that are already  in 
the ST ROM.   These come in the form of the BIOS, XBIOS and GEMDOS 
commands. Here is a list of some of the best commands :

GET KEYBOARD STATUS
status%=GEMDOS(11)

Returns 0 if there is no character, -1 if a character is waiting.

If  you are in a loop which reads the mouse and keyboard then  the 
mouse  will  flicker.  By using this command you  don't  read  the 
keyboard  until  the  command returns -1,  that  way  you  get  no 
flicker.
 
GET DEFAULT DRIVE NUMBER
drive%=GEMDOS(25)
 
Returns 0 for drive A, 1 for drive B, etc

GET INPUT DEVICE STATUS 
status%=BIOS(1,dev)

Returns 0 is no character is waiting,  -1 if character is waiting. 
dev=1 for RS-232, 2 for keyboard, 3 for MIDI.

READ A CHARACTER FROM DEVICE
char%=BIOS(2,dev)

Returns character from device. dev=1 for RS-232, 2 for keyboard, 3 
for MIDI.

WRITE A CHARACTER TO DEVICE
~BIOS(3,dev,char)

Writes character char to device dev.  dev=0 for printer, 1 for RS-
232, 2 for screen, 3 for MIDI, 4 for keyboard controlelr.

READ/WRITE DISK SECTORS
status%=BIOS(4,mode,L:buffer%,sectors,start,drive)

mode=0 for read,  1 for write. buffer%=pointer to 512 byte buffer. 
sectors=number  of  sectors to  write/write.  start=first  sector. 
drive=0 for drive A, 1 for drive B, etc.

Returns 0 for no error, otherise GEMDOS error code.

GET OUTPUT DEVICE STATUS
status%=BIOS(8,dev)

Returns  device  status,  0  for  no  character  waiting,  -1  for 
character waiting.  dev=0 for printer, 1 for RS-232, 2 for screen, 
3 for MIDI, 4 for keyboard controller.

GET MEDIA CHANGE STATUS
status%=BIOS(9,dev)

Returns  0=disk  definitely  changed,  1 for disk  might  of  been 
changed,  2 for disk definitely not changed.  dev=0 for drive A, 1 
for drive B, etc.

FIND VALID DRIVE NUMBERS
drives%=BIOS(10)

Returns  attached drives as bit settings,  bit 0 set for  drive  A 
attached, bit 1 set for drive B attached, etc.

READ/CHANGE KEYBOARD SHIFT STATUS
code%=BIOS(11,mode)

If  mode is positive then the appropriate bit is set,  if mode  is 
negative then the current settings are read. Bit 0 for right shift 
key,  bit 1 for left shift key,  bit 2 for control key,  bit 3 for 
alternate key and bit 4 for caps lock on.

     Eg, To turn on caps lock, ~BIOS(11,16)

GET PHYSICAL SCREEN ADDRESS
physical%=XBIOS(2)

Returns the physical screen address,  the screen that is currently 
being viewed.

GET LOGICAL SCREEN ADDRESS
logical%=XBIOS(3)

Returns the logical screen address, the screen that GEM draws on.

GET RESOLUTION MODE
res=XBIOS(4)

Returns the current graphics resolution,  0 for low resolution,  1 
for medium resolution and 2 for high resolution.

SET SCREEN PARAMETERS
~XBIOS(5,L:logical%,L:physical%,res)

Sets  the  logical  and physical screen  addresses  and  also  the 
resolution.  A  -1  in any of the parameters  leaves  the  current 
setting unchanged.

SET COLOUR PALETTE
~XBIOS(6,L:palette%)

Sets the colour palette. Sixteen word entries, bits 0-3 blue, bits 
4-7 green and bits 8-11 red.

SET COLOUR REGISTER
~XBIOS(7,register,colour)

Sets a single colour. Equivalent to SETCOLOR register,colour.

GET RANDOM NUMBER
random%=XBIOS(17)

Returns a 24 bit random number.

CONFIGURE TEXT CURSOR
rate=XBIOS(21,mode,newrate)

mode=0  to turn cursor off,  1 to turn cursor on,  2 turns  cursor 
blink off,  3 turns cursor blink on,  4 set blink rate to  newrate 
and 5 reads the current blink rate and store it in rate.

SET SYSTEM TIME AND DATE
~XBIOS(22,L:datetime%)

Of the datetime% variable, bits 0-4 are the seconds, divided by 2, 
bits 5-10 the minutes,  bits 11-15 the hour,  bits 16-20 the  day, 
bits 21-24 the month and bits 25-31 the year-1980.

GET SYSTEM TIME AND DATE
datetime%=XBIOS(23)

Reads the time and date settings, see previous XBIOS for format.

SET KEYBOARD REPEAT RATE
~XBIOS(35,delay,rate)

rate  sets  the time between key repeats,  each unit  indicates  a 
1/50th delay. delay is the inital delay time before the keys start 
to repeat, again the delay is in 1/50th of a second steps.

INPUT/OUTPUT CONSOLE CHARACTER
charin=GEMDOS(6,charout)

Outputs an ascii value of 0-254 to the screen.  If an ascii  value 
of  255 is sent then the current key press is returned in  charin. 
If  a character is read in then the ascii code is in the low  word 
and  the scan code is in the high word.  Reading is equivalent  to 
the INKEY$ command.

KEYBOARD INPUT WITHOUT ECHO
key%=GEMDOS(8)

Waits  for a keypress then returns the ascii code in the low  word 
and the scan code in the high word.

GET KEYBOARD INPUT STATUS
status%=GEMDOS(11)

Returns  0 if there are no characters waiting or -1 if  there  are 
characters waiting.

SET DEFAULT DRIVE NUMBER
~GEMDOS(14,default)

Sets the default drive, 0 for drive A, 1 for drive B, etc.

GET PRINTER OUTPUT STATUS
status%=GEMDOS(17)

Returns  0  if the printer is not ready and -1 if the  printer  is 
ready to accept data.

GET DEFAULT DRIVE NUMBER
default=GEMDOS(25)

Returns the default drive, 0 for drive A, 1 for drive B, etc.

GET GEMDOS VERSION NUMBER
version=GEMDOS(48)

The major version is stored in the low byte and the minor  version 
is stored in the high byte.

2) Error Reports

BIOS ERRORS                   GEMDOS ERRORS

-0   OK                       -32  Invalid function number
-1   Error                    -33  File not found
-2   Drive not ready          -34  Path not found
-3   Unknown command          -35  No file handles available
-4   CRC Error                -36  Access denied
-5   Bad request              -37  Invalid handle
-6   Seek error               
-7   Unknown media            -39  Insufficient memory
-8   Sector not found         -40  Invalid memory block
-9   No paper                 
-10  Write fault              -46  Invalid drive
-11  Read fault               -47  No more files
-12  General mishap           
-13  Write protect            -64  Range error
-14  Media change             -65  Gemdos internal error
-15  Unknown device           -66  Not executable file
-16  Bad sectors              -67  Memory block growth failure
-17  Insert disk              

-------------------------------------------------------------------
 
WRITING YOUR OWN COMMANDS                                         7
 
There  are a number of ways in which GFA can call a  machine  code 
routine,  but  the  one that all my routines work with is  the  C: 
command.  You supply the routine address and a list of parameters, 
ie
     ~C:address%(x,y,z,L:x,L:y,L:z)
 
The parameters are words unless they are preceded by a L: in which 
case  they are a long word.  In the above example the stack  would 
look like this to the routine.
 
     (SP)      Return address (LONG)
     4(SP)     x (WORD)
     6(SP)     y (WORD)
     8(SP)     z (WORD)
     10(SP)    x (LONG)
     14(SP)    y (LONG)
     18(SP)    z (LONG)
 
It  is  always  best to save the registers  when  the  routine  is 
called,  only D0 does not need to be saved as it is used to return 
values  back  to GFA.  Therefore the start of your code  may  look 
like:
 
     MOVEM.L   D1-D7/A0-A6,-(SP)   Push 56 bytes on stack
     MOVE.W    60(SP),D0           Get first (word) parameter
     MOVE.W    62(SP),D1           Get second (word) parameter
     MOVE.L    64(SP),D2           Get third (long) parameter
     etc .....
     .
     .
     MOVEM.L    (SP)+,D1-D7/A0-A6   Restore register
     RTS                           Return to GFA
 
When you have written the routine you must save it in binary,  NOT 
executable.  If you are using DEVPAC then enter the debugger after 
compiling and press 's' for save binary,  then enter the  filename 
and  then  enter 'text,data-1' for the save addresses  which  will 
automatically save the whole routine.     
 
------------------------------------------------------------------
 
USING COMMANDS WITH 68000                                        8
 
If  you are an assembler writer then you will want to know how  to 
use the routines in 68000. *All of the routines can be found in the 
68000  directory and most are aptly commented.  The  routines  are 
used  exactly  as they are in GFA except that you  must  push  the 
arguments  onto the stack in reverse and correct the  stack  after 
calling the routine.  As an example,  take the text routine  which 
takes the arguments x,y,length,colour,L:text,L:font and  L:screen. 
This becomes :
 
     MOVE.L    #screen,-(SP)      pushed 4 bytes
     MOVE.L    #font,-(SP)               8 bytes
     MOVE.L    #text,-(SP)               12 bytes
     MOVE.W    #colour,-(SP)             14 bytes
     MOVE.W    #length,-(SP)             16 bytes
     MOVE.W    #y,-(SP)                  18 bytes
     MOVE.W    #x,-(SP)                  20 bytes
     BSR       text
     LEA       20(SP),SP          correct stack by adding 20 bytes
 
After  calling the routine only the register D0 may be  corrupted, 
all other registers will be unaltered.
 
When  correcting the stack after calling the routine use  ADDQ  if 
the stack is between 2-8 bytes out, otherwise use LEA as above.

All  the Sprite Works commands default to using  user  mode.  That 
means  that all the routines that need supervisor mode calls  will 
change into supervisor mode and then back to user mode at the end. 
So if your assembly program is in supervisor mode to start with it 
will  lead  you  into problems !  The solution is  either  to  put 
yourself  in supervisor mode after calling the routines  and  then 
back   to  user  mode  before  switching  the  routines   off   or 
alternatively you can simply edit the routine sources to take  out 
all of the supervisor/user set up calls.

*NOTE:  Only the protracker source has not been given. If you want 
to include this in your assembly program then use INCBIN.

------------------------------------------------------------------
 
THE SCREEN LAYOUT                                                9
 
The  ST has a screen display of 32000 bytes for  low,  medium  and 
high  resolutions.  Both  low  and  medium  resolutions  have  200 
vertical lines, making each line use 160 bytes of memory.

The  low resolution screen is made from a number of bit planes  or 
layers.  Sixteen colours are available in low resolution which  is 
defined by the number of bit planes available. Four bit planes are 
available  in this case,  each plane defining one bit  of  colour. 
However,  the method of defining a single pixel of colour is maybe 
not how you would of imagined it ...

The  display is contructed from words,  which define 16 pixels  on 
ONE bit plane.  The first word defines the first 16 pixels  (0-15) 
on bit plane 1, the second word defines the first 16 pixels on bit 
plane 2, the third word defines the first 16 pixels on bit plane 3 
and the forth word defines the first 16 pixels on bit plane 4. The 
fifth word then defines the second set of 16 pixels (16-31) on bit 
plane 1, and so on.

The layout for one line looks like this :

          Word Offset  Pixels Plane

           0     0      0-15    1
           1     2      0-15    2
           2     4      0-15    3
           3     6      0-15    4
           4     8     16-31    1
           5     10    16-31    2
           6     12    16-31    3
           7     14    16-31    4
           8     16    32-63    1
           9     18    32-63    2
           .     .       .      .
           .     .       .      .
           76    152  304-319   1
           77    154  304-319   2
           78    156  304-319   3
           79    158  304-319   4

Most people commonly think that because each line is 160 bytes and 
the  horizontal  resolution is 320 pixels,  then  each  byte  must 
represent  two  pixels.  Whereas this may seem  more  logical,  in 
practise  the method used is much more versatile.  The use of  bit 
planes allows you to set 16 pixels on one bit plane with a  single 
word  instruction,  or  on  two planes with  a  single  long  word 
instruction.  I  don't  think that a single demo  has  every  been 
written without using the properties of bit planes. Take a look at 
the  KOPY_2.GFA example to show what can easily be  achieved  with 
bit  plane manipulation.  In the example it shows that  simply  by 
adding two to the screen address each time it is possible to print 
graphics on the next bit plane. The example uses three bit planes, 
the forth has been left for you to fill !

There  is a command called CLR_PLANES in the extension  kit  which 
will allow you to clear specific bit planes.  The parallax and  3D 
star  routines both print stars on only the first two bit  planes, 
and so by clearing only those bit planes, any graphics data on bit 
planes three and four will be unaffected.  Remember that bit plane 
one corresponds to the first bit of the colour information,  so to 
tell the CLR_PLANES command to clear planes one and two, the value 
used by the command will be %0011 (binary) or 3 (decimal).

The address of the screen display can also be altered which allows 
you  to achieve the screen switching technique by  displaying  one 
screen while all drawing occurs on the second screen.  The address 
can  then  be  changed  on the  VBL  causing  an  instant  change, 
producing flicker free graphics movement.  The screen address  has 
limitations though,  it cannot display a screen anywhere in memory 
but  can  only  display on a 256 bytes boundary  (except  for  STE 
owners !).  The reason the screen has to be on a 256 byte boundary 
is  because  only two hardware registers are used  to  define  the 
screen address,  the high byte and the medium byte and no low byte 
is used.  On a 512k machine the screen is usually found at  $78000 
and on a 1024k machine at $F8000.

When using the map printing command they will default to print  in 
the  top left of the screen.  To adjust the vertical position  you 
simply add 160 to the screen address for every line and to  adjust 
the  horizontal  position you must add 8 for every 16  pixels  you 
want to move.  After printing the screen address should be set  to 
their original values.

     Eg,  REPEAT
            swap_screens
            ADD back%,2568
            ADD fore%,2568
            '
            ' all printing carried out here
            '
            SUB back%,2568
            SUB fore%,2568
          UNTIL finished

This  example  shows how to offset all the printing by  16  pixels 
horizontally  and  16  pixels vertically.  Note  that  the  screen 
addresses  are  alterered  AFTER  the  screen  swapping  and  then 
returned to their original values BEFORE the next screen swap. 

------------------------------------------------------------------

STE COMMANDS                                                    10

There  are  several  commands  that are for  the  STE  which  take 
advantage of the blitter chip, hardware scrolling and DMA sound.

If  you intend to use any of theses routines then you  must  first 
check  at the start of the program that it is being run on an  STE 
machine.  There are two versions of doing this,  one is to use the 
GFA command STE? or you can use the next few lines of code.

     vl=PEEK(&HFF820D)             ! Read video register
     SPOKE &HFF820D,vl XOR 255     ! Invert all the bits
     IF PEEK(&HFF820D)=vl          ! Check if it changed
       ste=0                       ! No
     ELSE
       ste=-1                      ! Yes
       SPOKE &HFF820D,vl           ! Restore video register
     ENDIF

This takes advantage of the fact the on STE hardware you can write 
values  to the video address register.  The first few  lines  here 
write a value to the low byte of the video address register, which 
STs do not have. If this value is changed then the variable ste is 
set  to  -1  (TRUE)  and  resets  the  register  to  its  original 
condition.  Older versions of GFA do not have the STE? command and 
so  this  will have to be used,  also I am not sure  whether  STE? 
would return TRUE if used on a Falcon.  As the STE commands can be 
used on a Falcon then the above routine should be used anyway.

Blitter misconceptions
----------------------

I  could  use a four letter word to describe what I think  of  the 
blitter chip ... crap ! Atari had the potential of creating a true 
graphics engine for the ST, so what did they do ? All they did was 
encode the existing software blitter into hardware with hardly any 
speed improvements.  The blitter is certainly not as fast as  many 
people would think,  it is only a few percent faster than using  a 
software blit routine.  The blitter is only useful for large areas 
of  block manipulation and for sprite sized graphics it is  slower 
then  a dedicated routine written in machine (as with many  Sprite 
Works  commands).  The  only  thing the blitter can  do  which  is 
remotely  useful  is  run  in  parallel  with  the   68000,   thus 
'appearing' to be extremely quick.  However, Sprite Works does not 
exploit  this  as it interferes with the critical  timing  of  the 
screen  splitter  command and in other cases would result  in  the 
programmer getting confused with the parallel processing aspect.

Hardware scrolling
------------------

In  my opinion the hardware scrolling feature of the STE  is  it's 
most  impressive  feature.   The  scrolling  is  achieved  in  two 
sections,  changing  the screen address and offsetting  the  whole 
screen by a number of pixels.

The STE has an extra video display register,  a low byte which the 
ST  did  not have.  In the set_screens procedures in many  of  the 
example  files the line +255 AND &HFFFF00 can be seen  this  makes 
sure  that  a  screen is aligned on  a  256  byte  boundary,  thus 
removing the need of a low byte because it is always zero. The STE 
allows  you  to specify any screen address as long as it's  on  an 
even address.  Using these registers alone you can create vertical 
scrolling,  which was used to great effect in the STE pinball game 
OBSESSION.

However,   to  achieve  horizontal  scrolling  only  one  hardware 
register  is  really  needed which is  at  address  $FF8265.  This 
register  contains a value between 0-15 which is the pixel  offset 
of  the screen when it is physically  displayed.  Increasing  this 
value  causes  the  screen to scroll left.  To make  use  of  this 
register  you also need to use another register,  the  Over-Length 
Line  Width register at address $FF820F.  This register tells  the 
STE how many extra words there are on each line.  A normal ST line 
is 160 bytes width, but by changing this register you can create a 
'virtual  screen'  which  can be many times wider  than  a  normal 
screen.  The  SPLIT_SCREEN  command uses these registers  and  the 
previous video address registers to great effect,  and allows  you 
to  have two indepently moving pixel scrolling screens on  display 
at the same time.

DMA sound
---------

Again,  as with the blitter chip, Atari failed to come up with the 
goods.  They had the opportunity to include a decent  multichannel 
digital-to-analogue sound chip. Instead what the STE ended up with 
was  a  single  channel 8-bit sound  chip  with  limited  playback 
frequencies.  "But the STE has stereo sound,  so it has a left and 
right channel",  I hear you say.  Well not exactly, although there 
are  affectively two channels they cannot be  accessed  indepently 
unless you write your very own machine routine to do so. If I were 
a computer engineer working on the STE design,  the minimum  sound 
hardware  that I would of added would of been at least 4  indepent 
sound  channels each with it's own playback frequency and  volume, 
but hey, that's just my opinion !

The STE can only playback at speeds of 6.25kHz, 12.5kHz, 25kHz and 
50kHz in mono or stereo.  It plays signed samples,  which at least 
conforms  to  the standard notation of  samples,  made  from  byte 
values  of  -128 to +127 which represent a  negative  or  positive 
displacement  of  the speaker.  Stereo samples have the  left  and 
right channel bytes merged together in a single word, left channel 
in the high byte and right channel in the low byte.

DMA  sounds  have the huge advantage of using  no  processor  time 
and,  through alot of testing, appear not to interfere with any of 
the Sprite Works commands that use time critical interrupts.

Extended palette
----------------

The STE palette can be chosen from 4096 colours as opposed to  the 
STs 512 colours.  The gain in extra colours is because of the  use 
of an extra bit in the red,  green and blue colour  setting.  Each 
red,  green and blue setting now has 4 bits which means 16  shades 
of  each colour.  At location $FF8240+ are the word values of  the 
palette and can be DPOKEd to obtain the full range of colours.  On 
a normal ST the colour registers are laid out as follows:

                      Red  Green Blue
     $FF8240+  xxxx  x210  x210  x210

Each   x  represents  an  unused  bit,   numbers   represent   the 
significance of the bit within the red,  green or blue field (0 is 
the least significant bit).

On the STE they are as follows:

                      Red  Green Blue
     $FF8240+  xxxx  0321  0321  0321

The  0321  represents  the bit  sequence,  least  significant  bit 
followed by the most significant bit, then the next least and next 
least.  This  rather strange layout means that ST palettes  remain 
compatible  on the STE and vice-versa.  When setting  the  palette 
however, you must remember to shift the bits to the right with the 
least significant bit moving to the end.

     Eg, To set to a middle grey the red, green blue settings
         would be 7,7,7 decimal, %0111,%0111,%0111 binary.

         After shifting we end up with %1011,%1011,%1011 binary.
         In hexidecimal the value to SDPOKE would be $BBB.

         On a normal ST only three bits are significant and so the
         above would read %011,%011,%011 which as the ST has 8
         colour shades would still be a middle grey. So that's
         how palettes stay compatible.
 
