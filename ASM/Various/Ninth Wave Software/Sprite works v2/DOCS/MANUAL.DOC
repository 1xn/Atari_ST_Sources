      

                      Extension Kit Commands
                      ----------------------


The  following  is  a  detailed  breakdown  of  all  the  new  commands 
available. Each command is in a file with the extension .INL. These are 
intended  to  be loaded into INLINE statements  within  GFA  basic.  To 
include  the command in your program you simply type the line shown  in 
the  SETUP field then position the cursor on the INLINE  statement  and 
press HELP.  A menu will be displayed from which you can load the  .INL 
file which is stated in the FILE field.  INLINEs are used because  they 
form part of the program and so do not need to be loaded in, if however 
you  want to load them in separate then you will need to  reserve  some 
memory to load the command into it.

   Eg,  INLINE text%,444
        INLINE font%,760, will become ...

        DIM text|(444),font|(760)       ! Reserve memory
        text%=V:text|(0)                ! Define pointers
        font%=V:font|(0)
        BLOAD "TEXT.INL",text%          ! Load command
        BLOAD "FONT.DAT",font%          ! Load font

Note : You may have to use BLOAD as INLINE statements are limited to
       32746 bytes.

You  can of course rename the commands to whatever you  want,  but  make 
sure that you remember that you've changed the name of the command. Some 
commands require a LONG word passed to them which is signified by a  L:. 
Make sure that you remember to include the L:  otherwise it is likely to 
cause the command to crash.

All  of  the  commands  come with an  example  file,  so  if  you  don't 
understand a command then learn by example !

Most  of  the commands have a list file which may be merged  into  your 
program  to  provide the setup to the command.  The list files  can  be 
found in the INLINE folder


Extension kit overview
----------------------

        Command          Use
        
        animate_block    Set a map block for animation
        animate_clear    Clear animation entries
        animate_map      Animate map blocks
        backdrop         Fast one bit plane tile printer
        blit_clip        Clip window for blitter chip (BLITTER)
        blit_copy        Copy block using blitter chip (BLITTER)
        blit_get         Get block using blitter chip (BLITTER)
        blit_put         Put block using blitter chip (BLITTER)
        box              Replacement pbox command
        borders_on       Turn on top/bottom border removal
        borders_off      Turns off border removal
        box_hit          Box collision detection
        change_flag      Changes map location flags 
        change_map       Changes map location sprite
        chip_fx          Plays one of 75 sound chip effects
        chip_playing     Returns whether a chip sound is playing
        clip_draw        Set up clipping window for draw commands
        clip_explosion   Set up clipping window for explosions
        clip_kopy        Set up clipping window for kopy command
        clip_on          Turn on drawing clipping
        clip_off         Turn off drawing clipping
        clip_sprites     Set up clipping window for sprites
        clr_lines        Clear screen lines
        clr_planes       Clear selected screen bit planes
        cls              Fast clear screen
        compress         Degas Elite screen compressor
        copy_line        Copies screen lines
        copy_screen      Fast screen copy
        counter_on       Installs frame counter
        counter_off      Removes frame counter
        decompress       Degas Elite decompressor
        depack           Depacks ICE & AUTOMATION packers
        erase_sprites    Erase all sprites printed with print_sprites
        explode          Creates pixel explosion from screen graphics
        fade_to          Fades from current palette to new palette
        fade_to_black    Fades current palette to black
        fade_to_white    Fades current palette to white
        fast_invmask     Print preshifted inverted mask of sprite
        fast_mask        Print preshifted mask of sprite
        fast_sprite      Print preshifted sprite
        fuzz             Produces out-of-tune fuzzy TV effect
        get_flags        Gets the map location flags
        get_map          Gets the map location sprite
        h_wipe           Horizontal screen wipe
        install_rasters  Create raster colour bars
        joystick_on      Turns on new joystick controller
        joystick_off     Turns off joystick controller
        kopy             General purpose copy
        line             Replacement line command
        locate           Locates map address, use with print_map
        locate_flag      Locates map flag address
        mapper           Print multi-directional scrolling maps
        mem_fill         Fills memory will bytes
        mouse_on         Installs new mouse controller
        mouse_off        Removes new mouse controller
        move_parallax    Move parallax star field
        move_stars       Move 3D starfield
        music_off        Turns off soundchip music
        path_calc        Calculates bullet path
        path_kill        Kill bullet path
        path_state       Returns bullet status
        path_update      Update bullet position
        path_xy          Retrieve bullet x/y coordinate
        pixel_hit        Pixel collision detection
        play_bigalec     Play Big Alec soundchip music
        play_countzero   Play Count Zero soundchip music
        play_madmax      Play Mad Max soundchip music
        play_megatizer   Play Megatizer format music
        play_sentry      Play Sentry format music
        plot             Replacement plot command
        plot_explosion   Plot selected time frame of explosion
        plot_parallax    Plot parallax star field
        plot_stars       Plot 3D starfield
        print_invmask    Print sprites inverse mask
        print_map        Print a map screen
        print_mask       Print sprites mask
        print_sprite     Print single 16x or 32x sprite
        print_sprites    Sprite handler, prints sprites in one go
        reset_palettes   Removes palette switching
        reset_rasters    Remove raster effects
        reverse_lines    Copies screen lines in reverse
        sam_convert      Converts between signed/unsigned samples
        sam_play         Play sample using soundchip
        sam_playing      Returns whether a sample is playing
        sam_stop         Stops sample player
        sam_wait         Waits for sample to end
        scroll_banner    Updates the banner scroll
        set_banner       Sets up banner scroll
        set_mouse        Sets new mouse x,y and max x,y
        set_palettes     Installs palette switching
        set_rasters      Sets raster offset
        setup_parallax   Sets up 3 layer parallax stars
        setup_stars      Sets up 3D starfield
        shrink           Shrink sprites in real time
        split_screen     Dual screen hardware scroller/splitter (STE)
        ste_mapper       Fast multi-directional mapper command (STE)
        ste_playing      Check if DMA is playing sample (STE)
        ste_sample       Play a sample using DMA (STE)
        ste_sound        Set sound parameters on DMA (STE)
        store_kopy       Save block in kopy format
        store_sprite     Save block in sprite format
        swap_sync        Waits a number of frames and swap screens
        text             Print 40 column font
        text_pro         Proportional font text printer
        turn_onc         Turns on interrupt C - 200 Hz timer
        turn_offc        Turns off interrupt C
        unpack_spc       Unpack Spectrum 512 SPC format
        view_512         Displays spectrum 512 pictures
        v_mapper         Prints vertical scrolling maps
        v_wipe           Vertical screen wipe
        wait             Waits a number of frames

------------------------------------------------------------------------

FILE:       ANIM_MAP.INL
SETUP:      INLINE animate%,1438
            animate_block%=animate%
            animate_map%=animate%+4
            animate_clear%=animate%+8      
SYNTAX:     ~C:animate_block%(entry,x,y,first,last,start,speed,loop,L:map)
            ~C:animate_map%()
            ~C:animate_clear%(entry)
ARGUMENTS:
entry       (W) position in animation table 0-99
x/y         (W) x/y pixel position of block to animate
first       (W) first frame of animation
last        (W) last frame of animation
start       (W) start frame of animation
speed       (W) speed of animation
loop        (W) 0=loop off, 1=loop on
map         (L) pointer to map data

A  useful  command  for  use with  the  multidirectional  map  printing 
commands, it allows you to animate up to 100 blocks in a map. The block 
of  the map will start at the specified sprite,  increase to  the  last 
sprite then restart back at the first frame of animation if the loop is 
on.  If  the  loop is off then the animation will play  once  and  then 
cancel itself. To update the animation every time the routine is called 
a  speed of zero should be passed,  one for every other call,  two  for 
every third call,  etc. When calling ANIMATE_BLOCK an entry value of -1 
can  be  used and the next available table entry will be used  and  the 
position will be passed back if a variable is assigned to the  command, 
eg,

        entry&=C:animate_block%(..)

If the command was unable to allocate an entry then -1 is returned.

To  clear  any  entry the ANIMATE_CLEAR is used  which  will  stop  the 
animation of that entry.  By passing -1 to the command,  it will  clear 
all the entries.

If  you need alot of animation in your map then it may be  alot  easier 
and  faster to actually animate the graphics themselves instead of  the 
map  pointers  to the graphics.  In the example game  in  the  PLATFORM 
folder  a spinning ring is animated this way.  Each graphic block  uses 
128 bytes,  therefore if you know the block number you can simply shift 
blocks of graphics around to achieve the desired effect. In the case of 
the  spinning  ring  which is block number 72 there  are  6  frames  of 
animation  from block numbers 86 to 91.  By copying from each of  these 
blocks  in  turn  to  block 72 you can animate  all  of  the  (possible 
hundreds  of)  rings  that  appear  in the  map  with  a  single  BMOVE 
instruction. Here are the few lines that are used in the example game : 

        INC spin&
        IF spin&>5             ! spin sequence 0,1,2,3,4,5,0,1,.. 
          spin&=0
        ENDIF
        ' Now copy animation frame to block 72 (128 bytes)
        BMOVE gfx%+MUL(spin&+86,128),gfx%+MUL(72,128),128

------------------------------------------------------------------------

FILE:       BACKDROP.INL
SETUP:      INLINE backdrop%,250
SYNTAX:     ~C:backdrop%(x,y,L:gfx,L:screen)
ARGUMENTS:
x           (W) x offset within tile
y           (W) y offset within tile
gfx         (L) pointer to 32 32x32 tile blocks
screen      (L) screen address

A  special  effects  command  for printing a  fast  one  bitplane  tile 
backdrop.  The  whole  screen is filled with one bitplane  32x32  pixel 
blocks.  The  x offset gives an offset within the tile of between  0-31 
pixels, this is a frame number for the tile, thus 32 images of the tile 
are needed which are set up before hand.  The STORE_KOPY command can be 
used to store the graphics in the correct format.

The  following  example takes a block at 0,0 and converts it  into  the 
correct format:

        DIM buffer|(4096)
        buffer%=V:buffer|(0)
        GET 0,0,31,31,a$
        PUT 32,0,a$           ! Wrap tile to right
        FOR a|=0 to 31
          ~C:store_kopy%(a|,0,0,32,32,1,L:buffer%,L:screen%)
          GET 1,0,63,31,a$
          PUT 0,0,a$          ! Scroll tile to left
        NEXT a|
          
------------------------------------------------------------------------

FILE:       BANNER.INL
SETUP:      INLINE banner%,604
            set_banner%=banner%
            scroll_banner%=banner%+4
SYNTAX:     ~C:set_banner%(width,height,L:text,L:font,L:screen)
            ~C:scroll_banner%()
ARGUMENTS:
width       (W) width of font in pixels, commonly 16
height      (W) height of font in pixels, commonly 16
text        (L) address of text to scroll
font        (L) address of font graphics
screen      (L) screen address to print banner

Banner  is used to create scroll texts,  just like the ones you see  in 
demos. The font is a one bitplane font which can be designed in the art 
package and then saved with the SAVEFONT.GFA program.  The speed of the 
scrolling  is specified within the scroll text,  valid speed are  1,2,4 
and 8 pixels. The width of the font may be changed, but if the width is 
not divisable by the speed then the scroll will be messed up.

Once the banner has been set each successive call to SCROLL_BANNER will 
move  the  banner to the left.  The scroll text will  restart  when  it 
reaches a zero byte. The command can be automatically called by placing 
it in the STs VBL list (see example file).  This will update the banner 
under  interrupt  so it will even work as you load a  file,  great  for 
games which take a while to load.

As  the  font is only drawn on one bitplane it is  possible  to  select 
which  of the four bitplanes to draw on.  Simply add two to the  screen 
address to get to the second bitplane, +4 for third bitplane and +6 for 
the forth bitplane.

The  best way to store the banner text is within an  INLINE  statement. 
The  first time the program is run the text can be stored as  a  string 
which is converted into the INLINE, then the other lines can be deleted 
leaving you with all the text in the INLINE statement.  The data within 
the  INLINE  will stay there as long as the program is not saved  as  a 
listing.

        INLINE text%,28
        text$=CHR$(2)+"Store me in an INLINE....."+CHR$(0)
        FOR a|=0 TO LEN(text$)-1
          POKE text%+a|,PEEK(V:text$+a|)
        NEXT a|

The above listing will store the string text$ into the INLINE statement 
at location text%, all the lines except the INLINE may then be deleted.

Another  method is to use a word processor to write the text  and  load 
the text straight into the INLINE statement. But remember to change the 
last byte in the INLINE to a zero !

-----------------------------------------------------------------------

FILE:       BIG_BAN.INL
SETUP:      INLINE big_banner%,672
            set_banner%=big_banner%
            scroll_banner%=big_banner%+4
SYNTAX:     ~C:set_banner%(width,height,L:text,L:font,L:screen)
            ~C:scroll_banner%()
ARGUMENTS:
width       (W) width of font in pixels
height      (W) height of font in pixels
text        (L) address of text to scroll
font        (L) address of font graphics
screen      (L) screen address to print banner

The  last banner routine can only print small single colour  scrollers, 
this  routine is much more like the large ones you see  in  demos.  The 
fonts  can  be any width but can only be up to 48 pixels high  and  are 
designed in all 16 colours. 

Unlike  the last banner scroll there is no  speed  setting,  everything 
moves eight pixels on each call to SCROLL_BANNER.

A big advantage with this scroller is that the whole text is  reprinted 
every  time  it is called which means that it can easily be  used  with 
screen  switching  without anything messing up.  The  screen  that  the 
banner will be printed on is held in location big_banner%+30,  so  when 
the screen switch has occured the new foreground screen position can be 
written into this location so that the scroller is updated every  frame 
even if the screen switching occurs at a slower rate.

You can also create bendy scrollers by DPOKEing screen offsets into  an 
offset table.  The table is at big_banner%+38 and hold 40  words.  Each 
word  contains  an offset which is added to the  screen  address  after 
printing  an  8 pixel width strip of the  scroller.  Using  this  table 
allows  you  to create slanted,  sinus and bendy  type  scrollers.  The 
offsets are relative to the last position, so 40 words of the value 160 
will cause the scroller to appear slanted down to right.

To  save your fonts in the correct format you must use the  SAVEBIG.GFA 
program in the UTILITY folder.  The first character must be a space and 
the  last character depends on how many you want,  typically  the  last 
character  will be 'Z' for upper case only text or 'z' for  both  upper 
and lower case text.

NOTE:  The same syntax as the last routine has been used because it  is 
unlikely  that both routines will be used together.  As with  the  last 
routine, the text must end with a zero byte.

-----------------------------------------------------------------------

FILE:       BLIT_COPY.INL
SETUP:      INLINE blit_copy%,778
            blit_get%=blit_copy%+4
            blit_put%=blit_copy%+8
            blit_clip%=blit_copy%+12
SYNTAX:     ~C:blit_copy%(sw1,L:s1,x1,y1,w1,h1,sw2,L:s2,x2,y2,mode)
            ~C:blit_get%(sw1,L:s1,x1,y1,w1,h1,L:buffer)
            ~C:blit_put%(sw1,L:buffer,x2,y2,w1,h1,L:s2,mode)
            ~C:blit_clip%(xmin,ymin,xmax,ymax)
ARGUMENTS:
sw1         (W) source screen width in bytes
s1          (L) source screen address
x1/y1       (W) source x/y pixel coordinate
w1/h1       (W) source width & height in pixels
sw2         (W) destination screen width in bytes
s2          (L) destination screen address
x2/y2       (W) destination x/y pixel coordinate
buffer      (L) buffer address
mode        (W) put mode, 0-15
xmin/ymin   (W) top left pixel coordinate of clipping window
ymin/ymax   (W) bottom right pixel coordinate of clipping window

BLITTER CHIP ONLY:

BLIT_COPY  is  very  similar  to the  GFA  RC_COPY  command,  the  only 
difference  is  that the screen width can be altered for use  with  the 
SPLIT_SCREEN  command.  For normal screens the screen width  should  be 
160.

When BLIT_GET is used the block is transferred to a buffer.  Unlike the 
GFA GET command there are no details stored with the block and you must 
make sure you allocate enough space for the block.  The correct size of 
the buffer is (width in words+8)*height

When  using BLIT_PUT you must provide the original width and height  of 
the block and also the put mode.

The modes are as follows:

        0   0 (Erase)
        1   source AND destination
        2   source AND (NOT destination)
        3   source
        4   (NOT source) AND destination
        5   destination
        6   source XOR destination
        7   source OR destination
        8   NOT (source OR destination)
        9   NOT (source XOR destination)
        10  NOT destination
        11  source OR (NOT destination)
        12  NOT source
        13  (NOT source) OR destination
        14  NOT (source AND destination)
        15  1 (Solid colour)

The  most  useful  modes are 3 for solid moving  (normal  use),  4  for 
masking and 6 or 7 for merging sprites after putting down the mask.

BLIT_CLIP allows you to define a clipping window which does not need to 
be  word aligned.  Make sure the block is not bigger than the  clipping 
window. For full screen clipping use ~C:blit_clip%(0,0,319,199).

You  can  check if a blitter chip is installed with the  following  few 
lines:
        blitter&=XBIOS(64)
        IF (blitter& AND 2)=0
          blitter not available
        ELSE
          blitter available
        ENDIF

-----------------------------------------------------------------------

FILE:       BORDERS.INL
SETUP:      INLINE borders%,772
            borders_on%=borders%
            borders_off%=borders%+4
SYNTAX:     ~C:borders_on%()
            ~C:borders_off%()

The  borders  command  allows you to use the top  and  bottom  borders, 
effectively  giving  you around 276 vertical resolution  (depending  on 
your TV/Montor) instead of the usual 200 lines.  The majority of Sprite 
Works commands are compatible with this routine,  but the GFA  joystick 
and  mouse commands will not work,  see NEWJOY and NEWMOUSE.  Also  the 
CHIP_FX  will  not work,  if you need sound effects then you  must  use 
BORDERS+  which has the CHIP_FX routine built into it.  If you want  to 
use samples on an ST then see SAMPLAY+ for more details.

FILE:       BORDERS+.INL
SETUP:      INLINE borders%,3558
            borders_on%=borders%
            borders_off%=borders%+4
            chip_fx%=borders%+8             (See Chip FX)  
            chip_playing%=borders%+12

If you are using a monitor then you will probably not benefit from this 
routine  as  most monitors clip the top and bottom and so much  of  the 
picture will be chopped off. However, most monitors allow you to adjust 
the picture by squashing and repositioning the screen with dials on the 
back of the monitor.

It  it possible to tell GFA that it has a bigger screen and  so  normal 
drawing  and  text functions can be used in the extended  part  of  the 
screen,  however the mouse pointer cannot access the lower part of  the 
screen.  This  is  due to a memory limit on the mouse  which  can  only 
access 32k out of the new screen memory of 44k.  This is due to a 'bug' 
in earlier versions of TOS,  I believe that TOS 1.4 and above are  able 
to  access  lower into the border.  See BORDERS.GFA for an  example  of 
using borders in conjunction with GFA.

NOTE:  Border removal will only work on the ST and STE and must have an 
8MHz clock (I presume !).

-----------------------------------------------------------------------

FILE:       BOX_HIT.INL
SETUP:      INLINE box_hit%,50
SYNTAX:     hit=C:box_hit%(x1,y1,w1,h1,x2,y2,w2,h2)
ARGUMENTS:
x1/y1       (W) top left pixel coordinates of box one
w1/h1       (W) width and height of box one
x2/y2       (W) top left pixel coordinates of box two
w2/h2       (W) width and height of box two
RETURNS:
hit         (W) return -1 if boxes overlap, 0 otherwise

This command aids simple collision detection. You specify the coordina-
tes  of the two boxes and the command returns TRUE (-1) when the  boxes 
hit or overlap each other.

 Eg,    IF C:box_hit%(x1&,y1&,w1&,h1&,x2&,y2&,w2&,h2&)
           PRINT "HIT"
        ENDIF

This  routine  is  really only needed if the two  collision  boxes  are 
different  sizes.  If the widths and heights are the same then  GFA  is 
actually over twice as as fast with the following routine !

        IF ABS(SUB(x1&,x2&))<width&
           IF ABS(SUB(y1&,y2&))<height&
              PRINT "HIT"
           ENDIF
        ENDIF

NOTE:  By staggering the AND statements (one on each line) as above  it 
produces  faster code than having multiple AND statements on one  line. 
Thanks to Simon Scott for the above GFA routine. 

-----------------------------------------------------------------------

FILE:       CHIP_FX.INL
SETUP:      INLINE chip_fx%,2652
            chip_playing%=chip_fx%+4
SYNTAX:     ~C:chip_fx%(sound)
            play=C:chip_playing%()
ARGUMENTS:
sound       (W) sound effect to play, 0=turn off soundchip
RETURNS:
play        (W) returns 0 if no sound, otherwise current fx number

Plays a sound chip effect,  from 1 to 75. Playing sound 0 will turn off 
the sound chip.

To  test whether a sound is still playing the CHIP_PLAYING  command  is 
used which returns the current sound effect number or zero if no  sound 
is playing.

-----------------------------------------------------------------------

FILE:       CHIPMUSI.INL
SETUP:      INLINE chip_music%,284
            play_bigalec%=chip_music%
            play_countzero%=chip_music%+4
            play_madmax%=chip_music%+8
            play_megatizer%=chip_music+12
            play_sentry%=chip_music%+16
            music_off%=chip_music%+20
SYNTAX:     ~C:play_bigalec%(tune,L:music)
            ~C:play_countzero%(tune,L:music)
            ~C:play_madmax%(tune,L:music)
            ~C:play_megatizer%(tune,L:music)
            ~C:play_sentry%(tune,L:music)
            ~C:music_off%()
ARGUMENTS:
tune        (W) Select tune number, generally 1
music       (L) Address of music data

An  easy  way  to get music into your game is to use one  of  the  many 
soundchip music files which are available from almost all PD libraries. 
Most  of  the  common formats are supported  here,  although  the  code 
doesn't  contain the playback routines,  it merely calls  the  playback 
routine built into the music file on interrupt.

Music  files  tend not to stick to a rigid format and so you  may  find 
that  using  one of the above commands does'nt play the  music,  or  at 
worst may crash the computer. Whenever you are testing a piece of music 
for the first time make sure that you save your program before  running 
it.  Should  you  encounter problems then choose a  different  playback 
command,  for  example,  you may find the a Big Alec music  file  plays 
using the ~C:megatizer command !

Any   of   the  music  formats  may  be  turned  off  with   a   single 
~C:music_off%() command.

NOTE: The VBL interrupt vector at $4DA is used to playback the music.

-----------------------------------------------------------------------

FILE:       CLRPLANE.INL
SETUP:      INLINE clr_planes%,1908
SYNTAX:     ~C:clr_planes%(mask,lines,L:screen)
ARGUMENTS:
mask        (W) bit pattern of bitplanes to clear
lines       (W) number of lines affected
screen      (L) screen address

A special fx routine to clear any or all of the screen bitplanes.  This 
command  is  specifically for use with parallax and stars  routines  as 
both routines use only the first two bitplanes.  By clearing the  first 
two  bitplanes,  any  graphics  on bitplanes three  and  four  will  be 
unaffected.

   Eg,  ~C:clr_planes%(%0011,200,L:back%)

   will clear 200 lines on the back screen on planes one and two.

-----------------------------------------------------------------------

FILE:       CLR_LINE.INL
SETUP:      INLINE clr_lines%,112
SYNTAX:     ~C:clr_lines%(lines,L:screen)
ARGUMENTS:
lines       (W) number of lines to clear
screen      (L) screen address

Clear a specified number of screen lines.

-----------------------------------------------------------------------

FILE:       CLS.INL
SETUP:      INLINE cls%,102
SYNTAX:     ~C:cls%(L:screen)
ARGUMENTS:
screen      (L) screen address

A fast clear screen command,  clears 32000 bytes. This is equivalent in 
speed to ~C:clr_lines%(200,L:screen).

-----------------------------------------------------------------------

FILE:       COMPRESS.INL
SETUP:      INLINE compress%,238
SYNTAX:     ~C:compress%(L:screen,L:buffer)
ARGUMENTS:
screen      (L) pointer to screen address
buffer      (L) destination address for compressed image

This  command is used to compress Degas Elite and IFF images which  are 
32000  bytes  long.  The command returns the length of  the  compressed 
image by assigning a variable to the command.
        
   Eg,  length%=C:compress%(L:XBIOS(2),L:buffer%)

See the PICS.GFA program for examples.

-----------------------------------------------------------------------

FILE:       COPYLINE.INL
SETUP:      INLINE copy_lines%,70
SYNTAX:     ~C:copy_lines%(lines,L:source,L:destination)
ARGUMENTS:
lines       (W) number of lines to copy
source      (L) address to copy from
destination (L) address to copy to

Allows you to copy a number of lines from one screen to another.

-----------------------------------------------------------------------

FILE:       COPYSCRN.INL
SETUP:      INLINE copy_screen%,68
SYNTAX:     ~C:copy_screen%(L:source,L:destination)
ARGUMENTS:
source      (LONG) address to copy from
destination (LONG) address to copy to

Fast  copy of 32000 bytes from one screen to another.  This command  is 
identical in speed to ~C:copy_lines%(200,L:source,L:destination).

-----------------------------------------------------------------------

FILE:       DECOMP.INL
SETUP:      INLINE decompress%,100
SYNTAX:     ~C:decompress%(L:buffer,L:screen)
ARGUMENTS:
buffer      (L) pointer to compressed image
screen      (L) image decompressed to this address

This command is used to decompress Degas Elite and IFF images.  It uses 
run  length  encoding and only works for images which are  32000  bytes 
long. See the PICS.GFA program for examples.

-----------------------------------------------------------------------

FILE:       DEPACK.INL
SETUP:      INLINE depack%,410
SYNTAX:     ~C:depack%(L:address)
ARGUMENTS:
address     (L) pointer to packed code

Depacks code packed by ICE 2.4 or AUTOMATION 5.0.1 packers. The code is 
depacked  on  the spot,  and so a destination address  is  not  needed. 
Remember to allocate enough space for the depacked code !

You  can  check yourself if code has been packed by reading  the  first 
four bytes with a long peek.  If code is packed then the packed size is 
given  by  then next four bytes and the packed size by the  four  bytes 
after that. ie,

        IF LPEEK(code%)=&H49434521      ! Check for 'ICE!' header
          unpacked_size%=LPEEK(code%+8)
        ENDIF

For AUTOMATION packed code change &H49434521 to &H41553521.
   
-----------------------------------------------------------------------

FILE:       DRAWING.INL
SETUP:      INLINE drawing%,1496
            plot%=drawing%
            line%=drawing%+4
            box%=drawing%+8
            clip_draw%=drawing%+12
            clip_on%=drawing%+16
            clip_off%=drawing%+20
SYNTAX:     ~C:plot%(x,y,colour,L:screen)
            ~C:line%(x1,y1,x2,y2,colour,L:screen)
            ~C:box%(x1,y1,x2,y2,colour,L:screen)
            ~C:clipping%(xmin,ymin,xmax,ymax)
            ~C:clip_on%()
            ~C:clip_off%()
ARGUMENTS:
x/x1/x2     (W) x pixel position
y/y1/y2     (W) y pixel position
colour      (W) draw colour
screen      (L) screen to draw to
xmin/ymin   (W) top left coordinate of clipping window
xmax/ymax   (W) bottom right coordinate of clipping window

A suite of new drawing commands to replace those of GFA,  each  command 
provides  a  faster  and direct  replacement.  Unlike  GFA  the  colour 
represents the corresponding colour in the palette, ie. in GFA, drawing 
in  colour  1 will actually draw in palette colour  15,  whereas  these 
commands will draw in the correct colour.

Generally the clipping should be kept on,  but if you know that all the 
drawing commands will be on screen you can switch the clipping off  for 
a 'minimal' increase in speed.

For  those  of  you who have a blitter chip  installed  then  GFA  will 
actually be faster at drawing a box.

NOTE: The box command draws a solid box, not an outline. These commands 
are uneffected by GRAPHMODE. Here is a speed comparison of Sprite Works 
against GFA:

        Time taken in seconds for 1000 operations
                 Sprite Works      GFA
        Points      0.2            1.6
        Lines       2.1            3.9
        Boxes       10.6           15.4 (5.1 with blitter)

-----------------------------------------------------------------------

FILE:       EXPLODE.INL
SETUP:      INLINE explode%,2724
            plot_explosion%=explode%+4
            clip_explosion%=explode%+8
SYNTAX:     ~C:explode%(x1,y1,x2,y2,ex,ey,speed,grav,rand,L:buff,L:screen)
            ~C:plot_explosion%(time,L:screen)
            ~C:clip_explosion%(xmin,ymin,xmax,ymax)
ARGUMENTS:
x1/y1       (W) top left of exploding object
x2/y2       (W) bottom right of exploding object
ex/ey       (W) center of explosion
speed       (W) speed of explosion projectiles
grav        (W) gravity, 0 = no gravity
rand        (W) random factor, creates realistic explosions
buff        (L) buffer, allocate 12 bytes for every pixel
screen      (L) screen address
time        (W) time frame of explosion, 0=original object
xmin/ymin   (W) top left coordinate of clipping window
xmax/ymax   (W) bottom right coordinate of clipping window

This  command provides a very special effect,  the ability to blow  any 
object on screen into a zillion pixels !  You must specify a window  of 
the area of the screen you wish to blow up, there is then a brief delay 
as all the points in the window are read in.  By specifying the  center 
of  the explosion you can make the object get blown up or to get  blown 
across  the  screen if the explosion occurs a distance  away  from  the 
object.

A  large buffer is needed for this effect,  12 bytes for  every  pixel. 
Generally the buffer size must be (x2-x1)*(y2-y1)*12 which can cope  if 
all  the  points are needed,  however those points  in  the  background 
colour are not saved and so the actual buffer needed may be smaller. By 
assigning  a  value to the explode command  (points&=C:exp....)  it  is 
possible to find out how many points were actually found.

Speed  should generally be around 40 to give fairly smooth  explosions. 
Gravity values up to around 5 can be used,  0 gives no gravity and  the 
points  of  the explosion will travel in a straight  line.  The  random 
factor, again values up to 5 can be used, is used to give the explosion 
a more realistic effect.  With no random factor the explosion tends  to 
produce pretty patterns,  but with a random factor a messier  explosion 
is produced.

When plotting the explosion with plot_explosion only the time frame and 
the  screen  address are needed.  If the time frame is  zero  then  the 
object  will  appear in its original state,  with a value  of  one  the 
object will appear at the point the explosion occured.  The time  frame 
is  completely variable and will allow you to  run  backwards,  causing 
objects to implode !

-----------------------------------------------------------------------

FILE:       FADE_TO.INL
SETUP:      INLINE fade_to%,336
            fade_to_black%=fade_to%+4
            fade_to_white%=fade_to%+8
SYNTAX:     ~C:fade_to%(speed,L:palette)
            ~C:fade_to_black%(speed)
            ~C:fade_to_white%(speed)
ARGUMENTS:
speed       (W) number of frames between each successive fade
palette     (L) pointer to new palette

A  smooth  palette  fader  which works under  interrupt  to  allow  the 
palettes to change as the program is running. To test whether a palette 
is currently in mid fade,  test the location $4DE with LPEEK.  If  this 
value is zero then the palette has finished changing.

These  commands  automatically  switch themselves off  when  they  have 
finished.

-----------------------------------------------------------------------

FILE:       FUZZ.INL
SETUP:      INLINE fuzz%,94
SYNTAX:     ~C:fuzz%(width,height,L:screen)
ARGUMENTS:
width       (W) word width of block
height      (W) pixel height of block
screen      (L) top left screen address of block

A special effects command that produces an out-of-tune TV effect.  Each 
call causes a different pattern to be produced. The width is defined in 
words,  so a width of 1 actually means 16 pixels.  Colours 0 and 15 are 
used  for  this effect and should normally be set to  black  and  white 
respectively.

------------------------------------------------------------------------

FILE:       H_WIPE.INL
SETUP:      INLINE h_wipe%,158
SYNTAX:     ~C:h_wipe%(height,L:screen,L:buffer)
ARGUMENTS:
height      (W) height of strip in pixels
screen      (L) current screen
buffer      (L) new screen

This  is  a special effects way of  clearing/changing  the  screen.  It 
slides  horizontal  strips of the screen right and  left  on  alternate 
lines at the same time bringing on the new screen.

With  a height of 8 there will be 13 strips moving right and 12  strips 
moving left. There is no need to have a height that 200 is divisable by 
as the command automatically clips the last row should it overshoot the 
end of the screen.

There is no speed setting for this command, it simple carries it out as 
fast as it can,  therefore using it on a Falcon or accelerated  machine 
it may be too quick.

------------------------------------------------------------------------

FILE:       KOPY.INL
SETUP:      INLINE kopy%,480
            store_kopy%=kopy%+4
            clip_kopy%=kopy%+8
SYNTAX:     ~C:kopy%(frame,x,y,width,height,planes,mode,L:data,L:screen)
            ~C:store_kopy%(frame,x,y,width,height,planes,mode,L:data,L:screen)
            ~C:clip_kopy%(xmin,ymin,xmax,ymax)
ARGUMENTS:
frame       (W) block number to copy
x/y         (W) top left x/y pixel position
width       (W) width of block in pixels
height      (W) height of block in pixels
planes      (W) number of bitplanes
mode        (W) 0=solid mode, 1=x-ray mode
data        (L) address of kopy data
screen      (L) screen address to print to or save from
xmin/ymin   (W) top left coordinate of clipping window
xmax/ymax   (W) bottom right coordinate of clipping window

A  general purpose copy routine that was specifically written to  print 
logos  and large fonts,  16x16 upwards.  The block to copy can be  made 
from 1 to 4 bitplanes and can print the blocks as solid or x-ray  which 
makes the background parts of the block appear transparent.

The STORE_KOPY command can be used to save graphics from the screen  or 
memory,  similar to the GFA GET command.  Unlike GET and PUT,  kopy can 
only  print on an x coordinate that is word aligned (divisable by  16), 
this also applies to the width, but NOT the y coordinate and height.

You can also use the basic program KOPYSAVE.GFA to load in Degas  Elite 
pictures and save portions of the screen in kopy format.

When  specifying  a  clipping window the x  coordinates  must  be  word 
aligned.  Also clipping will fail to work if the object is bigger  than 
the clipping window.
 
-----------------------------------------------------------------------

FILE:       LOCATE.INL
SETUP:      INLINE locate_flag%,244
            change_map%=locate_flag%+4
            change_flag%=locate_flag%+8
            get_map%=locate_flag%+12
            get_flag%=locate_flag%+16
SYNTAX:     address=C:locate_flag%(x,y,L:map,L:flags)
            ~C:change_map%(x,y,sprite,L:map)
            ~C:change_flag%(x,y,flags,L:map,L:flags)
            sprite=C:get_map%(x,y,L:map)
            status=C:get_flag%(x,y,l:map,L:flags)
ARGUMENTS:
x/y         (W) x/y pixel coordinate
sprite      (W) sprite block number
map         (L) address of map data
flags       (L) address of flag data
RETURNS:
address     (L) address of map block flags
sprite      (W) sprite number of map block
status      (W) eight flags of map block

These  commands are used in conjunction with the  multidirectional  map 
printing commands. 

LOCATE_FLAG is used to find the flags that relates to a 16x16 pixel map 
block.  It returns the address of the flags which can then be read with 
PEEK or changed with POKE. CHANGE_FLAG and GET_FLAG have now superceded 
this command.

CHANGE_MAP is used to change a graphic block within the map. Supply the 
x and y coordinates,  the new block number (between 0-number of sprites 
as saved in DESIGN2.PRG) and the map data address.

CHANGE_FLAG sets the flags for a map block.  It is equivalent to  using 
LOCATE_FLAG and POKEing to the returned address.

GET_MAP returns the sprite number of the map block. 

GET_FLAG returns the flags of the map block.  It is equivalent to using 
LOCATE_FLAG and PEEKing the returned address.

Although these commands take pixel coordinates they are converted  into 
block  coordinates by the commands by dividing them by  16.  ie,  pixel 
coordinates 0,0 and 15,15 both relate to block coordinate 0,0.

See the technical documentation for more details.

-----------------------------------------------------------------------

FILE:       MAPPER.INL
SETUP:      INLINE mapper%,834
SYNTAX:     ~C:mapper%(x,y,width,height,L:map,L:gfx,L:screen)
ARGUMENTS:
x/y         (W) top left x/y position of map
width       (W) number of horizontal 16x16 blocks to print
height      (W) number of vertical 16x16 blocks to print
map         (L) pointer to map data
gfx         (L) pointer to map graphics
screen      (L) screen address to print map

This  is a powerful command to print multi-directional scrolling  maps. 
Design  your maps with DESIGN2.PRG and save the graphics with the  type 
set to 8-way.  This can use large amounts of memory so take note of the 
total size in the map designer.

It  can  handle  1,2,4  and 8 pixel  scrolling,  the  correct  size  is 
automatically  set by the command as the size is specified in  the  map 
data header.

If you have an STE then use STE_MAPPER as it is MUCH faster and uses  a 
fraction less graphics data.

-----------------------------------------------------------------------

FILE:       MEM_FILL.INL
SETUP:      INLINE mem_fill%,30
SYNTAX:     ~C:mem_fill%(L:start,L:length,number)
ARGUMENTS:
start       (L) address to fill from
length      (L) number of bytes to fill
number      (B) fill value

A  memory  fill command that is normally used to  initialise  areas  of 
memory to zeros.

     Eg,
        ~C:mem_fill%(L:(V:tmp$),L:1024,0), will fill tmp$ with 1024
        zero bytes.

-----------------------------------------------------------------------

FILE:       NEWMOUSE.INL
SETUP:      INLINE new_mouse%,412
            mouse_on%=new_mouse%
            mouse_off%=new_mouse%+4
            set_mouse%=new_mouse%+8
            mb%=new_mouse%+12
            mx%=new_mouse%+14
            my%=new_mouse%+16
SYNTAX:     ~C:mouse_on%()
            ~C:mouse_off%()
            ~C:set_mouse%(x,y,xmax,ymax)
ARGUMENTS:
x/y         (W) start x/y pixel position
xmax/ymax   (W) maximum x/y pixel position

These  commands  are used to switch to a  different  mouse  controller. 
Normally GFA uses relative position mode which causes programs to  slow 
down  when the mouse is moved.  The new commands use absolute  position 
mode and do not slow the program down.  To use the commands simply  use 
SET_MOUSE and then MOUSE_ON.  The mouse x,y position and buttons can be 
read  by  DPEEK(mx%),   DPEEK(my%)  and  DPEEK(mb%).  Remember  to  use 
MOUSE_OFF  before  the  program  finishes to  return  to  normal  mouse 
control.

-----------------------------------------------------------------------

FILE:       NEWJOY.INL
SETUP:      INLINE newjoy%,236
            joystick_on%=newjoy%
            joystick_off%=newjoy%+4
            joy0%=newjoy%+8
            joy1%=newjoy%+9
SYNTAX:     ~C:joystick_on%()
            ~C:joystick_off%()

As  with  the mouse command,  the standard joystick  routine  takes  up 
processor time each time the joystick is moved.  This command will only 
read the joystick every frame.  To read the joystick use PEEK(joy0%) or 
PEEK(joy1%),  these locations can also be written to with POKE to reset 
certain  conditions.  The value obtained must have its bits  tested  to 
check for movement or fire button,  bit 0 up,  bit 1 down,  bit 2 left, 
bit 3 right and bit 7 fire.

   Eg,  s|=PEEK(joy1%)
        IF BTST(s|,0)
           up
        ENDIF
        IF BTST(s|,1)
           down
        ENDIF
        IF BTST(s|,2)
           left
        ENDIF
        IF BTST(s|,3)
           right
        ENDIF
        IF BTST(s|,7)
           fire
        ENDIF

NOTE:  If  you are using the border removal command then  this  command 
must be used if you want joystick control.

-----------------------------------------------------------------------

FILE:       PALSWTCH.INL
SETUP:      INLINE set_palettes%,456
            reset_palettes%=set_palettes%+4
SYNTAX:     ~C:set_palettes%(line,L:palette1,L:palette2)
            ~C:reset_palettes%()
ARGUMENTS:
line        (W) line number to switch palettes
palette1    (L) address of first palette
palette2    (L) address of second palette

Allows  32  colours  on screen at once by  switching  palettes  on  the 
specified line.  The first palette will be set from above the line  and 
the second palette will be set from and below the line.

Occasionally  you  may notice the palette switch suddenly  jump  a  few 
lines down.  This is caused by interference from Timer C,  to turn this 
off you can use turn_offc from the rasters command.

When  the command has been used you must use reset_palettes  to  remove 
the interrupt routine.

NOTE: The command is unable to switch palettes for the first few screen 
lines 0-2.

-----------------------------------------------------------------------

FILE:       PARALLAX.INL
SETUP:      INLINE parallax%,2126
            setup_parallax%=parallax%
            plot_parallax%=parallax%+4
            move_parallax%=parallax%+8
SYNTAX:     ~C:setup_parallax%(stars,xmin,ymin,xmax,ymax)
            ~C:plot_parallax%(L:screen)
            ~C:move_parallax%(xinc,yinc)
ARGUMENTS:
stars       (W) number of stars, max of 200
xmin/ymin   (W) top left x/y of clipping window
xmax/ymax   (W) bottom right x/y of clipping window
screen      (L) screen address to plot stars
xinc        (W) horizontal star movement
yinc        (W) vertical star movement

These  commands  allow  you to create  a  three  layer  starfield,  the 
background stars are plotted in colour 1,  the middle stars in colour 2 
and the foreground stars in colour 3.  The xinc and yinc values may  be 
positive or negative to create movement in all directions,  the further 
back  the  stars  the less movement there will  be  which  creates  the 
parallax effect.

The  stars  are  plotted  on bitplanes one and  two  only  and  so  the 
CLR_PLANES command can be used to clear the stars without upsetting the 
graphics that may be on bitplanes three and four.

-----------------------------------------------------------------------

FILE:       PATHCALC.INL
SETUP:      INLINE path_calc%,1350
            path_update%=path_calc%+4
            path_state%=path_calc%+8
            path_xy%=path_calc%+12
            path_kill%=path_calc%+16
SYNTAX:     ~C:path_calc%(n,x1,y1,x2,y2,speed)
            cond=C:path_update%(n)
            cond=C:path_state%(n)
            xy=C:path_xy%()
            ~C:path_kill%()
ARGUMENTS:
n           (W) path number (0-49)
x1/y1       (W) start pixel coordinates
x2/y2       (W) end pixel coordinates
speed       (W) 1=1 pixel, 2=2 pixel, 3=4 pixel, 4=8 pixel
RETURNS:
cond        (W) condition of path, 0=active, -1=finished
xy          (L) high word contains x, low word contains y

These  commands are specifically for use with handling the  tracing  of 
bullet  paths although you may find them useful in other  applications. 
Although GFA is capable of this job it would be extremely slow compared 
with these commands.

The command PATH_CALC is first used to calculate the direction  vectors 
of a path and the speed at which the point should travel.  You can only 
specify  speeds that are 2 to the power,  1 and 2 move 1 and  2  pixels 
respectively, but 3 moves 8 pixels, 4 moves 16 pixels at a time, and so 
on. Up to 50 paths can be handled at a time, so a value of 0-49 must be 
passed to the command to control the specified path.

To  update your position within the path a call to PATH_UPDATE is  used 
along  with the path number.  If the path has finished then it  returns 
TRUE (-1), otherwise it returns FALSE (0).

To  find whether you've already used a path or a path has finished  you 
can  use the PATH_STATE command which returns FALSE if the path  hasn't 
finished or TRUE if it has.

The PATH_XY command returns the x and y positions in a single long word 
register,  so  they  must  be split into separate  x  and  y  variables 
manually. Eg,
                    xy%=C:path_xy%(path number)
                    x&=CARD(SWAP(xy%))
                    y&=CARD(xy%)

The x position is in the high word so the variable is swapped and  then 
CARD  is  used to remove the upper word.  For the y position  only  the 
upper word needs to be removed.

To kill a path simply call PATH_KILL with the path number.  To kill all 
the paths,  which it is advisable you do at the start of your  program, 
use a value of -1, ~C:path_kill%(-1).

----------------------------------------------------------------------

FILE:       PIXELHIT.INL
SETUP:      INLINE pixel_hit%,298
SYNTAX:     hit=C:pixel_hit%(frame,x,y,height,L:gfx,L:screen)
ARGUMENTS:
frame       (W) sprite frame number (16 pixel width format)
x/y         (W) sprite x/y pixel coordinate
height      (W) height of 16x sprite
gfx         (L) address of sprite graphics
screen      (L) screen address of collision detection
RETURNS:
hit         (W) returns -1 if hit, 0 otherwise

This command is used for pixel collision detection. It uses the mask of 
the sprite to check whether any pixels will be covered by the mask.  It 
will only work with 16x sprites, not 32x, but can cope with any height. 
This  command will only work if the background is blank,  otherwise  it 
will always return a hit. If you want a patterned background a solution 
is to have two screens,  one with normal screen graphics and the  other 
contains only objects that are considered solid.

This command is much slower than the BOX_HIT command and should only be 
used if there are a limited number of PIXEL_HIT tests.  For example, it 
is ideal for a pinball or thrust/lunar lander type game.

-----------------------------------------------------------------------

FILE:       PRINTMAP.INL
SETUP:      INLINE print_map%,280
            locate%=print_map%+4
SYNTAX:     ~C:print_map%(number,L:map,L:graphics,L:screen)
            location=C:locate%(x,y,number,L:map)
ARGUMENTS:
number      (W) screen number
map         (L) pointer to map data
x/y         (W) x/y pixel position
graphics    (L) pointer to map graphics (16x16 sprites, no mask)
screen      (L) pointer to destination screen
RETURNS:
location    (L) returns an address of a map block

This  command  is  for printing non-scrolling maps  designed  with  the 
DESIGN1 program, from which the graphics and map data are saved. Unlike 
the  other  two map printing commands this one can print any one  of  a 
number of maps.  Each map block contains its own flags from bits 10  to 
15. 

LOCATE is used to find the address of a block so that its flags may  be 
obtained or the block graphic may be changed. As an address is returned 
a variable must be assigned to it, ie var%=C:locate%(..)

See technical documentation for more details.

----------------------------------------------------------------------

FILE:       PROTRACK.INL
SETUP:      DIM protrack|(40000)
            play_module%=V:protrack|(0)
            stop_module%=play_module%+4
            bass_setting%=play_module%+8
            treble_setting%=play_module%+10
SYNTAX:     reg=C:play_module%(frequency,L:module)
            ~C:stop_module%()
ARGUMENTS:
module      (L) address of protracker module
frequency   (W) playback frequency, typically 7500-14000 Hz
RETURNS:
reg         (L) address of the protracker registers

A protracker module player originally written by Griff of Inner Circle. 
This  is one of the best players avaiable with high compatibility  with 
many Amiga modules,  now converted to accept any playback frequency and 
run without using any registers.

The  playback frequency can be anything from 2.5Khz up to around  16kHz 
(in practise more like 6kHz-15kHz), anything higher and the computer is 
likely to lock-up.  Be careful with playing at 16kHz as the only  thing 
the  computer can do is wait for a keypress as there is so  little  CPU 
time left.  A good compromise between CPU time and sound quality is  to 
use  a frequency of around 12kHz.  The command automatically  sets  the 
output to stereo if DMA sound is available.

For  STE  owners you can specify how much bass and treble there  is  by 
DPOKEing the values into bass_setting% and treble_setting%. Values of 0 
to 12 can be used, 6 being the default value.

This  command  has good compatibility with many GFA  and  Sprite  Works 
commands.  In  particular  the  GFA INKEY$ is still able  to  read  the 
keyboard  and  the GFA mouse can also be used (at  lower  frequencies). 
Generally if you want to use the mouse then use the NEWMOUSE command.

NOTE:  Don't expect to be able to use rasters or border removal !  

The PLAY_MODULE command can be assigned a variable so that the  address 
of  the  protracker registers can be found.  In  the  PROTRACK  example 
program  these registers are used by the fade_out_module  procedure  to 
smoothly fade out the module when it has finished playing.  Fading  out 
modules with a playback frequency of over 12 kHz are unlikely to  sound 
very good as the player overwrites the new volumes faster than GFA  can 
set them !

As  you can see from the commands SETUP,  it cannot be loaded  into  an 
INLINE because of the 32746 byte limit imposed.  This command  requires 
you  to  allocate  40000 bytes of memory and then BLOAD  in  the  code. 
However,  it  is possible to load the command into an INLINE if it  has 
been  packed.  A  packed version has been  included  (see  below),  its 
advantage  is that is it does not require any external loading  and  so 
forms  a  single PRG file,  the disadvantage is that it  wastes  9k  of 
memory. Thanks to MUG U.K. for that tip !

FILE:       PRO_PACK.INL
            (DEPACK.INL also needed)
SETUP:      INLINE pro_pack%,9377
            INLINE depack%,410
            DIM protrack|(40000)
            play_module%=V:protrack|(0)
            stop_module%=play_module%+4
            BMOVE pro_pack%,play_module%,9377
            ~C:depack%(L:play_module%)
SYNTAX:     see previous
ARGUMENTS:  see previous

NOTE:  If you use this command in your program then please give  credit 
to 'Griff of Inner Circle' for writing the original version.

-----------------------------------------------------------------------

FILE:       RASTERS.INL
SETUP:      INLINE rasters%,586
            install_rasters%=rasters%
            reset_rasters%=rasters%+4
            set_rasters%=rasters%+8
            turn_onc%=rasters%+12
            turn_offc%=rasters%+16
SYNTAX:     ~C:install_rasters%(line,height,index,offset,L:colours)
            ~C:reset_rasters%()
            ~C:set_rasters%(line)
            ~C:turn_onc%()
            ~C:turn_offc%()
ARGUMENTS:
line        (W) pixel offset into raster data
height      (W) height in pixel between rasters
index       (W) colour index affected by rasters
offset      (W) y offset to start of raster
colours     (L) pointer to list of raster colours

These  commands are for creating special effects with coloured bars  of 
colour.  Only one colour can be affected by the rasters,  specified  by 
the index.  For example, to create rasters in the border you should use 
an index of zero and for colour 1 use 1 and so on.

The  rasters  can be offset by specifying a line,  this allows  you  to 
scroll through the rasters as smooth as you wish.  If you had a  raster 
height  of 16 pixels,  then a line offset of 14 would show 2 pixels  of 
the first colour followed by 16 pixels of the second  colour,  etc.  By 
repeating the colours in the list and reseting the line offset after  a 
certain number of cycles it is possible to create an everlasting  cycle 
of colour.  A start offset can be used to avoid the rasters occuring at 
the top of the screen,  simply state which line you want the rasters to 
be first switched on in the offset parameter.

Once the rasters have been setup with INSTALL_RASTERS, you only need to 
use SET_RASTERS to alter the line offset. If you experience glitches in 
the rasters then you may stablize the rasters by using TURN_OFFC  which 
turns  off the systems 200Hz interrupt,  but remember to  use  TURN_ONC 
before finishing the program.

NOTE:  If  you are using the border removal command then TURN_OFFC  and 
TURN_ONC are not needed and will have no effect.
 
----------------------------------------------------------------------

FILE:       REVELINE.INL
SETUP:      INLINE reverse_lines%,82
SYNTAX:     ~C:reverse_lines(L:source,L:destination,lines)
ARGUMENTS:
source      (L) address to copy from
destination (L) address to copy to
lines       (W) number of lines to copy

The  command  is the same as copy line except that the  block  will  be 
mirrored vertically.

----------------------------------------------------------------------

FILE:       SAMPLAY.INL
SETUP:      INLINE sam_play%,2662
            sam_stop%=sam_play%+4
            sam_wait%=sam_play%+8
            sam_convert%=sam_play%+12
            sam_playing%=sam_play%+16
SYNTAX:     ~C:sam_play%(L:sample,L:length,frequency,loop)
            ~C:sam_stop%()
            ~C:sam_wait%()
            ~C:sam_convert%(L:sample,L:length)
            play=C:sam_playing%()
ARGUMENTS:
sample      (L) start address of sample
length      (L) length of sample
frequency   (W) playback frequency 2500-16000Hz
loop        (W) 0=play once, 1=repeat sample
RETURNS:
play        (L) 0=not playing, otherwise address of current sample

SAM_PLAY is used to play samples.  The first time the command is called 
the interrupt Timer A is set up,  each successive call will only change 
the  sample pointers without having to reinitialise Timer  A.  While  a 
sample is playing the rest of the program will continue to run,  but if 
you  wish  to halt the program until the sample has finished  then  use 
SAM_WAIT.  This is the newest version of the sample player which allows 
you  to specify exactly what speed the playback should be for  accurate 
control instead of the old table of fixed playback speeds.

When  the samples have been finished with or the program  has  finished 
then you must use SAM_STOP to stop the interrupt otherwise the  program 
will be likely to crash on exit.

This sample player plays signed samples, if a sample sounds terrible on 
playback it is probably an unsigned sample.  Use SAM_CONVERT to convert 
from one format to the other.

This  version  of the sample player uses less processor time  than  the 
original  and so gives more time for the processor to execute your  own 
code.  It does have one disadvantage though, the routine will overshoot 
the  end  of the sample,  from between 50 to  300 bytes*  (depending  on 
playback frequency).  This may result in the sample 'clicking' when  it 
has finished. To solve the problem you can either make sure that zeroes 
follow the sample,  or tell the sample player that the sample is a  100 
bytes or so shorter in length.

*  The  maximum  number  of bytes that a sample  can  overshoot  by  is 
frequency/50.

By  using the SAM_PLAYING command it is possible to see what sample  is 
currently playing. A value of zero is returned if no sample is playing, 
otherwise the first address of the sample playing is returned. 

It  is actually possible to play samples AND have border  removal,  but 
not with this routine.  You will need to use SAMPLAY+ which is not only 
compatible  with  the  border  removal  but  also  uses  slightly  less 
processor time,  so even if you aren't using border removal but wish to 
squeeze some more CPU time out of the computer then this is the command 
for you.

FILE:       SAMPLAY+.INL
SETUP:      INLINE sam_play%,12972
SYNTAX:     see previous
ARGUMENTS   see previous

As you can see,  the major disadvantage with this command as opposed to 
the normal samplay command is the size ...  nearly 13k. The reason this 
command  works  with  the border removal is that it works  on  a  lower 
priority  interrupt,  but  it  still  doesn't  mean  that  it  is  100% 
compatible.  This command will ONLY work with the border removal at low 
sample  frequencies,  the  highest being 6080 Hz.  Here is  a  list  of 
frequencies that you should find compatible with border removal :

        Frequency   Closest to

          2610        2.5 kHz
          3030        3.0 kHz
          3560        3.5 kHz
          4040        4.0 kHz
          4585        4.5 kHz
          4995        5.0 kHz
          5510        5.5 kHz
          6080        6.0 kHz

If  you find that these frequencies still cause the border  routine  to 
glitch  then  make sure that you have a 'clean system' with  no  memory 
resident programs that may interfere with it.

NOTE:  The  normal  GEM mouse pointer will interfere with both  of  the 
sample  routine.  If  you wish to use the mouse then use  the  NEWMOUSE 
command.

-----------------------------------------------------------------------

FILE:       SHRINK.INL
SETUP:      INLINE shrink%,9272
SYNTAX:     nheight=C:shrink%(size,width,height,L:source,L:destination)
ARGUMENTS:
size        (W) degree of shrinkage, 0-7 for 16x sprites,
                0-15 for 32x sprites
width       (W) width of sprite in pixels either 16 or 32
height      (W) height of sprite in pixels
source      (L) location of original sprite
destination (L) location of the shrunken sprite
RETURNS:
nheight     (W) the new height of the shrunken sprite

A  powerful  command that allows you to shrink  sprites  in  real-time. 
Shrinking  a 16x or 32x width sprite will not change its width but  the 
height  will change,  and so must be retrieved from  the  command.  The 
final shrunken sprite can then be printed as a normal sprite.

   Eg,  height&=C:shrink%(7,32,32,L:gfx%,L:gfx%+640)
        ~C:print_sprite%(0,x&,y&,32,height&,L:gfx%+640,L:screen%)
    
        will shrink a 32x32 sprite by 50%

Each change in the size will affect the sprite by two pixels, therefore 
a  16x  sprite has eight possible sizes (0-7) and a 32x sprite  has  16 
possible sizes (0-15).  The command needs a buffer to send the shrunken 
sprite  to.  For a 32x32 sprite a 640 byte buffer is  needed,  see  the 
SPRITES.INL for more information.

-----------------------------------------------------------------------

FILE:       SCRNSPLT.INL
SETUP:      INLINE split_screen%,894
            reset_split%=split_screen%+4
SYNTAX:     ~C:split_screen%(line,x1,w1,L:p1,L:s1,x2,w2,L:p2,L:s2)
            ~C:reset_split%()
ARGUMENTS:
line        (W) y line at which split occurs
x1          (W) x pixel offset of screen 1
w1          (W) width in bytes of screen 1
p1          (L) palette of screen 1
s1          (L) screen 1 address
x2          (W) x pixel offset of screen 2
w2          (W) width in bytes of screen 2
p2          (L) palette of screen 2
s2          (L) screen 2 address

STE ONLY:

A  powerful  command  to split the physical  screen  into  two  virtual 
screens. Each screen has its own x position, width and palette.

An x coordinate is given to move horizontally,  but should you wish  to 
move up and down then you will need to subtract or add the screen width 
in  bytes  to the screen address.  Normal ST screens are 160  bytes  in 
width,  this  is  fine if only vertical scrolling,  but  if  horizontal 
scrolling is needed then the minimum width should be 168 bytes,  giving 
336 pixels (virtual) width. 

This command can come in very useful when displaying menu/score bars as 
only  the main play area needs screen switching and the score bar  will 
display the same section of memory all the time.  Without this  command 
the score bar would also be swapped when a screen switch occurs and  so 
the  score and other details would have to be drawn on both  foreground 
and background screens.

You  must remember that when reserving memory for the screens that  you 
reserve  the correct amount.  A screen can now be 'virtually' any  size 
you  want and also be on any even address,  thus removing the  need  to 
ensure that the screen is on a 256 byte boundary (+255 AND $FFFF00).

You  may require only one hardware scrolling screen in which  case  set 
the line parameter to 255 and the second set of screen parameters  will 
not  be  used,  just  set  them to be the  same  as  the  first  screen 
parameters.

If  you create a screen that is any different than 160 bytes  in  width 
then  the  only graphics commands that will work are  the  SPRITES  and 
BLITTER commands. 

You  can  avoid using palettes by passing the value -1 for any  of  the 
palette  pointers.  In  this  case the palette is left  alone  and  can 
sometimes  provide  a  slightly  more  stable  interrupt  which  avoids 
glitching,  this also allows the FADE_TO command to work.  Generally if 
you  are  writing a game then it is best to use this  method.  See  the 
example platform game for an example of this.

NOTE:  You may find the BLITTER commands interfere quite badly with the 
screen  switch,  but  only if you have two screens  setup.

ADDITIONAL NOTE:  Should  you encounter minor glitches then  make  sure 
that  you have a clean system with no resident programs or  accessories 
in memory.  Also GFA itself may interfere slightly and the glitches may 
not occur once the program has been compiled.  

-----------------------------------------------------------------------

FILE:       SPRITES.INL
SETUP:      INLINE sprites%,6198
            print_sprite%=sprites%
            print_sprites%=sprites%+4
            erase_sprites%=sprites%+8
            clip_sprites%=sprites%+12
            print_mask%=sprites%+16
            print_invmask%=sprites%+20
            fast_sprite%=sprites%+24
            fast_mask%=sprites%+28
            fast_invmask%=sprites%+32
            store_sprite%=sprites%+36
            sprite_width%=sprites%+40
SYNTAX:     ~C:print_sprite%(frame,x,y,width,height,L:gfx,L:screen)
            ~C:print_sprites%(number,L:records,L:screen)
            ~C:erase_sprites%(number,L:records)
            ~C:clip_sprites%(xmin,ymin,xmax,ymax)
            ~C:print_mask%(frame,x,y,width,height,L:gfx,L:screen)
            ~C:print_invmask%(frame,x,y,width,height,L:gfx,L:screen)
            ~C:fast_sprite%(frame,x,y,width,height,L:gfx,L:screen)
            ~C:fast_mask%(frame,x,y,width,height,L:gfx,L:screen)
            ~C:fast_invmask%(frame,x,y,width,height,L:gfx,L:screen)
            ~C:store_sprite%(frame,x,y,width,height,L:gfx,L:screen)
            ~C:sprite_width%(scr_width)
ARGUMENTS:
sprite      (W) sprite frame to print
x           (W) center x coordinate to print sprite
y           (W) top y coorinate to print sprite
width       (W) width of sprite, either 16 or 32
height      (W) height of sprite, between 1-48
number      (W) number of sprites to print
xmin/ymin   (W) top left coordinates of clipping window
xmax/ymax   (W) bottom right coordinates of clipping window
gfx         (L) address of sprite graphics
records     (L) address of the sprite records, each are 26 bytes long
screen      (L) the screen address at which the sprites are to be
                printed.
scr_width   (W) screen width in bytes

The first command,  PRINT_SPRITE is for printing one sprite at a  time. 
It  is print only and cannot be erased.  It is used in particular  when 
the background screen is constantly redrawn,  thus erasing the sprites. 
The  mapper command is a good example of this,  as the area behind  the 
sprite  is  not  saved it is slightly  faster  than  the  PRINT_SPRITES 
command.

The  second command,  PRINT_SPRITES is a complex sprite handler and  is 
used  ONLY  WHEN  SCREEN SWITCHING IS USED.  It can print  all  of  the 
sprites  in one go and handles the erasing of the sprites.  To use  the 
command  you must create a sprite record for each sprite which is  laid 
out as follows :
 
     Offset  Length  Name       Function

       0       W     Mode       0=no print, >0=print
       2       L     Graphics   Pointer to sprite graphics location
       6       W     Frame      Sprite frame number
       8       W     X          X coordinate of sprite
       10      W     Y          Y coordinate of sprite
       12      W     Width      0=16 pixels, 1=32 pixels
       14      W     Height     Height of sprite in pixels       
       16      W     Size       Number of bytes for sprite graphics
       18      L     Buffer_1   Buffer area for sprite deletion
       22      L     Buffer_2   Buffer area for sprite deletion
 Total 26 bytes

The  command will print all sprites with a mode value other than  zero. 
The  size of a 16 width sprite is calculated from size=10*height and  a 
32 width sprite is size=20*height.  The buffer areas are very important 
and  must be understood.  When a sprite is printed the area behind  the 
sprite  is  saved  so that when the sprite is moved  the  area  can  be 
replaced. Sprites are printed on two workscreens using screen switching 
to  avoid any flicker,  therefore each sprite needs a buffer  for  each 
screen.  You must set up an area of memory that the sprite can use as a 
buffer and place the addresses in the Buffer_1 and Buffer_2  locations. 
The  number of bytes required for a 16 width sprite  are  (16*height)+8 
and for a 32 width sprite (24*height)+8 per buffer.

Example: You are using three sprites, two 16x16 and one 32x48.

     A 16x16 sprite needs 2*((16*16)+8)=528 bytes buffer
     A 32x32 sprite needs 2*((24*48)+8)=2320 bytes buffer

     Buffer area = (2*528)+2320
                 = 3376 bytes

     Using the procedures defined in SETUP.GFA, the setup 
     routine would be:

     nspr=3                              ! Number of sprites
     DIM records|(26*nspr)               ! Space for 3 sprite records
     records%=V:records|(0)              ! records%, pointer to records
     DIM buffer|(3376)                   ! Area for sprite buffers
     buffer%=V:buffer|(0)                ! buffer%, pointer to buffer area
     set_sprite(0,1,graphics16%,16,16)   ! Set sprite record  
     set_sprite(1,1,graphics16%,16,16)
     set_sprite(2,1,graphics32%,32,32)    

     (See technical documentation for more details)

NOTE:   It is not wise to alter the size of a sprite while it is  being 
printed  as the buffers will also change in size.  You may only  change 
the  size if it is becoming smaller (this means that some buffer  space 
is being wasted).

You  can clip the sprites with the clip_sprites command.  Supply the  x 
and  y  minimum and then the x and y maximum.  The x  minimum  must  be 
divisable by 16 and x maximum must be divisable by 16 minus 1.

        ie, For full screen clipping

                ~C:clip_sprites%(0,0,319,199)

ADDITIONAL NOTE:  The  X coordinate of the sprite is the centre of  the 
sprite,  therefore  printing a 16x or a 32x sprite at an x location  of 
160  will print them both centred on the screen.  The Y  coordinate  in 
both cases is the top of the sprite.

The  PRINT_MASK  command prints the sprite's mask on all  four  planes, 
making  the sprite appear in solid colour 15 which is  commonly  white. 
This command is ideal for making sprites flash when they are hit.  This 
is  also  ideal  for sprites such as small bullets as  it  prints  much 
faster than a normal coloured sprite.

The  PRINT_INVMASK  command  will erase the mask on  all  four  planes, 
making  the  sprite appear in solid colour 0 which  is  the  background 
colour. This command is ideal for creating shadows.

Preshifted  sprites  are now supported with the  commands  FAST_SPRITE, 
FAST_MASK  and FAST_INVMASK.  Preshifting means that the  graphics  are 
stored  16 times,  each rotated by one pixel which speeds  up  printing 
annormously.  The  drawback  is  the huge amount of  memory  they  use, 
therefore animation is basically out of the question,  but if you  only 
have  a  few  frames  and a large number  of  on  screen  sprites  then 
preshifting  is  ideal.  Use the PRESHIFT.GFA program  in  the  UTILITY 
folder  to  load Degas Elite screens and store  sprites  in  preshifted 
format.

The  command STORE_SPRITE allows you to retrieve graphics  direct  from 
the  screen,  similar to the GFA GET command.  Unlike creating  sprites 
from within the art package you DO NOT need to create a mask underneath 
the  sprite as the command creates its own mask,  the  disadvantage  of 
this is that any part within the sprite drawn in the background  colour 
will be transparent.

The  final  command SPRITE_WIDTH is only for use with the STE  and  the 
SPLIT_SCREEN command.  As the STE allows you to define a larger  screen 
which  may be many times wider than a standard screen this  command  is 
needed to tell the sprite commands to take this into account. The width 
of the screen in bytes must be passed to it,  160 for a normal  screen. 
The  default  width is 160 bytes so there's no need to set  it  if  you 
haven't changed the screen width. See the SPLIT_SCREEN command for more 
details.

NOTE: As this routine is so large an additional cut down routine called 
OSPRITES.INL  can be used which is only 2510 bytes long.  This  routine 
only has the first four commands and no masks,  inverse masks, preshif-
ting or sprite saving are included.

   Eg, INLINE sprites%,2510
       print_sprite%=sprites%
       print_sprites%=sprites%+4
       erase_sprites%=sprites%+8
       clip_sprites%=sprites%+12
       sprite_width%=sprites%+16

-----------------------------------------------------------------------

FILE:       STARS.INL
SETUP:      INLINE stars%,5918
            setup_stars%=stars%
            plot_stars%=stars%+4
            move_stars%=stars%+8
SYNTAX:     ~C:setup_stars%(stars,pers,cx,cy,xmin,ymin,xmax,ymax)
            ~C:plot_stars%(L:screen)
            ~C:move_stars%(xinc,yinc,zinc)
ARGUMENTS:
stars       (W) number of stars, max of 200
pers        (W) the perspective constant, usually around 200
cx/cy       (W) x/y center of starfield
xmin/ymin   (W) top left x/y of clipping window
xmax/ymax   (W) bottom right x/y of clipping window
screen      (L) screen address to plot stars
xinc        (W) horizonal star movement
yinc        (W) vertical star movement
zinc        (W) depth star movement

These commands provide a 'real' 3D starfield, unlike the parallax stars 
these commands also allow you to move into or outof the starfield.

The perspective constant distorts the depth of the starfield, the lower 
the  value  the  more depth and the higher the value  the  flatter  the 
starfield becomes. Values from 100-300 give the best results.

Like the parallax stars this routine also uses the first two bit planes 
only and has the same colouring of the stars.  If you do not need any z 
movement then the parallax star routine is faster.

-----------------------------------------------------------------------

FILE:       STE_MAP.INL
SETUP:      INLINE ste_mapper%,906
SYNTAX:     ste_x=C:ste_mapper%(x,y,height,L:map,L:gfx,L:screen)
ARGUMENTS:
x           (W) x pixel position offset
y           (W) y pixel position offset
height      (W) height in 16x16 pixels blocks to be displayed
map         (L) pointer to map data
gfx         (L) pointer to graphics data
screen      (L) screen address to print map
RETURNS:
ste_x       (W) hardware scroll offset 0-15

STE ONLY:

This  command does not work on its own but MUST be used in  conjunction 
with  the  SCREEN_SPLIT command.  The reason for this is that  to  take 
advantage of the STE hardware scrolling you must first set up a  screen 
which  is  wider than the normal 160 bytes.  In this  case  the  screen 
should be set with a width of 168 which gives you an extra 16 pixels on 
the right hand side of the screen.

On  its  own this command this command does not give  pixel  horizontal 
scrolling and is equivalent to the V_MAPPER command,  except that  this 
command  prints  on  a  168 byte width screen and not  160  as  in  the 
V_MAPPER case.  The command returns the hardware pixel offset which  in 
turn is passed onto the SPLIT_SCREEN command,  together these  commands 
produce extremely fast multidirectional scrolling.

IMPORTANT:  Unlike the MAPPER command which uses a huge 3968 bytes  per 
graphics block for pixel scrolling this command only uses 128 bytes per 
block  !  In  the DESIGN2 map designer you must remember  to  save  the 
graphics in vertical format NOT multidirectional format.  Also remember 
to use ~C:sprite_width(168) before using the sprite commands.

When  it comes to printing sprites combined with this routine you  MUST 
subtract the ste_x value from each x sprite position.  If you do not do 
this then all of the sprites will jerk very annoyingly.

The  STE PLATFORM game and STE MAPPER examples show exactly how to  use 
this command with the SPLIT_SCREEN and SPRITES commands.

-----------------------------------------------------------------------

FILE:       STE_SND.INL
SETUP:      INLINE ste_sound%,308
            ste_sample%=ste_sound%+4
            ste_playing%=ste_sound%+8
SYNTAX:     ~C:ste_sound%(volume,bass,treble,mixer)
            ~C:ste_sample%(L:sample,L:length,frequency,loop,mode)
            playing=C:ste_playing%()
            ~C:ste_off%()
ARGUMENTS:
volume      (W) sets master volume, 0-40
bass        (W) sets bass, 0-12
treble      (W) sets treble, 0-12
mixer       (W) 0=-12db, 1=mix with soundchip, 2=do not mix
sample      (L) sample address
length      (L) length of sample
frequency   (W) 0=6.25kHz, 1=12.5kHz, 2=25kHz and 3=50kHz
loop        (W) 0=loop off, 1=loop on
mode        (W) 0=mono, 1=stereo playback
RETURNS:
playing     (W) return -1 if sample is still playing

STE ONLY:

These  commands allow you to control the DMA playback which  I  presume 
can also be used for the Falcon.  The STE_SOUND command should be  used 
first  to  set  up how you would like the playback to  sound  and  also 
whether the playback should be mixed with the ST soundchip.  Personally 
I  like  plenty  of bass with some treble with values of  8  for  both. 
Should  you use the STE_SOUND as sound is playing then there may  be  a 
second  or two delay before the playback is affected.  When you  switch 
your computer on the default volume is 40 and bass and treble are 6.

DMA  samples are SIGNED as are samples played by the SAM_PLAY  command. 
If a sample sounds distorted it is probably unsigned and so you can use 
the SAM_CONVERT command from the SAM_PLAY routines.  Stereo samples are 
made from words,  the high byte is the left channel and the low byte is 
the right channel.

STE_OFF  is  used  to switch the DMA off causing  any  playback  to  be 
immediately stopped.

NOTE: Samples must be word aligned and so no odd addresses are allowed.

-----------------------------------------------------------------------

FILE:       TEXT.INL
SETUP:      INLINE text%,444
SYNTAX:     ~C:text%(x,y,length,colour,L:text,L:font,L:screen)
ARGUMENTS:
x           (W) x position 0-39
y           (W) y position 0-24
length      (W) length of text string
colour      (W) colour of font 0-16
text        (L) pointer to text string
font        (L) pointer to font data
screen      (L) pointer to font destination screen

This  is  a substitute for the PRINT command which is very  very  slow. 
This  command is much faster and also allows you to have as many  fonts 
as you like. If you want to design a new font you must design it in the 
art  package  and save it in Degas Elite format.  Draw it in  the  last 
colour (15) and then run the program SAVEFONT.GFA in the UTILTY folder. 
You must design the characters from 32 to 126 (SPACE to '~') which will 
take up 760 bytes.

You can have multicoloured fonts by specifying colour 16. The font must 
be saved as multicoloured in the SAVEFONT.GFA program and will take  up 
3040  bytes.  You  must  remember to set the palette  to  that  of  the 
original Degas Elite file.

Whether your printing a single or multicolour font,  it can be  printed 
in x-ray mode by adding 128 to the colour. This will cause parts of the 
text that are drawn in colour 0 to be transparent

NOTE:  The  example  program TEXT.GFA shows a good example of  using  a 
procedure to simplify the command.

-----------------------------------------------------------------------

FILE:       TEXT_PRO.INL
SETUP:      INLINE text_pro%,388
SYNTAX:     ~C:text_pro%(x,y,length,L:text,L:font,L:screen,mode)
ARGUMENTS:
x           (W) x position of text 0-319
y           (W) y position of text 0-199
length      (W) length of string
text        (L) pointer to text string
font        (L) pointer to font graphics
screen      (L) pointer to font destination screen
mode        (W) selects solid or x-ray mode

This command replaces the 64 column font printer in previous  versions. 
Exactly  the same 64 column font can be printed with this  command  and 
with  the added advantage that characters can be defined as  any  width 
from 1 to 8 pixels wide.

To  define  your own proportional font you will need  to  arrange  your 
characters  on an 8x8 pixel grid.  The first row of  characters  should 
appear  on the second row of the screen and the next row of  characters 
another two rows down from that.  Then above each character you need to 
draw a line in colour 15 which defines the width of the character.  See 
the  PROPORTN.PC1 file in the FONTS folder to see the  correct  layout. 
Once  you have defined the font you must save it with the  SAVEFONT.GFA 
program in the UTILITY folder.

Proportional  fonts  are 3167 bytes long and have the  correct  palette 
included in the font data. eg, ~XBIOS(6,L:font%)

------------------------------------------------------------------------

FILE:       VIEW_512.INL
SETUP:      INLINE view_512%,738
SYNTAX:     ~C:view_512%(L:picture,L:screen)
            ~C:unpack_spc%(L:source,L:destination)
ARGUMENTS:
picture     (L) pointer to the spectrum 512 screen
screen      (L) pointer to the screen address
source      (L) source address of spc screen
destination (L) destination address of unpacked spc screen

This command is used to display uncompressed spectrum 512 (SPU)  files. 
As  this routine is very CPU hungry it is not possible to  do  anything 
while  the picture is being displayed,  the routine just waits until  a 
key is pressed.

If  you've  loaded an SPC (compressed) file then first  use  UNPACK_SPC 
before you call VIEW_512.

------------------------------------------------------------------------

FILE:       V_MAPPER.INL
SETUP:      INLINE v_mapper%,364
SYNTAX:     ~C:v_mapper%(x,y,width,height,L:map,L:gfx,L:screen)
ARGUMENTS:
x/y         (W) top left x/y pixel position within map
width       (W) number of horizontal 16x16 blocks to print
height      (W) number of vertical 16x16 blocks to print
map         (L) pointer to map data
gfx         (L) pointer to map graphics
screen      (L) screen address to print map

To  complement  the  multidirectional scroller,  this  command  is  for 
vertical  scrolling maps.  It is ideal for vertical scrolling  shoot-em 
ups.  This command can replace the older PRINT_MAP command, although is 
does  not  have the flags included within the map but must  be  created 
separately.

An x coordinate parameter has been included to give 16 pixel scrolling. 
This  can be used to give burst scrolling for a platform game  as  this 
command  is much faster than the mapper command and also uses  a  1/7th 
less graphic data ! (How about writing a Rick Dangerous style game !)

------------------------------------------------------------------------

FILE:       V_WIPE.INL
SETUP:      INLINE v_wipe%,200
SYNTAX:     ~C:v_wipe%(width,L:screen,L:buffer)
ARGUMENTS:
height      (W) number of 16 pixel strips
screen      (L) current screen
buffer      (L) new screen

This  is the second special effects clear/change  screen  command.  The 
buffer  screen is scrolled onto the current screen in vertical  strips, 
up and down on alternate strips.

A width of 1 will gives 20 strips each strip being 16 pixels wide.

As with the H_WIPE this command it carried out as fast as possible.

------------------------------------------------------------------------

FILE:       WAIT_VBI.INL
SETUP:      INLINE wvbi%,230
            counter_on%=wvbi%
            counter_off%=wvbi%+4
            wait%=wvbi%+8
            swap_sync%=wvbi%+12
SYNTAX:     ~C:counter_on%()
            ~C:counter_off%()
            ~C:wait%(frames)
            ~C:swap_sync%(frames,L:logical,L:physical)
ARGUMENTS:
frames      (W) delay in 1/50ths of a second
logical     (L) address of logical screen
physical    (L) address of physical screen

Don't  you  just hate games that suddenly speed up  when  there's  less 
action  on the screen ?  Well these commands are used to  regulate  the 
speed  by  waiting  on the vertical blank  interrupt  until  a  counter 
reaches  the required frame rate.  Use COUNTER_ON at the start  of  the 
program  to set up a 50Hz counter.  If you want a program to run at  50 
fps then use ~C:wait%(0) which will wait for one VSYNC.  If the program 
occasionally runs over into 25 fps then you will notice the speed  will 
jerk, so you can then use ~C:wait%(1) to make the program always run at 
25 fps. Most games run at 17 or 13 frames per second so use values of 2 
or 3 in ~C:wait%.  Always use COUNTER_OFF at the end of your program to 
remove the interrupt patch, otherwise the program could crash on exit.

If  your program uses screen switching then use swap_sync to  flip  the 
screens.  The  usual  method of screen switching is to  use  the  XBIOS 
command  :  ~XBIOS(5,l:logical%,l:physical%,-1)  followed by  a  VSYNC, 
replace  these lines of your program with the SWAP_SYNC command and  it 
will  time your programs beautifully.  The first parameter is used  the 
same as the wait command,  0 for 50 fps,  1 for 25 fps,  2 for 17  fps, 
etc.

------------------------------------------------------------------------ 

          Terry King (Copyright 1993-95) Ninth Wave Software

