
                   CALAMUS FONT DESCRIPTION AND FONT ROUTINES
                   ==========================================

                                By Peter D Hibbs

     This document describes the format of  the  Calamus font files (as far
     as I know it) and  describes  in  some  detail a suite of sub-routines
     which can be used by a  machine code programmer to incorporate Calamus
     fonts into his program code.

     The complete documentation package consists of this document, a number
     of pictures in IMG format which  should  be viewed in conjunction with
     this text and a group of  reference sheet files describing the various
     sub-routines. If you are  likely  to  use  these  routines in your own
     program I would strongly advise  that  the  text  and picture files be
     imported into your favourite DTP or  WP  program  and printed out as a
     single document.  The  sub-routine  reference  sheets  should  also be
     printed and stored in an A4 binder for use when writing your software.

     The software package  comprises  the  source  file (CFN_CODES.S) which
     incorporates all the necessary sub-routines  and a short demonstration
     Calamus font program (CFN_DEMO.S)  which  illustrates  the  use of the
     main sub-routines.


     INTRODUCTION.
     -------------
     This document is split into three  main  sections, the first shows the
     Calamus font file format, the  second  describes the main sub-routines
     and how to use them in a  program  and the third section provides more
     information about the main sub-routines that is not covered in section
     2. If you only need  to  use  a  Calamus  font  in  a program you will
     probably only need to  read  the  first  two  sections, however, it is
     quite possible that the existing  routines  don't do exactly what your
     program requires and you may need  to modify the routines slightly. In
     this case it is obviously  important  that  the  exact workings of the
     code is understood before any  modifications  can  be made. Be warned,
     however, this code is fairly complex and even though it is fairly well
     commented, it  is  not  possible  to  explain  the  reason  for  EVERY
     instruction.

     The following files should be present on this disk :-

     CFN_CODE.DOC    This document file.

     In the IMAGES folder-

     FIG1.IMG        Figure 1 image file. (Guidelines)
     FIG2.IMG        Figure 2 image file. (Character store format)
     FIG3.IMG        Figure 3 image file. (Kerning outlines)
     FIG4.IMG        Figure 4 image file. (Character A outline)
     FIG5.IMG        Figure 5 image file. (Character O outline)
     FIG6.IMG        Figure 6 image file. (Horizontal line)

     In the REFERNCE folder-

     BLIT_CHR.DOC    'blit_char' sub-routine reference sheet.
     CALC_TOP.DOC    'calc_top' sub-routine reference sheet.
     MAKE_CHR.DOC    'make_char_set' sub-routine reference sheet.
     MAKE_IMG.DOC    'make_image' sub-routine reference sheet.
     OUTLINE.DOC     'outline'  sub-routine reference sheet.
     PATTERN.DOC     'pattern' sub-routine reference sheet.
     SHOW_CHR.DOC    'show_char' sub-routine reference sheet.
     SHOW_IMG.DOC    'show_image' sub-routine reference sheet.
     KERN.DOC        'calc_kern' sub-routine reference sheet.
     CLR_BUFF.DOC    'clear_buffer' sub-routine reference sheet.

     In the SOURCE folder-

     CFN_CODE.S      Calamus routines source file.
     BEZ_TAB.DAT     Bezier curve look up table data file.
     CFN_DEMO.S      Calamus font demonstration source code file.


                                   SECTION 1

                            The Calamus Font format.
                            ------------------------

     This information was taken from a PD document written by Chris McArlan
     and has been updated in parts, however, the function of some variables
     are not known although it does  not  affect  the operation of the sub-
     routines unduly. If you have  any  further  information on the unknown
     values perhaps you would let me know.

     A Calamus font file  is  divided  into  8  sections numbered 0-7, each
     section (except the first) being marked by a label in the format 0001,
     0002, etc.

     In the font file table shown below  the offset value is the address in
     hexadecimal relative to the start of the font data.

     The bytes value is the size of  the  data  in bytes shown as a decimal
     value.

     Any value in the  contents  column  shows  the  data that is generally
     present but may vary from font  to  font, if it is completely variable
     it is left blank.

     The description indicates the function of the data, if known.


     Offset  Bytes   Contents        Description

     0000    10      "CALAMUSCFN"    Identifier string
     000A    2       03E9            Unknown
     000C    2       0000            Unknown
     000E    2       0001            Unknown
     0010    4       00000000        Font No if registered
     0014    2       0000            Unknown
     0016    2       00E0            Max No of chrs (i.e. 224)
     0018    2       0020            ASCII code of first used character
     001A    2       0010            Add space value for letter spacing
     ----------------------------------------------------------------------
     001C    2       0001            Strings section label
     001E    2                       Length of font name
     0020    26                      Font name string in ASCII
     003A    2                       Length of creator string
     003C    26                      Creator string in ASCII
     0056    2                       Length of company string 1
     0058    26                      Company string 1 in ASCII
     0072    2                       Length of company string 2
     0074    26                      Company string 2 in ASCII
     ----------------------------------------------------------------------
     008E    2       0002            Bit image section label
     0090    2       00A0            Width of font bit image in pixels
     0092    2       0010            Height of font bit image in pixels
     0094    320                     Bit image data (10*16 words)
     ----------------------------------------------------------------------
     01D4    2       0003            Guide lines section label
     01D6    2                       Diff between top and bottom lines
     01D8    2                       Diff between left and right lines
     01DA    2                       Top line position
     01DC    2                       Ascender guide line
     01DE    2                       Xline (half line)
     01E0    2                       Base line
     01E2    2                       Descender guide line
     01E4    2                       Bottom guide line
     01E6    2                       Left vertical guide line
     01E8    2                       Middle vertical guide line
     01EA    2                       Right vertical guide line
     01EC    2       000C            Max user defined guide lines (12)
     01EE    96                      x1,y1,x2,y2, etc. (end = FFFF)
     024E    2       000C            Max user defined ellipses (12)
     0250    96                      x,y,r1,r2, etc (end = FFFF)
     ----------------------------------------------------------------------
     02B0    2       0004            Kerning section label
     02B2    2       00E0            No of displayable chrs (224)
     02B4    16*n                    n=value in previous word (usually 224)
                                     16 bytes per character
                                     1st 8 bytes=left kerning values for
                                     8 heights. 2nd 8 bytes=right kerning
                                     values for 8 heights. Values range
                                     from 0 to 255.
     ----------------------------------------------------------------------
     nnnn    2       0005            Character pointers section label
     nnnn    4       00000000        Encryption modifier for coded fonts
     nnnn    2       00E0            No of displayable characters (224)
     nnnn    4*n                     n=value in previous word (usually 224)
                                     Longword offsets to character data.
                                     Offset is from start of data block.
                                     Unused chrs have offset of $FFFFFFFE.
     ----------------------------------------------------------------------
     nnnn    2       0006            Character data section label
     nnnn    4                       Total number of bytes in chr table
     nnnn    nnnn                    Character data. Characters can be in
                                     any order and data is only present for
                                     used characters, i.e. unused chrs do
                                     not exist.
                                     Characters are defined by  a sequence
                                     of paths (a path is two points joined
                                     by a straight line or a bezier curve).
                                     The are four control codes :-

                                     0000 = start of a new path
                                     000F = end of character data
                                     0001 = connect with a straight line
                                     0002 = connect with a bezier curve
                                          (followed by two control points)
     ----------------------------------------------------------------------
     nnnn    2       0007            Character widths section label
     nnnn    2       00E0            No of displayable characters
     nnnn    2*n                     n=value in previous word (usually 224)
                                     Two bytes per character in chr order.
                                     1st byte is minimum x co-ord.
                                     2nd byte is maximum x co-ord.
                                     Both values scaled down by 64 so that
                                     they are in the range 0-255.
     ----------------------------------------------------------------------
     nnnn    2       FFFF            End of font data
     ----------------------------------------------------------------------

     The descriptions here are  fairly  brief  and  are  only intended as a
     quick reference, the values that are relevant to the font routines are
     discussed more fully in section 3 below.



                                   SECTION 2

                    Using the Calamus Font display routines.
                    ----------------------------------------

     There are two  basic  ways  that  the  font  routines  can  be used as
     described here, as usual there is no ideal  way and in this case it is
     a tradeoff between memory availability and speed.

     The first method is to  load  a  font  and  then generate a bit mapped
     image in RAM for each character at the required point size. Each image
     can then be blitted to  the  screen  when  required which gives a very
     fast screen display of  the  font  characters.  The  problem with this
     method is that the bit mapped images will  require a lot of RAM and if
     the program requires  several  different  fonts  at  lots of different
     point sizes the RAM required could be too much. If, on the other hand,
     the program only needs to use one font  at say one or two point sizes,
     this is probably the preferred method to use.

     The second method requires the font/s to be loaded into RAM and when a
     character is to be  displayed  on  screen  (or  printed)  the image is
     generated and stored in a temporary buffer and then blitted from there
     to the  screen  in  one  operation.  This  has  the  advantage  of not
     requiring too  much  memory  but  is  slower  since  it  takes  a  few
     milliseconds to format and copy each  character as it is required. The
     time it actually takes will, of  course,  depend on the point size and
     the complexity of the character.

     There are routines provided in the accompanying source code which will
     cater for both methods, the programmer  will  have to decide which one
     to use for each program.

     2.1  Memory problems.
     ---------------------
     Before looking  at  the  routines  in  detail  the  problem  of memory
     allocation first needs to be addressed.  As  well as a number of fixed
     length memory stores the routines  will  also require temporary buffer
     stores while the font data is being  processed and this can be quite a
     headache for the programmer.

     Firstly the font data itself  has  to  be  loaded into RAM and Calamus
     fonts can vary in size from about 9Kb to nearly 100Kb (I have not come
     across a  font  larger  than  this  although  I  suppose  it's  always
     possible).

     Secondly two temporary buffers of equal size are required to store the
     pixel co-ordinates of each point  in  the  outline of a font character
     when it is being formatted. The  size  of these buffers will depend on
     the point size of the  character  and  the complexity of the character
     shape. They are called the  'up_list'  and  the 'down_list' buffers in
     the source code.

     Thirdly the bit mapped images require  a  buffer, if the whole font is
     to be stored as a bit map the  buffer  will need to be quite large and
     will depend on the number of useable characters and the point size. If
     the characters are to be formatted only  as and when they are required
     the buffer can be much smaller.

     Unfortunately it is not easy  to  determine  the size of these various
     buffers before they are used  so  the  programmer  will either have to
     guess the maximum size of each buffer and allocate the required RAM as
     a ds.b pseudo-op in the BSS section  or use the Malloc TOS function to
     grab temporary memory  from  the  remaining  memory  pool.  As is well
     known, however, this  function  is  somewhat  fraught  with  bugs when
     blocks of RAM are  continually  being  allocated  and  released by the
     operating system. The  Calamus  DTP  program  itself  gets around this
     problem by grabbing virtually all  the  available  RAM on start up and
     using its own system of RAM allocation.

     There is not really any universal answer to this problem, each program
     should use the method which  is  most  appropriate. For instance, if a
     program only allows a maximum  point  size,  the  maximum size of each
     buffer can be  determined  (by  trial  and  error  or calculation, see
     section 3 below) and buffers allocated which will cater for the 'worst
     case' situation. If a program allows  the  user  to use any point size
     with numerous fonts (as in a  DTP  type  program for example) then the
     Calamus  program  method  would   probably   be  best,  albeit  rather
     complicated to program.

     The routines below generally assume  that  the buffers are pre-defined
     since it is easier to explain  how  to  use them. However, if they are
     allocated different addresses from  the  memory  pool  each time it is
     easy enough to modify the code to allow for this method.

     2.2  Summary of sub-routines.
     -----------------------------
     There are basically two  main  groups  of  sub-routines  in the source
     file. The first group  are  those  that  the  programmer will normally
     access from his program, the second  group  are called by the routines
     in the first group but would  not  normally  need  to be called by the
     programmer directly. However, since  programs  can  vary  so much, the
     function and operation of   both  groups  are  described below in case
     they are needed to be called directly  or  modified in some way by the
     programmer.

     The following list shows  the  sub-routines  that  are included in the
     source code file CFN_CODE.S together with  a VERY brief description of
     what they do, the data  sheets  included  with this document provide a
     more detailed description of  the  functions, input/output parameters,
     etc of each routine.

     S/R NAME        DESCRIPTION
     --------        -----------
     show_char       Blits a character from the bit image buffer to the
                     screen.

     show_image      Blits the font bit image that is stored in the font
                     data file to the screen. This routine does not form
                     part of the main font code but is provided for the
                     convenience of the programmer.

     make_char_set   Generates a complete set of bit images for each valid
                     character in RAM at the specified point size.

     make_image      Generates a bit image of a specified character in RAM
                     at a specified point size. Used mainly by the above
                     routine but can be called by itself.

     blit_char       Blits a character from a bit image buffer to the
                     screen.

     calc_top        Calculates the top edge offset, max height, chr width
                     and baseline offset for complete character set. The
                     outputs from this routine are stored in various RAM
                     stores and used by several other routines.

     calc_kern       Calculates the x co-ordinate of the next character
                     image when kerning is being used.

     clr_buffer      Clears the image buffer of the next displayed chr.

     pattern         Modifies a character image in RAM with a bit pattern.

     outline         Generates an outline image of a font character.

     ----------------------- Internal routines ----------------------------

     end_poly        Checks if both ends of a polyline are for the same
                     direction.

     fill_char       Fills in an outline character image.

     draw_bezier     Draws a bezier curve line in RAM.

     bez_calc        Calculates the bezier curve x and y co-ordinates.

     poly_line       Draws a polyline in RAM.

     plot_line       Draws a straight line in RAM.

     draw_pix        Draws a single pixel in RAM.

     fill_list       Generates a list of pixel co-ordinates in a buffer.

     line_fill       Fills in a horizontal line between two x co-ordinates.

     sort_list       Sorts a list of y/x co-ordinates into numerical order.

     laddr_sr        } SIF maths routines (see ICTARI Issue 14)
     lmul_sr         }


     2.3  Calamus Font character format.
     -----------------------------------
     Before describing how to use the routines in a program it is necessary
     to understand how the character data  is  stored  in the font file and
     how the routines need to access the data.

     Each character in the font  is  originally constructed on an imaginary
     grid that is 16320 points  high  and  16320 points wide (although some
     fonts have values up to 16384 but  we  will ignore these for now). The
     top left corner of the  grid  will  start  at  0  and the bottom right
     corner will end at  16320  (fortunately  for  the  programmer the same
     layout as the ST screen co-ordinates).  Each straight line in the font
     is stored as an x/y co-ordinate for  the  start of the line and an x/y
     co-ordinate for the end of the line.  Each bezier curve is stored as a
     start co-ordinate followed  by  two  control  point co-ordinates which
     determine the radius of the curve. Control  codes at the start of each
     line define the type of line or  define the end of the character data,
     all co-ordinates are  stored  as  16  bit  values  (words).  Section 3
     describes the format of the data in more detail.

     Before a font can be used the character  has to be scaled down so that
     it will fit on the screen  or  print out. When the appropriate routine
     is called (make_image) every co-ordinate is divided by scale factor to
     generate a  character  bit  image  of  the  required  size.  The first
     problem, therefore, is to  decide  what  the  divide factor should be.
     Since fonts are usually  measured  in  point  sizes  the divide factor
     should be calculated so that the  resultant  bit image is the required
     point size. However, the point size will also depend on the resolution
     of the output device, i.e. screen  or  printer. The divide value for a
     given point size will obviously  be  different for the screen (hi-rez)
     with a resolution of about 80 dpi  compared  with a printer of say 300
     dpi. With one point being 1/72 inch  the  formula below can be used to
     calculate the divide factor :-

                              h  * 72
             divide factor = --------
                             dpi * pt

     where h   is the maximum height of the character,
           dpi is the resolution of the output device in dots/inch,
           pt  is the required point size and
           72  is the number of points in one inch.

     The last three parameters are  straightforward,  the  first one, h, is
     not quite so straightforward  however.  It  might  be thought at first
     that this value would be  16320  since  that  is  the maximum that any
     character can be  in  the  original  grid.  However,  when  a  font is
     designed with a font designer, the  characters can be made any height.
     Some fonts use almost the full  height  of  the grid area while others
     make the characters quite small with lots  of space above or below the
     characters. If this  anomaly  is  not  corrected,  fonts  that are all
     supposed to be the same size will come out in all different sizes.

     As shown in Fig 1 the font data  also includes a number of guide lines
     which are used when designing  the  fonts.  The  two that are relevant
     here are the top and bottom lines  which define the highest point (the
     lowest y  co-ordinate)  and  the  lowest  point  (the  highest  y  co-
     ordinate). Unfortunately,  even  these  can  be  changed  by  the font
     designer so the problem still exists but  this is the best that can be
     done and anyway, that's what  Calamus  itself  uses when it calculates
     the point sizes. Conveniently, there is  a store (at offset $01D6 from
     the start of the font data)  which contains the difference between the
     top and bottom lines which, in  effect,  defines the maximum height of
     any character in the font and  this  value  should be used in place of
     the h parameter in the formula  above. Actually even this parameter is
     somewhat arbitrary since there  are  some  fonts which have characters
     that extend above and below these  lines.  The moral here, I think, is
     to generally ignore most of the extra guidelines, limits, etc that are
     included in the font data.

     As an example, suppose we want a character  with a point size of 24 to
     print on a printer at 300 dpi using the TROJAN.CFN font.

                             15136 * 72
             divide factor = ----------  = 151.36
                              300  * 24

     so the divide  factor  will  be  151  which  should  be  stored in the
     'font_size' store whenever a new font  size  is used. Warning ! Do not
     use a point size less than 2 or the program will bomb out.


                             [ Insert Fig 1 here ]


     2.4  Mode 1. Generating a complete character set.
     -------------------------------------------------
     As mentioned above, there  are  two  main  methods  to use the Calamus
     fonts, generating a bit image for  every  character in a RAM buffer or
     generating each character image as it is needed. The first method will
     be discussed next.

     The basic idea here is to load a font into a RAM buffer, then call the
     'make_char_set' sub-routine which generates a bit mapped image of each
     valid character in a RAM buffer and  also a look table which holds the
     start addresses of each character image.  When this has been completed
     (and provided there were  no  errors)  the 'show_char' sub-routine can
     then be used to display any character on screen.

     Follow these steps :-

     (1)  Load the required font into a  buffer, it will be assumed for the
     moment that this buffer is called the 'font_buffer'.

     (2)  Allocate a bit image buffer to hold the character images and copy
     the start address of this RAM buffer  into the 'chr_addr' store i.e. a
     32 bit value. Make sure  that  the  buffer  has  first been cleared to
     zeros since the bit image code  only  writes  ones  to the RAM and not
     zeros. If this is not done  the  next  font  (if there is one) will be
     superimposed on the first one.

     (3)  Copy the end address  of  the  bit  image  buffer into the 32 bit
     store 'max_ram'. The code which generates  the images will return with
     an error code 2 if  the  address  pointer  reaches this address and so
     prevents a system crash if there is insufficient RAM available.

     (4)  Calculate the divide factor  (see  section  2.3) and copy it into
     the 'font_size' store.

     (5)  Set register a0 to the start of the font data buffer.

     (6)  Set register a5 to the start  of a 224 longword buffer which will
     be used as a look-up table.  This  store should be labelled 'ca_table'
     and is used by the display routine. Obviously if more than one font is
     loaded a bit image buffer  and  ca_table  buffer  will be required for
     each font.

     (7)  Allocate RAM for  the  sort  buffers.  These  are two equal sized
     buffers labelled  'up_list'  and  'down_list'  which  should  be large
     enough to store the character  with  the  most pixel co-ordinates. See
     section 3 for more information on these  buffers. The safest way is to
     make them fairly large initially and  then  reduce to the minimum size
     when the code has been tested satisfactorily.

     (8)  Call the 'make_char_set' sub-routine.  On return from the routine
     the d0 register should be tested,  if  it  is zero the bit images have
     been stored OK, if  it  is  a  value  between  1  and  3  an error has
     occurred. The error codes are as follows :-

     Error 1  The data in the 'font_buffer' is not a valid Calamus font.
     Error 2  There insufficient RAM for the bit image data.
     Error 3  There was an error in  the sort routine, either a faulty font
              or insufficient memory available in the sort buffers.

     A number of other parameters  are  also  returned by the routine which
     can be used by the program when displaying the characters.

     The 'chr_addr' store now  holds  the  address  following the last used
     address of the bit image  buffer  and  so  indicates the next free RAM
     address if any further data is required to be stored.

     The remaining parameters first require some explanation on how the bit
     image data is stored in RAM. When the font characters are formatted as
     bit images in RAM they are each  stored  in  a buffer which will be so
     many bytes wide by so many  scan  lines high, each character store for
     any given font being the same  size.  The  image can then be copied to
     the screen (or printer) using the  BitBlt  function. The exact size of
     the stores  will,  of  course,  be  determined  by  the  divide factor
     discussed earlier.

     Suppose, for example, that the divide  factor  was 200 and the maximum
     height (and width) was 16320 pixels. This would give a character store
     height of 81 scan lines and a width  of  81 pixels which is equal to a
     width of 12 bytes (the width is always rounded up to an even number of
     bytes). The total character store size, therefore, is 81*12=972 bytes.
     In addition each character store has an  extra four words at the start
     of the store which holds the width  of  the store in bytes, the height
     of the store in scan lines, the left edge in pixels and the right edge
     in pixels. There will be one of  these stores for each valid character
     in the whole font. So the total  bit image buffer store size would, in
     this example, be (972+8)*(No of valid chrs) bytes.

     However, this use of memory is  a  bit wasteful because, as was stated
     earlier, very few font characters  use  the  full  height of the pixel
     grid which means that,  even  after  being  scaled  down,  there are a
     number of scan lines above  and  below  the  character image which are
     just  left  blank.  The  routine  (actually  the  'calc_top'  routine)
     attempts to save this memory by  calculating the number of blank lines
     above the character image  and  subtracting  that  value from the each
     character buffer. However it  is  not  practical  to  have a different
     value for each character  since  this  would  make the display routine
     very complicated so the routine  finds  the tallest character and uses
     the value from that one to  calculate  the  offset. This value is then
     stored in the 't_edge' store for  use  by  other routines. Fig 2 shows
     the method in graphical form and should be easier to understand.

     A similar method is used to  remove  the  bottom margin except in this
     case the height of  the  character  is  calculated  in  scan lines and
     stored in the  'font_height'  store.  Since  this  value  is the total
     number of scan lines  required  for  each  character, the routine only
     needs to store this number in  the  character store so that the bottom
     margin is automatically removed. In fact  an  extra scan line is added
     to the top and bottom  of  the  character  store so that the character
     images do not quite touch the  top  or  bottom  edges of the box. Note
     that this value is also  stored  in  the  second word of the character
     store header for use by the display routines.

     A similar  problem  exists  for  the  left  and  right  edges  of each
     character store but it is not so  easy to eliminate these and also the
     wastage is less of a problem since  the pixel values are divided by 16
     for the word size stores.  However,  since  there is sometimes a large
     amount of space on either side of some characters (letter I, figure 1,
     etc) it is still necessary to  eliminate  this when the characters are
     displayed. This problem is solved by calculating the x co-ordinates of
     the left and right edge of each character and storing this information
     in the header block for each  character. When the character is blitted
     to the screen the display  routine  only  uses the image between these
     two values and so a letter 'I'  may  be 5 pixels wide while the letter
     'W' may be 25  pixels  wide.  These  values  are calculated within the
     'make_image' sub-routine and are stored  in  the  3rd and 4th words of
     the character store header block.  As  with  the  height, one pixel is
     added to the left and right edges so that the character image does not
     quite touch the edge of the character cell area.

     During a program it may be necessary  to  find the size of the largest
     character in a font  so  that  positioning  or  spacing  of a group of
     characters from the same (or different)  fonts  can be set. It is easy
     enough to find the width  of  any  individual character by subtracting
     the left edge x co-ordinate from the right edge x co-ordinate found in
     that characters header  block.  To  find  the  widest  character would
     involve a lot more code so the  'make_char_set' returns a value in the
     store 'max_width' which defines  the  width  in  pixels  of the widest
     character in that font.

     Another important parameter is the base line co-ordinate. If a line of
     characters are being displayed on  screen  it  is normal that they all
     sit on the same baseline. This  is  not  too  much of a problem if the
     characters are all part of the same  font  and are the same point size
     since they all have the  same  character height and will automatically
     line up correctly but if  characters  of  different fonts or different
     point sizes are displayed together this may  not be the case. For this
     reason the routine also returns a  baseline offset value for each font
     which can be used to  align  the  baselines of characters of different
     sizes. The value is actually the  number  of pixels between the top of
     the character cell and the baseline for that font. When a character is
     displayed on screen the 'show_char' routine is  passed the x and y co-
     ordinates for the screen location which  refer  to the top left corner
     pixel of the character  image.  To  ensure  that  the baselines of two
     different size characters line up  correctly,  first  define the y co-
     ordinate on screen  for  the  baseline,  subtract  the baseline offset
     value from this and  then  use  that  value  as  the y co-ordinate for
     'show_char' sub-routine. Fig 2 below shows the character cell format.

                             [ Insert Fig 2 here ]

     When the bit image data has been  generated and checked for error, the
     next stage is to display a  character  on  screen (we will worry about
     printing later). This is  done  with  the  'show_char' sub-routine and
     requires a number of input parameters.

     First set register d0 to the required x co-ordinate and register d1 to
     the  required  y  co-ordinate.   Unlike   the  GEM  character  display
     functions, the reference point for the  character cell is the top left
     corner of the image. Note that these  values can be negative values if
     the reference co-ordinate is  off  the  screen  area, the routine will
     just show the area of  the  character  which  is visible on screen. As
     mentioned above, the y co-ordinate should be calculated in conjunction
     with 'baseline' variable if the  characters  are  to be displayed in a
     horizontal line. Don't forget that if  there  is more than one font or
     more than one size  of  font  in  use,  there  should  be a 'baseline'
     variable stored for each font or font size.

     Copy the ASCII code of the character to be displayed into register d2.
     This should be in the range $20-$FF, any value outside this range will
     be ignored and will return an error  code. If the character is not one
     available in the font, it will also  be ignored and an error returned.
     Note that no registers are changed by this routine.

     Set  register  a0  to  the  start  of  the  character  address  table,
     'ca_table', which holds the start address of each character bit image.
     Remember that if more than one  font  is  being  used, there will be a
     'ca_table'  for  each  one   which   could  be  labelled  'ca1_table',
     'ca2_table', etc.

     The display routine is  also  subject  to  the  VDI clipping rectangle
     function if it is enabled.

     Since the routine uses the  'vrt_cpyfm'  VDI  function, the source and
     destination Memory Form Definition Blocks  (mfdb) must also be defined
     in RAM as two 20 word stores labelled 'srce_mfdb' and 'dest_mfdb'.

     Turn off the mouse cursor, if it is visible.

     The 'show_char' routine can  now  be  called  to  display the required
     character on screen. If this is successful,  the CPU Z flag is cleared
     (bne) and if not (due to the  errors  mentioned above) the flag is set
     (beq). The user program  should  test  this  flag  after  each call to
     confirm that the image was displayed.

     There are two  more  parameters  which  will  affect  the  display and
     although they are not passed to  the routine from the calling program,
     they may still need to be set up within the program.

     Firstly the  'vrt_cpyfm'  function  (situated  near  the  end  of  the
     'show_char' sub-routine) can blit an  image  to  the  screen in one of
     four modes. In the routines supplied this parameter (the first one) is
     set to #1 (replace mode)  which  would  draw  a white rectangle with a
     black character inside on to  the  screen.  However, this would not be
     suitable if characters were close  together  or  close to other images
     and in this case the drawing  mode  should be set to #2 (transparent),
     #3 (XOR) or #4 (reverse transparent)  depending on the requirements of
     the program. This  information  could  be  passed  to  the  routine in
     another register (say d4-d7) or could be stored in a memory store.

     Secondly the 'vrt_cpyfm' function also allows the colours of the image
     to be set. Up until  now  it  has  been  assumed that the routines are
     working in monochrome but all the code supplied will work equally well
     in colour. The last two parameters  of the 'vrt_cpyfm' function define
     which pixels are set/reset when there  is  more than one colour plane.
     In the routine  these  are  set  to  #1  and  #0  which  gives a black
     character on a white background. These values can be changed to values
     between 0 and 3 for  medium  resolution  screens  or  0 and 15 for low
     resolution screens. Presumably more colours can  be used on the Falcon
     higher resolution screens but I  have  not  tried this. When selecting
     the colour values, however, bear in mind  that as 'vrt_cpyfm' is a VDI
     function the colour codes  are  not  the  same  values  as the palette
     codes. As in the case of  the  draw  mode above, these values could be
     passed to the routine in registers or memory stores.

     2.5  An example program.
     ------------------------
     A typical program code to use a Calamus font could look like this :-

     program start   initialise GEM, etc, etc          Pgm Initialisation
                     ..
                     ..
                     lea     font_buffer,a0            Locate font buffer
                     bsr     load_font                 Load reqd font data
                     bsr     clr_image                 Clear i_buffer
                     move.l  #i_buffer,chr_addr        Locate image buffer
                     move.l  #i_buffer+100000,max_ram  Define 100Kb max RAM
                     move    #200,font_size            Set reqd font size
                     lea     font_buffer,a0            Locate font data
                     lea     ca_table,a5               Locate chr addresses
                     bsr     make_char_set             Generate images
                     tst     d0                        Chk for errors
                     bne     font_error                Branch if error
                     ..
                     ..


     loop            move    #100,d0                   Set x co-ord
                     move    #100,d1                   Set y co-ord
                     move    #'A',d2                   Set chr code
                     lea     ca_table,a0               Locate addr table
                     (set draw mode if reqd)
                     (set image colours if reqd)
                     v_hide_c                          Hide mouse if reqd
                     bsr     show_char                 Display character
                     beq     chr_error                 Branch if error
                     ..
                     ..

                     section BSS

     ca_table        ds.l    224                     Chr address table
     i_buffer        ds.b    100000                  Image buffer
     font_buffer     ds.b    100000                  Font buffer
     srce_mfdb       ds.w    20                      Source mfdb
     dest_mfdb       ds.w    20                      Destination mfdb
     + various other RAM stores (see CFN_CODE.S file)


     2.6  Mode 2. Generating individual characters.
     ----------------------------------------------
     The second method of using Calamus fonts  in a user program is to load
     the fonts required into  a  number  of  buffers  and then generate the
     image for a character as and when  it  is required to be displayed. As
     mentioned before,  this  is  slower  but  less  memory  intensive.  In
     practice the speed penalty is not a  major factor because if there are
     a lot of characters on screen they would generally be fairly small and
     thus do not take very much time to construct and if the characters are
     very large there would only be  a  small  number on screen to display.
     Note that the characters are first  constructed in a RAM buffer before
     being blitted to  the  screen  so  that  the  impression  given to the
     program user is that the images appear fairly quickly.

     Before a character can be displayed  there  are a number of steps that
     must first be taken.

     (1)  Load the required font/s into memory and record the start address
     of each font so that  the  program  can  access the required font data
     when it is required.

     This is all that is required initially. The next steps should be taken
     each time a font size is changed.

     (2)  Before a character can  be  displayed,  the size of the character
     cell has to be calculated from  the  required  font point size so that
     the blitter code knows the size of  the RAM area. Since this will vary
     with the point size, this operation must be done each time a new point
     size is chosen.  The  'calc_top'  sub-routine  calculates  the various
     values and returns them in four memory stores together with the number
     of actual characters available in the font.

     First set register a0 to the start  of  the font data for the required
     font. Next set the variable 'font_size'  to the required divide factor
     as discussed  earlier.  Now  call  the  'calc_top'  sub-routine  which
     returns five parameters in five memory stores.

     't_edge' holds the offset from the  top  of the character cell (before
     it is scaled down).

     'font_height' holds the height of the  character cells (in scan lines)
     after they have been scaled down.

     'char_width' holds the width  of  each  character  cell in bytes after
     being scaled down (always an even value).

     'base_line' holds the number  of  scan  lines  between  the top of the
     character cell and the base line.

     'chr_count' holds the  number  of  characters  used  in  the font, see
     section 3 for uses of this information.

     If the program has to display more  than one font and/or more than one
     point size simultaneously on  screen,  these  values  should be copied
     into a set of memory stores  which  will  then  be associated with the
     current font and point  size.  In  addition  to  these parameters, the
     current font_size value should also be saved since this is required to
     construct a character. No other  operations  are  now required until a
     character is to be displayed.

     (3)  To display a character the image has to be constructed first in a
     temporary buffer and then  blitted  to  the  screen.  The two routines
     which will do this are the 'make_image' and 'blit_char' sub-routines.

     Before the 'make_image' routine is called  a number of parameters must
     be initialised as follows :-

     Register a0 should be  set  to  the  start  of  the  font  data of the
     required font.

     Register d7 should be loaded with the ASCII code minus 32 ($20) of the
     character to be displayed. For  example  to  display the 'A' character
     ($41) the value $21 should be loaded into d7.

     The following four variables should be loaded with the values returned
     by the 'calc_top' routine or copied  from the temporary stores if they
     were   previously   saved.   They   are   'font_size',   'char_width',
     'font_height' and 't_edge'.

     The 'chr_addr'  variable  should  be  loaded  with  the  address  of a
     temporary buffer which must  be  large  enough  to  hold the character
     image. The buffer should be cleared to all zeros before the routine is
     called. Note  that  the  size  of  the  buffer  can  be  calculated by
     multiplying the value in  'char_width'  by  the value in 'font_height'
     and adding 8. The 'clr_buffer' routine in the source code provided can
     perform this function.

     Note also that the variable 'max_width'  also returns with a value but
     is only valid if all the characters are generated in sequence (as done
     by the 'make_char_set' routine) and should be ignored here.

     The 'make_image' routine can now be called and will construct an image
     in the temporary buffer, the format  of  the data will be identical to
     that used by  the  'make_char_set'  routine  discussed  earlier and is
     described in more detail in section 3 below.

     On return from the  'make_image'  routine  the  d0  register should be
     tested for any error codes. If the register is zero, the operation was
     successful and the buffer holds  the  image  data.  If the register is
     non-zero the following codes indicate the error type :-

     Error code 1. Specified character not present in font data.
     Error code 3. There was an error  in the sort routine, either a faulty
                   font or insufficient memory available in the sort 
                   buffers.

     This routine does not check  that  there  is sufficient memory for the
     operation since the buffer can  usually  be  made large enough for any
     character and in any case  it  is  very  easy  to  check that there is
     sufficient memory by using the calculation mentioned above.

     When the 'make_image' routine has  been called the 'blit_char' routine
     is then called to display the character. This routine is basically the
     same as the 'show_char' routine  without  the  look  up table code (in
     fact it is the latter part  of  the  routine). As with the 'show_char'
     routine, a number of parameters must first be set up as follows :-

     First set register d0 to the required x co-ordinate and register d1 to
     the required y co-ordinate using the 'base_line' offset if necessary.

     Copy the  start  address  of  the  temporary  buffer  which  holds the
     character image into register a0.

     Turn off the mouse cursor if it is showing.

     Call the 'blit_char' routine to display the image. Note that it is not
     necessary to check the Z  flag  on  return  from the routine since the
     character has already been checked with the previous routine.

     The VDI clipping rectangle, draw  mode  and colour parameters apply to
     this routine in  exactly  the  same  way  as  the  'show_char' routine
     mentioned earlier.


     2.7  An example program.
     ------------------------
     A typical program code to use a  Calamus font which uses just one font
     at one size could look like this :-

     program start   initialise GEM, etc, etc          Pgm Initialisation
                     ..
                     ..
                     lea     font_buffer,a0            Locate font buffer
                     bsr     load_font                 Load reqd font data
                     move    #200,font_size            Set reqd font size
                     lea     font_buffer,a0            Locate font data
                     bsr     calc_top                  Calculate variables
                     (save variables if reqd)
                     ..
                     ..
                     lea     font_buffer,a0            Locate font data
                     move    #'A'-32,d7                Display 'A'
                     move    #200,font_size            Set point size
                     move.l  #temp_buff,chr_addr       Locate image buffer
                     (restore variables if reqd)

                     bsr     make_image                Construct image
                     tst     d0                        Chk for errors
                     bne     chr_error                 Branch if error
                     move    #100,d0                   Set x co-ord
                     move    #100,d1                   Set y co-ord
                     lea     temp_buff,a0              Locate image data
                     (set draw mode if reqd)
                     (set image colours if reqd)
                     v_hide_c                          Hide mouse if reqd
                     bsr     blit_char                 Display character
                     ..
                     ..

                     section BSS

     temp_buff       ds.b    1000                    Temporary image buffer
     font_buffer     ds.b    100000                  Font buffer
     srce_mfdb       ds.w    20                      Source mfdb
     dest_mfdb       ds.w    20                      Destination mfdb
     + various other RAM stores (see CFN_CODE.S file)


     2.8  Printing Calamus font images.
     ----------------------------------
     Depending on the program it may  also  be  necessary to print the font
     data to a printer at some stage. There are too many variables involved
     here to provide a general  purpose  routine  which  will cater for all
     situations so in  this  section  just  the  basic  principles  will be
     discussed.

     Since the font data is constructed in  memory as a bit image (together
     with any other images  the  program  may  be  using)  the printer will
     obviously be printing in bit image mode.  The easiest way to print the
     data is to construct a bit image of  the whole page in memory and then
     output this to the  printer  one  (or  more)  raster  line/s at a time
     (depending on the type of printer,  of  course). The size of the total
     image will depend on the size  of  the  page and the resolution of the
     printer. For example, to print to an  A4 size sheet on a Laser printer
     at 300 dpi would require approximately  1Mb  of memory. If this amount
     of memory is not available then the  program will have to generate the
     image in smaller blocks and  output  each  block  as it is ready which
     makes the program somewhat more complicated.

     The program will have to store  the  images  being used as well as the
     characters and fonts used with  some  sort of co-ordinate system. Bear
     in mind that the font  characters  displayed  on  screen  will be at a
     different size (different divide value) than the equivalent characters
     being printed due  to  the  different  resolutions  of  the screen and
     printer.

     When the page image is  to  be  displayed  the Calamus font characters
     should be constructed in a buffer  at the required size (as previously
     described) and then blitted to  the  appropriate position in the print
     buffer using the VDI 'vro_cpyfm'  function.  Note  that as the data is
     being copied from a  memory  store  to  another  memory  store the VDI
     clipping rectangle is not active as it would be on screen. If any part
     of the source image falls outside the  area of the print buffer block,
     the image must be clipped by 'manually' adjusting the x/y co-ordinates
     used in the 'blit' function. It is  outside the scope of this document
     to describe the  detailed  operation  of  the  'BitBlt'  functions but
     examination of  the  'show_char'  sub-routine  will  show  the general
     methods used (see  also  section  3  for  further  information  on the
     routine).

     2.9  Kerning factors.
     ---------------------
     When displaying more than one character on a line, it may be desirable
     to allow for kerning  to  give  a  more  compact  text  format. When a
     character is displayed the width of the character cell is the width of
     the widest parts of  the  character  image.  If  the next character is
     displayed at the next available  x  co-ordinate  (i.e.  the last x co-
     ordinate plus the width of the  character  cell)  the text can look as
     though it is spaced out too much  especially when a character like 'A'
     is followed by a character like a  'W'. To overcome this Calamus fonts
     contain a 'kerning'  table  for  each  character  which  can allow the
     program to position characters closer  together  when the shape of the
     characters allow it.  Fig  3  shows  two  typical  characters with the
     kerning guide lines shown.

                             [ Insert Fig 3 here ]

     The kerning information takes the form of two sets of 8 bytes for each
     character in the font. The first  group  of 8 bytes represent the left
     edge of the character and the  second  group represent the right edge.
     The height of the character  is  divided  into 8 (approximately) equal
     sections with one byte for  each  section,  the  value being the x co-
     ordinate for the extreme edge of the image divided by 64 to give a one
     byte value. If part of the image  is  not  present in a section (as in
     the bottom two sections in the  letter  'W') the left edge table value
     is set to 255 and the right  edge  set  to 0. A typical table is shown
     below for the letter 'W' in the ADVERT.CFN font (the letter W in Fig 3
     does not represent this font) :-

             Left edge               Right edge
             ---------               ----------
               40                      226
               40                      226
               50                      214
               54                      207
               59                      199
               63                      192
               255                     0
               255                     0

     As can be seen from the two letters  shown in Fig 3, if the letter 'W'
     is displayed followed by the  letter  'j',  the second letter could be
     positioned with the top  part  of  the  'j'  (kerning  section 1) just
     touching the top part of the 'W',  the descender of the 'j' would then
     appear underneath the right side of  the  'W'. In practice a small gap
     would need to  be  inserted  between  the  characters  to prevent them
     actually touching.

     To calculate the x co-ordinate of a character image which is to follow
     an existing character  requires  a  number  of  parameters.  The x co-
     ordinate, width and kerning  values  of  the  first character plus the
     width and kerning values for  the  second  character together with the
     required extra gap between  the  characters.  These  parameters can be
     entered into a formula which can then  be  used to calculate the x co-
     ordinate of the second character image.

     The first operation, however, is  to  determine which kerning value to
     use so that the characters can be positioned correctly. In the example
     shown in Fig 3 it is fairly  obvious  that  the top section (1) is the
     one that needs to be used but  the program needs some way to determine
     this. The method used is  to  locate  the  right kerning table for the
     first character and the left  kerning  table for second character, the
     difference between the 8 corresponding  values  in  the two tables are
     then calculated and the one with  the largest difference indicates the
     kerning section of the character  to  be  used in the calculation. For
     example, the table below shows the  right  and left kerning values for
     the letters 'W' and 'j' respectively  as  used in the ADVERT font. The
     values for the 'j' are subtracted from the values for the 'W' for each
     level to give 8 difference  values.  Since  the first one produces the
     largest difference (the top section of  the character) of 122, the two
     values, 226 and 104, are then used in the formula to calculate the new
     x co-ordinate. Note  that  where  there  is  no  character  image in a
     section a negative value is produced which is then ignored.

             1st Chr W       2nd Chr j
             Right edge      Left edge    Difference
             ----------      ---------    ----------
               226             104           122   (=largest value)
               226             104           122
               214             100           114
               207             100           107
               199             108           91
               192             106           86
               0               84            -84   (ignored)
               0               84            -84   (ignored)

     The formula to calculate the x  co-ordinate of the second character is
     as follows :-

             x2 = x1 + ((KR*64/FS)-XL1) - ((KL*64/FS)-XL2) + G pixels

     where -

     x2 is the x co-ordinate of the second character image.
     x1 is the x co-ordinate of the first character image.
     KR is the right kerning value for the first character, i.e. 226 above.
     KL is the left kerning value for the second character, i.e. 104 above.
     XL1 is the first character left x offset value in the chr image header
         block.
     XL2 is the second character left x offset value in the chr image
         header block.
     FS is the 'font_size' variable divide factor.
     G  is the required gap between characters in pixels.

     While this may look a bit  involved  it  isn't  really and in any case
     there is  a  sub-routine  provided  which  does  all  the calculations
     required. However, a short explanation is  given here in case you need
     to make any modifications to the source code.

     Firstly the two kerning  values  from  the  two  characters have to be
     multiplied by 64 to convert  them  back  to  their original values and
     then divided by the current divide factor  to bring them into range of
     the image data. The  x  co-ordinate  of  the  first character is first
     added to the width  of  the  first  character  at the required kerning
     section (i.e. the right kerning value minus the left x offset) to give
     the x co-ordinate at the right  edge  of the first character. Then the
     corrected left kerning value minus  the  left  x  offset of the second
     character is subtracted from the  previous  x  value which, in effect,
     moves the second character  to  the  left  by  the  required number of
     pixels so that they just touch and then the gap is added in to provide
     the final position. Draw it out on  two  pieces of graph paper and try
     it out (like I did) if you don't believe me !

     The 'calc_kern' sub-routine can be used to calculate the x co-ordinate
     of the second character and  should  be  used  as shown in the example
     below. A number of parameters have to be passed to the routine when it
     is called as follows :-

     d0 = the x co-ordinate of the previous character image.
     d4 = left x offset value of the previous character image.
     d5 = left x offset value of the new character image.
     d6 = ident of previous character used.
     d7 = ident of new character.
     a0 = address of buffer holding font data.
     (font_size) = divide factor.
     (gap) = size of gap between characters in pixels.

     On return from the routine  register  d0  holds the new x co-ordinate.
     Most of the  parameters  can  be  accessed  easily  although the three
     relating to the previous character will need to be stored in temporary
     registers because that data is not  available from memory when the new
     character is being generated.  Some  example  code which just displays
     two characters illustrates the sequence.  In  practice, of course, the
     main part of the code would probably be in a sub-routine.

             move    #5,gap                  set chr gap to 5 pixels
             move    #50,font_size           set divide factor
             lea     font_buffer,a0          locate font data
             bsr     calc_top                calculate width, height, etc

             move    #'A'-32,d7              1st character = A
             move.l  #img_buff,chr_addr      locate image buffer
             bsr     make_image              make chr image
             tst     d0
             bne     exit                    abort if error

             move    img_buff+4,d4           fetch 1st chr left x limit
             move    d7,d6                   save last chr ident in d6

             lea     img_buff,a0             locate image data
             move    #10,d0                  set x co-ord for 1st chr
             move    d0,d3                   save x co-ord in d3
             move    #100,d1                 set y co-ord for all chrs
             bsr     blit_char               and display 1st chr

             lea     img_buff,a1             locate image buffer
             bsr     clr_buffer              and clear to zeros

             move    #'Y'-32,d7              2nd character = Y
             move.l  #img_buff,chr_addr      locate image buffer
             lea     font_buffer,a0          locate font data
             bsr     make_image              make chr image
             tst     d0                      d0=error code (if applicable)
             bne     exit                    abort if error

             move    img_buff+4,d5           fetch 2nd chr left x limit
             move    d3,d0                   restore old x co-ord
             bsr     calc_kern               calc x co-ord for chr in d0

             lea     img_buff,a0             locate image data
             bsr     blit_char               and display chr (d1=y co-ord)

     Note that the 'calc_kern' routine  must  not be called when displaying
     the first  character  in  a  sequence  since  there  is  no  displayed
     character  to  compare  with.  Also   the  routine  assumes  that  the
     characters in a sequence are all  in  the  same font (only one font is
     accessed) and are also the same  size. Kerning characters of different
     point sizes or from different fonts will require some trickier code.

     The example above assumes  that  method  2  is  being  used to display
     characters, i.e. formatting each character as it is needed. If all the
     character images have been stored in RAM  (method 1) the left x offset
     values for the two characters (to  be  stored  in registers d4 and d5)
     can be read from the images  stores  by  locating the required data in
     the image buffer. See the start of the 'show_char' sub-routine code on
     how to access the header block for  any character image in the buffer.
     The left x offset value  is  stored  in  the  third word of the header
     block.

     There are one or two points to  bear  in mind when using the 'kerning'
     routine. Firstly the 'kerning' values are  scaled down 64 times before
     being stored in the font data. This will inevitably introduce a slight
     error which may mean that some characters  in some fonts at some point
     sizes may not be positioned exactly  as  one might like. Also as there
     are several 'subtract'  instructions  in  the  sub-routine,  it may be
     possible that a  slight  error  in  co-ordinate  values  may produce a
     negative value which will return an x  co-ordinate which is way out of
     range. It may be prudent to  test  the value returned from the routine
     and check that it is not larger than some preset value.

     Secondly there are a number of Calamus fonts around (notably the AWARD
     and OPTICAL fonts given  away  on  recent  magazine cover disks) which
     have incorrect kerning values, i.e. all sections having the same value
     or worse. Although these can  easily  be  corrected with a font editor
     such as Fonty they could play havoc with the 'calc_kern' sub-routine.

     In practice it is probable that  only some specialist programs such as
     DTP or Word Processor type  programs  will  need to implement kerning.
     Displaying a row of characters  without  any kerning still looks quite
     acceptable, it is only a few  characters which when displayed together
     make the spacing look excessive. The  best  option is to try a program
     without kerning and only use it if the program really needs it.


     2.10  Fill pattern.
     -------------------
     Normally the routines described above generate a solid black character
     on a white background (in monochrome  anyway). The pattern routine can
     superimpose a 16 by 16 pixel pattern  on a character instead of an all
     black character. First construct the  character  in a buffer using the
     'make_image' sub-routine and also set up  a  pattern image in RAM. The
     pattern should consist of 16 words in a RAM buffer or a series of dc.w
     statements (see the two examples in the source file).

     To modify the character, set register a0 to the start of the character
     buffer and register a1 to the start of the pattern data. Then call the
     'pattern' routine which will  fetch  the  width and height information
     from the header data in the  character  buffer to modify the character
     image. Note  that  there  is  no  outline  drawn  around  the  edge of
     character. A typical section of code would be :-

                     ..
                     Generate a chr in temp_buff with make_image S/R
                     lea     temp_buff,a0            locate chr data
                     lea     pattern_1,a1            locate pattern data
                     bsr     pattern                 generate pattern
                     ..
                     ..

     pattern_1       dc.w    $5555                   Chequerboard pattern
                     dc.w    $aaaa
                     dc.w    $5555
                     dc.w    $aaaa
                     dc.w    $5555
                     dc.w    $aaaa
                     dc.w    $5555
                     dc.w    $aaaa
                     dc.w    $5555
                     dc.w    $aaaa
                     dc.w    $5555
                     dc.w    $aaaa
                     dc.w    $5555
                     dc.w    $aaaa
                     dc.w    $5555
                     dc.w    $aaaa


                     section BSS

     temp_buff       ds.b    1000                    chr buffer


     2.11  Outline character.
     ------------------------
     The 'outline' routine works in a  similar way to the 'pattern' routine
     but generates  an  outline  of  a  character  that  has  already  been
     constructed in a buffer. In this  case,  however, the new character is
     formatted in a separate buffer which  allows  it to be combined with a
     patterned character, if required.

     First  generate  the  character  in   a   temporary  buffer  with  the
     'make_image' routine as described earlier.  Set  up another RAM buffer
     of the same size as  the  character  buffer, say the 'outline buffer',
     and clear it all to  zeros.  Load  register  a0  with the start of the
     character buffer and load register  a1  with  the start address of the
     outline buffer and then  call  the  'outline'  routine.  On return the
     outline buffer will  contain  an  image  of  the  character in outline
     including the necessary  header  information.  The  image  can then be
     displayed with  the  'blit_char'  sub-routine  as  normal  or  perhaps
     combined with a patterned character image.


                                   SECTION 3

                 Font construction and Sub-routine information.
                 ----------------------------------------------

     This section describes  how  the  font  bit  images  are generated and
     further information on the main  sub-routines. Although it is probably
     not necessary for the programmer to  understand the exact operation of
     each of the routines used, it will  be helpful if any of the functions
     have to be changed to accommodate  any  new facilities. Note that some
     'library' routines such  as  the  routines  which  are  common to many
     programs like the maths,  sort,  bezier  curve  routines, etc, are not
     described in much detail since  these  will  be  covered more fully in
     future issues of the ICTARI magazine.

     3.1  Calamus font character construction.
     -----------------------------------------
     Before discussing the routines the  method of constructing a character
     image should  first  be  fully  understood.  As  mentioned  earlier, a
     Calamus font is a  vector  font  which  describes  each character as a
     series of vector co-ordinates which define the position, direction and
     radius (in the case of bezier curves)  of every line in the character.
     Basically each character is comprised  of  one or more closed polygons
     placed on a  co-ordinate  grid  of  dimensions  16320  by 16320. Note,
     however, that these are NOT  filled  polygons.  When  a bit image of a
     character is constructed the  outline  is  first  drawn  on to a blank
     buffer after first being scaled down and then the appropriate parts of
     the character are  filled  in  to  produce  a  solid  character image.
     Drawing the outline shape  is  fairly  straightforward, filling in the
     character is a bit more involved however.

     The data  section  (section  0006)  holds  the  character  description
     information in the following format :-

     Ctrl    Co-ordinate data                Function
     Codes

     0000    x1, y1                          Start of new path.
     000F                                    End of data for character.
     0001    x1, y1                          Connect with straight line.
     0002    c1x, c1y, c2x, c2y, x3, y3      Bezier curve line + controls.

     All values are 16 bit (1  word).  Each  new polygon (path) starts with
     the control code 0000 followed by  the  first set of co-ordinates. The
     next control code will indicate  either  a  straight  line or a bezier
     curve. If it is a straight line  the  control code 0001 is followed by
     two co-ordinates and a line  is  then drawn between these co-ordinates
     and the previous ones. If the next line is a bezier curve, the control
     code 0002 is followed by two  bezier  control  points and then the end
     co-ordinate. The program will  then  draw  a  curved  line between the
     previous co-ordinate and  the  new  co-ordinate  with  the two control
     points determining the curve. When a  completed polygon has been drawn
     a new one is marked by a new path starting with the 0000 control code,
     note that the  first  and  last  co-ordinates  of  each polygon should
     always be the same.  A  control  code  of  000F  marks  the end of the
     character data.

     For example, a typical sequence could be :-

     0000, x1, y1                            Start of new path
     0001, x2, y2                            Draw line from x1,y1 to x2,y2
     0001, x3, y3                            Draw line from x2,y2 to x3,y3
     0002, x4, y4, x5, y5, x6, y6            Draw curve from x3,y3 to x6,y6
                                             Bezier controls x4,y4 & x5,y5
     0001, x1, y1                            Draw line from x6,y6 to x1,y1
     0000, x7, y7                            Start of new path
     etc, etc
     ..
     000F                                    End of chr data

     To generate a new character the first  step  is to allocate a block of
     RAM for the character cell. The size  of  the  cell will be set by the
     current divide factor as described  above.  The  width  of the cell in
     bytes will, therefore, be 16320 divided  by  the font size value which
     is then converted into words by  dividing  by  8 and rounding up to an
     even value, if necessary. The height  of  the cell (in scanlines) will
     just be 16320 divided by the font size.

     Figs 4 and 5 show the  characters  A  and  O as a magnified image. The
     character cell in this case is 6  bytes  wide (48 pixels) by 37 raster
     lines high (37 pixels).  Each  character  cell  also  has  a four word
     header block at the start (not  shown)  which holds information on the
     cell size.

                          [ Insert Figs 4 and 5 here ]

     The letter A (Fig  3)  is  constructed  from  two  polygons, the first
     starting at point A (x14,y17) and progressing to points B, C, D, E, F,
     G and H (which is the same co-ordinate as point A). The second polygon
     starts at point I and goes through points J, K and L. You might wonder
     why one would start a path at point  A rather than points G or B, well
     you probably wouldn't but  is  serves  to  illustrate a problem later.
     Note that, as mentioned  earlier,  it  is  not  possible to use simple
     filled polygons to construct these  characters,  it would in fact work
     for the letter A but if the  same  system  was used in the letter O in
     Fig 5, we would just get one big black blob.

     In order to fill in the  characters properly, the 'winding' factor has
     to be considered. That is the direction in which each line is drawn is
     important and is determined by  the  way  the character was originally
     drawn. In any character which uses more  than one polygon, such as the
     two characters shown  in  Figs  4  and  5,  the  'winding' factor will
     determine how the character is  filled.  The  'line fill' routine will
     only fill in a horizontal line  between two pixels which have opposite
     'winding' values. In Fig 4  the  two  polygons have the same 'winding'
     values as shown by  the  arrows  by  each  line.  Consider the y28 co-
     ordinate line (indicated by the  reference  line X-Y), the first pixel
     at x9 has an 'up' value and  the  next  pixel  at x12 also has an 'up'
     value while the next pixel along at x16 has a 'down' value so the fill
     routine will fill in the pixels  between  x9 and x16 because they have
     opposite 'winding' values. Similarly, the  pixels  between x12 and x32
     will be filled in and also x28 and x39 will be filled.

     In Fig 5 the same principle applies  except  that in this case the two
     polygons (the two circles)  have  opposite  'winding'  values, the y19
     raster line will be filled in between pixels x9 to x15 and also pixels
     x31 to x37 because these pixels have opposite 'winding' values.

     As shown above, the  'winding'  value  can  be  simplified to 'up' and
     'down' values since horizontal lines can effectively be ignored as any
     horizontal lines are already filled in.  As the vector lines are drawn
     in RAM the value of each pixel  (the  x and y co-ordinates) are stored
     in two separate lists, the  'up_list'  and  the 'down_list'. All pixel
     co-ordinates that have an 'up' value  are  stored in the 'up_list' and
     similarly the 'down' pixels in the  'down_list'. The next problem then
     is how to determine whether a pixel  is  an 'up' or 'down' pixel. This
     is easily done by comparing  the  y  co-ordinate  of the start and end
     pixel of each line before it  is  drawn.  Obviously if a line is drawn
     from point A to point B (Fig 4) the line is going up because the y co-
     ordinate of the first pixel will be 17 and the end co-ordinate will be
     1. A 'direction' flag is set in the  routine and so all the pixels for
     that line will then  be  stored  in  the  'up_list'. Similarly all the
     'down' pixel co-ordinates will  be  stored  in  the 'down_list'. Since
     each polygon is a completed loop,  at  the  end of the operation there
     will always be the same number  of  'up' and 'down' pixel co-ordinates
     in each list.

     Bezier curves are treated in  basically  the  same  way. Each curve is
     constructed from up to 12 straight  lines  and each line is treated in
     the same way as any other straight line.

     Horizontal straight lines such as the  ones between points C-D and F-G
     in Fig 4 can be completely ignored  since there is no point in filling
     in the lines again. The  co-ordinates  for  those  lines that have the
     same y co-ordinate for the start  and  end of the line, therefore, are
     not stored in either list. However, lines which are going up (or down)
     but which have  a  horizontal  section  have  to  be  treated slightly
     differently. Fig 6 shows an example line  from point A to point D. The
     problem here is that if  every  pixel  on  the  line was stored in the
     'up_list' (as the line is going up) there would be lots of 'up' pixels
     stored with only one corresponding  'down' pixel. The drawing routine,
     therefore, checks the y  co-ordinate  of  each  pixel  with  the y co-
     ordinate of the previous pixel before it  is stored in the list and if
     they have the same value  and  same  direction,  the current pixel co-
     ordinates are not stored in the  list.  This means that in the example
     shown, the pixel at point A  will  be  stored but the remaining pixels
     from point A to the pixel before point B will not be stored since they
     all have the same y co-ordinate  value.  The  pixel at B point will be
     stored but not the rest of the pixels  on that section of the line and
     similarly for the remainder of the line.

     The solution to this problem does, however, raise yet another problem.
     It is easy enough to  check  the  y  co-ordinate of the previous pixel
     stored because it is in  the  previous  RAM  location to the one being
     processed but suppose the polygon was  started at point C and finished
     at point C in Fig 6. When the  first pixel is plotted we still need to
     know whether the previous pixel has the  same y co-ordinate so that it
     can be stored or not stored but  as  this co-ordinate has not yet been
     plotted it is not possible to do this at the time. For this reason the
     address in the list of the  first  pixel  plotted  of each new path is
     stored so that when the  polygon  has  been completed, the first pixel
     can be compared with the last pixel and the co-ordinates stored in the
     list or not as the case may be.  This point is illustrated in Fig 4 at
     points A and H. Since both pixels at  A  and H have the same value and
     the same direction, only one of  them  is  stored in the 'up_list'. If
     this was not  done  there  would  be  two  'up'  pixels at co-ordinate
     y17,x14  and  only  one  corresponding  'down'  pixel  at  co-ordinate
     y17,x21.

                             [ Insert Fig 6 here ]

     When all the polygons have  been  drawn, the 'up_list' and 'down_list'
     buffers will contain a list of  co-ordinates,  one for each pixel. The
     values are stored with the y  co-ordinate  first followed by the x co-
     ordinate. Unfortunately the values  are  stored  in  the same order as
     they were originally drawn so  before  the  character can be filled in
     the two lists have to be sorted into numerical order. The sort routine
     is called and  sorts  both  lists  into  order  using  the  Shell Sort
     algorithm.

     Since the y co-ordinate is stored first,  the list will be sorted in y
     co-ordinate order. In the example in  Fig  4, the first co-ordinate in
     the 'up_list' will be the pixel at  point B (y1,x22) and the first one
     in the 'down_list' will  also  be  point  B  (y1,x22). The 'line_fill'
     routine will then try  to  fill  in  the  line  between  these two co-
     ordinates. However, since they have  the  same x co-ordinates, nothing
     needs to be done in this case.  The  same  applies to the next pair of
     co-ordinates at y2,x22. The next  pair  of  co-ordinates at y3,x21 and
     y3,x23 are then joined with a horizontal  line to fill in the pixel at
     y3,x22. This process continues  until  all  the co-ordinates have been
     checked. Note that at point E (as  in  the case of point B) there will
     be two co-ordinates stored for y15,x22,  one  in the 'up_list' and one
     in the 'down_list'. In this case a  line will be drawn between y15,x15
     to y15,x22 and another line between y15,x22 to y15,x29.

     Where the two  polygons  overlap,  the  co-ordinates are automatically
     aligned correctly by the sort routine.  For  example, in the case of y
     co-ordinate 28 (the X-Y reference line) the pixels y28,x9, y28,x12 and
     y28,x28 will be stored in  the  'up_list'  and pixels y28,x16, y28,x32
     and y28,x39 will be  stored  in  the  'down_list'  in  that order. The
     horizontal fill lines will then  be  drawn between x9-x16, x12-x32 and
     x28-x39 which is just what is required.

     When the bit image has been completed it can be displayed on screen or
     copied to a printer buffer with the standard VDI BitBlt functions.

     3.2  Sub-routine operations.
     ----------------------------
     This section provides  further  information  on  the main sub-routines
     used which has not been covered  in previous sections. The source code
     listing, which is  fairly  well  documented,  should  also  be read in
     conjunction with the notes below.


     'show_char' and 'blit_char' routines.
     -------------------------------------
     These two routines are used  to  display  a  character on screen. Both
     routines are very similar,  the  first  one  uses  one  of a series of
     images that have been stored in  RAM  and  are  accessed via a look up
     table, the second one uses an  image  that  has first been stored in a
     temporary buffer. The 'show_char' routine  should  only be used if the
     'make_char_set' has first  been  called  to  generate  the  images and
     initialise the look  up  table.  The  images  and  table  layout is as
     follows :-

                     Address table                   Chr image data

          ca_table   address_000 ------------------> width (bytes) Chr $20
                     address_001 --------            height (lines)
                     address_002 --->    |           left offset (pix)
                     ..                  |           right offset (pix)
                     ..                  |           image data
                     address_223 --->    |           ..
                                         |           ..
                                         |
                                          ---------> width (bytes) Chr $21
                                                     etc.

     The ca_table holds a list of  32  bit addresses which define the start
     address of each valid character. If a  character does not exist in the
     font the address is set to zero.  When  a character is to be displayed
     the routine is called with the  x  and  y co-ordinates in registers d0
     and d1. Register a0 holds the address of the look up table (this could
     be set up within the routine  if  there  is only one table being used)
     and register  d2  holds  the  ASCII  code  for  the  character  to  be
     displayed.

     The routine calculates the address of the required character data from
     the value in d2 and sets register a0 to the start of the image data.

     The remaining part of the routine  sets  up the source and destination
     mfdb buffers and the ptsin array for the VDI 'vrt_cpyfm' function. The
     character header information is used to set up the source mfdb and the
     left and right offset values are used  to clip the source image to the
     correct character width. The values  in  registers  d0 and d1 are then
     used to position the image on screen.

     As mentioned earlier, the draw mode  and  image colours can be changed
     by altering the parameters in the  'vrt_cpyfm' function. The format of
     the MACRO is as follows :-

             vrt_cpyfm       #mode,#srce_mfdb,#dest_mfdb,#i1,#i2

     where i1 is the 'pen colour' for all the 1s in the source image and i2
     is the 'pen colour' for all the  0s  in the source image. With '#mode'
     set to 1 (replace), #i1 set to  1  and  #i2 set to 0 (as they normally
     are in the routines) the character will  be displayed as a black image
     in a  white  rectangle  (on  a  monochrome  screen).  This  mode would
     probably not be suitable for  most  programs, however, since the white
     background rectangle would overwrite any  other  images that happen to
     be close to the character images.

     With '#mode' set to 2 (transparent)  the character image (the bits set
     to 1) will be copied to  the  screen  but  the background bits will be
     ignored. In this case only the value  in #i1 is relevant, the value of
     #i2 is ignored (although some value must still be stored there).

     With '#mode' set to 3 (XOR) the source image (1s and 0s) will be XORed
     with the data on screen  so  the  resultant  image  will depend on the
     current screen image and the values of #i1 and #i2.

     With '#mode' set to 4 (reverse transparent) only the 0s will be copied
     to the screen so that the  rectangle  will  be displayed in the colour
     set by #i2 and the character  image  itself will appear in the current
     screen colour.

     For the monochrome screen mode the values of #i1 and #i2 can only be 1
     and 0, of course, but for colour  screens they could be 0-3 for medium
     rez or 0-15  for  low  rez.  The  actual  colours  of  the characters,
     therefore, will vary depending  on  the  colour  values used, the mode
     used and possibly the current screen colours.

     The state of  the  CPU  Z  flag  (for  the  'show_char'  routine only)
     indicates whether an error occurred on exit from the routine.


     'make_char_set' routine.
     ------------------------
     The 'make_char_set' routine generates a complete  set of bit images in
     a RAM buffer for each valid character  at the specified point size. As
     mentioned earlier, the RAM allocation for  the bit images and the sort
     lists can be a  problem.  It  is  possible,  however, to calculate the
     amount of memory  required  for  the  bit  images  before  calling the
     routine itself.

     First set the a0 register to the font buffer which holds the font data
     and set the 'font_size' variable  to  the required divide factor. Then
     call the 'calc_top' sub-routine which will set up a number of variable
     stores (note that the 'make_char_set'  routine also calls this routine
     but this will not matter). The  size  of  the image buffer can then be
     calculated as follows :-

     Multiply the 'font_height' variable  by  the  'char_width' variable to
     give the number of bytes used for the individual images. Add 8 to this
     value to allow for the header  block  and then multiply this number by
     the 'chr_count' variable  to  give  the  total  size  of  the required
     buffer. The formula would look like :-

     ((font_height)*(char_width)+8)*(chr_count) = total memory reqd (bytes)


     'make_image' routine.
     ---------------------
     This routine generates a bit image of  a specified character in RAM at
     a specified point size. Used mainly  by  the  above routine but can be
     called by itself.

     The amount of memory  required  for  the  bit  image can be calculated
     before the routine is called  by  first calling the 'calc_top' routine
     and then multiplying the  'font_height'  variable  by the 'char_width'
     variable and adding 8 to the result.  The  layout of the bit image and
     header block  are  identical  to  that  described  earlier  under  the
     'show_char' routine except that there is no look-up table, of course.


     'calc_top' routine.
     -------------------
     This routine performs several  functions  in  preparation for the font
     construction routines, it  calculates  the  top  edge  offset, maximum
     height, character width, baseline offset and number of used characters
     for the complete character set.

     To avoid using unnecessary memory the bit image only uses the required
     number of scan lines to store  the  tallest character in the font. The
     routine scans through the y  co-ordinate  values for each character to
     find the lowest  value  which  represents  the  highest  point  in the
     character grid that is used.  The  result  is returned in the variable
     't_edge' and is used by the 'make_image' routine when constructing the
     character bit image.

     A similar operation is  performed  to  find  the highest y co-ordinate
     value used  (bottom  edge  of  character)  except  that  when  all the
     characters have been checked, the value in 't_edge' is subtracted from
     this value and  then  divided  by  the  scaling  value  to produce the
     maximum character height in scan lines.

     The 'char_width' variable  is  calculated  by  dividing  16320  by the
     scaling factor and then rounding up to an even number of bytes.

     The 'base_line' variable is  calculated  by  subtracting  the value in
     't_edge' from the base line  value  stored  in  the font data file (to
     allow for the lines removed from  the  top  of the character cell) and
     then dividing by the scaling factor to give the result in scan lines.

     The  'chr_count'  variable  returns  with  the  number  of  characters
     actually in use in the font.


     'calc_kern' routine.
     --------------------
     This routine calculates the x co-ordinate of a character image after a
     previous character has been displayed. It is suggested that it is only
     used where the program requirements really  need it and only then with
     characters of the same point size and  from the same font. See section
     2.9 for further details.


     'pattern' routine.
     ------------------
     This routine modifies a character image  in  RAM with a predefined bit
     pattern. The bit pattern is defined in a  block of 16 words and can be
     programmed as constants by the programmer  or designed in a RAM buffer
     by the program user.

     The character  image  to  be  modified  is  first  generated  with the
     'make_image' routine  and  stored  in  a  buffer.  When  the 'pattern'
     routine is called the  bit  pattern  is  superimposed on the character
     image, that  is  wherever  there  is  a  0  bit  in  the  pattern, the
     equivalent bit in the character image  is  also set to 0. However, the
     character image is still only  a  2  bit  image  so when the character
     image is blitted to the screen,  the  'replace' mode should be used in
     the 'vrt_cpyfm'  function  in  the  'show_char'  or  'blit_char'  sub-
     routines. If the 'transparent' mode is  used,  the white pixels in the
     character image will  become  transparent  and  the  screen background
     image will show through the character.  To overcome this drawback, the
     image could be drawn twice on screen,  once  as a solid black image to
     clear the background data and  then  with  the modified image. Another
     alternative would be to write a  'sprite'  like routine to replace the
     'vrt_cpyfm' function which would be somewhat more difficult.

     Note that when a character image  is  modified with a pattern there is
     no outline around the character image  which  can look 'messy' on some
     characters. To provide an outline the following routine may need to be
     used in conjunction with the 'pattern' routine.


     'outline' routine.
     ------------------
     This routine generates an outline image  of a character. The character
     to be outlined is first  generated  in  a buffer with the 'make_image'
     routine and then the  routine  creates  an  outline  image in a second
     buffer. Since the header  information  is  also  copied to the outline
     buffer, the  outline  image  can  be  displayed  with  the 'blit_char'
     routine by setting register a0 to  the  start address of the buffer as
     described previously.  Note  that  the  limitations  described  in the
     previous paragraph also apply in this case.


     'clr_buffer' routine.
     ---------------------
     This routine can be used to clear  the image buffer before a character
     image is generated. It should  be  called after the 'calc_top' routine
     has been called  and  before  the  'make_image'  routine  is called to
     generate a new character  image.  It  clears  just  the  amount of RAM
     required for the new image and uses the 'font_height' and 'char_width'
     variables to calculate the size  of  the  RAM  required for the image.
     Register a1 should first be  set  to  the  start  address of the image
     buffer being used.


     'end_poly' routine.
     -------------------
     This routine checks if  both  ends  of  a  polyline  are  for the same
     direction. As described in section 3.1  earlier, the start and end co-
     ordinates of every polygon have to be  checked to see if they have the
     same 'direction' value. If they  have,  the last co-ordinate stored is
     erased from the appropriate list.


     'fill_char' routine.
     --------------------
     This routine fills  in  an  outline  character  image  which  has been
     constructed in a RAM buffer. The  routine basically just steps through
     the 'up' and 'down' lists  and  draws  a  line  between  the two x co-
     ordinate points for each y co-ordinate  (i.e. raster line). Since both
     lists have been sorted into  numerical  order, the y co-ordinates will
     progress in sequence. If the y co-ordinate  in one list does not match
     with the same y  co-ordinate  in  the  other  list  (this should never
     happen) an error will be returned in d0. See also the 'line_fill' sub-
     routine.


     'draw_bezier' routine.
     ----------------------
     This routine draws a bezier curve line in RAM and will be discussed in
     a  future  issue  of  ICTARI.  Note  that  the  bezier  look-up  table
     BEZ_TAB.DAT is included in the source code as a binary file.


     'bez_calc' routine.
     -------------------
     Calculates the bezier curve x and y  co-ordinates and is called by the
     'draw_bezier' routine.


     'poly_line' routine.
     --------------------

     This routine draws  a  polyline  in  RAM  and  is  similar  to the GEM
     'v_pline' function except that each  co-ordinate  point is stored in a
     table.


     'plot_line' routine.
     --------------------
     This routine draws a straight line in a RAM buffer.

     'draw_pix' routine.
     -------------------
     This routine plots  a  single  pixel  in  RAM  and  is  called  by the
     'plot_line' sub-routine. Normally this would  be in the character cell
     buffer where the 'chr_addr' variable  holds  the  start address of the
     buffer and 'char_width' holds the width of the buffer in bytes.


     'fill_list' routine.
     --------------------
     This routine generates a list of pixel co-ordinates in a buffer and is
     called by the 'plot_line' sub-routine as  each pixel is plotted. The x
     and y co-ordinates (in registers d0  and  d1) are stored in either the
     'up_list' or 'down_list' buffers, the  value  in the variable 'direct'
     defines the current direction of the  line and therefore which list to
     use. The 'up_pointer' and  'down_pointer'  variables  hold the current
     memory positions of the  two  lists.  The  routine  also checks if the
     current and previous y co-ordinates are the same and omits one if they
     are as discussed in section 3.1 earlier.

     As mentioned before, the size of the  two buffers holding the lists of
     co-ordinates can vary depending on the size and complexity of the font
     used. A character which consists  of  a  large number of polygons will
     require more  space  than  a  character  which  consists  of  a simple
     rectangle. The routine assumes  that  there  will be sufficient memory
     space for the data and  does  not  check  whether  there is enough RAM
     since this would just slow down the code a bit more.

     However, it  would  be  possible  to  include  some  memory  tests  if
     required. The simplest way would be to allocate two equal size buffers
     which use a block of RAM and store  the  end address of the block in a
     variable.  Then  after  adding  #4  to   register  a0  (at  the  label
     'fill_list5') check whether a0 has exceeded  the end address and if it
     has, set an error flag  and  exit  the routine. Obviously the routines
     which call this one will  also  have  to  check  the flag and take the
     appropriate action.

     As a rough guide to the amount  of  RAM  required, the size of the two
     buffers using the DINGBATS.CFN font (the most complex one I have) with
     a divide value of 52 was about 8.3Kb each.

     In the source code provided, these buffers  have been set to 50Kb each
     but this should be modified  if  less  RAM  space  is needed. The same
     applies to the other two main buffers,  the image buffer (1Mb) and the
     font buffer (100KB). In fact the  image  buffer  will not be needed at
     all if the 'make_char_set' routine is not used although a small buffer
     will still  be  required  for  the  character  images  when  using the
     'make_image' sub-routine.


     'line_fill' routine.
     --------------------
     This routine fills in a  horizontal  line  between two x co-ordinates.
     The two x co-ordinates are fetched  from the 'up_list' and 'down_list'
     buffers for each y co-ordinate by the 'fill_char' routine. Register a0
     is first pointed at the  required  raster  line  in the character cell

     which is defined by the  y  co-ordinate.  Obviously  if  the two x co-
     ordinates have the same value, no action is needed.

     This routine also performs another  function, it calculates the lowest
     and highest x co-ordinate values and  stores these in the header block
     of the character cell RAM buffer. When the routine is called, register
     a4 is pointing at the third word of the character cell memory which is
     being filled. As the x co-ordinates are passed to the routine, the low
     and high values  are  continuously  checked  so  that  the  lowest and
     highest values for the character are  stored  back in the header block
     in words 3 and 4  respectively.  Although  the  Calamus font file does
     have a section (section 0007) which  defines the minimum and maximum x
     co-ordinates I found that some  fonts  have faulty values which tended
     to crash the routines so  for  this  reason  the values are calculated
     within the 'line_fill' routine.


     'sort_list' routine.
     --------------------
     This routine sorts a list  of  y/x  co-ordinates into numerical order.
     This is a standard Shell Sort  routine which sorts the longword values
     (i.e. y  co-ordinate  plus  x  co-ordinate)  into  numerical  order in
     preparation for the fill character  operation.  The  sort code will be
     discussed in more detail in a future issue of ICTARI.


     'lsub_sr', 'lmul_sr' routines.
     ------------------------------
     These routines are Sign  Integer  Fraction  maths  routines which were
     originally published in ICTARI  issue  14  and  are  used  here in the
     bezier curve drawing routines. If  these  routines  are already in use
     within the user  program  they  should  be  omitted  from  the Calamus
     section of the source code.


                                   CONCLUSION
                                   ----------

     The above information together  with  the  source code supplied should
     enable a programmer to incorporate Calamus fonts into his programs and
     so increase the flexibility of  graphics based text programs. However,
     these routines can still be improved on  in a number of ways. Although
     I  have  chosen  the  methods  outlined  here  to  generate  the  font
     characters this is not necessarily the best or quickest way to achieve
     this. If any  programmer  can  find  ways  to  improve  on  any of the
     routines, please send them into  ICTARI  so that other programmers can
     share the information.

     For example, it would be very useful to be able to fill the characters
     from the 'up_list' and  'down_list'  data  without  having to sort the
     data first but I cannot see any easy way of doing this that is quicker
     than the current method.

     Routines to rotate the font characters (as Calamus does) would also be
     very useful but I don't know how one would do this. Shadow effects, 3D
     effects, shading effects and  multiple  colours  are  also  just a few
     other improvements that would be extremely  useful. Also I'm sure that
     some of the routines, especially  the  line drawing routines, could be
     speeded up which would  increase  the  overall  speed considerably. If
     anyone can come up with code to provide any of these facilities I, and
     other members I'm sure, would be very grateful.

     If anyone actually uses these routines  in  a  program I would be very
     interested to hear about it so please  let  me know at ICTARI. Also if
     you use these routines  in  a  published  program, please mention that
     they were supplied by the  ICTARI  disk  magazine, it may produce some
     new members.

     Acknowledgements.
     -----------------
     Thanks to Chris McArlan for the original Calamus description document.
     Thanks to Matthew Carey for bezier curve routines and font fill info.

     And to ICTARI members -

     Thanks to John Charles for additional Calamus font information.
     Thanks to John Logan for invaluable Integer Fraction maths routines.
     Thanks to Terry King for the fast outline source code.


     Please send any comments, bug reports, suggestions, code, etc to :-

     Peter D Hibbs
     ICTARI Programmers Group
     63 Woolsbridge Road
     Ringwood
     Hants
     BH24 2LX


                              ++++ End of file +++
