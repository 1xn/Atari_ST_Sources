<HTML>
<HEAD>
<TITLE>
FASHION/Les objets un par un/G_BOUNDING et G_GBOUNDED
</TITLE>
</HEAD>
<body>
<CENTER><H1>G_BOUDING et G_BOUNDED</H1></CENTER>
<br>
Les objets G_BOUNDING et G_BOUNDED sont un peu particuliers.
En effet, il permettent d'afficher tout ou une partie d'un
formulaire dans un autre. L'objet G_BOUNDING est en fait l'objet
dans lequel on peut afficher un G_BOUNDED. D&egrave;s lors, tout
appel &agrave; objc_draw() affichera un arbre complexe dans
lequel on peut trouver un autre arbre, et ce … l'infini.<br>
De plus, du fait qu'un objet peut avoir des coordonn&eacute;es
n&eacute;gative dans l'ob_x/ob_y, il est tout &agrave; fait
envisageable d'utiliser les G_BOUNDxxx pour fabriquer un objet
dont le contenu se d‚place (exemple : des ascenseurs dans un formulaire...).<br><br>

Les G_BOUNDING on la structure suivante point&eacute; par leur ob_spec :<br><br>

<font size=-1><pre>
typedef struct {
	object		*gbo_tree;	// pointeur vers l'arbre affich‚
	unsigned short	gbo_first;	// num‚ro du 1er objet dessin‚ (G_BOUNDED)
	unsigned short	gbo_depth;	// profondeur de dessin
} bounding;</font></pre><br><br>

Les G_BOUNDED on la structure suivante :<br><br>
<font size=-1><pre>
typedef struct {
	object		*gbd_tree;	// pointeur vers l'arbre englobant
	unsigned short	gbd_index;	// num‚ro de l'objet englobant (G_BOUNDING)
	unsigned short	gbd_flags;	// champ de bits
} bounded;</font></pre><br><br>

Comme vous pouvez le voire, ces deux types d'objet sont ins&eacute;parable,
et il faut bien prendre garde que les liens soient bien respect&eacute;s.
Bien sur, la fonction objc_find retourne de nouveau param&egrave;tres
puisqu'il faut maintenant savoir dans quel formulaire on &agrave; cliqu&eacute;,
et dans quel formulaire englobant.<br><br>

<A HREF="../toc.htm">Retour &agrave; l'index</A> <A HREF="gpix.htm">G_PIX</A>

</body>
</html>