    Hartmut Thordsen
    Stillachzeile 3
D - 1000 Berlin 27


          Update-Service fÅr die Pascal-Libraries LIB auf PD53
                       Stand vom 16. Dezember 1987


Die Pascal-Libraries wurden im FrÅhjahr im PD-Service der Zeitschrift  ST 
Computer  auf  Diskette 53 verîffentlicht.  Wie es  nicht  anders  kommen 
konnte,  haben sich einige Fehler eingeschlichen, bzw. habe ich noch hier 
und  da etwas verbessert und es ist PASCAL+ V2.00 und bald  danach  V2.02 
erschienen.  Die  énderungen  an  den  Libraries  sollen  hier  gesammelt 
dokumentiert  werden,  so  daû  sie  jeder Besitzer  der  alten  PD53  im 
Sourcecode der Libraries berÅcksichtigen kann.


CONVLIB

Die  interne Routine zzzctrim versagt bei Åbergebenen  Strings,  die  nur 
Leerzeichen  enthalten  (meist  kommt es  dÅmmer,  als  man  denkt).  Der 
Sourcecode ist wie folgt zu Ñndern:
     WHILE (length(s) > 0) AND (s[1] = ' ') DO
       delete (s, 1, 1);
     WHILE (length(s) > 0) AND (s[length(s)] = ' ') DO
       delete (s, length(s), 1);

In der Funktion str_to_real ist als erste Anweisung der Befehl
     ok := TRUE;
einzufÅgen.  Andernfalls  ist die Variable nicht initialisiert,  was  mit 
einiger  Wahrscheinlichkeit zu Fehlern fÅhren kann (ist mir  beim  Testen 
eben nicht passiert).


STRINLIB

Auch hier muû der Sourcecode der Routine ltrim :
     WHILE (length(s) > 0) AND (s[1] = ' ') DO
       delete (s, 1, 1);

und auch von rtrim :
     WHILE (length(s) > 0) AND (s[length(s)] = ' ') DO
       delete (s, length(s), 1);

geÑndert werden, um den oben angesprochenen Fehler zu vermeiden.

ACHTUNG!  Die Implementation und FunktionalitÑt der Formatierroutinen hat 
sich geÑndert.  So wird kein implizites trim mehr durchgefÅhrt und wo  zu 
lange Strings beschnitten werden, richtet sich nach der Art des Aufrufes. 
Die Routine zzzsformat entfÑllt.

  { Diese Prozeduren geben in s den  Åbergebenen String formatiert in der
  LÑnge width zurÅck. Ist s lÑnger als width,  so  wird der  Åberstehende
  Teil rechts (lformat), links (rformat) oder beidseitig (cformat)  abge-
  schnitten. Sonst wird s linksbÅndig (lformat),  rechtsbÅndig  (rformat)
  oder zentriert (cformat) entsprechend mit Leerzeichen aufgefÅllt. }

Der neue Sourcecode ist:

PROCEDURE lformat (VAR s : STRING; width : INTEGER);
BEGIN
IF length (s) > width THEN
    s := copy (s, 1, width)
ELSE WHILE (length (s) < width) DO
    s := concat (s, ' ');
END; { lformat }

PROCEDURE rformat (VAR s : STRING; width : INTEGER);
BEGIN
IF length (s) > width THEN
    s := copy (s, length(s) - width + 1, width)
ELSE WHILE (length (s) < width) DO
    s := concat (' ', s);
END; { rformat }

PROCEDURE cformat (VAR s : STRING; width : INTEGER);
VAR     i       : INTEGER;
BEGIN
IF length (s) > width THEN
    s := copy (s, (length(s) - width) DIV 2, width)
ELSE WHILE (length (s) < width) DO
    BEGIN
    s := concat (s, ' ');
    IF length (s) < width THEN
        s := concat (' ', s);
    END;
END; { cformat }


Eine  neue  Funktion zum Grîûenvergleich von Strings  ist  hinzugekommen. 
Dazu ist die Includedatei um folgenden Eintrag zu ergÑnzen:

FUNCTION str_greater (s1, s2 : STRING) : BOOLEAN;               EXTERNAL;
  { Die Funktion  liefert TRUE,  wenn s1 lexikalisch groesser als s2 ist.
  Dabei werden die deutschen Umlaute und esszett (Atari-interne  Darstel-
  lung) wie A, O, U bzw. S behandelt. Kleinbuchstaben werden  wie  Gross-
  buchstaben behandelt. }

FUNCTION str_greater (s1, s2 : STRING) : BOOLEAN;
VAR i : INTEGER;
        PROCEDURE zzzszeichen_pruefen (VAR s : STRING);
        BEGIN
        CASE ord(s[i]) OF
          142, 132 : s[i] := chr($41);   { Ae, ae => A }
          153, 148 : s[i] := chr($4F);   { Oe, oe => O }
          154, 129 : s[i] := chr($55);   { Ue, ue => U }
          158      : s[i] := chr($53);   { esszet => S }
          OTHERWISE: IF ord(s[i]) IN [$61..$7A] { Kleinb. => Grossb. }
                       THEN s[i] := chr(ord(s[i])-$20);
          END;
        END; { zzzszeichen_pruefen }
BEGIN
FOR i := 1 TO length (s1) DO
  zzzszeichen_pruefen (s1);
FOR i := 1 TO length (s2) DO
  zzzszeichen_pruefen (s2);
str_greater := (s1 > s2);
END; { str_greater }

Mit Erscheinen der neuen PASTRIX-Library sind die Routinen pa_to_str  und 
str_to_pa  sowie  die damit verbundene Datei  PA_TYP.INC  ÅberfÑllig  und 
ersatzlos gestrichen worden. Es gibt ja nun CtoPstr und PtoCstr.


DATELIB

KernstÅck  aller  Berechnungen  sind ja die  Funktionen  julian_date  und 
gregorian_date.  Die Algorithmen dafÅr stammen - wie dokumentiert - nicht 
von  mir.  Leider wurde in der Quelle kein Hinweis auf  den  GÅltigkeits-
bereich  dieser  Routinen gegeben,  so daû ich bei  einem  selbstgebauten 
Programm zur Mitgliederverwaltung meines Sportvereins keine  Geburtsdaten 
vor 1900 eingeben konnte (date_ok lieferte immer  FALSE).  Offensichtlich 
wurde die besondere Schaltjahrregel des Gregorianischen Kalenders bei der 
Jahrhundertwende  nicht berÅcksichtigt.  Daraufhin habe ich die  Funktion 
julian_date wie folgt geÑndert:
     FUNCTION julian_date (greg_date : REAL) : LONG_INTEGER;
     CONST a = 1720982;
     VAR d, m, y : INTEGER;
         b, c    : LONG_INTEGER;
         last_hundred : BOOLEAN;
     BEGIN
     date_dmy (greg_date, d, m, y);
     last_hundred := (y < 1900) OR ((y = 1900) AND (m < 3));
     IF m <= 2
       THEN BEGIN
       y := y - 1;
       m := m + 12
       END;
     m := m + 1;
     b := y;       { Zuweisung fuer LONG_INTEGER-Arithmetik }
     b := (b * 365) + (b DIV 4);
     c := trunc (30.6001 * m);
     c := a + b + c + d;
     IF last_hundred
       THEN c := c + 1;
     julian_date := c;
     END; { julian_date }

Der  GÅltigkeitsbereich  aller Routinen der Library  ist  somit  begrenzt 
durch den 1. MÑrz 1800 und den 28. Februar 2100.

Es gilt die Regel,  daû die Jahre zur Jahrhundertwende (also die mit zwei 
Nullen  am Ende) entgegen der Åblichen Regel (alle durch  vier  teilbaren 
Jahre) keine Schaltjahre sind, aber eben doch, wenn sie durch 400 teilbar 
sind  (also  ist  2000  ein  Schaltjahr,  nicht  jedoch  1900).  Wer  die 
Algorithmen  der  beiden Routinen entsprechend anpassen kann  (die  obige 
énderung  ist nur eine "KrÅcke" fÅr das  19.  Jahrhundert),  mîchte  sich 
bitte bei mir melden.

BUG +++ BUG +++ BUG +++ BUG +++ BUG +++ BUG +++ BUG +++ BUG +++ BUG +++ B

Beim  Abfragen des Systemdatums gab's unter gewissen UmstÑnden  Probleme, 
was  jedoch erst im nÑchsten Jahrtausend aufgefallen  wÑre.  Gravierender 
ist  der  analoge  Fehler  in  der  TIMELIB  (s.  unten).  Der  Code  der 
zustÑndigen Routinen ist nun:

FUNCTION sysdate_date (sdate : INTEGER) : REAL;
VAR d, m, y : INTEGER;
    date    : REAL;
BEGIN
d :=  sdate & $001F;
m := ShR ((sdate & $01E0), 5);
y := ShR ((sdate & $FE00), 9) + 1980;
dmy_date (d, m, y, date);
sysdate_date := date;
END; { sysdate_date }

FUNCTION date_sysdate (date : REAL) : INTEGER;
VAR d, m, y : INTEGER;
BEGIN
date_dmy (date, d, m, y);
m := ShL (m, 5);
y := ShL ((y - 1980), 9);
date_sysdate := d | m | y;
END; { date_sysdate }


TIMELIB

FUNCTION systime_time (stime : INTEGER) : REAL;
VAR h, m, s : INTEGER;
    t       : REAL;
BEGIN
h := ShR ((stime & $F800), 11);
m := ShR ((stime & $07E0),  5);
s := ShL ((stime & $001F),  1);
hms_time (h, m, s, t);
systime_time := t;
END; { systime_time }

FUNCTION time_systime (time : REAL) : INTEGER;
VAR h, m, s : INTEGER;
BEGIN
time_hms (time, h, m, s);
h := ShL (h, 11);
m := ShL (m,  5);
s := s DIV 2;
time_systime := h | m | s;
END; { time_systime }


Alle Åbrigen énderungen auf der neuen PD53 sind Schînheitskorrekturen, um 
die  Routinen  etwas  Åbersichtlicher  und  gelegentlich  auch  laufzeit-
effizienter  zu  gestalten.  Hoffentlich  sind dadurch  nicht  neue  Bugs 
hinzukommen. Eventuelle énderungen werde ich in Zukunft in Ñhnlicher Form 
dokumentieren  und  bei  Anfrage gegen  Einsendung  eines  RÅckumschlages 
zusenden. Vorerst wird sich allerdings nicht viel ereignen.

