

                        ππππππππππππππππππππππππππ
                              CHAPITRE nr¯ 3:

                        *   PREMIERS PROGRAMMES  *

                        ππππππππππππππππππππππππππ



                    *** INTRODUCTION AVEC UN EXEMPLE ***
                    ππππππππππππππππππππππππππππππππππππ

          - Soit le programme (#1) en ASSembleur 68000 suivant:


                             πππππππππππππππππππ

; programme #1 en Assembleur 68000

                TEXT                      ;dÇbut zone Text
                                   
A               EQU      18               ;A=18
B               EQU      2                ;B=2

                move.w   A,destination    ;pose mot A en destination
                move.b   B,autre          ;pose bit B en autre
                move.w   autre,d0         ;pose ce qu'il y a en autre ds
                                          ;le registre d0

                add.l    A,d0             ;ajoute A Ö d0
                lea      A,a0             ;met l'adresse de A ds le
                                          ;registre a0

                move.w   (a0)+,sauve_A    ;incrÇmente a0 et sauve a0
                add.l    sauve_A,d1       ;ajoute sauve_A Ö d1
                add.l    d0,d1            ;ajoute d0 Ö d1
                move.l   d1,resultat      ;pose d1 en resultat
                move.w   DAT,d0           ;met dat ds d0
                add.l    DAT,resultat     ;ajoute dat Ö rÇsultat
                clr.l    resultat         ;efface rÇsultat

                DATA                      ;dÇbut zone Data

DAT             DC.W    6                 ;data 6 en DAT

                BSS                       ;dÇbut zone Bss

sauve_A         DS.L    1                 ;rÇserve un M-L en sauve_A
resultat        DS.L    1                 ;rÇserve un M-L en resultat
destination     DS.L    1                 ;idem en destination
autre           DS.B    1                 ;rÇserve un OCTET en autre


                END                       ;fin du listing

      
                        ππππππππππππππππππππ


1)  EXPLICATIONS:
    πππππππππππππ
  - Ne cherchez pas de sens particulier Ö ce listing, il n'a pour but que
    d'introduire les diffÇrentes notions de la programmation en ASS...

  - Comme vous pouvez le constater, un programme en ASS. est structurÇ.
    Cette structure se divise en 3 colonnes.

          .1¯ colonne: Les LABELS ou noms d'êTIQUETTES:
           πππππππππππ
           Ils ont pour but de fixer une adresse de la mÇmoire,ainsi on
           peut appeller une ADRESSE en nommant le LABEL quand une ins-
           truction le nÇssecite. (Comme un numÇro de ligne en BASIC)

           La vÇritable adresse attribuÇe au Label est donnÇe apräs le
           'linkage',ces adresses servent de points de repÇres dans
           le prg , et ne pointent pas sur des adresses dÇfinissables.
           (Sauf si le programme est relogÇ en un endroit prÇcis de la
           mÇmoire, mais cela n'a pas de rÇel intÇrät)

          .2¯ colonne: Les INSTRUCTIONS et leurs OPêRANDES:
           πππππππππππ
           Les instructions indiquent Ö l'ordi la marche Ö suivre, ces
           instructions peuvent ätres suivies d'opÇrandes si leur syn-
           taxe le demande ( comme pour MOVE x,y )

           En ASS 68000, on dÇmonbre 56 instructions de Base.

          .3¯ colonne: Les REMARQUES:
           πππππππππππ
           Tout le texte situÇ apräs les OpÇrandes n'est plus reconnu en
           tant qu'instruction, et il peut donc servir Ö dÇcrire le lis-
           ting en y mettant des renseignements utiles...
           Avec certains Çditeurs (PROFIMAT), il faut mettre une virgule
           avant les commentaires, sinon cela entraine une erreur lors 
           de l'assemblage.
           Les lignes blanches (ou vides) ou celles qui commencent par *
           (pour METACOMCO ) ou ';' (pour PROFIMAT)sont aussi assimillÇes
           Ö des REMARQUES.

     NB: .Pour qu'un LABEL soit reconnu comme tel, il doit ätre Çcris sur
     πππ  la premiÇre colonne, les autres colonnes doivent ätres sÇparÇes
          d'au moins un espace (' ').

         .Pas plus d'une instruction par ligne.



2)  COMMENTAIRE DêTAILLê DU LISTING:
    ππππππππππππππππππππππππππππππππ

-ligne 1 : '; Programme #1 en Assembleur 68000 '
 πππππππππ  
     .Comme vous pouvez le constater, il sagit d'une 'remarque', ici
      ,il s'agit du nom du programme...

-ligne 2 : '                                               '
 πππππππππ
     .Une ligne blanche...       c.Ö.d. rien du tout (eh oui !)


-ligne 3 : '           TEXT'
 πππππππππ
     .Il y a une instruction (colonne 2).
     .Il s'agit en fait d'une DIRECTIVE D'ASSEMBLAGE.
     .Les DIRECTIVES sont des fonctions propres Ö l'ASSEMBLEUR utilisÇ,
      ceci peut expliquer pourquoi leur syntaxe peut varier avec l'Çdi-
      teur utilisÇ.
      Pour la plupart des directives,la syntaxe est identique. (je vous
      nommerais les exceptions mais la notice de votre assembleur devrait
      contenir les noms et la description des directives qu'il utilise.)
     .Les DIRECTIVES se placent sur la 2¯ colonne du listing, tout comme
      les intructions ou les MACROS-INSTRUCTIONS.
     .La directive 'TEXT' a pour effet de forcer l'initialisation du P.C.
      ,le Compteur Programme. ( Ö 0 ou Ö sa valeur lors de sa derniäre
      initialisation si il existe plusieurs sections 'text' )

                               ----------------


- Mais qu'est ce que le 'P.C.' ? :
                     ππππππππππππ
- C'est le compteur programme ou Programm Counter
  C'est un REGISTRE de 32 Bits qui contient l'adresse ( paire ) du MOT
  dans lequel se trouve le CODE (en BIN) de la prochaine instruction Ö
  exÇcuter.
  En pratique, seul les 24 Bits de poids faibles sont utilisÇs dans ce
  registre particulier.

  Le P.C. est donc incrÇmentÇ aprÇs chaque instruction d'un nombre pair
  d'octets (suivant la taille de l'instruction) .

  Les instructions de saut (jmp...) ou de branchement (bsr..), ont pour
  but de modifier le P.C. et provoquent ainsi un saut Ö l'adresse que
  pointe le P.C.

  donc:            PC      |    code de l'instruction en BIN
  πππππ
                                ???????????????
             PC ---------->
                                ???????????????
             PC ---------->
                                ???????????????
             PC ---------->

                           etc...

    reprÇsentation du PC:
    πππππππππππππππππππππ
             32       23                                             0
              ********[][][][][][][][][][][][][][][][][][][][][][][][]



                            ------------------

     .La directive 'TEXT' a donc pour but d'intialiser le P.C.:
      Elle prÇcäde les instructions qui forment le listing,d'oó
      le nom 'text'.



-ligne 4: ' A        EQU        18 '
 ππππππππ (je ne compte plus les lignes blanches)

         .On trouve, un LABEL: A, une DIRECTIVE : EQU et son OPêRANDE: 18
         .la directive EQU a pour but d'assigner une valeur Ö l'Çtiquette
          Ö laquelle elle se rapporte.(un nombre entier)
          Dans notre listing: on associe la valeur 18 Ö l'adresse 'A'

-ligne 5: ' B        EQU         2 '
 ππππππππ
          .On associe 2 Ö l'adresse 'B'

-ligne 6: '          move.w      A,destination '
 ππππππππ

          .On y trouve une INSTRUCTION (move) et deux oÇrandes (la source
           et la destination)
          .L'instruction 'move' dÇplace une opÇrande source j'usqu'Ö une
           opÇrande destination.
          .L'instruction 'move' est suivie du suffixe '.w' : ceci indique
           que l'instruction agit sur un MOT (ou Word)

          .Il existe 3 suffixes pouvant ätres rajoutÇs Ö certaines instru
           -ctions (nous verrons en dÇtail lesquelles)

               - .L  :l'instruction porte sur un L-M ( Long )
               - .W  :elle porte sur un MOT ( Word )
               - .B  :elle porte sur un OCTET (ou Byte en Anglais)

 NB:  Si une instruction admet un de ces suffixe et qu'on ne le met pas :
 ππ  par exemple si on Çcrit  'MOVE   #1,d0', le suffixe .W sera pris par 
     dÇfaut,c.Ö.d. que si vous Çcrivez 'MOVE #3,d2' cela revient Ö Çcrire
     'MOVE.W  #3,d2' )


                               ----------------------

 Que sont Les MODES D'ADRESSAGE ?:
          πππππππππππππππππππππππππ

       VoilÖ le point le plus fondamental de la programmation en ASS.

 - L'Ass permet de dÇplacer aisement des donnÇes en mÇmoire (par exemple
   avec l'instruction 'move') ou de 'pointer' sur des instructions ou des
   donnÇes repÇrÇes en mÇmoire.
   Une des richesses de l'Ass. comparÇ aux autres langages est que l'Ass.
   utilise plusieurs MODES D'ADRESSAGES :14 en 68000.
   C.Ö.d. qu'en Ass, il est possible de dÇplacer (directement ou indirec-
   tement) des donnÇes en mÇmoire ou d'agir sur des donnÇes localisÇes en
   mÇmoire, de 14 mamiäres diffÇrentes !

 - Les ÇlÇments qui interviennent dans les diffÇrents modes d'adressages
   sont: Les REGISTRES,le PC (et aussi le SR , un registre trÇs spÇcial,
   que nous Çtudierons en dÇtail)

                                les REGISTRES:
                                ππππππππππππππ

. On distingue les REGISTRES DE DONNêES:
                   πππππππππππππππππππππ
  Ils sont 8 et sont dÇsignÇs par leurs adresses:d0,d1,d2,d3,d4,d5,d6,d7
  ,ils ont une taille de 32 Bits et SERVENT AU STOCKAGE DE DONNêES numÇ-
  riques.                           ππππππππππππππππππππππππππππππ
          ainsi, si on Çcrit:    MOVE.L    #1,d0
                                 ADD.L     #1,d0

  On pose 1 dans le registre d0 de 32 Bits (les 32 Bits du registre sont
  affectÇs par l'instruction 'move.l' Ö cause du suffixe '.L' ), puis on
  ajoute (add.l) 1 Ö ce registre (les 32 Bits du registre sont Ö nouveau
  affectÇs), donc d0 contiendra '2' et sera reprÇsentÇ ainsi en mÇmoire:

                      00000000000000000000000000000010        ,(%10=2)


           et  les REGISTRES D'ADRESSES:
                   πππππππππππππππππππππ

  Ils sont 9 ,8 sont Ö la disposition du programmeur: ils sont dÇsignÇs
  par leurs adresses:a0,a1,a2,a3,a4,a5,a6,a7 et SERVENT AU STOCKAGE DES
  ADRESSES.                                     πππππππππππππππππππππππ
  ππππππππ
           ainsi, si on Çcrit:  MOVE.L  NOM,a0

  Le registre a0 est chargÇ avec la valeur de l'adresse de 'NOM' (les 32
  bits du registre a0 sont affectÇs Ö cause du suffixe '.L')


  ATTENTION: On ne peut transfÇrer que des MOTS ou des L-M dans un
  ππππππππππ REGISTRE D'ADRESSE (pas d'OCTET,c'est träs important!)


NB  le registre a7 est particulier, il est utilisÇ comme pointeur de PILE
ππ  SYSTEME ( ou SP de 'Stack Pointer' ) qui est une zone particuliäre de
    la mÇmoire utilisÇe par certaines instructions de saut qui y stockent
    l'adresse de retour Ö l'instruction appelant le sous programme (en rÇ-
    alitÇ c'est le PC qui est sauvÇ puis rechargÇ ,donc remis Ö sa valeur
    initiale Ö la fin du sous programme ce qui provoque un retour Ö l'ins-
    truction suivant l'instruction de saut, nous Çtudierons cela en pro-
    fondeur plus tard)




       il y a le PC, qui EST aussi UN REGISTRE:
              πππππ


.Nous avons vu qu'il est composÇ de 32 bits dont 24 sont utilisÇs et qu'                             
 il pointe sur l'adresse paire de la prochaine instruction Ü executer.

       et le  SR (le Registre d'Çtat ou 'Status Register'):
              ππ
  C'est un registre de 16 Bits qui se divise en 2 octets distincts:

     - Un octet utilisateur (de poids faible)
     - Un octet superviseur (de poids fort)

  Voici sa structure:

                     superviseur        |       utilisateur
              --------------------------+------------------------

SR:           [T][ ][S][ ][ ][i2][i1][i0][ ][ ][ ][X][N][Z][V][C]
πππ
     Bits n¯ 15                        8  7                    0


  - L'octet superviseur:n'est utilisable en Çcriture qu'en MODE SUPER-
    VISEUR par mise Ö 1 du bit 'S'. ( Il existe une fonction du Gemdos
    qui le fait si on l'appelle )
    Ce n'est qu'en mode superviseur qu'on peut avoir accäs Ö la PILE
    SYSTEME et Ö certaines instructions dites privilÇgiÇes.

    La mise Ö 1 du bit 'T' permet ou microprocesseur de fonctionner en
    mode TRACE (exÇcution pas Ö pas du prg Ö chaque instruction, nous
    en reparlerons dans le chapitre sur les DêBUGGERS)

    Les bits i2,i1,i0 constituent le masque d'interruption.

    (j'y reviendrais en dÇtail...)



  - L'octet utilisateur:est utilisable dans les 2 MODES (utilisateur et
    superviseur)
    Cet OCTET est aussi appellÇ REGISTRE DES CODES CONDITIONS ou CCR de
    'Condition Codes Register'                                   πππ
                                                            
  - Il est modifiÇ par la plupart des instructions du 68000.

    *   Le bit 'N' (n¯3) est Ö 1 si le rÇsultat d'une opÇration
        arithmÇtique est NÇgatif ,sinon il est mis Ö 0.

    *   Le bit 'Z' (n¯2) est mis Ö 1 si le rÇsultat d'une opÇration
        est nul (ZÇro) , sinon il est mis Ö 0.
       
    *   Le bit 'V' (n¯1) est mis Ö 1 si le rÇsultat d'une opÇration
        ne peut pas ätre reprÇsentÇ dans la taille de l'opÇrande dÇ-
        finie (dÇbordement) sinon il est mis Ö 0.

    *   Le bit 'C' (n¯0) est mis Ö 1 si une opÇration provoque une
        retenue au dela du bit de plus fort poids de l'opÇrande rÇ
        sultat (division par exemple), sinon il est mis Ö 0.

    *   Le bit 'X' (n¯4) est le bit d'eXtension, son utilisation se
        limite Ö certaines instructions que nous Çtudierons.



.Maintenant que vous vous ätes familliarisÇ avec les diffÇrents Registres
 du 68000, je vais dÇfinir les diffÇrents MODES D'ADRESSAGE.

 Les modes d'adressage permettent de modifier les valeurs du PC, du SP,
 du SR et la pile systäme.

 je prendrais les intructions MOVE (permet de dÇplacer l'opÇrande source
 jusqu'Ö l'opÇrande destination) et ADD (ajoute l'opÇrande source Ö son
 opÇrande destination) pour illustrer les diffÇrents types de modes d'ad-
 ressage.





                  *** LES MODES D'ADRESSAGE DU 68000 ***
                      ππππππππππππππππππππππππππππππ


1) l'adressage IMMêDIAT    (shÇmatisÇ #...)
   ππππππππππππππππππππ

   A) NUMêRIQUE: (L'opÇrande source est une donnÇe)
      ππππππππππ
      Il s'Çcrit:
      πππππππππππ
                    +-------------------------------------+
                    | Instruction     #donnÇe,destination |
                    +-------------------------------------+

      Et se lit:
      ππππππππππ
      On pose la donnÇe source dans ( Ö ) l'opÇrande destination



   Exemples:
   πππππππππ        MOVE    #12,d1

           ( c.Ö.d. MOVE.W  #12,d1)

    On pose le nombre 12 ,codÇ sur un MOT dans le MOT de poids faible du
    registre d1:

                           0000000000001100 ( Mot=%12 )

                                  |
                                 \|/

           ................0000000000000000( Registre d1, seul le MOT de
                                            poids faible est affectÇ car
Bits n¯  31               15              0 on a Çcrit:'move.W' )

                            et on obtient:
                            ππππππππππππππ

           ................0000000000001100 ( %12 Dans le MOT de poids
                                              faible de d1 )
Bits n¯  31               15              0



          Exp 2:    ADD.L    #3,d1
          ππππππ
    On ajoute 3, codÇ sur un L-M au contenu de d1 et les 32 bits de d1
    participent Ö l'opÇration:


                   00000000000000000000000000000011  ( L-M=%3 )

                                 |
                                \|/

                   00000000000000000000000000000000  ( Registre d1 )

Bits n¯           31                              0
                            et on obtient:
                            ππππππππππππππ

                   00000000000000000000000000000011  ( Registre d1=%3)

Bits n¯           31                              0



    B) SYMBOLIQUE:   (L'opÇrande source est un LABEL)
       ππππππππππ

        Il s'Çcrit:
        πππππππππππ      +--------------------------------------+
                         | Instruction       #Label,destination |
                         +--------------------------------------+

        Et se lit:
        ππππππππππ
        On pose l'adresse du Label dans ( Ö ) l'opÇrande destination.


   Exemple:
   ππππππππ
                    MOVE.L      #etiquette,a0

     On pose le L-M (paire) contenant l'adresse de 'etiquette' dans le
     registre d'adresse a0, les 32 bits du registre sont affectÇs.

   si on a  l'adresse de 'etiquette' =00000000000000001101101011010000

          cela donnerait:

             00000000000000001101101011010000  ( adresse de 'etiquette')

                            |
                           \|/

             00000000000000000000000000000000  ( Registre a0 )

Bits n¯     31                              0

                      et on obtiendrait:
                         πππππππππππππππ

             00000000000000001101101011010000  ( adresse de 'etiquette'

                                                 dans le registre a0 )
Bits n¯     31                              0




2) L'adressage INDIRECT SIMPLE:       (shÇmatisÇ: (an) )
   ππππππππππππππππππππππππππππ

      Il s'Çcrit:
      πππππππππππ
                    +-------------------------------------+
                    | Instruction        (an),destination |
                    +-------------------------------------+
                                     OU
                                     ππ
                    +-------------------------------------+
                    | Instruction             source,(an) |
                    +-------------------------------------+


      Et se lit:
      ππππππππππ
      On dÇplace la donnÇe pointÇe par le registre d'adresse an dans
      ( Ö ) l'opÇrande destination.
                                    OU
                                    ππ
      On dÇplace la donnÇe source jusqu'Ö l'adresse pointÇe par an


   Exemple:
   ππππππππ
                      MOVE.B       (a2),d2

   On pose le BIT situÇ Ö l'adresse pointÇe par le registre d'adresse a2
   dans le BIT de poids faible du registre de donnÇe d2.

   Ainsi, si a2 pointe sur une adresse qui contient l'octet 01101001

                  On obtient:

              ........................01101001    (registre d2)

   Bits n¯   31                       7      0  


   NB: notez que la taille d'opÇration .B est autorisÇe pour ce mode
       d'adressage, alors qu'elle est interdite pour dÇplacer une ad-
       resse dans un registre.



3) L'adressage INDIRECT AVEC POSTINCRêMENTATION:    (shÇmatisÇ  (an)+ )
   πππππππππππππππππππππππππππππππππππππππππππππ

     Il s'Çcrit:
     πππππππππππ
                  +-----------------------------------+
                  | Instruction     (an)+,destination |
                  +-----------------------------------+
                                   OU
                                   ππ
                  +-----------------------------------+
                  | Instruction          source,(an)+ |
                  +-----------------------------------+

     Et se lit:
     ππππππππππ
     On prend la donnÇe pointÇe par le registre d'adresse 'an', puis on
     incrÇmente (augmente) la valeur de 'an' en fonction du SUFFIXE de
     l'instruction ( de 1 pour .B, 2 pour .W, 4 pour .L ) et on dÇplace
     la donnÇe ainsi pointÇe jusqu'Ö l'opÇrande destination.

                                   OU
                                   ππ
     On dÇplace l'opÇrande source jusqu'Ö l'adresse pointÇe par le regis-
     tre an, puis on incrÇmente la valeur de 'an' en fonction du SUFFIXE
     de l'instruction ( de 1 pour .B, 2 pour .W, 3 pour .L )


     C'est Ö dire:  Si vous Çcrivez ' MOVE.B   #%10101011,(A2)+ '
     πππππππππππππ
     Vous posez le BIT '10101011' Ö l'adresse que pointe le registre a2
     , puis le registre d'adresse a2 est INCRêMENTê d'1 unitÇ ( .B ).

     Si a2 pointe par exemple sur l'adresse $FFA0:

          on a:                10101011
                                   |
                                  \|/

                              |--------|--------| $FF9F
                        $FFA0 |--------|--------| $FFA1
          mÇmoire:      $FFA2 |--------|--------| $FFA3
          ππππππππ            |--------|--------|


          registre a2:   00000000000000001111111110100000  (=$ffa0)
          ππππππππππππ


                                 et on obtient:
                              

                              |--------|--------| $FF9F
                        $FFA0 |10101011|--------| $FFA1
          mÇmoire:      $FFA2 |--------|--------| $FFA3
          ππππππππ            |--------|--------|

          registre a2:   00000000000000001111111110100001  (=$ffa1)
          ππππππππππππ

          .L'octet 10101011 est placÇ en $FFA0

          .L'adresse de a2 est IncrÇmentÇ de 8 Bits (un Octet) car le
           suffixe de l'instruction est ' .B ', comme la mÇmoire est
           adressable Ö l'octet, a2 est augmentÇ d'une unitÇ.



  Et si on Çcrivait maintenant:        MOVE.B   #%11101010,(a2)

  Que se passerait-il ?

  RÇponse: MOVE.B    #%11101010,(a2) c'est poser l'octet 11101010 Ö
  ππππππππ l'adresse pointÇe par le registre a2:
           Comme a2 vaut $FFA1 maintenant, on obtiendrait:


                              |--------|--------| $FF9F
                        $FFA0 |10101011|11101010| $FFA1
          mÇmoire:      $FFA2 |--------|--------| $FFA3
          ππππππππ            |--------|--------|

          registre a2:  00000000000000001111111110100001  (=$ffa1)
          ππππππππππππ


  Et si j'Çcris maintenant :          MOVE    #%00000001,(a2) ?

  Il y aurait une ERREUR !, a2 pointe sur $FFA1, c'est une adresse
  impaire, donc impropre pour y placer un MOT  (MOVE sans suffixe =
  MOVE.W)

  Et si j'Çcrivais :                  MOVE.B     (a2)+,(a2) ?

  Je prends l'octet que pointe a2, j'augmente a2 d'une unitÇ (.B) c.Ö.d.
  que a2 pointe sur $FFA2 et je place cet octet Ö l'adresse que pointe
  a2, c.Ö.d. en $FFA2 puisque a2 vient d'ätre incrÇmentÇ.

             cela donne:



                              |--------|--------| $FF9F
                        $FFA0 |10101011|11101010| $FFA1
          mÇmoire:      $FFA2 |--------|--------| $FFA3
          ππππππππ            |--------|--------|

          registre a2:  00000000000000001111111110100001  (=$ffa1)
          ππππππππππππ

                          apräs MOVE.B    (a2)+,(a2)

                              |--------|--------| $FF9F
                        $FFA0 |10101011|11101010| $FFA1
          mÇmoire:      $FFA2 |11101010|--------| $FFA3
          ππππππππ            |--------|--------|

          registre a2:  00000000000000001111111110100001  (=$ffa1)
          ππππππππππππ



  Si maintenant je change la valeur de a2, et que a2 vaut $FFA0 et si
  j'Çcris:     MOVE   (a2)+,(a2)+

  On prend le MOT en $FFA0, on incrÇmente a2 ,a2 vaut donc $FFA2 ( car
  MOVE = MOVE.W et un MOT=2 Octets, comme la mÇmoire est adressable au
  niveau de L'octet: a2=a2+2 Oct ) et on le met Ö l'adresse pointÇe par
  le registre a2 (c.Ö.d. $FFA2) puis on incrÇmente Ö nouveau le registre
  d'adresse a2 de 2 (Oct.) donc a2 vaudra finalement $FFA4.



                              |--------|--------| $FF9F
                        $FFA0 |10101011|11101010| $FFA1
          mÇmoire:      $FFA2 |11101010|--------| $FFA3
          ππππππππ      $FFA4 |--------|--------|

          registre a2:  00000000000000001111111110100000  (=$ffa0)
          ππππππππππππ

                               MOVE  (a2)+,(a2)+

                              |--------|--------| $FF9F
                        $FFA0 |10101011|11101010| $FFA1
          mÇmoire:      $FFA2 |10101011|11101010| $FFA3
          ππππππππ      $FFA4 |--------|--------|

          registre a2:  00000000000000001111111110100100  (=$ffa4)
          ππππππππππππ



4) L'adressage INDIRECT AVEC PRêDêCRêMENTATION:     (shÇmatisÇ -(an) )
   ππππππππππππππππππππππππππππππππππππππππππππ

   Il s'Çcrit:
   πππππππππππ      +------------------------------------+
                    | Instruction      -(an),destination |
                    +------------------------------------+
                                      OU
                                      ππ
                    +------------------------------------+
                    | Instruction            source,-(an)|
                    +------------------------------------+

   Et se lit:
   ππππππππππ
  On dÇcrÇmente (diminue) la valeur du registre d'adresse an en fonction
  du suffixe de l'instruction (de 1,2 ou 4) , on prend la donnÇe pointÇe
  par cette nouvelle valeur de 'an' et on la pose dans ( Ö ) l'opÇrande
  destination.

                                     OU
                                     ππ
  On prend l'opÇrande source, on dÇcrÇmente la valeur du registre 'an' en
  fonction du suffixe de l'instruction (de 1,2 ou 4) puis on la pose dans
  dans ( Ö ) l'adresse pointÇe par cette nouvelle valeur de 'an'.


NB:  Important, notez que pour ce mode d'adressage la dÇcrÇmentation de 
πππ  'an' se fait avant (signe '-' avant '(an)' , c'est de lÖ que vient 
     le nom de PRêdÇcrÇmentation).
     Pour le mode d'adressage (an)+ ,le signe '+' se situe apräs '(an)',
     ceci explique le nom de POSTincrÇmentÇ.


     Ce mode d'adressage ressemble fort au mode d'adressage postincrÇmentÇ
     (an)+ ,sauf qu'ici le registre d'adresse 'an' voit sa valeur diminuer
     en fonction du suffixe de l'instructon.


exemple:      Soit la portion de mÇmoire suivante:
ππππππππ

              Si le registre a2 pointe sur $FFA4:

                              |--------|--------| $FF9F
                        $FFA0 |10101011|11101010| $FFA1
          mÇmoire:      $FFA2 |11101010|00000001| $FFA3
          ππππππππ      $FFA4 |--------|--------|

          registre a2:  00000000000000001111111110100100  (=$ffa4)
          ππππππππππππ

      et si j'Çcris:        MOVE.L   -(a2),-(a2)

      On dÇcrÇmente a2 de 4 (oct.) car on a move.L , a2 pointe donc sur
      $FFA0, on prend le L-M situÇ en $FFA0, on dÇcrÇmente Ö nouveau a2
      de 4 , a2 pointe donc sur $FF9C et on dÇplace le L-M en $FF9C

      on a donc:



                              |--------|--------| $FF9B
                        $FF9C |10101011|11101010| $FF9D
                        $FF9E |11101010|00000001| $FF9F
                        $FFA0 |10101011|11101010| $FFA1
          mÇmoire:      $FFA2 |11101010|00000001| $FFA3
          ππππππππ      $FFA4 |--------|--------|

          registre a2:  00000000000000001111111110011100  (=$ff9c)
          ππππππππππππ



      Si maintenant je fais pointer a2 sur $FFA0 et que j'Çcris:

                            MOVE.B   #23,-(a2)

      Je prend l'octet 23 (=%00010111) , je dÇcrÇmente a2 de 1 (.B), a2
      vaudra donc $FF9F et je pose l'octet 00010111 Ö cette nouvelle ad-
      resse.

      Donc:

                              |--------|--------| $FF9F
                        $FFA0 |10101011|11101010| $FFA1
          mÇmoire:      $FFA2 |11101010|00000001| $FFA3
          ππππππππ      $FFA4 |--------|--------|

          registre a2:  00000000000000001111111110100000  (=$ffa0)
          ππππππππππππ
                                 MOVE.B   #23,-(a2)

                                     donne:

                              |--------|00010111| $FF9F  (23 en $FF9F)
                        $FFA0 |10101011|11101010| $FFA1
          mÇmoire:      $FFA2 |11101010|00000001| $FFA3
          ππππππππ      $FFA4 |--------|--------|

          registre a2:  0000000000000000111111111011111  (=$ffa0)
          ππππππππππππ


5) L'adressage INDIRECT AVEC DêPLACEMENT:       (shÇmatisÇ  d(an) )
   ππππππππππππππππππππππππππππππππππππππ

   Il s'Çcrit:
   πππππππππππ       +------------------------------------+
                     | Instruction      d(an),destination |
                     +------------------------------------+

   Et se lit:
   ππππππππππ
   On ajoute au contenu du registre d'adresse 'an', la valeur (signÇe)
   du dÇplacement 'd', la donnÇe pointÇe par cette nouvelle valeur du
   registre 'an' est posÇe dans ( Ö ) l'opÇrande destination.

   Donc  d(an)= d+(an)

   'd' est un nombre entier signÇ (+ si le MSB est nul,- si il est actif)
   et contenu dans un MOT: ( -32768 <= d < 32768 ).


   Exemple:      Si le registre d'adresse a3 pointe sur $FFA0
   ππππππππ

                              |--------|--------| $FF9F
                        $FFA0 |--------|--------| $FFA1
          mÇmoire:      $FFA2 |--------|--------| $FFA3
          ππππππππ      $FFA4 |--------|--------|

          registre a3:  00000000000000001111111110100000  (=$ffa0)
          ππππππππππππ

          et que j'Çcris:      MOVE.W  #458,2(a3)

          On pose 458=%0000000111001010 Ö l'adresse $FFA0+2=$FFA2

                                   on obtient:

                              |--------|--------| $FF9F
                        $FFA0 |--------|--------| $FFA1
          mÇmoire:      $FFA2 |00000001|11001010| $FFA3
          ππππππππ      $FFA4 |--------|--------|

          registre a3:  00000000000000001111111110100000  (=$ffa0)
          ππππππππππππ
          Le registre a3 est inchangÇ !



6) L'adressage INDIRECT AVEC INDEX ET DêPLACEMENT:  (shÇmatisÇ d(an,rn) )
   πππππππππππππππππππππππππππππππππππππππππππππππ
   Il s'Çcrit:
   πππππππππππ  +---------------------------------------+
                | Instruction      d(an,rn),destination |
                +---------------------------------------+

   Et se lit:
   ππππππππππ 
   On ajoute au registre 'an', la valeur signÇe du dÇplacement 'd' contenu
   sur un MOT et la valeur du registre 'rn' (d'adresse ou de donnÇe), puis
   on dÇplace la donnÇe ainsi pointÇe dans ( Ö ) l'opÇrande destination.

   donc d(an,rn)= d+(an)+(an)   ou    =d+(an)+(dn)

   Si le registre rn prend le suffixe .w, son mot de poids faible parti-
   cipe Ö l'opÇration, si il prend le suffixe .l, il y participe en ent-
   ier. (taille .w par dÇfaut)

 Exemple: Si le registre d'adresse a2 pointe sur $FFA0 et si le registre de
 ππππππππ donnÇe d5 vaut 122.

            Si j'Çcris        MOVE.B   #2,5(a2,d5)

          On pose l'octet 2=%00000010 en 5+$FFA0+122=$1001F

                                        00000010
                                            |
                                           \|/
                              |--------|--------| $FF9F
                        $FFA0 |--------|--------| $FFA1
          mÇmoire:      $FFA2 |--------|--------| $FFA3
          ππππππππ      $FFA4 |--------|--------|

          registre a2:  00000000000000001111111110100000  (=$ffa0)
          ππππππππππππ
          registre d5:  00000000000000000000000001111010  (=122)
          ππππππππππππ
                                  on obtient:

                              |--------|--------| $1001D
                       $1001E |--------|00000010| $1001F
          mÇmoire:     $10020 |--------|--------| $10021
          ππππππππ     $10022 |--------|--------| $10023

          registre a2:  00000000000000001111111110100000  (=$ffa0)
          ππππππππππππ
          registre d5:  00000000000000000000000001111010  (=122)
          ππππππππππππ
          Les registres a2 et d5 sont inchangÇs !


NB: ATTENTION,certains Assembleurs (Metacomco) n'admettent pas la syntaxe 
πππ (an,rn) si d=0, il faut Çcrire 0(an,rn) quand d=0 !


                              πππππππππππππππππ




PIECHOCKI Laurent
8, impasse Bellevue                         
57980 TENTELING                                  suite dans COURS.DOC
                                                            πππππππππ

