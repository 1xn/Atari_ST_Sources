<!DOCTYPE HTML>
<HTML>
<!-- HTML conversion created with STG2HTML v0.75 -->
<!-- Copyright 2014 by Lonny Pursell and ENCOM -->
<!-- All rights reserved. -->
<HEAD>
<TITLE>GFABasic.HYP v2.92 (5/29/2017)</TITLE>
<STYLE><!--A{text-decoration:none}--></STYLE>
</HEAD>
<BODY STYLE="FONT-FAMILY:'Monaco'" BGCOLOR="WHITE" TEXT="BLACK" LINK="BLUE">
<PRE>
<H1>The GFA-Basic Compendium</H1>
Subject: Documentation/Programming
Author: GFA Systemtechnik GmbH

HTML conversion created with <B>STG2HTML v0.75</B>
Written by Lonny Pursell and ENCOM
<I>Note: Images are not supported.</I>

<A HREF="#_Index_">Index</A>
<HR SIZE=3><H2 ID="Main">Main</H2>
<A HREF="#GFA-Basic_Editor/Interpreter_Manual">GFA-Basic Editor/Interpreter Manual</A>  <A HREF="#AES">AES</A>
<A HREF="#GFA-Basic_Compiler/Linker_Manual">GFA-Basic Compiler/Linker Manual</A>     <A HREF="#VDI">VDI</A>
<A HREF="#GFA-Basic_Addendum">GFA-Basic Addendum</A>                   <A HREF="#BIOS">BIOS</A><A HREF="#()">()</A>
                                     <A HREF="#XBIOS">XBIOS</A><A HREF="#()">()</A>
<A HREF="#Error_Codes">Error Codes</A>        <A HREF="#index">index</A>             <A HREF="#GEMDOS">GEMDOS</A><A HREF="#()">()</A>
<A HREF="#Number_Table">Number Table</A>       <A HREF="#Shift_Table">Shift Table</A>       <A HREF="#LINE-A">LINE-A</A>

<A HREF="#HYPertext_Version">HYPertext Version</A>  <A HREF="#EULA">EULA</A>              <A HREF="#Help">Help</A>

<HR>
The Atari Compendium
The documentation for TOS (aka TOS.HYP)
<HR SIZE=3><H2 ID="Help">Help</H2>
<B>How to use this HYPertext</B>

At the end of most pages are external links to 'The Atari Compendium'
(compend.hyp) which should be placed in the same directory as this
document. The external links are denoted by the <A HREF="#'">'</A><A HREF="#+">+</A>' sign after them.

<B>Example:</B>

appl_init()<A HREF="#+">+</A> would be an external link to the page 'appl_init()' in the
compend.hyp.

The external links provide additional information which may be more
accurate than the information provided in this document.

You migh also see a <B>Memo</B> at the end of various pages. These provide
information that I've discovered on my own or reported from other
<A HREF="#GFA-Basic">GFA-Basic</A> users.
<HR SIZE=3><H2 ID="Document_not_found">Document not found</H2>
The requested document was not found.

Please recheck your typing and try again or check the <A HREF="#index">index</A> for the page
you were looking for.
<HR SIZE=3><H2 ID="GFA-Basic">GFA-Basic</H2>
<A HREF="#GFA-Basic">GFA-Basic</A> is the best BASIC for the Atari!
<HR SIZE=3><H2 ID="Lonny_Pursell">Lonny Pursell</H2>
<A NAME="ENCOM"></A>WWW: <A TARGET="_BLANK" HREF="http://gfa.atari-users.net/atari/">http://gfa.atari-users.net/atari/</A>
<HR SIZE=3><H2 ID="DR">DR</H2>
Digital Research
<HR SIZE=3><H2 ID="HYPertext_Version">HYPertext Version</H2>
Manual ported by <A HREF="#Lonny_Pursell">Lonny Pursell</A> and <A HREF="#ENCOM">ENCOM</A> [v2.92 5/29/2017]

WWW: <A TARGET="_BLANK" HREF="http://gfa.atari-users.net/atari/">http://gfa.atari-users.net/atari/</A>

Tools used in porting:
  <A HREF="#GFA-Basic">GFA-Basic</A>
  ST-Guide
  STeno
  ScanX Pro
  OCR
  QED
  GEMView

Time spent porting:
  I spent about 2 months working on this project. On an average I spent 3 days
  per week (6 hours a day) scanning and editing the text. The grand total is
  approximately 144 hours. The raw data is about 736k.

<HR>

<B>Note:</B> I have <A HREF="#GFA-Basic">GFA-Basic</A> v3.6TTe (last known version) so all comments are based
      on this version.

Written by <A HREF="#Lonny_Pursell">Lonny Pursell</A>
(C)1998-2017 <A HREF="#Lonny_Pursell">Lonny Pursell</A> and <A HREF="#ENCOM">ENCOM</A>
<U>All</U> <U>rights</U> <U>reserved.</U>

<HR>

<B>Disclaimer</B>
This package may <A HREF="#NOT">NOT</A> be freely distributed under any conditions whatsoever. It
was ported to HYPertext so that I could speed up my own personal software
developement. I claim absolutely no rights to the information contained within
or responsibility for anything resulting from improper distribution.
<HR SIZE=3><H2 ID="GFA-Basic_Addendum">GFA-Basic Addendum</H2>
<A HREF="#End-user_License_Agreement">End-user License Agreement</A>
<A HREF="#General_Information">General Information</A>
<A HREF="#Known_problems_with_GFA-Basic">Known problems with GFA-Basic</A>
<A HREF="#Patches_for_GFA-Basic">Patches for GFA-Basic</A>
<A HREF="#N.AES_Functions_and_Objects">N.AES Functions and Objects</A>
<A HREF="#GFA-Basic_History">GFA-Basic History</A>
<A HREF="#The_Origins_of_GFA-Basic">The Origins of GFA-Basic</A>
<A HREF="#GFA-Basic_v3_float_format">GFA-Basic v3 float format</A>
<A HREF="#ST-Basic_float_format">ST-Basic float format</A> (<A HREF="#CVS">CVS</A><A HREF="#()">()</A>)
<A HREF="#Debugging_with_GFA-Basic_and_MiNT">Debugging with GFA-Basic and MiNT</A>
<A HREF="#Misc_Images">Misc Images</A>
<A HREF="#Optimizations_not_covered_in_the_Compiler_manual">Optimizations not covered in the Compiler manual</A>
<A HREF="#Command_line_options">Command line options</A>
<A HREF="#Cookie_Jar">Cookie Jar</A>
<A HREF="#Fastload_on_TOS_1.00/1.02">Fastload on TOS 1.00/1.02</A>
<A HREF="#Assembler_Notes">Assembler Notes</A>
<A HREF="#Start-up/Shut-down_modules">Start-up/Shut-down modules</A>
<A HREF="#C_to_GFABASIC">C to GFABASIC</A>
<A HREF="#Compatibility_with_GFA-BASIC_3.5">Compatibility with GFA-BASIC 3.5</A>
<A HREF="#Understanding_GFA's_VDI_scheme">Understanding GFA's VDI scheme</A>
<HR SIZE=3><H2 ID="Command_line_options">Command line options</H2>
The editor can be started with a command line:

Example:

TEST.GFA   start editor and run source
-TEST.GFA  start editor in edit mode
<HR SIZE=3><H2 ID="Optimizations_not_covered_in_the_Compiler_manual">Optimizations not covered in the Compiler manual</H2>
<B>Math with numbers</B>

a%=10+4*1-6/7  !for example, is converted into:

  moveq #13,d0
  move.l d0,adr_of_variable

That's quite an impressive optimization.

Say you are dealing with some structure, and you prefer to write like this for
clearity:
  <A HREF="#LONG">LONG</A>{struct%+0}=22
  <A HREF="#LONG">LONG</A>{struct%+4}=5  !etc...

The +0 in the first line generates no code at all when compiled.

<B>IF/ENDIF versus SELECT/CASE</B>

If you have an IF/ENDIF structure that does 2 or more tests on the same
variable, SELECT/CASE should be used. Why? Because SELECT/CASE holds the
value of the variable in a register for the entire structure, where as
IF/ENDIF fetches the value of the variable at each reference.

<HR>

<B>IF/ENDIF with Boolean tests</B>

<A HREF="#IF">IF</A> test!<A HREF="#=">=</A><A HREF="#TRUE">TRUE</A>  !generates more code
<A HREF="#IF">IF</A> test!       !less code

<A HREF="#IF">IF</A> test!<A HREF="#=">=</A><A HREF="#FALSE">FALSE</A> !generates more code
<A HREF="#IF">IF</A> <A HREF="#NOT">NOT</A> test!   !less code

<HR>

<B>Quick flip flags</B>

How to flip a boolean variable (<A HREF="#FALSE">FALSE</A> or <A HREF="#TRUE">TRUE</A>) in one line of code:
flag!<A HREF="#=">=</A><A HREF="#NOT">NOT</A> flag!


How to flip a word variable used as a flag (0 or 1) in one line of code:
flag&<A HREF="#=">=</A><A HREF="#BCHG">BCHG</A>(flag&,0)

<HR>

<B>Variables versus Constants</B>

This is slower and generates more code:

    pdomain&=281
    domain_mint&=1
    result&<A HREF="#=">=</A><A HREF="#GEMDOS">GEMDOS</A>(pdomain&,W:domain_mint&)

This is faster and more compact when compiled:

    result&<A HREF="#=">=</A><A HREF="#GEMDOS">GEMDOS</A>(281,W:1)

Although the first example is easier to read, fetching the values of the
variables adds overhead.

<HR>

<B>Built in commands versus custom bindings</B>

If at all possible always use the built in commands. Built in commands pass
parameters via registers. User written routines on the other hand pass all
parameters via the stack, which is slower.
<HR SIZE=3><H2 ID="Cookie_Jar">Cookie Jar</H2>
Normally you need to go to supervisor mode to get the cookie jar address. To
avoid that one can use this legal <A HREF="#BIOS">BIOS</A><A HREF="#()">()</A> call. This is the best method for
MiNT and works equally well under all versions of TOS.

jar_adr%<A HREF="#=">=</A><A HREF="#BIOS">BIOS</A>(5,W:SHR&(&H5A0,2),L:TRUE)

The <A HREF="#Cookie_Jar">Cookie Jar</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="Fastload_on_TOS_1.00/1.02">Fastload on TOS 1.00/1.02</H2>
<A NAME="fastload"></A>How to force a <A HREF="#fastload">fastload</A> on TOS 1.00/1.02 (exploit a bug in TOS)
______________________________________________________________________________

The binary must meet 2 requirements:
  1) No relocation data (must be 100% pc relative)
  2) The ABSFLAG in the header must be set to non-zero (word at offset 26)

The OS will load the file and relocate it.
Control will be passed to the binary like normal.

The OS fails to do 2 things (the bug)<A HREF="#:">:</A>
  The BSS and heap memory areas will not be cleared (thus its fastloaded)<A HREF="#.">.</A>
  The binary is not closed, it cannot be deleted or moved from the Desktop.

The binary should close itself before it terminates.
  If not, the system will have 1 less file handle available to other apps.
______________________________________________________________________________

To close the binary you have 2 options:

Method #1 (used in PinHead v1.4)
Call fsfirst() with "<A HREF="#*">*</A><A HREF="#.">.</A>*" in the current dir and open the 1st file you find.
Then simply close the file.
Now fclose(previous handle-1), the binary will then be closed.

Method #2 (used in DC Squish II v2.12)
Check the TOS version:
  If its TOS 1.00:
    If the word at offset $15D2 <A HREF="#=">=</A> $601A, then the next word is the handle.
  If its TOS 1.02:
    If the word at offset $1632 <A HREF="#=">=</A> $601A, then the next word is the handle.
  Call fclose() with the file handle, the binary will then be closed.

TOS 1.04 and up do not have this bug and also supports <A HREF="#fastload">fastload</A> directly.
______________________________________________________________________________

This technique is probably only useful in small \auto folder programs as it is
sort of hard to write a rather large application that has no fixups.

The information regarding this trick was discovered by dis-assembling the
above mentioned programs and studying the code. Tests were made with old
versions of TOS to verify the mysterious offsets mentioned as well.

The Atari Compendium mentions a bug related to the ABSFLAG and some versions
of TOS, but does not state the nature of the problem. Well, now I know.  ;o)

<A HREF="#==">==</A><A HREF="#=">=</A>===========================================================================

Related information:

From the PinHead v1.4 documentation:
  <A HREF="#*">*</A>************
  <A HREF="#*">*</A>           *
  <A HREF="#*">*</A> <A HREF="#NEW">NEW</A> STUFF *
  <A HREF="#*">*</A>           *
  <A HREF="#*">*</A>************

  <A HREF="#-">-</A>------------
   PinHead 1.4
  <A HREF="#-">-</A>------------

  PinHead Now Fastloads Itself!
  <A HREF="#-">-</A>----------------------------

       Version 1.4 of PinHead uses an undocumented feature of TOS 1.0 and
  1.2 to "<A HREF="#fastload">fastload</A>" itself.  This means that the speedup starts one
  program sooner in your AUTO folder, since the PinHead program file does
  not cause memory to be cleared when it runs.

       (NOTE: Normally, the use of this undocumented feature would result
  in the PinHead program file being left "open" by the system.  PinHead
  1.4 uses a special technique to avoid this bug in TOS, and you will have
  no trouble deleting, renaming, or copying the PinHead program file after
  it runs.)

From the DC Squish II manual, page 19, 1st paragraph:
  When the FAST bit is OFF, both the BSS and the HEAP
  memory areas are cleared. Early TOS versions, 1.0 and 1.2
  do not know about the FAST bit an therefore 'always'
  clear both the BSS and HEAP. There is a trick to make
  <A HREF="#GEMDOS">GEMDOS</A> load files 'fast' on TOS 1.0 <A HREF="#&">&</A> 1.2, and SQUISH
  uses this technique to allow fast-equivalent execution
  speed.
______________________________________________________________________________

<A HREF="#GEMDOS">GEMDOS</A> Processes+
<HR SIZE=3><H2 ID="GFA-Basic_History">GFA-Basic History</H2>
From: Holger Herzog <A HREF="#&">&</A>#60;Holger_Herzog@ZW.maus.de&#62;
Organization: MAUS Zweibr&#402;cken +49-6332-16629
Newsgroups: <A HREF="#&">&</A>#60;maus.computer.sprache.gfabasic&#62;
Date: Friday, November 22, 2002 12:17 PM
Subject: Re: gfa history

Hi Lonny!

L&#62;Does someone here know what "gfa" means in the title of "gfa-basic"<A HREF="#?">?</A> I
L&#62;have wondered this since the day I discovered version 2.x back in the
L&#62;days of the Atari 520st.

As far as I know, GFA (originally called "GfA") was a shortcut for
"Gesellschaft f&#252;r Anwendungssoftware mbH"<A HREF="#.">.</A> That means in english
(word by word)<A HREF="#:">:</A> "Company for application software Ltd." So GfA was
the name of the company, and GfA-Basic was the name of the software.

But in fact, this name ("GfA") was in conflict with the name of a
further organization. I can't remember which one it was. But due to
that, the company was renamed into "GFA Systemtechnik GmbH" which
means: "GFA system engineering Ltd." So from then, "GfA" was called
"GFA"<A HREF="#.">.</A> And "GFA" is now <A HREF="#-">-</A> AFAIK - only a symbol for the company that
sounds like the old shortcut, but without officially being a
shurtcut. Now, the basic also is called "<A HREF="#GFA-Basic">GFA-Basic</A>", not "GfA-Basic"
any longer.


Best regards!

Holger

<HR>

Subject: [gfa-dev-atari] GFA <A HREF="#/">/</A> GfA
Date: Monday, January 28, 2008 8:29 AM
From: Holger Herzog <A HREF="#&">&</A>#60;ich@holger-herzog.de&#62;
Reply-To: <A HREF="#GFA-Basic">GFA-Basic</A> Dev Mailing-List <A HREF="#&">&</A>#60;gfa@atari-users.net&#62;
To: <A HREF="#GFA-Basic">GFA-Basic</A> Dev Mailing-List <A HREF="#&">&</A>#60;gfa@atari-users.net&#62;
Conversation: [gfa-dev-atari] GFA <A HREF="#/">/</A> GfA

Hi Lonny!

I'm not sure anymore if I'm right with "GF*A*" <A HREF="#=">=</A> "application
software" instead of "automation"<A HREF="#.">.</A>

Once I've asked the GFA support why "GfA" was renamed as "GFA" and Mr.
Lars von Str&#232;len (Software Support, GFA Systemtechnik) replied:

<A HREF="#-">-</A>----
"GfA" was renamend as "GFA" in 1987. It happened, because the acronym
"GfA" was changed into the proper name "GFA-Systemtechnik"<A HREF="#.">.</A>

D&#402;sseldorf, 1991-06-20
<A HREF="#-">-</A>---

The header shows:

GFA Systemtechnik GmbH
Software-Entwicklung, Software-Vertrieb, Verlag
D&#402;sseldorf, Germany

This means:

GFA Systems Enginieering Ltd
Software Development, Software Sales, Publishing
D&#402;sseldorf, Germany ;<A HREF="#-">-</A>)

CEOs are Mr. Thomas Nied and Dr.Ing. Heinrich Meckner

Later, GFA Systemtechnik GmbH moved to M&#252;nchengladbach, another
town in western Germany.

But I found exactly ONE curious invoice in my documents. The header
here is:

GFA Systemtechnik GmbH
Industrie-Automation
Proze&#7885;leit-Systeme
Qualit&#232;tssicherungs-Systeme

And THIS means:

GFA Systemtechnik GmbH
Industrial Automation
Process Control Systems
Quality Assurance Systems

Date: 1992-02-17

The address still is D&#402;sseldorf, not yet M&#252;nchengladbach. But the
local court is in Kiel (nothern Germany)<A HREF="#.">.</A> I really don't understand
what this means. Because the CEO is still Mr. Thomas Nied.

I found nothing about Thomas Nied in google. Dr. Meckner seems having
worked for Krupp (a big steel company), but for both I found no
reference where I could get in contact.

So it *is* possible, that GfA meant "Gesellschaft f&#402;r Automatisierung"
(=automation), and not, as I heavyliy do remeber, "Gesellschaft for
Anwendungssoftware" (=application software)<A HREF="#.">.</A>



Holger


_______________________________________________
gfa mailing list
gfa@atari-users.net
<A TARGET="_BLANK" HREF="http://atariforums.com/mailman/listinfo/gfa">http://atariforums.com/mailman/listinfo/gfa</A>
<HR SIZE=3><H2 ID="The_Origins_of_GFA-Basic">The Origins of GFA-Basic</H2>
THE ORIGINS OF GFA BASIC

It began with an Atari 400, a small computer similar to the Commadore 64.
There existed a BASIC for that computer.  This BASIC was neither fast nor
comfortable to use, but, with only 16K of RAM, large programs could not be
written anyway.  After upgrading the computer to 48K of memory and 88K of disk
space, I wrote some programs in assembly code.  Eventually I ended up with a
number of help routines, and a BASIC language with which I could marginally use
with these routines.  After trying FORTH, I decided to take a closer look at
BASIC, and slightly modified it.  These modifications eventually became so
numerous that I decided to completely replace many of the routines.  To remain
compatible, some of the routines were left untouched.  There were a lot of
commands I did not like, such as computed GOTOs, and line numbers were a
nuisance.

This new BASIC was published in a computer magazine.  Shortly thereafter I
received an offer from GFA Systemtechnik GmbH to write a workable BASIC for the
new computer, the Atari ST.

The Atari ST incorporates a fresh modern processor.  Its operating system,
although certainly not the newest or fastest (nor is it very compact, having
been written in C language) is very powerful.  And, even though it lacks
multitasking, one can write programs in high level languages that offer
exciting performance.

Shipped with a BASIC language that did not even measure up to the one included
with the Atari 400, the ST was destined to become a language developers dream.
It was possible to now develop a BASIC that did not have to conform to the
standard of any other interpreter.

This new BASIC should have the simplicity of BASIC combined with the
possibility of writing well structured code.  The first step was to eliminate
the line numbers.  This made the task difficult from the outset because a
solution had to be found to avoid the usual confusion of GOTOs and GOSUBs.  It
was important to be able to pass parameters to procedures and to declare local
variables, thus enabling the programmer to use recursive programming
techniques.  The BASIC should also make sure that all loops are properly closed
before the program starts execution.

The <A HREF="#GOTO">GOTO</A> statement was one of the last statements added to this BASIC.  After
much thought, I even allowed the <A HREF="#GOTO">GOTO</A> command to be used between different
procedures.

In an Interpreter it is possible to use segmented PEEKs and POKEs to simulate
one of the Intel-processors.  In a compiled program, this would greatly affect
execution time.

The unsuitable 16 bit integers would not be used either, as this makes it
harder to address all of the memory.  Besides, the processor already uses 32
bits internally, thus allowing it to process larger numbers without speed loss.

The editor of this BASIC had to be screen oriented and not use the windows of
GEM.  It would be virtually impossible to create non GEM programs from within
the GEM interface.  Other reasons exist for not having the editor run under
GEM.

In the case of a program error, it is often possible to save program changes
that were made.  Something that cannot always be done from within GEM because
the windows lock up.  So it happened that a relatively fast editor, one that
could be used without a mouse, was created.

I wanted to write the BASIC completely in machine language so that it would be
fast and take up only a small portion of memory.  Other languages like C use
only a few machine instructions outside of the library, and they always pass
parameters through the stack.  The MC68000 has a very powerful instruction set
that can be better utilized with an Assembler.

Taking all this into consideration, Version 1.0 of <B>GFA BASIC</B> came into
existence less than 6 months later.

While I was writing the interpreter, I carefully made sure that the finished
programs could be easily compiled.  That is why the MERGE command is missing.
This command may be useful in an interpreter, but is of little value in a
compiler.

While I was working on the compiler, I was confronted with requests to expand
the command set.  Some of those requests I was able to incorporate in Version
2.0 of the interpreter.  Most new commands, like <A HREF="#VOID">VOID</A>, <A HREF="#BASEPAGE">BASEPAGE</A>, and <A HREF="#OPTION">OPTION</A>,
were inserted to give the compiler more optimization opportunities, and to
provide the programmer with more control over the compiling process.

Even an extensive computer language cannot fulfill all the wishes of everyone
who uses it.  This book will, therefore, show you how to create necessary
routines using <B>GFA BASIC</B><A HREF="#.">.</A>

This book does not present you with complete applications; it gives routines
that can be incorporated into your own programs.

<B>GFA BASIC</B> is only a BASIC and not a Modula 2, therefore you cannot
create modules in quite the same way.  Modula 2 takes a lot more coding and a
multitude of small modules to write an application.  Modula 2 can only be used
as a compiler.  BASIC includes numerous commands that would have to be created
within libraries in Modula 2.

Part of this book discusses many different operating system routines which
include examples wherever I felt they were needed.  Naturally, there are
routines that can be run directly without going to the low-level operating
system routines, but rather with built in commands.

An important part of this book is the last chapter, where a complete GEM
program is shown.  It demonstrates how to use all parts of a window.  This is
not easy to do in GEM, but it makes it convenient for the user of the program.
For the programmer, GEM always means extra work.  There are many programs where
most of the code is written just to manipulate the window.

I hope that you find the routines and tips in this book useful, and I wish you
much success.

<HR>

Taken from the <A HREF="#'">'</A><A HREF="#Introduction">Introduction</A>' section of the book "The GFA BASIC Book"
Written by Frank Ostrowski
Text Translation by Wilford Niepraschk
Published in the U.S.A. by <A HREF="#MichTron,_Inc.">MichTron, Inc.</A>
(C)1987 GFA Systemtechnik
1st English Edition: September 1987
ISBN 0-923213-85-6
<HR SIZE=3><H2 ID="Misc_Images">Misc Images</H2>






















<HR SIZE=3><H2 ID="General_Information">General Information</H2>
Rather than duplicate alot of work that has already been done this document
will not explain each and every system call available.

I highly recommend you have some additional documentation.

GFA specific:
  <A HREF="#GFA-Basic">GFA-Basic</A> Book
  Concepts in Programming
  Programming with <A HREF="#GFA-Basic">GFA-Basic</A> 3.0
  <A HREF="#GFA-Basic">GFA-Basic</A> Training Reboot Camp
  <A HREF="#GFA-Basic">GFA-Basic</A> Programmer's Reference Guide  Volume 1
  The <A HREF="#GFA-Basic">GFA-Basic</A> <A HREF="#&">&</A> Assembler User Book
  <A HREF="#GFA-Basic">GFA-Basic</A> Toolkit  Volume 1

Atari in general:
  The Atari Compendium (also available on CD-ROM)
  Modern Atari System Software  A programmer's Guide
  The TRB Reference Series  <A HREF="#AES">AES</A> Quick Reference
  The TRB Reference Series  <A HREF="#VDI">VDI</A> Quick Reference
  Atari ST GEM Programmer's Reference (Abacus)
  Atari ST Internals (Abacus)
  Atari ST Machine Language (Abacus)
  Atari ST Tips <A HREF="#&">&</A> Tricks (Abacus)
  Atari ST 3D Graphics (Abacus)
  ST Disk Drives: Inside and Out (Abacus)
  COMPUTE!'s ST Programmer's Guide
  COMPUTE!'s Technical Reference Guide  Atari ST: <A HREF="#AES">AES</A>
  COMPUTE!'s Technical Reference Guide  Atari ST: TOS
  COMPUTE!'s Technical Reference Guide  Atari ST: <A HREF="#VDI">VDI</A>

If you see a typo, find a program listing that does not work, or anything else
wrong then please contact me. If you find this document handy and find yourself
releasing a program, then please give me a mention in your doc file. That's all
I ask.  <A HREF="#;">;</A><A HREF="#^">^</A>)

<HR SIZE=3><H2 ID="Patches_for_GFA-Basic">Patches for GFA-Basic</H2>
I've seen several patches for <A HREF="#GFA-Basic">GFA-Basic</A>, but the best one by far is the one
listed below. I personally use it on a daily basis.

<B><A HREF="#GFA-Basic">GFA-Basic</A> Interpreter/Compiler-Patcher Version 1.05/1.07 (1994)</B>
  Compiler <A HREF="#&">&</A> Library-Patches by Christoph Conrad,
    Adalbertsteinweg 113, D-52070 Aachen, Germany - eMail:
    Christoph_Conrad@AC3.maus.de
  Interpreter-Patches and GEM interface by - Gregor Duchalski,
    Baueracker 15a, D-44627 Herne, Germany - eMail:
    Gregor_Duchalski@<A HREF="#DO">DO</A>.maus.ruhr.de

This patch completely removes all the LINEA calls used in the GFA libs. It also
makes the compiled programs function on multi-tasking operating systems. It
should also be noted that this patch removes the auto mouse hiding/showing that
takes place when graphics commands are used. Once patched you must hide/show
the mouse yourself when using <A HREF="#VDI">VDI</A> graphics commands.

<A HREF="#GFA_PTCH.TXT">GFA_PTCH.TXT</A>  <A HREF="#LIBPATCH.TXT">LIBPATCH.TXT</A>

<HR>

<B>LicomLIB 5.9.H</B>
  Copyright (c)1998 Richard Gordon Faika
  All rights reserved.
Hompage:
  www.atari-computer.de/rgfaika/
Email:
  rgfaika@atari-computer.de
  richard-gordon.faika@b.maus.de

This patch replaces many routines in the GFA library file. From what I can tell
from the German docs it adds automatic FPU support among many other things. An
impressive update to the GFA library. The patch seems to require an original
German v3.6TT compiler/linker package.

<HR>

<B>Patchable areas in <A HREF="#GFA-Basic">GFA-Basic</A></B>

Within GFABASIC.PRG and GFABASRO.PRG there is a small area where you can
predetermine the appeareance of the program.

Always ensure that you have made a backup of your master disk before attempting
such patches.

<B>Auto Clear Screen</B>

    <A HREF="#OPEN">OPEN</A> "U",#1,"GFABASIC.PRG" !or "GFABASRO.PRG"
    <A HREF="#SEEK">SEEK</A> #1,31
    <A HREF="#PRINT">PRINT</A> #1,"E"<A HREF="#;">;</A> !or "H";
    <A HREF="#CLOSE">CLOSE</A> #1

With "E" the monitor screen will be erased before the program starts and with
"H" the monitor is left as it is.

<B>Autorun Patch </B>

    <A HREF="#OPEN">OPEN</A> "U",#1,"GFABASRO.PRG"
    <A HREF="#SEEK">SEEK</A> #1,32
    <A HREF="#PRINT">PRINT</A> #1,"TESTPROG.GFA"<A HREF="#;">;</A><A HREF="#CHR$">CHR$</A>(0);
    <A HREF="#CLOSE">CLOSE</A> #1

When starting GFABASRO.PRG the default TESTPROG.GFA will start if you do not
alter this by using the Install Application option of the GEM Destop.

The program's name and path may not exceed 63 bytes. The zero byte at the end
of the string is very important. If you only give the zero byte, the original
status will be reimplemented.

<B>Variable Default Type</B>

    <A HREF="#OPEN">OPEN</A> "U",#1,"GFABASIC.PRG"
    <A HREF="#SEEK">SEEK</A> #1,32
    <A HREF="#FOR">FOR</A> i%=0 TO 24
      <A HREF="#READ">READ</A> a%
      <A HREF="#OUT">OUT</A> #1,a%
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#CLOSE">CLOSE</A> #1
    <A HREF="#'">'</A>    A B C D E F G H I J K L M N O P Q R S T U V X Y Z
    <A HREF="#DATA">DATA</A> 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

It is possible to change the <A HREF="#DATA">DATA</A> row. Doing this will alter the preset
default-type for the variable, the name of which starts with the above letter.

Only the following values are allowed:
    0 <A HREF="#=">=</A> <A HREF="#DEFFLT">DEFFLT</A>
    1 <A HREF="#=">=</A> <A HREF="#DEFSTR">DEFSTR</A>
    2 <A HREF="#=">=</A> <A HREF="#DEFINT">DEFINT</A>
    3 <A HREF="#=">=</A> <A HREF="#DEFBIT">DEFBIT</A>
    8 <A HREF="#=">=</A> <A HREF="#DEFWRD">DEFWRD</A>
    9 <A HREF="#=">=</A> <A HREF="#DEFBYT">DEFBYT</A>

<B>Editor Colors</B>

    <A HREF="#OPEN">OPEN</A> "U",#1,"GFABASIC.PRG"
    <A HREF="#SEEK">SEEK</A> #1,58
    <A HREF="#FOR">FOR</A> i%=0 TO 3
      <A HREF="#READ">READ</A> a%
      <A HREF="#PRINT">PRINT</A> #1,<A HREF="#MKI$">MKI$</A>(a%)<A HREF="#;">;</A>
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#CLOSE">CLOSE</A> #1
    <A HREF="#'">'</A> Normal colors for the Editor
    <A HREF="#DATA">DATA</A> &0777,&0700,&0070,&0000
    <A HREF="#'">'</A> Colors inverted for the Editor
    <A HREF="#'">'</A> <A HREF="#DATA">DATA</A> &0000,&0700,&0070,&0777
<HR SIZE=3><H2 ID="Known_problems_with_GFA-Basic">Known problems with GFA-Basic</H2>
Features not implemented due to it's age and lack of support:

FPU 68881/882 (sort of)
CPU 68010/020/030/040/060 support

Things just act plain weird:

<A HREF="#~">~</A><A HREF="#INP">INP</A>(2) will fail under MiNT if the application does not initialize the <A HREF="#AES">AES</A><A HREF="#.">.</A>
The GFA linker in some cases is smart enough to link only what's needed.
If your application makes no <A HREF="#AES">AES</A> calls it will not initialize the AES.
Further investigation shows that any command that uses Bconin() fails
to wait for input.

Commands and functions which don't quite work right (A to Z)<A HREF="#:">:</A>

<A HREF="#$X">$X</A>
<A HREF="#$F%">$F%</A>
<A HREF="#ACOS">ACOS</A><A HREF="#()">()</A>, <A HREF="#ASIN">ASIN</A>()
<A HREF="#AFTER_GOSUB">AFTER GOSUB</A>, <A HREF="#EVERY_GOSUB">EVERY GOSUB</A>
<A HREF="#APOLY">APOLY</A>
<A HREF="#APPL_TPLAY">APPL_TPLAY</A><A HREF="#()">()</A>
<A HREF="#BITBLT">BITBLT</A>
<A HREF="#CALL">CALL</A>
<A HREF="#CASE">CASE</A>
<A HREF="#CLS">CLS</A>
<A HREF="#DEFFN">DEFFN</A>
<A HREF="#DFREE">DFREE</A><A HREF="#()">()</A>
<A HREF="#DIM">DIM</A>, <A HREF="#ERASE">ERASE</A>
<A HREF="#EXIST">EXIST</A><A HREF="#()">()</A>
<A HREF="#FILESELECT">FILESELECT</A>
<A HREF="#FRE">FRE</A><A HREF="#()">()</A>
<A HREF="#FUNCTION">FUNCTION</A>
<A HREF="#GET">GET</A>, <A HREF="#PUT">PUT</A>, <A HREF="#SGET">SGET</A>, <A HREF="#SPUT">SPUT</A>
<A HREF="#GET_#">GET #</A>, <A HREF="#PUT_#">PUT #</A>
<A HREF="#GETSIZE">GETSIZE</A><A HREF="#()">()</A>
<A HREF="#GOTO">GOTO</A>
<A HREF="#GRAF_MKSTATE">GRAF_MKSTATE</A><A HREF="#()">()</A>
<A HREF="#INLINE">INLINE</A>
<A HREF="#INSTR">INSTR</A><A HREF="#()">()</A>, <A HREF="#RINSTR">RINSTR</A>()
<A HREF="#LPENx">LPENx</A>, <A HREF="#PADx">PADx</A>, <A HREF="#STICK">STICK</A><A HREF="#()">()</A>, <A HREF="#STRIG">STRIG</A>()
<A HREF="#LPRINT">LPRINT</A>
<A HREF="#MAT_DET">MAT DET</A>, <A HREF="#MAT_INPUT">MAT INPUT</A>, <A HREF="#MAT_QDET">MAT QDET</A>, <A HREF="#MAT_RANG">MAT RANG</A>
<A HREF="#MAT_PRINT">MAT PRINT</A>
<A HREF="#MAT_READ">MAT READ</A>
<A HREF="#MENU_REGISTER">MENU_REGISTER</A><A HREF="#()">()</A>
<A HREF="#MSHRINK">MSHRINK</A><A HREF="#()">()</A>
<A HREF="#OBJC_CHANGE">OBJC_CHANGE</A><A HREF="#()">()</A>
<A HREF="#ON_BREAK_GOSUB">ON BREAK GOSUB</A>
<A HREF="#ON_ERROR_GOSUB">ON ERROR GOSUB</A>
<A HREF="#ON_GOSUB">ON GOSUB</A>
<A HREF="#ON_MENU_BUTTON">ON MENU BUTTON</A>
<A HREF="#ON_MENU_GOSUB">ON MENU GOSUB</A>
<A HREF="#ON_MENU_IBOX">ON MENU IBOX</A>
<A HREF="#ON_MENU_KEY">ON MENU KEY</A>
<A HREF="#ON_MENU_MESSAGE">ON MENU MESSAGE</A>
<A HREF="#ON_MENU_OBOX">ON MENU OBOX</A>
<A HREF="#OPTION_BASE">OPTION BASE</A>
<A HREF="#POINT">POINT</A><A HREF="#()">()</A>
<A HREF="#POLYFILL">POLYFILL</A>, <A HREF="#POLYLINE">POLYLINE</A>, <A HREF="#POLYMARK">POLYMARK</A>
<A HREF="#QSORT">QSORT</A>, <A HREF="#SSORT">SSORT</A>
<A HREF="#RESTORE">RESTORE</A>, <A HREF="#_DATA">_DATA</A>
<A HREF="#RESUME_label">RESUME label</A>
<A HREF="#SETMOUSE">SETMOUSE</A>
<A HREF="#SOUND">SOUND</A>, <A HREF="#WAVE">WAVE</A>
<A HREF="#SPACE$">SPACE$</A><A HREF="#()">()</A>, <A HREF="#STRING$">STRING$</A>()
<A HREF="#SPRITE">SPRITE</A>
<A HREF="#STE?">STE?</A>, <A HREF="#TT?">TT?</A>
<A HREF="#STR$">STR$</A><A HREF="#()">()</A>
<A HREF="#TEXT">TEXT</A>
<A HREF="#VDIBASE">VDIBASE</A>
<A HREF="#VSETCOLOR">VSETCOLOR</A>
<A HREF="#V_OPNWK">V_OPNWK</A><A HREF="#()">()</A>, <A HREF="#V_OPNVWK">V_OPNVWK</A>()

Compiler issues:
<A HREF="#EXIT_IF">EXIT IF</A>
<A HREF="#IF">IF</A><A HREF="#-">-</A><A HREF="#THEN">THEN</A>
<A HREF="#INSERT">INSERT</A>
<A HREF="#FOR">FOR</A><A HREF="#-">-</A><A HREF="#NEXT">NEXT</A>
<HR SIZE=3><H2 ID="Start-up/Shut-down_modules">Start-up/Shut-down modules</H2>
This section will try and explain what happens when GFABASIC starts and
terminates. The code you can't really control.

The basic layout of a compiled GFA program is like so:

INIT module
your code
EXIT module

What does the INIT module do exactly:

  Calculates how much BSS space it needs and clears it.
  Moves the stack pointer to the BSS.
  <A HREF="#MSHRINK">MSHRINK</A><A HREF="#()">()</A> is called.  Skipped if started as an ACC, OS auto shrinks an ACC)
  <A HREF="#Line-A">Line-A</A> Init is called.  This is harmless, used by the Line-A gfx commands.
  <A HREF="#APPL_INIT">APPL_INIT</A><A HREF="#()">()</A> is called.  The appl_id is saved.
  <A HREF="#V_OPNVWK">V_OPNVWK</A><A HREF="#()">()</A> is called.  The vdi_handle is saved. No clipping rectangle is set.
  <A HREF="#WORK_OUT">WORK_OUT</A><A HREF="#()">()</A> array is created.
  Default <A HREF="#VDI">VDI</A> workstation values are setup.
  If any GFA window commands are linked, <A HREF="#WINDTAB">WINDTAB</A><A HREF="#()">()</A> structure is initialized.
  <A HREF="#MALLOC">MALLOC</A>($Mxxx) is called. If $Mxxx=0 all ram is allocated for stings/arrays.
  <A HREF="#CLEAR">CLEAR</A> is called.  All Variables are cleared.
  <A HREF="#RESTORE">RESTORE</A> is called.  First <A HREF="#DATA">DATA</A> statement is located for <A HREF="#READ">READ</A>.
  User code starts here...

What does the EXIT module do exactly:

  User code ends here with <A HREF="#EDIT">EDIT</A>, <A HREF="#QUIT">QUIT</A>, or <A HREF="#SYSTEM">SYSTEM</A><A HREF="#.">.</A>..
  If any GFA window commands are linked, all open GFA windowd are closed.
  <A HREF="#V_CLSVWK">V_CLSVWK</A><A HREF="#()">()</A> is called.
  <A HREF="#APPL_EXIT">APPL_EXIT</A><A HREF="#()">()</A> is called.
  <A HREF="#CLOSE">CLOSE</A> (no parameter) is called.  All open files are closed.
  pterm() is called.  User error code is passed out via SYSTEM/QUIT.

  Note:
  GFA deos not call <A HREF="#MFREE">MFREE</A><A HREF="#()">()</A> as it assumes pterm() will auto free the ram.
<HR SIZE=3><H2 ID="Number_Table">Number Table</H2>
<B>Dec Hex Bin         Dec Hex Bin         Dec Hex Bin         Dec Hex Bin</B>
  0 $00 %00000000    64 $40 %01000000   128 $80 %10000000   192 $C0 %11000000
  1 $01 %00000001    65 $41 %01000001   129 $81 %10000001   193 $C1 %11000001
  2 $02 %00000010    66 $42 %01000010   130 $82 %10000010   194 $C2 %11000010
  3 $03 %00000011    67 $43 %01000011   131 $83 %10000011   195 $C3 %11000011
  4 $04 %00000100    68 $44 %01000100   132 $84 %10000100   196 $C4 %11000100
  5 $05 %00000101    69 $45 %01000101   133 $85 %10000101   197 $C5 %11000101
  6 $06 %00000110    70 $46 %01000110   134 $86 %10000110   198 $C6 %11000110
  7 $07 %00000111    71 $47 %01000111   135 $87 %10000111   199 $C7 %11000111
  8 $08 %00001000    72 $48 %01001000   136 $88 %10001000   200 $C8 %11001000
  9 $09 %00001001    73 $49 %01001001   137 $89 %10001001   201 $C9 %11001001
 10 $0A %00001010    74 $4A %01001010   138 $8A %10001010   202 $CA %11001010
 11 $0B %00001011    75 $4B %01001011   139 $8B %10001011   203 $CB %11001011
 12 $0C %00001100    76 $4C %01001100   140 $8C %10001100   204 $CC %11001100
 13 $0D %00001101    77 $4D %01001101   141 $8D %10001101   205 $CD %11001101
 14 $0E %00001110    78 $4E %01001110   142 $8E %10001110   206 $CE %11001110
 15 $0F %00001111    79 $4F %01001111   143 $8F %10001111   207 $CF %11001111
 16 $10 %00010000    80 $50 %01010000   144 $90 %10010000   208 $D0 %11010000
 17 $11 %00010001    81 $51 %01010001   145 $91 %10010001   209 $D1 %11010001
 18 $12 %00010010    82 $52 %01010010   146 $92 %10010010   210 $D2 %11010010
 19 $13 %00010011    83 $53 %01010011   147 $93 %10010011   211 $D3 %11010011
 20 $14 %00010100    84 $54 %01010100   148 $94 %10010100   212 $D4 %11010100
 21 $15 %00010101    85 $55 %01010101   149 $95 %10010101   213 $D5 %11010101
 22 $16 %00010110    86 $56 %01010110   150 $96 %10010110   214 $D6 %11010110
 23 $17 %00010111    87 $57 %01010111   151 $97 %10010111   215 $D7 %11010111
 24 $18 %00011000    88 $58 %01011000   152 $98 %10011000   216 $D8 %11011000
 25 $19 %00011001    89 $59 %01011001   153 $99 %10011001   217 $D9 %11011001
 26 $1A %00011010    90 $5A %01011010   154 $9A %10011010   218 $DA %11011010
 27 $1B %00011011    91 $5B %01011011   155 $9B %10011011   219 $DB %11011011
 28 $1C %00011100    92 $5C %01011100   156 $9C %10011100   220 $DC %11011100
 29 $1D %00011101    93 $5D %01011101   157 $9D %10011101   221 $DD %11011101
 30 $1E %00011110    94 $5E %01011110   158 $9E %10011110   222 $DE %11011110
 31 $1F %00011111    95 $5F %01011111   159 $9F %10011111   223 $DF %11011111
 32 $20 %00100000    96 $60 %01100000   160 $A0 %10100000   224 $E0 %11100000
 33 $21 %00100001    97 $61 %01100001   161 $A1 %10100001   225 $E1 %11100001
 34 $22 %00100010    98 $62 %01100010   162 $A2 %10100010   226 $E2 %11100010
 35 $23 %00100011    99 $63 %01100011   163 $A3 %10100011   227 $E3 %11100011
 36 $24 %00100100   100 $64 %01100100   164 $A4 %10100100   228 $E4 %11100100
 37 $25 %00100101   101 $65 %01100101   165 $A5 %10100101   229 $E5 %11100101
 38 $26 %00100110   102 $66 %01100110   166 $A6 %10100110   230 $E6 %11100110
 39 $27 %00100111   103 $67 %01100111   167 $A7 %10100111   231 $E7 %11100111
 40 $28 %00101000   104 $68 %01101000   168 $A8 %10101000   232 $E8 %11101000
 41 $29 %00101001   105 $69 %01101001   169 $A9 %10101001   233 $E9 %11101001
 42 $2A %00101010   106 $6A %01101010   170 $AA %10101010   234 $EA %11101010
 43 $2B %00101011   107 $6B %01101011   171 $AB %10101011   235 $EB %11101011
 44 $2C %00101100   108 $6C %01101100   172 $AC %10101100   236 $EC %11101100
 45 $2D %00101101   109 $6D %01101101   173 $AD %10101101   237 $ED %11101101
 46 $2E %00101110   110 $6E %01101110   174 $AE %10101110   238 $EE %11101110
 47 $2F %00101111   111 $6F %01101111   175 $AF %10101111   239 $EF %11101111
 48 $30 %00110000   112 $70 %01110000   176 $B0 %10110000   240 $F0 %11110000
 49 $31 %00110001   113 $71 %01110001   177 $B1 %10110001   241 $F1 %11110001
 50 $32 %00110010   114 $72 %01110010   178 $B2 %10110010   242 $F2 %11110010
 51 $33 %00110011   115 $73 %01110011   179 $B3 %10110011   243 $F3 %11110011
 52 $34 %00110100   116 $74 %01110100   180 $B4 %10110100   244 $F4 %11110100
 53 $35 %00110101   117 $75 %01110101   181 $B5 %10110101   245 $F5 %11110101
 54 $36 %00110110   118 $76 %01110110   182 $B6 %10110110   246 $F6 %11110110
 55 $37 %00110111   119 $77 %01110111   183 $B7 %10110111   247 $F7 %11110111
 56 $38 %00111000   120 $78 %01111000   184 $B8 %10111000   248 $F8 %11111000
 57 $39 %00111001   121 $79 %01111001   185 $B9 %10111001   249 $F9 %11111001
 58 $3A %00111010   122 $7A %01111010   186 $BA %10111010   250 $FA %11111010
 59 $3B %00111011   123 $7B %01111011   187 $BB %10111011   251 $FB %11111011
 60 $3C %00111100   124 $7C %01111100   188 $BC %10111100   252 $FC %11111100
 61 $3D %00111101   125 $7D %01111101   189 $BD %10111101   253 $FD %11111101
 62 $3E %00111110   126 $7E %01111110   190 $BE %10111110   254 $FE %11111110
 63 $3F %00111111   127 $7F %01111111   191 $BF %10111111   255 $FF %11111111
<HR SIZE=3><H2 ID="Shift_Table">Shift Table</H2>
logical shift left (lsl) (asl)  <A HREF="#SHL">SHL</A><A HREF="#()">()</A>
1       <A HREF="#*">*</A> 2
2       <A HREF="#*">*</A> 4
3       <A HREF="#*">*</A> 8
4       <A HREF="#*">*</A> 16
5       <A HREF="#*">*</A> 32
6       <A HREF="#*">*</A> 64
7       <A HREF="#*">*</A> 128
8       <A HREF="#*">*</A> 256

logical shift right (lsr) (asr) <A HREF="#SHR">SHR</A><A HREF="#()">()</A>
1       <A HREF="#/">/</A> 2
2       <A HREF="#/">/</A> 4
3       <A HREF="#/">/</A> 8
4       <A HREF="#/">/</A> 16
5       <A HREF="#/">/</A> 32
6       <A HREF="#/">/</A> 64
7       <A HREF="#/">/</A> 128
8       <A HREF="#/">/</A> 256
<HR SIZE=3><H2 ID="N.AES_Functions_and_Objects">N.AES Functions and Objects</H2>
<A NAME="N.AES"></A><A HREF="#GFA-Basic">GFA-Basic</A> bindings for <A HREF="#N.AES">N.AES</A> v2.0

<A HREF="#appl_control">appl_control</A><A HREF="#()">()</A>

<A HREF="#appl_yield">appl_yield</A>

<A HREF="#form_popup">form_popup</A><A HREF="#()">()</A>

<A HREF="#graf_multirubber">graf_multirubber</A><A HREF="#()">()</A>

<A HREF="#objc_xfind">objc_xfind</A><A HREF="#()">()</A>

<A HREF="#shel_help">shel_help</A><A HREF="#()">()</A>

<A HREF="#shel_rdef">shel_rdef</A><A HREF="#()">()</A>

<A HREF="#shel_wdef">shel_wdef</A><A HREF="#()">()</A>

<A HREF="#wind_draw">wind_draw</A><A HREF="#()">()</A>

<A HREF="#wind_sget">wind_sget</A><A HREF="#()">()</A>

<A HREF="#-">-</A>-----------------------------------------------------------------------------

WHITEBAK <A HREF="#N.AES">N.AES</A>

 purpose: Switch on the MagiC special buttons.

 C-prototype: #define WHITEBAK 0x0040

 Binding: Tree[obnr].If_state <A HREF="#&#124;">&#124;</A><A HREF="#=">=</A> WHITEBAK;                       [bit 6 on]

Parameter description:


If_type <A HREF="#=">=</A> G_BUTTON

 G_BUTTON with underscore:
 (if_state <A HREF="#&#62;">&#62;</A><A HREF="#&">&</A>#62; 8) & 0x80 <A HREF="#=">=</A> 0.                                     [bit 15 off]
 (if_state <A HREF="#&#62;">&#62;</A><A HREF="#&">&</A>#62; 8) & 0x7f decides the position of the underscore.  [bits 8-14]

 As Checkbox with underscore:
 If_flags <A HREF="#&">&</A> RADIOBUTTON <A HREF="#=">=</A> 0.                                     [bit 4 off]
 (if_state <A HREF="#&#62;">&#62;</A><A HREF="#&">&</A>#62; 8) & 0x80 <A HREF="#=">=</A> 0x80.                                  [bit 15 on]
 (if_state <A HREF="#&#62;">&#62;</A><A HREF="#&">&</A>#62; 8) & 0x7f decides the position of the underscore.  [bits 8-14]
 If_flags <A HREF="#&">&</A> FL3DMASK decides the colour of the underscore.       [bits 9-10]

 As Radiobutton with underscore:
 If_flags <A HREF="#&">&</A> RADIOBUTTON <A HREF="#=">=</A> RADIOBUTTON.                           [bit 4 on]
 (if_state <A HREF="#&#62;">&#62;</A><A HREF="#&">&</A>#62; 8) & 0x80 <A HREF="#=">=</A> 0x80.                                  [bit 15 on]
 (if_state <A HREF="#&#62;">&#62;</A><A HREF="#&">&</A>#62; 8) & 0x7f decides the position of the underscore.  [bits 8-14]
 If_flags <A HREF="#&">&</A> FL3DMASK decides the colour of the underscore.       [bits 9-10]

 As Checkbox without underscore:
 (if_state <A HREF="#&#62;">&#62;</A><A HREF="#&">&</A>#62; 8) <A HREF="#=">=</A> 0xff.                                         [bits 8-15 on]
 If_flags <A HREF="#&">&</A> RADIOBUTTON <A HREF="#=">=</A> 0.                                     [bit 4 off]

 As Radiobutton without underscore:
 (if_state <A HREF="#&#62;">&#62;</A><A HREF="#&">&</A>#62; 8) <A HREF="#=">=</A> 0xff.                                         [bits 8-15 on]
 If_flags <A HREF="#&">&</A> RADIOBUTTON <A HREF="#=">=</A> RADIOBUTTON.                           [bit 4 on]

 As Frame:
 (if_state <A HREF="#&#62;">&#62;</A><A HREF="#&">&</A>#62; 8) <A HREF="#=">=</A> 0xfe.                                         [bit 9-15 on]
 If_state <A HREF="#&">&</A> SHADOWED control font size                           [bit 5 on]
 If_flags <A HREF="#&">&</A> FL3DMASK decides the 3D-behaviour of frame and font. [bits 9-10]


If_type <A HREF="#=">=</A> G_STRING

 G_STRING with underscore:
 (if_state <A HREF="#&#62;">&#62;</A><A HREF="#&">&</A>#62; 8) & 0x80 <A HREF="#=">=</A> 0.                                     [bit 15 off]
 (if_state <A HREF="#&#62;">&#62;</A><A HREF="#&">&</A>#62; 8) & 0x7f decides the position of the underscore.  [bits 8-14]

 G_STRING, completely underlined based on chars:
 (if_state <A HREF="#&#62;">&#62;</A><A HREF="#&">&</A>#62; 8) <A HREF="#=">=</A> 0xfe.                                         [bits 9-15]
 If_flags <A HREF="#&">&</A> FL3DMASK decides the 3D-behaviour of line and font.  [bits 9-10]

 G_STRING, completely underlined based on object width:
 (if_state <A HREF="#&#62;">&#62;</A><A HREF="#&">&</A>#62; 8) <A HREF="#=">=</A> 0xff.                                         [bits 8-15 on]
 If_flags <A HREF="#&">&</A> FL3DMASK decides the 3D-behaviour of line and font.  [bits 9-10]


If_type <A HREF="#=">=</A> G_TITLE

 G_TITLE with underscore:
 (if_state <A HREF="#&#62;">&#62;</A><A HREF="#&">&</A>#62; 8) & 0x80 <A HREF="#=">=</A> 0.                                     [bit 15 off]
 (if_state <A HREF="#&#62;">&#62;</A><A HREF="#&">&</A>#62; 8) & 0x7f decides the position of the underline.   [bits 8-14]


 3D-behaviour:
 FL3DIND Bit switches text 3D attribute.
 FL3DBAK Bit switches line/frame 3D attribute.

 Underline colour:
 None       <A HREF="#=">=</A> black.
 Background <A HREF="#=">=</A> black.
 Indicator  <A HREF="#=">=</A> green.
 Activator  <A HREF="#=">=</A> red.

With all underscore positions:
If the text is shorter, there will be no underscore drawn.

See too: <A HREF="#appl_getinfo">appl_getinfo</A><A HREF="#()">()</A>, form_keybd()
<HR SIZE=3><H2 ID="Debugging_with_GFA-Basic_and_MiNT">Debugging with GFA-Basic and MiNT</H2>
<B><A HREF="#Debugging_with_GFA-Basic_and_MiNT">Debugging with GFA-Basic and MiNT</A></B>
by <A HREF="#Lonny_Pursell">Lonny Pursell</A>

Revision 0.10b
May 4, 2006


<B><A HREF="#Introduction">Introduction</A></B>
This document describes a method for debugging when all else fails and all you
have to go on is the crash log MiNT dumps in the console.  Sometimes you can
simply add <A HREF="#PRINT">PRINT</A> statements at various points in the program in order to narrow
your search.  However sometimes this becomes rather tedious, especially in very
large programs.  In some extreme cases I've actually seen programs suddenly stop
crashing simply by adding <A HREF="#PRINT">PRINT</A> statements.  Needless to say that is a very
frustrating situation if that happens.  The method described here will help you
locate the exact <A HREF="#PROCEDURE">PROCEDURE</A> or <A HREF="#FUNCTION">FUNCTION</A> in a more precise manner.  Hopefully
saving you time which can be put to better uses, like coding more applications.
:o)

Note: The particular example presented here is not an actual crash log from a
compiled <A HREF="#GFA-Basic">GFA-Basic</A> program, however all the same principles apply.


<B>Understanding the crash log</B>
Firstly one needs to understand the information MiNT is trying to provide when
an application crashes.  A typical crash log might look like this:

PROCESS "make_ndx" KILLED: MEMORY VIOLATION. (PID 021) Type: free
PC: 0050A128  Addr: 0090BFD4  BP: 0050A000

Note: The example used here is a an application that crashes only when MiNT's
memory protection (MP) is enabled.  All values are in hex notation.


The log entry breaks down like this:

<U>Entry                           Description</U>
PROCESS "make_ndx"              name of the program that crashed
KILLED: MEMORY VIOLATION        the reason the program was killed
(PID 021)                       <A HREF="#GEMDOS">GEMDOS</A> Process ID of the program
Type: free                      type of memory block accessed
PC: 0050A128                    address of Program Counter
Addr: 0090BFD4                  address it attempted to access
BP: 0050A000                    <A HREF="#BASEPAGE">BASEPAGE</A> address of the program

Type can have one of the following entries:

<U>Type            Description</U>
private         owned by another application
global          remapped to 'hardware' for violation reports
super   only    accessible in supervisor mode only
readable        read only, writing not allowed
free            free memory, has no owner
hardware        memory not controlled by MiNT

This represents the type of memory block the application attempted to illegally
access.  This can be an important clue.

Note: Information taken from file mprot.x on the MiNT <A HREF="#CVS">CVS</A> server.


<B>Interpreting the crash log</B>
The most interesting pieces of information here are the PC and BP values.  With
a little math we can determine the exact offset into the binary where the crash
occurred.

<A HREF="#OFFSET">OFFSET</A> <A HREF="#=">=</A> PC <A HREF="#-">-</A> (BP <A HREF="#+">+</A> 256)

This is accomplished by subtracting the <A HREF="#BASEPAGE">BASEPAGE</A> <A HREF="#+">+</A> 256 from the Program Counter.
Adding 256 to the <A HREF="#BASEPAGE">BASEPAGE</A> accounts for the size of the BASEPAGE itself.  We are
not interested in the <A HREF="#BASEPAGE">BASEPAGE</A> because it will not be included in the
disassembly.

In the above example we get this:

$0050A128 <A HREF="#-">-</A> ($0050A000 <A HREF="#+">+</A> $100) <A HREF="#=">=</A> $28    !hex
5284136 <A HREF="#-">-</A> (5283840 <A HREF="#+">+</A> 256) <A HREF="#=">=</A> 40          !decimal

We now know that at offset $28 (40) in the binary is where the crash actually
occurred.


<B>I know the offset, now what?</B>
The next step would be to recompile the application with the <A HREF="#Symbol_Table">Symbol Table</A> option
set to on.  This allows TTDigger (TTD) to show much more detailed information
when disassembling a program.  All the <A HREF="#PROCEDURE">PROCEDURE</A> and <A HREF="#FUNCTION">FUNCTION</A> names in the
program will be visible in TTD starting with an underscore.  Some examples:

<U><A HREF="#GFA-Basic">GFA-Basic</A>                  TTD</U>
<A HREF="#FUNCTION">FUNCTION</A> test              _TEST:
<A HREF="#FUNCTION">FUNCTION</A> dump_tree(addr%)  _DUMP_TR:
<A HREF="#PROCEDURE">PROCEDURE</A> init_system      _INIT_SY:
<A HREF="#PROCEDURE">PROCEDURE</A> go(x&,y&)        _GO:

Only the first 7 characters of <A HREF="#PROCEDURE">PROCEDURE</A> and <A HREF="#FUNCTION">FUNCTION</A> names will be shown.
Entry points (labels) for <A HREF="#PROCEDURE">PROCEDURE</A> and <A HREF="#FUNCTION">FUNCTION</A> names are always aligned to
the left edge of the window and followed by a colon.

Note: The 7 character limitation within the <A HREF="#Symbol_Table">Symbol Table</A> is actually part of
the DRI Object File Specification.


<B><A HREF="#Symbol_Table">Symbol Table</A> warning</B>
The <A HREF="#Symbol_Table">Symbol Table</A> will make the binary larger.  It is also recommended you do
not leave this option on all the time.  Distributing binaries with the Symbol
Table serves only hackers, and it makes reverse engineering your application
quite a bit easier.  So always remember to disable the <A HREF="#Symbol_Table">Symbol Table</A> option when
you are done debugging!


<B>Using TTD</B>
Now start TTD and load your application.  Scroll down to the offset which you
calculated earlier ($28)<A HREF="#.">.</A>  Once you locate the offset, you can see the assembler
instruction that actually caused the program to crash.  Now scroll up to the
first label that begins with an underscore "_"<A HREF="#.">.</A>  This should be the <A HREF="#PROCEDURE">PROCEDURE</A>
or <A HREF="#FUNCTION">FUNCTION</A> your program was executing when it suddenly came to a grinding halt.
Note: TTD can be set to work in Hex or Decimal mode.

It's possible the offset does not lie in the range of your application.  This
can happen if you are loading and executing external modules or overlays.  If
this happens you can apply the same techniques to the module or overlay.
However if you are not the author of the module or overlay, you probably won't
have access to the source code and thus cannot resolve the problem yourself.


<B>Another tip that might help</B>
If you suspect your program is crashing outside of a <A HREF="#PROCEDURE">PROCEDURE</A> or <A HREF="#FUNCTION">FUNCTION</A> you
can add some markers that are easy to spot in TTD.

Examples:       dummy$<A HREF="#=">=</A>"XXXX"
                dummy$<A HREF="#=">=</A>"<A HREF="#&#62;">&#62;</A><A HREF="#&">&</A>#62;&#62;&#62;"

The <A HREF="#GFA-Basic">GFA-Basic</A> Compiler converts 4 character strings directly into  code instead
of placing them in the <A HREF="#DATA">DATA</A> segment of the binary.  Thus they will appear in the
TTD listing exactly where you place them in your source code.

Note: Turn on the HEX/ASC option in TTD.


<B>TTD output (further analysis)</B>
Here's the actual code segment from the offending application:

<A HREF="#*">*</A>       Created by TT-Digger v7.0
<A HREF="#*">*</A>       Mon Apr 24 07:54:20 2006

<A HREF="#*">*</A>       <A HREF="#TEXT">TEXT</A>            $0004FC bytes, segment starts at $00000000
<A HREF="#*">*</A>       <A HREF="#DATA">DATA</A>            $00005E bytes, segment starts at $000004FC
<A HREF="#*">*</A>       BSS             $00014E bytes, segment starts at $0000055A
<A HREF="#*">*</A>       SYMBOLS $000000 bytes
<A HREF="#*">*</A>       FLAG            $0000


000:    movea.l $0004(a7),a0            <A HREF="#;">;</A> a0 <A HREF="#=">=</A> basepage addr
004:    move.l  $000C(a0),d0            <A HREF="#;">;</A> d0 <A HREF="#=">=</A> length of text segment
008:    add.l   $0014(a0),d0            <A HREF="#;">;</A> add d0,length of data segment
00C:    add.l   $001C(a0),d0            <A HREF="#;">;</A> add d0,length of bss segment
010:    addi.l  <A HREF="##">#</A>$00000100,d0           <A HREF="#;">;</A> add d0,256
016:    move.l  d0,<A HREF="#-">-</A>(a7)                <A HREF="#;">;</A> push new size on to the stack
018:    move.l  a0,<A HREF="#-">-</A>(a7)                <A HREF="#;">;</A> push block addr on to the stack
01A:    clr     <A HREF="#-">-</A>(a7)                   <A HREF="#;">;</A> push 0 on to the stack
01C:    move    <A HREF="##">#</A>$004A,<A HREF="#-">-</A>(a7)            <A HREF="#;">;</A> push Mshrink opcode on to the stack
020:    trap    #1                      <A HREF="#;">;</A> Gemdos (make the call)
022:    adda.l  <A HREF="##">#</A>$0000000C,a7           <A HREF="#;">;</A> restore stack to previous state
028:    move.l  <A HREF="##">#</A>$FFFFFFFF,<A HREF="#-">-</A>(a7)        <A HREF="#;">;</A> push -1 on to the stack
02E:    move    <A HREF="##">#</A>$0048,<A HREF="#-">-</A>(a7)            <A HREF="#;">;</A> push Malloc opcode on to the stack
032:    trap    #1                      <A HREF="#;">;</A> Gemdos (make the call)
034:    addq.l  #6,a7                   <A HREF="#;">;</A> restore stack to previous state

Note: This is only a partial listing.  The actual listing is much larger, but
its not really needed to illustrate the problem.  Comments added for clarity.

Program breakdown:
$000 <A HREF="#-">-</A> $010     computes the actual program size, result in d0
$016 <A HREF="#-">-</A> $022     <A HREF="#MSHRINK">MSHRINK</A> call    -<A HREF="#&#62;">&#62;</A> status%=MSHRINK(addr%,size%)
$028 <A HREF="#-">-</A> $034     <A HREF="#MALLOC">MALLOC</A> call     -<A HREF="#&#62;">&#62;</A> free_ram%=MALLOC(-1)


<B>Understanding the problem</B>
From the listing we can determine the crash occurs very early on in the programs
start up phase.  We can see at offset $28 we have this:

move.l  <A HREF="##">#</A>$FFFFFFFF,<A HREF="#-">-</A>(a7)

This one line of code simply tries to move (<A HREF="#LPOKE">LPOKE</A> if you will) the value -1 to
where ever the stack pointer is currently pointing. Why does this one line of
code bring our program to a grinding halt?

The answer in this case requires some basic knowledge of how MiNT starts up an
application.  The first thing MiNT does is allocate all available ram (largest
available block)<A HREF="#.">.</A>  It then creates a <A HREF="#BASEPAGE">BASEPAGE</A> for the application in the first
256 bytes and following that is the actual code of the application.  By default
MiNT sets the user stack pointer to the end of the memory block.

This line of code is actually the program preparing for a <A HREF="#MALLOC">MALLOC</A> call.  It is
attempting to inquire (-1) the largest free memory block.

What happens in this particular case is the program attempts to do the right
thing and give back memory it does not need with <A HREF="#MSHRINK">MSHRINK</A><A HREF="#.">.</A>  However, before doing
so it fails to move the stack pointer to a safe location inside it's own memory
space.  Remember the stack pointer by default is pointing to the end of the
memory block.  After the <A HREF="#MSHRINK">MSHRINK</A> call the stack pointer is literally left
pointing out into free memory!  As soon as the <A HREF="#MSHRINK">MSHRINK</A> succeeds the memory is
no longer owned by the application and under no circumstances will MiNT allow
you to access memory you do not own when MP is enabled.  The program is
instantly killed as a result.  This is a huge mistake on the part of the
programmer, if not downright sloppy programming.

There you have it, a way to let MiNT help you debug your programs.


<B>Contact</B>
Hopefully the information presented here is useful.  To make suggestions or
report a typo please visit:

<A TARGET="_BLANK" HREF="http://www.bright.net/~gfabasic/">http://www.bright.net/~gfabasic/</A>


eof
<HR SIZE=3><H2 ID="C_to_GFABASIC">C to GFABASIC</H2>
Tips on porting 'C' to GFABASIC

<B>C         GFA        Notes</B>
<A HREF="#-">-</A>------------------------------
<A HREF="#&">&</A>&        <A HREF="#AND">AND</A>        <A HREF="#IF">IF</A> compare
<A HREF="#&#124;">&#124;</A><A HREF="#&">&</A>#124;        <A HREF="#OR">OR</A>         <A HREF="#IF">IF</A> compare
<A HREF="#!">!</A><A HREF="#=">=</A>        <A HREF="#&#60;&#62;">&#60;&#62;</A>         <A HREF="#IF">IF</A> compare
<A HREF="#==">==</A>        <A HREF="#=">=</A>          <A HREF="#IF">IF</A> compare
<A HREF="#&">&</A>         <A HREF="#AND()">AND()</A>      operator
<A HREF="#&#124;">&#124;</A>         <A HREF="#OR()">OR()</A>       operator
<A HREF="#%">%</A>         <A HREF="#MOD()">MOD()</A>      operator
<A HREF="#!">!</A>         <A HREF="#NOT">NOT</A>        operator
<A HREF="#~">~</A>         <A HREF="#NOT">NOT</A>        bitwise
<A HREF="#^">^</A>         <A HREF="#XOR">XOR</A>        bitwise
<A HREF="#&#60;">&#60;</A><A HREF="#&">&</A>#60;        <A HREF="#SHL">SHL</A><A HREF="#()">()</A>      bitwise
<A HREF="#&#62;">&#62;</A><A HREF="#&">&</A>#62;        <A HREF="#SHR">SHR</A><A HREF="#()">()</A>      bitwise
var++     <A HREF="#INC">INC</A> var
var--     <A HREF="#DEC">DEC</A> var
a+=b      a=a+b
a-=b      a=a-b
a*=b      a=a*b
a/=b      a=a/b
a%=b      a=<A HREF="#MOD">MOD</A>(a,b)
a&=b      a=<A HREF="#AND">AND</A>(a,b)
a&#124;=b      a=<A HREF="#OR">OR</A>(a,b)
a^=b      a=<A HREF="#XOR">XOR</A>(a,b)
a&#60;&#60;=b     a=<A HREF="#SHL">SHL</A>(a,b)
a&#62;&#62;=b     a=<A HREF="#SHR">SHR</A>(a,b)
var[x]    array(x)   subscript
&var      *var       address of
Random()  <A HREF="#XBIOS">XBIOS</A>(17)  24-bit random number

<HR>

These are structure referenece and must be recoded.

a-<A HREF="#&">&</A>#62;b  structure dereference
a.b   structure reference

<HR>

Variable types:

int var         word size
unsigned int    card size (must use long)
char var        string or byte size
int var[10]     <A HREF="#DIM">DIM</A> var&(10)
#define var 2   replaced at compile time

<HR>

Constructs like this do not work in GFA:
  a=b=c=2

  In 'C' this sets all variables to the value of 2.
  GFA interpreters this as a logic comparison and it must be recoded:
    a=2
    b=2  !assigned individually
    c=2

<HR>

<B>The <A HREF="#?">?</A> <A HREF="#.">.</A>.. <A HREF="#:">:</A> ... operator</B>

The <A HREF="#?">?</A> <A HREF="#.">.</A>.. <A HREF="#:">:</A> ... operator is a sort of shorthand if...else... statement.
Because it is a little cryptic, it is not often used, but the basic form is as
follows:

(condition) <A HREF="#?">?</A>  expression1 <A HREF="#:">:</A> expression2;

The program evaluates condition. If it is true (not zero), then expression1 is
returned; otherwise, expression2 is returned.

For example, in the short program below, the line
bas <A HREF="#=">=</A> (foo <A HREF="#&#62;">&#62;</A> bar) <A HREF="#?">?</A> foo <A HREF="#:">:</A> bar;
assigns foo to bas if foo is greater than bar; otherwise, it assigns bar to
bas.

#include <A HREF="#&">&</A>#60;stdio.h&#62;

int main()
{
  int foo <A HREF="#=">=</A> 10;
  int bar <A HREF="#=">=</A> 50;
  int bas;

  bas <A HREF="#=">=</A> (foo <A HREF="#&#62;">&#62;</A> bar) <A HREF="#?">?</A> foo <A HREF="#:">:</A> bar;

  printf("bas <A HREF="#=">=</A> %d\n\n", bas)<A HREF="#;">;</A>

  return 0;
}

The program will print bas <A HREF="#=">=</A> 50 as a result.

Another example:
  x <A HREF="#=">=</A> (x&#62;0) <A HREF="#?">?</A> x <A HREF="#:">:</A> -x

  translates to:

  <A HREF="#IF">IF</A> x&#62;0
    x=x
  <A HREF="#ELSE">ELSE</A>
    x=-x
  <A HREF="#ENDIF">ENDIF</A>

  which basically is the same as x=<A HREF="#ABS">ABS</A>(x)
<HR SIZE=3><H2 ID="GFA-Basic_v3_float_format">GFA-Basic v3 float format</H2>
From: Albin La&#946; &#60;Albin_Lass@HB2.maus.de&#62;
Organization: MAUS Hansestadt Bremen 2 +49-421-702569
Newsgroups: <A HREF="#&">&</A>#60;maus.computer.sprache.gfabasic&#62;
Date: Wednesday, September 11, 2002 7:11 AM
Subject: Re: floating point conversion

Hi Lonny!

LP&#62; How does GFA internally store these?

Byte: 0       1       2       3       4       5        <A HREF="#&#124;">&#124;</A> 6       7
Bit <A HREF="#:">:</A> 63                                            16 <A HREF="#&#124;">&#124;</A> 15             0
      IMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM   SEEEEEEEEEEEEEEE
      <A HREF="#&#60;">&#60;</A><A HREF="#-">-</A>-------------- 48 bit Mantissa --------------<A HREF="#&#62;">&#62;</A>   <A HREF="#&">&</A>#60;--- 16 bit ---&#62;
      <A HREF="#^">^</A>                  (normalized)                    ^   Exponent
      <A HREF="#&#124;">&#124;</A>                                                  <A HREF="#&">&</A>#124; (bias=1023)
      <A HREF="#&#124;">&#124;</A>                                                  <A HREF="#&">&</A>#124;
      <A HREF="#+">+</A><A HREF="#-">-</A>- MSB <A HREF="#=">=</A> Integer Bit                              +-- Sign of Mantissa

Integer Bit is allways one, except number is zero (then all Bytes zero)<A HREF="#.">.</A>
If Exponent negative (sign of Mantissa is negative), than  exp <A HREF="#=">=</A> -exp.

<A HREF="#-">-</A>-------------------------------- schnipp ---------------------------------
<A HREF="#CLS">CLS</A>
<A HREF="#DO">DO</A>
  <A HREF="#INPUT">INPUT</A> "Number: ";number#
  addr%=V:number#
  mantissa_h%<A HREF="#=">=</A>{addr%}
  mantissa_l%<A HREF="#=">=</A><A HREF="#CARD">CARD</A>{addr%+4}
  bias%<A HREF="#=">=</A><A HREF="#WORD">WORD</A>{addr%+6}
  <A HREF="#PRINT">PRINT</A> "BYTE: 0       1       2       3       4       5        6       7"
  <A HREF="#PRINT">PRINT</A> "BIT <A HREF="#:">:</A> 63                                            16 15             0"
  <A HREF="#PRINT">PRINT</A> "BIN <A HREF="#:">:</A> "<A HREF="#;">;</A><A HREF="#BIN$">BIN$</A>(mantissa_h%,32);BIN$(mantissa_l%,16)'BIN$(bias%,16)
  <A HREF="#PRINT">PRINT</A> "HEX <A HREF="#:">:</A> "<A HREF="#;">;</A><A HREF="#HEX$">HEX$</A>(mantissa_h%,8);HEX$(mantissa_l%,4);<A HREF="#SPACE$">SPACE$</A>(37);HEX$(bias%,4)
  b2%=bias%
  <A HREF="#IF">IF</A> bias%<A HREF="#&">&</A>#60;0
    neg!<A HREF="#=">=</A><A HREF="#TRUE">TRUE</A>
    bias%<A HREF="#=">=</A>-bias%
  <A HREF="#ELSE">ELSE</A>
    neg!<A HREF="#=">=</A><A HREF="#FALSE">FALSE</A>
  <A HREF="#ENDIF">ENDIF</A>
  exponent%=bias%-1023
  dual_value#<A HREF="#=">=</A><A HREF="#ABS">ABS</A>(number#)<A HREF="#/">/</A>(2^exponent%)
  <A HREF="#PRINT">PRINT</A> "DEZ <A HREF="#:">:</A> "<A HREF="#;">;</A><A HREF="#LEFT$">LEFT$</A>(<A HREF="#STR$">STR$</A>(dual_value#)<A HREF="#+">+</A><A HREF="#SPACE$">SPACE$</A>(49),49);STR$(b2%);" (";STR$(exponent%);")"
  <A HREF="#PRINT">PRINT</A> "CALC: (";neg!;")^0 <A HREF="#*">*</A> ";<A HREF="#STR$">STR$</A>(dual_value#);" * 2^(";bias%;"-1023)"
  <A HREF="#PRINT">PRINT</A>
<A HREF="#LOOP">LOOP</A>
<A HREF="#-">-</A>-------------------------------- schnipp ---------------------------------

Ciao, ALbin.

<HR>

From: Albin La&#7885; &#60;Albin_Lass@HB2.maus.de&#62;
Organization: MAUS Hansestadt Bremen 2 +49-421-702569
Newsgroups: <A HREF="#&">&</A>#60;maus.computer.sprache.gfabasic&#62;
Date: Friday, September 13, 2002 3:42 AM
Subject: Re: floating point conversion

Hi Lonny!

Sorry for german writing! But, I'm a bad english writer. <A HREF="#;">;</A>)

LP&#62; I have been looking for such info for ages!

Ich hatte mal vor ca. 10 Jahren (in einem B&#402;cherladen) in irgendeinem Buch
(ich glaube es war von Data Becker) gebl&#232;ttert. Und darin war auch das
Format der GFA-Fliesskommazahlen beschrieben und ein Hinweis darauf, da&#7885;
das irgendeinem *IEEE*-Standard (wie auch die FPU-Datentypen) entsprechen
soll.
Suche also mal nach "IEEE" (die genaue Nummer und URL wei&#7885; ich leider nicht)<A HREF="#.">.</A>

LP&#62; Did you figure this out on your own?

Ja. Und zwar durch Analyse eines reassemblierten GFA-Compilats und durch
Vergleich mit den dokumentierten FPU-Datentypen.
Und die Richtigkeit der Analyse hatte ich dann nochmal mit einem Beispiel-
Programm (was ich dir gepostet habe) <A HREF="#&">&</A>#402;berpr&#402;ft.
Ach, ja. Da fehlen am Ende eigentlich noch einige Zeilen:

  result#<A HREF="#=">=</A>(neg!^0*dual_value#)*2^exponent%
  <A HREF="#PRINT">PRINT</A> "RES <A HREF="#:">:</A> "<A HREF="#;">;</A><A HREF="#STR$">STR$</A>(result#)

Ciao, ALbin.

<HR>

From: Albin La&#7885; &#60;Albin_Lass@hb2.maus.de&#62;
Organization: MAUS Hansestadt Bremen 2 (+49-421-702569)
To: <A HREF="#&">&</A>#60;atari@q1.net&#62;
Date: Monday, September 16, 2002 5:33 AM
Subject: floating point conversion

Hi Lonny!

LP&#62; I don't know any German, but lucky for me there is translators.  ;<A HREF="#-">-</A>)

Na, dann <A HREF="#.">.</A>.. Hauptsache wir verstehen uns.  <A HREF="#;">;</A>)

LP&#62; I have many books on GFA, but never found this info.

Tja, leider wei&#7885; ich nicht mehr, was das f&#402;r ein Buch das war.  <A HREF="#:">:</A>(
Ich glaube es war _nicht nur_ <A HREF="#&">&</A>#402;ber GFA.

LP&#62; I managed to add these myself after some test runs.  ;<A HREF="#-">-</A>)

Hab ich mir auch (fast) schon so gedacht.
Mit einem Calculator w&#232;re das wohl auch nichts <A HREF="#.">.</A>..  ;)

LP&#62; In this line you reference the 'number#' itself.

Stimmt, ist ein wenig umst&#232;ndlich. Einfacherer w&#232;re es so:  ;)
  <A HREF="#WORD">WORD</A>{addr%+6}=1023
  dual_value#=number#

LP&#62; How would you figure out the floating point value of a float just
LP&#62; based on the 8 bytes stored in ram?

Hatte ich ja schon geschrieben: einmal durch Anschauen (im Compilat) wie
die Routinen von GFA z.B. ein Long in ein Float wandelt (oder auch <A HREF="#STR$">STR$</A>(n#)).
Und durch Vergleich mit den FPU-Datentypen. Die sind n&#232;mlich IEEE-Standard.
Und wenn die GFA-Floats auch IEEE sind, dann sollte das ziemlich <A HREF="#&">&</A>#232;hnlich
sein.
Beschrieben werden die FPU-Datentypen z.B. im Buch "68030 Assembly Language
Reference" (von Steve Williams (Addison-Wesley)) unter dem Kapitel 4.2.1.2
"Floating Point Intructions"<A HREF="#/">/</A>"Binary Floating Point Data Formats"<A HREF="#.">.</A>
Falls Du das Buch nicht zur Hand haben solltest: Ich hab's mal in ein
Hypertext (ST-Guide) umgeschrieben:  :)

  Fileliste der Maus <A HREF="#@">@</A> OL (Phone: 0441-3844034):
  Gruppenprogrammteil Maus.Computer.Software.Hypertext

  Nr.  System   Filename       Bytes   Dauer  Abruf   DpM   Datum
  260  ST TOS   MC68030E.ZIP  429034   01:56    7     0.16  03.11.98
     Programmier-Tool, Textfile, Freeware
      Ausfuehrliche Dokumentation ueber die Motorola-Prozessoren MC68000 bis
      MC68030. Mit FPU und MMU. (Hypertext, englisch).
      Von Albin Lass <A HREF="#@">@</A> HB2

LP&#62; The files I have, I have no way to know the float value before hand,
LP&#62; if you follow me.

Nicht so ganz. Du willst wissen, wie die Bitwertigkeit der Mantisse ist?

Bit   47   46    45    44    43    42    41    <A HREF="#.">.</A>..
Wert  1    1/2   1/4   1/8   1/16  1/32  1/64  <A HREF="#.">.</A>..
oder  2^0  2^-1  2^-2  2^-3  2^-4  2^-5  2^-6  <A HREF="#.">.</A>..

LP&#62; Thus, I cannot compute 'dual_value' at all.

Wie? Per Hand? Warum <A HREF="#&">&</A>#402;berl&#232;sst Du die Arbeit nicht dem Computer?
Ahh, ich verstehe: Du willst Beweise <A HREF="#.">.</A>..  <A HREF="#;">;</A>)
Dann setze mal Folgendes im Programm ein:
<A HREF="#-">-</A>-------------------------------- schnipp ---------------------------------
  <A HREF="#.">.</A>..
  calc_dual(mantissa_h%,mantissa_l%,dual_value#)
  <A HREF="#.">.</A>..

<A HREF="#PROCEDURE">PROCEDURE</A> calc_dual(m_h%,m_l%,<A HREF="#VAR">VAR</A> dual#)
  <A HREF="#CLR">CLR</A> dual#,d_exp&
  <A HREF="#FOR">FOR</A> i&=31 <A HREF="#DOWNTO">DOWNTO</A> 0
    <A HREF="#IF">IF</A> <A HREF="#BTST">BTST</A>(m_h%,i&)<A HREF="#=">=</A><A HREF="#TRUE">TRUE</A>
      dual#=dual#+2^d_exp&
    <A HREF="#ENDIF">ENDIF</A>
    <A HREF="#DEC">DEC</A> d_exp&
  <A HREF="#NEXT">NEXT</A> i&
  <A HREF="#FOR">FOR</A> i&=15 <A HREF="#DOWNTO">DOWNTO</A> 0
    <A HREF="#IF">IF</A> <A HREF="#BTST">BTST</A>(m_l%,i&)<A HREF="#=">=</A><A HREF="#TRUE">TRUE</A>
      dual#=dual#+2^d_exp&
    <A HREF="#ENDIF">ENDIF</A>
    <A HREF="#DEC">DEC</A> d_exp&
  <A HREF="#NEXT">NEXT</A> i&
<A HREF="#RETURN">RETURN</A>
<A HREF="#-">-</A>-------------------------------- schnapp ---------------------------------

LP&#62; Many thanks for the info,

Bitte sch&#252;&#252;&#252;nn!

LP&#62; I am much closer than I was.

Na, hoffentlich bist Du _jetzt_ noch ein bischen _mehr_ schlauer geworden. <A HREF="#;">;</A>)

LP&#62; <A TARGET="_BLANK" HREF="http://www.q1.net/~atari/">http://www.q1.net/~atari/</A>

Hmm, ist da nicht auch ein Crack-Code bez&#402;glich LST-&#62;GFA drauf?  <A HREF="#:">:</A>)

Ciao, ALbin.
<HR SIZE=3><H2 ID="ST-Basic_float_format">ST-Basic float format</H2>

 31                     8 7 6     0
 mmmmmmmmmmmmmmmmmmmmmmmm s eeeeeee

 m <A HREF="#=">=</A> mantissa
 s <A HREF="#=">=</A> sign bit
 e <A HREF="#=">=</A> exponent

Note: Maximum of 5 decimal places: '0.12345'

<A HREF="#-">-</A>-------------------------------------------------------------------------------

From: <A TARGET="_BLANK" HREF="http://alvyn.sourceforge.net/amos_file_formats.html">http://alvyn.sourceforge.net/amos_file_formats.html</A>

    <A HREF="#*">*</A> 4 bytes: the single-precision floating point value.
          o bits 31-8: mantissa (24 bits)
          o bit 7: sign bit. Positive if 0, negative if 1
          o bits 6-0: exponent

An exponent of 0 means 0.0, regardless of mantissa.
Counting from MSB (23) to LSB (0),
each bit set in the mantissa is 2^(mantissa_bit <A HREF="#+">+</A> exponent <A HREF="#-">-</A> 88)

<A HREF="#-">-</A>-------------------------------------------------------------------------------

From: <A TARGET="_BLANK" HREF="http://www.atari-forum.com/wiki/index.php/STOS.BAS">http://www.atari-forum.com/wiki/index.php/STOS.BAS</A>

1 long: number value <A HREF="#-">-</A> 1st 24 bits are the mantissa, 
                       25th bit is the sign,
                       last 7 bits are the exponent

Note: to convert to a readable format,
each bit of the mantissa <A HREF="#=">=</A> 2 <A HREF="#^">^</A> (bit_position <A HREF="#+">+</A> exponent <A HREF="#-">-</A> 88.0).
Add up the values indicated by each bit in the mantissa.

<HR>

<A HREF="#FUNCTION">FUNCTION</A> get_float(<A HREF="#VAR">VAR</A> p%)
  <A HREF="#LOCAL">LOCAL</A> s!
  <A HREF="#LOCAL">LOCAL</A> e&,b&
  <A HREF="#LOCAL">LOCAL</A> d%,m%
  <A HREF="#LOCAL">LOCAL</A> f
  f=<A HREF="#FALSE">FALSE</A>
  d%<A HREF="#=">=</A><A HREF="#LONG">LONG</A>{p%}
  m%<A HREF="#=">=</A><A HREF="#SHR">SHR</A>(d%,8)    !mantissa
  s!<A HREF="#=">=</A><A HREF="#BTST">BTST</A>(d%,7)   !sign
  e&<A HREF="#=">=</A><A HREF="#AND">AND</A>(d%,&H7F) !exponent
  <A HREF="#IF">IF</A> e&<A HREF="#&#62;">&#62;</A><A HREF="#FALSE">FALSE</A>     !fix?
    <A HREF="#FOR">FOR</A> b&=23 <A HREF="#DOWNTO">DOWNTO</A> 0
      <A HREF="#IF">IF</A> <A HREF="#BTST">BTST</A>(m%,b&)<A HREF="#=">=</A><A HREF="#TRUE">TRUE</A>
        f=f+(2^(b&+e&-88))
      <A HREF="#ENDIF">ENDIF</A>
    <A HREF="#NEXT">NEXT</A> b&
  <A HREF="#ENDIF">ENDIF</A>
  <A HREF="#IF">IF</A> s!<A HREF="#=">=</A><A HREF="#TRUE">TRUE</A>      !negative?
    f=-f
  <A HREF="#ENDIF">ENDIF</A>
  <A HREF="#ADD">ADD</A> p%,4
  <A HREF="#RETURN">RETURN</A> <A HREF="#ROUND">ROUND</A>(f,5) !clip
<A HREF="#ENDFUNC">ENDFUNC</A>
<HR SIZE=3><H2 ID="Assembler_Notes">Assembler Notes</H2>
<B>Program startup</B>

move.l	4(a7),d0  ;basepage address (prg)
move.l	a0,d0     ;0=prg/&#60;&#62;0 acc (basepage address)
a7                ;prg=stack assigned by os/acc=invalid, no stack!

Accessories are pre-shrunk (<A HREF="#MSHRINK">MSHRINK</A>) by the OS.
Programs must call <A HREF="#MSHRINK">MSHRINK</A> themselves.

Initial <A HREF="#DTA">DTA</A> address <A HREF="#=">=</A> <A HREF="#BASEPAGE">BASEPAGE</A>+128
If you don't move the <A HREF="#DTA">DTA</A>, the command line will be clobbered.

<HR>

<B>OS calls</B>

Type    Destroyed      Output    Input     Invalid opcodes
<A HREF="#-">-</A>-----  -------------  --------  --------  ---------------------------
<A HREF="#AES">AES</A>     none <A HREF="##">#</A>         paramblk  paramblk  crash (N.Aes pops an alert)
<A HREF="#VDI">VDI</A>     none <A HREF="##">#</A>         paramblk  paramblk  crash
<A HREF="#BIOS">BIOS</A>	d0-d2/a0-a2    d0        stack     garbage (MiNT -32)
<A HREF="#XBIOS">XBIOS</A>   d0-d2/a0-a2    d0        stack     opcode
<A HREF="#GEMDOS">GEMDOS</A>  d0-d2/a0-a2    d0        stack     -32
<A HREF="#Line-A">Line-A</A>  d0-d2/a0-a2 <A HREF="#*">*</A>  <A HREF="#+">+</A>         paramblk  crash

<A HREF="##">#</A> <A HREF="#=">=</A> Noted in the TOS.HYP
<A HREF="#*">*</A> <A HREF="#=">=</A> Additional registers that are destroyed are noted at each function call.
<A HREF="#+">+</A> <A HREF="#=">=</A> Depends on the call made.

Note: Never call the <A HREF="#AES">AES</A> in supervisor mode.

<HR>

<B>FireBee notes:</B>

The TAS instruction causes cache issue on the FireBee. Don't use it!
<HR SIZE=3><H2 ID="Compatibility_with_GFA-BASIC_3.5">Compatibility with GFA-BASIC 3.5</H2>
These funtions were added to v3.6:
  <A HREF="#_C">_C</A>
  <A HREF="#_X">_X</A>
  <A HREF="#_Y">_Y</A>
  <A HREF="#GETSIZE">GETSIZE</A><A HREF="#()">()</A>

GFABASIC v3.5 will load v3.6 tokenized files. If you use the functions noted
above the editor will display garbage. Trying to run or compile the code
will likely result in a crash.

The rules are simple.
  1) If you code with v3.5 you can safely migrate to v3.6 without any
     problems.
  2) If you code with v3.6 be careful if you attempt to migrate back to v3.5.
     The best way to do that is to save as <A HREF="#ASCII">ASCII</A> and then merge the listing.
     This way the editor will flag anything it don't like with '<A HREF="#==&#62;">==&#62;</A>'<A HREF="#.">.</A>
<HR SIZE=3><H2 ID="Understanding_GFA's_VDI_scheme">Understanding GFA's VDI scheme</H2>
<B>Redirecting all <A HREF="#VDI">VDI</A> calls</B>

handle&<A HREF="#=">=</A><A HREF="#V_OPNWK">V_OPNWK</A>(<A HREF="#.">.</A>..
<A HREF="#V~H">V~H</A>=handle&  !send all gfx commands to this handle
<A HREF="#'">'</A> many <A HREF="#VDI">VDI</A> calls...
<A HREF="#'">'</A> <A HREF="#.">.</A>..
<A HREF="#V_CLSWK">V_CLSWK</A><A HREF="#()">()</A>  !gfa closes the workstation and internally does <A HREF="#V~H">V~H</A><A HREF="#=">=</A>-1

This scheme might seem odd at first, but it's somewhat rare to open another
workstation. It does however have less overhead than the usual way. Why pass
the same handle to hundreds of <A HREF="#VDI">VDI</A> calls? Once you understand how GFA manages
<A HREF="#VDI">VDI</A> calls it's really rather simple.

<A HREF="#V~H">V~H</A>=x redirects all graphics commands like <A HREF="#LINE">LINE</A>, <A HREF="#BOX">BOX</A>, <A HREF="#PLOT">PLOT</A>, and anything
called via <A HREF="#VDISYS">VDISYS</A> so long as you leave <A HREF="#CONTRL">CONTRL</A>(6) alone.

There's also no need to copy the contents of <A HREF="#V~H">V~H</A> before redirecting as GFA
itself keeps it's own backup copy. The command <A HREF="#V~H">V~H</A><A HREF="#=">=</A>-1 reset it back to it's
original value, the default workstation openwd at startup.
<HR SIZE=3><H2 ID="GFA-Basic_Editor/Interpreter_Manual">GFA-Basic Editor/Interpreter Manual</H2>
CONTENTS
<HR>

<B><A HREF="#Chapter__1_-_Introduction">Chapter  1 - Introduction</A></B>
  <A HREF="#About_This_Manual">About This Manual</A>
  <A HREF="#Using_GFA-Basic_3_For_The_First_Time">Using GFA-Basic 3 For The First Time</A>
  <A HREF="#The_Editor">The Editor</A>
    <A HREF="#Fundamentals">Fundamentals</A>
    <A HREF="#The_Cursor_Keypad">The Cursor Keypad</A>
    <A HREF="#The_Numeric_Keypad">The Numeric Keypad</A>
    <A HREF="#The_Modifier_Keys">The Modifier Keys</A>
    <A HREF="#Further_Editing_Commands">Further Editing Commands</A>
    <A HREF="#Further_Control_Commands">Further Control Commands</A>
    <A HREF="#The_Menu_Bar_and_Function_Keys">The Menu Bar and Function Keys</A>
  <A HREF="#Special_Commands">Special Commands</A>

<B><A HREF="#Chapter__2_-_Variables_and_Memory_Management">Chapter  2 - Variables and Memory Management</A></B>
  <A HREF="#Variable_Types">Variable Types</A>
  <A HREF="#Arrays">Arrays</A>
    <A HREF="#Matrix_Commands">Matrix Commands</A>
  <A HREF="#Type_Transformation">Type Transformation</A>
  <A HREF="#Pointer_Operations">Pointer Operations</A>
  <A HREF="#Deleting_and_Exchanging">Deleting and Exchanging</A>
  <A HREF="#Reserved_Variables">Reserved Variables</A>
  <A HREF="#Special">Special</A>
  <A HREF="#Memory_Management">Memory Management</A>

<B><A HREF="#Chapter__3_-_Operators">Chapter  3 - Operators</A></B>
  <A HREF="#Arithmetic_Operators">Arithmetic Operators</A>
  <A HREF="#Logical_Operators">Logical Operators</A>
  <A HREF="#Concatenation_Operator">Concatenation Operator</A>
  <A HREF="#Comparison_Operators">Comparison Operators</A>
  <A HREF="#Assignment_Operator">Assignment Operator</A>
  <A HREF="#Operator_Hierarchy">Operator Hierarchy</A>

<B><A HREF="#Chapter__4_-_Numerical_Functions">Chapter  4 - Numerical Functions</A></B>
  <A HREF="#Mathematical_Functions">Mathematical Functions</A>
  <A HREF="#Random_Number_Generator">Random Number Generator</A>
  <A HREF="#Integer_Arithmetic">Integer Arithmetic</A>
    <A HREF="#Commands_and_Functions">Commands and Functions</A>
    <A HREF="#Bit_Operations">Bit Operations</A>

<B><A HREF="#Chapter__5_-_String_Manipulation">Chapter  5 - String Manipulation</A></B>

<B><A HREF="#Chapter__6_-_Input_and_Output">Chapter  6 - Input and Output</A></B>
  <A HREF="#Keyboard_and_Screen_Handling">Keyboard and Screen Handling</A>
  <A HREF="#KEYxxx_Commands">KEYxxx Commands</A>
  <A HREF="#Data_Input_and_Output">Data Input and Output</A>
    <A HREF="#Data_Commands">Data Commands</A>
  <A HREF="#File_Management">File Management</A>
  <A HREF="#Directory_Handling">Directory Handling</A>
  <A HREF="#Files">Files</A>
  <A HREF="#Sequential_Access">Sequential Access</A>
  <A HREF="#Random_Access">Random Access</A>
  <A HREF="#Communicating_with_Peripherals">Communicating with Peripherals</A>
    <A HREF="#Byte_by_Byte_Input_and_Output">Byte by Byte Input and Output</A>
  <A HREF="#Serial_(RS232)_and_MIDI_Interfaces">Serial (RS232) and MIDI Interfaces</A>
  <A HREF="#Mouse_and_Joysticks">Mouse and Joysticks</A>
  <A HREF="#Printing">Printing</A>
  <A HREF="#Sound_Generation">Sound Generation</A>

<B><A HREF="#Chapter__7_-_Program_Structure">Chapter  7 - Program Structure</A></B>
  <A HREF="#Decision_Commands">Decision Commands</A>
  <A HREF="#Multiple_Branching">Multiple Branching</A>
  <A HREF="#Loops">Loops</A>
  <A HREF="#Procedures_and_Functions">Procedures and Functions</A>
  <A HREF="#Error_Handling">Error Handling</A>
  <A HREF="#Interrupt_Programming">Interrupt Programming</A>
  <A HREF="#Other_Commands">Other Commands</A>
  <A HREF="#Program_Tracing">Program Tracing</A>

<B><A HREF="#Chapter__8_-_Graphics">Chapter  8 - Graphics</A></B>
  <A HREF="#Graphics_Definition_Commands">Graphics Definition Commands</A>
  <A HREF="#General_Graphics_Commands">General Graphics Commands</A>
  <A HREF="#Grabbing_Sections_of_the_Screen">Grabbing Sections of the Screen</A>

<B><A HREF="#Chapter__9_-_Event,_Menu,_and_Window_Management">Chapter  9 - Event, Menu, and Window Management</A></B>
  <A HREF="#Event_Management">Event Management</A>
  <A HREF="#Pull-down_Menus">Pull-down Menus</A>
  <A HREF="#Window_Commands">Window Commands</A>
  <A HREF="#Other_Window-related_Commands">Other Window-related Commands</A>

<B><A HREF="#Chapter_10_-_System_Routines">Chapter 10 - System Routines</A></B>
  <A HREF="#BIOS,_XBIOS,_and_GEMDOS">BIOS, XBIOS, and GEMDOS</A>
  <A HREF="#Line-A_Calls">Line-A Calls</A>
  <A HREF="#VDI_Routines">VDI Routines</A>
  <A HREF="#Special_VDI_Routines_and_GDOS">Special VDI Routines and GDOS</A>
  <A HREF="#Non-BASIC_Routine_Calls">Non-BASIC Routine Calls</A>
  <A HREF="#Other_System-related_Commands">Other System-related Commands</A>

<A NAME="AES_Library"></A><B><A HREF="#Chapter_11_-_AES_Libraries">Chapter 11 - AES Libraries</A></B>
  <A HREF="#Object_Structure">Object Structure</A>
  <A HREF="#Text_Data_Structure_(TEDINFO)">Text Data Structure (TEDINFO)</A>
  <A HREF="#Icon_Data_Structure_(ICONBLK)">Icon Data Structure (ICONBLK)</A>
  <A HREF="#Color_Icon_Data_Structure_(CICONBLK)">Color Icon Data Structure (CICONBLK)</A>
  <A HREF="#Color_Icon_Structure_(CICON)">Color Icon Structure (CICON)</A>
  <A HREF="#Bit_Image_Block_Structure_(BITBLK)">Bit Image Block Structure (BITBLK)</A>
  <A HREF="#Application_Block_Structure_(APPLBLK)">Application Block Structure (APPLBLK)</A>
  <A HREF="#Parameter_Block_Structure_(PARMBLK)">Parameter Block Structure (PARMBLK)</A>
  <A HREF="#Application_Services_Library">Application Services Library</A>
    <A HREF="#Event_Library">Event Library</A>
    <A HREF="#Menu_Library">Menu Library</A>
    <A HREF="#Object_Library">Object Library</A>
    <A HREF="#Form_Library">Form Library</A>
    <A HREF="#Graphics_Library">Graphics Library</A>
    <A HREF="#Scrap_Library">Scrap Library</A>
    <A HREF="#File_Selector_Library">File Selector Library</A>
    <A HREF="#Window_Library">Window Library</A>
    <A HREF="#Resource_Library">Resource Library</A>
    <A HREF="#Shell_Library">Shell Library</A>
  <A HREF="#Sample_Programs">Sample Programs</A>

<B><A HREF="#Chapter_12_-_Appendix">Chapter 12 - Appendix</A></B>
  <A HREF="#Compatibility_with_GFA-BASIC_2">Compatibility with GFA-BASIC 2</A>
  <A HREF="#GEMDOS()_Table">GEMDOS() Table</A>
  <A HREF="#BIOS()_Table">BIOS() Table</A>
  <A HREF="#XBIOS()_Table">XBIOS() Table</A>
  <A HREF="#Line-A_Variable_Table">Line-A Variable Table</A>
  <A HREF="#V_OPNWK()_and_V_OPNVWK()_Input_Parameter_Table">V_OPNWK() and V_OPNVWK() Input Parameter Table</A>
  <A HREF="#VDI_WORK_OUT()_Array_Table">VDI WORK_OUT() Array Table</A>
  <A HREF="#VT-52_Escape_Code_Table">VT-52 Escape Code Table</A>
  <A HREF="#Scan_Code_Table">Scan Code Table</A>
  <A HREF="#ASCII_Table">ASCII Table</A>
  <A HREF="#Special_ASCII_Characters">Special ASCII Characters</A>
  <A HREF="#Fill_Pattern_Table">Fill Pattern Table</A>
  <A HREF="#Line_Style_Table">Line Style Table</A>
  <A HREF="#Error_Codes">Error Codes</A>
    <A HREF="#Editor_Error_Messages">Editor Error Messages</A>   (Test option only)
    <A HREF="#Interpreter_Error_Codes">Interpreter Error Codes</A>
    <A HREF="#BIOS_Error_Codes">BIOS Error Codes</A>
    <A HREF="#GEMDOS_Error_Codes">GEMDOS Error Codes</A>
    <A HREF="#Bomb_Error_Codes">Bomb Error Codes</A>

<A HREF="#Publisher">Publisher</A>
<HR SIZE=3><H2 ID="GFA_PTCH.TXT">GFA_PTCH.TXT</H2>
<A HREF="#-">-</A>--------------------------------------------------------------------------
<A HREF="#-">-</A>                 GFA-BASIC Interpreter/Compiler-Patcher                  -
<A HREF="#-">-</A>                             Version 1.07                                -
<A HREF="#-">-</A>--------------------------------------------------------------------------
<A HREF="#-">-</A> Compiler <A HREF="#&">&</A> Library-Patches by                                           -
<A HREF="#-">-</A> Christoph Conrad, Adalbertsteinweg 113, D-52070 Aachen                  -
<A HREF="#-">-</A> eMail: Christoph_Conrad@AC3.maus.de                                     -
<A HREF="#-">-</A>                                                                         -
<A HREF="#-">-</A> Interpreter-Patches and GEM interface by                                -
<A HREF="#-">-</A> Gregor Duchalski, Baueracker 15a, D-44627 Herne                         -
<A HREF="#-">-</A> eMail: Gregor_Duchalski@<A HREF="#DO">DO</A>.maus.ruhr.de                                 -
<A HREF="#-">-</A>                                                                         -
<A HREF="#-">-</A> A big thank you for the English translation of GFA_PTCH                 -
<A HREF="#-">-</A> and this documentation goes to *The System ST Team*                     -
<A HREF="#-">-</A>--------------------------------------------------------------------------

The program enclosed provides a convenient method of making useful patches 
to the GFA-BASIC 3.x interpreter and compiler.

At the start, select the Basic interpreter or compiler (GFA_BCOM.PRG). 
After that you will be taken to the settings dialog box.

Something in advance: Please take care not to save the patched program(s) 
under the same name as the original(s)<A HREF="#.">.</A> We accept no responsibility for the 
functionality of the patches, anyone who damages his own interpreter and 
does not have a backup, only has himself to blame!

<A HREF="#-">-</A>---------------------------------------------------------------------------
Patching the compiler
<A HREF="#-">-</A>---------------------------------------------------------------------------
Two changes can be made to the compiler or to the library:

<A HREF="#-">-</A> Insertion of an improved INIT section
<A HREF="#-">-</A> A bugfix for the crash under Mag!X

Both patches can be made individually or in one go. The Mag!X patch only 
changes the GFA_BCOM.PRG file, the INIT patch also updates the library.

In the patch dialog box, you can enter the new names that should be used to 
save the compiler and the library. If necessary, you can also use the 
original library again in case the preset name is not correct.

<A HREF="#-">-</A>---------------------------------------------------------------------------
Patching the compiler 1: New INIT section
<A HREF="#-">-</A>---------------------------------------------------------------------------
You can get precise information about the new INIT section by reading the 
text file <A HREF="#LIBPATCH.TXT">LIBPATCH.TXT</A><A HREF="#.">.</A> The listing <A HREF="#ERR">ERR</A>.LST contains some examples of
how to use the new features.

Important: The LIBPATCH folder _must_ contain the files <A HREF="#HIDEM">HIDEM</A>.O, INIT35.O 
and INIT36.O!

Clicking on 'Patch' will start the automatic patching procedure. At the 
end, you should try to create a new <A HREF="#index">index</A> file (GFA3BLIB.NDX) using the 
program MAKE_NDX.PRG. This program (you should have received this with the 
original package containing the compiler) will search first in the original 
library folder and then in the folder LIBPATCH. If this fails, the file can 
still be chosen using the file selector. If this also fails, then the 
program will terminate. You should be aware that in this instance you will 
have to create an NDX file 'by hand'<A HREF="#.">.</A> If you can avoid this situation, so 
much the better.

Hint: If you do not have the MAKE_NDX.PRG program, you can obtain this from
GFA Systemtechnik (good luck with that) or send your original diskette and
a stamped, addressed return mailer to G. Duchalski and the adress mentioned
above.

<A HREF="#-">-</A>--------------------------------------------------------------------------
Patching the compiler II: MAG!X bugfix
<A HREF="#-">-</A>--------------------------------------------------------------------------
The compiler crashes under Mag!X with the message "Memory block destroyed"<A HREF="#.">.</A>
This is the cause:

The compiler uses MShrink (<A HREF="#GEMDOS">GEMDOS</A> 74) to reduce its memory requirement as 
neccessary. Using Malloc (<A HREF="#GEMDOS">GEMDOS</A> 72) it then checks for the largest 
available memory block and allocates this amount less 16 Kbytes. 
Unfortuantely, the program assumes fom this that the allocated memory lies 
directly after the area previously shrunk. In general this is true. Under 
Mag!X, it lies before the allocated memory block (the address that was 
returned by MAlloc) which is indeed the so-called MCB, 'Memory Control 
Block'<A HREF="#.">.</A>

This contains
<A HREF="#-">-</A> An identifier ('ANDR' or 'KROM' a greeting to one of the programmers
<A HREF="#-">-</A> The length of the allocated block
<A HREF="#-">-</A> The base page address of the program, to which the block belongs
<A HREF="#-">-</A> A pointer to the last MCB.

The GFA compiler overwrites the MCB. After the compiler terminates, Mag!X 
checks whether the chain of MCBs is still intact and then reports the error 
described.

By the way: This problem also occurs under MultiTOS. However, in this case 
it can be removed by simply setting the memory protection flags in the 
program header to GLOBAL.

Through the use of the patch, the GFA compiler no longer uses the first 
16 bytes lying after the MShrink memory block and therefore dose not 
overwrite an MCB. The behaviour of the compiler remains nevertheless 
incorrect, so that the area allocated does not unconditionally lie after 
that which is still in use by the compiler (although as a rule this is 
true)<A HREF="#.">.</A>

<A HREF="#-">-</A>---------------------------------------------------------------------------
Patching the interpreter
<A HREF="#-">-</A>---------------------------------------------------------------------------

This provides either practical configuration patches, as documented
by GFA or the correction of errors.

Interpreters that can be patched:

 Version:     File length:

  3.6TT          104770
                 104766
                 104739
                 104597 (English version)
  3.5E           103510
                 103337 (English version)
  3.50           102519
                 102523
  3.07           92894
  
What will be patched in the interpreter?

 <A HREF="#-">-</A> No more LINEA calls:
   Also see <A HREF="#LIBPATCH.TXT">LIBPATCH.TXT</A><A HREF="#.">.</A> When moving the mouse in the editor you may get 
   some residual images, but not while a program is running.
   
 <A HREF="#-">-</A> No more <A HREF="#SETCOLOR">SETCOLOR</A> calls, that change the colors on the TT:
   GFA Basic make some errors with the internal setting and querying of the 
   screen colors, so that in resolutions like TT Medium, some colors are 
   changed after running the interpreter. This patch prevents this. Also 
   the command <A HREF="#SETCOLOR">SETCOLOR</A> will no longer have an effect. The better command 
   <A HREF="#VSETCOLOR">VSETCOLOR</A> should be used as a replacement.
   Hint: Please take note that additional patches made to the editor colors 
   in conjunction with the <A HREF="#SETCOLOR">SETCOLOR</A> patch will have no effect either!
   
 <A HREF="#-">-</A> MERGE will no longer abort when <A HREF="#ASCII">ASCII</A> 4 is encountered within the text:
   The interpreter normally aborts the merging of files at the 
   corresponding line when it encounters <A HREF="#ASCII">ASCII</A> 4 (EOT <A HREF="#==">==</A> End of trans-
   mission, CONTROL D, left arrow)<A HREF="#.">.</A> Under UNIX, <A HREF="#ASCII">ASCII</A> 4 is the <A HREF="#EOF">EOF</A> 
   character which was one of the greatest ambitions of GFA Systemtechnik. 
   This patch removes this disrupting behaviour.
   
 <A HREF="#-">-</A> <A HREF="#CALL">CALL</A> bug removed:
   The <A HREF="#CALL">CALL</A> command in interpreter version 3.6 D TT with a size of 104770 
   bytes does not work because of a typing error (movem.l a4/a6,<A HREF="#-">-</A>(sp)
   instead of movem.l a4-a6,-(sp)). The patch repairs this command.
   
 <A HREF="#-">-</A> Free system memory:
   When starting, the interpreter reserves all available memory for itself 
   apart from 16 Kbytes. This is especially a problem on non-TT machines 
   since too little memory is available for <A HREF="#accessories">accessories</A> and they refuse to 
   work. This patch allows you to set the amount of memory that will remain 
   free (e.g. 32Kbytes).

 <A HREF="#-">-</A> Activate 'New names'<A HREF="#:">:</A>
   The 'New names' option from the Basic's system menu will
   be activated automatically.
   
 <A HREF="#-">-</A> The <A HREF="#DEFLIST">DEFLIST</A> preset

 <A HREF="#-">-</A> The editor colors
   Hint: These do not work when the 'No more <A HREF="#SETCOLOR">SETCOLOR</A> calls' is active at 
   the same time.
   
 <A HREF="#-">-</A> The default variable type can be entered without Postfix.
   This is preset to Float.

 <A HREF="#-">-</A> No <A HREF="#CLS">CLS</A> when strating program
 
Patching is basically simple: Once you have selected the patches you 
require, select the "Patch.." button. The patched version of the 
interpreter will then be saved under a new name.

<A HREF="#-">-</A>---------------------------------------------------------------------------
Version history
<A HREF="#-">-</A>---------------------------------------------------------------------------
Vers.   Date

        24.07.93 <A HREF="#-">-</A> First version released. And shortly afterwards, I added 
                   the numbering of versions. <A HREF="#:">:</A>-)

0.90&#223;   26.07.93 <A HREF="#-">-</A> MERGE patch for V 3.50 of the interpreter incorporated.
                 <A HREF="#-">-</A> The defalut variable type of the interpreter loaded
                   will be read and displayed.
                 <A HREF="#-">-</A> Patches for later versions expanded.

0.91&#223;   27.07.93 <A HREF="#-">-</A> No more 'mouse droppings' with the file selector
                 <A HREF="#-">-</A> Compiler patch support started.
        
0.92&#223;   29.07.93 <A HREF="#-">-</A> <A HREF="#DEFFILL">DEFFILL</A> patch incorporated, its action was wrongly 
                   documented.
                 <A HREF="#-">-</A> GFA_BCOM.PRG now longer has an evaluation table 
                   appended. All of the data necessary is now incorporated
                   directly within the file.
                   
        01.08.93 <A HREF="#-">-</A> The compiler was wrongly patched.

0.93    08.08.93 <A HREF="#-">-</A> Library patches integrated.

0.94    13.08.93 <A HREF="#-">-</A> Call to the MAKE_NDX program was incorrect.
                 <A HREF="#-">-</A> MERGE patch for the 3.5E Interpreter incorporated.
                 <A HREF="#-">-</A> Instruction reworked.

0.95    19.08.93 <A HREF="#-">-</A> Remaining patches incorporated: <A HREF="#Line-A">Line-A</A> and <A HREF="#SETCOLOR">SETCOLOR</A>
                   suppression for Version 3.07.
                 <A HREF="#-">-</A> <A HREF="#DEFFILL">DEFFILL</A> patch expanded to a value of 8.
                 <A HREF="#-">-</A> Documents reworked again.

0.96    28.08.93 <A HREF="#-">-</A> 3.6 Interpreter with 104739 Bytes now supported.
                 <A HREF="#-">-</A> <A HREF="#Line-A">Line-A</A> patch for 3.07 doesn't work.

0.97    27.09.93 <A HREF="#-">-</A> 3.6 Interpreter with 104766 Bytes now supported.

0.98    29.09.93 <A HREF="#-">-</A> Modifications for the MAG!X-Compiler patch begun.

        02.10.93 <A HREF="#-">-</A> MAG!X-patch incorporated completely.

        04.10.93 <A HREF="#-">-</A> A brief information dialog now appears when the program 
                   is started.

0.99    23.01.94 <A HREF="#-">-</A> New INIT section. The old one contained an error in
                   conjunction with floating point varaibles.

                 <A HREF="#-">-</A> The program no longer uses LINEA.

1.00    07.02.94 <A HREF="#-">-</A> The <A HREF="#SETCOLOR">SETCOLOR</A> patch did not work with V3.50 of the 
                   interpreter.

                 <A HREF="#-">-</A> An additional patch has been added: The size of the 
                   memory which remains free after starting the program can 
                   be changed. The default is 16 Kbytes the least that is 
                   practical when using <A HREF="#accessories">accessories</A> e.g. (ERGO!help).
                   
                 <A HREF="#-">-</A> 3D effects under MultiTOS and Mag!X were incorrect.

                 <A HREF="#-">-</A> If SHIFT, CONTROL or ALTERNATE is pressed when starting
                   the program, the info dialog no longer appears. The file 
                   selector appears instead.
 
1.01    10.04.94 <A HREF="#-">-</A> The LINEA patch for the interpreter with 102523 Bytes 
                   was incorrect.

                 <A HREF="#-">-</A> The memory patch would only work on the ST until the 
                   next <A HREF="#RESERVE">RESERVE</A> call occurred. This was then reset to 16 
                   KB.

        15.04.94 <A HREF="#-">-</A> A successful patch operation is now confirmed with an
                   appropriate message.

1.02    15.05.94 <A HREF="#-">-</A> The <A HREF="#SETCOLOR">SETCOLOR</A> patch for V3.5 of the interpreter with
                   102519 Bytes did not work (Andre Muller)<A HREF="#.">.</A>

                 <A HREF="#-">-</A> Since the editor colors patch does not work at the same
                   time as <A HREF="#SETCOLOR">SETCOLOR</A> suppression, the corresponding option
                   will be diabled (David Reitter)<A HREF="#.">.</A>

1.03    20.07.94 <A HREF="#-">-</A> A few internal changes, some further security checks
                   were added and some adaptions for the new English
                   version.

                 <A HREF="#-">-</A> The 'Patch...' button will be disabled if no patch
                   is chosen for the interpreter.

1.04    11.08.94 <A HREF="#-">-</A> Included support for English 3.6 interpreter
                   (104597 bytes)<A HREF="#.">.</A>

1.05    29.08.94 <A HREF="#-">-</A> 'New names' patch included.

1.06    07.09.94 <A HREF="#-">-</A> Included support for English 3.5E interpreter
                   (103337 bytes), thanx to Bob Samuel.

1.07    05.10.94  -Included support for French 3.6TT interpreter
                   (104740 bytes)<A HREF="#.">.</A>

                  <A HREF="#-">-</A><A HREF="#ERR">ERR</A>.LST and the new <A HREF="#FILESELECT">FILESELECT</A> replacement can
                   be found in the LISTINGS directory.

        22.10.94  <A HREF="#-">-</A>'Patch...' was not selectable if only one of the
                   last three patches was chosen.

<A HREF="#-">-</A>--------------------------------------------------------------------------
Status and disclaimer
<A HREF="#-">-</A>--------------------------------------------------------------------------
GFA_PTCH is freeware and can be freely distributed so long as the contents 
of the original archive remains complete. The commercial use of this 
program is prohibited. The distribution by PD vendors is allowed provided 
that the fee charged does not exceed DM 10.<A HREF="#-">-</A>.

We accept no responsibility for the functionality of the patches, anyone
who damages his hard- or software by using GFA_PTCH and does not have a
backup only has himself to blame!

The newest version of this program can always be found in the Maus <A HREF="#DO">DO</A><A HREF="#.">.</A>

If you have any suggestions for additional patches or have a Basic version 
that is not supported, we would be pleased to here from you.

Have fun

 Gregor Duchalski <A HREF="#&">&</A> Christoph Conrad

<A HREF="#-">-</A>-------------------------------------------------------------------------
<HR SIZE=3><H2 ID="LIBPATCH.TXT">LIBPATCH.TXT</H2>
<A HREF="#*">*</A>***********************************************************************
Please note, the following text is not up to my usual(<A HREF="#?">?</A>) standard of
translation.  It is both colloquial, and contains a lot of jargon <A HREF="#-">-</A> too
much for my understanding and my dictionary!
Nevertheless, I hope it will be both useful, and usable!

The Saint <A HREF="#-">-</A> July '94
<A HREF="#*">*</A>************************************************************************

///////////////////////////////////////////////////////////////////////////////
<A HREF="#/">/</A>                                                                             /
<A HREF="#/">/</A>                                                                 19.08.93    /
<A HREF="#/">/</A>                                                                             /
<A HREF="#/">/</A>     Compiler/Library patches for GFABASIC Atari ST/STE/TT/Falcon            /
<A HREF="#/">/</A>                                                                             /
<A HREF="#/">/</A>     P*ST:                                                                   /
<A HREF="#/">/</A>           Christoph Conrad                                                  /
<A HREF="#/">/</A>           Adalbertsteinweg 113                                              /
<A HREF="#/">/</A>           52070 Aachen                                                      /
<A HREF="#/">/</A>                                                                             /
<A HREF="#/">/</A> E-Mail direct:                                                              /
<A HREF="#/">/</A>     MAUS: Christoph Conrad <A HREF="#@">@</A> AC3                                            /
<A HREF="#/">/</A>                                                                             /
<A HREF="#/">/</A> E-Mail Gateways:                                                            /
<A HREF="#/">/</A>     FIDO: Christoph Conrad <A HREF="#%">%</A> Maus AC3 2:242/2.6                             /
<A HREF="#/">/</A>           ACHTUNG: evt. neu                                                 /
<A HREF="#/">/</A>           Christoph Conrad <A HREF="#%">%</A> Maus AC3 2:242/42.333                          /
<A HREF="#/">/</A>   USEnet: Christoph_Conrad@ac3.maus.de    (keine ueberlangen Mails!)        /
<A HREF="#/">/</A> Zerberus: Christoph_Conrad%ac3@zermaus.zer                                  /
<A HREF="#/">/</A>   Pronet: MAUS:AC3:Christoph_Conrad                                         /
<A HREF="#/">/</A> Internet: conrad@pool.Informatik.RWTH-Aachen.DE                             /
<A HREF="#/">/</A>           (selten, bitte keine ueberlangen Mails!)                          /
<A HREF="#/">/</A>      BTX: Seite *35008024#, im Formular ausf&#252;llen                           /
<A HREF="#/">/</A>           Christoph_Conrad@AC3.MAUS.DE.UUCP                                 /
<A HREF="#/">/</A>           (kostet 90 Pfennig)                                               /
<A HREF="#/">/</A>                                                                             /
<A HREF="#/">/</A> In case you have discovered something that causes a problem, or you have    /
<A HREF="#/">/</A> suggestions for improvements, write to me by EMail (preferrably) or P*ST.   /
<A HREF="#/">/</A>                                                                             /
<A HREF="#/">/</A> When you find an error in Basic, write to me!                               /
<A HREF="#/">/</A>                                                                             /
<A HREF="#/">/</A> I cannot accept any responsibility or take liability for any damage that    /
<A HREF="#/">/</A> could possibly have been caused to your data or programs either directly or /
<A HREF="#/">/</A> indirectly that have occurred as a result of using these patches!           /
<A HREF="#/">/</A>                                                                             /
///////////////////////////////////////////////////////////////////////////////

Contents:

 (I) General <A HREF="#&">&</A> specific info for these patches
(II) Various questions and answers

(I) General <A HREF="#&">&</A> specific info for these patches

Moin,

GFABASIC has grown close to all of our hearts.  When I first got my ST, it was
the only programmming language that offered a really fast turn around time (edit
a program, test it, edit a....), a hyperspeed compiler/interpreter (in most cases
the compiler also created correctly fixed code!) a usable editor and could
usefully be employed on a 1Mb computer _without_ a hard drive. I suspect that
this was ther reson for the success of GFA BASIC.

In the course of time and particularly (but not only) in conjunction with
graphic improvements has GFABASIC shown some of its shortcomings. These library
patches correct some (serious) problems.

The library patches has already appeared in two versions as GFAL1030 and
improved in GFAL1072. I was then asked by Gregor Duchalski whether I did
not have the desire to contribute some of my own ideas to patch the interpreter
using a convenient GEM interface.

Since my patch program offered a convenient operating environment <A HREF="#AND">AND</A> because of
Gregor's involvement and the wishes of the GFABASIC MAUS group, I decided to do
this. This convinced me to develop my own GFA library that can be installed
using GFA_PTCH.

<A HREF="#+">+</A>+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
What does the compiler patch part of GFA_PTCH offer?

<A HREF="#-">-</A> <A HREF="#Line-A">Line-A</A> patches are incorporated automatically!
<A HREF="#-">-</A> Clean Auto folder recognition
<A HREF="#-">-</A> Clean recognition of <A HREF="#accessories">accessories</A>
<A HREF="#-">-</A> In case the memory requested by $m does not exist, this can be recognized
<A HREF="#-">-</A> $U/$I bug in 3.6 removed!
  Important: I definately advise against the $I matter in particular. It is
  untidy or in fact lethal. Also, <A HREF="#$U">$U</A> can be critical. Wirth this Init part,
  $U/$I will run just as "dirty" or "uncertain" as before, apart from the fact
  that it does now actually run under 3.6.

<A HREF="#ERR">ERR</A>.LST demonstartes to you in an exemplary way all of the features. This also
uses <A HREF="#$I+">$I+</A> cleany in the case of the demo. Take note of the comments incorporated
in <A HREF="#ERR">ERR</A>.LST and the hints offered below!

<A HREF="#!">!</A>!! Part of the assembler code is <A HREF="#&">&</A>#169; GFA Systemtechnik

Changes made to either part are for personal use only. Modified copies may not
be re-distributed!

<A HREF="#+">+</A>+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Since there was a great deal of work involved in developing these patches, If
you find them useful, a gift (of thanks) of <A HREF="#&#62;=">&#62;=</A> 10,<A HREF="#-">-</A> would show your appreciation
<A HREF="#:">:</A>-)

Alternatively, since I am a music fan, you can send me a cassette (Chrome
dioxide, Dolby B <A HREF="#-">-</A> prefferrably a TDK SA-X) containing some of your favourites.
All types from Classical vocal (Opera, Operetta etc.), Rock, Folk and Disco
(Bananarama, Sabrina) are welcome. I prefer lesser known groups/bands/
interpretations. I hope to get a flood of cassettes!!! <A HREF="#:">:</A>-)

<A HREF="#+">+</A>+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
What does GFA_PTCH.PRG do <A HREF="#?">?</A>

<A HREF="#==">==</A> (a) patches the compiler

Attention: Programs created using a patched compiler will _NOT_ run with an
           original library!

<A HREF="#==">==</A> (b) Patches the library

In the strictest sense this is not a patch but an exchange of code.

<A HREF="#==">==</A> 9c) Creation of a new <A HREF="#index">index</A> file GFA3BLIB.NDX

MAKE_NDX.PRG must be used _unconditionally_, which creates a new GFA3LIB.NDX.
this ought to be used with GFA_PTCH.

You ought probably to save the old version of GFA3BLIB.NDX even though you
could re-create this at any time using MAKE_NDX.PRG with the old library.

Unfortunately, MAKE_NDX first appeared with version 3.5. Currently I am
unaware (even if you are) whether it could be included with this package
and I have queried this with GFA.  If it can't, I will probably write a
functional equivalent.

<A HREF="#==">==</A> (d) Patch the interpreter

You must _unconditionally_ patch the interpreter using GFA_PTCH.PRG. In
case your version of the interpreter has not been seen by us:

Replace the FIRST occurrance of $A00A and $A009 by $4E71. This _ought_ to
cause a crash. As a result of the patch: $E0C0 $A00A $4CDF as well as $0008
$A009 $246E.

This will produce "mouse droppings" when moving the mouse within the
interpreter editor, but not whilst a program is running (the clean nesting
of hidems/showms for <A HREF="#GRAF_MOUSE">GRAF_MOUSE</A> is taken for granted!)<A HREF="#.">.</A>


<A HREF="#+">+</A>++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
In case you have further problems:

<A HREF="#-">-</A> Make a test with the original GFA3BLIB (<A HREF="#+">+</A> the previous GFA3BLIB.NDX).

Send me
<A HREF="#-">-</A> the INIT.O file for your library
<A HREF="#-">-</A> The exact version number/length of the library <A HREF="#&">&</A> compiler.

This can be done simply by: Run INIT2DMP.PRG from the same folder as
GFA3BLIB which will produce a printable or E-mail-able file INIT.DMP.

<A HREF="#!">!</A>!! Make sure that you use your ORIGINAL library or a copy of it and !!!
<A HREF="#!">!</A>!! not one that has already been patched                            !!!


<A HREF="#+">+</A>+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
How do I work with it <A HREF="#?">?</A>

Please take a look at the <A HREF="#ERR">ERR</A>.LST file. I hope that will be enough. You
should then read through the question and answers section of this text. The
commands that you ought to avoid (e.g. the Line A patches), and you will
find many of the tips useful.

<A HREF="#+">+</A>++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BUGS:

Hopefully there are not too many

Still being worked on:

<A HREF="#ERR">ERR</A> appears when starting the interpreter not always when initialised to
zero.

Before you blame this INIT, please test it first using the orignal GFA3BLIB
(<A HREF="#&">&</A> the previous GFABLIB.NDX).

<A HREF="#+">+</A>+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Disclaimer:

I have taken all possible precautions to create error-free programs <A HREF="#&">&</A> data.
Nevertheless, it is not totally possible to exclude errors. Therefore, the
authors cannot accept any responsibility or take liability for any damage
that could possibly have been caused to your data or programs either directly
or indirectly that have occurred as a result of using these programs!

<A HREF="#*">*</A>****************************************************************************

(II) Questions <A HREF="#&">&</A> answer section

QUESTIONS <A HREF="#&">&</A> ANSWERS:

<A HREF="#+">+</A>++++++++++++++++++++
QUESTION:
I have taken your advice that <A HREF="#Line-A">Line-A</A> should not be used. Why is this so?
Therefore, how can I make my compiler library (GFA3BLIB) <A HREF="#Line-A">Line-A</A> free?

ANSWER:
Here is an extract from the 10th edition of the Profibook:

[Start of quote]

The architecture of the operating system certainly speaks against the usage
of <A HREF="#Line-A">Line-A</A> routinmes. These are used for display in the low-level <A HREF="#VDI">VDI</A> screen
driver. Using them prevents the possible usage of another (faster) screen
driver!

Also, <A HREF="#Line-A">Line-A</A> routines are only provided for ST modes (320*200, 640*200,
640*400)<A HREF="#.">.</A> Already, with 256 color graphics (special graphic cards or the TT
in 'low' resolution) the provisions of the <A HREF="#Line-A">Line-A</A> interface have been
exhausted (see COLBIT0 to COLBIT3)

[End of quote]

In case that was a sclear as mud: DON'T PANIC!

The deciding factor in all this will be that progams using <A HREF="#Line-A">Line-A</A> routines
will not run correctly with graphic cards! Ergo: Do away with it!

<A HREF="#*">*</A>** Take heed from a correct nesting of hidems/showms (via <A HREF="#GRAF_MOUSE">GRAF_MOUSE</A> <A HREF="#AES">AES</A>
78)<A HREF="#.">.</A> For each hide of a show, "droppings" will result. With the mouse not
switched on, when it already is, as is the rule when starting GEM programs,
there are no "droppings"<A HREF="#.">.</A>

<A HREF="#*">*</A>** AVOID THE FOLLOWING COMMANDS:
<A HREF="#CRSCOL">CRSCOL</A>   <A HREF="#CRSLIN">CRSLIN</A>   <A HREF="#MOUSE">MOUSE</A>    <A HREF="#MOUSEK">MOUSEK</A>   <A HREF="#MOUSEX">MOUSEX</A>   <A HREF="#MOUSEY">MOUSEY</A>   <A HREF="#SETMOUSE">SETMOUSE</A> <A HREF="#RC_COPY">RC_COPY</A>
<A HREF="#SHOWM">SHOWM</A>    <A HREF="#HIDEM">HIDEM</A>    <A HREF="#SPRITE">SPRITE</A>   <A HREF="#ACHAR">ACHAR</A>    <A HREF="#ACLIP">ACLIP</A>    <A HREF="#ALINE">ALINE</A>    <A HREF="#APOLY">APOLY</A>    <A HREF="#ARECT">ARECT</A>
<A HREF="#ATEXT">ATEXT</A>    <A HREF="#BITBLT">BITBLT</A>   <A HREF="#HLINE">HLINE</A>    <A HREF="#L~A">L~A</A>      <A HREF="#PSET">PSET</A>     <A HREF="#PTST">PTST</A>     <A HREF="#GET">GET</A>      <A HREF="#PUT">PUT</A>
<A HREF="#SGET">SGET</A>     <A HREF="#SPUT">SPUT</A>     <A HREF="#FILESELECT">FILESELECT</A>        FILESELECT <A HREF="##">#</A>

When using without #file_number:
<A HREF="#INPUT">INPUT</A>    <A HREF="#INPUT$">INPUT$</A>   <A HREF="#LINE_INPUT">LINE INPUT</A>

Replacement commands:

MOUSE/MOUSEK/MOUSEX/MOUSEY <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> (<A HREF="#AES">AES</A>) <A HREF="#GRAF_MKSTATE">GRAF_MKSTATE</A>
<A HREF="#SETMOUSE">SETMOUSE</A>                   <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> (<A HREF="#AES">AES</A>) <A HREF="#APPL_TPLAY">APPL_TPLAY</A>
SHOWM/HIDEM                <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> (<A HREF="#AES">AES</A>) <A HREF="#GRAF_MOUSE">GRAF_MOUSE</A>
<A HREF="#FILESELECT">FILESELECT</A>                 <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> (<A HREF="#AES">AES</A>) <A HREF="#FSEL_INPUT">FSEL_INPUT</A>
<A HREF="#FILESELECT">FILESELECT</A> <A HREF="##">#</A>               <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> (<A HREF="#AES">AES</A>) FSEL_EXINPUT
<A HREF="#SPRITE">SPRITE</A>                     <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> (<A HREF="#VDI">VDI</A>) vro/vrt_cpyfm
<A HREF="#ACHAR">ACHAR</A>                      <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> (<A HREF="#VDI">VDI</A>) <A HREF="#TEXT">TEXT</A>
<A HREF="#ACLIP">ACLIP</A>                      <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> (<A HREF="#VDI">VDI</A>) <A HREF="#CLIP">CLIP</A>
<A HREF="#ALINE">ALINE</A>                      <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> (<A HREF="#VDI">VDI</A>) <A HREF="#LINE">LINE</A>
<A HREF="#APOLY">APOLY</A>                      <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> (<A HREF="#VDI">VDI</A>) <A HREF="#POLYFILL">POLYFILL</A>
<A HREF="#ARECT">ARECT</A>                      <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> (<A HREF="#VDI">VDI</A>) <A HREF="#PBOX">PBOX</A>
<A HREF="#ATEXT">ATEXT</A>                      <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> (<A HREF="#VDI">VDI</A>) <A HREF="#TEXT">TEXT</A>
<A HREF="#BITBLT">BITBLT</A>                     <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> (<A HREF="#VDI">VDI</A>) BITBLT q%<A HREF="#()">()</A>,z%(),d%()
<A HREF="#HLINE">HLINE</A>                      <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> (<A HREF="#VDI">VDI</A>) <A HREF="#LINE">LINE</A>
<A HREF="#PSET">PSET</A>                       <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> (<A HREF="#VDI">VDI</A>) <A HREF="#PLOT">PLOT</A> oder v_pmarker bei grob <A HREF="#&">&</A>#62; 200 Punkten
<A HREF="#PTST">PTST</A>                       <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> (<A HREF="#VDI">VDI</A>) <A HREF="#POINT">POINT</A>
GET/PUT/SGET/SPUT          <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> (<A HREF="#VDI">VDI</A>) <A HREF="#BITBLT">BITBLT</A>
<A HREF="#RC_COPY">RC_COPY</A>                    <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> (<A HREF="#VDI">VDI</A>) <A HREF="#BITBLT">BITBLT</A>

<A HREF="#&#62;">&#62;</A><A HREF="#&">&</A>#62; Without a guarantee of completeness!

<A HREF="#+">+</A>++++++++++++++++++++

QUESTION:
Where can I find information about GEM conformant programming?

ANSWER:
Tim Orens ProGEM. This text from 1985, which you should be able to find in
most mailboxes provides the best in 'Professsional GEM' programming. You
will find more in the book 'Vom Anf&#228;nger zum GEM-Profi' by Gebr&#252;der Geiss.
A little confused, but otherwise very good. As reference material, the
'Profibuch' by Jankowski/Reschke/Rabich, is undoubtedly irreplaceable.

<A HREF="#+">+</A>+++++++++++++++++++
QUESTION:
GFA already has good commands for using windows. What can these be used
for?

ANSWER:
I advise against using GFA's own window management routines. In previous
versions this is incorrect <A HREF="#-">-</A> today, who knows? Using the <A HREF="#AES">AES</A>, it is equally
as 'simple' or 'difficult'<A HREF="#.">.</A>

<A HREF="#+">+</A>++++++++++++++++++++
QUESTION:
Sometimes my program is no longer under my control. With the best will in
the world I cannot find any erros. What is happening and how do I find out?

ANSWER:
Use SysMon and TempleMon. You can find TempleMon in many mailboxes <A HREF="#-">-</A> SysMon
can be obtained directly from the author:-

Karsten Isakovic
Wilmersdorferstr. 82
1000 Berlin 12

At the time of the crash, you will at least be able to establish the last
used system call and possibly the bad parameter.

Another good possibility is to use the TRACE procedurename (seee the
manual)<A HREF="#.">.</A> When all of the lines that have been traced are written to a
previously opened file (<A HREF="#PRINT">PRINT</A> #1,<A HREF="#TRACE$">TRACE$</A>) you will quickly be able to
localise the cause of the crash.

The Turbo-C/Pure-C debugger can be equally as useful when the program has
been translated into symbols.

There is an extensive unknown error that exists <A HREF="#GFA-Basic">GFA-Basic</A>'s own memory
management. This exists in all three versions.

Hint: add a <A HREF="#FRE">FRE</A>(0) command (in conjunction with any string) liberally to
your code.

Try the following (after re-booting)<A HREF="#:">:</A>


<A HREF="#'">'</A> Compiler version with $m
<A HREF="#'">'</A> instead of <A HREF="#RESERVE">RESERVE</A>
<A HREF="#RESERVE">RESERVE</A> 1000
$m 4711
<A HREF="#'">'</A> <A HREF="#RESERVE">RESERVE</A> will cause a quicker crash but is actually unneccessary
<A HREF="#'">'</A> The lines ending (<A HREF="#*">*</A>*) will then really cause the interpreter to return a
<A HREF="#'">'</A> value of minus 4 from (<A HREF="#FRE">FRE</A><A HREF="#()">()</A> <A HREF="#MOD">MOD</A> 16) <A HREF="#==">==</A> 0 after the <A HREF="#RESERVE">RESERVE</A>
<A HREF="#'">'</A> Because of the backtrailer with rest16$ with the compiler in case
<A HREF="#'">'</A> $m XXXX with (XXXX <A HREF="#MOD">MOD</A> 16)<A HREF="#&#60;">&#60;</A><A HREF="#&">&</A>#62;0
rest16%<A HREF="#=">=</A>(<A HREF="#FRE">FRE</A>(0) <A HREF="#MOD">MOD</A> 16)-4   <A HREF="#!">!</A> <A HREF="#*">*</A>*
<A HREF="#IF">IF</A> rest16%<A HREF="#&">&</A>#60;0                <A HREF="#!">!</A> <A HREF="#*">*</A>*
  <A HREF="#ADD">ADD</A> rest16%,16            <A HREF="#!">!</A> <A HREF="#*">*</A>*
<A HREF="#ENDIF">ENDIF</A>                       <A HREF="#!">!</A> <A HREF="#*">*</A>*
rest16$<A HREF="#=">=</A><A HREF="#STRING$">STRING$</A>(rest16%,0)  <A HREF="#!">!</A> <A HREF="#*">*</A>*
<A HREF="#'">'</A> (<A HREF="#FRE">FRE</A><A HREF="#()">()</A> <A HREF="#MOD">MOD</A> 16) <A HREF="#==">==</A> 0 now fulfilled
str$<A HREF="#=">=</A>"AHAH"
<A HREF="#DO">DO</A>
  @crash(str$)
<A HREF="#LOOP">LOOP</A>
<A HREF="#PROCEDURE">PROCEDURE</A> crash(str$)
  str$<A HREF="#=">=</A>"OHOH"
<A HREF="#RETURN">RETURN</A>

<A HREF="#+">+</A>++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<A HREF="#Special">Special</A> thanks:

<A HREF="#-">-</A> Harald Ax for DELITE, an outstanding GFA-Shell
<A HREF="#-">-</A> Jankowski/Rabich/Reschke for his "Profibuch", an indispensible treasure.
<A HREF="#-">-</A> Karsten Isakovic for his 'SysMon', as well as
  Thomas Tempelmann and Johannes Hill for 'TempleMon'
  Both tool are known as 'The Programmers best friends' <A HREF="#:">:</A>-)
<A HREF="#-">-</A> ATARI <A HREF="#/">/</A> Landon Dyer for the 'MadMac'<A HREF="#.">.</A>
<A HREF="#-">-</A> GENESIS for 'Selling England by the pound' as well as 'Foxtrot'
  THE CURE for 'Disintegrations'
  THE RED HOT CHILI PEPPERS for 'Blood sugar sex magik'
  KING'S X <A HREF="#&">&</A>#169; 1992 (with 'Black Flag')
  TEMPLE OF THE DOG f&#252;r ihr Deb&#252;talbum
  RAGE AGAINST THE MACHINE for their debut album
  BODY COUNT <A HREF="#&">&</A> ICE-T for the Plate
<A HREF="#-">-</A> Barbara for her understanding, that gives me life without my
  computer =<A HREF="#:">:</A>^}

Have fun,
Byeeeeeeeeeeeeee, Chris
<HR SIZE=3><H2 ID="VDIBASE.TXT">VDIBASE.TXT</H2>
This information was provided by Ingo Schmidt (from a book)<A HREF="#.">.</A>

Starting address of a memory block which GEM installs to manage the <A HREF="#VDI">VDI</A>
parameters. This list isn't valid for the Mega-TOS or Blitter-TOS. GFA V3.0
gives confused values here. However, in the standard ROM-TOS the parameter
block for the virtual workstation is at address &H578C. That block also is 308
bytes long and has the same structure as <A HREF="#VDIBASE">VDIBASE</A><A HREF="#.">.</A> The VDIBASE is a copy of that
parameter block. So in V3.0 you can use the hardware address instead of
<A HREF="#VDIBASE">VDIBASE</A><A HREF="#.">.</A>

<B>Offset  Size  Description</B>
   0    word  current text rotation (0, 900, 1800, 2700)
   2    word  clipping flag (0=on, 1=off)
   4    long  address of current font header
   8    word  DDA_INC (<A HREF="#?">?</A>)
   10   word  multi-fill flag
   12   word  number of scan lines of current fill pattern
   14   long  start address of fill pattern
   18   word  points/absolute mode (<A HREF="#?">?</A>)
   20   long  SCRTCHP (buffer pointer, current boot sector <A HREF="#?">?</A>?)
   24   word  SCRPT2 (minus offset to <A HREF="#LPEEK">LPEEK</A>(<A HREF="#VDIBASE">VDIBASE</A>+20) <A HREF="#?">?</A>?)
              Gives the start of the eventually executable part of the boot
              sector <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> from <A HREF="#LPEEK">LPEEK</A>(<A HREF="#VDIBASE">VDIBASE</A>+20)-<A HREF="#DPEEK">DPEEK</A>(VDIBASE+24) these are the
              last 490 bytes of the boot sector <A HREF="#?">?</A>?
   26   word  current text style
   28   word  T_SCLSTS (=0 <A HREF="#?">?</A>?)
   30   word  current polygon fill color
   32   word  current fill pattern <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> <A HREF="#DEFFILL">DEFFILL</A> color,<A HREF="#DPEEK">DPEEK</A>(<A HREF="#VDIBASE">VDIBASE</A>+32)-1,style
   34   word  boundary flag
   36   word  current fill style
   38   word  current text alignment (0=left, 1=centered, 2=right)
   40   word  <A HREF="#VDI">VDI</A> handle of current workstation (<A HREF="#GFA-Basic">GFA-Basic</A>)
   42   word  current line start form
   44   word  current line color
   46   word  current line end form
   48   word  current line style
   50   word  current line width
   52   long  pointer to next <A HREF="#VDI">VDI</A><A HREF="#-">-</A>(GDOS) font
   56   word  current polymarker color
   58   word  current polymarker height
   60   word  current polymarker type
   62   word  relative polymarker height
   64   long  pointer to next virtual workstation parameter block
   68   word  number of available GEM/VDI fonts
   70   word  <A HREF="#index">index</A> of current GEM/VDI font
   72   byte  copy of current font header (88 bytes)
   160  word  <A HREF="#?">?</A>
   162  word  current text color
   164  word  current user line style
   166  word  plane 1 of user fill pattern [mono]  (16 words)
   198  word  plane 2 of user fill pattern [color] (16 words)
   230  word  plane 3 of user fill pattern [color] (16 words)
   262  word  plane 4 of user fill pattern [mono]  (16 words)
   294  word  current vertical text alignment
              0=baseline, 1=halfline, 2=ascentline,
              3=bottomline, 4=descentline, 5=topline
   296  word  current graphics mode <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> <A HREF="#GRAPHMODE">GRAPHMODE</A> <A HREF="#DPEEK">DPEEK</A>(<A HREF="#VDIBASE">VDIBASE</A>+296)-1
   298  word  current coordinate system
              Normalized Device Coordinates (NDC)=0
              Raster Coordinates (RC)=2 <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> standard
   300  word  x1, y1, x2, y2 of current clipping box (4 words)

This system variable should be avoided. This table is actually stored outside
the programs memory space. Messing around with this table can lead to
unpredictable results.
<HR SIZE=3><H2 ID="ATTRDEF.H">ATTRDEF.H</H2>
<A HREF="#/*">/*</A>
<A HREF="#*">*</A>******************************** attrdef.h ***********************************
<A HREF="#*">*</A>
<A HREF="#*">*</A> $Revision: 3.1 $      $Source: /u/lozben/projects/vdi/mtaskvdi/RCS/attrdef.h,v $
<A HREF="#*">*</A> <A HREF="#==">==</A><A HREF="#=">=</A>==========================================================================
<A HREF="#*">*</A> $Author: lozben $     $Date: 91/01/04 12:20:40 $     $Locker:  $
<A HREF="#*">*</A> <A HREF="#==">==</A><A HREF="#=">=</A>==========================================================================
<A HREF="#*">*</A>
<A HREF="#*">*</A> $Log: attrdef.h,v $
<A HREF="#*">*</A> Revision 3.1  91/01/04  12:20:40  lozben
<A HREF="#*">*</A> Typedefed structure atribute to ATTRIBUTE.
<A HREF="#*">*</A>
<A HREF="#*">*</A> Revision 3.0  91/01/03  15:05:57  lozben
<A HREF="#*">*</A> New generation <A HREF="#VDI">VDI</A>
<A HREF="#*">*</A>
<A HREF="#*">*</A> Revision 2.2  90/04/24  15:51:14  lozben
<A HREF="#*">*</A> Expanded the user defined pattern array from a 4x16 to an 8x16.
<A HREF="#*">*</A>
<A HREF="#*">*</A> Revision 2.1  89/02/21  17:28:19  kbad
<A HREF="#*">*</A> *** TOS 1.4  FINAL RELEASE VERSION ***
<A HREF="#*">*</A>
<A HREF="#*">*</A>******************************************************************************
*<A HREF="#/">/</A>

#ifndef _ATTRDEF_H_
#define _ATTRDEF_H_

<A HREF="#/*">/*</A> Structure to hold data for a virtual workstation *<A HREF="#/">/</A>
typedef struct attribute {
    <A HREF="#WORD">WORD</A> chup;                      <A HREF="#/*">/*</A> Character Up vector                  *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> clip;                      <A HREF="#/*">/*</A> Clipping Flag                        *<A HREF="#/">/</A>
    FONT_HEAD *cur_font;            <A HREF="#/*">/*</A> Pointer to current font              *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> dda_inc;                   <A HREF="#/*">/*</A> Fraction to be added to the DDA      *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> multifill;                 <A HREF="#/*">/*</A> Multi-plane fill flag                *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> patmsk;                    <A HREF="#/*">/*</A> Current pattern mask                 *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> *patptr;                   <A HREF="#/*">/*</A> Current pattern pointer              *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> pts_mode;                  <A HREF="#/*">/*</A> <A HREF="#TRUE">TRUE</A> if height set in points mode    *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> *scrtchp;                  <A HREF="#/*">/*</A> Pointer to text scratch buffer       *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> scrpt2;                    <A HREF="#/*">/*</A> Offset to large text buffer          *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> style;                     <A HREF="#/*">/*</A> Current text style                   *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> t_sclsts;                  <A HREF="#/*">/*</A> <A HREF="#TRUE">TRUE</A> if scaling up                   *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> fill_color;                <A HREF="#/*">/*</A> Current fill color (PEL value)       *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> fill_index;                <A HREF="#/*">/*</A> Current fill index                   *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> fill_per;                  <A HREF="#/*">/*</A> <A HREF="#TRUE">TRUE</A> if fill area outlined           *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> fill_style;                <A HREF="#/*">/*</A> Current fill style                   *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> h_align;                   <A HREF="#/*">/*</A> Current text horizontal alignment    *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> handle;                    <A HREF="#/*">/*</A> handle for attribute area            *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> line_beg;                  <A HREF="#/*">/*</A> Beginning line endstyle              *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> line_color;                <A HREF="#/*">/*</A> Current line color (PEL value)       *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> line_end;                  <A HREF="#/*">/*</A> Ending line endstyle                 *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> line_index;                <A HREF="#/*">/*</A> Current line style                   *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> line_width;                <A HREF="#/*">/*</A> Current line width                   *<A HREF="#/">/</A>
    FONT_HEAD *loaded_fonts;        <A HREF="#/*">/*</A> Pointer to first loaded font         *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> mark_color;                <A HREF="#/*">/*</A> Current marker color (PEL value)     *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> mark_height;               <A HREF="#/*">/*</A> Current marker height                *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> mark_index;                <A HREF="#/*">/*</A> Current marker style                 *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> mark_scale;                <A HREF="#/*">/*</A> Current scale factor for marker data *<A HREF="#/">/</A>
    struct attribute *next_work;    <A HREF="#/*">/*</A> Pointer to next virtual workstation  *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> num_fonts;                 <A HREF="#/*">/*</A> Total number of faces available      *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> scaled;                    <A HREF="#/*">/*</A> <A HREF="#TRUE">TRUE</A> if font scaled in any way       *<A HREF="#/">/</A>
    FONT_HEAD scratch_head;         <A HREF="#/*">/*</A> Holder for the doubled font data     *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> text_color;                <A HREF="#/*">/*</A> Current text color (PEL value)       *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> ud_ls;                     <A HREF="#/*">/*</A> User defined linestyle               *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> ud_patrn[32*16]<A HREF="#;">;</A>           <A HREF="#/*">/*</A> User defined pattern                 *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> v_align;                   <A HREF="#/*">/*</A> Current text vertical alignment      *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> wrt_mode;                  <A HREF="#/*">/*</A> Current writing mode                 *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> xfm_mode;                  <A HREF="#/*">/*</A> Transformation mode requested        *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> xmn_clip;                  <A HREF="#/*">/*</A> Low x point of clipping rectangle    *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> xmx_clip;                  <A HREF="#/*">/*</A> High x point of clipping rectangle   *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> ymn_clip;                  <A HREF="#/*">/*</A> Low y point of clipping rectangle    *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A> ymx_clip;                  <A HREF="#/*">/*</A> High y point of clipping rectangle   *<A HREF="#/">/</A>
} ATTRIBUTE;

#endif
<HR SIZE=3><H2 ID="BASEPAGE.H">BASEPAGE.H</H2>
<A HREF="#/*">/*</A>
 <A HREF="#*">*</A> $Id: basepage.h,v 1.4 2001/06/13 20:21:41 fna Exp $
 <A HREF="#*">*</A>
 <A HREF="#*">*</A> This file belongs to FreeMiNT.  It's not in the original MiNT 1.12
 <A HREF="#*">*</A> distribution.  See the file Changes.MH for a detailed log of changes.
 *<A HREF="#/">/</A>

<A HREF="#/*">/*</A>
 <A HREF="#*">*</A> Description: Definition of the basepage structure.
 *<A HREF="#/">/</A>

<A HREF="##">#</A> ifndef _mint_basepage_h
<A HREF="##">#</A> define _mint_basepage_h


typedef struct basepage <A HREF="#BASEPAGE">BASEPAGE</A><A HREF="#;">;</A>

struct basepage
{
        long            p_lowtpa;       <A HREF="#/*">/*</A> pointer to self (bottom of TPA) *<A HREF="#/">/</A>
        long            p_hitpa;        <A HREF="#/*">/*</A> pointer to top of TPA <A HREF="#+">+</A> 1 *<A HREF="#/">/</A>
        long            p_tbase;        <A HREF="#/*">/*</A> base of text segment *<A HREF="#/">/</A>
        long            p_tlen;         <A HREF="#/*">/*</A> length of text segment *<A HREF="#/">/</A>
        long            p_dbase;        <A HREF="#/*">/*</A> base of data segment *<A HREF="#/">/</A>
        long            p_dlen;         <A HREF="#/*">/*</A> length of data segment *<A HREF="#/">/</A>
        long            p_bbase;        <A HREF="#/*">/*</A> base of BSS segment *<A HREF="#/">/</A>
        long            p_blen;         <A HREF="#/*">/*</A> length of BSS segment *<A HREF="#/">/</A>
        char            *p_dta;         <A HREF="#/*">/*</A> pointer to current <A HREF="#DTA">DTA</A> *<A HREF="#/">/</A>
        <A HREF="#BASEPAGE">BASEPAGE</A>        *p_parent;      <A HREF="#/*">/*</A> pointer to parent's basepage *<A HREF="#/">/</A>
        long            p_flags;        <A HREF="#/*">/*</A> memory usage flags *<A HREF="#/">/</A>
        char            *p_env;         <A HREF="#/*">/*</A> pointer to environment string *<A HREF="#/">/</A>

        <A HREF="#/*">/*</A> Anything after this (except for p_cmdlin) is undocumented,
         <A HREF="#*">*</A> reserved, subject to change, etc. <A HREF="#-">-</A>- user programs must <A HREF="#NOT">NOT</A> use!
         *<A HREF="#/">/</A>
        char            p_devx[6]<A HREF="#;">;</A>      <A HREF="#/*">/*</A> real handles of the standard devices *<A HREF="#/">/</A>
        char            p_res2;         <A HREF="#/*">/*</A> reserved *<A HREF="#/">/</A>
        char            p_defdrv;       <A HREF="#/*">/*</A> default drv *<A HREF="#/">/</A>
        long            p_undef[17]<A HREF="#;">;</A>    <A HREF="#/*">/*</A> reserved space *<A HREF="#/">/</A>
        long            p_usp;          <A HREF="#/*">/*</A> a fake USP to make dLibs programs happy *<A HREF="#/">/</A>
        char            p_cmdlin[128]<A HREF="#;">;</A>  <A HREF="#/*">/*</A> command line image *<A HREF="#/">/</A>
}<A HREF="#;">;</A>


<A HREF="##">#</A> endif <A HREF="#/*">/*</A> _mint_basepage_h *<A HREF="#/">/</A>
<HR SIZE=3><H2 ID="ERRNO.H">ERRNO.H</H2>
<A HREF="#/*">/*</A>
 <A HREF="#*">*</A> $Id: errno.h,v 1.4 2001/06/13 20:21:42 fna Exp $
 <A HREF="#*">*</A>
 <A HREF="#*">*</A> mint/errno.h <A HREF="#-">-</A>- MiNTLib.
 <A HREF="#*">*</A> Copyright (C) 1999 Guido Flohr <A HREF="#&">&</A>#60;guido@freemint.de&#62;
 <A HREF="#*">*</A>
 <A HREF="#*">*</A> This file is part of the MiNTLib project, and may only be used
 <A HREF="#*">*</A> modified and distributed under the terms of the MiNTLib project
 <A HREF="#*">*</A> license, COPYMINT.  By continuing to use, modify, or distribute
 <A HREF="#*">*</A> this file you indicate that you have read the license and
 <A HREF="#*">*</A> understand and accept it fully.
 *<A HREF="#/">/</A>

#ifndef _MINT_ERRNO_H
<A HREF="##">#</A> define _MINT_ERRNO_H 1         <A HREF="#/*">/*</A> Allow multiple inclusion.  *<A HREF="#/">/</A>

#ifndef __KERNEL__

<A HREF="#/*">/*</A> for src integrity checking until all src is converted *<A HREF="#/">/</A>
#error no __KERNEL__

<A HREF="##">#</A> ifndef _FEATURES_H
<A HREF="##">#</A>  include <A HREF="#&">&</A>#60;features.h&#62;
<A HREF="##">#</A> endif

__BEGIN_DECLS

<A HREF="#/*">/*</A> See below.  *<A HREF="#/">/</A>
#define __KERNEL_NEG(c) c

#else <A HREF="#/*">/*</A> __KERNEL__ *<A HREF="#/">/</A>
  <A HREF="#/*">/*</A> The kernel should actually have code like

        if (whew_we_dont_know_that)
          return -ENOSYS;

     instead of the current

        if (whew_we_dont_know_that)
          return ENOSYS;

     That seems to be a matter of taste.

     As a convenience we offer both possibilities here:
  *<A HREF="#/">/</A>

<A HREF="##">#</A> ifdef POSITIVE_ERROR_CODES
<A HREF="##">#</A>  define __KERNEL_NEG(c) (c)
<A HREF="##">#</A> else  <A HREF="#/*">/*</A> not POSITIVE_ERROR_CODES *<A HREF="#/">/</A>
<A HREF="##">#</A>  define __KERNEL_NEG(c) (<A HREF="#-">-</A>(c))
<A HREF="##">#</A> endif <A HREF="#/*">/*</A> not POSITIVE_ERROR_CODES *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> If you prefer to type E_OK instead of 0 <A HREF="#.">.</A>..  *<A HREF="#/">/</A>
<A HREF="##">#</A> define E_OK 0

#endif <A HREF="#/*">/*</A> not __KERNEL__ *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> The original atarierr.h defined quite a few error codes which were
   either useless or non-standard.  Important codes such as EISDIR,
   ENOTEMPTY were missing, others were simply misunderstood (for example
   the usual EINVAL would really be an ENOSYS, EINVAL is not invalid
   function number but invalid argument) and especially in MiNT
   some error codes got really overloaded, for example ENOENT serves
   as ENOENT, ESRCH and ECHILD, or EACCES and EPERM were the same.

   The codes in this file try to find the closest equivalent for
   all error codes currently in use, marks some error codes as
   deprecated and tries to be fit for the future by defining all
   error codes that may be needed for future enhancement.
*<A HREF="#/">/</A>

<A HREF="#/*">/*</A>
   The explanations are mostly taken from the GNU libc manual.
   Unfortunately they don't always document the current usage in the
   MiNT system but rather how it should be.  I've marked all current
   misusage with either `KERNEL' or `FIXME'<A HREF="#.">.</A>

   We provide way too many synonyms for error codes here.  Both in
   the kernel and the libc only the `official' name (the one in the
   top row that bears the actual define) should be used.
*<A HREF="#/">/</A>

<A HREF="#/*">/*</A> Where is ENOERR and E_OK?  This file is <A HREF="#&">&</A>#60;errno.h&#62; and not &#60;noerror.h&#62;,
   no error is 0, basta.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> Is this really needed?  Deprecated.  *<A HREF="#/">/</A>
#define EERROR          __KERNEL_NEG(1)         <A HREF="#/*">/*</A> Generic error.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> A system resource that can't be shared is already in use.  For example
   if you try to delete a file that is the root of a currently mounted
   filesystem, you get this error.
   This used to be EDRNRDY resp. EDRNRDY.  *<A HREF="#/">/</A>
#define EBUSY           __KERNEL_NEG(2)         <A HREF="#/*">/*</A> Resource busy.  *<A HREF="#/">/</A>
#ifdef __LOOSE_ERRROR_CODES
<A HREF="##">#</A> define EDRNRDY        EBUSY
<A HREF="##">#</A> define EDRVNR         EBUSY
#endif

<A HREF="#/*">/*</A> Deprecated.  *<A HREF="#/">/</A>
#define EUKCMD          __KERNEL_NEG(3)         <A HREF="#/*">/*</A> Unknown command.  *<A HREF="#/">/</A>
#ifdef __LOOSE_ERRROR_CODES
<A HREF="##">#</A> define EUNCMD         EUKCMD
#endif

<A HREF="#/*">/*</A> Checksum error detected while reading from a block device such as
   a floppy drive.  Obviously non-standard but often used.  *<A HREF="#/">/</A>
#define ECRC            __KERNEL_NEG(4)         <A HREF="#/*">/*</A> CRC error.  *<A HREF="#/">/</A>
#ifdef __LOOSE_ERRROR_CODES
<A HREF="##">#</A> define E_CRC          ECRC
#endif

<A HREF="#/*">/*</A> Bad request.  *<A HREF="#/">/</A>
#define EBADR           __KERNEL_NEG(5)         <A HREF="#/*">/*</A> Bad request.  *<A HREF="#/">/</A>
#ifdef __LOOSE_ERRROR_CODES
<A HREF="##">#</A> define EBADREQ        EBADR
<A HREF="##">#</A> define EBADRQ         EBADR
#endif

<A HREF="#/*">/*</A> Invalid seek operation (such as on a pipe)<A HREF="#.">.</A>  *<A HREF="#/">/</A>
<A HREF="#/*">/*</A> KERNEL: The pipe file system currently returns 0 for seek on a pipe!  *<A HREF="#/">/</A>
#define ESPIPE          __KERNEL_NEG(6)         <A HREF="#/*">/*</A> Illegal seek.  *<A HREF="#/">/</A>
#ifdef __LOOSE_ERRROR_CODES
<A HREF="##">#</A> define ESEEK          ESPIPE
<A HREF="##">#</A> define E_SEEK         ESPIPE
#endif

<A HREF="#/*">/*</A> Wrong medium type.  *<A HREF="#/">/</A>
#define EMEDIUMTYPE     __KERNEL_NEG(7)         <A HREF="#/*">/*</A> Wrong medium type.  *<A HREF="#/">/</A>
#ifdef __LOOSE_ERRROR_CODES
<A HREF="##">#</A> define EUKMEDIA       EMEDIUMTYPE
<A HREF="##">#</A> define EMEDIA         EMEDIUMTYPE
#endif

<A HREF="#/*">/*</A> A sector that does not exist was addressed in the call to a bock
   device function.  *<A HREF="#/">/</A>
#define ESECTOR         __KERNEL_NEG(8)         <A HREF="#/*">/*</A> Sector not found.  *<A HREF="#/">/</A>
#ifdef __LOOSE_ERRROR_CODES
<A HREF="##">#</A> define ESECNF         ESECTOR
#endif

<A HREF="#/*">/*</A> No paper.  No, not at the conveniences, in the printer.  *<A HREF="#/">/</A>
#define EPAPER          __KERNEL_NEG(9)         <A HREF="#/*">/*</A> No paper.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> Read and write faults.  Deprecated, be more specific instead.  *<A HREF="#/">/</A>
#define EWRITE          __KERNEL_NEG(10)                <A HREF="#/*">/*</A> Write fault.  *<A HREF="#/">/</A>
#ifdef __LOOSE_ERRROR_CODES
<A HREF="##">#</A> define EWRITEF        EWRITE
#endif
#define EREAD           __KERNEL_NEG(11)                <A HREF="#/*">/*</A> Read fault. *<A HREF="#/">/</A>
#ifdef __LOOSE_ERRROR_CODES
<A HREF="##">#</A> define EREADF         EREAD
#endif

<A HREF="#/*">/*</A> Another generic error.  Who can tell the difference to EERROR?  *<A HREF="#/">/</A>
#define EGENERIC        __KERNEL_NEG(12)                <A HREF="#/*">/*</A> General mishap.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> An attempt was made to modify something on a read-only file
   file system.  *<A HREF="#/">/</A>
#define EROFS           __KERNEL_NEG(13)                <A HREF="#/*">/*</A> Write protect.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> A removable medium was exchanged before the operation could finish.  *<A HREF="#/">/</A>
#define ECHMEDIA        __KERNEL_NEG(14)                <A HREF="#/*">/*</A> Media change.  *<A HREF="#/">/</A>
#ifdef __LOOSE_ERRROR_CODES
<A HREF="##">#</A> define E_CHNG         ECHMEDIA
#endif

<A HREF="#/*">/*</A> The wrong type of device was given to a function that expects a
   particular sort of device.  *<A HREF="#/">/</A>
#define ENODEV          __KERNEL_NEG(15)                <A HREF="#/*">/*</A> No such device.  *<A HREF="#/">/</A>
#ifdef __LOOSE_ERRROR_CODES
<A HREF="##">#</A> define EUKDEV         ENODEV
<A HREF="##">#</A> define EUNDEV         ENODEV
#endif

<A HREF="#/*">/*</A> Bad sectors on block device medium found.  Uhm, if the driver found
   them, mark them as bad and don't bother the user with that.
   Deprecated.  *<A HREF="#/">/</A>
#define EBADSEC         __KERNEL_NEG(16)                <A HREF="#/*">/*</A> Bad sectors found.  *<A HREF="#/">/</A>
#ifdef __LOOSE_ERRROR_CODES
<A HREF="##">#</A> define EBADSF         EBADSEC
#endif

<A HREF="#/*">/*</A> A device with a removable media (such as a floppy) is empty.  *<A HREF="#/">/</A>
#define ENOMEDIUM       __KERNEL_NEG(17)                <A HREF="#/*">/*</A> No medium found.  *<A HREF="#/">/</A>
#ifdef __LOOSE_ERRROR_CODES
<A HREF="##">#</A> define EIDISK         ENOMEDIUM
<A HREF="##">#</A> define EOTHER         ENOMEDIUM
#endif

<A HREF="#/*">/*</A> MetaDOS error (deprecated)<A HREF="#.">.</A>  *<A HREF="#/">/</A>
#define EINSERT         __KERNEL_NEG(18)                <A HREF="#/*">/*</A> Insert media.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> MetaDOS error (deprecated)<A HREF="#.">.</A>  *<A HREF="#/">/</A>
#define EDRVNRSP        __KERNEL_NEG(19)                <A HREF="#/*">/*</A> Drive not responding.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> No process matches the specified process ID.

   KERNEL: This is a new error code.  Currently ENOENT is returned instead.  *<A HREF="#/">/</A>
#define ESRCH           __KERNEL_NEG(20)                <A HREF="#/*">/*</A> No such process.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> There are no child processes.  This error happens on operations
   that are supposed to manipulate child processes, when there aren't
   any processes to manipulate.

   KERNEL: This is a new error code.  Currently ENOENT is returned instead.  *<A HREF="#/">/</A>
#define ECHILD          __KERNEL_NEG(21)                <A HREF="#/*">/*</A> No child processes.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> Deadlock avoided; allocating a system resource would have resulted
   in a deadlock situation.  The system does not guarantee that it
   will notice all such situations.  This error means you got lucky
   and the system noticed; it might just hang.

   KERNEL: This is a new error code.  The kernel currently never returns
   it.  But that doesn't mean that there are no deadlock situations in
   the kernel.  *<A HREF="#/">/</A>
#define EDEADLK         __KERNEL_NEG(22)                <A HREF="#/*">/*</A> Resource deadlock would occur.  *<A HREF="#/">/</A>
#define EDEADLOCK       EDEADLK

<A HREF="#/*">/*</A> A file that isn't a block special file was given in a situation
   that requires one.  For example, trying to mount an ordinary file
   as a file system in Unix gives this error.  New code.  *<A HREF="#/">/</A>
#define ENOTBLK         __KERNEL_NEG(23)                <A HREF="#/*">/*</A> Block device required.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> File is a directory; you cannot open a directory for writing, or
   create or remove hard links to it.

   KERNEL: This is a new error code.  Flink() should be fixed.  *<A HREF="#/">/</A>
#define EISDIR          __KERNEL_NEG(24)        <A HREF="#/*">/*</A> Is a directory.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> Invalid argument.  This is used to indicate various kinds of
   problems with passing the wrong argument to a library function.

   FIXME: This used to be the same as `ENOSYS'<A HREF="#.">.</A>  In fact that should
   be two distinct error codes.  For example, the `fchmod' function
   should return `EINVAL' if the file <A HREF="#descriptor">descriptor</A> passed as an
   argument corresponds to a pipe or socket, not an ordinary file.
   But since `fchmod' is a function that is currently only supported
   under MiNT the same error would be reported if the operating
   system does not support the call at all.  It is common practice
   to cache such failures because in the case of `ENOSYS' there
   is no chance that succeeding calls will proceed.  So how do
   you want to distinguish between these cases?  *<A HREF="#/">/</A>
#define EINVAL          __KERNEL_NEG(25)                <A HREF="#/*">/*</A> Invalid argument.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> Inappropriate file type or format.  The file was the wrong type
   for the operation, or a data file had the wrong format.

   On some systems `chmod' returns this error if you try to set the
   sticky bit on a non-directory file.  *<A HREF="#/">/</A>
#define EFTYPE          __KERNEL_NEG(26)                <A HREF="#/*">/*</A> Inappropriate file type or format.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> While decoding a multibyte character the function came along an
   invalid or an incomplete sequence of bytes or the given wide
   character is invalid.  *<A HREF="#/">/</A>
#define EILSEQ          __KERNEL_NEG(27)                <A HREF="#/*">/*</A> Illegal byte sequence.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> Function not implemented.  Some functions have commands or options
   defined that might not be supported in all implementations, and
   this is the kind of error you get if your request them and they are
   not supported.

   KERNEL: This was usually called EINVFN (invalid function number) and
   that's why it was probably mixed up with EINVAL (invalid argument)<A HREF="#.">.</A>

   FIXME: Grep thru the MiNTLib sources for EINVAL and replace it with
   the correct ENOSYS.  Same for the kernel.  *<A HREF="#/">/</A>
#define ENOSYS          __KERNEL_NEG(32)                <A HREF="#/*">/*</A> Function not implemented.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> This is a "file doesn't exist" error for ordinary files that are
   referenced in contexts where they are expected to already exist.

   KERNEL/FIXME: This used to be the same as ESRCH and and ECHILD,
   in the kernel it was usually called EFILNF.  Fix the wrong usage
   of ESRCH and ECHILD and replace EFILNF with ENOENT.  *<A HREF="#/">/</A>
#define ENOENT          __KERNEL_NEG(33)                <A HREF="#/*">/*</A> No such file or directory.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> A file that isn't a directory was specified when a directory is
   required.  The usage of the synonyme EPATH is deprecated!  *<A HREF="#/">/</A>
#define ENOTDIR         __KERNEL_NEG(34)                <A HREF="#/*">/*</A> Not a directory.  *<A HREF="#/">/</A>
#ifdef __LOOSE_ERRROR_CODES
<A HREF="##">#</A> define EPATH          ENOTDIR
#endif

<A HREF="#/*">/*</A> The current process has too many files open and can't open any
   more.  Duplicate descriptors do count toward this limit.

   In BSD and GNU, the number of open files is controlled by a
   resource limit that can usually be increased.  If you get this
   error, you might want to increase the `RLIMIT_NOFILE' limit
   or make it unlimited.

   Under MiNT we currently have to live without such luxury.  *<A HREF="#/">/</A>
#define EMFILE          __KERNEL_NEG(35)                <A HREF="#/*">/*</A> Too many open files.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> Permission denied; the file permissions do not allow the
   attempted operation.

   KERNEL: This used to be mixed up with EPERM (operation not permitted)<A HREF="#.">.</A>  *<A HREF="#/">/</A>
#define EACCES          __KERNEL_NEG(36)                <A HREF="#/*">/*</A> Permission denied.  *<A HREF="#/">/</A>
#ifdef __LOOSE_ERRROR_CODES
<A HREF="##">#</A> define EACCESS                EACCES
#endif

<A HREF="#/*">/*</A> Bad file <A HREF="#descriptor">descriptor</A><A HREF="#;">;</A> for example, I/O on a descriptor that has been
   closed or reading from a <A HREF="#descriptor">descriptor</A> open only for writing (or vice
   versa)<A HREF="#.">.</A>  *<A HREF="#/">/</A>
#define EBADF           __KERNEL_NEG(37)                <A HREF="#/*">/*</A> Bad file <A HREF="#descriptor">descriptor</A><A HREF="#.">.</A>  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> Operation not permitted; only the owner of the file (or other
   resource) or processes with special privileges can perform the
   operation.

   This is a new error code (used to be a synonyme for EACCES)<A HREF="#.">.</A>  As
   a general rule you can say, whenever you want to disallow something
   take EACCES.  Only if you positively know that EPERM should be
   used, then take this one.

   FIXME: Some kernel functions should return EPERM, for example
   Tsettimeofday, Tsetdate, Tsettime, Setdate <A HREF="#.">.</A>.. *<A HREF="#/">/</A>
#define EPERM           __KERNEL_NEG(38)                <A HREF="#/*">/*</A> Operation not permitted.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> No memory available.  The system cannot allocate more virtual
   memory because its capacity is full.  *<A HREF="#/">/</A>
#define ENOMEM          __KERNEL_NEG(39)                <A HREF="#/*">/*</A> Cannot allocate memory.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> Bad address; an invalid pointer was detected.  In the GNU system,
   this error never happens; you get a signal instead.  In the MiNT
   system this error often happens, and you get angry mails and flames
   on the usenet.  *<A HREF="#/">/</A>
#define EFAULT          __KERNEL_NEG(40)                <A HREF="#/*">/*</A> Bad address.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> No such device or address.  The system tried to use the device
   represented by a file you specified, and it couldn't find the
   device.  This can mean that the device file was installed
   incorrectly, or that the physical device is missing or not
   correctly attached to the computer.

   Under MiNT this can also happen if a pathname starts with a
   drive letter followed by a colon (e. g. `x:/dont/exist').  This
   was called `invalid drive specification' or `invalid drive id'<A HREF="#.">.</A>  *<A HREF="#/">/</A>
#define ENXIO           __KERNEL_NEG(46)                <A HREF="#/*">/*</A> No such device or address.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> An attempt to make an improper link across file systems was
   detected.  This happens not only when you use `link' (for
   hard links) but also when you rename a file with `rename'<A HREF="#.">.</A>  *<A HREF="#/">/</A>
#define EXDEV           __KERNEL_NEG(48)                <A HREF="#/*">/*</A> Cross-device link.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> No more matching file names, only used by Fsnext(2)<A HREF="#.">.</A>  Don't mix
   that up with ENFILE.  *<A HREF="#/">/</A>
#define ENMFILES        __KERNEL_NEG(49)                <A HREF="#/*">/*</A> No more matching file names.  *<A HREF="#/">/</A>
#ifdef __LOOSE_ERRROR_CODES
<A HREF="##">#</A> define ENMFIL         ENMFILES
#endif

<A HREF="#/*">/*</A> There are too many distinct file openings in the entire system.
   Note that any number of linked channels count as just one file
   opening.  This error never occurs in the GNU system, and it probably
   never occurs in the MiNT system, too.  *<A HREF="#/">/</A>
#define ENFILE          __KERNEL_NEG(50)                <A HREF="#/*">/*</A> File table overflow.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> Locking conflict.  Deprecated.

   KERNEL: If the LOCK_NB flag was selected EWOULDBLOCK should be used
   instead.  Otherwise the process should be blocked until the lock
   is available?  *<A HREF="#/">/</A>
#define ELOCKED         __KERNEL_NEG(58)                <A HREF="#/*">/*</A> Locking conflict.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> Deprecated, should only happen with Dlock()<A HREF="#.">.</A>  *<A HREF="#/">/</A>
#define ENSLOCK         __KERNEL_NEG(59)                <A HREF="#/*">/*</A> No such lock.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> Bad argument, used to be `range error/context unknown'<A HREF="#.">.</A>  Deprecated.  */
#define EBADARG         __KERNEL_NEG(64)                <A HREF="#/*">/*</A> Bad argument.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> Another spurious error, deprecated.  *<A HREF="#/">/</A>
#define EINTERNAL       __KERNEL_NEG(65)                <A HREF="#/*">/*</A> Internal error.  *<A HREF="#/">/</A>
#ifdef __LOOSE_ERRROR_CODES
<A HREF="##">#</A> define EINTRN         EINTERNAL
#endif

<A HREF="#/*">/*</A> Invalid executable file format.  This condition is detected by the
   `exec' functions.  *<A HREF="#/">/</A>
#define ENOEXEC         __KERNEL_NEG(66)                <A HREF="#/*">/*</A> Invalid executable file format.  *<A HREF="#/">/</A>
#ifdef __LOOSE_ERRROR_CODES
<A HREF="##">#</A> define EPLFMT         ENOEXEC
#endif

<A HREF="#/*">/*</A> Can't grow block, deprecated.  At least within the library this should
   be handled with ENOMEM.  *<A HREF="#/">/</A>
#define ESBLOCK         __KERNEL_NEG(67)                <A HREF="#/*">/*</A> Memory block growth failure.  *<A HREF="#/">/</A>
#ifdef __LOOSE_ERRROR_CODES
<A HREF="##">#</A> define EGSBF          ESBLOCK
#endif

<A HREF="#/*">/*</A> Terminated with CTRL-C (Kaos, MagiC, BigDOS)<A HREF="#.">.</A>  Nonsense.  *<A HREF="#/">/</A>
#define EBREAK          __KERNEL_NEG(68)                <A HREF="#/*">/*</A> Aborted by user.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> This looks like a joke but it isn't.  Who has introduced that
   in the kernel?  *<A HREF="#/">/</A>
#define EXCPT           __KERNEL_NEG(69)                <A HREF="#/*">/*</A> Terminated with bombs.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> An attempt to execute a file that is currently open for writing, or
   write to a file that is currently being executed.  Often using a
   debugger to run a program is considered having it open for writing
   and will cause this error.  (The name stands for "text file
   busys"<A HREF="#.">.</A>)  This is not an error in the GNU system; the text is
   copied as necessary.  In the MiNT system this error currently cannot
   occur.  *<A HREF="#/">/</A>
#define ETXTBSY         __KERNEL_NEG(70)                <A HREF="#/*">/*</A> Text file busy.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> File too big; the size of a file would be larger than allowed by
   the system.

   KERNEL: This is a new code.  If this error condition can occur,
   then the correct code should be returned.  *<A HREF="#/">/</A>
#define EFBIG           __KERNEL_NEG(71)                <A HREF="#/*">/*</A> File too big.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> Too many levels of symbolic links were encountered in looking up a
   file name.  This often indicates a cycle of symbolic links.

   KERNEL: There was no difference between EMLINK (too many links and
   ELOOP (too many symbolic links)<A HREF="#.">.</A>  The more common meaning of this
   error code is preserved, but whenenver EMLINK should be used, this
   has to be fixed in the kernel.  *<A HREF="#/">/</A>
#define ELOOP           __KERNEL_NEG(80)                <A HREF="#/*">/*</A> Too many symbolic links.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> Broken pipe; there is no process reading from the other end of a
   pipe.  Every function that returns this error code also generates
   a `SIGPIPE' signal; this signal terminates the program if not
   handled or blocked.  Thus, your program will never actually see
   `EPIPE' unless it has handled or blocked `SIGPIPE'<A HREF="#.">.</A>  *<A HREF="#/">/</A>
#define EPIPE           __KERNEL_NEG(81)                <A HREF="#/*">/*</A> Broken pipe.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> Too many links; the link count of a single file would become too
   large.  `rename' can cause this error if the file being renamed
   already has as many links as it can take.

   KERNEL: This is a new error code.  See the note for ELOOP.  *<A HREF="#/">/</A>
#define EMLINK          __KERNEL_NEG(82)                <A HREF="#/*">/*</A> Too many links.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> Directory not empty, where an empty directory was expected.  Typically
   this error occurs when you are trying to delete a directory.

   KERNEL: New error code, for the case of non-empty directories
   EEXIST was returned.  The new behavior could cause compatibility
   problems since inproper implementations of recursive rm commands
   could rely on the old error code (85) being returned.

   Which error is more probable?  *<A HREF="#/">/</A>
#define ENOTEMPTY       __KERNEL_NEG(83)                <A HREF="#/*">/*</A> Directory not empty.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> File exists; an existing file was specified in a context where it
   only makes sense to specify a new file.  *<A HREF="#/">/</A>
#define EEXIST          __KERNEL_NEG(85)                <A HREF="#/*">/*</A> File exists.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> Filename too long (longer than `PATH_MAX') or host name too long
   (in `gethostname' or `sethostname')<A HREF="#.">.</A>  *<A HREF="#/">/</A>
#define ENAMETOOLONG    __KERNEL_NEG(86)                <A HREF="#/*">/*</A> Name too long.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> Inappropriate I/O control operation, such as trying to set terminal
   modes on ordinary files.  *<A HREF="#/">/</A>
#define ENOTTY          __KERNEL_NEG(87)                <A HREF="#/*">/*</A> Not a tty.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> Range error; used by mathematical functions when the result value
   is not representable because of overflow or underflow.

   The string to number conversion functions (`strtol', `strtoul',
   `strtod', etc. can also return this error.  *<A HREF="#/">/</A>
#define ERANGE          __KERNEL_NEG(88)                <A HREF="#/*">/*</A> Range error.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> Domain error; used by mathematical functions when an argument
   value does not fall into the domain over which the function is
   defined.  *<A HREF="#/">/</A>
#define EDOM            __KERNEL_NEG(89)                <A HREF="#/*">/*</A> Domain error.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> Input/output error; usually used for physical read or write errors.  */
#define EIO             __KERNEL_NEG(90)                <A HREF="#/*">/*</A> I/O error */

<A HREF="#/*">/*</A> No space left on device; write operation on a file failed because
   the disk is full.  *<A HREF="#/">/</A>
#define ENOSPC          __KERNEL_NEG(91)                <A HREF="#/*">/*</A> No space left on device.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> Error number 92-99 reserved for TraPatch.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> This means that the per-user limit on new process would be
   exceeded by an attempted `fork'<A HREF="#.">.</A>  *<A HREF="#/">/</A>
#define EPROCLIM        __KERNEL_NEG(100)               <A HREF="#/*">/*</A> Too many processes for user.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> This file quota system is confused because there are too many users.  *<A HREF="#/">/</A>
#define EUSERS          __KERNEL_NEG(101)               <A HREF="#/*">/*</A> Too many users.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> The user's disk quota was exceeded.  *<A HREF="#/">/</A>
#define EDQUOT          __KERNEL_NEG(102)               <A HREF="#/*">/*</A> Quota exceeded.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> Stale NFS handle.  This indicates an internal confusion in
   the NFS system which is due to file system rearrangements on the
   server host.  Reparing this condition usually requires unmounting
   and remounting the NFS file system on the local host.  *<A HREF="#/">/</A>
#define ESTALE          __KERNEL_NEG(103)               <A HREF="#/*">/*</A> Stale NFS file handle.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> An attempt was made to NFS-mount a remote file system with a file
   name that already specifies an NFS-mounted file.  (This is an
   error on some operating systems, but we expect it to work properly
   on the GNU system, making this error code impossible)<A HREF="#.">.</A>  *<A HREF="#/">/</A>
#define EREMOTE         __KERNEL_NEG(104)               <A HREF="#/*">/*</A> Object is remote.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> <A HREF="#?">?</A>?? *<A HREF="#/">/</A>
#define EBADRPC         __KERNEL_NEG(105)       <A HREF="#/*">/*</A> RPC struct is bad.  *<A HREF="#/">/</A>
#define ERPCMISMATCH    __KERNEL_NEG(106)       <A HREF="#/*">/*</A> RPC version wrong.  *<A HREF="#/">/</A>
#define EPROGUNAVAIL    __KERNEL_NEG(107)       <A HREF="#/*">/*</A> RPC program not available.  *<A HREF="#/">/</A>
#define EPROGMISMATCH   __KERNEL_NEG(108)       <A HREF="#/*">/*</A> RPC program version wrong.  *<A HREF="#/">/</A>
#define EPROCUNAVAIL    __KERNEL_NEG(109)       <A HREF="#/*">/*</A> RPC bad procedure for program.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> No locks available.  This is used by the file locking facilities;
   This error is never generated by the GNU system, but it can result
   from an operation to an NFS server running another operating system.  *<A HREF="#/">/</A>
#define ENOLCK          __KERNEL_NEG(110)       <A HREF="#/*">/*</A> No locks available.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> <A HREF="#?">?</A>?? *<A HREF="#/">/</A>
#define EAUTH           __KERNEL_NEG(111)       <A HREF="#/*">/*</A> Authentication error.  *<A HREF="#/">/</A>
#define ENEEDAUTH       __KERNEL_NEG(112)       <A HREF="#/*">/*</A> Need authenticator.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> In the GNU system, servers supporting the `term' protocol return
   this error for certain operations when the caller is not in the
   foreground process group of the terminal.  Users do not usually
   see this error because functions such as `read' and `write'
   translate it into a `SIGTTIN' or `SIGTTOU' signal.  *<A HREF="#/">/</A>
#define EBACKGROUND     __KERNEL_NEG(113)               <A HREF="#/*">/*</A> Inappropriate operation for background process.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> <A HREF="#?">?</A>?? *<A HREF="#/">/</A>
#define EBADMSG         __KERNEL_NEG(114)               <A HREF="#/*">/*</A> Not a data message.  *<A HREF="#/">/</A>
#define EIDRM           __KERNEL_NEG(115)               <A HREF="#/*">/*</A> Identifier removed.  *<A HREF="#/">/</A>
#define EMULTIHOP       __KERNEL_NEG(116)               <A HREF="#/*">/*</A> Multihop attempted.  *<A HREF="#/">/</A>
#define ENODATA         __KERNEL_NEG(117)               <A HREF="#/*">/*</A> No data available.  *<A HREF="#/">/</A>
#define ENOLINK         __KERNEL_NEG(118)               <A HREF="#/*">/*</A> Link has been severed.  *<A HREF="#/">/</A>
#define ENOMSG          __KERNEL_NEG(119)               <A HREF="#/*">/*</A> No message of desired type.  *<A HREF="#/">/</A>
#define ENOSR           __KERNEL_NEG(120)               <A HREF="#/*">/*</A> Out of streams resources.  *<A HREF="#/">/</A>
#define ENOSTR          __KERNEL_NEG(121)               <A HREF="#/*">/*</A> Device not a stream.  *<A HREF="#/">/</A>
#define EOVERFLOW       __KERNEL_NEG(122)               <A HREF="#/*">/*</A> Value too large for defined data type.  *<A HREF="#/">/</A>
#define EPROTO          __KERNEL_NEG(123)               <A HREF="#/*">/*</A> Protocol error.  *<A HREF="#/">/</A>
#define ETIME           __KERNEL_NEG(124)               <A HREF="#/*">/*</A> Timer expired.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> Argument list too long; used when the arguments passed to a new
   program being executed with one of the `exec' functions occupy
   too much memory space.  This condition never arises in the
   MiNT system.  *<A HREF="#/">/</A>
#define E2BIG           __KERNEL_NEG(125)               <A HREF="#/*">/*</A> Argument list too long.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> The following error codes are defined by the Linux/i386 kernel.
   Some of them are probably useful for MiNT, too.  *<A HREF="#/">/</A>
#define ERESTART        __KERNEL_NEG(126)               <A HREF="#/*">/*</A> Interrupted system call should be
                                           restarted.  *<A HREF="#/">/</A>
#define ECHRNG          __KERNEL_NEG(127)               <A HREF="#/*">/*</A> Channel number out of range.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> Interrupted function call; an asynchronous signal occured and
   prevented completion of the call.  When this happens, you should
   try the call again.

   On other systems you can choose to have functions resume after a
   signal handled, rather than failing with `EINTR'<A HREF="#.">.</A>  *<A HREF="#/">/</A>
#define EINTR           __KERNEL_NEG(128)               <A HREF="#/*">/*</A> Interrupted function call.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> Falcon <A HREF="#XBIOS">XBIOS</A> errors.  *<A HREF="#/">/</A>
#define ESNDLOCKED      __KERNEL_NEG(129)               <A HREF="#/*">/*</A> Sound system is already locked.  *<A HREF="#/">/</A>
#define ESNDNOTLOCK     __KERNEL_NEG(130)               <A HREF="#/*">/*</A> Sound system is not locked.  *<A HREF="#/">/</A>

#define EL2NSYNC        __KERNEL_NEG(131)               <A HREF="#/*">/*</A> Level 2 not synchronized.  *<A HREF="#/">/</A>
#define EL3HLT          __KERNEL_NEG(132)               <A HREF="#/*">/*</A> Level 3 halted.  *<A HREF="#/">/</A>
#define EL3RST          __KERNEL_NEG(133)               <A HREF="#/*">/*</A> Level 3 reset.  *<A HREF="#/">/</A>
#define ELNRNG          __KERNEL_NEG(134)               <A HREF="#/*">/*</A> Link number out of range.  *<A HREF="#/">/</A>
#define EUNATCH         __KERNEL_NEG(135)               <A HREF="#/*">/*</A> Protocol driver not attached.  *<A HREF="#/">/</A>
#define ENOCSI          __KERNEL_NEG(136)               <A HREF="#/*">/*</A> No CSI structure available.  *<A HREF="#/">/</A>
#define EL2HLT          __KERNEL_NEG(137)               <A HREF="#/*">/*</A> Level 2 halted.  *<A HREF="#/">/</A>
#define EBADE           __KERNEL_NEG(138)               <A HREF="#/*">/*</A> Invalid exchange.  *<A HREF="#/">/</A>
#define EXFULL          __KERNEL_NEG(139)               <A HREF="#/*">/*</A> Exchange full.  *<A HREF="#/">/</A>
#define ENOANO          __KERNEL_NEG(140)               <A HREF="#/*">/*</A> No anode.  *<A HREF="#/">/</A>
#define EBADRQC         __KERNEL_NEG(141)               <A HREF="#/*">/*</A> Invalid request code.  *<A HREF="#/">/</A>
#define EBADSLT         __KERNEL_NEG(142)               <A HREF="#/*">/*</A> Invalid slot.  *<A HREF="#/">/</A>
#define EBFONT          __KERNEL_NEG(143)               <A HREF="#/*">/*</A> Bad font file format.  *<A HREF="#/">/</A>
#define ENONET          __KERNEL_NEG(144)               <A HREF="#/*">/*</A> Machine is not on the network.  *<A HREF="#/">/</A>
#define ENOPKG          __KERNEL_NEG(145)               <A HREF="#/*">/*</A> Package is not installed.  *<A HREF="#/">/</A>
#define EADV            __KERNEL_NEG(146)               <A HREF="#/*">/*</A> Advertise error.  *<A HREF="#/">/</A>
#define ESRMNT          __KERNEL_NEG(147)               <A HREF="#/*">/*</A> Srmount error.  *<A HREF="#/">/</A>
#define ECOMM           __KERNEL_NEG(148)               <A HREF="#/*">/*</A> Communication error on send.  *<A HREF="#/">/</A>
#define EDOTDOT         __KERNEL_NEG(149)               <A HREF="#/*">/*</A> RFS specific error.  *<A HREF="#/">/</A>
#define ELIBACC         __KERNEL_NEG(150)               <A HREF="#/*">/*</A> Cannot access a needed shared library. *<A HREF="#/">/</A>
#define ELIBBAD         __KERNEL_NEG(151)               <A HREF="#/*">/*</A> Accessing a corrupted shared library.  *<A HREF="#/">/</A>
#define ELIBSCN         __KERNEL_NEG(152)               <A HREF="#/*">/*</A> .lib section in a.out corrupted.  *<A HREF="#/">/</A>
#define ELIBMAX         __KERNEL_NEG(153)               <A HREF="#/*">/*</A> Attempting to link too many shared
                                                           libraries.  *<A HREF="#/">/</A>
#define ELIBEXEC        __KERNEL_NEG(154)               <A HREF="#/*">/*</A> Cannot exec a shared library directly. *<A HREF="#/">/</A>
#define ESTRPIPE        __KERNEL_NEG(155)               <A HREF="#/*">/*</A> Streams pipe error.  *<A HREF="#/">/</A>
#define EUCLEAN         __KERNEL_NEG(156)               <A HREF="#/*">/*</A> Structure needs cleaning.  *<A HREF="#/">/</A>
#define ENOTNAM         __KERNEL_NEG(157)               <A HREF="#/*">/*</A> Not a XENIX named type file.  *<A HREF="#/">/</A>
#define ENAVAIL         __KERNEL_NEG(158)               <A HREF="#/*">/*</A> NO XENIX semaphores available.  *<A HREF="#/">/</A>
#define EREMOTEIO       __KERNEL_NEG(159)               <A HREF="#/*">/*</A> Remote I/O error.  */

#ifdef __KERNEL__
<A HREF="#/*">/*</A> This is not really an error but a dummy error code used within the kernel
   to indicate that a mount point may have been crossed.  *<A HREF="#/">/</A>
#define EMOUNT          __KERNEL_NEG(200)
#endif

<A HREF="#/*">/*</A> There used to be a distinction between MiNTNet errors and ordinary
   MiNT errors.  This macro is provided for backwards compatibility.  *<A HREF="#/">/</A>
#define _NE_BASE 300

<A HREF="#/*">/*</A> A file that isn't a socket was specified when a socket is required.  *<A HREF="#/">/</A>
#define ENOTSOCK        __KERNEL_NEG(300)               <A HREF="#/*">/*</A> Socket operation on non-socket.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> No default destination address was set for the socket.  You get
   this error when you try to transmit data over a connectionless
   socket, without first specifying a destination for the data with
   `connect'<A HREF="#.">.</A>  *<A HREF="#/">/</A>
#define EDESTADDRREQ    __KERNEL_NEG(301)               <A HREF="#/*">/*</A> Destination address required.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> The size of a message sent on a socket was larger than the
   supported maximum size.  *<A HREF="#/">/</A>
#define EMSGSIZE        __KERNEL_NEG(302)               <A HREF="#/*">/*</A> Message too long.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> The socket type does not support the requested communications
   protocol.  *<A HREF="#/">/</A>
#define EPROTOTYPE      __KERNEL_NEG(303)               <A HREF="#/*">/*</A> Protocol wrong type for socket.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> You specified a socket option that doesn't make sense for the
   particular protocol being used by the socket.  *<A HREF="#/">/</A>
#define ENOPROTOOPT     __KERNEL_NEG(304)               <A HREF="#/*">/*</A> Protocol not available.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> The socket domain does not support the requested communications
   protocol (perhaps because the requested protocol is completely
   invalid)<A HREF="#.">.</A>  *<A HREF="#/">/</A>
#define EPROTONOSUPPORT __KERNEL_NEG(305)               <A HREF="#/*">/*</A> Protocol not supported.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> The socket type is not supported.  *<A HREF="#/">/</A>
#define ESOCKTNOSUPPORT __KERNEL_NEG(306)               <A HREF="#/*">/*</A> Socket type not supported.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> The operation you requested is not supported.  Some socket
   functions don't make sense for all type of sockets, and others
   may not be implemented for all communications prototcols.  In the
   GNU system, this error can happen for many calls when the object
   does not support the particular operation; it is a generic
   indication that the server knows nothing to do for that
   cal.  *<A HREF="#/">/</A>
#define EOPNOTSUPP      __KERNEL_NEG(307)               <A HREF="#/*">/*</A> Operation not supported.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> The socket communications protocol family you requested is not
   supported.  *<A HREF="#/">/</A>
#define EPFNOSUPPORT    __KERNEL_NEG(308)               <A HREF="#/*">/*</A> Protocol family not supported.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> The address family specified for a socket is not supported; it is
   inconsistent with the protocol being used on the socket.  *<A HREF="#/">/</A>
#define EAFNOSUPPORT    __KERNEL_NEG(309)               <A HREF="#/*">/*</A> Address family not supported
                                           by protocol. *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> The requested socket address is already in use.  *<A HREF="#/">/</A>
#define EADDRINUSE      __KERNEL_NEG(310)               <A HREF="#/*">/*</A> Address already in use *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> The requested socket address is not available; for example, you
   tried to give a socket a name that doesn't match the local host
   name.  *<A HREF="#/">/</A>
#define EADDRNOTAVAIL   __KERNEL_NEG(311)               <A HREF="#/*">/*</A> Cannot assign requested address.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> A socket operation failed because the network was down.  *<A HREF="#/">/</A>
#define ENETDOWN        __KERNEL_NEG(312)               <A HREF="#/*">/*</A> Network is down.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> A socket operation failed because the subnet containing the remote
   host was unreachable.  *<A HREF="#/">/</A>
#define ENETUNREACH     __KERNEL_NEG(313)               <A HREF="#/*">/*</A> Network is unreachable.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> A network connection was reset because the remote host crashed.  *<A HREF="#/">/</A>
#define ENETRESET       __KERNEL_NEG(314)               <A HREF="#/*">/*</A> Network dropped conn. because of
                                           reset.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> A network connnection was aborted locally.  *<A HREF="#/">/</A>
#define ECONNABORTED    __KERNEL_NEG(315)               <A HREF="#/*">/*</A> Software caused connection abort.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> A network connection was closed for reasons outside the control of
   the local host, such as by the remote machine rebooting or an
   unrecoverable protocol violation.  *<A HREF="#/">/</A>
#define ECONNRESET      __KERNEL_NEG(316)               <A HREF="#/*">/*</A> Connection reset by peer.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> You tried to connect a socket that is already connected.  *<A HREF="#/">/</A>
#define EISCONN         __KERNEL_NEG(317)               <A HREF="#/*">/*</A> Socket is already connected.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> The socket is not connected to anything.  You get this error when
   you try to transmit data over the socket, without first specifying
   a destination for the data.  For a connectionless socket (for
   datagram protocols, such as UDP), you get `EDESTADDRREQ' instead.  *<A HREF="#/">/</A>
#define ENOTCONN        __KERNEL_NEG(318)               <A HREF="#/*">/*</A> Socket is not connected.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> The socket has already been shut down.  *<A HREF="#/">/</A>
#define ESHUTDOWN       __KERNEL_NEG(319)               <A HREF="#/*">/*</A> Cannot send after shutdown.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> A socket operation with a specified timeout received nor response
   during the timeout period.  *<A HREF="#/">/</A>
#define ETIMEDOUT       __KERNEL_NEG(320)               <A HREF="#/*">/*</A> Connection timed out.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> A remote host refused to allow the network connection (typically
   because it is not running the requested service)<A HREF="#.">.</A>  *<A HREF="#/">/</A>
#define ECONNREFUSED    __KERNEL_NEG(321)               <A HREF="#/*">/*</A> Connection refused.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> The remote host for a requested network connection is down.  *<A HREF="#/">/</A>
#define EHOSTDOWN       __KERNEL_NEG(322)               <A HREF="#/*">/*</A> Host is down.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> The remote host for a requested network connection is not
   reachable.  *<A HREF="#/">/</A>
#define EHOSTUNREACH    __KERNEL_NEG(323)               <A HREF="#/*">/*</A> No route to host.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> An operation is already in progress on an object that has
   non-blocking mode selected.  *<A HREF="#/">/</A>
#define EALREADY        __KERNEL_NEG(324)               <A HREF="#/*">/*</A> Operation already in progress.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> An operation that cannot complete immediately was initiated on an
   object that has non-blocking mode selected.  Some functions that
   must always block (such as `connect') never return `EAGAIN'<A HREF="#.">.</A>  Instead
   they return `EINPROGRESS' to indicate that the operation has begun and
   will take some time.  Attempts to manipulate the object before the
   call completes return `EALREADY'<A HREF="#.">.</A>  You can use the `select' function
   to find out when the pending operation has completed.  *<A HREF="#/">/</A>
#define EINPROGRESS     __KERNEL_NEG(325)               <A HREF="#/*">/*</A> Operation now in progress.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> Resource temporarily unavailable; the call might work if you try
   again later.  The macro `EWOULDBLOCK' is another name for `EAGAIN'<A HREF="#;">;</A>
   they are always the same in the MiNT system.

   This error can happen in a few different situations:

        <A HREF="#*">*</A> An operation that would block was attempted on an object that
          has non-blocking mode selected.  Trying the same operation
          again will block until some external condition makes it
          possible to read, write or connect (whatever the operation)<A HREF="#.">.</A>
          You can use `select' to find out when the operation will be
          possible.

          Portability Note: In many older Unix systems, this condition
          was indicated by `EWOULDBLOCK', which was a distinct error
          code different from `EAGAIN'<A HREF="#.">.</A>  To make your program portable,
          you should check for both codes and treat them the same.
          In C programs you should not use a case statement for that
          because that will trigger a compile-time error for systems
          where `EWOULDBLOCK' and `EAGAIN' expand to the same numerical
          value.  You should either handle treat it with preprocessor
          macros (test if they are equal or not) or use an if conditional.

        <A HREF="#*">*</A> A temporary resource shortage made an operation impossible.
          `fork' can return this error.  It indicates that the shortage
          is expected to pass, so your program can try the call again
          later and it may succeed.  It is probably a good idea to
          delay for a few seconds before trying it again, to allow time
          for other processes to release scarce resources.  Such
          shortages are usually fairly serious and affect the whole
          system, so usually an interactive program should report the
          error to the user and return to its command loop.  *<A HREF="#/">/</A>
#define EAGAIN          __KERNEL_NEG(326)               <A HREF="#/*">/*</A> Operation would block.  *<A HREF="#/">/</A>
#define EWOULDBLOCK     EAGAIN

<A HREF="#/*">/*</A> The kernel's buffer for I/O operations are all in use.  In GNU,
   this error is always synonymous with `ENOMEM'<A HREF="#;">;</A> you may get one or
   the other from network operations.  *<A HREF="#/">/</A>
#define ENOBUFS         __KERNEL_NEG(327)               <A HREF="#/*">/*</A> No buffer space available.  *<A HREF="#/">/</A>

<A HREF="#/*">/*</A> Too many references: cannot splice.  *<A HREF="#/">/</A>
#define ETOOMANYREFS    __KERNEL_NEG(328)               <A HREF="#/*">/*</A> Too many references.  *<A HREF="#/">/</A>

#define _NE_MAX         ETOOMANYREFS

#ifndef __KERNEL__

__END_DECLS

#endif

#endif <A HREF="#/*">/*</A> _MINT_ERRNO_H *<A HREF="#/">/</A>
<HR SIZE=3><H2 ID="LINEAVAR.H">LINEAVAR.H</H2>
<A HREF="#/*">/*</A>
<A HREF="#*">*</A>*****************************  lineavar.h  **********************************
<A HREF="#*">*</A>
<A HREF="#*">*</A> $Revision: 3.2 $      $Source: /u/lozben/projects/vdi/mtaskvdi/RCS/lineavar.h,v $
<A HREF="#*">*</A> <A HREF="#==">==</A><A HREF="#=">=</A>=========================================================================
<A HREF="#*">*</A> $Author: lozben $     $Date: 91/09/10 19:55:56 $     $Locker:  $
<A HREF="#*">*</A> <A HREF="#==">==</A><A HREF="#=">=</A>=========================================================================
<A HREF="#*">*</A>
<A HREF="#*">*</A> $Log: lineavar.h,v $
<A HREF="#*">*</A> Revision 3.2  91/09/10  19:55:56  lozben
<A HREF="#*">*</A> Added "<A HREF="#WORD">WORD</A> qCircle[80]" to the linea structure.
<A HREF="#*">*</A>
<A HREF="#*">*</A> Revision 3.1  91/07/29  16:52:14  lozben
<A HREF="#*">*</A> Definition of the line1010 variable structure.
<A HREF="#*">*</A>
<A HREF="#*">*</A>*****************************************************************************
*<A HREF="#/">/</A>

#ifndef _LINEAVAR_H_
#define _LINEAVAR_H_

typedef struct vdiVars {

    <A HREF="#WORD">WORD</A>        _angle;
    <A HREF="#WORD">WORD</A>        begAng;
    FONT_HEAD   *curFont;           <A HREF="#/*">/*</A> pointer to current font              *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        delAng;
    <A HREF="#WORD">WORD</A>        deltaY;
    <A HREF="#WORD">WORD</A>        deltaY1;
    <A HREF="#WORD">WORD</A>        deltaY2;
    <A HREF="#WORD">WORD</A>        endAng;
    <A HREF="#WORD">WORD</A>        filIntersect;
    <A HREF="#WORD">WORD</A>        fillMaxY;
    <A HREF="#WORD">WORD</A>        fillMinY;
    <A HREF="#WORD">WORD</A>        nSteps;
    <A HREF="#WORD">WORD</A>        oDeltaY;
    <A HREF="#WORD">WORD</A>        sBegstY;
    <A HREF="#WORD">WORD</A>        sEndstY;
    <A HREF="#WORD">WORD</A>        sFilCol;
    <A HREF="#WORD">WORD</A>        sFillPer;
    <A HREF="#WORD">WORD</A>        sPatMsk;
    <A HREF="#WORD">WORD</A>        *sPatPtr;
    <A HREF="#WORD">WORD</A>        _start;
    <A HREF="#WORD">WORD</A>        xC;
    <A HREF="#WORD">WORD</A>        xRad;
    <A HREF="#WORD">WORD</A>        y;
    <A HREF="#WORD">WORD</A>        yC;
    <A HREF="#WORD">WORD</A>        yRad;

    <A HREF="#WORD">WORD</A>        mPosHx;             <A HREF="#/*">/*</A> Mouse hot spot <A HREF="#-">-</A> x coord             *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        mPosHy;             <A HREF="#/*">/*</A> Mouse hot spot <A HREF="#-">-</A> y coord             *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        mPlanes;            <A HREF="#/*">/*</A> Ms planes (reserved, but we used it) *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        mCdbBg;             <A HREF="#/*">/*</A> Mouse background color as pel value  *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        mCdbFg;             <A HREF="#/*">/*</A> Mouse foreground color as pel value  *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        maskForm[32]<A HREF="#;">;</A>       <A HREF="#/*">/*</A> Storage for ms cursor mask and form  *<A HREF="#/">/</A>

    <A HREF="#WORD">WORD</A>        inqTab[45]<A HREF="#;">;</A>         <A HREF="#/*">/*</A> info returned by vq_extnd <A HREF="#VDI">VDI</A> call   *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        devTab[45]<A HREF="#;">;</A>         <A HREF="#/*">/*</A> info returned by v_opnwk <A HREF="#VDI">VDI</A> call    *<A HREF="#/">/</A>

    <A HREF="#WORD">WORD</A>        gCurX;              <A HREF="#/*">/*</A> current mouse cursor X position      *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        gCurY;              <A HREF="#/*">/*</A> current mouse cursor Y position      *<A HREF="#/">/</A>

    <A HREF="#WORD">WORD</A>        hideCnt;            <A HREF="#/*">/*</A> depth at which the ms is hidden      *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        mouseBt;            <A HREF="#/*">/*</A> current mouse button status          *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        reqCol[16][3]<A HREF="#;">;</A>      <A HREF="#/*">/*</A> internal data for vq_color           *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        sizTab[15]<A HREF="#;">;</A>         <A HREF="#/*">/*</A> size in device coordinates           *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        termCh;             <A HREF="#/*">/*</A> 16 bit character info                *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        chcMode;            <A HREF="#/*">/*</A> the mode of the Choice device        *<A HREF="#/">/</A>
    ATTRIBUTE   *curWork;           <A HREF="#/*">/*</A> pointer to current works attributes  *<A HREF="#/">/</A>
    FONT_HEAD   *defFont;           <A HREF="#/*">/*</A> pointer to default font head         *<A HREF="#/">/</A>
    FONT_HEAD   *fontRing[4]<A HREF="#;">;</A>       <A HREF="#/*">/*</A> ptrs to link list of fnt hdrs        *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        iniFontCount;       <A HREF="#/*">/*</A> <A HREF="##">#</A> of fonts in the FONT_RING lists    *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        lineCW;             <A HREF="#/*">/*</A> current line width                   *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        locMode;            <A HREF="#/*">/*</A> the mode of the Locator device       *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        numQCLines;         <A HREF="#/*">/*</A> <A HREF="##">#</A> of line in the quarter circle      *<A HREF="#/">/</A>

    <A HREF="#LONG">LONG</A>        trap14Sav;          <A HREF="#/*">/*</A> space to save the return address     *<A HREF="#/">/</A>
    <A HREF="#LONG">LONG</A>        colOrMask;          <A HREF="#/*">/*</A> some modes this is ored in VS_COLOR  *<A HREF="#/">/</A>
    <A HREF="#LONG">LONG</A>        colAndMask;         <A HREF="#/*">/*</A> some modes this is anded in VS_COLOR *<A HREF="#/">/</A>
    <A HREF="#LONG">LONG</A>        trap14BSav;         <A HREF="#/*">/*</A> space to sav ret adr (for reentrency)*<A HREF="#/">/</A>

    <A HREF="#WORD">WORD</A>        reserved0[32]<A HREF="#;">;</A>      <A HREF="#/*">/*</A> reserved                             *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        strMode;            <A HREF="#/*">/*</A> the mode of the String device        *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        valMode;            <A HREF="#/*">/*</A> the mode of the Valuator device      *<A HREF="#/">/</A>
    <A HREF="#BYTE">BYTE</A>        curMsStat;          <A HREF="#/*">/*</A> Current mouse status                 *<A HREF="#/">/</A>
    <A HREF="#BYTE">BYTE</A>        reserved1;          <A HREF="#/*">/*</A> reserved                             *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        disabCnt;           <A HREF="#/*">/*</A> hide depth of alpha cursor           *<A HREF="#/">/</A>


    <A HREF="#/*">/*</A>
     <A HREF="#*">*</A> the next 5 bytes are used as a communication
     <A HREF="#*">*</A> block to the vblank cursor draw routine.
     <A HREF="#*">*</A> They must be contiguous!!!!!!
     *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        xyDraw[2]<A HREF="#;">;</A>          <A HREF="#/*">/*</A> x,y communication block.             *<A HREF="#/">/</A>
    <A HREF="#BYTE">BYTE</A>        drawFlag;           <A HREF="#/*">/*</A> Non-zero means draw ms frm on vblank *<A HREF="#/">/</A>

    <A HREF="#BYTE">BYTE</A>        mouseFlag;          <A HREF="#/*">/*</A> Non-zero if mouse ints disabled      *<A HREF="#/">/</A>

    <A HREF="#LONG">LONG</A>        trap1Sav;           <A HREF="#/*">/*</A> space to save return address         *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        savCXY[2]<A HREF="#;">;</A>          <A HREF="#/*">/*</A> save area for cursor cell coords.    *<A HREF="#/">/</A>

    <A HREF="#WORD">WORD</A>        saveLen;            <A HREF="#/*">/*</A> height of saved form                 *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        *saveAddr;          <A HREF="#/*">/*</A> screen addr of 1st word of plane 0   *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        saveStat;           <A HREF="#/*">/*</A> cursor save status                   *<A HREF="#/">/</A>
    <A HREF="#LONG">LONG</A>        saveArea[64]<A HREF="#;">;</A>       <A HREF="#/*">/*</A> save up to 4 planes. 16 longs/plane  */

    <A HREF="#WORD">WORD</A>        (*timAddr)<A HREF="#()">()</A><A HREF="#;">;</A>       <A HREF="#/*">/*</A> ptr to user installed routine        *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        (*timChain)<A HREF="#()">()</A><A HREF="#;">;</A>      <A HREF="#/*">/*</A> jmps here when done with above       *<A HREF="#/">/</A>

    <A HREF="#WORD">WORD</A>        (*userBut)<A HREF="#()">()</A><A HREF="#;">;</A>       <A HREF="#/*">/*</A> user button vector                   *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        (*userCur)<A HREF="#()">()</A><A HREF="#;">;</A>       <A HREF="#/*">/*</A> user cursor vector                   *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        (*userMot)<A HREF="#()">()</A><A HREF="#;">;</A>       <A HREF="#/*">/*</A> user motion vector                   *<A HREF="#/">/</A>

    <A HREF="#WORD">WORD</A>        vCelHt;             <A HREF="#/*">/*</A> height of character cell             *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        vCelMx;             <A HREF="#/*">/*</A> maximum horizontal cell <A HREF="#index">index</A>        *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        vCelMy;             <A HREF="#/*">/*</A> maximum vertical cell <A HREF="#index">index</A>          *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        vCelWr;             <A HREF="#/*">/*</A> screen width (bytes) <A HREF="#*">*</A> cel_ht        *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        vColBg;             <A HREF="#/*">/*</A> character cell text background color *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        vColFg;             <A HREF="#/*">/*</A> character cell text foreground color *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        *vCurAd;            <A HREF="#/*">/*</A> cursor address                       *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        vCurOff;            <A HREF="#/*">/*</A> byte ofsset to cur from screen base  *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        vCurCx;             <A HREF="#/*">/*</A> cursor cell X position               *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        vCurCy;             <A HREF="#/*">/*</A> cursor cell Y position               *<A HREF="#/">/</A>
    <A HREF="#BYTE">BYTE</A>        vCTInit;            <A HREF="#/*">/*</A> vCurTim reload value.                *<A HREF="#/">/</A>
    <A HREF="#BYTE">BYTE</A>        vCurTim;            <A HREF="#/*">/*</A> cursor blink rate (<A HREF="##">#</A> of vblanks)     *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        *vFntAd;            <A HREF="#/*">/*</A> address of monospaced font data      *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        vFntNd;             <A HREF="#/*">/*</A> last <A HREF="#ASCII">ASCII</A> code in font              *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        vFntSt;             <A HREF="#/*">/*</A> first <A HREF="#ASCII">ASCII</A> code in font             *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        vFntWr;             <A HREF="#/*">/*</A> width of font form in bytes          *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        vHzRez;             <A HREF="#/*">/*</A> horizontal pixel resolution          *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        *vOffAd;            <A HREF="#/*">/*</A> address of font offset table         *<A HREF="#/">/</A>

<A HREF="#/*">/*</A>
 <A HREF="#*">*</A>              bit 0   cursor flash            0:disabled  1:enabled
 <A HREF="#*">*</A>              bit 1   flash state             0:off       1:on
 <A HREF="#*">*</A>  not used    bit 2   cursor visibility       0:invisible 1:visible
 <A HREF="#*">*</A>              bit 3   end of line             0:overwrite 1:wrap
 <A HREF="#*">*</A>              bit 4   reverse video           0:on        1:off
 <A HREF="#*">*</A>              bit 5   cursor position saved   0:false     1:true
 <A HREF="#*">*</A>  not used    bit 6   critical section        0:false     1:true
 *<A HREF="#/">/</A>
    <A HREF="#BYTE">BYTE</A>        vStat0;             <A HREF="#/*">/*</A> cursor display mode (look above)     *<A HREF="#/">/</A>

    <A HREF="#BYTE">BYTE</A>        vDelay;             <A HREF="#/*">/*</A> cursor redisplay period              *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        vVtRez;             <A HREF="#/*">/*</A> vertical resolution of the screen    *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        bytesLin;           <A HREF="#/*">/*</A> copy of vLinWr for concat            *<A HREF="#/">/</A>

    <A HREF="#WORD">WORD</A>        vPlanes;            <A HREF="#/*">/*</A> number of video planes               *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        vLinWr;             <A HREF="#/*">/*</A> number of bytes/video line           */

    <A HREF="#WORD">WORD</A>        *contrl;            <A HREF="#/*">/*</A> ptr to the <A HREF="#CONTRL">CONTRL</A> array              *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        *intin;             <A HREF="#/*">/*</A> ptr to the <A HREF="#INTIN">INTIN</A> array               *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        *ptsin;             <A HREF="#/*">/*</A> ptr to the <A HREF="#PTSIN">PTSIN</A> array               *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        *intout;            <A HREF="#/*">/*</A> ptr to the <A HREF="#INTOUT">INTOUT</A> array              *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        *ptsout;            <A HREF="#/*">/*</A> ptr to the <A HREF="#PTSOUT">PTSOUT</A> array              *<A HREF="#/">/</A>

    <A HREF="#/*">/*</A>
     <A HREF="#*">*</A> The following 4 variables are accessed by the line-drawing
     <A HREF="#*">*</A> routines as an array (to allow post-increment addressing)<A HREF="#.">.</A>
     <A HREF="#*">*</A> THEY MUST BE CONTIGUOUS <A HREF="#!">!</A>!
     *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        fgBp1;              <A HREF="#/*">/*</A> foreground bit plane #1 value        *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        fgBp2;              <A HREF="#/*">/*</A> foreground bit plane #2 value        *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        fgBp3;              <A HREF="#/*">/*</A> foreground bit plane #3 value        *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        fgBp4;              <A HREF="#/*">/*</A> foreground bit plane #4 value        *<A HREF="#/">/</A>

    <A HREF="#WORD">WORD</A>        lstLin;             <A HREF="#/*">/*</A> 0 <A HREF="#=&#62;">=&#62;</A> not last line of polyline       *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        lnMask;             <A HREF="#/*">/*</A> line style mask.                     *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        wrtMode;            <A HREF="#/*">/*</A> writing mode.                        *<A HREF="#/">/</A>


    <A HREF="#WORD">WORD</A>        x1;                 <A HREF="#/*">/*</A> X1 coordinate                        *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        y1;                 <A HREF="#/*">/*</A> Y1 coordinate                        *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        x2;                 <A HREF="#/*">/*</A> X2 coordinate                        *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        y2;                 <A HREF="#/*">/*</A> Y2 coordinate                        *<A HREF="#/">/</A>

    <A HREF="#WORD">WORD</A>        *patPtr;            <A HREF="#/*">/*</A> ptr to pattern.                      *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        patMsk;             <A HREF="#/*">/*</A> pattern <A HREF="#index">index</A><A HREF="#.">.</A> (mask)                *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        multiFill;          <A HREF="#/*">/*</A> multiplane fill flag. (0 <A HREF="#=&#62;">=&#62;</A> 1 plane) *<A HREF="#/">/</A>

    <A HREF="#WORD">WORD</A>        clip;               <A HREF="#/*">/*</A> clipping flag.                       *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        xMnClip;            <A HREF="#/*">/*</A> x minimum clipping value.            *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        yMnClip;            <A HREF="#/*">/*</A> y minimum clipping value.            *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        xMxClip;            <A HREF="#/*">/*</A> x maximum clipping value.            *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        yMxClip;            <A HREF="#/*">/*</A> y maximum clipping value.            *<A HREF="#/">/</A>

    <A HREF="#WORD">WORD</A>        xAccDda;            <A HREF="#/*">/*</A> accumulator for x DDA                *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        ddaInc;             <A HREF="#/*">/*</A> the fraction to be added to the DDA  *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        tSclsts;            <A HREF="#/*">/*</A> scale up or down flag.               *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        monoStatus;         <A HREF="#/*">/*</A> non-zero - cur font is monospaced    *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        sourceX;            <A HREF="#/*">/*</A> X coord of character in font         *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        sourceY;            <A HREF="#/*">/*</A> Y coord of character in font         *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        destX;              <A HREF="#/*">/*</A> X coord of character on screen       *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        destY;              <A HREF="#/*">/*</A> X coord of character on screen       *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        delX;               <A HREF="#/*">/*</A> width of character                   *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        delY;               <A HREF="#/*">/*</A> height of character                  *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        *fBase;             <A HREF="#/*">/*</A> pointer to font data                 *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        fWidth;             <A HREF="#/*">/*</A> offset,segment and form with of font *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        style;              <A HREF="#/*">/*</A> special effects                      *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        liteMask;           <A HREF="#/*">/*</A> special effects                      *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        skewMask;           <A HREF="#/*">/*</A> special effects                      *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        weight;             <A HREF="#/*">/*</A> special effects                      *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        rOff;               <A HREF="#/*">/*</A> Skew offset above baseline           *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        lOff;               <A HREF="#/*">/*</A> Skew offset below baseline           *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        scale;              <A HREF="#/*">/*</A> replicate pixels                     *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        chUp;               <A HREF="#/*">/*</A> character rotation vector            *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        textFg;             <A HREF="#/*">/*</A> text foreground color                *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        *scrtchP;           <A HREF="#/*">/*</A> pointer to base of scratch buffer    *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        scrPt2;             <A HREF="#/*">/*</A> large buffer base offset             *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        textBg;             <A HREF="#/*">/*</A> text background color                *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        copyTran;           <A HREF="#/*">/*</A> cp rstr frm type flag (opaque/trans) */
    <A HREF="#WORD">WORD</A>        (*quitFill)<A HREF="#()">()</A><A HREF="#;">;</A>      <A HREF="#/*">/*</A> ptr to routine for quitting seedfill *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        (*UserDevInit)<A HREF="#()">()</A><A HREF="#;">;</A>   <A HREF="#/*">/*</A> ptr to user routine before dev_init  *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        (*UserEscInit)<A HREF="#()">()</A><A HREF="#;">;</A>   <A HREF="#/*">/*</A> ptr to user routine before esc_init  *<A HREF="#/">/</A>
    <A HREF="#LONG">LONG</A>        reserved2[8]<A HREF="#;">;</A>       <A HREF="#/*">/*</A> reserved                             *<A HREF="#/">/</A>

    <A HREF="#WORD">WORD</A>        (<A HREF="#*">*</A>*routines)<A HREF="#()">()</A><A HREF="#;">;</A>     <A HREF="#/*">/*</A> ptr to primitives vector list        *<A HREF="#/">/</A>
    SCREENDEF   *curDev;            <A HREF="#/*">/*</A> ptr to a surrent device structure    *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        bltMode;            <A HREF="#/*">/*</A> 0: soft BiT BLiT 1: hard BiT BLiT    *<A HREF="#/">/</A>
    <A HREF="#/*">/*</A>
     <A HREF="#*">*</A> Stuff for 8 plane <A HREF="#VDI">VDI</A>
     *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        reserved3;          <A HREF="#/*">/*</A> reserved                             *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        reqXCol[240][3]<A HREF="#;">;</A>    <A HREF="#/*">/*</A> extended request color array         *<A HREF="#/">/</A>

    <A HREF="#WORD">WORD</A>        *svBlkPtr;          <A HREF="#/*">/*</A> points to the proper save block      *<A HREF="#/">/</A>
    <A HREF="#LONG">LONG</A>        fgBPlanes;          <A HREF="#/*">/*</A> fg bit plns flags (bit 0 is plane 0) *<A HREF="#/">/</A>

    <A HREF="#/*">/*</A>
     <A HREF="#*">*</A> The following 4 variables are accessed by the line-drawing routines
     <A HREF="#*">*</A> as an array (to allow post-increment addressing)<A HREF="#.">.</A>
     <A HREF="#*">*</A> THEY MUST BE CONTIGUOUS <A HREF="#!">!</A>!
     *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        fgBP5;              <A HREF="#/*">/*</A> foreground bitPlane #5 value.        *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        fgBP6;              <A HREF="#/*">/*</A> foreground bitPlane #6 value.        *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        fgBP7;              <A HREF="#/*">/*</A> foreground bitPlane #7 value.        *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        fgBP8;              <A HREF="#/*">/*</A> foreground bitPlane #8 value.        *<A HREF="#/">/</A>

    <A HREF="#/*">/*</A>
     <A HREF="#*">*</A> we don't get rid of the old area for compatibility reasons
     *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        _saveLen;           <A HREF="#/*">/*</A> height of saved form                 *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        *_saveAddr;         <A HREF="#/*">/*</A> screen addr of 1st word of plane 0   *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        _saveStat;          <A HREF="#/*">/*</A> cursor save status                   *<A HREF="#/">/</A>
    <A HREF="#LONG">LONG</A>        _saveArea[256]<A HREF="#;">;</A>     <A HREF="#/*">/*</A> save up to 8 planes. 16 longs/plane  */

    <A HREF="#WORD">WORD</A>        qCircle[80]<A HREF="#;">;</A>        <A HREF="#/*">/*</A> space to build circle coordinates    *<A HREF="#/">/</A>


<A HREF="#/*">/*</A><A HREF="#==">==</A><A HREF="#=">=</A>=========================== <A HREF="#NEW">NEW</A> STUFF =================================*<A HREF="#/">/</A>

    <A HREF="#WORD">WORD</A>        bytPerPix;          <A HREF="#/*">/*</A> number of bytes per pixel (0 if <A HREF="#&#60;">&#60;</A> 1) *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        formId;             <A HREF="#/*">/*</A> scrn form 2 ST, 1 stndrd, 3 pix      *<A HREF="#/">/</A>
    <A HREF="#LONG">LONG</A>        vlColBg;            <A HREF="#/*">/*</A> escape background color (long value) *<A HREF="#/">/</A>
    <A HREF="#LONG">LONG</A>        vlColFg;            <A HREF="#/*">/*</A> escape foreground color (long value) *<A HREF="#/">/</A>
    <A HREF="#LONG">LONG</A>        palMap[256]<A HREF="#;">;</A>        <A HREF="#/*">/*</A> either a maping of reg's or true val *<A HREF="#/">/</A>
    <A HREF="#WORD">WORD</A>        (*primitives[40])<A HREF="#()">()</A><A HREF="#;">;</A>    <A HREF="#/*">/*</A> space to copy vectors into       *<A HREF="#/">/</A>
} VDIVARS;

#endif
<HR SIZE=3><H2 ID="LINEAEQU.S">LINEAEQU.S</H2>
<A HREF="#*">*</A>******************************  lineaequ.s  *********************************
<A HREF="#*">*</A>
<A HREF="#*">*</A> $Revision: 3.1 $      $Source: /u/lozben/projects/vdi/mtaskvdi/RCS/lineaequ.s,v $
<A HREF="#*">*</A> <A HREF="#==">==</A><A HREF="#=">=</A>=========================================================================
<A HREF="#*">*</A> $Author: lozben $     $Date: 91/07/29 14:55:44 $     $Locker:  $
<A HREF="#*">*</A> <A HREF="#==">==</A><A HREF="#=">=</A>=========================================================================
<A HREF="#*">*</A>
<A HREF="#*">*</A> $Log: lineaequ.s,v $
<A HREF="#*">*</A> Revision 3.1  91/07/29  14:55:44  lozben
<A HREF="#*">*</A> Created this file of needed equates for the new multitasking vdi.
<A HREF="#*">*</A>
<A HREF="#*">*</A>*****************************************************************************

.include        "devequ.s"

<A HREF="#*">*</A>****************************************
<A HREF="#*">*</A>       Non-Overlayable Variables       *
<A HREF="#*">*</A>****************************************
angle           <A HREF="#=">=</A>       -910
beg_ang         <A HREF="#=">=</A>       -908
CUR_FONT        <A HREF="#=">=</A>       -906
del_ang         <A HREF="#=">=</A>       -902
deltay          <A HREF="#=">=</A>       -900
deltay1         <A HREF="#=">=</A>       -898
deltay2         <A HREF="#=">=</A>       -896
end_ang         <A HREF="#=">=</A>       -894
fil_intersect   <A HREF="#=">=</A>       -892
fill_maxy       <A HREF="#=">=</A>       -890
fill_miny       <A HREF="#=">=</A>       -888
n_steps         <A HREF="#=">=</A>       -886
odeltay         <A HREF="#=">=</A>       -884
s_begsty        <A HREF="#=">=</A>       -882
s_endsty        <A HREF="#=">=</A>       -880
s_fil_col       <A HREF="#=">=</A>       -878
s_fill_per      <A HREF="#=">=</A>       -876
s_patmsk        <A HREF="#=">=</A>       -874
s_patptr        <A HREF="#=">=</A>       -872
start           <A HREF="#=">=</A>       -868
xc              <A HREF="#=">=</A>       -866
xrad            <A HREF="#=">=</A>       -864
yc              <A HREF="#=">=</A>       -860
yrad            <A HREF="#=">=</A>       -858


mouse_cdb       <A HREF="#=">=</A>       -856    <A HREF="#;">;</A> define the mouse form storage area
m_pos_hx        <A HREF="#=">=</A>       -856    <A HREF="#;">;</A> Mouse hot spot - x coord
m_pos_hy        <A HREF="#=">=</A>       -854    <A HREF="#;">;</A> Mouse hot spot - y coord
m_planes        <A HREF="#=">=</A>       -852    <A HREF="#;">;</A> Mouse planes (reserved, but we used it!)
m_cdb_bg        <A HREF="#=">=</A>       -850    <A HREF="#;">;</A> Mouse background color as pel value
m_cdb_fg        <A HREF="#=">=</A>       -848    <A HREF="#;">;</A> Mouse foreground color as pel value
mask_form       <A HREF="#=">=</A>       -846    <A HREF="#;">;</A> Storage for mouse cursor mask and form

_INQ_TAB        <A HREF="#=">=</A>       -782
_DEV_TAB        <A HREF="#=">=</A>       -692

_GCURXY         <A HREF="#=">=</A>       -602
_GCURX          <A HREF="#=">=</A>       -602
_GCURY          <A HREF="#=">=</A>       -600

_HIDE_CNT       <A HREF="#=">=</A>       -598
_MOUSE_BT       <A HREF="#=">=</A>       -596
_REQ_COL        <A HREF="#=">=</A>       -594
_SIZ_TAB        <A HREF="#=">=</A>       -498
_TERM_CH        <A HREF="#=">=</A>       -468
_chc_mode       <A HREF="#=">=</A>       -466
_cur_work       <A HREF="#=">=</A>       -464    <A HREF="#;">;</A> pointer to current works attributes
_def_font       <A HREF="#=">=</A>       -460    <A HREF="#;">;</A> pointer to default font head
_font_ring      <A HREF="#=">=</A>       -456
_ini_font_count <A HREF="#=">=</A>       -440
_line_cw        <A HREF="#=">=</A>       -438
_loc_mode       <A HREF="#=">=</A>       -436
_num_qc_lines   <A HREF="#=">=</A>       -434

trap14sav       <A HREF="#=">=</A>       -432    <A HREF="#;">;</A> space to save the return address
col_or_mask     <A HREF="#=">=</A>       -428    <A HREF="#;">;</A> some modes this is ored in VS_COLOR
col_and_mask    <A HREF="#=">=</A>       -424    <A HREF="#;">;</A> some modes this is anded in VS_COLOR
trap14bsav      <A HREF="#=">=</A>       -420    <A HREF="#;">;</A> space to sav ret adr (for reentrency)

_str_mode       <A HREF="#=">=</A>       -352
_val_mode       <A HREF="#=">=</A>       -350

_MOUSE_ST       <A HREF="#=">=</A>       -348
cur_ms_stat     <A HREF="#=">=</A>       -348    <A HREF="#;">;</A> Current mouse status bits
                                <A HREF="#;">;</A>        bits used as follows
                                <A HREF="#;">;</A>
                                <A HREF="#;">;</A>        0   LEFT button state
                                <A HREF="#;">;</A>        1   RIGHT button state
                                <A HREF="#;">;</A>        2-4 not used
                                <A HREF="#;">;</A>        5   movement status
                                <A HREF="#;">;</A>        6   LEFT button changed
                                <A HREF="#;">;</A>        7   RIGHT button changed


disab_cnt       <A HREF="#=">=</A>       -346


_XYDRAW         <A HREF="#=">=</A>       -344
 xydraw         <A HREF="#=">=</A>       -344    <A HREF="#;">;</A> x,y communication block.
_DRAW_FLAG      <A HREF="#=">=</A>       -340
 draw_flag      <A HREF="#=">=</A>       -340    <A HREF="#;">;</A> Non-zero means draw mouse form on vblank


mouse_flag      <A HREF="#=">=</A>       -339    <A HREF="#;">;</A> Non-zero if mouse ints disabled

retsav          <A HREF="#=">=</A>       -338
sav_cxy         <A HREF="#=">=</A>       -334    <A HREF="#;">;</A> save area for cursor cell coords
sav_cx          <A HREF="#=">=</A>       -334    <A HREF="#;">;</A> save area for cursor cell coords X pos
sav_cy          <A HREF="#=">=</A>       -332    <A HREF="#;">;</A> save area for cursor cell coords Y pos

save_block      <A HREF="#=">=</A>       -330
save_len        <A HREF="#=">=</A>       -330
save_addr       <A HREF="#=">=</A>       -328    <A HREF="#;">;</A> screen address of 1st word of plane 0
save_stat       <A HREF="#=">=</A>       -324
save_area       <A HREF="#=">=</A>       -322    <A HREF="#;">;</A> save up to 4 planes. 16 longwords <A HREF="#/">/</A> plane

tim_addr        <A HREF="#=">=</A>       -66
tim_chain       <A HREF="#=">=</A>       -62
user_but        <A HREF="#=">=</A>       -58     <A HREF="#;">;</A> user button vector
user_cur        <A HREF="#=">=</A>       -54     <A HREF="#;">;</A> user cursor vector
user_mot        <A HREF="#=">=</A>       -50     <A HREF="#;">;</A> user motion vector

v_cel_ht        <A HREF="#=">=</A>       -46
v_cel_mx        <A HREF="#=">=</A>       -44
v_cel_my        <A HREF="#=">=</A>       -42
v_cel_wr        <A HREF="#=">=</A>       -40     <A HREF="#;">;</A> used in ST blitter code otherwise obsolete
v_col_bg        <A HREF="#=">=</A>       -38
v_col_fg        <A HREF="#=">=</A>       -36
v_cur_ad        <A HREF="#=">=</A>       -34
v_cur_off       <A HREF="#=">=</A>       -30
v_cur_cx        <A HREF="#=">=</A>       -28
v_cur_cy        <A HREF="#=">=</A>       -26
vct_init        <A HREF="#=">=</A>       -24     <A HREF="#;">;</A> v_cur_tim reload value.
v_cur_tim       <A HREF="#=">=</A>       -23
v_fnt_ad        <A HREF="#=">=</A>       -22
v_fnt_nd        <A HREF="#=">=</A>       -18
v_fnt_st        <A HREF="#=">=</A>       -16
v_fnt_wr        <A HREF="#=">=</A>       -14
v_hz_rez        <A HREF="#=">=</A>       -12
v_off_ad        <A HREF="#=">=</A>       -10
v_stat_0        <A HREF="#=">=</A>       -6
v_delay         <A HREF="#=">=</A>       -5
v_vt_rez        <A HREF="#=">=</A>       -4
_bytes_lin      <A HREF="#=">=</A>       -2      <A HREF="#;">;</A> copy of _v_lin_wr for concat.


lineavar        <A HREF="#=">=</A>       0
_v_planes       <A HREF="#=">=</A>       0       <A HREF="#;">;</A> number of video planes.
_v_lin_wr       <A HREF="#=">=</A>       2       <A HREF="#;">;</A> number of bytes/video line.

local_pb        <A HREF="#=">=</A>       4

_CONTRL         <A HREF="#=">=</A>       4       <A HREF="#;">;</A> ptr to the CONTRL array.
_INTIN          <A HREF="#=">=</A>       8       <A HREF="#;">;</A> ptr to the INTIN array.
_PTSIN          <A HREF="#=">=</A>       12      <A HREF="#;">;</A> ptr to the PTSIN array.
_INTOUT         <A HREF="#=">=</A>       16      <A HREF="#;">;</A> ptr to the INTOUT array.
_PTSOUT         <A HREF="#=">=</A>       20      <A HREF="#;">;</A> ptr to the PTSOUT array.

_FG_BP_1        <A HREF="#=">=</A>       24      <A HREF="#;">;</A> foreground bit_plane #1 value.
_FG_BP_2        <A HREF="#=">=</A>       26      <A HREF="#;">;</A> foreground bit_plane #2 value.
_FG_BP_3        <A HREF="#=">=</A>       28      <A HREF="#;">;</A> foreground bit_plane #3 value.
_FG_BP_4        <A HREF="#=">=</A>       30      <A HREF="#;">;</A> foreground bit_plane #4 value.
_LSTLIN         <A HREF="#=">=</A>       32      <A HREF="#;">;</A> 0 <A HREF="#=&#62;">=&#62;</A> not last line of polyline.
_LN_MASK        <A HREF="#=">=</A>       34      <A HREF="#;">;</A> line style mask.
_WRT_MODE       <A HREF="#=">=</A>       36      <A HREF="#;">;</A> writing mode.


_X1             <A HREF="#=">=</A>       38      <A HREF="#;">;</A> _X1.
_Y1             <A HREF="#=">=</A>       40      <A HREF="#;">;</A> _Y1.
_X2             <A HREF="#=">=</A>       42      <A HREF="#;">;</A> _X2.
_Y2             <A HREF="#=">=</A>       44      <A HREF="#;">;</A> _Y2.
_patptr         <A HREF="#=">=</A>       46      <A HREF="#;">;</A> ptr to pattern.
_patmsk         <A HREF="#=">=</A>       50      <A HREF="#;">;</A> pattern <A HREF="#index">index</A><A HREF="#.">.</A> (mask)
_multifill      <A HREF="#=">=</A>       52      <A HREF="#;">;</A> multi-plane fill flag. (0 <A HREF="#=&#62;">=&#62;</A> 1 plane)

_CLIP           <A HREF="#=">=</A>       54      <A HREF="#;">;</A> clipping flag.
_XMN_CLIP       <A HREF="#=">=</A>       56      <A HREF="#;">;</A> x minimum clipping value.
_YMN_CLIP       <A HREF="#=">=</A>       58      <A HREF="#;">;</A> y minimum clipping value.
_XMX_CLIP       <A HREF="#=">=</A>       60      <A HREF="#;">;</A> x maximum clipping value.
_YMX_CLIP       <A HREF="#=">=</A>       62      <A HREF="#;">;</A> y maximum clipping value.

_XACC_DDA       <A HREF="#=">=</A>       64      <A HREF="#;">;</A> accumulator for x DDA
_DDA_INC        <A HREF="#=">=</A>       66      <A HREF="#;">;</A> the fraction to be added to the DDA
_T_SCLSTS       <A HREF="#=">=</A>       68      <A HREF="#;">;</A> scale up or down flag.
_MONO_STATUS    <A HREF="#=">=</A>       70      <A HREF="#;">;</A> non-zero - cur font is monospaced
_SOURCEX        <A HREF="#=">=</A>       72
_SOURCEY        <A HREF="#=">=</A>       74      <A HREF="#;">;</A> upper left of character in font file
_DESTX          <A HREF="#=">=</A>       76
_DESTY          <A HREF="#=">=</A>       78      <A HREF="#;">;</A> upper left of destination on screen
_DELX           <A HREF="#=">=</A>       80
_DELY           <A HREF="#=">=</A>       82      <A HREF="#;">;</A> width and height of character
_FBASE          <A HREF="#=">=</A>       84      <A HREF="#;">;</A> pointer to font data
_FWIDTH         <A HREF="#=">=</A>       88      <A HREF="#;">;</A> offset,segment and form with of font
_STYLE          <A HREF="#=">=</A>       90      <A HREF="#;">;</A> special effects
_LITEMASK       <A HREF="#=">=</A>       92      <A HREF="#;">;</A> special effects
_SKEWMASK       <A HREF="#=">=</A>       94      <A HREF="#;">;</A> special effects
_WEIGHT         <A HREF="#=">=</A>       96      <A HREF="#;">;</A> special effects
_R_OFF          <A HREF="#=">=</A>       98
_L_OFF          <A HREF="#=">=</A>       100     <A HREF="#;">;</A> skew above and below baseline
_DOUBLE         <A HREF="#=">=</A>       102     <A HREF="#;">;</A> replicate pixels
_CHUP           <A HREF="#=">=</A>       104     <A HREF="#;">;</A> character rotation vector
_TEXT_FG        <A HREF="#=">=</A>       106     <A HREF="#;">;</A> text foreground color
_scrtchp        <A HREF="#=">=</A>       108     <A HREF="#;">;</A> pointer to base of scratch buffer
_scrpt2         <A HREF="#=">=</A>       112     <A HREF="#;">;</A> large buffer base offset
_TEXT_BG        <A HREF="#=">=</A>       114     <A HREF="#;">;</A> text background color
_COPYTRAN       <A HREF="#=">=</A>       116     <A HREF="#;">;</A> copy raster form type flag. (opaque/trans)
_quitfill       <A HREF="#=">=</A>       118     <A HREF="#;">;</A> ptr to routine for quitting seedfill.
UserDevInit     <A HREF="#=">=</A>       122     <A HREF="#;">;</A> ptr to user routine before dev_init
UserEscInit     <A HREF="#=">=</A>       126     <A HREF="#;">;</A> ptr to user routine before esc_init

V_ROUTINES      <A HREF="#=">=</A>       162     <A HREF="#;">;</A> pointer to drawing primitives vector list
CUR_DEV         <A HREF="#=">=</A>       166     <A HREF="#;">;</A> pointer to current device structure
_BLT_MODE       <A HREF="#=">=</A>       170

_REQ_X_COL      <A HREF="#=">=</A>       174     <A HREF="#;">;</A> extended request color array

sv_blk_ptr      <A HREF="#=">=</A>       1614    <A HREF="#;">;</A> points to the proper save block
_FG_B_PLANES    <A HREF="#=">=</A>       1618    <A HREF="#;">;</A> foreground bit planes flags (bit 0 is plane 0)

_FG_BP_5        <A HREF="#=">=</A>       1622    <A HREF="#;">;</A> foreground bit_plane #5 value.
_FG_BP_6        <A HREF="#=">=</A>       1624    <A HREF="#;">;</A> foreground bit_plane #6 value.
_FG_BP_7        <A HREF="#=">=</A>       1626    <A HREF="#;">;</A> foreground bit_plane #7 value.
_FG_BP_8        <A HREF="#=">=</A>       1628    <A HREF="#;">;</A> foreground bit_plane #8 value.

_save_block     <A HREF="#=">=</A>       1630
_save_len       <A HREF="#=">=</A>       1630
_save_addr      <A HREF="#=">=</A>       1632    <A HREF="#;">;</A> screen address of 1st word of plane 0
_save_stat      <A HREF="#=">=</A>       1636
_save_area      <A HREF="#=">=</A>       1638    <A HREF="#;">;</A> save up to 8 planes. 16 longwords <A HREF="#/">/</A> plane

q_circle        <A HREF="#=">=</A>       2662    <A HREF="#;">;</A> space to build circle coordinates

<A HREF="#*">*</A>****************** <A HREF="#NEW">NEW</A> EQUATES *******************

byt_per_pix     <A HREF="#=">=</A>       2822    <A HREF="#;">;</A> number of bytes per pixel (0 if <A HREF="#&#60;">&#60;</A> 1)
form_id         <A HREF="#=">=</A>       2824    <A HREF="#;">;</A> scrn form 2 ST, 1 stndrd, 3 pix
vl_col_bg       <A HREF="#=">=</A>       2826    <A HREF="#;">;</A> escape background color
vl_col_fg       <A HREF="#=">=</A>       2830    <A HREF="#;">;</A> escape foreground color
pal_map         <A HREF="#=">=</A>       2834    <A HREF="#;">;</A> either a maping of reg's or true val
V_PRIMITIVES    <A HREF="#=">=</A>       3858    <A HREF="#;">;</A> all the vectored primitives
<HR SIZE=3><H2 ID="The_local=FN_bug">The local=FN bug</H2>
<B><A HREF="#The_local=FN_bug">The local=FN bug</A></B>                                    GFA Basic FAQ (English)
<HR>

   <B>Symptoms:</B>
      The local variable never receives the <A HREF="#FN">FN</A> value returned. The
      system may hang at a later point in the program.

   <B>Description:</B>
      This problem arises when a function assigns a value to local
      variable and a <A HREF="#DIM">DIM</A> or <A HREF="#ERASE">ERASE</A> occurs before the function
      returns.

   An example source is given below that explains how, and can
   diagnose if your version of GFA has this problem:


   <A HREF="#PROCEDURE">PROCEDURE</A> test
     <A HREF="#LOCAL">LOCAL</A> a&                           <A HREF="#!">!</A> any variable, any variable type
     <A HREF="#'">'</A>
     a&=5
     adr=V:a&                           <A HREF="#!">!</A> note original address of a&
     <A HREF="#PRINT">PRINT</A> "defined",adr,"val"'a&
     <A HREF="#'">'</A>
     a&<A HREF="#=">=</A><A HREF="#FN">FN</A> oh_oh                        <A HREF="#!">!</A> new value assigned by way of
     <A HREF="#'">'</A> <A HREF="#^">^</A>                                <A HREF="#!">!</A> function
     <A HREF="#'">'</A> \<A HREF="#-">-</A>- error occurs here, in assignment!!!
     <A HREF="#'">'</A>
     <A HREF="#PRINT">PRINT</A> "after",V:a&,"val"'a&        <A HREF="#!">!</A> local variables have moved
     <A HREF="#PRINT">PRINT</A> "val at ",adr,<A HREF="#WORD">WORD</A>{adr}      <A HREF="#!">!</A> new value is at old address
   <A HREF="#RETURN">RETURN</A>

   <A HREF="#FUNCTION">FUNCTION</A> oh_oh
     <A HREF="#DIM">DIM</A> a$(10)                         <A HREF="#!">!</A> address of local a&<A HREF="#.">.</A>..
     <A HREF="#RETURN">RETURN</A> 10                          <A HREF="#!">!</A> in calling routine moved here
   <A HREF="#ENDFUNC">ENDFUNC</A>


   <B>Some remarks to this:</B>
    <A HREF="#*">*</A> The fault occurs both in the interpreter and in the compiled
      code.
    <A HREF="#*">*</A> The fault occurs when assigning any local variable (numeric or
      string) a value from a function inside of which, at any
      sublevel, a <A HREF="#DIM">DIM</A> or <A HREF="#ERASE">ERASE</A> statement is executed.
    <A HREF="#*">*</A> The fault does not occur when existing string elements in an
      array are reassigned. The error arises only when
      (re)dimensioning string or numeric arrays.
    <A HREF="#*">*</A> The fault does not affect local variables returned as a <A HREF="#VAR">VAR</A>
      parameter. Nor does it affect assignment to a global variable.

   <B>Analysis:</B>
      This is a memory management bug caused by how the function
      assigns a value to a variable. Any program which has functions
      and uses dynamic management of arrays has the potential for
      unexplained and seemingly random problems. Note that the
      problem is especially treacherous since the cause can be
      buried far below where the faulty assignment occurs, e.g. the
      assigning function may call a procedure which calls a
      procedure which calls a procedure which performs a <A HREF="#DIM">DIM</A><A HREF="#.">.</A>

   <B>Workaround:</B>
      A workaround to function assignment of a local variable, is to
      return the value using a <A HREF="#VAR">VAR</A>-defined parameter in the call
      (i.e. using a procedure), or to have the function return to a
      global variable. Or to not use dynamic arrays, or at least
      carefully structure when and how they are changed.

   Evidently the function assignment involves an internal V:a&
   reference being generated before executing the function call. The
   <A HREF="#DIM">DIM</A> command inside the function allocates global variable space
   for the array (the element pointers in the case of string arrays,
   the physical array in the case of numeric arrays), which pushes
   all existing local variables addresses. (See detailed notes on
   memory use, below.) This is a problem only because it occurs at
   runtime when we have a static address reference pending in the
   function. The return value is thus written to the old invalid
   address, and variable a& itself, now at another address, is
   unmodified.

   Note that attempting to <A HREF="#ERASE">ERASE</A> the array dimensioned in this
   situation will cause the system to hang, since when the function
   return assigned the value, the old address for a& then points
   into a <A HREF="#descriptor">descriptor</A> structure belonging to the new array. Where it
   points when an existing array is erased or redimensioned is less
   obvious, as is what happens then.

   Furthermore, any local variable which is assigned <A HREF="#ABSOLUTE">ABSOLUTE</A> will
   in a case like this (incorrectly) behave as a global and not have
   its address moved, see below:


   <A HREF="#LOCAL">LOCAL</A> a&,b&
   <A HREF="#.">.</A>..
   b&<A HREF="#=">=</A><A HREF="#ABSOLUTE">ABSOLUTE</A> V:a&
   b&<A HREF="#=">=</A><A HREF="#FN">FN</A> oh_oh
   <A HREF="#.">.</A>..

   <A HREF="#.">.</A>.. Variable b& is not moved and so gets the new value.


   Note that the address of b& is actually now invalid, and points
   into space reserved for the array.
   (V:a&=V:b& is no longer true!)

   This behaviour is quite unlike e.g. garbage collection (~fre(0)),
   where both variables are moved together and the relationship
   V:a&=V:b& holds true.
<HR SIZE=3><H2 ID="256_color_VDI/Hardware_table">256 color VDI/Hardware table</H2>
<A HREF="#SETCOLOR">SETCOLOR</A>   000 to 255
<A HREF="#VSETCOLOR">VSETCOLOR</A>  000 255 001 002 004 006 003 005 007 008 009 010 012 014 011 013
           016 017 018 019 020 021 022 023 024 025 026 027 028 029 030 031
           032 033 034 035 036 037 038 039 040 041 042 043 044 045 046 047
           048 049 050 051 052 053 054 055 056 057 058 059 060 061 062 063
           064 065 066 067 068 069 070 071 072 073 074 075 076 077 078 079
           080 081 082 083 084 085 086 087 088 089 090 091 092 093 094 095
           096 097 098 099 100 101 102 103 104 105 106 107 108 109 110 111
           112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127
           128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143
           144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159
           160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175
           176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191
           192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207
           208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223
           224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239
           240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 015
<HR SIZE=3><H2 ID="Publisher">Publisher</H2>
<A HREF="#GFA_Software_Technologies,_Inc.">GFA Software Technologies, Inc.</A>
<A HREF="#MichTron,_Inc.">MichTron, Inc.</A>
<A HREF="#Antic_Software">Antic Software</A>
<HR SIZE=3><H2 ID="GFA_Software_Technologies,_Inc.">GFA Software Technologies, Inc.</H2>

ATARI ST

<B>GFA</B>
<B>BASIC</B>
Version 3

Editor/Interpreter

<A HREF="#/">/</A>-------------------\
<A HREF="#&#124;">&#124;</A>               GFA <A HREF="#&">&</A>#124;
<A HREF="#&#124;">&#124;</A><A HREF="#-">-</A>------------------<A HREF="#&">&</A>#124;
<A HREF="#&#124;">&#124;</A>          SOFTWARE <A HREF="#&">&</A>#124;
<A HREF="#&#124;">&#124;</A> TECHNOLOGIES <A HREF="#INC">INC</A><A HREF="#.">.</A> <A HREF="#&">&</A>#124;
\<A HREF="#-">-</A>------------------<A HREF="#/">/</A>

<HR>

<B>July 1988</B>

No part of this publication may be copied, transmitted or stored in a retrieval
system or reproduced in any way including but not limited to photography,
photocopy, magnetic or other recording means, without prior written permission
from the publishers, with the exception of material entered and executed for
the reader's own use.

<B>Warranty</B>

All programs in this manual were written expressly to illustrate specific
training points, they are not warranted as being suitable for any particular
application. Every care has been taken in the writing and presentation of this
manual but no responsibility is assumed by the author or publishers for any
errors or omissions contained herein or any consequential loss suffered
therefrom.


<B>ISBN 1 85181 186 9</B>

<B>COPYRIGHT <A HREF="#&">&</A>#169; 1988 GFA Systemtechnik GmbH</B>

<B>Published in the U.S. by:</B>

                          <A HREF="#GFA_Software_Technologies,_Inc.">GFA Software Technologies, Inc.</A>
                          27 Congress St.
                          Salem, MA 01970
<HR SIZE=3><H2 ID="MichTron,_Inc.">MichTron, Inc.</H2>

                   <B>GFA BASIC 3.0</B>


Full Access, Structured BASIC Programming Language
              For the Atari ST Series


             Written By Frank Ostrowski
                 GFA Systemtechnik

           Published in the United States
                 By <A HREF="#MichTron,_Inc.">MichTron, Inc.</A>

                576 South Telegraph
                 Pontiac MI, 48053
                Tel: (313) 334-5700
                BBS: (313) 332-5452

<HR>

<B>GFA BASIC Interpreter Manual</B>


<B><A HREF="#&">&</A>#169; GFA Systemtechnik 1988</B>

All rights reserved, including those of translation, photographic reproduction,
and storage in a retrieval system.

Published in the U.S.A.
By <A HREF="#MichTron,_Inc.">MichTron, Inc.</A>
576 South Telegraph
Pontiac, MI 48053


     Program Author:  Frank Ostrowski
     Manual Authors:  Gottfried Engels, Markus G&#246;rgens, and Frank Ostrowski
        Book Design:  Thomas L. Logan
       Cover Design:  Paul Deckard
English Translation:  Jeff Little
          Edited By:  George Miller

<B>1st English Edition  August 1988</B>

88 89 90 10 9 8 7 6 5 4 3 2 1

<B>ISBN 0-944500-09-9</B>


Further Trademark and Copyright Notices:
<A HREF="#DEC">DEC</A>, VT, VT100, VT52, VT101, VT102, VT200, VT220 are registered trademarks of
  Digital Equipment Corporation.
GEM is a registered trademark of Digital Research Inc.
Atari, 520ST and 1040ST are registered trademarks of ATARI Corp.
MS DOS is a registered trademark of Microsoft.
D.E.G.A.S. is a registered trademark of Batteries Included.

Printed in the United States
<HR SIZE=3><H2 ID="Antic_Software">Antic Software</H2>

                  <B>GFA-BASIC 3.0</B>


Full Acess, Structured BASIC Programming Language
             For the Atari ST/Mega Series

            Published in the United States
                  by <A HREF="#Antic_Software">Antic Software</A>

<HR>

<B>GFA BASIC Interpreter Manual</B>


<B><A HREF="#&">&</A>#169; GFA Systemtechnik 1988</B>

All rights reserved, including those of translation, photographic reproduction,
and storage in a retrieval system.

Published in the U.S.A.
<A HREF="#Antic_Software">Antic Software</A>
544 Second Street
San Francisco, CA 94107
(415) 957-0886


     Program Author:  Frank Ostrowski
     Manual Authors:  Gottfried Engels, Markus G&#246;rgens, and Frank Ostrowski
        Book Design:  Thomas L. Logan
       Cover Design:  Paul Deckard
English Translation:  Jeff Little
          Edited By:  George Miller

<B>1st English Edition  August 1988</B>

88 89 90 10 9 8 7 6 5 4 3 2 1

<B>ISBN 0-944500-09-9</B>


Further Trademark and Copyright Notices:
<A HREF="#DEC">DEC</A>, VT, VT100, VT52, VT101, VT102, VT200, VT220 are registered trademarks of
  Digital Equipment Corporation.
GEM is a registered trademark of Digital Research Inc.
Atari, 520ST and 1040ST are registered trademarks of ATARI Corp.
MS DOS is a registered trademark of Microsoft.
D.E.G.A.S. is a registered trademark of Batteries Included.
Antic and <A HREF="#Antic_Software">Antic Software</A> are trademarks of Antic Publishing.

Printed in the United States
<HR SIZE=3><H2 ID="Chapter__1_-_Introduction">Chapter  1 - Introduction</H2>
With the release of <A HREF="#GFA-Basic">GFA-Basic</A> 3 one is provided with both an extensive
programming and powerful language which is easy to use via its quick and
friendly Editor. The entire framework and design of the language encourages
structured programming and provides the user with the necessary tools.

The Interpreter provides for simple debugging by means of the special commands
provided. <A HREF="#The_Editor">The Editor</A> supports structured programming by automatic indentation
of loops and conditions. Additionally, subroutines can be represented in the
program listing by name only, and 'opened' to their full length by pressing a
key.

In the area of conditional commands, various additions have been made to the
commands <A HREF="#IF">IF</A><A HREF="#-">-</A><A HREF="#ELSE">ELSE</A>-<A HREF="#ENDIF">ENDIF</A>, which already existed in earlier versions of <A HREF="#GFA-Basic">GFA-Basic</A>,
e.g. <A HREF="#ELSE_IF">ELSE IF</A>, <A HREF="#SELECT">SELECT</A><A HREF="#-">-</A><A HREF="#CASE">CASE</A>. Both the values of variables and the variables
themselves can be passed to procedures. Furthermore, the loop types <A HREF="#FOR">FOR</A><A HREF="#-">-</A><A HREF="#NEXT">NEXT</A>,
<A HREF="#REPEAT">REPEAT</A><A HREF="#-">-</A><A HREF="#UNTIL">UNTIL</A>, <A HREF="#WHILE">WHILE</A>-<A HREF="#WEND">WEND</A>, and <A HREF="#DO">DO</A>-<A HREF="#LOOP">LOOP</A> available in earlier versions of
<A HREF="#GFA-Basic">GFA-Basic</A> have been extended with <A HREF="#DO">DO</A><A HREF="#-">-</A><A HREF="#UNTIL">UNTIL</A>, DO-<A HREF="#WHILE">WHILE</A>, <A HREF="#LOOP">LOOP</A>-UNTIL, and
<A HREF="#LOOP">LOOP</A><A HREF="#-">-</A><A HREF="#WHILE">WHILE</A><A HREF="#.">.</A>

System level programming is achieved through the ability to call operating
system routines (<A HREF="#GEMDOS">GEMDOS</A>, <A HREF="#BIOS">BIOS</A>, <A HREF="#XBIOS">XBIOS</A>)<A HREF="#.">.</A> Many of these routines are also
available in the form of simple instructions. The programming of Interrupts
with <A HREF="#EVERY">EVERY</A> and <A HREF="#AFTER">AFTER</A> is also possible. Assembler and C routines may be
interleaved into programs with instructions like <A HREF="#RCALL">RCALL</A>, <A HREF="#C:">C:</A>, <A HREF="#CALL">CALL</A>, and <A HREF="#MONITOR">MONITOR</A><A HREF="#.">.</A>
The most important <A HREF="#VDI">VDI</A> routines and all <A HREF="#AES">AES</A> functions, e.g. menu and form
management, are available as built-in functions.

<A HREF="#GFA-Basic">GFA-Basic</A> provides genuine Integer arithmetic, which offers high computing
speed, as well as floating-point arithmetic with high computational accuracy
(13 decimal places), while further variable types <A HREF="#BYTE">BYTE</A>, <A HREF="#WORD">WORD</A>, and bit
operations <A HREF="#BCLR">BCLR</A><A HREF="#()">()</A>, <A HREF="#BSET">BSET</A>(), <A HREF="#BTST">BTST</A>(), <A HREF="#BCHG">BCHG</A>(), <A HREF="#SHL">SHL</A>(), <A HREF="#SHR">SHR</A>(), <A HREF="#ROL">ROL</A>(), <A HREF="#ROR">ROR</A>(), etc.,
have been included. Graphics programs can easily make use of the <A HREF="#Line-A">Line-A</A>
routines which are implemented as instructions.

<HR SIZE=3><H2 ID="About_This_Manual">About This Manual</H2>
<A NAME="avar"></A><A NAME="aexp"></A><A NAME="svar"></A><A NAME="sexp"></A><A NAME="ivar"></A><A NAME="iexp"></A><A NAME="bexp"></A>The manual begins with a short description of the <A HREF="#GFA-Basic">GFA-Basic</A> 3 programming
language, followed by an explanation of the manual structure and an
introduction to the use of the <A HREF="#GFA-Basic">GFA-Basic</A> Interpreter. It ends with a
description of the points which one must take note of when using programs which
were written in older versions of <A HREF="#GFA-Basic">GFA-Basic</A><A HREF="#.">.</A>

The next chapter describes the commands for the operation of the Editor. The
remaining chapters of the manual detail the instructions and facilities of
<A HREF="#GFA-Basic">GFA-Basic</A> 3.0. These are arranged according to criteria concerning the
contents, with joint explanations of related terms, e.g. <A HREF="#MIN">MIN</A><A HREF="#()">()</A> and <A HREF="#MAX">MAX</A>(). In
the <A HREF="#Appendix">Appendix</A> an alphabetical overview of the instructions and functions is
given, with references to the appropriate pages for full explanation.

Descriptions of Commands, etc. are laid out as follows:

    <A HREF="#&">&</A>#8226; The syntax
    <A HREF="#&">&</A>#8226; Description of the permissible parameter types
    <A HREF="#&">&</A>#8226; Explanatory text
    <A HREF="#&">&</A>#8226; Example

In the Syntax description optional parameters are indicated with square
brackets, e.g.

    <A HREF="#LEFT$">LEFT$</A>(a$[,x])

In <A HREF="#GFA-Basic">GFA-Basic</A> there are <A HREF="#Commands_and_Functions">Commands and Functions</A><A HREF="#.">.</A> Commands do not return a value,
e.g.

    <A HREF="#LINE">LINE</A> 100,100,200,200

Functions, on the other hand, do return a value and can display this value with
<A HREF="#PRINT">PRINT</A>, assign it to variables, etc. Here are some examples:

    <A HREF="#PRINT">PRINT</A> <A HREF="#ASC">ASC</A>("65")
    <A HREF="#PRINT">PRINT</A> <A HREF="#ASC">ASC</A>("a")
    a=<A HREF="#ASC">ASC</A>("a")
    b=<A HREF="#ASC">ASC</A>("a")+32

In this manual the fact that a Function returns a value is not noted in the
Syntax section, but is made clear in the explanation. In the Syntax section, in
the case of the function <A HREF="#ASC">ASC</A> for example, only ASC(a$) is specified and the
fact that this would be assigned to a numeric variable is not stated.

Where many optional parameters may be given, e.g. with the <A HREF="#DATA">DATA</A> statement, this
is shown by three periods:

    <A HREF="#DATA">DATA</A> x[,y,<A HREF="#.">.</A>..]

The description of permitted parameter types follows the Syntax section.  For
these types the following abbreviations are used:

<B><A HREF="#avar">avar</A>  Arithmetic variable</B>

This a numeric variable, which can be of any form, e.g. floating-point,
integer, boolean, etc.

<B><A HREF="#aexp">aexp</A>  Arithmetic expression</B>

This is any simple or complex expression which produces a number and can
include variables. Examples of arithmetic expressions are:

    a%
    3
    2+a%+<A HREF="#ASC">ASC</A>("a")

<B><A HREF="#svar">svar</A>  String variable</B>

This is a character string variable ending with <A HREF="#$">$</A>, e.g.<A HREF="#:">:</A>

    a$

<B><A HREF="#sexp">sexp</A>  String expression</B>

This expression can be of arbitrary complexity but must finally result in a
String. Examples of string expressions are:

    a$
    "Test"
    a$<A HREF="#+">+</A>"GFA BASIC"+<A HREF="#LEFT$">LEFT$</A>("MANUAL",4)

<B><A HREF="#ivar">ivar</A>  Integer variable</B>

This can be any integer variable.

<B><A HREF="#iexp">iexp</A>  Integer expression</B>

This is any simple or complex expression but the result must be an integer.

<B><A HREF="#bexp">bexp</A>  Boolean (logical) expression</B>

Any expression from which the result is a Boolean number.

It is important for some numerical expressions that particular variable types
must be used. The most important example of this is with memory addresses.
Addresses must be specified with at least a four byte variable and Boolean,
Byte, or Word variables are thus not allowed.

After the description of the parameter types comes the explanation of the
command. Here the meaning of the command and its individual parameters are
explained. The discussion of a command is terminated with one or more examples.
These examples are designed to be entered into the Editor and started with <A HREF="#RUN">RUN</A>
(shift+F10 or clicking <A HREF="#RUN">RUN</A> in the menu bar)<A HREF="#.">.</A> After each example the effect it
produces is given.

This form of command description is modified only in the section dealing with
the <A HREF="#AES">AES</A> library routines. Here the name of the appropriate command is given,
followed by the explanation of its function, then the syntax of the command
with the description of the individual parameters. At the end of the chapter
concerning the libraries several longer example programs are provided. The
reasoning behind this structure is that many commands in the chapter must be
used in correct conjunction with other commands, so that example programs tend
to contain many <A HREF="#AES">AES</A> calls and tend to be somewhat more extensive.

The manual concludes with a collection of tables and an alphabetical list of
all commands, with their page numbers.


<B>Note:</B> Where a program line is longer than the width of the page it has been
      wrapped round on the page and right justified. This will not happen
      when you are typing in the line, it will just extend to the right of
      the screen as far as necessary (up to 254 characters)<A HREF="#.">.</A>

<B>Memo:</B> The original manual claims a line can be up to 255 characters.
      That is incorrect.
<HR SIZE=3><H2 ID="Using_GFA-Basic_3_For_The_First_Time">Using GFA-Basic 3 For The First Time</H2>
This section is for those who have not used <A HREF="#GFA-Basic">GFA-Basic</A> before. Those who have
already worked with the older versions can just scan this section or, if
feeling very confident, jump to Chapter 2.

The <A HREF="#GFA-Basic">GFA-Basic</A> 3 Program disk is not copy-protected, so first make a back-up
copy of the orignal disk. You will find a description of how to do this in your
computer manual. Put the copy of the program disk in your disk drive and start
<A HREF="#GFA-Basic">GFA-Basic</A> by clicking on the icon.

After a short while, the Editor screen will appear, which is where you can
write and debug your programs. For now, enter the following program lines,
pressing Return at the end of each line. Do not omit the spaces, which serve to
separate adjacent keywords. The indenting of instructions within loops is done
automatically by the Editor, as is the capitalisation (or lack of it) when
Return is pressed.

    <A HREF="#DEFFILL">DEFFILL</A> 1,2,8
    <A HREF="#REPEAT">REPEAT</A>
      <A HREF="#WHILE">WHILE</A> <A HREF="#MOUSEK">MOUSEK</A>=1
        <A HREF="#PBOX">PBOX</A> <A HREF="#MOUSEX">MOUSEX</A>,<A HREF="#MOUSEY">MOUSEY</A>,MOUSEX+30,MOUSEY+30
      <A HREF="#WEND">WEND</A>
    <A HREF="#UNTIL">UNTIL</A> <A HREF="#MOUSEK">MOUSEK</A>=2

In the upper right corner of the screen you will find the word 'Run'<A HREF="#.">.</A> Point
with the mouse arrow to this word and press the left mouse button to start the
program.

Now a white screen appears, on which the mouse pointer is visible. If you now
press the left mouse button and move the mouse about, you can draw on the
screen. A rectangle is used as a 'brush'. Pressing the right mouse button
termimates the program and a box appears containing the message 'Program end'<A HREF="#.">.</A>
Point to the word 'Return' in this box and press the left mouse button to
return you to the Editor.

How does this program work? Drawing takes place with the instruction in the
center of the program. It draws filled rectangles, with the four parameters
specifying the corner points. The first instruction of the program (<A HREF="#DEFFILL">DEFFILL</A>
1,2,8) determines what pattern the rectangle is to be filled with.

Information about the mouse is contained in the built-in variables <A HREF="#MOUSEK">MOUSEK</A>,
<A HREF="#MOUSEX">MOUSEX</A>, and <A HREF="#MOUSEY">MOUSEY</A><A HREF="#.">.</A>

<A HREF="#MOUSEK">MOUSEK</A> determines which mouse button is being pressed. MOUSEK=1 means that the
left button was pressed and <A HREF="#MOUSEK">MOUSEK</A>=2 that the right button was pressed. <A HREF="#MOUSEX">MOUSEX</A>
and <A HREF="#MOUSEY">MOUSEY</A> return the x and y positions on the screen of the mouse arrow point.

The remaining commands (<A HREF="#REPEAT">REPEAT</A>, <A HREF="#WHILE">WHILE</A>, <A HREF="#WEND">WEND</A>, <A HREF="#UNTIL">UNTIL</A>) are loop instructions. The
loop formed with the commands <A HREF="#WHILE">WHILE</A> <A HREF="#MOUSEK">MOUSEK</A>=1 and <A HREF="#WEND">WEND</A> means 'repeat, as long as
the left mouse button is pressed'<A HREF="#.">.</A> The outside loop, made from the instructions
<A HREF="#REPEAT">REPEAT</A> and <A HREF="#UNTIL">UNTIL</A> <A HREF="#MOUSEK">MOUSEK</A>=2, means 'repeat, until the right mouse button is
pressed'<A HREF="#.">.</A>

Since there are no further instructions after the <A HREF="#UNTIL">UNTIL</A>, the program terminates
after leaving this loop. Move the cursor (with the arrow keys) to the beginning
of the line after the last and enter the following intentionally wrong program
line, in which the 'i' of the command word <A HREF="#PRINT">PRINT</A> is missing:

    prnt "test"

When you press the Return key to leave the line and confirm the instruction, a
bell sounds and on the second screen line the message 'Syntax error' appears.

<A HREF="#The_Editor">The Editor</A> checks during program entry whether the instructions entered are
syntactically correct. Now, with the cursor on the letter 'r', press the Delete
key three times. The program line should now contain only:

    p "test"

If the Return key is now pressed, then you can leave the line, as the letter p
is recognized automatically as an abbreviation for the command <A HREF="#PRINT">PRINT</A><A HREF="#.">.</A>

<HR SIZE=3><H2 ID="The_Editor">The Editor</H2>
<A NAME="Fundamentals"></A>The <A HREF="#GFA-Basic">GFA-Basic</A> 3.0 Editor is no usual text editor, but was specially designed
for program development. Syntactically wrong instructions are recognised at the
typing-in stage. In addition, commands are indented automatically in loops or
conditional sections and command names expanded from their abbreviations, e.g.
p expands to <A HREF="#PRINT">PRINT</A><A HREF="#.">.</A>

When writing a program a syntax check is carried out whenever the cursor leaves
the current line. If the line is not syntactically correct, then the message
'Syntax error' appears on the second line of the screen. It will only be
possible to move the cursor from the line by correcting the syntax or putting
an apostrophe at the beginning, thus converting it into a Comment.

Only one instruction per program line is allowed, but a comment may be added to
the end of a line by beginning the comment with an exclamation mark.

Program lines may he up to 255 characters long. When a line exceeds 80
characters in length it is scrolled horizontally to the left. When the cursor
leaves an instruction line a syntax check is done, correct indentation of the
line is carried out and the line is formatted. In addition, redundant spaces
are removed. e.g. '2 <A HREF="#+">+</A> 2' becomes '2+2', and the letters belonging to command
words and variable names are adjusted according to the current <A HREF="#DEFLIST">DEFLIST</A> setting.
The preset parameter <A HREF="#DEFLIST">DEFLIST</A> 0 causes all command words to he written in upper
case and all variable names in lower case.

<HR SIZE=3><H2 ID="The_Cursor_Keypad">The Cursor Keypad</H2>
Cursor control is by means of the block of arrow keys. The key settings are:
    Left arrow  <A HREF="#-">-</A> cursor moves one character to the left
    Right arrow <A HREF="#-">-</A> cursor moves one character to the right
    Up arrow    <A HREF="#-">-</A> cursor moves up one line
    Down arrow  <A HREF="#-">-</A> cursor moves down one line

The movements of the cursor are subject to certain restrictions. It can be
moved a maximum of one character beyond the last character in a line, and a
maximum of one line beyond the last line in a program. If the cursor enters a
line which is too short for the current cursor position, the cursor jumps to
the end of that line, otherwise it maintains its current column position (this
is different to the behaviour of the cursor in earlier versions of <A HREF="#GFA-Basic">GFA-Basic</A>)<A HREF="#.">.</A>
It also is possible to position the cursor with the mouse. To do this point the
mouse arrow to the desired place and click the left mouse button.

The Insert key inserts a blank line between the line the cursor is on and the
line above. The cursor is set to the beginning of this blank line.

Clr/Home moves the cursor to the upper left corner under the menu bar.
Control-Clr/Home jumps to the beginning of the program listing.

The Undo key will cancel any changes made in an edited line, provided that the
changes have not been confirmed by moving the cursor off that line.

With the <A HREF="#Help">Help</A> key, procedures or functions in the program listing can be
shortened to just their name ('folded')<A HREF="#.">.</A> This is done by moving the cursor to
the line with the word <A HREF="#PROCEDURE">PROCEDURE</A> or <A HREF="#FUNCTION">FUNCTION</A> on it and then pressing <A HREF="#Help">Help</A><A HREF="#.">.</A> A
<A HREF="#'">'</A><A HREF="#&#62;">&#62;</A>' character is placed at the beginning of the line to indicate that folding
has occurred. The procedure or function can be unfolded in the same way, or by
deleting the <A HREF="#'">'</A><A HREF="#&#62;">&#62;</A>'<A HREF="#.">.</A> Of course this does not affect the procedure or function in
the program itself, only as listed. This folding up of subroutines enables one
to create short clear listings in which one 'opens' only the subroutine on
which one is working.

A program with folded up procedures can look as follows. Note, that to call a
procedure in <A HREF="#GFA-Basic">GFA-Basic</A> 3 only the procedure name is used.

    init
    main_menu
    <A HREF="#'">'</A>
    <A HREF="#&#62;">&#62;</A> <A HREF="#PROCEDURE">PROCEDURE</A> init
    <A HREF="#&#62;">&#62;</A> <A HREF="#PROCEDURE">PROCEDURE</A> main_menu
    <A HREF="#&#62;">&#62;</A> <A HREF="#PROCEDURE">PROCEDURE</A> menu_list
    <A HREF="#&#62;">&#62;</A> <A HREF="#PROCEDURE">PROCEDURE</A> load
    <A HREF="#&#62;">&#62;</A> <A HREF="#PROCEDURE">PROCEDURE</A> store
    <A HREF="#&#62;">&#62;</A> <A HREF="#PROCEDURE">PROCEDURE</A> do_work
    <A HREF="#&#62;">&#62;</A> <A HREF="#PROCEDURE">PROCEDURE</A> fetch_info
    <A HREF="#&#62;">&#62;</A> <A HREF="#PROCEDURE">PROCEDURE</A> show_info
    <A HREF="#&#62;">&#62;</A> <A HREF="#FUNCTION">FUNCTION</A> test_info

With an opened procedure the program then appears as:

    init
    main_menu
    <A HREF="#'">'</A>
    <A HREF="#&#62;">&#62;</A> <A HREF="#PROCEDURE">PROCEDURE</A> init
    <A HREF="#&#62;">&#62;</A> <A HREF="#PROCEDURE">PROCEDURE</A> main_menu
    <A HREF="#&#62;">&#62;</A> <A HREF="#PROCEDURE">PROCEDURE</A> menu_list
    <A HREF="#PROCEDURE">PROCEDURE</A> load
      <A HREF="#FILESELECT">FILESELECT</A> "\<A HREF="#*">*</A>.RSC","",rsc_file$
      <A HREF="#IF">IF</A> <A HREF="#NOT">NOT</A> <A HREF="#EXIST">EXIST</A>(rsc_file$)
        <A HREF="#ALERT">ALERT</A> 1,"File does not exist <A HREF="#!">!</A>",1,"abort",r%
      <A HREF="#ELSE">ELSE</A>
        <A HREF="#IF">IF</A> <A HREF="#RSRC_LOAD">RSRC_LOAD</A>(rsc_file$)=0
          <A HREF="#ALERT">ALERT</A> 1,"Fault when loading the file <A HREF="#!">!</A>",1,"abort",r%
          <A HREF="#END">END</A>
        <A HREF="#ENDIF">ENDIF</A>
      <A HREF="#ENDIF">ENDIF</A>
    <A HREF="#RETURN">RETURN</A>
    <A HREF="#&#62;">&#62;</A> <A HREF="#PROCEDURE">PROCEDURE</A> store
    <A HREF="#&#62;">&#62;</A> <A HREF="#PROCEDURE">PROCEDURE</A> do_work
    <A HREF="#&#62;">&#62;</A> <A HREF="#PROCEDURE">PROCEDURE</A> fetch_info
    <A HREF="#&#62;">&#62;</A> <A HREF="#PROCEDURE">PROCEDURE</A> show_info
    <A HREF="#&#62;">&#62;</A> <A HREF="#FUNCTION">FUNCTION</A> test_info
<HR SIZE=3><H2 ID="The_Numeric_Keypad">The Numeric Keypad</H2>
The numeric keypad is normally used to input numbers and some other characters.
However, in addition it can, in combination with the Control key, perform the
following functions:

Control and 4  Cursor one character to the left
Control and 6  Cursor one caharacter to the right
Control and 8  Cursor one line up
Control and 2  Cursor one line down
Control and 7  Jump to start of program (control-home)
Control and 1  Jump to end of program (control-z)
Control and 9  Move one page up (control-up)
Control and 3  Move one page down (control-down)
Control and 0  Equivalent to pressing Insert
Control and <A HREF="#.">.</A>  Equivalent to pressing Delete
Control and <A HREF="#-">-</A>  Toggle mode of numeric keypad
Control and (  Same as <A HREF="#-">-</A>

The functions are similar to those obtained on a PC when NumLock is not on.
The numeric pad can also be switched to a mode in which the keys can be used
without having to press Control as well. The switch is made by pressing Control
and <A HREF="#'">'</A><A HREF="#-">-</A>' on the numeric pad, and indicated by a circumflex to the left of the
menu bar. This key combination acts as a toggle switching between modes each
time it is pressed.
<HR SIZE=3><H2 ID="The_Modifier_Keys">The Modifier Keys</H2>
These keys only work in the editor and only for the following commands:

<A HREF="#DIR">DIR</A>, <A HREF="#FILES">FILES</A>, <A HREF="#DUMP">DUMP</A>, and <A HREF="#TRON">TRON</A>

Right-Shift  Pause display (halts scrolling when held down)
Caps Lock    Slow motion (slows scrolling when On)

<B>Memo:</B> This information was missing from the original manual.
<HR SIZE=3><H2 ID="Further_Editing_Commands">Further Editing Commands</H2>
The Delete key deletes the character at the cursor position, the remainder or
the line being pulled to the left.

The Backspace key deletes the character to the left of the cursor.

The Tab key moves the cursor eight character positions to the right.

Control+Tab moves the cursor eight character positions to the left.

LeftShift+Tab inserts blank spaces to the next tab position.

RightShift+Tab deletes all blank spaces in one row up to or from cursor.

The Return or Enter keys move the cursor to the beginning of the next line.

The Escape key enters Direct Mode, in which you can type in commands.

<HR SIZE=3><H2 ID="Further_Control_Commands">Further Control Commands</H2>
Control-Delete       Deletes the line on which the cursor appears
Control-U            Restores a line deleted as above, or below (the line may
                     be restored several times <A HREF="#-">-</A> like copying)
Control-Y            Deletes the line on which the cursor appears
Control-N            Inserts a blank line as with the Insert key
Control-Q            Call block menu (like function key F4)
Control-B            Mark beginning of block (Block start)
Control-K            Mark end of block (Block end)
Control-R            Page up
Control-C            Page down
Control-E            Replace text
Shift-Control-E      Input text and find/replace it
Control-F            Find text
Shift-Control-F      Input text and find it
Control-left arrow   Cursor jumps to the beginning of the line
Control-right arrow  Cursor jumps to the end of the line
Control-up arrow     Page up
Control-down arrow   Page down
Control-Clr/Home     Jump to beginning of the program
Control-P            Deletes everthing to the right of the cursor
Control-O            Brings back the string deleted with Control-P and inserts
                     it at the cursor position. Perhaps it is difficult to
                     remember these combinations; We thought of:
                       P <A HREF="#=">=</A> Put line end into buffer
                       O <A HREF="#=">=</A> Output line from buffer
Control-Z            Jump to the end of the program
Control-Tab          Cursor jumps one tab position to the left
Control-G (goto)     Move to Line Number display (top right on Menu bar), then
                     enter line number
Control-A            Enter <A HREF="#ASCII">ASCII</A> code (up to 3 digits are accepted)
Control-S            Enter one character (bit #7 will be set)

A special group of Control commands makes the setting of 'Editor Marks'
possible. These marks are only meaningful to the Editor and have no effect on
the actual program. These marks can be set by Control-n, where n is a number on
the main keyboard. The cursor can be made to jump to a given mark by
simultaneously pressing Alternate and the appropriate number.

The key combinations of Alternate and the numbers 7-9 and 0 are preallocated.
They are as follows:

Alternate+7  Makes the cursor jump to the last cursor position before Direct
             mode or before a program was last Run.
Alternate+8  The cursor jumps to the line where the last error occured.
Alternate+9  Moves it to the position at which the last search procedure was
             started.
Alternate+0  Moves the cursor to the last cursor position at which a change
             was made.

<HR SIZE=3><H2 ID="The_Menu_Bar_and_Function_Keys">The Menu Bar and Function Keys</H2>
The items in the menu bar on the second and first screen lines are also
available via the function keys and Shift-function keys respectively.




On the far left of the menu bar is the Atari symbol (<A HREF="#&">&</A>#47;&#92;), clicking this
generates another menu containing the menu titles, Atari symbol and <A HREF="#GFA-Basic">GFA-Basic</A><A HREF="#.">.</A>
Clicking the Atari symbol causes an Alert box to appear, giving the title and
version number of <A HREF="#GFA-Basic">GFA-Basic</A> 3.xx and the two options Editor and Menu. Clicking
the Editor button returns you to the Editor, or clicking Menu brings you back
to the same menu.







The <A HREF="#GFA-Basic">GFA-Basic</A> Menu Bar contains the following items:

<B>Save</B>

A File Select box appears, by means of which the current program can be stored
by entering a program name and clicking on OK.

<B>Load</B>

A program can be similarly loaded into the Editor by clicking on the program
name and then clicking on OK.

<B>Deflist</B>

Makes possible the adjustment of the appearance of the program listing (see
<A HREF="#DEFLIST">DEFLIST</A> later on for details, or experiment)<A HREF="#.">.</A>

<B>New names</B>

By means of this item a mode can be set in which variable names are queried as
you introduce them into a program. This is useful as GFA-Baisc allows long
variable names, making typing errors possible. If you are editing a program and
do not mean to introduce new variables and you mis-type an existing name, this
feature will warn you.

<B>Editor</B>

Clicking this entry will return you to the editor.


On the right-hand side of the menu bar is a clock and the line number display.
The use of these two items is explained later on.

Under the Atari symbol there is a space for two further indicators, namely an
up-arrow character () to show when Caps Lock is active on the keyboard, and
the circumflex (<A HREF="#^">^</A>) showing when the numeric pad is used for cursor movements,
etc. These two modes can be entered and exited by clicking the mouse on the
space for the indicator (or the indicator itself if present)<A HREF="#.">.</A>

<B>Load (F1)</B>

The command load is used to load a <A HREF="#GFA-Basic">GFA-Basic</A> 3 program. This will be in
tokenised format, which enables programs to be loaded and saved quickly, using
less disk space. The extension <A HREF="#'">'</A>.GFA' will be looked for by default.

Earlier versions of <A HREF="#GFA-Basic">GFA-Basic</A> saved their programs using a different
tokenisation process. For these programs to be loaded into version 3 they must
first be saved, using the old <A HREF="#GFA-Basic">GFA-Basic</A>, in <A HREF="#ASCII">ASCII</A> format ('Save,A') and then
loaded into Version 3 with Merge. After that they can be stored in version 3
format with Save, and then Loaded as normal.

<B>Save (Shift+F1)</B>

A File Select box appears, in which the desired program name can be specified.
The extension <A HREF="#'">'</A>.GFA' will be added to the file name if no other is given. If a
file of that name already exists on the disk it will be renamed to <A HREF="#'">'</A>.BAK'.

<A NAME="==&#62;"></A><B>Merge (F2)</B>

With this command a file in <A HREF="#ASCII">ASCII</A> format can be inserted into the current
program, starting at the line above the cursor position. The default file
extension will be <A HREF="#'">'</A>.LST'. Syntax checking is also carried out during the
Merging process, but instead of interrupting with a Syntax error when an
uninterpretable line is encountered, the line will be prefixed with the
characters <A HREF="#'">'</A><A HREF="#==&#62;">==&#62;</A>', and must be fixed before the program can be Run.

<B>Save,A (Shift+F2)</B>

The current program will be stored in <A HREF="#ASCII">ASCII</A> format. The extension <A HREF="#'">'</A>.LST' will
be added to the filename if no other is specified. If a file with that name
already exists on the disk, it will be renamed to <A HREF="#'">'</A>.BAK'.

<A NAME="."></A><A NAME=".dot_commands"></A><A NAME=".LL"></A><A NAME=".PL"></A><A NAME=".FF"></A><A NAME=".HE"></A><A NAME=".FO"></A><A NAME=".LR"></A><A NAME=".L-"></A><A NAME=".L+"></A><A NAME=".Nx"></A><A NAME=".N0"></A><A NAME=".PA"></A><A NAME=".P-"></A><A NAME=".P+"></A><A NAME=".IN"></A><B>Llist (F3)</B>

This command causes the program to be printed out in the manner specified by
so-called Dot Commands within the program. They have no effect other than on
the printout, and are as follows, where 'x' represents a digit:

    <A HREF="#.LL">.LL</A> xx        Maximum line length
    <A HREF="#.PL">.PL</A> xx        Maximum page length
    <A HREF="#.FF">.FF</A> xxx       Form feed character (for printers, which have other
                  values than &H0C (Decimal 12)<A HREF="#.">.</A> (<A HREF="#.FF">.FF</A> 012 is the default)
    <A HREF="#.HE">.HE</A> head      Text to be put on the first line of each page
    <A HREF="#.FO">.FO</A> foot      Text to be put on the last line of each page
    <A HREF="#.LR">.LR</A> xx        Left margin
    <A HREF="#.L-">.L-</A>           Conditional printing: This instruction causes the following
                  lines not to be printed
    <A HREF="#.L+">.L+</A>           <A HREF="#Printing">Printing</A> starts again if it was stopped by a previous <A HREF="#.L-">.L-</A>
    .N1 to .N9    Switches on line numbering adjusted to occupy up to nine
                  character positions
    <A HREF="#.N0">.N0</A>           Switches off line numbering
    <A HREF="#.PA">.PA</A>           Forces a form feed
    <A HREF="#.P-">.P-</A>           The point commands are <A HREF="#NOT">NOT</A> listed
    <A HREF="#.P+">.P+</A>           The point commmands ARE listed, as usual
                  <A HREF="#.P+">.P+</A> and <A HREF="#.P-">.P-</A> influence the whole listing (like <A HREF="#.Nx">.Nx</A>), the last
                  command gives the effect
    <A HREF="#.IN">.IN</A> xxx       Printer initialization, a string that will be printed only
                  once at the beginning

In the header and footer text the following can also be inserted:

    \xxx          The <A HREF="#ASCII">ASCII</A> character xxx
    \d            Date (see <A HREF="#MODE">MODE</A>)
    \t            Time
    <A HREF="##">#</A>             Page number

<B>Note:</B> To print the symbols \ and <A HREF="##">#</A>, use <A HREF="#\\">\\</A> and \# respectively.

<B>Memo:</B> The <A HREF="#.dot_commands">.dot commands</A> are not case sensitive.
      A space after the command is optional.
      Syntax errors are silently ignored.
      There are 22 commands in all.
      Comments are not supported in <A HREF="#.dot_commands">.dot commands</A><A HREF="#.">.</A>
        Example: <A HREF="#'">'</A><A HREF="#.HE">.HE</A> header <A HREF="#!">!</A> test' will output 'header ! test'

<B>Quit (Shift-F3)</B>

After querying this command to make sure you are sure, <A HREF="#GFA-Basic">GFA-Basic</A> is exited
completely and normally you will be returned to the Desktop.

<B>Block (F4)</B>

If no block has been marked, then the message 'Block <A HREF="#?">?</A>??' appears on the second
line in order to indicate that a block command would be unreasonable. If,
however, a block has been marked, then the Block menu appears on the top line
of the screen. Items can then be chosen with the mouse, or by pressing the key
corresponding to the first letter of the command (except for block Delete,
which for safety is called from the keyboard by Control-D)<A HREF="#.">.</A>




<B>Copy</B>

Copies the block to the current cursor position. The block remains marked.

<B>Move</B>

Moves the block to the current cursor position. The block is then 'forgotten'
and no further block commands can be used until another is marked out.

<B>Write</B>  Stores the block as an <A HREF="#ASCII">ASCII</A> file (to be read via Merge)

<B>Llist</B>  Prints the block out

<B>Start</B>  Moves the cursor to the beginning of the block

<B>End</B>    Moves the cursor to the end of the block

<B>Del</B>    Deletes the block (Control-D)

<B>Hide</B>   Removes the block markers

Clicking the mouse outside the Block menu or pressing a key removes it, and the
original menu is restored.

Note: The oddly placed clock symbol in the block menu seems to be a typo or
      minor bug in the editor. It doesn't do anything.


<B>New (Shift-F4)</B>

The program currently in the Editor is deleted.

<B>BlkEnd (F5)</B>

The line before the cursor is marked as the end of a block. If the start of
block marker is located before this line, the block is shown in a different
color (or with a dotted background if a monochrome monitor is being used)<A HREF="#.">.</A> The
end of a block can also be marked by means of Control-K, without recourse to
the Block menu.

<B>BikSta (Shift-F5)</B>

Marks the beginning of a block as above. Control-B from the keyboard has the
same effect.

<B>Find (F6)</B>

A string of text can be input, which then becomes the object of a search
starting from the current cursor postion. If the string is found, the search
can be continued for another occurrence of the string with Control-F or
Control-L. When a string is found, the cursor is put at its position, or, if
not, at the end of the program. If Find is called again, the previous search
string is presented, which may be accepted with Return, deleted with Escape, or
edited with the cursor, delete and backspace keys. The command can also be
called directly by Shift-Control-F or Shift-Control-L.

You can use the Find function to search in the header rows of closed procedures
or functions.

<B>Procedures which have been 'folded' (see above) are not searched.</B>

<B>Replace (Shift-F6)</B>

This command is for replacing one string of text by another. First the user is
asked for the text to be replaced, then the replacement text. If the text to be
replaced is found, the cursor moves to the beginning of that line. The actual
replacement can be effected with Control-E, where upon another search is made
for further occurrences of the string to be replaced. The command can also be
called from the keyboard using Shift-Control-E. The editing facilities for the
strings are available as above.

<B>Again, 'folded' procedures and functions are not searched.</B>

<B>Pg  (F7)</B>

Scrolls the screen one page down. Also called via Control-C.

<B>Pg  (Shift-F7)</B>

Scrolls the screen one page upwards. Also called via Control-R.

<B>Insert/Overwr (F8)</B>

Switches between insert and overwrite modes.

<B>Txt 16/Text 8 (Shift-F8)</B>

This feature is available only if a monochrome monitor is being used. It refers
to the size of characters displayed on the screen. 16-pixel high characters
(default) allow 23 lines to be displayed at once on the screen. Using 8-pixel
high characters, 48 lines are displayed.

<B>Flip (F9)</B>

This command switches between the Edit and Output screens. Pressing any key or
a mouse button also switches from the Output to the Edit screen.

<B>Direct (Shift-F9)</B>

Switches to Direct Mode, in which commands are responded to immediately, e.g.
<A HREF="#PRINT">PRINT</A> "hello"<A HREF="#.">.</A> Some commands, e.g. loop commands, are not however available in
Direct Mode. This mode can also be reached by pressing the Escape key. In
addition, by use of the up and down arrow keys, the last eight commands entered
in Dircct Mode can be recalled, edited, entered, etc. The Undo key recalls the
last command. Direct Mode can only be entered when the syntax of the current
line in the Editor is correct.

Several lines of instructons can be executed from Direct Mode by writing them
as a procedure in Edit mode and then calling it from Direct Mode.

<B>Test (F10)</B>

Issuing this instruction causes all loops, subroutines and conditional
instructions to be checked for consistency without actually running the
program.

<B>Run (Shift-F10)</B>

The program currently in the Editor is started. If this program contains a
structural fault, of the kind that could have been found with Test above, then
an appropriate error message is displayed and the program is not started. A
running program can be interrupted by the 'Break key' combination,
Control-Shift-Alternate.

<B>The Line Number <A HREF="#&">&</A> Clock Displays</B>

The Line number display and the Clock on the right of the menu bar both react
when clicked with the mouse. In the case of the clock, the cursor moves to the
first hour digit, and the time can be set by typing in the new time and ending
with Return. The input can be edited with the Cursor and Backspace keys, or
pressing Escape aborts the process, leaving the time display as it was.

With the Line number display, the cursor moves there, and a number can be typed
in. Pressing Return causes the cursor to jump to that line number. Instead of
clicking on the Line number display, Control-G could be typed to produce the
same effect. Only numbers are accepted as the input and they can be edited with
the Escape, Cursor and Backspace keys as before.

<B>Memo:</B> The Merge funtion will stop loading if <A HREF="#ASCII">ASCII</A> character 4 (Control-D)
      is encountered. If you must use this character in your program it's best
      to refer to it with <A HREF="#CHR$">CHR$</A>(4)<A HREF="#.">.</A> Merge cannot read Unix format <A HREF="#ASCII">ASCII</A> files.

<HR SIZE=3><H2 ID="Special_Commands">Special Commands</H2>
<A HREF="#DEFBIT">DEFBIT</A>
<A HREF="#DEFBYT">DEFBYT</A>
<A HREF="#DEFWRD">DEFWRD</A>
<A HREF="#DEFINT">DEFINT</A>
<A HREF="#DEFFLT">DEFFLT</A> (<A HREF="#DEFSNG">DEFSNG</A>, <A HREF="#DEFDBL">DEFDBL</A>)
<A HREF="#DEFSTR">DEFSTR</A>
<A HREF="#DEFLIST">DEFLIST</A>
<A HREF="#$">$</A>
<A HREF="#.dot_commands">.dot commands</A>
<A HREF="#==&#62;">==&#62;</A>
<HR SIZE=3><H2 ID="DEFWRD">DEFWRD</H2>
<A NAME="DEFBIT"></A><A NAME="DEFBYT"></A><A NAME="DEFINT"></A><A NAME="DEFFLT"></A><A NAME="DEFSTR"></A><A NAME="DEFSNG"></A><A NAME="DEFDBL"></A><B><A HREF="#DEFBIT">DEFBIT</A> f$
<A HREF="#DEFBYT">DEFBYT</A> f$
<A HREF="#DEFWRD">DEFWRD</A> f$
<A HREF="#DEFINT">DEFINT</A> f$
<A HREF="#DEFFLT">DEFFLT</A> f$
<A HREF="#DEFSTR">DEFSTR</A> f$</B>

f$<A HREF="#:">:</A> string constant

The instruction DEFxxx facilitates variable declaration, where xxx is the
variable type, specified as follows:

These definitions will normally be declared at the beggining of a program, but
may be changed at any time. The post-fixed symbols will always override and
previous global definitions. The default variable type is floating-point.

The above definitions will have no effect on variables which are already in the
program, they only effect those which are still to be typed in.

<B><A HREF="#DEFBIT">DEFBIT</A></B>

<A HREF="#DEFBIT">DEFBIT</A> "b"
All variables beginning with the letter 'b' or post-fixed with '<A HREF="#!">!</A>' are declared
as Boolean (logical) variables.

<B><A HREF="#DEFBYT">DEFBYT</A></B>

<A HREF="#DEFBYT">DEFBYT</A> "by"
All variables beginning with the letterd 'by' or post-fixed with '<A HREF="#&#124;">&#124;</A>' ('rule'
character) are declared as 1-byte integers.

<B><A HREF="#DEFWRD">DEFWRD</A></B>

<A HREF="#DEFWRD">DEFWRD</A> "w"
All variables beginning with the letter 'w' or post-fixed with '<A HREF="#&">&</A>' are declared
as 2-byte signed integers.

<B><A HREF="#DEFINT">DEFINT</A></B>

<A HREF="#DEFINT">DEFINT</A> "i-k,m-p"
All variables beginning with letters 'i to k' and 'm to p', or post-fixed with
<A HREF="#'">'</A><A HREF="#%">%</A>' are declared as 4-byte integers.

<B><A HREF="#DEFFLT">DEFFLT</A></B>

<A HREF="#DEFFLT">DEFFLT</A> "x-z"
All variables beginning with letters 'x to z', or post-fixed with '<A HREF="##">#</A>' are
declared as 8-byte floating-point (the default variable type)<A HREF="#.">.</A>

Appearances of <A HREF="#DEFSNG">DEFSNG</A> or <A HREF="#DEFDBL">DEFDBL</A> will be replaced automatically in the Editor
with <A HREF="#DEFFLT">DEFFLT</A><A HREF="#.">.</A>

<B><A HREF="#DEFSTR">DEFSTR</A></B>

<A HREF="#DEFSTR">DEFSTR</A> "s,t"
All variables beginning with the letters 's' and 't', or post-fixed with '<A HREF="#$">$</A>'
are declared as character strings.

<HR SIZE=3><H2 ID="DEFLIST">DEFLIST</H2>
<B><A HREF="#DEFLIST">DEFLIST</A> n</B>

n: <A HREF="#iexp">iexp</A>

<A HREF="#DEFLIST">DEFLIST</A> determines the format of the program listing. The numerical expression
'n' can be a value between 0 and 11 (inclusive)<A HREF="#.">.</A> The effect of the instruction
on the listing is as follows:

<B>n   Command  Variable  Comment</B>
 0  <A HREF="#PRINT">PRINT</A>    abc       <A HREF="#!">!</A>
 1  Print    Abc       <A HREF="#!">!</A>
 2  <A HREF="#PRINT">PRINT</A>    abc#      <A HREF="#!">!</A>
 3  Print    Abc#      <A HREF="#!">!</A>
 4  <A HREF="#PRINT">PRINT</A>    abc       <A HREF="#//">//</A>
 5  Print    Abc       <A HREF="#//">//</A>
 6  <A HREF="#PRINT">PRINT</A>    abc#      <A HREF="#//">//</A>
 7  Print    Abc#      <A HREF="#//">//</A>
 8  <A HREF="#PRINT">PRINT</A>    abc       <A HREF="#/*">/*</A>
 9  Print    Abc       <A HREF="#/*">/*</A>
10  <A HREF="#PRINT">PRINT</A>    abc#      <A HREF="#/*">/*</A>
11  Print    Abc#      <A HREF="#/*">/*</A>

The default mode is <A HREF="#DEFLIST">DEFLIST</A> 0.

<B><A HREF="#DEFLIST">DEFLIST</A> 0</B>

Instructions and functions are represented in capitols. Variables, procedures,
and function names are in lower case.

<B><A HREF="#DEFLIST">DEFLIST</A> 1</B>

Instructions, functions, procedures, and variable names are represented with
the first letter in upper case, and the remainder in lower case.

<B><A HREF="#DEFLIST">DEFLIST</A> 2</B>

Same as <A HREF="#DEFLIST">DEFLIST</A> 0, except that variable type post-fix is added.

<B><A HREF="#DEFLIST">DEFLIST</A> 3</B>

Same as <A HREF="#DEFLIST">DEFLIST</A> 1, except that variable type post-fix is added.

<B><A HREF="#DEFLIST">DEFLIST</A> 4-7</B>

Same as <A HREF="#DEFLIST">DEFLIST</A> 0-3, except that the comment marker is <A HREF="#'">'</A><A HREF="#//">//</A>'<A HREF="#.">.</A>

<B><A HREF="#DEFLIST">DEFLIST</A> 8-11</B>

Same as <A HREF="#DEFLIST">DEFLIST</A> 0-3, except that the comment marker is <A HREF="#'">'</A><A HREF="#/*">/*</A>'<A HREF="#.">.</A>

<B>Memo:</B> The additional comment styles were not documented in my manual.
      <A HREF="#DEFLIST">DEFLIST</A> style breakdown:
      <B>Bit  Description</B>
      0    Capitalize commands and variables
      1    Show prefix for default variable type
      2    Display <A HREF="#'">'</A><A HREF="#//">//</A>' instead of '<A HREF="#!">!</A>'
      3    Display <A HREF="#'">'</A><A HREF="#/*">/*</A>' instead of '<A HREF="#!">!</A>'
      4-7  Ignored
<HR SIZE=3><H2 ID="$">$</H2>
<A NAME="$compiler_option"></A><A NAME="OPTION"></A><B>$text</B>

The command <A HREF="#$">$</A>, which is treated by the Interpreter lika a <A HREF="#REM">REM</A>, is used for the
control of the Compiler.

<B>Example:</B>

    $m16384

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The compiled program will only allocate 16k of memory.

<B>Memo:</B> For a list of compiler commands see section <A HREF="#'">'</A><A HREF="#The_Compiler_Options">The Compiler Options</A>'<A HREF="#.">.</A>
      <A HREF="#GFA-Basic">GFA-Basic</A> 2.0 had a different command for compiler control.
      The old command was <A HREF="#OPTION">OPTION</A> "text"<A HREF="#.">.</A>
      This seems to have been replaced by the $text command.

      Commands are not case sensitive.
      Commands may be seperated with commas or spaces.
      Commands can optionally be preceeded with a dollar sign.
      Comments are also allowed.
        Example: <A HREF="#$">$</A> m2048,s& S&#62; <A HREF="#$B+">$B+</A>    !this is a valid compiler command

      <A HREF="#The_Compiler">The Compiler</A> will accept almost anything in such a line. In fact it only
      reacts to correct compiler commands. Any incorrect compiler commands will
      be <B>silently</B> ignored. There is no easy way to detect incorrect
      compiler commands.
<HR SIZE=3><H2 ID="Chapter__2_-_Variables_and_Memory_Management">Chapter  2 - Variables and Memory Management</H2>
<A NAME="Variable_Types"></A><A NAME="&#124;"></A><A NAME="&"></A><A NAME="%"></A><A NAME="#"></A><B><A HREF="#Variable_Types">Variable Types</A></B>

<A HREF="#GFA-Basic">GFA-Basic</A> 3 allows the following variable types:

<B>Type     Postfix  Memory requirements       Range</B>
Boolean  <A HREF="#!">!</A>        1 byte (1 bit in arrays)  0 or -1 (<A HREF="#FALSE">FALSE</A> or <A HREF="#TRUE">TRUE</A>)
Byte     <A HREF="#&#124;">&#124;</A>        1 byte                    0 to 255
Word     <A HREF="#&">&</A>        2 bytes                   -32768 to 32767
Long     <A HREF="#%">%</A>        4 bytes                   -2147483648 to 2147483647
Float    <A HREF="##">#</A>        8 bytes                   2.225073858507E-308 to 3.595386269725E+308
String   <A HREF="#$">$</A>        0 to 32767 bytes          <A HREF="#ASCII">ASCII</A> value 0 to 255 for each character

<B>Boolean</B> (logical) variables can accept only the values 0 (<A HREF="#FALSE">FALSE</A>) or -1
(<A HREF="#TRUE">TRUE</A>)<A HREF="#.">.</A> If a non-zero value is assigned, then this value is taken as -1. This
variable type is designated by the postfix <A HREF="#'">'</A><A HREF="#!">!</A>', and occupies '1' byte of
memory. In boolean arrays elements require only one bit.

<B>Example:</B>

    b!<A HREF="#=">=</A><A HREF="#TRUE">TRUE</A>
    c!=x&#62;y

<B>Byte</B> variables can accept values between 0 and 255. Larger values will
provoke a "Number not byte" error. The postfix for this variable type is the
vertical rule character <A HREF="#'">'</A><A HREF="#&#124;">&#124;</A>'<A HREF="#.">.</A> As the name implies, this variable type occupies
one byte.

<B>Example:</B>

    x&#124;=128

<B>Word</B> variables are signed 2-byte integers. The postfix of this type is
<A HREF="#'">'</A><A HREF="#&">&</A>'<A HREF="#.">.</A> Numbers in the range from -32768 to 32767 can be represented. Outside
this range, a "Number not word" error occurs.

<B>Example:</B>

    x&=32767

<B>Long</B> variables are signed 4-byte integers with the postfix <A HREF="#'">'</A><A HREF="#%">%</A>'<A HREF="#.">.</A> Numbers
can be represented in the range from -2147483648 to 2147483647.

<B>Example:</B>

    x%=2000000000

<B>Float</B> variables are signed 8-byte floating point with the postfix <A HREF="#'">'</A><A HREF="##">#</A>'<A HREF="#.">.</A> The
range of representable numbers extends from 2.225073858507E-308 to
3.595386269725E+308. As this is the default type, no postfix is necessary. The
numerical accuracy is approximately 14 decimal places.

<B>Example:</B>

    x=123456789e123

<B>String</B> variables are designated by the postfix <A HREF="#'">'</A><A HREF="#$">$</A>'<A HREF="#.">.</A> They can have a
maximum length of 32767 characters. Strings are administered by means of a
so-called <A HREF="#descriptor">descriptor</A>, six bytes in length. The first 4 bytes contain the
address of the character string, the last 2 bytes contain the length of the
string. If a string contains and odd number of characters a zero filler byte is
added. The address of the <A HREF="#descriptor">descriptor</A> (Backtrailer) is also added.

<B>Example:</B>

    a$<A HREF="#=">=</A>"qwertyuiop"

The address of all variable types can be determined with the help of the
functions <A HREF="#VARPTR">VARPTR</A><A HREF="#()">()</A> (<A HREF="#V:">V:</A>) and <A HREF="#ARRPTR">ARRPTR</A>() (<A HREF="#*">*</A>)<A HREF="#.">.</A>

<B>Memo:</B> For more information on the internal storage of floats see page
      <A HREF="#'">'</A><A HREF="#GFA-Basic_v3_float_format">GFA-Basic v3 float format</A>'<A HREF="#.">.</A>

      There seems to be a difference between floats used in the Editor versus
      compiled. For example:
      f=2.5E+310
      <A HREF="#PRINT">PRINT</A> f
      <A HREF="#PRINT">PRINT</A> <A HREF="#STR$">STR$</A>(f)
      <A HREF="#The_Editor">The Editor</A> produces the expected result "2.5E+310" while the
      compiled version produces a different result "2.499999997857E+310".

      The book <A HREF="#'">'</A><A HREF="#GFA-Basic">GFA-Basic</A> Programmer's Reference Guide Volume I' (page 8)
      states a variable name can be up to 255 characters long.

      The <A HREF="#GFA-Basic">GFA-Basic</A> v2.x manual (page 47) states this about variable names:
      Names of variables must begin with a letter and can be any length
      (limited, of course by the length of a line)<A HREF="#.">.</A> After the first letter in
      the name, digits, underscore, and period are allowed. The full name is
      always used to distinguish between variables.

      Function names appear to follow the same rules as variable names.
      Label names however do not follow the same rules. See <A HREF="#GOTO">GOTO</A> for details.
      Procedure names appear to follow the same rules as labels.

      Notes on boolean!<A HREF="#()">()</A> arrays:
      These are not stored in the logical order as one might assume.
      Example:
          <A HREF="#DIM">DIM</A> b!(8)
          <A HREF="#ARRAYFILL">ARRAYFILL</A> b!<A HREF="#()">()</A>,<A HREF="#FALSE">FALSE</A>
          b!(0)<A HREF="#=">=</A><A HREF="#TRUE">TRUE</A>
          <A HREF="#PRINT">PRINT</A> <A HREF="#BIN$">BIN$</A>(<A HREF="#BYTE">BYTE</A>{V:b!(0)},8) !results <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> "00000001"
          <A HREF="#ARRAYFILL">ARRAYFILL</A> b!<A HREF="#()">()</A>,<A HREF="#FALSE">FALSE</A>
          b!(7)<A HREF="#=">=</A><A HREF="#TRUE">TRUE</A>
          <A HREF="#PRINT">PRINT</A> <A HREF="#BIN$">BIN$</A>(<A HREF="#BYTE">BYTE</A>{V:b!(0)},8) !results <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> "10000000"
      For speed reasons GFA stores them backwards. Thus accessing a boolean!<A HREF="#()">()</A>
      is not particularly useful unless this is the behaviour you expect.

      A signed byte is considered to be in the range of -128 to 127.

      The Motorola 68K series of processors use the <B>big-endian</B> format.
<HR SIZE=3><H2 ID="Arrays">Arrays</H2>
<A HREF="#DIM">DIM</A>, <A HREF="#DIM?">DIM?</A><A HREF="#()">()</A>
<A HREF="#OPTION_BASE">OPTION BASE</A>
<A HREF="#ARRAYFILL">ARRAYFILL</A>

All variable types can be used in arrays, or 'fields'<A HREF="#.">.</A> An array can be
dimensioned with <A HREF="#DIM">DIM</A>, or the size of an array can be determined with <A HREF="#DIM?">DIM?</A><A HREF="#()">()</A><A HREF="#.">.</A>

The management of arrays in memory is effected by means of Descriptors. A
<A HREF="#descriptor">descriptor</A> is a structure six bytes in length, the first four bytes of which
contain the address of the array. The next two bytes specify the number of
dimensions. The array field itself begins with sets of four bytes, giving the
number of elements in each dimension (beginning with the last dimension)
followed by the actual contents of the dimensions. With string arrays, instead
of the contents, the descriptors of the character strings follow the four
number-of-elements bytes. For example, after

    <A HREF="#DIM">DIM</A> a%(2,3)

*a%<A HREF="#()">()</A> gives the address of the array <A HREF="#descriptor">descriptor</A><A HREF="#.">.</A> The number of dimensions of
the array is in the last two bytes of the <A HREF="#descriptor">descriptor</A>, therefore

    <A HREF="#PRINT">PRINT</A> <A HREF="#DPEEK">DPEEK</A>(*a%<A HREF="#()">()</A>+4)

returns the value 2.

The array itself begins with the number of elements in the second dimension,
where the zeroth element is taken into account (assuming <A HREF="#OPTION_BASE">OPTION BASE</A> 0 is
valid), followed by the number of elements in the first dimension. Then

    <A HREF="#PRINT">PRINT</A> <A HREF="#LPEEK">LPEEK</A>(V:a%(0,0)-8)

returns the value 4.

    <A HREF="#PRINT">PRINT</A> <A HREF="#LPEEK">LPEEK</A>(V:a%(0,0)-4)

returns the value 3

Following this, the actual contents in the order:

a%(0,0), a%(1,0), a%(2,0), a%(0,1), a%(1,1), a%(2,1), etc.

<B>Memo:</B> For speed considerations when compiling one should read section
      <A HREF="#'">'</A><A HREF="#Array_Index_Checking">Array Index Checking</A>'<A HREF="#.">.</A>

      The library contains minor bugs which cause incorrect error messages.
      Error messages that don't work correctly at DIM:
        #14 'array dimensioned twice'
        #17 'dim <A HREF="#index">index</A> too large'
        It will appear to issue random error messages.
<HR SIZE=3><H2 ID="DIM">DIM</H2>
<A NAME="DIM?"></A><B><A HREF="#DIM">DIM</A> x(d1,[d2,<A HREF="#.">.</A>..]) [,y(d1,[d2,...])]
<A HREF="#DIM?">DIM?</A>(x())</B>

x, y: variable name (arbitrary variable type)
d1, d2: <A HREF="#iexp">iexp</A>

With the instruction <A HREF="#DIM">DIM</A> numerical and character string arrays can be declared.
The structure of such an array was explained in the introduction of this
section.

An array with one dimension is only limited by memory. <A HREF="#DIM">DIM</A> b&#124;(131072) would
use 128kb of ram.

Multi-dimensional arrays have two or more dimensions and follow different
rules. The possible number of the dimensions of the array is only limited by:

A) The dimensions must all be smaller than 65535
B) The product of the field elements must be smaller than 65535
C) The limit on the number of dimensions is 7

So <A HREF="#DIM">DIM</A> a%(100,10,10) is permitted, as all the dimensions and the product
of the field elements (100*10*10=10000) are both less than 65535.

In an array, only variables of the same type may exist. The type of array takes
precedence over the type of number put into it.

The function <A HREF="#DIM?">DIM?</A><A HREF="#()">()</A> determines the total number of elements in an array.

<B>Example:</B>

    <A HREF="#DIM">DIM</A> x(10)
    x(4)=3
    <A HREF="#PRINT">PRINT</A> x(<A HREF="#LEN">LEN</A>("test"))
    <A HREF="#PRINT">PRINT</A> <A HREF="#DIM?">DIM?</A>(x())
    <A HREF="#'">'</A>
    <A HREF="#DIM">DIM</A> y%(2,3)
    <A HREF="#PRINT">PRINT</A> <A HREF="#DIM?">DIM?</A>(y%<A HREF="#()">()</A>)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Two arrays are declared. The output on the screen consists of the
    numbers 3, 11, and 12.

<B>Memo:</B> <A HREF="#DIM">DIM</A> should not be used within a <A HREF="#FUNCTION">FUNCTION</A><A HREF="#.">.</A> It seems to clobber any
      <A HREF="#LOCAL">LOCAL</A> variables defined within the <A HREF="#FUNCTION">FUNCTION</A><A HREF="#.">.</A> See <A HREF="#'">'</A><A HREF="#The_local=FN_bug">The local=FN bug</A>'
      notes from the GFA Basic FAQ by Bo Leuf.

      <A HREF="#DIM">DIM</A> seems to crash the compiler if one attempts 8 dimensions:
      <A HREF="#DIM">DIM</A> a&(1,2,3,4,5,6,7,8) <A HREF="#&#60;">&#60;</A><A HREF="#-">-</A> causes the compiler to crash
      <A HREF="#DIM">DIM</A> a&(1,1,1,1,1,1,1,1) <A HREF="#&#60;">&#60;</A><A HREF="#-">-</A> runs ok in the editor!

      The limit of 65535 elements for multi-dimensional arrays doesn't work
      correctly:
      <A HREF="#DIM">DIM</A> x&#124;(800,800)   !no error issued
      <A HREF="#DIM">DIM</A> x&#124;(800,800,1) !error is issued

      How <A HREF="#DIM?">DIM?</A><A HREF="#()">()</A> works based on <A HREF="#OPTION">OPTION</A> BASE:
      <A HREF="#OPTION_BASE">OPTION BASE</A> 0
      <A HREF="#DIM">DIM</A> y%(2,3)<A HREF="#:">:</A> <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> 0-2,0-3 -<A HREF="#&">&</A>#62; 3*4=12
      <A HREF="#OPTION_BASE">OPTION BASE</A> 1
      <A HREF="#DIM">DIM</A> y%(2,3)<A HREF="#:">:</A> <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> 1-2,1-3 -<A HREF="#&">&</A>#62; 2*3=6
<HR SIZE=3><H2 ID="OPTION_BASE">OPTION BASE</H2>
<B><A HREF="#OPTION_BASE">OPTION BASE</A> n</B>

n: <A HREF="#iexp">iexp</A> (must be 0 or 1)

With the help of the command <A HREF="#OPTION_BASE">OPTION BASE</A> it can be decided whether an array is
to contain a zeroth element or not. With <A HREF="#OPTION_BASE">OPTION BASE</A> 0 (default) a zero-th
element is allocated, with <A HREF="#OPTION_BASE">OPTION BASE</A> 1 it is not, and the array starts with
element number 1.

The contents of fields are not changed by the <A HREF="#OPTION_BASE">OPTION BASE</A> instruction, however
the indices may be, as in the following:

<B>Example:</B>

    <A HREF="#DIM">DIM</A> x%(3)
    <A HREF="#FOR">FOR</A> i%=3 <A HREF="#DOWNTO">DOWNTO</A> 0
      x%(i%)=i%
      <A HREF="#PRINT">PRINT</A> i%,x%(i%)
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#'">'</A>
    <A HREF="#OPTION_BASE">OPTION BASE</A> 1
    <A HREF="#FOR">FOR</A> i%=3 <A HREF="#DOWNTO">DOWNTO</A> 0
      <A HREF="#PRINT">PRINT</A> i%,x%(i%)
    <A HREF="#NEXT">NEXT</A> i%

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> x%<A HREF="#()">()</A> is declared, by default including the zero-th element, and the
    elements are given the values 0-3 and printed. After <A HREF="#OPTION_BASE">OPTION BASE</A> 1, there
    is no longer a zero-th element, and accessing the element 3 actually
    accesses what was element 2, etc.

The program ends with an error message on attempting to access the no longer
valid zero-th element of the array.

<B>Memo:</B> <A HREF="#OPTION_BASE">OPTION BASE</A> 1 causes problems with compiled programs. The library
      contains a serious bug which renders <A HREF="#OPTION_BASE">OPTION BASE</A> 1 unreliable. Stick to
      <A HREF="#OPTION_BASE">OPTION BASE</A> 0 and everthing is fine.

<HR SIZE=3><H2 ID="ARRAYFILL">ARRAYFILL</H2>
<B><A HREF="#ARRAYFILL">ARRAYFILL</A> x(),y</B>

x: name of an array (numerical variable type)
y: <A HREF="#aexp">aexp</A>

The instruction <A HREF="#ARRAYFILL">ARRAYFILL</A> sets all elements of the array x() equal to the value
of the numerical expression y.

<B>Example:</B>

    <A HREF="#DIM">DIM</A> x(10)
    <A HREF="#PRINT">PRINT</A> x(4)
    <A HREF="#ARRAYFILL">ARRAYFILL</A> x(),5+1
    <A HREF="#PRINT">PRINT</A> x(4)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The first number printed is zero, because when an array is dimensioned all
    elements are automatically set to zero. After filling the array with 5+1's,
    the number 6 is printed on the screen.

<B>Note:</B> It is not possibie to use the <A HREF="#ARRAYFILL">ARRAYFILL</A> command with string arrays.

<B>Memo:</B> <A HREF="#ARRAYFILL">ARRAYFILL</A> does not generate an error for undimensioned arrays in the
      editor or compiled.

<HR SIZE=3><H2 ID="Matrix_Commands">Matrix Commands</H2>
System Commands
<A HREF="#MAT_BASE">MAT BASE</A>

Generating Commands
<A HREF="#MAT_CLR">MAT CLR</A>
<A HREF="#MAT_SET">MAT SET</A>
<A HREF="#MAT_ONE">MAT ONE</A>

Read and Write Commands
<A HREF="#MAT_READ">MAT READ</A>
<A HREF="#MAT_PRINT">MAT PRINT</A> (<A HREF="#MAT_?">MAT ?</A>)
<A HREF="#MAT_INPUT">MAT INPUT</A>

Copy and Transposition Commands
<A HREF="#MAT_CPY">MAT CPY</A>
<A HREF="#MAT_XCPY">MAT XCPY</A>
<A HREF="#MAT_TRANS">MAT TRANS</A>

Operation Commands
<A HREF="#MAT_ADD">MAT ADD</A> (<A HREF="#MAT">MAT</A>)
<A HREF="#MAT_SUB">MAT SUB</A>
<A HREF="#MAT_MUL">MAT MUL</A>
<A HREF="#MAT_NORM">MAT NORM</A>
<A HREF="#MAT_DET">MAT DET</A>
<A HREF="#MAT_QDET">MAT QDET</A>
<A HREF="#MAT_RANG">MAT RANG</A>
<A HREF="#MAT_INV">MAT INV</A>

Misc Commands
<A HREF="#MAT_ABS">MAT ABS</A>
<A HREF="#MAT_NEG">MAT NEG</A>

Linear operations with vectors and matrices.

All functions described in this chapter relate only to one and/or
two-dimensional fields with floating-point variables.

<B>Memo:</B> Some of the <A HREF="#MAT">MAT</A> commands can be stopped with break.
      However, do to a bug, most of them do not react to the break keys.
      <A HREF="#MAT_DET">MAT DET</A>
      <A HREF="#MAT_QDET">MAT QDET</A>
      <A HREF="#MAT_INV">MAT INV</A>
      <A HREF="#MAT_RANG">MAT RANG</A>
      <A HREF="#MAT_MUL">MAT MUL</A>
      <A HREF="#MAT_INPUT">MAT INPUT</A>
      <A HREF="#MAT_READ">MAT READ</A>
<HR SIZE=3><H2 ID="MAT_BASE">MAT BASE</H2>
<B><A HREF="#MAT_BASE">MAT BASE</A> n</B>

n: <A HREF="#iexp">iexp</A> (must be 0 or 1)

The <A HREF="#MAT_BASE">MAT BASE</A> command can only sensibly be used when <A HREF="#OPTION_BASE">OPTION BASE</A> 0 has been
activated. In this case, <A HREF="#MAT_BASE">MAT BASE</A> 1 can be used to set the offset for the start
of the row and column indexing of one or two-dimensional fields with floating
point variables to 1 for the matrix operations. <A HREF="#MAT_BASE">MAT BASE</A> 0 resets this offset
to 0 after a <A HREF="#MAT_BASE">MAT BASE</A> 1.

The setting made with <A HREF="#MAT_BASE">MAT BASE</A> n affects the following commands:

    <A HREF="#MAT_READ">MAT READ</A>
    <A HREF="#MAT_PRINT">MAT PRINT</A>
    <A HREF="#MAT_CPY">MAT CPY</A>
    <A HREF="#MAT_XCPY">MAT XCPY</A>
    <A HREF="#MAT_ADD">MAT ADD</A>
    <A HREF="#MAT_SUB">MAT SUB</A>
    <A HREF="#MAT_MUL">MAT MUL</A>

<B>Note:</B> The default is <A HREF="#MAT_BASE">MAT BASE</A> 1.

<B>Example:</B>

    <A HREF="#OPTION_BASE">OPTION BASE</A> 0
    <A HREF="#MAT_BASE">MAT BASE</A> 1
    <A HREF="#DATA">DATA</A> 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16
    <A HREF="#DIM">DIM</A> a(3,3)
    <A HREF="#MAT_READ">MAT READ</A> a()
    <A HREF="#PRINT">PRINT</A> a(1,1)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Outputs the value 1.
<HR SIZE=3><H2 ID="MAT_CLR">MAT CLR</H2>
<A NAME="MAT_SET"></A><A NAME="MAT_ONE"></A><B><A HREF="#MAT_CLR">MAT CLR</A> a()
<A HREF="#MAT_SET">MAT SET</A> a()=x
<A HREF="#MAT_ONE">MAT ONE</A> a()</B>

a: name of field with numeric variables
x: <A HREF="#aexp">aexp</A>

<A HREF="#MAT_CLR">MAT CLR</A> a() corresponds to <A HREF="#ARRAYFILL">ARRAYFILL</A> a(),0, i.e. the command sets all elements
in the field (matrix or vector) a() to a value of 0.

<A HREF="#MAT_SET">MAT SET</A> a()=x corresponds to an <A HREF="#ARRAYFILL">ARRAYFILL</A> a(),x, i.e. the command sets all
elements in the field (matrix or vector) a() to the value of x.

<A HREF="#MAT_ONE">MAT ONE</A> a() generates from a square matrix a() a uniform matrix, i.e. a square
martrix in which elements a(1,1), a(2,2), <A HREF="#.">.</A>.., a(n,n) are all equally 1 and all
other elements equally 0.

<B>Examples:</B>

    <A HREF="#DATA">DATA</A> 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16
    <A HREF="#DIM">DIM</A> a(3,3)
    <A HREF="#MAT_READ">MAT READ</A> a()
    <A HREF="#PRINT">PRINT</A> a(1,1)
    <A HREF="#MAT_CLR">MAT CLR</A> a()
    <A HREF="#PRINT">PRINT</A> a(1,1)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Outputs the value 1, then 0.

    <A HREF="#DIM">DIM</A> a(5,7)
    <A HREF="#FOR">FOR</A> i%=1 TO 5
      <A HREF="#FOR">FOR</A> j%=1 TO 7
        a(i%,j%)<A HREF="#=">=</A><A HREF="#RAND">RAND</A>(10)
      <A HREF="#NEXT">NEXT</A> j%
    <A HREF="#NEXT">NEXT</A> i%
    MEAT SET a(),5.3
    <A HREF="#FOR">FOR</A> i%=1 TO 5
      <A HREF="#FOR">FOR</A> j%=1 TO 7
        <A HREF="#PRINT">PRINT</A> a(i%,j%)
      <A HREF="#NEXT">NEXT</A> j%
    <A HREF="#NEXT">NEXT</A> i%

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Outputs the value '3.5' 35 times.

    <A HREF="#DIM">DIM</A> a(3,3)
    <A HREF="#MAT_ONE">MAT ONE</A> a()
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Outputs: 1,0,0
             0,1,0
             0,0,1
<HR SIZE=3><H2 ID="MAT_READ">MAT READ</H2>
<A NAME="MAT_PRINT"></A><A NAME="MAT_?"></A><A NAME="MAT_INPUT"></A><B><A HREF="#MAT_READ">MAT READ</A> a()
<A HREF="#MAT_PRINT">MAT PRINT</A> [#i,]a()[,g,n]
<A HREF="#MAT_INPUT">MAT INPUT</A> #i,a()</B>

i, g, n: <A HREF="#iexp">iexp</A>
a: name of field with numeric variables

<A HREF="#MAT_READ">MAT READ</A> a() reads a previously dimensioned matrix or vector from <A HREF="#DATA">DATA</A>
rows.

<B>Example:</B>

    <A HREF="#DATA">DATA</A> 1,2,3,4,5,6,7,8,9,10
    <A HREF="#DIM">DIM</A> a(2,5)
    <A HREF="#MAT_READ">MAT READ</A> a()
    <A HREF="#PRINT">PRINT</A> a(2,4)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Outputs the value 9.

<A HREF="#MAT_PRINT">MAT PRINT</A> [#i,]a()[,g,n] outputs a matrix or a vector. Vectors are output on
one row, the elements being separated by commas. With a matrix, each row is
followed by a rowfeed.

The output can optionally be redirected with #i, as with <A HREF="#PRINT">PRINT</A><A HREF="#.">.</A>

If g and n are specified, the numbers are formatted as with <A HREF="#STR$">STR$</A>(x,g,n)<A HREF="#.">.</A>

<B>Example:</B>

    <A HREF="#DATA">DATA</A> 1,2.33333,3
    <A HREF="#DATA">DATA</A> 7,5.25873,9.376
    <A HREF="#DATA">DATA</A> 3.23,7.2,8.999
    <A HREF="#DIM">DIM</A> a(3,3)
    <A HREF="#MAT_READ">MAT READ</A> a()
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()
    <A HREF="#PRINT">PRINT</A> "<A HREF="#-">-</A>----------------------"
    <A HREF="#MAT_PRINT">MAT PRINT</A> a(),7,3

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Outputs: 1,   2.33333, 3
             7,   5.24873, 9.376
             3.23 7.2,     8.999
             <A HREF="#-">-</A>------------------
             1.000, 2.333, 3.000
             7.000, 5.259, 9.376
             3.230, 7.200, 8.999

<A HREF="#MAT_INPUT">MAT INPUT</A> #1,a() reads a matrix or vector from a file in <A HREF="#ASCII">ASCII</A> format (the
format being the reverse of <A HREF="#MAT_PRINT">MAT PRINT</A>, commas and rowfeeds may be varied as
with <A HREF="#INPUT_#">INPUT #</A>)<A HREF="#.">.</A>

<B>Example:</B>

    <A HREF="#OPEN">OPEN</A> "o",#1,"Test.DAT"
    <A HREF="#DIM">DIM</A> a(3,3)
    <A HREF="#MAT_ONE">MAT ONE</A> a()
    <A HREF="#MAT_PRINT">MAT PRINT</A> #1,a()
    <A HREF="#CLOSE">CLOSE</A> #1
    <A HREF="#MAT_CLR">MAT CLR</A> a()
    <A HREF="#OPEN">OPEN</A> "i",#1,"Test.DAT"
    <A HREF="#MAT_INPUT">MAT INPUT</A> #1,a()
    <A HREF="#CLOSE">CLOSE</A> #1
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Outputs: 1,0,0
             0,1,0
             0,0,1

<B>Memo:</B> The statement <A HREF="#'">'</A><A HREF="#MAT_INPUT">MAT INPUT</A> a()' crashes the compiler!
      Perhaps the #channel is not suppose to be optional and the tokenizer
      fails to syntax check it correctly? The example above does not even work,
      so perhaps <A HREF="#MAT_INPUT">MAT INPUT</A> regardless of the parameters is just plain broken?

      <A HREF="#MAT_READ">MAT READ</A> fails in the editor with 'Out of data' but works compiled.

      <A HREF="#MAT_PRINT">MAT PRINT</A> a()      !works
      <A HREF="#MAT_PRINT">MAT PRINT</A> a(),g,n  !fails, always prints 0s
      <A HREF="#MAT_PRINT">MAT PRINT</A> works ok compiled.
<HR SIZE=3><H2 ID="MAT_CPY">MAT CPY</H2>
<A NAME="MAT_XCPY"></A><A NAME="MAT_TRANS"></A><B><A HREF="#MAT_CPY">MAT CPY</A> a([i,j])=b([k,l])[,h,w]
<A HREF="#MAT_XCPY">MAT XCPY</A> a([i,j])=b([k,l])[,h,w]
<A HREF="#MAT_TRANS">MAT TRANS</A> a()[=b()]</B>

a, b: name of fields with numerical variables
i, j, k, l, h, w: <A HREF="#iexp">iexp</A>

<A HREF="#MAT_CPY">MAT CPY</A> a([i,j])=b([k,l])[,h,w] copies h rows with w elements each from matrix
b to the row and column offset of matrix a defined by i,j, starting from the
row and column offset of matrix b defined by l,k.

<B>Example:</B>

    <A HREF="#DIM">DIM</A> a(5,5),b(4,4)
    <A HREF="#MAT_SET">MAT SET</A> a()=1
    <A HREF="#FOR">FOR</A> i%=1 TO 4
      <A HREF="#FOR">FOR</A> j%=1 TO 4
        b(i%,j%)=SUC(i%)
      <A HREF="#NEXT">NEXT</A> j%
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#'">'</A>
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()
    <A HREF="#PRINT">PRINT</A> "<A HREF="#-">-</A>--------"
    <A HREF="#MAT_PRINT">MAT PRINT</A> b()
    <A HREF="#PRINT">PRINT</A> "<A HREF="#-">-</A>--------"
    <A HREF="#MAT_CPY">MAT CPY</A> a(2,2)=b(2,2),3,3

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Outputs: 1,1,1,1,1
             1,1,1,1,1
             1,1,1,1,1
             1,1,1,1,1
             1,1,1,1,1
             <A HREF="#-">-</A>--------
             2,2,2,2
             3,3,3,3
             4,4,4,4
             5,5,5,5
             <A HREF="#-">-</A>--------
             1,1,1,1,1
             1,3,3,3,1
             1,4,4,4,1
             1,5,5,5,1
             1,1,1,1,1

<B><A HREF="#Special">Special</A> Cases</B>

<A HREF="#MAT_CPY">MAT CPY</A> a()=b() copies the complete matrix b into matrix a if the matrix are of
the same order.

Only those elements are copied in this process for which identical indices are
given in both the source and the destination matrix.

<B>Example:</B>

    <A HREF="#DIM">DIM</A> a(5,3),b(4,4)
    <A HREF="#MAT_SET">MAT SET</A> a()=1
    <A HREF="#FOR">FOR</A> i%=1 TO 4
      <A HREF="#FOR">FOR</A> j%=1 TO 4
        b(i%,j%)<A HREF="#=">=</A><A HREF="#SUCC">SUCC</A>(i%)
      <A HREF="#NEXT">NEXT</A> j%
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#'">'</A>
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()
    <A HREF="#PRINT">PRINT</A> "<A HREF="#-">-</A>------"
    <A HREF="#MAT_PRINT">MAT PRINT</A> b()
    <A HREF="#PRINT">PRINT</A> "<A HREF="#-">-</A>------"
    <A HREF="#MAT_CPY">MAT CPY</A> a()=b(),3,3
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Outputs: 1,1,1
             1,1,1
             1,1,1
             1,1,1
             1,1,1
             <A HREF="#-">-</A>------
             2,2,2,2
             3,3,3,3
             4,4,4,4
             5,5,5,5
             <A HREF="#-">-</A>------
             2,2,2
             3,3,3
             4,4,4
             1,1,1
             1,1,1

<A HREF="#MAT_CPY">MAT CPY</A> a(i,j)=b() copies matrix b, starting from the row and column offset
defined by <A HREF="#MAT_BASE">MAT BASE</A>, to the row and column offset of matrix a defined by i,j.
Only those elements are copied for which identical indices are given in both
the source and the destination matrix.

<B>Example:</B>

    <A HREF="#DIM">DIM</A> a(5,3),b(4,4)
    <A HREF="#MAT_SET">MAT SET</A> a()=1
    <A HREF="#FOR">FOR</A> i%=1 TO 4
      <A HREF="#FOR">FOR</A> j%=1 TO 4
        b(i%,j%)<A HREF="#=">=</A><A HREF="#SUCC">SUCC</A>(i%)
      <A HREF="#NEXT">NEXT</A> j%
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#'">'</A>
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()
    <A HREF="#PRINT">PRINT</A> "<A HREF="#-">-</A>------"
    <A HREF="#MAT_PRINT">MAT PRINT</A> b()
    <A HREF="#PRINT">PRINT</A> "<A HREF="#-">-</A>------"
    <A HREF="#MAT_CPY">MAT CPY</A> a(2,2)=b(2,2),3,3
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Outputs: 1,1,1
             1,1,1
             1,1,1
             1,1,1
             1,1,1
             <A HREF="#-">-</A>------
             2,2,2,2
             3,3,3,3
             4,4,4,4
             5,5,5,5
             <A HREF="#-">-</A>------
             1,1,1
             1,3,3
             1,4,4
             1,5,5
             1,1,1

<A HREF="#MAT_CPY">MAT CPY</A> a()=b(i,j) copies matrix b, starting from the row and column offset
defined by i,j, to the offset of matrix a defined by <A HREF="#MAT_BASE">MAT BASE</A><A HREF="#.">.</A> Only those
elements are copied for which identical indices are given in both the source
and the destination matrix.

<B>Example:</B>

    <A HREF="#DIM">DIM</A> a(5,3),b(4,4)
    <A HREF="#MAT_SET">MAT SET</A> a()=1
    <A HREF="#FOR">FOR</A> i%=1 TO 4
      <A HREF="#FOR">FOR</A> j%=1 TO 4
        b(i%,j%)<A HREF="#=">=</A><A HREF="#SUCC">SUCC</A>(i%)
      <A HREF="#NEXT">NEXT</A> j%
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#'">'</A>
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()
    <A HREF="#PRINT">PRINT</A> "<A HREF="#-">-</A>------"
    <A HREF="#MAT_PRINT">MAT PRINT</A> b()
    <A HREF="#PRINT">PRINT</A> "<A HREF="#-">-</A>------"
    <A HREF="#MAT_CPY">MAT CPY</A> a()=b(2,2),3,3
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Outputs: 1,1,1
             1,1,1
             1,1,1
             1,1,1
             1,1,1
             <A HREF="#-">-</A>------
             2,2,2,2
             3,3,3,3
             4,4,4,4
             5,5,5,5
             <A HREF="#-">-</A>------
             3,3,3
             4,4,4
             5,5,5
             1,1,1
             1,1,1

<A HREF="#MAT_CPY">MAT CPY</A> a(i,j)=b(k,l) copies matrix b, starting from the row and column offset
defined by k,l, to the offset i,j of matrix a. Only those elements are copied
for which identical indices are given in both the source and the destination
matrix.

<B>Example:</B>

    <A HREF="#DIM">DIM</A> a(5,3),b(4,4)
    <A HREF="#MAT_SET">MAT SET</A> a()=1
    <A HREF="#FOR">FOR</A> i%=1 TO 4
      <A HREF="#FOR">FOR</A> j%=1 TO 4
        b(i%,j%)<A HREF="#=">=</A><A HREF="#SUCC">SUCC</A>(j%)
      <A HREF="#NEXT">NEXT</A> j%
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#'">'</A>
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()
    <A HREF="#PRINT">PRINT</A> "<A HREF="#-">-</A>------"
    <A HREF="#MAT_PRINT">MAT PRINT</A> b()
    <A HREF="#PRINT">PRINT</A> "<A HREF="#-">-</A>------"
    <A HREF="#MAT_CPY">MAT CPY</A> a()=b()
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Outputs: 1,1,1
             1,1,1
             1,1,1
             1,1,1
             1,1,1
             <A HREF="#-">-</A>------
             2,3,4,5
             2,3,4,5
             2,3,4,5
             2,3,4,5
             <A HREF="#-">-</A>------
             1,1,1
             1,3,4
             1,3,4
             1,3,4
             1,1,1

<A HREF="#MAT_CPY">MAT CPY</A> a()=b() copies h rows with w elements each from the matrix b, starting
from the row and column offset defined by <A HREF="#MAT_BASE">MAT BASE</A>, the row and column offset
of matrix a defined by <A HREF="#MAT_BASE">MAT BASE</A><A HREF="#.">.</A> Only those elements are copied for which
identical indices are given in both the source and the destination matrix.

<B>Example:</B>

    <A HREF="#DIM">DIM</A> a(5,3),b(4,4)
    <A HREF="#MAT_SET">MAT SET</A> a()=1
    <A HREF="#FOR">FOR</A> i%=1 TO 4
      <A HREF="#FOR">FOR</A> j%=1 TO 4
        b(i%,j%)<A HREF="#=">=</A><A HREF="#SUCC">SUCC</A>(j%)
      <A HREF="#NEXT">NEXT</A> j%
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#'">'</A>
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()
    <A HREF="#PRINT">PRINT</A> "<A HREF="#-">-</A>------"
    <A HREF="#MAT_PRINT">MAT PRINT</A> b()
    <A HREF="#PRINT">PRINT</A> "<A HREF="#-">-</A>------"
    <A HREF="#MAT_CPY">MAT CPY</A> a(2,2)=b(2,2)
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Outputs: 1,1,1
             1,1,1
             1,1,1
             1,1,1
             1,1,1
             <A HREF="#-">-</A>------
             2,3,4,5
             2,3,4,5
             2,3,4,5
             2,3,4,5
             <A HREF="#-">-</A>------
             2,3,4
             2,3,4
             2,3,4
             2,3,4
             1,1,1

<A HREF="#MAT_XCPY">MAT XCPY</A> a([i,j])=b([k,l])[,h,w] works basically in the same manner as <A HREF="#MAT_CPY">MAT CPY</A>
a([i,j])=b([k,l])[,h,w], except that matrix b is being transposed while being
copied to matrix a, i.e. the rows and columns of matrix b are swapped while it
is copied to matrix a. Array b remains unchanged, however. Only those elements
are copied for which identical indices are given in both the source and the
destination matrix.

<B>Example:</B>

    <A HREF="#DIM">DIM</A> a(5,3),b(4,4)
    <A HREF="#MAT_SET">MAT SET</A> a()=1
    <A HREF="#FOR">FOR</A> i%=1 TO 4
      <A HREF="#FOR">FOR</A> j%=1 TO 4
        b(i%,j%)<A HREF="#=">=</A><A HREF="#SUCC">SUCC</A>(j%)
      <A HREF="#NEXT">NEXT</A> j%
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#'">'</A>
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()
    <A HREF="#PRINT">PRINT</A> "<A HREF="#-">-</A>------"
    <A HREF="#MAT_PRINT">MAT PRINT</A> b()
    <A HREF="#PRINT">PRINT</A> "<A HREF="#-">-</A>------"
    <A HREF="#MAT_XCPY">MAT XCPY</A> a(2,2)=b(2,2),3,3
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Outputs: 1,1,1
             1,1,1
             1,1,1
             1,1,1
             1,1,1
             <A HREF="#-">-</A>------
             2,3,4,5
             2,3,4,5
             2,3,4,5
             2,3,4,5
             <A HREF="#-">-</A>------
             1,1,1
             1,3,3
             1,4,4
             1,5,5
             1,1,1

<B>Further <A HREF="#Special">Special</A> Cases</B>

As with <A HREF="#MAT_CPY">MAT CPY</A> a(i,j)=b(k,l),w,h.

If <A HREF="#MAT_CPY">MAT CPY</A> or <A HREF="#MAT_XCPY">MAT XCPY</A> are applied to vectors, j and l may be ignored.
Following a <A HREF="#DIM">DIM</A> a(n),b(m), a() and b() are interpreted as row vectors, i.e. as
matrix of the (1,n) or (1,m) types.

For a and b to be treated as column vectors, they must be dimensioned as matrix
of the (n,1) or (m,1) type, ie. <A HREF="#DIM">DIM</A> a(n,1),b(n,1).

If both vectors are of the same order (both are row or column vectors), <A HREF="#MAT_CPY">MAT CPY</A>
must be used. Irrespective of the type of vectors a and b, <A HREF="#MAT_CPY">MAT CPY</A> always
treats both vectors syntactically as column vectors, so that the correct syntax
to be used for <A HREF="#MAT_CPY">MAT CPY</A> is always:

    <A HREF="#MAT_CPY">MAT CPY</A> a(n,1)=b(m,1)<A HREF="#!">!</A>

<B>Example:</B>

    <A HREF="#DIM">DIM</A> a(10),b(5) !a() and b() are row vectors
    <A HREF="#MAT_SET">MAT SET</A> a()=1
    <A HREF="#FOR">FOR</A> i%=1 TO 5
      b(i%)<A HREF="#=">=</A><A HREF="#SUCC">SUCC</A>(i%)
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#PRINT">PRINT</A> "a()<A HREF="#:">:</A> "<A HREF="#;">;</A>
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()
    <A HREF="#PRINT">PRINT</A> "b()<A HREF="#:">:</A> "<A HREF="#;">;</A>
    <A HREF="#MAT_PRINT">MAT PRINT</A> b()
    <A HREF="#PRINT">PRINT</A> <A HREF="#STRING$">STRING$</A>(45,"<A HREF="#-">-</A>")
    <A HREF="#MAT_CPY">MAT CPY</A> a(3,1)=b(1,1) !interprets a() and b() as column vectors
    <A HREF="#PRINT">PRINT</A> "<A HREF="#MAT_CPY">MAT CPY</A> a(3,1)=b(1,1)<A HREF="#:">:</A> "<A HREF="#;">;</A>
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Outputs: a(): 1,1,1,1,1,1,1,1,1,1
             b()<A HREF="#:">:</A> 2,3,4,5,6
             <A HREF="#-">-</A>-----------------------------------------
             <A HREF="#MAT_CPY">MAT CPY</A> a(3,1)=b(1,1)<A HREF="#:">:</A> 1,1,2,3,4,5,6,1,1,1

For <A HREF="#MAT_XCPY">MAT XCPY</A>, one of the two vectors a and b must be explicitly dimensioned as
a row vector, the other as a column vector. For example:

    <A HREF="#DIM">DIM</A> a(1,10),b(5,1)

Since <A HREF="#MAT_XCPY">MAT XCPY</A> first transposes the second vector before copying it to the
first. For this reason, <A HREF="#MAT_XCPY">MAT XCPY</A> can only be used for <A HREF="#DIM">DIM</A> a(1,n),b(m,1)<A HREF="#:">:</A>
a()=row vector, b()=column vector and <A HREF="#DIM">DIM</A> a(n,1),b(1,m)<A HREF="#:">:</A> a()=column vector,
b()=row vector.

<B>Example:</B>

    <A HREF="#DIM">DIM</A> a(1,10).n(5,1)
    <A HREF="#MAT_SET">MAT SET</A> a()=1
    <A HREF="#FOR">FOR</A> i%=1 TO 5
      b(i%,1)<A HREF="#=">=</A><A HREF="#SUCC">SUCC</A>(i%)
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#MAT_PRINT">MAT PRINT</A> b()
    <A HREF="#MAT_XCPY">MAT XCPY</A> a(1,3)=b(1,1)
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#MAT">MAT</A> PRINY a()

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Outputs: 1,1,1,1,1,1,1,1,1,1
             2
             3
             4
             5
             6
             1,1,2,3,4,5,6,1,1,1

Optionally, the parameters h and w can also be used when copying vectors with
<A HREF="#MAT_CPY">MAT CPY</A> or <A HREF="#MAT_XCPY">MAT XCPY</A><A HREF="#.">.</A> However, the following applies: with <A HREF="#MAT">MAT</A> CPY, only the h
parameter is used for w=<A HREF="#&">&</A>#62;1. No copying takes place with w=0.

With <A HREF="#MAT_XCPY">MAT XCPY</A>, only h is used for w=<A HREF="#&">&</A>#62;1 if b is a column vector to be copied
into a row vector after transposition. No copying takes place when w=0. On the
other hand, only w is used for h=<A HREF="#&">&</A>#62;1 if b is a row vector which is to be copied
to a column vector after transposition. In this case, no copying takes place if
h=0.

<A HREF="#MAT_TRANS">MAT TRANS</A> a()=b() copies the transposed from matrix b to matrix a if a and b
are dimensioned accordingly, i.e. the number of rows from a must correspond to
the number of columns in b, and the number of columns from a to the number of
rows of n: for example, <A HREF="#DIM">DIM</A> a(n,m),b(m,n)<A HREF="#.">.</A>

<B>Example:</B>

    <A HREF="#DIM">DIM</A> a(3,4),b(4,3)
    <A HREF="#MAT_SET">MAT SET</A> b()=4
    <A HREF="#MAT_SET">MAT SET</A> a()=1
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()
    <A HREF="#PRINT">PRINT</A> <A HREF="#STRING$">STRING$</A>(10,"<A HREF="#-">-</A>")
    <A HREF="#MAT_PRINT">MAT PRINT</A> b()
    <A HREF="#PRINT">PRINT</A> <A HREF="#STRING$">STRING$</A>(10,"<A HREF="#-">-</A>")
    <A HREF="#MAT_TRANS">MAT TRANS</A> a()=b()
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Outputs: 1,1,1,1
             1,1,1,1
             1,1,1,1
             <A HREF="#-">-</A>------
             4,4,4
             4,4,4
             4,4,4
             4,4,4
             <A HREF="#-">-</A>------
             4,4,4,4
             4,4,4,4
             4,4,4,4

In the case of a square matrix, i.e. one with equal numbers of rows and
columns, <A HREF="#MAT_TRANS">MAT TRANS</A> a() may be used. This command swaps the rows and columns of
matrix a and writes the matrix thus changed back to a.

The original matrix is lost in the process but can be restored with another <A HREF="#MAT">MAT</A>
TRANS a()<A HREF="#.">.</A>

<B>Example:</B>

    <A HREF="#DIM">DIM</A> a(5,5)
    <A HREF="#FOR">FOR</A> i%=1 TO 5
      <A HREF="#FOR">FOR</A> j%=1 TO 5
        a(i%,j%)=j%
      <A HREF="#NEXT">NEXT</A> j%
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()
    <A HREF="#PRINT">PRINT</A> <A HREF="#STRING$">STRING$</A>(10,"<A HREF="#-">-</A>")
    <A HREF="#MAT_TRANS">MAT TRANS</A> a()
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Outputs: 1,2,3,4,5
             1,2,3,4,5
             1,2,3,4,5
             1,2,3,4,5
             1,2,3,4,5
             <A HREF="#-">-</A>--------
             1,1,1,1,1
             2,2,2,2,2
             3,3,3,3,3
             4,4,4,4,4
             5,5,5,5,5
<HR SIZE=3><H2 ID="MAT_ADD">MAT ADD</H2>
<A NAME="MAT"></A><A NAME="MAT_SUB"></A><A NAME="MAT_MUL"></A><A NAME="MAT_NORM"></A><A NAME="MAT_DET"></A><A NAME="MAT_QDET"></A><A NAME="MAT_RANG"></A><A NAME="MAT_INV"></A><B><A HREF="#MAT_ADD">MAT ADD</A> a()=b()+c()
<A HREF="#MAT_ADD">MAT ADD</A> a(),b()
<A HREF="#MAT_ADD">MAT ADD</A> a(),x
<A HREF="#MAT_SUB">MAT SUB</A> a()=b()-c()
<A HREF="#MAT_SUB">MAT SUB</A> a(),b()
<A HREF="#MAT_SUB">MAT SUB</A> a(),x
<A HREF="#MAT_MUL">MAT MUL</A> a()=b()*c()
<A HREF="#MAT_MUL">MAT MUL</A> x=a()*b()
<A HREF="#MAT_MUL">MAT MUL</A> x=a()*b()*c()
<A HREF="#MAT_MUL">MAT MUL</A> a(),x
<A HREF="#MAT_NORM">MAT NORM</A> a(),0
<A HREF="#MAT_NORM">MAT NORM</A> a(),1
<A HREF="#MAT_DET">MAT DET</A> x=a([i,j])[,n]
<A HREF="#MAT_QDET">MAT QDET</A> x=a([i,j])[,n]
<A HREF="#MAT_RANG">MAT RANG</A> x=a([i,j])[,n]
<A HREF="#MAT_INV">MAT INV</A> a()=b()</B>

a, b, c: names of numerical floating point fields
x: <A HREF="#aexp">aexp</A> (scalar value)
i, j, n: <A HREF="#aexp">aexp</A>

<A HREF="#MAT_ADD">MAT ADD</A> a()=b()+c() is only defined for matrix (vectors) of the same order,
e.g. <A HREF="#DIM">DIM</A> a(n,m),b(m,m),c(n,m) or DIM a(n),b(n),c(n). Array c is added to matrix
b, element by element, and the result is written to matrix a.

<B>Example:</B>

    <A HREF="#DIM">DIM</A> a(3,5),b(3,5),c(3,5)
    <A HREF="#MAT_SET">MAT SET</A> b()=3
    <A HREF="#MAT_SET">MAT SET</A> c()=4
    <A HREF="#MAT_PRINT">MAT PRINT</A> b()
    <A HREF="#PRINT">PRINT</A> <A HREF="#STRING$">STRING$</A>(10,"<A HREF="#-">-</A>")
    <A HREF="#MAT_PRINT">MAT PRINT</A> c()
    <A HREF="#PRINT">PRINT</A> <A HREF="#STRING$">STRING$</A>(10,"<A HREF="#-">-</A>")
    <A HREF="#MAT_ADD">MAT ADD</A> a()=b()+c()
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Outputs: 3,3,3,3,3
             3,3,3,3,3
             3,3,3,3,3
             <A HREF="#-">-</A>--------
             4,4,4,4,4
             4,4,4,4,4
             4,4,4,4,4
             <A HREF="#-">-</A>--------
             7,7,7,7,7
             7,7,7,7,7
             7,7,7,7,7

<A HREF="#MAT_ADD">MAT ADD</A> a(),b() is only defined for matrix (vectors) of the same order, e.g.
<A HREF="#DIM">DIM</A> a(n,m),b(n,m) or DIM a(n),b(n)<A HREF="#.">.</A> Array b is added to matrix a, element by
element, and the result is written to matrix a. The original matrix a is lost
in the process.

<B>Example:</B>

    <A HREF="#DIM">DIM</A> a(3,5),b(3,5)
    <A HREF="#MAT_SET">MAT SET</A> a()=1
    <A HREF="#MAT_SET">MAT SET</A> b()=3
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()
    <A HREF="#PRINT">PRINT</A> <A HREF="#STRING$">STRING$</A>(10,"<A HREF="#-">-</A>")
    <A HREF="#MAT_PRINT">MAT PRINT</A> b()
    <A HREF="#PRINT">PRINT</A> <A HREF="#STRING$">STRING$</A>(10,"<A HREF="#-">-</A>")
    <A HREF="#MAT_ADD">MAT ADD</A> a(),b()
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Outputs: 1,1,1,1,1
             1,1,1,1,1
             1,1,1,1,1
             <A HREF="#-">-</A>--------
             3,3,3,3,3
             3,3,3,3,3
             3,3,3,3,3
             <A HREF="#-">-</A>--------
             4,4,4,4,4
             4,4,4,4,4
             4,4,4,4,4

<A HREF="#MAT_ADD">MAT ADD</A> a(),x is defined for all matrix (vectors)<A HREF="#.">.</A> Here, the scalar x is added
to matrix a, element by element, and the result is written to matrix a. The
original matrix a is lost in the process.

<B>Example:</B>

    <A HREF="#DIM">DIM</A> a(3,5)
    <A HREF="#MAT_SET">MAT SET</A> a()=1
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()
    <A HREF="#PRINT">PRINT</A> <A HREF="#STRING$">STRING$</A>(10,"<A HREF="#-">-</A>")
    <A HREF="#MAT_ADD">MAT ADD</A> A(),5
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Outputs: 1,1,1,1,1
             1,1,1,1,1
             1,1,1,1,1
             <A HREF="#-">-</A>--------
             6,6,6,6,6
             6,6,6,6,6
             6,6,6,6,6

<A HREF="#MAT_SUB">MAT SUB</A> a()=b()-c() is only defined for matrix (vectors) of the same order,
e.g. <A HREF="#DIM">DIM</A> a(n,m),b(n,m),c(n,m) or DIM a(n),b(n),c(n). Array c is subtracted from
matrix b, element by element, and the result is written to matrix a.

<B>Example:</B>

    <A HREF="#DIM">DIM</A> a(3,5),b(3,5),c(3,5)
    <A HREF="#MAT_SET">MAT SET</A> b()=5
    <A HREF="#MAT_SET">MAT SET</A> c()=3
    <A HREF="#MAT_PRINT">MAT PRINT</A> b()
    <A HREF="#PRINT">PRINT</A> <A HREF="#STRING$">STRING$</A>(10,"<A HREF="#-">-</A>")
    <A HREF="#MAT_PRINT">MAT PRINT</A> c()
    <A HREF="#PRINT">PRINT</A> <A HREF="#STRING$">STRING$</A>(10,"<A HREF="#-">-</A>")
    <A HREF="#MAT_SUB">MAT SUB</A> a()=b()-c()
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Outputs: 5,5,5,5,5
             5,5,5,5,5
             5,5,5,5,5
             <A HREF="#-">-</A>--------
             3,3,3,3,3
             3,3,3,3,3
             3,3,3,3,3
             <A HREF="#-">-</A>--------
             2,2,2,7,2
             2,2,2,2,2
             2,2,2,2,2

<A HREF="#MAT_SUB">MAT SUB</A> a(),b() is only defined for matrix (vectors) of the same order, e.g.
<A HREF="#DIM">DIM</A> a(n,m),b(n,m) or DIM a(n),b(n)<A HREF="#.">.</A> Array b is subtracted from matrix a,
element by element, and the result written to matrix a. The original matrix a
is lost in the process.

<B>Example:</B>

    <A HREF="#DIM">DIM</A> a(3,5),b(3,5)
    <A HREF="#MAT_SET">MAT SET</A> a()=3
    <A HREF="#MAT_SET">MAT SET</A> b()=1
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()
    <A HREF="#PRINT">PRINT</A> <A HREF="#STRING$">STRING$</A>(10,"<A HREF="#-">-</A>")
    <A HREF="#MAT_PRINT">MAT PRINT</A> b()
    <A HREF="#PRINT">PRINT</A> <A HREF="#STRING$">STRING$</A>(10,"<A HREF="#-">-</A>")
    <A HREF="#MAT_SUB">MAT SUB</A> a(),b()
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Outputs: 3,3,3,3,3
             3,3,3,3,3
             3,3,3,3,3
             <A HREF="#-">-</A>--------
             1,1,1,1,1
             1,1,1,1,1
             1,1,1,1,1
             <A HREF="#-">-</A>--------
             2,2,2,2,2
             2,2,2,2,2
             2,2,2,2,2

<A HREF="#MAT_SUB">MAT SUB</A> a(),x is defined for all matrix (vectors)<A HREF="#.">.</A> Here, the scalar x is
subtracted from matrix x, element by element, and the result is written to
matrix a. The original matrix a is lost in the process.

<B>Example:</B>

    <A HREF="#DIM">DIM</A> a(3,5)
    <A HREF="#MAT_SET">MAT SET</A> a()=6
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()
    <A HREF="#PRINT">PRINT</A> <A HREF="#STRING$">STRING$</A>(10,"<A HREF="#-">-</A>")
    <A HREF="#MAT_SUB">MAT SUB</A> A(),5
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Outputs: 6,6,6,6,6
             6,6,6,6,6
             6,6,6,6,6
             <A HREF="#-">-</A>--------
             1,1,1,1,1
             1,1,1,1,1
             1,1,1,1,1

<A HREF="#MAT_MUL">MAT MUL</A> a()=b()*c() is defined for matrix of an "appropriate" order.  <A HREF="#Arrays">Arrays</A> b
and c are multiplied with each other. The result of this multiplication is
written to matrix a. In order for the result to be defined, the matrix on the
left (matrix b in this case) must have the same number of columns as the matrix
on the right (c in this case) has rows.  Array a, in this case, must have as
many rows as b and as many columns as c, for example:

    <A HREF="#DIM">DIM</A> a(2,2),b(2,3),c(3,2)

<A HREF="#Arrays">Arrays</A> are multiplied as "row by column", i.e. element a(i,j) is obtained by
multiplying the elements in the ith row of matrix b with the elements in the
jth column of matrix c, element by element, and then adding up the individual
products.

<B>Example:</B>

    <A HREF="#DIM">DIM</A> a(2,2),b(2,3),c(3,2)
    <A HREF="#MAT_SET">MAT SET</A> b()=1
    <A HREF="#DATA">DATA</A> 1,2,-3,4,5,-1
    <A HREF="#MAT_READ">MAT READ</A> c()
    <A HREF="#MAT_PRINT">MAT PRINT</A> b(),5,1
    <A HREF="#PRINT">PRINT</A> <A HREF="#STRING$">STRING$</A>(18,"<A HREF="#-">-</A>")
    <A HREF="#MAT_PRINT">MAT PRINT</A> c(),5,1
    <A HREF="#PRINT">PRINT</A> <A HREF="#STRING$">STRING$</A>(18,"<A HREF="#-">-</A>")
    <A HREF="#MAT_MUL">MAT MUL</A> a()=b()*c()
    <A HREF="#MAT_PRINT">MAT PRINT</A> a(),5,1

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Outputs:  1.0,  1.0,  1.0
              1.0,  1.0,  1.0
             <A HREF="#-">-</A>-----------------
              1.0,  2.0
             -3.0,  4.0
              5.0, -1.0
             <A HREF="#-">-</A>-----------------
              3.0,  5.0
              3.0,  5.0

With vectors instead of matrix, <A HREF="#MAT_MUL">MAT MUL</A> a()=b()*c() results in the dyadic (or
external) product of two vectors.

<B>Example:</B>

    <A HREF="#DIM">DIM</A> a(3,3),b(3),c(3)
    <A HREF="#DATA">DATA</A> 1,2,-3,4,5,-1
    <A HREF="#MAT_READ">MAT READ</A> b()
    <A HREF="#MAT_READ">MAT READ</A> c()
    <A HREF="#MAT_PRINT">MAT PRINT</A> b(),5,1
    <A HREF="#PRINT">PRINT</A> <A HREF="#STRING$">STRING$</A>(18,"<A HREF="#-">-</A>")
    <A HREF="#MAT_PRINT">MAT PRINT</A> c(),5,1
    <A HREF="#PRINT">PRINT</A> <A HREF="#STRING$">STRING$</A>(18,"<A HREF="#-">-</A>")
    <A HREF="#MAT_MUL">MAT MUL</A> a()=b()*c()
    <A HREF="#MAT_PRINT">MAT PRINT</A> a(),5,1

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Outputs:   1.0,   2.0, -3.0
             <A HREF="#-">-</A>-----------------
               4.0,   5.0, -1.0
             <A HREF="#-">-</A>-----------------
               4.0,   5.0, -1.0
               5.0,  10.0, -2.0
             -12.0, -15.0,  3.0

<A HREF="#MAT_MUL">MAT MUL</A> x=a()*b() is only defined for vectors with an equal number of elements.
The result x is the scalar product (the so-called interior product) of vectors
a and b. The scalar product of two vectors is defined as the sum of n products
a(i)*b(i),i=1,<A HREF="#.">.</A>..,n.

<B>Example:</B>

    <A HREF="#DIM">DIM</A> b(3),c(3)
    <A HREF="#DATA">DATA</A> 1,2,-3,4,5,-1
    <A HREF="#MAT_READ">MAT READ</A> b()
    <A HREF="#MAT_READ">MAT READ</A> c()
    <A HREF="#MAT_PRINT">MAT PRINT</A> b(),5,1
    <A HREF="#PRINT">PRINT</A> <A HREF="#STRING$">STRING$</A>(18,"<A HREF="#-">-</A>")
    <A HREF="#MAT_PRINT">MAT PRINT</A> c(),5,1
    <A HREF="#PRINT">PRINT</A> <A HREF="#STRING$">STRING$</A>(18,"<A HREF="#-">-</A>")
    <A HREF="#MAT_MUL">MAT MUL</A> x=b()*c()
    <A HREF="#PRINT">PRINT</A> x

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Outputs: 1.0, 2.0, -3.0
             <A HREF="#-">-</A>-----------------
             4.0, 5.0, -1.0
             <A HREF="#-">-</A>-----------------
             17.0

<A HREF="#MAT_MUL">MAT MUL</A> x=a()*b()*c() is defined for qualified Vectors a and c as well as
qualified Matrix b()<A HREF="#.">.</A>

<B>Example:</B>

    <A HREF="#DIM">DIM</A> a(2).b(2,3),c(3)
    <A HREF="#DATA">DATA</A> 1,2,-3,4,5
    <A HREF="#MAT_READ">MAT READ</A> a()
    <A HREF="#MAT_READ">MAT READ</A> c()
    <A HREF="#MAT_SET">MAT SET</A> b()=1
    <A HREF="#MAT_PRINT">MAT PRINT</A> a(),5,1
    <A HREF="#PRINT">PRINT</A> <A HREF="#STRING$">STRING$</A>(18,"<A HREF="#-">-</A>")
    <A HREF="#MAT_PRINT">MAT PRINT</A> b(),5,1
    <A HREF="#PRINT">PRINT</A> <A HREF="#STRING$">STRING$</A>(18,"<A HREF="#-">-</A>")
    <A HREF="#MAT_PRINT">MAT PRINT</A> c(),5,1
    <A HREF="#PRINT">PRINT</A> <A HREF="#STRING$">STRING$</A>(18,"<A HREF="#-">-</A>")
    <A HREF="#MAT_MUL">MAT MUL</A> x=a()*b()*c()
    <A HREF="#PRINT">PRINT</A> x

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Outputs:  1.0,  2.0
             <A HREF="#-">-</A>-----------------
              1.0,  1.0,  1.0
              1.0,  1.0,  1.0
              1.0,  1.0,  1.0
             <A HREF="#-">-</A>-----------------
             -3.0,  4.0,  5.0
             <A HREF="#-">-</A>-----------------
             18.0

<A HREF="#MAT_NORM">MAT NORM</A> a(),0 or <A HREF="#MAT">MAT</A> NORM a(),1 are defined for matrix and vectors. MAT NORM
a(),0 normalises a matrix (a vector) by rows, <A HREF="#MAT_NORM">MAT NORM</A> a(),1 by columns. This
means that after a normalisation by rows (by columns) the sum of the squares of
all elements in each row (column) is identical at 1.

<B>Example:</B>

    <A HREF="#DIM">DIM</A> a(10,10),b(10,10),v(10)
    <A HREF="#DATA">DATA</A> 1,2,3,4,5,6,7,8,9,-1
    <A HREF="#DATA">DATA</A> 3.2,4,-5,2.4,5.1,6.2,7.2,8.1,6,-5
    <A HREF="#DATA">DATA</A> -2,-5,-6,-1.2,-1.5,-6.7,4.5,8.1,3.4,10
    <A HREF="#DATA">DATA</A> 5,-2.3,4,5.6,12.2,18.2,14.1,16,-21,-13
    <A HREF="#DATA">DATA</A> 4.1,5.2,16.7,18.4,19.1,20.2,13.6,14.8,19.4,18.6
    <A HREF="#DATA">DATA</A> 15.2,-1.8,13.6,-4.9,5.4,19.8,16.4,-20.9,21.4,13.8
    <A HREF="#DATA">DATA</A> -3.6,6,-8.2,-9.1,4,-2.5,2,3.4,6.7,8.4
    <A HREF="#DATA">DATA</A> 4.7,8.3,9.4,10.5,11,19,15.4,18.9,-20,12.6
    <A HREF="#DATA">DATA</A> 5.3,-4.7,6.1,6.5,6.9,-9.2,-10.8,4.3,5.6,9.1
    <A HREF="#DATA">DATA</A> 21.4,19.5,28.4,19.3,24.6,14.9,71.3,23.5,14.5,-12.3
    <A HREF="#'">'</A>
    <A HREF="#CLS">CLS</A>
    <A HREF="#MAT_READ">MAT READ</A> a()
    <A HREF="#MAT_CPY">MAT CPY</A> b()=a() !Source matrix stored
    <A HREF="#PRINT">PRINT</A> "Source matrix"
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#MAT_PRINT">MAT PRINT</A> a(),7,2
    <A HREF="#~">~</A><A HREF="#INP">INP</A>(2)
    <A HREF="#CLS">CLS</A>
    <A HREF="#MAT_NORM">MAT NORM</A> a(),0
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#PRINT">PRINT</A> "Row:"
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#MAT_PRINT">MAT PRINT</A> a(),7,2
    <A HREF="#~">~</A><A HREF="#INP">INP</A>(2)
    <A HREF="#'">'</A>
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#PRINT">PRINT</A> "Test:"
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#FOR">FOR</A> i%=1 TO 10
      <A HREF="#MAT_XCPY">MAT XCPY</A> v()=a(i%,1)
      <A HREF="#MAT_MUL">MAT MUL</A> x=v()*v()
      <A HREF="#PRINT">PRINT</A> x'
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#~">~</A><A HREF="#INP">INP</A>(2)
    <A HREF="#'">'</A>
    <A HREF="#CLS">CLS</A>
    <A HREF="#MAT_CPY">MAT CPY</A> a()=b()
    <A HREF="#MAT_NORM">MAT NORM</A> a(),1
    <A HREF="#PRINT">PRINT</A> "Column:"
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#MAT_PRINT">MAT PRINT</A> a(),7,2
    <A HREF="#~">~</A><A HREF="#INP">INP</A>(2)
    <A HREF="#'">'</A>
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#PRINT">PRINT</A> "Test:"
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#FOR">FOR</A> i%=1 TO 10
      <A HREF="#MAT_CPY">MAT CPY</A> v()=a(1,i%) !Copy column a() in the vector v()
      <A HREF="#MAT_MUL">MAT MUL</A> x=v()*v()
      <A HREF="#PRINT">PRINT</A> x'
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#~">~</A><A HREF="#INP">INP</A>(2)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Outputs:
    Source matrix

     1.00,  2.00,  3.00,  4.00,  5.00,  6.00,   7.00,   8.00,   9.00,  -1.00
     3.20,  4.00, -5.00,  2.40,  5.10,  6.20,   7.20,   8.10,   6.00,  -5.00
    -2.00, -5.00, -6.00, -1.20, -1.50, -6.70,   4 50,   8.10,   3.40,  10.00
     5.00, -2.30,  4.00,  5.60, 12.20, 18.20,  14.10,  16.00, -21.00, -13.00
     4.10,  5.20, 16.70, 18.40, 19.10, 20.20,  13.60,  14.80,  19.40,  18.60
    15.20, -1.80, 13.60, -4.90,  5.40, 19.80,  16.40, -20.90,  21.40,  13.80
    -3.60,  6.00, -8.20, -9.10,  4.00, -2.50,   2.00,   3.40,   6.70,   8.40
     4.70,  8.30,  9.40, 10.50, 11.00, 19.00,  15.40,  18.90, -20.00,  12.60
     5.30, -4.70,  6.10,  6.50,  6.90, -9.20, -10.80,   4.30,   5.60,   9.10
    21.40, 19.50, 28.40, 19.30, 24.60, 14.90,  71.30,  23.50,  14.50, -12.30

    Row:

     0.06,  0.12,  0.18,  0.24,  0.30,  0.35,  0.41,  0.47,  0.53, -0.06
     0.18,  0.23, -0.29,  0.14,  0.29,  0.36,  0.42,  0.47,  0.35, -0.29
    -0.11, -0.28, -0.34, -0.07, -0.09, -0.38,  0.26,  0.46,  0.19,  0.57
     0.12, -0.06,  0.10,  0.14,  0.30,  0.45,  0.35,  0.40, -0.52, -0.32
     0.08,  0.10,  0.33,  0.36,  0.38,  0.40,  0.27,  0.29,  0.38,  0.37
     0.32, -0.04,  0.29, -0.10,  0.11,  0.42,  0.35, -0.44,  0.45,  0.29
    -0.19,  0.32, -0.44, -0.48,  0.21, -0.13,  0.11,  0.18,  0.36,  0.45
     0.11,  0.19,  0.21,  0.24,  0.25,  0.43,  0.35,  0.43, -0.46,  0.29
     0.23, -0.21,  0.27,  0.29,  0.31, -0.41, -0.48,  0.19,  0.25,  0.40
     0.23,  0.21,  0.30,  0.21,  0.26,  0.16,  0.76,  0.25,  0.15, -0.13

    Test:

    1 1 1 1 1 1 1 1 1 1

    Columns:

     0.04,  0.08,  0.08,  0.12,  0.13,  0.14,  0.09,  0.18,  0.20, -0.03
     0.11,  0.16, -0.13,  0.07,  0.14,  0.14,  0.09,  0.18,  0.13, -0.14
    -0.07, -0.21, -0.15, -0.04, -0.04, -0.15,  0.06,  0.18,  0.07,  0.28
     0.18, -0.09,  0.10,  0.17,  0.33,  0.41,  0.18,  0.35, -0.46, -0.36
     0.14,  0.21,  0.42,  0.57,  0.51,  0.46,  0.17,  0.33,  0.42,  0.52
     0.53, -0.07,  0.35, -0.15,  0.15,  0.45,  0.21, -0.46,  0.47,  0.38
    -0.13,  0.25, -0.21, -0.28,  0.11, -0.06,  0.03,  0.08,  0.15,  0.23
     0.17,  0.34,  0.24,  0.33,  0.30,  0.43,  0.20,  0.42, -0.44,  0.35
     0.19, -0.19,  0.15,  0.20,  0.19, -0.21, -0.14,  0.10,  0.12,  0.25
     0.75,  0.80,  0.72,  0.60,  0.66,  0.34,  0.90,  0.52,  0.32, -0.34

    Test:

    1 1 1 1 1 1 1 1 1 1

<A HREF="#MAT_DET">MAT DET</A> x=a([i,j])[,n] calculates the determinants of a square matrix of the
(n,n) type. The row and column offsets are preset to a(0,0) or a(1,1),
depending on <A HREF="#MAT_BASE">MAT BASE</A> 0 or <A HREF="#MAT">MAT</A> BASE 1, assuming that <A HREF="#OPTION_BASE">OPTION BASE</A> 1 is enabled.
It is also possible, however, to calculate the determinant of a square part
matrix. To do this, the row and column offsets of a() must be specified as i
and j, and the number of elements in the part matrix as n. A part matrix of the
(n,n) type is then created internally starting from the "position" ith row, jth
column.

<B>Example:</B>

    <A HREF="#DIM">DIM</A> a(10,10),b(4,4)
    <A HREF="#DATA">DATA</A> 1,2,3,4,5,6,7,8,9,-1
    <A HREF="#DATA">DATA</A> 3.2,4,-5,2.4,5.1,6.2,7.2,8.1,6,-5
    <A HREF="#DATA">DATA</A> -2,-5,-6,-1.2,-1.5,-6.7,4.5,8.1,3.4,10
    <A HREF="#DATA">DATA</A> 5,-2.3,4,5.6,12.2,18.2,14.1,16,-21,-13,3.8
    <A HREF="#DATA">DATA</A> 4.1,5.2,16.7,18.4,19.1,20.2,13.6,14.8,19.4,18.6
    <A HREF="#DATA">DATA</A> 15.2,-1.8,13.6,-4.9,5.4,19.8,16.4,-20.9,21.4,13.8
    <A HREF="#DATA">DATA</A> -3.6,6,-8.2,-9.1,4,-2.5,2,3.4,6.7,8.4,10.9
    <A HREF="#DATA">DATA</A> 4.7,8.3,9.4,10.5,11,19,15.4,18.9,-20,12.6
    <A HREF="#DATA">DATA</A> 5.3,-4.7,6.1,6.5,6.9,-9.2,-10.8,4.3,5.6,9.1
    <A HREF="#DATA">DATA</A> 21.4,19.5,28.4,19.3,24.6,14.9,71.3,23.5,14.5,-12.3
    <A HREF="#'">'</A>
    <A HREF="#CLS">CLS</A>
    <A HREF="#MAT_READ">MAT READ</A> a()
    <A HREF="#PRINT">PRINT</A> "Source matrix"
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#MAT_PRINT">MAT PRINT</A> a(),7,2
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#PRINT">PRINT</A> "Determinant: "<A HREF="#;">;</A>
    <A HREF="#MAT_DET">MAT DET</A> x=a()
    <A HREF="#PRINT">PRINT</A> x;
    <A HREF="#MAT_DET">MAT DET</A> y=a(1,4),4
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#PRINT">PRINT</A> "Determinant from a(1,4),4: "<A HREF="#;">;</A>
    <A HREF="#PRINT">PRINT</A> y
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#PRINT">PRINT</A> "Test: "
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#MAT_CPY">MAT CPY</A> b()=a(1,4),4,4 !copy to b()
    <A HREF="#MAT_PRINT">MAT PRINT</A> b(),7,2
    <A HREF="#MAT_DET">MAT DET</A> z=b() !Determinant from b()
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#PRINT">PRINT</A> z

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Outputs:
    Source Matrix

       1.00,  2.00,  3.00,  4.00,  5.00,  6.00,  7.00,  8.00,   9.00,  -1.00
       3.20,  4.00, -5.00,  2.40,  5.10,  6.20,  7.20,  8.10,   6.00,  -5.00
      -2.00, -5.00, -6.00, -1.20, -1.50, -6.70,  4.50,  8.10,   3.40,  10.00
       5.00, -2.30,  4.00,  5.60, 12.20, 18.20, 14.10, 16.00, -21.00, -13.00
       3.80,  4.10,  5.20, 16.70, 18.40, 19.10, 20.20, 13.60,  14.80,  19.40
      18.60, 15.20, -1.80, 13.60, -4.90,  5.40, 19.80, 16.40, -20.90,  21.40
      13.80, -3.60,  6.00, -8.20, -9.10,  4.00, -2.50,  2.00,   3.40,   6.70
       8.40, 10.90,  4.70,  8.30,  9.40, 10.50, 11.00, 19.00,  15.40,  18.90
     -20.00, 12.60,  5.30, -4.70,  6.10,  6.50,  6.90, -9.20, -10.80,   4.30
       5.60,  9.10, 21.40, 19.50, 28.40, 19.30, 24.60, 14.90,  71.30,  23.50

    Determinant: -2549840202186
    Determinant from a(1,4),4: -57.61200000001

    Test:
       4.00,   5.00,   6.00,   7.00
       2.40,   5.10,   6.20,   7.20
      -1.20,  -1.50,  -6.70,   4.50
       5.60,  12.20,  18.20,  14.10

    -57.61200000001

<A HREF="#MAT_QDET">MAT QDET</A> x=a([i,j])[,n] works in the same manner as <A HREF="#MAT_DET">MAT DET</A> x=a([i,j])[,n],
except that it has been optimised for speed rather than accuracy. Both will
normally produce identical results. With "critical" matrix, whose determinant
is close to 0, you should always use <A HREF="#MAT_DET">MAT DET</A>, though.

<B>Example:</B>

    <A HREF="#DIM">DIM</A> a(10,10)
    <A HREF="#DATA">DATA</A> 1,2,3,4,5,6,7,8,9,-1
    <A HREF="#DATA">DATA</A> 3.2,4,-5,2.4,5.1,6.2,7.2,8.1,6,-5
    <A HREF="#DATA">DATA</A> -2,-5,-6,-1.2,-1.5,-6.7,4.5,8.1,3.4,10
    <A HREF="#DATA">DATA</A> 5,-2.3,4,5.6,12.2,18.2,14.1,16,-21,-13,3.8
    <A HREF="#DATA">DATA</A> 4.1,5.2,16.7,18.4,19.1,20.2,13.6,14.8,19.4,18.6
    <A HREF="#DATA">DATA</A> 15.2,-1.8,13.6,-4.9,5.4,19.8,16.4,-20.9,21.4,13.8
    <A HREF="#DATA">DATA</A> -3.6,6,-8.2,-9.1,4,-2.5,2,3.4,6.7,8.4,10.9
    <A HREF="#DATA">DATA</A> 4.7,8.3,9.4,10.5,11,19,15.4,18.9,-20,12.6
    <A HREF="#DATA">DATA</A> 5.3,-4.7,6.1,6.5,6.9,-9.2,-10.8,4.3,5.6,9.1
    <A HREF="#DATA">DATA</A> 21.4,19.5,28.4,19.3,24.6,14.9,71.3,23.5,14.5,-12.3
    <A HREF="#'">'</A>
    <A HREF="#CLS">CLS</A>
    <A HREF="#MAT_READ">MAT READ</A> a()
    <A HREF="#PRINT">PRINT</A> "Source matrix"
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#MAT_PRINT">MAT PRINT</A> a(),7,2
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#PRINT">PRINT</A> "Determinant with <A HREF="#MAT">MAT</A> DET: "<A HREF="#;">;</A>
    <A HREF="#MAT_DET">MAT DET</A> x=a()
    <A HREF="#PRINT">PRINT</A> x;
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#PRINT">PRINT</A> "Determinant with <A HREF="#MAT">MAT</A> QDET: "<A HREF="#;">;</A>
    <A HREF="#MAT_DET">MAT DET</A> y=a()
    <A HREF="#PRINT">PRINT</A> y;
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#PRINT">PRINT</A> "Deviation: ";x-y

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Outputs:
    Source Matrix

       1.00,  2.00,  3.00,  4.00,  5.00,  6.00,  7.00,  8.00,   9.00,  -1.00
       3.20,  4.00, -5.00,  2.40,  5.10,  6.20,  7.20,  8.10,   6.00,  -5.00
      -2.00, -5.00, -6.00, -1.20, -1.50, -6.70,  4.50,  8.10,   3.40,  10.00
       5.00, -2.30,  4.00,  5.60, 12.20, 18.20, 14.10, 16.00, -21.00, -13.00
       3.80,  4.10,  5.20, 16.70, 18.40, 19.10, 20.20, 13.60,  14.80,  19.40
      18.60, 15.20, -1.80, 13.60, -4.90,  5.40, 19.80, 16.40, -20.90,  21.40
      13.80, -3.60,  6.00, -8.20, -9.10,  4.00, -2.50,  2.00,   3.40,   6.70
       8.40, 10.90,  4.70,  8.30,  9.40, 10.50, 11.00, 19.00,  15.40,  18.90
     -20.00, 12.60,  5.30, -4.70,  6.10,  6.50,  6.90, -9.20, -10.80,   4.30
       5.60,  9.10, 21.40, 19.50, 28.40, 19.30, 24.60, 14.90,  71.30,  23.50

    Determinant with <A HREF="#MAT">MAT</A> DET: -2549840202186
    Determinant with <A HREF="#MAT">MAT</A> QDET: -2549840202186
    Deviation: 0

<A HREF="#MAT_RANG">MAT RANG</A> x=a([i,j])[,n] outputs the rank of a square matrix. As with <A HREF="#MAT_DET">MAT DET</A> or
<A HREF="#MAT_QDET">MAT QDET</A>, you can select any row and column offset. The number of elements in
the part matrix must be specified with n. This creates a part matrix of the
(n,n) type internally, starting from the position ith row, jth column.

<B>Example:</B>

    <A HREF="#DIM">DIM</A> a(5,5)
    <A HREF="#DATA">DATA</A> 1,2,3,4,5
    <A HREF="#DATA">DATA</A> 3.2,4,-5,2.4,5.1
    <A HREF="#DATA">DATA</A> -2,4,-5,2.4,5.1
    <A HREF="#DATA">DATA</A> 5,-2.3,4,5.6,12.2
    <A HREF="#DATA">DATA</A> 4.1,5.2,16.7,18.4,19.1
    <A HREF="#'">'</A>
    <A HREF="#CLS">CLS</A>
    <A HREF="#MAT_READ">MAT READ</A> a()
    <A HREF="#PRINT">PRINT</A> "Source matrix"
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#MAT_PRINT">MAT PRINT</A> a(),7,2
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#PRINT">PRINT</A> "Rang from a()<A HREF="#:">:</A> "<A HREF="#;">;</A>
    <A HREF="#MAT_RANG">MAT RANG</A> x=a()
    <A HREF="#PRINT">PRINT</A> x;
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#PRINT">PRINT</A> "Rang from a(1,2),3: "<A HREF="#;">;</A>
    <A HREF="#MAT_RANG">MAT RANG</A> y=a(1,2),3
    <A HREF="#PRINT">PRINT</A> y;
    <A HREF="#PRINT">PRINT</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Outputs:
    Source matrix

       1.00,   2.00,   3.00,   4.00,   5.00
       3.20,   4.00,  -5.00,   2.40,   5.10
      -2.00,   4.00,  -5.00,   2.40,   5.10
       5.00,  -2.30,   4.00,   5.60,  12.20
       4.10,   5.20,  16.70,  18.40,  19.10

    Rang from a()<A HREF="#:">:</A> 5
    Rang from a(1,2),3: 2

<A HREF="#MAT_INV">MAT INV</A> b()=a() is used to determine the inverses of a square matrix. The
inverse of matrix a() is written to matrix b(), hence b() must be of the same
type as a()<A HREF="#.">.</A>

<B>Example:</B>

    <A HREF="#DIM">DIM</A> a(5,5),b(5,5),c(5,5)
    <A HREF="#DATA">DATA</A> 1,2,3,4,5
    <A HREF="#DATA">DATA</A> 3.2,4,-5,2.4,5.1
    <A HREF="#DATA">DATA</A> -2,4,-5,2.4,5.1
    <A HREF="#DATA">DATA</A> 5,-2.3,4,5.6,12.2
    <A HREF="#DATA">DATA</A> 4.1,5.2,16.7,18.4,19.1
    <A HREF="#'">'</A>
    <A HREF="#CLS">CLS</A>
    <A HREF="#MAT_READ">MAT READ</A> a()
    <A HREF="#PRINT">PRINT</A> "Source matrix a()<A HREF="#:">:</A> "
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#MAT_PRINT">MAT PRINT</A> a(),7,2
    <A HREF="#'">'</A>
    <A HREF="#MAT_INV">MAT INV</A> b()=a()
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#PRINT">PRINT</A> "Inverse from a()<A HREF="#:">:</A> "
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#MAT_PRINT">MAT PRINT</A> b(),7,2
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#PRINT">PRINT</A> "Test b()*a()<A HREF="#&">&</A>#62;Unity matrix <A HREF="#?">?</A>"
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#MAT_MUL">MAT MUL</A> c()=b()*a()
    <A HREF="#MAT_PRINT">MAT PRINT</A> c(),7,2

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Outputs:
    Source matrix a()<A HREF="#:">:</A>

     1.00,  2.00,  3.00,  4.00,  5.00
     3.20,  4.00, -5.00,  2.40,  5.10
    -2.00,  4.00, -5.00,  2.40,  5.10
     5.00, -2.30,  4.00,  5.60, 12.20
     4.10,  5.20, 16.70, 18.40, 19.10

    Inverse from a()<A HREF="#:">:</A>

     0.00,  0.19, -0.19, -0.00, -0.00
     0.97,  0.02, -0.09, -0.10, -0.17
     0.71, -0.10, -0.10, -0.01, -0.12
    -1.65,  0.17,  0.11, -0.06,  0.39
     0.71, -0.12,  0.04,  0.09, -0.17

    Test b()*a()<A HREF="#&">&</A>#62;Unity matrix <A HREF="#?">?</A>

     1.00,  0.00,  0.00,  0.00,  0.00
     0.00,  1.00,  0.00,  0.00, -0.00
     0.00, -0.00,  1.00,  0.00, -0.00
    -0.00, -0.00, -0.00,  1.00,  0.00
    -0.00,  0.00,  0.00,  0.00,  1.00

<B>Memo:</B> <A HREF="#MAT_DET">MAT DET</A> x=a(i,j),n   !causes the compiler to crash
      <A HREF="#MAT_DET">MAT DET</A> x=a(i,j),2+6 !is also fatal
      <A HREF="#MAT_DET">MAT DET</A> x=a(i,j),4   !seems to compile ok
      <A HREF="#MAT_DET">MAT DET</A> x=a(i,j),n&  !seems to compile ok
      <A HREF="#MAT_QDET">MAT QDET</A> and <A HREF="#MAT_RANG">MAT RANG</A> seem to have the same problems.
<HR SIZE=3><H2 ID="MAT_ABS">MAT ABS</H2>
<A NAME="MAT_NEG"></A><B><A HREF="#MAT_ABS">MAT ABS</A> a()
<A HREF="#MAT_NEG">MAT NEG</A> a()</B>

a: names of numerical floating point fields

<A HREF="#MAT_ABS">MAT ABS</A> a() will perform an <A HREF="#ABS">ABS</A>() function on all elements of a()<A HREF="#.">.</A>

<B>Example:</B>

    <A HREF="#DIM">DIM</A> a(3,3)
    <A HREF="#MAT_SET">MAT SET</A> a()<A HREF="#=">=</A>-1
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()
    <A HREF="#PRINT">PRINT</A> <A HREF="#STRING$">STRING$</A>(8,"<A HREF="#-">-</A>")
    <A HREF="#MAT_ABS">MAT ABS</A> a()
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> -1,-1,-1
    -1,-1,-1
    -1,-1,-1
    <A HREF="#-">-</A>-------
    1,1,1
    1,1,1
    1,1,1

<A HREF="#MAT_NEG">MAT NEG</A> a() multiplies all elements of a one or two dimensional floating point
array a() with -1.

<B>Example:</B>

    <A HREF="#DIM">DIM</A> a(3,3)
    <A HREF="#MAT_ONE">MAT ONE</A> a()
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()
    <A HREF="#PRINT">PRINT</A> <A HREF="#STRING$">STRING$</A>(6,"<A HREF="#-">-</A>")
    <A HREF="#MAT_NEG">MAT NEG</A> a()
    <A HREF="#MAT_PRINT">MAT PRINT</A> a()

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> 1,0,0
    0,1,0
    0,0,1
    <A HREF="#-">-</A>-----
    -1,0,0
    0,-1,0
    0,0,-1
<HR SIZE=3><H2 ID="Type_Transformation">Type Transformation</H2>
<A HREF="#TYPE">TYPE</A><A HREF="#()">()</A>
<A HREF="#ASC">ASC</A><A HREF="#()">()</A>, <A HREF="#CHR$">CHR$</A>()
<A HREF="#STR$">STR$</A><A HREF="#()">()</A>, <A HREF="#BIN$">BIN$</A>(), <A HREF="#OCT$">OCT$</A>(), <A HREF="#HEX$">HEX$</A>()
<A HREF="#VAL">VAL</A><A HREF="#()">()</A>, <A HREF="#VAL?">VAL?</A>()
<A HREF="#CVI">CVI</A><A HREF="#()">()</A>, <A HREF="#CVL">CVL</A>(), <A HREF="#CVS">CVS</A>(), <A HREF="#CVF">CVF</A>(), <A HREF="#CVD">CVD</A>()
<A HREF="#MKI$">MKI$</A><A HREF="#()">()</A>, <A HREF="#MKL$">MKL$</A>(), <A HREF="#MKS$">MKS$</A>(), <A HREF="#MKF$">MKF$</A>(), <A HREF="#MKD$">MKD$</A>()
<A HREF="#CINT">CINT</A><A HREF="#()">()</A>, <A HREF="#CFLOAT">CFLOAT</A>()
<HR SIZE=3><H2 ID="TYPE">TYPE</H2>
<B><A HREF="#TYPE">TYPE</A>(x)</B>

x: <A HREF="#iexp">iexp</A>

With the function <A HREF="#TYPE">TYPE</A><A HREF="#()">()</A> the type of a variable can be determined. The function
operates on the pointer to the variable, and returns a value corresponding to
the variable type as follows:

    Float          0
    String         1
    Long           2
    Boolean        3
    Float array    4
    String array   5
    Long array     6
    Boolean array  7
    Word           8
    Byte           9
    Word array     12
    Byte array     13

<B>Note:</B> An invalid pointer returns the vaiue -1.

<B>Example:</B>

    a$<A HREF="#=">=</A>"test"
    x%=4
    <A HREF="#DIM">DIM</A> y(3)
    <A HREF="#PRINT">PRINT</A> <A HREF="#TYPE">TYPE</A>(*a$),TYPE(*x%),TYPE(*y())

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The numbers 1, 2, and 4 appear on the screen. (*a$, etc, represent the
    pointer to a variable.)
<HR SIZE=3><H2 ID="ASC">ASC</H2>
<A NAME="CHR$"></A><B><A HREF="#ASC">ASC</A>(a$)
<A HREF="#CHR$">CHR$</A>(x)</B>

a$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>
x: <A HREF="#aexp">aexp</A>

<A HREF="#ASC">ASC</A><A HREF="#()">()</A> and <A HREF="#CHR$">CHR$</A>() are complementary functions.

The function <A HREF="#ASC">ASC</A><A HREF="#()">()</A> returns the <A HREF="#ASCII">ASCII</A> code of the first character in the subject
string. If the string is of zero length (""), zero is returned.

<A HREF="#CHR$">CHR$</A><A HREF="#()">()</A> gives a character, from a specified <A HREF="#ASCII">ASCII</A> code. Only the lowest 8 bits
of x (the low-byte) are relevant, as <A HREF="#ASCII">ASCII</A> codes only go up to 255.

<B>Example:</B>

    <A HREF="#PRINT">PRINT</A> <A HREF="#ASC">ASC</A>("TEST")
    code&#124;<A HREF="#=">=</A><A HREF="#ASC">ASC</A>(<A HREF="#CHR$">CHR$</A>(65)) !CHR$(65) is A
    <A HREF="#PRINT">PRINT</A> code&#124;,<A HREF="#CHR$">CHR$</A>(189)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The numbers 84 and 65 and the copyright sign appear on the screen.
<HR SIZE=3><H2 ID="STR$">STR$</H2>
<A NAME="BIN$"></A><A NAME="OCT$"></A><A NAME="HEX$"></A><B><A HREF="#STR$">STR$</A>(x[,y][,z])
<A HREF="#BIN$">BIN$</A>(x[,y])
<A HREF="#OCT$">OCT$</A>(x[,y])
<A HREF="#HEX$">HEX$</A>(x[,y])</B>

x, y, z: <A HREF="#aexp">aexp</A>

The functions <A HREF="#STR$">STR$</A><A HREF="#()">()</A>, <A HREF="#BIN$">BIN$</A>(), <A HREF="#OCT$">OCT$</A>(), and <A HREF="#HEX$">HEX$</A>() convert a numerical expression
into a character string.

The length of the required output string can be specified by a second
parameter. If necessary, it is padded at the front by blanks (<A HREF="#STR$">STR$</A><A HREF="#()">()</A>) or zeros
(<A HREF="#BIN$">BIN$</A><A HREF="#()">()</A>, <A HREF="#OCT$">OCT$</A>(), <A HREF="#HEX$">HEX$</A>())<A HREF="#.">.</A> If the length specified is too short, only that
number of characters will be returned.

<A HREF="#STR$">STR$</A><A HREF="#()">()</A> produces a string (base 10) from the number 'x', with 'y' specifying the
required length.

A further variant of <A HREF="#STR$">STR$</A><A HREF="#()">()</A> is provided with the third parameter 'z'<A HREF="#.">.</A> The
number is formatted and rounded with 'y' characters and 'z' decimal places.

<A HREF="#BIN$">BIN$</A><A HREF="#()">()</A> converts an integer to Binary (base 2) representation. The optional
parameter 'y' specifies the number of character positions (1 to 32) to be used.

<A HREF="#OCT$">OCT$</A><A HREF="#()">()</A> converts an integer to Octal (base 8) representation. The optional
parameter 'y' specifies the number of character positions (1 to 11) to be used.

<A HREF="#HEX$">HEX$</A><A HREF="#()">()</A> converts an integer to Hexadecimal (base 16) representation. The
optional parameter 'y' specifies the number of character positions (1 to 8) to
be used.

<B>Examples:</B>

    a=123.4567
    <A HREF="#PRINT">PRINT</A> <A HREF="#STR$">STR$</A>(a,6,2)
    <A HREF="#PRINT">PRINT</A> <A HREF="#STR$">STR$</A>(<A HREF="#PI">PI</A>,5,3)
    <A HREF="#PRINT">PRINT</A> <A HREF="#STR$">STR$</A>(<A HREF="#PI">PI</A>,2,2)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Prints the numbers 123.46, 3.142, and 14 on the screen.

    x=32+15
    a$<A HREF="#=">=</A><A HREF="#OCT$">OCT$</A>(16+7,4)
    <A HREF="#PRINT">PRINT</A> <A HREF="#HEX$">HEX$</A>(x),a$,<A HREF="#BIN$">BIN$</A>(1+4+16+64,8)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Prints 2F, 0027, and 01010101 on the screen.

<B>Memo:</B> <A HREF="#STR$">STR$</A><A HREF="#()">()</A> with 3 parameters is limited to 2000 characters for
      parameter 'y' in the editor and 400 characters compiled.
<HR SIZE=3><H2 ID="VAL">VAL</H2>
<A NAME="VAL?"></A><B><A HREF="#VAL">VAL</A>(a$)
<A HREF="#VAL?">VAL?</A>(a$)</B>

a$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>

<A HREF="#VAL">VAL</A><A HREF="#()">()</A> turns a character string into a number. If VAL() encounters a character
that cannot be interpreted as part of a number, the conversion stops at that
point with the characters successfully converted returned as the result. If no
number is found at the beginning of the string, zero is returned.

By adding the prefix <A HREF="#&H">&H</A> (Hex), <A HREF="#&X">&X</A> (Bin), or <A HREF="#&O">&O</A> (Oct) numbers in Hexadecimal,
Binary, and Octal notation can be recognized.

The prefixes <A HREF="#'">'</A><A HREF="#$">$</A>' and '<A HREF="#%">%</A>' may also be used to identify Hexadecimal and Binary
notation respectively.

With <A HREF="#VAL?">VAL?</A><A HREF="#()">()</A> one can determine the number of characters convertible with <A HREF="#VAL">VAL</A>(),
returning zero if none can be converted.

<B>Examples:</B>

    a$<A HREF="#=">=</A><A HREF="#STR$">STR$</A>(12345)
    <A HREF="#PRINT">PRINT</A> <A HREF="#VAL">VAL</A>(a$),VAL("<A HREF="#-">-</A>.123abc123"),<A HREF="#VAL?">VAL?</A>("3.00 km")

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The numbers 12345,-0.123 and 4 are printed on the screen.

    <A HREF="#PRINT">PRINT</A> <A HREF="#VAL">VAL</A>("<A HREF="#&H">&H</A>"<A HREF="#+">+</A>"AF")

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> '175' is displayed.

    <A HREF="#PRINT">PRINT</A> <A HREF="#VAL">VAL</A>("$AA")
    <A HREF="#PRINT">PRINT</A> <A HREF="#VAL">VAL</A>("%10101010")

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> '170' is displayed twice.

<B>Memo:</B> <A HREF="#VAL">VAL</A><A HREF="#()">()</A> assumes hex if the type is left out in gfa format strings.
      <A HREF="#VAL">VAL</A><A HREF="#()">()</A> also ignores leading spaces. <A HREF="#VAL?">VAL?</A>() counts leading spaces.
      Example:
        <A HREF="#PRINT">PRINT</A> <A HREF="#VAL">VAL</A>("&HFF")  !prints 255
        <A HREF="#PRINT">PRINT</A> <A HREF="#VAL">VAL</A>("&FF")   !also prints 255
        <A HREF="#PRINT">PRINT</A> <A HREF="#VAL">VAL</A>(" 255")  !also prints 255
        <A HREF="#PRINT">PRINT</A> <A HREF="#VAL">VAL</A>(" 2 0")  !prints 2
        <A HREF="#'">'</A>
        <A HREF="#PRINT">PRINT</A> <A HREF="#VAL?">VAL?</A>("  22")        !prints 4
        <A HREF="#PRINT">PRINT</A> <A HREF="#VAL?">VAL?</A>(<A HREF="#TRIM$">TRIM$</A>("  22")) !prints 2
<HR SIZE=3><H2 ID="CVI">CVI</H2>
<A NAME="CVL"></A><A NAME="CVS"></A><A NAME="CVF"></A><A NAME="CVD"></A><A NAME="MKI$"></A><A NAME="MKL$"></A><A NAME="MKS$"></A><A NAME="MKF$"></A><A NAME="MKD$"></A><B><A HREF="#CVI">CVI</A>(a$)  <A HREF="#CVL">CVL</A>(a$)  <A HREF="#CVS">CVS</A>(a$)  <A HREF="#CVF">CVF</A>(a$)  <A HREF="#CVD">CVD</A>(a$)
<A HREF="#MKI$">MKI$</A>(x)  <A HREF="#MKL$">MKL$</A>(x)  <A HREF="#MKS$">MKS$</A>(x)  <A HREF="#MKF$">MKF$</A>(x)  <A HREF="#MKD$">MKD$</A>(x)</B>

a$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>
x: <A HREF="#aexp">aexp</A>

The functions <A HREF="#CVI">CVI</A><A HREF="#()">()</A>, <A HREF="#CVL">CVL</A>(), <A HREF="#CVS">CVS</A>(), <A HREF="#CVF">CVF</A>(), and <A HREF="#CVD">CVD</A>() convert character strings
into numbers, but, as opposed to <A HREF="#VAL">VAL</A><A HREF="#()">()</A> and <A HREF="#STR$">STR$</A>(), it is the internal
representation which is set.

The individual CVx() functions have the following effects:

    <A HREF="#CVI">CVI</A><A HREF="#()">()</A>  Changes a 2-byte character string into an Word.

    <A HREF="#CVL">CVL</A><A HREF="#()">()</A>  Changes a 4-byte character string into a Long

    <A HREF="#CVS">CVS</A><A HREF="#()">()</A>  Changes a 4-byte character string containing a valid ST-Basic
           compatible number into <A HREF="#GFA-Basic">GFA-Basic</A> 3 floating point format.

    <A HREF="#CVF">CVF</A><A HREF="#()">()</A>  Changes a 6-byte character string containing a valid <A HREF="#GFA-Basic">GFA-Basic</A> 1.0
           or <A HREF="#GFA-Basic">GFA-Basic</A> 2.0 compatible number into GFA-Basic 3 floating point
           format.

    <A HREF="#CVD">CVD</A><A HREF="#()">()</A>  Changes an 8-byte character string into <A HREF="#GFA-Basic">GFA-Basic</A> 3 floating point
           format.

<A HREF="#MKI$">MKI$</A><A HREF="#()">()</A>, <A HREF="#MKL$">MKL$</A>(), <A HREF="#MKS$">MKS$</A>(), <A HREF="#MKF$">MKF$</A>(), and <A HREF="#MKD$">MKD$</A>() are the inverse of the CVx()
functions above, thus:

    <A HREF="#MKI$">MKI$</A>(x%)<A HREF="#=">=</A><A HREF="#CHR$">CHR$</A>(<A HREF="#SHR">SHR</A>(x%,8))+CHR$(x%)
    <A HREF="#MKL$">MKL$</A>(x%)<A HREF="#=">=</A><A HREF="#CHR$">CHR$</A>(<A HREF="#SHR">SHR</A>(x%,24))+CHR$(SHR(x%,16))+CHR$(SHR(x%,8))+CHR$(x%)

(<A HREF="#SHR">SHR</A><A HREF="#()">()</A> is the shift-right function. Note that the high-byte comes first.)

Uses might be reading the number formats of other programs or in saving space
when storing numbers in random access files.

<B>Example:</B>

    a$<A HREF="#=">=</A><A HREF="#MKL$">MKL$</A>(1000)
    <A HREF="#PRINT">PRINT</A> <A HREF="#CVL">CVL</A>(a$),<A HREF="#LEN">LEN</A>(a$)
    b$<A HREF="#=">=</A><A HREF="#MKD$">MKD$</A>(100.1)
    <A HREF="#PRINT">PRINT</A> <A HREF="#CVD">CVD</A>(b$),<A HREF="#LEN">LEN</A>(b$)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Prints the numbers 1000, 4, 100.1, and 8 on the screen.

<B>Memo:</B> For more information on the internal storage of floats see pages
      <A HREF="#'">'</A><A HREF="#GFA-Basic_v3_float_format">GFA-Basic v3 float format</A>' and '<A HREF="#ST-Basic_float_format">ST-Basic float format</A>'<A HREF="#.">.</A>
<HR SIZE=3><H2 ID="CINT">CINT</H2>
<A NAME="CFLOAT"></A><B><A HREF="#CINT">CINT</A>(x)
<A HREF="#CFLOAT">CFLOAT</A>(y)</B>

x: <A HREF="#aexp">aexp</A>
y: <A HREF="#iexp">iexp</A>

The function <A HREF="#CINT">CINT</A><A HREF="#()">()</A> changes a floating point number 'x' into a rounded integer
value.

<A HREF="#CFLOAT">CFLOAT</A><A HREF="#()">()</A> changes and integer 'y' into a floating point number. This function is
not normally required and is specified only for the sake of completeness. With
compiled programs, however, it has a use.

<B>Example:</B>

    a=1.2345
    a%=10000
    b%<A HREF="#=">=</A><A HREF="#CINT">CINT</A>(a)
    b=<A HREF="#CFLOAT">CFLOAT</A>(a%)
    <A HREF="#PRINT">PRINT</A> b%,b

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Prints 1 and 10000 on the screen.
<HR SIZE=3><H2 ID="Pointer_Operations">Pointer Operations</H2>
<A HREF="#PEEK">PEEK</A><A HREF="#()">()</A>, <A HREF="#DPEEK">DPEEK</A>(), <A HREF="#LPEEK">LPEEK</A>()
<A HREF="#POKE">POKE</A>, <A HREF="#DPOKE">DPOKE</A>, <A HREF="#LPOKE">LPOKE</A>
<A HREF="#SPOKE">SPOKE</A>, <A HREF="#SDPOKE">SDPOKE</A>, <A HREF="#SLPOKE">SLPOKE</A>
<A HREF="#BYTE">BYTE</A><A HREF="#{}">{}</A>, <A HREF="#WORD">WORD</A>{} (<A HREF="#INT">INT</A>{}), <A HREF="#LONG">LONG</A>{} ({}), <A HREF="#FLOAT">FLOAT</A>{}
<A HREF="#CARD">CARD</A><A HREF="#{}">{}</A>, <A HREF="#SINGLE">SINGLE</A>{}, <A HREF="#DOUBLE">DOUBLE</A>{}
<A HREF="#CHAR">CHAR</A><A HREF="#{}">{}</A>
<A HREF="#VARPTR">VARPTR</A><A HREF="#()">()</A>, <A HREF="#V:">V:</A>
<A HREF="#ARRPTR">ARRPTR</A><A HREF="#()">()</A>, <A HREF="#*">*</A> (as function/as command)
<A HREF="#ABSOLUTE">ABSOLUTE</A>
<HR SIZE=3><H2 ID="PEEK">PEEK</H2>
<A NAME="DPEEK"></A><A NAME="LPEEK"></A><A NAME="POKE"></A><A NAME="DPOKE"></A><A NAME="LPOKE"></A><A NAME="SPOKE"></A><A NAME="SDPOKE"></A><A NAME="SLPOKE"></A><B><A HREF="#PEEK">PEEK</A>(x)    <A HREF="#DPEEK">DPEEK</A>(x)    <A HREF="#LPEEK">LPEEK</A>(x)
<A HREF="#POKE">POKE</A> x,y   <A HREF="#DPOKE">DPOKE</A> x,y   <A HREF="#LPOKE">LPOKE</A> x,y
<A HREF="#SPOKE">SPOKE</A> x,y  <A HREF="#SDPOKE">SDPOKE</A> x,y  <A HREF="#SLPOKE">SLPOKE</A> x,y</B>

x, y: <A HREF="#iexp">iexp</A>

With the functions xPEEK() one can read from specified memory locations.
With the functions xPOKE one can write to specified memory locations.

The individual variants are:

    <A HREF="#PEEK">PEEK</A>(x)   Reads a byte from the address x.
    <A HREF="#DPEEK">DPEEK</A>(x)  Reads two bytes (word) staring at address x.
    <A HREF="#LPEEK">LPEEK</A>(x)  Reads four bytes (long) staring at address x.

    <A HREF="#POKE">POKE</A> x,y    Writes the value y as a byte to the address x.
    <A HREF="#DPOKE">DPOKE</A> x,y   Writes the value y as a 2-byte word to the address x.
    <A HREF="#LPOKE">LPOKE</A> x,y   Writes the value y as a 4-byte long to the address x.

It is important that when using <A HREF="#DPEEK">DPEEK</A><A HREF="#()">()</A> and <A HREF="#LPEEK">LPEEK</A>(), only <U>even</U>
addresses are given.

The xPEEK() functions always work in <U>supervisor</U> mode.

xPOKE instructions have variants which work in the <U>supervisor</U> mode. So
protected addresses, e.g. 0 to 2047, can be modified. The appropriate
instructions are <A HREF="#SPOKE">SPOKE</A>, <A HREF="#SDPOKE">SDPOKE</A> and <A HREF="#SLPOKE">SLPOKE</A><A HREF="#.">.</A> Caution is advised, paricularly in
the <U>supervisor</U> mode, since modifications to protected addresses can have
serious consequences.

<B>Example:</B>

    <A HREF="#LPOKE">LPOKE</A> <A HREF="#XBIOS">XBIOS</A>(14,1)+6,0

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Sets the head and tail pointers to the keyboard buffer to the buffer start,
    effectively erasing the buffer.

or alternately:

    <A HREF="#REPEAT">REPEAT</A>
    <A HREF="#UNTIL">UNTIL</A> <A HREF="#INKEY$">INKEY$</A><A HREF="#=">=</A>""

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Deletes the keyboard buffer, character by character.
<HR SIZE=3><H2 ID="WORD">WORD</H2>
<A NAME="{}"></A><A NAME="BYTE"></A><A NAME="INT"></A><A NAME="LONG"></A><A NAME="FLOAT"></A><A NAME="CARD"></A><A NAME="SINGLE"></A><A NAME="DOUBLE"></A><A NAME="CHAR"></A><B><A HREF="#BYTE">BYTE</A>{x}
<A HREF="#WORD">WORD</A>{x} (<A HREF="#INT">INT</A>{x})
<A HREF="#LONG">LONG</A>{x} ({x})
<A HREF="#FLOAT">FLOAT</A>{X}
<A HREF="#CARD">CARD</A>{x}
<A HREF="#SINGLE">SINGLE</A>{x}
<A HREF="#DOUBLE">DOUBLE</A>{x}
<A HREF="#CHAR">CHAR</A>{x}</B>

x: <A HREF="#iexp">iexp</A>

By means of these commands one can read certain variable types starting from a
given address, or write them to an address.

As a function, e.g. y=<A HREF="#BYTE">BYTE</A>{x}, one can read, starting from the address x, and
as an instruction, e.g. <A HREF="#BYTE">BYTE</A>{x}=y, one can write, again starting from address
x.

It is important when using <A HREF="#WORD">WORD</A><A HREF="#{}">{}</A>, <A HREF="#CARD">CARD</A>{}, <A HREF="#LONG">LONG</A>{}, <A HREF="#FLOAT">FLOAT</A>{}, <A HREF="#SINGLE">SINGLE</A>{}, and
<A HREF="#DOUBLE">DOUBLE</A><A HREF="#{}">{}</A> that only <U>even</U> numbered addresses are specified, since
otherwise an address error occurs and three bombs are displayed.

<B>Type      Meaning</B>
<A HREF="#BYTE">BYTE</A><A HREF="#{}">{}</A>    Reads/writes a byte.

<A HREF="#CARD">CARD</A><A HREF="#{}">{}</A>    Reads/writes a 2-byte unsigned integer (0-65535)<A HREF="#.">.</A>

<A HREF="#WORD">WORD</A><A HREF="#{}">{}</A>    Reads/writes a 2-byte signed integer.
          Instead of <A HREF="#WORD">WORD</A><A HREF="#{}">{}</A> you may use <A HREF="#INT">INT</A>{} which has the same effect.

<A HREF="#LONG">LONG</A><A HREF="#{}">{}</A>    Reads/writes a 4-byte integer.
          Instead of <A HREF="#LONG">LONG</A>{x} you may use {x} which has the same effect.

<A HREF="#FLOAT">FLOAT</A><A HREF="#{}">{}</A>   Reads/writes an 8-byte variable in <A HREF="#GFA-Basic">GFA-Basic</A> 3 floating-point
          format.

<A HREF="#SINGLE">SINGLE</A><A HREF="#{}">{}</A>  Reads/writes a 4-byte floating-point variable in IEEE
          single-precision format.

<A HREF="#DOUBLE">DOUBLE</A><A HREF="#{}">{}</A>  Reads/writes an 8-byte floating-point variable in IEEE
          double-precision format.

<A HREF="#CHAR">CHAR</A><A HREF="#{}">{}</A>    Reads a string of bytes until a null byte (zero) is encountered, or
          writes the specified string of bytes and appends a null byte.
          Paricularly important for communication with C routines and <A HREF="#GEMDOS">GEMDOS</A><A HREF="#()">()</A><A HREF="#.">.</A>

With x%<A HREF="#=">=</A><A HREF="#LONG">LONG</A>{adr%} the variable x% is assigned the long-word value found at the
address adr%, and with <A HREF="#LONG">LONG</A>{adr%}=x% the value of x% is written as a long-word
to the address adr%<A HREF="#.">.</A>

With <A HREF="#SINGLE">SINGLE</A><A HREF="#{}">{}</A> and <A HREF="#DOUBLE">DOUBLE</A>{} it is possible to read or write in IEEE format, used
by some 'C' compilers. So, with <A HREF="#GFA-Basic">GFA-Basic</A>, a number in the Single or Double
format can be converted and displayed in hexadecimal:

    a$<A HREF="#=">=</A><A HREF="#SPACE$">SPACE$</A>(4)
    <A HREF="#SINGLE">SINGLE</A>{V:a$}=1.2345
    <A HREF="#PRINT">PRINT</A> <A HREF="#HEX$">HEX$</A>(<A HREF="#CVL">CVL</A>(a$),8)

or

    a$<A HREF="#=">=</A><A HREF="#SPACE$">SPACE$</A>(8)
    <A HREF="#DOUBLE">DOUBLE</A>{V:a$}=1.2345
    <A HREF="#PRINT">PRINT</A> <A HREF="#HEX$">HEX$</A>(<A HREF="#LONG">LONG</A>{V:a$},8)
    <A HREF="#PRINT">PRINT</A> <A HREF="#HEX$">HEX$</A>(<A HREF="#LONG">LONG</A>{V:a$+4},8)

Some functions mentioned above approximately correspond: <A HREF="#LONG">LONG</A><A HREF="#{}">{}</A> for instance
corresponds to <A HREF="#LPEEK">LPEEK</A><A HREF="#()">()</A><A HREF="#.">.</A> However, <A HREF="#LONG">LONG</A><A HREF="#{}">{}</A> is quicker than LPEEK(), although it
will not work in the <U>Supervisor</U> mode. Attempting to access protected
memory locations (0 to 2047) with <A HREF="#LONG">LONG</A><A HREF="#{}">{}</A> will result in a bus error, with two
bombs displayed.

<B>Examples:</B>

    adr%<A HREF="#=">=</A><A HREF="#XBIOS">XBIOS</A>(2)
    t%<A HREF="#=">=</A><A HREF="#TIMER">TIMER</A>
    <A HREF="#FOR">FOR</A> i%=1 TO 4000
      <A HREF="#VOID">VOID</A> <A HREF="#LONG">LONG</A>{adr%}
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#PRINT">PRINT</A> (<A HREF="#TIMER">TIMER</A><A HREF="#-t">-t</A><A HREF="#%">%</A>)/200
    <A HREF="#'">'</A>
    t%<A HREF="#=">=</A><A HREF="#TIMER">TIMER</A>
    <A HREF="#FOR">FOR</A> i%=1 TO 4000
      <A HREF="#VOID">VOID</A> <A HREF="#LPEEK">LPEEK</A>(adr%)
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#PRINT">PRINT</A> (<A HREF="#TIMER">TIMER</A><A HREF="#-t">-t</A><A HREF="#%">%</A>)/200
    <A HREF="#'">'</A>
    <A HREF="#PRINT">PRINT</A> x
    <A HREF="#FLOAT">FLOAT</A>{*x}<A HREF="#=">=</A><A HREF="#PI">PI</A>
    <A HREF="#PRINT">PRINT</A> x

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The first part of the example shows that <A HREF="#LONG">LONG</A><A HREF="#{}">{}</A> works more quickly than
    <A HREF="#LPEEK">LPEEK</A><A HREF="#()">()</A>, and the second part demonstrates writing a floating-point number
    indirectly to a variable.

    <A HREF="#BYTE">BYTE</A>{<A HREF="#XBIOS">XBIOS</A>(2)+100*160}<A HREF="#=">=</A>&HFF
    <A HREF="#CARD">CARD</A>{<A HREF="#XBIOS">XBIOS</A>(2)+102*160}<A HREF="#=">=</A>&HFFFF
    <A HREF="#LONG">LONG</A>{<A HREF="#XBIOS">XBIOS</A>(2)+104*160}<A HREF="#=">=</A>&HFFFFFFFF
    <A HREF="#'">'</A>
    a$<A HREF="#=">=</A>"test"<A HREF="#+">+</A><A HREF="#CHR$">CHR$</A>(0)
    <A HREF="#PRINT">PRINT</A> <A HREF="#CHAR">CHAR</A>{V:a$}<A HREF="#;">;</A>
    <A HREF="#'">'</A>
    b$<A HREF="#=">=</A><A HREF="#SPACE$">SPACE$</A>(5)
    <A HREF="#CHAR">CHAR</A>{V:b$}<A HREF="#=">=</A>"word"
    <A HREF="#PRINT">PRINT</A> b$,<A HREF="#ASC">ASC</A>(<A HREF="#RIGHT$">RIGHT$</A>(b$))

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> First, some values are written directly to the screen memory and appear as
    lines. Then a$ is assigned conventionally, with a zero byte added, where
    upon it is read with <A HREF="#CHAR">CHAR</A><A HREF="#{}">{}</A> and printed. Then the word 'word' is written
    into the space made for it by assigning b$ as five spaces. The reassigned
    b$ is then printed, together with the <A HREF="#ASCII">ASCII</A> code of its last character, to
    prove that a null byte was indeed added to 'word'<A HREF="#.">.</A> The output is thus
    'test', 'word', and '0'<A HREF="#.">.</A>

<B>Memo:</B>
    t$<A HREF="#=">=</A><A HREF="#CHAR">CHAR</A>{addr%} does not check the resulting string size when compiled.
    Always test your code in the interpreter!
<HR SIZE=3><H2 ID="VARPTR">VARPTR</H2>
<A NAME="V:"></A><A NAME="ARRPTR"></A><A NAME="*"></A><A NAME="*variable_pointer"></A><A NAME="*var="></A><A NAME="descriptor"></A><A NAME="Descriptor"></A><B><A HREF="#VARPTR">VARPTR</A>(x)  V:x
<A HREF="#ARRPTR">ARRPTR</A>(y)  *y</B>

x, y: variable name of any type

<A HREF="#VARPTR">VARPTR</A>(x) or V:x returns the address of variables or strings or particular
elements of arrays. <A HREF="#VARPTR">VARPTR</A><A HREF="#()">()</A> and <A HREF="#V:">V:</A> have the same effect.

<A HREF="#ARRPTR">ARRPTR</A>(y) or *y returns the addresses of variables, but for strings or arrays
the address of the <A HREF="#Descriptor">Descriptor</A> is returned. <A HREF="#ARRPTR">ARRPTR</A><A HREF="#()">()</A> and <A HREF="#*">*</A> have the same effect.

<B>Example:</B>

    <A HREF="#DIM">DIM</A> x%(10)
    a$<A HREF="#=">=</A>"test"
    <A HREF="#PRINT">PRINT</A> <A HREF="#VARPTR">VARPTR</A>(x%(0)),V:x%(1),<A HREF="#ARRPTR">ARRPTR</A>(x%<A HREF="#()">()</A>)
    <A HREF="#PRINT">PRINT</A> <A HREF="#ARRPTR">ARRPTR</A>(a$),*a$,<A HREF="#VARPTR">VARPTR</A>(a$)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The third line prints the addresses of the first two elements of x%<A HREF="#()">()</A>,
    together with the address of the Array <A HREF="#Descriptor">Descriptor</A><A HREF="#.">.</A> The fourth line prints
    the address of the String <A HREF="#Descriptor">Descriptor</A> twice, followed by the address of the
    first byte of a$<A HREF="#.">.</A>

<HR>

*x (indirect array passing)

x: <A HREF="#svar">svar</A> or an array name followed by <A HREF="#()">()</A>

The multiply sign also serves as a pointer symbol. In this case *x gives the
address of the variable x in memory. With character strings *x$ gives the
address of the String <A HREF="#Descriptor">Descriptor</A> (as with <A HREF="#ARRPTR">ARRPTR</A>(x$))<A HREF="#.">.</A>

*x is synonymous with <A HREF="#ARRPTR">ARRPTR</A>(x)<A HREF="#.">.</A> This usage has special meaning with the
indirect passing of arrays and variables to subroutines. In addition one can
use, in Version 3, the instruction <A HREF="#VAR">VAR</A><A HREF="#.">.</A>

<A HREF="#*">*</A> as a command:
    *flt=0
    *flt=""
    *lng%=0
    *lng%<A HREF="#=">=</A>""

<B>Examples:</B>

    <A HREF="#'">'</A> Version 2              <A HREF="#&#124;">&#124;</A> ' Version 3
    <A HREF="#'">'</A>                        <A HREF="#&#124;">&#124;</A> '
    <A HREF="#'">'</A> indirect array passing <A HREF="#&#124;">&#124;</A> '
    <A HREF="#DIM">DIM</A> a(3)                 <A HREF="#&#124;">&#124;</A> DIM a(3)
    change(*a())             <A HREF="#&#124;">&#124;</A> change(a())
    <A HREF="#PRINT">PRINT</A> a(2)               <A HREF="#&#124;">&#124;</A> PRINT a(2)
    <A HREF="#'">'</A>                        <A HREF="#&#124;">&#124;</A> '
    <A HREF="#PROCEDURE">PROCEDURE</A> change(ptr%)   <A HREF="#&#124;">&#124;</A> PROCEDURE change(<A HREF="#VAR">VAR</A> x())
      <A HREF="#SWAP">SWAP</A> *ptr%,x()         <A HREF="#&#124;">&#124;</A>   <A HREF="#ARRAYFILL">ARRAYFILL</A> x(),1
      <A HREF="#ARRAYFILL">ARRAYFILL</A> x()          <A HREF="#&#124;">&#124;</A> <A HREF="#RETURN">RETURN</A>
      <A HREF="#SWAP">SWAP</A> *ptr%,x()         <A HREF="#&#124;">&#124;</A>
    <A HREF="#RETURN">RETURN</A>                   <A HREF="#&#124;">&#124;</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The contents of the array a() are changed, without its name being used in
    the procedure 'change'<A HREF="#.">.</A> The number 1 is printed on the screen (see also
    <A HREF="#SWAP">SWAP</A>)<A HREF="#.">.</A>

    t%=0
    <A HREF="#GOSUB">GOSUB</A> num(*t%)
    <A HREF="#PRINT">PRINT</A> t%
    t$<A HREF="#=">=</A>"set"
    <A HREF="#GOSUB">GOSUB</A> str(*t$)
    <A HREF="#PRINT">PRINT</A> t$
    <A HREF="#PROCEDURE">PROCEDURE</A> num(p%)
      *p%=22
    <A HREF="#RETURN">RETURN</A>
    <A HREF="#PROCEDURE">PROCEDURE</A> str(p%)
      *p%<A HREF="#=">=</A>"changed"
    <A HREF="#RETURN">RETURN</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Displays the number '22' and the word 'changed'<A HREF="#.">.</A>

<B>Memo:</B> Be careful using pointers to strings since <A HREF="#GFA-Basic">GFA-Basic</A> can move
      them and so the pointer becomes invalid.
      <A HREF="#*">*</A> as a command was never documented in the manual.

Poor example:
  p%=V:buffer$
  <A HREF="#BMOVE">BMOVE</A> <A HREF="#XBIOS">XBIOS</A>(2),p%,32000
  p% can become invalid later on in the program

Good example:
  <A HREF="#BMOVE">BMOVE</A> <A HREF="#XBIOS">XBIOS</A>(2),V:buffer$,32000
  this method forces the address to be fetched on demand

<HR>

<B>String <A HREF="#Descriptor">Descriptor</A></B>
 <A HREF="#/">/</A>-------------------------- <A HREF="#&">&</A>#60;array_address%<A HREF="#&#62;">&#62;</A>&#60;number_of_dimensions&&#62; (6 bytes)
 <A HREF="#&#124;">&#124;</A>                                  <A HREF="#&">&</A>#124;
 <A HREF="#&#124;">&#124;</A>                                  
 \<A HREF="#-">-</A>- <A HREF="#&">&</A>#60;backtrailer%<A HREF="#&#62;">&#62;</A>&#60;block_size%&#62;&#60;1st_dimension%&#62;&#60;string_address%&#62;&#60;string_length&&#62;
                                                      <A HREF="#&#124;">&#124;</A> 
            <A HREF="#/">/</A>-----------------------------------------/ <A HREF="#&#124;">&#124;</A>
                                                       <A HREF="#&#124;">&#124;</A>
     <A HREF="#&">&</A>#60;string_data...<A HREF="#&#62;">&#62;</A>&#60;null_filler_if_odd_length&#124;&#62;&#60;string_backtrailer%&#62;

<B>Numeric <A HREF="#Descriptor">Descriptor</A></B>
 <A HREF="#/">/</A>-------------------------- <A HREF="#&">&</A>#60;array_address%<A HREF="#&#62;">&#62;</A>&#60;number_of_dimensions&&#62; (6 bytes)
 <A HREF="#&#124;">&#124;</A>                                  <A HREF="#&">&</A>#124;
 <A HREF="#&#124;">&#124;</A>                                  
 \<A HREF="#-">-</A>- <A HREF="#&">&</A>#60;backtrailer%<A HREF="#&#62;">&#62;</A>&#60;block_size%&#62;&#60;1st_dimension%&#62;&#60;array_data...&#62;

<A HREF="#REM">REM</A> <A HREF="#DIM">DIM</A> av%(2) !even with this line commented out, this works
addr%<A HREF="#=">=</A>*av%<A HREF="#()">()</A>   !creates a null <A HREF="#descriptor">descriptor</A> if the array does not exist
<A HREF="#PRINT">PRINT</A> addr%    !one would expect an 'array not dimensioned' error
<HR SIZE=3><H2 ID="ABSOLUTE">ABSOLUTE</H2>
<B><A HREF="#ABSOLUTE">ABSOLUTE</A> v,a
<A HREF="#ABSOLUTE">ABSOLUTE</A> v=a</B>

v: a variable of arbitrary type
a: <A HREF="#iexp">iexp</A>

With the instruction <A HREF="#ABSOLUTE">ABSOLUTE</A> the address 'a' is given to the variable 'v'<A HREF="#.">.</A>

<B>Exampe:</B>

    <A HREF="#ABSOLUTE">ABSOLUTE</A> x,*y
    x=13
    y=7
    <A HREF="#PRINT">PRINT</A> x,y,*x,*y

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Here the variable x is assigned to the address of variable y, so that at
    the end both variables have the same value (7) and same address.

<B>Memo:</B> This command does not work with array type variables.
      For string variables: <A HREF="#ABSOLUTE">ABSOLUTE</A> a$,*b$   !works

      <A HREF="#'">'</A> make buffer
      a$<A HREF="#=">=</A>"blah"                     !print adr to verify string pool adr
      <A HREF="#INLINE">INLINE</A> test%,256
      <A HREF="#ABSOLUTE">ABSOLUTE</A> t$,test%             !set addr
      t$<A HREF="#=">=</A>"test"                     !set string
      <A HREF="#PRINT">PRINT</A> test%,*t$               <A HREF="#!">!</A><A HREF="#descriptor">descriptor</A> is placed in the buffer
      <A HREF="#PRINT">PRINT</A> <A HREF="#MKL$">MKL$</A>(<A HREF="#LONG">LONG</A>{LONG{test%}}) !dump string contents to veryify
      <A HREF="#PRINT">PRINT</A> V:a$,V:t$               !string data placed in string pool
<HR SIZE=3><H2 ID="Deleting_and_Exchanging">Deleting and Exchanging</H2>
<A HREF="#CLEAR">CLEAR</A>
<A HREF="#CLR">CLR</A>
<A HREF="#ERASE">ERASE</A>
<A HREF="#SWAP">SWAP</A>
<A HREF="#INSERT">INSERT</A>, <A HREF="#DELETE">DELETE</A>
<A HREF="#QSORT">QSORT</A>, <A HREF="#SSORT">SSORT</A>
<HR SIZE=3><H2 ID="CLEAR">CLEAR</H2>
<A NAME="CLR"></A><A NAME="ERASE"></A><B><A HREF="#CLEAR">CLEAR</A>
<A HREF="#CLR">CLR</A> x[,y,<A HREF="#.">.</A>..]
<A HREF="#ERASE">ERASE</A> z1()[,x2(),<A HREF="#.">.</A>..]</B>

x, y: <A HREF="#svar">svar</A> or <A HREF="#avar">avar</A>
z1, x2: name of arbitrary array

With <A HREF="#CLEAR">CLEAR</A> all variables and arrays are emptied. The instruction cannot be used
within <A HREF="#FOR">FOR</A><A HREF="#-">-</A><A HREF="#NEXT">NEXT</A> loops or subroutines. When a program is <A HREF="#RUN">RUN</A> it is implemented
automatically, otherwise it is really only applicable for dealing with serious
faults before using <A HREF="#RESUME">RESUME</A> <A HREF="#proc">proc</A> appropriately. All open channels will be closed
as well.

The instruction <A HREF="#CLR">CLR</A> sets all variables specified in the list following it to 0
or "" depending on it's type. <A HREF="#Arrays">Arrays</A> cannot be used with <A HREF="#CLR">CLR</A>, see <A HREF="#ARRAYFILL">ARRAYFILL</A>.

<A HREF="#ERASE">ERASE</A> deletes complete arrays, which can then be redimensioned if required. In
contrast to Version 2, several arrays can be deleted at once, for example <A HREF="#ERASE">ERASE</A>
x(),y()<A HREF="#.">.</A>

<B>Example:</B>

    x=2
    y=3
    <A HREF="#CLEAR">CLEAR</A>
    <A HREF="#PRINT">PRINT</A> x,y
    <A HREF="#'">'</A>
    x=2
    y=3
    <A HREF="#CLR">CLR</A> x
    <A HREF="#PRINT">PRINT</A> x,y
    <A HREF="#'">'</A>
    <A HREF="#DIM">DIM</A> x(10)
    <A HREF="#PRINT">PRINT</A> <A HREF="#FRE">FRE</A>(0)
    <A HREF="#ERASE">ERASE</A> x()
    <A HREF="#PRINT">PRINT</A> <A HREF="#FRE">FRE</A>(0)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The above program prints three zeros and a '3' on the screen. After that
    the amount of free memory is displayed both before and after the erasure
    of x(), showing that the memory occupied by the array is released by
    <A HREF="#ERASE">ERASE</A><A HREF="#.">.</A>

<B>Memo:</B> The command <A HREF="#ERASE">ERASE</A> should be avoided as it can lead to many hard to
      find errors.

      <A HREF="#CLEAR">CLEAR</A> closes all open channels, as if <A HREF="#'">'</A><A HREF="#CLOSE">CLOSE</A>' was executed.
      <A HREF="#CLEAR">CLEAR</A> also resets the <A HREF="#_DATA">_DATA</A> pointer back to the first <A HREF="#DATA">DATA</A> statement.
      This happens in the editor and compiled programs.
      This information was missing from the manual.

      Also clears the event flags for all 'ON x <A HREF="#GOSUB">GOSUB</A>' commands.
      This only happens in the editor.

      <A HREF="#CLEAR">CLEAR</A> inside a <A HREF="#FOR">FOR</A><A HREF="#-">-</A><A HREF="#NEXT">NEXT</A> loop or subroutine is fatal.
      <A HREF="#ERROR">ERROR</A> code #40 does not actually work.
<HR SIZE=3><H2 ID="SWAP">SWAP</H2>
<B><A HREF="#SWAP">SWAP</A> a,b</B>
<B><A HREF="#SWAP">SWAP</A> e(),f()</B>
<B><A HREF="#SWAP">SWAP</A> *c,d()</B>

a, b: <A HREF="#avar">avar</A> or <A HREF="#svar">svar</A>
c: pointer to an array <A HREF="#descriptor">descriptor</A>
d, e, f: names of arrays

In its most simple variant the instruction <A HREF="#SWAP">SWAP</A> serves to exchange two
variables of the same type (<A HREF="#SWAP">SWAP</A> a,b), In addition, it can be used for
exchanging two arrays. The process is fast, since in fact only the associated
Descriptors are exchanged, having the effect of also exchanging the
dimensioning of the two arrays. <A HREF="#Arrays">Arrays</A> do not need to be dimensioned for this.
The third variant, where one of the descriptors is addressed directly, is
mainly useful for the indirect passing of arrays to subroutines (see second
example)<A HREF="#.">.</A>

<B>Note:</B> The instruction <A HREF="#SWAP">SWAP</A> should be clearly differentiated from the
      function <A HREF="#SWAP()">SWAP()</A>, which is discussed in the section on bit operations.

<B>Examples:</B>

    x=1
    y=2
    <A HREF="#PRINT">PRINT</A> x,y
    <A HREF="#SWAP">SWAP</A> x,y
    <A HREF="#PRINT">PRINT</A> x,y

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The numbers 1, 2, and then 2 and 1 are displayed.

    <A HREF="#DIM">DIM</A> x(3)
    change(*x())
    <A HREF="#PRINT">PRINT</A> x(2)
    <A HREF="#'">'</A>
    <A HREF="#PROCEDURE">PROCEDURE</A> change(adr%)
      <A HREF="#SWAP">SWAP</A> *adr%,a()
      <A HREF="#ARRAYFILL">ARRAYFILL</A> a(),1
      <A HREF="#SWAP">SWAP</A> *adr%,a()
    <A HREF="#RETURN">RETURN</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The array x() is filled with 1's in the procedure CHANGE without reference
    to the name x(), so the subroutine is of general use. The <A HREF="#Descriptor">Descriptor</A>
    address is handed over to the subroutine and by means of <A HREF="#SWAP">SWAP</A>, the array is
    addressed under the name a()<A HREF="#.">.</A>

In Version 3 the array name itself can be passed:

    <A HREF="#DIM">DIM</A> x(3)
    change(x())
    <A HREF="#PRINT">PRINT</A> x(2)
    <A HREF="#'">'</A>
    <A HREF="#PROCEDURE">PROCEDURE</A> change(<A HREF="#VAR">VAR</A> a())
      <A HREF="#ARRAYFILL">ARRAYFILL</A> a(),1
    <A HREF="#RETURN">RETURN</A>
<HR SIZE=3><H2 ID="QSORT">QSORT</H2>
<A NAME="SSORT"></A><A NAME="xSORT"></A><B><A HREF="#QSORT">QSORT</A> a([s]) [,n[,j%<A HREF="#()">()</A>]]
<A HREF="#QSORT">QSORT</A> s$([s]) [<A HREF="#OFFSET">OFFSET</A> o] [WITH i()] [,n[,j%()]]
<A HREF="#SSORT">SSORT</A> a([s]) [,n[,j%<A HREF="#()">()</A>]]
<A HREF="#SSORT">SSORT</A> s$([s]) [<A HREF="#OFFSET">OFFSET</A> o] [WITH i()] [,n[,j%()]]</B>

a()<A HREF="#:">:</A> arbitrary array, or string array
i()<A HREF="#:">:</A> integer-array (<A HREF="#&#124;">&#124;</A>, <A HREF="#&">&</A> or <A HREF="#%">%</A>) with at least 256 entries
j%()<A HREF="#:">:</A> 4-byte integer array
s$()<A HREF="#:">:</A> string array
n: <A HREF="#iexp">iexp</A>
o: <A HREF="#iexp">iexp</A>
s: <A HREF="#+">+</A>, <A HREF="#-">-</A>, or no sign

You can <A HREF="#xSORT">xSORT</A> string fields with an <A HREF="#OFFSET">OFFSET</A> only from version 3.02 on wards.
The <A HREF="#OFFSET">OFFSET</A> determines how many characters off the beginning shall not be
considered; e.g.

    <A HREF="#DIM">DIM</A> a$(256)
    <A HREF="#FILES">FILES</A> "<A HREF="#*">*</A><A HREF="#.">.</A>*" TO "LISTE"
    <A HREF="#OPEN">OPEN</A> "I",#1,"LISTE"
    <A HREF="#RECALL">RECALL</A> #1,a$<A HREF="#()">()</A>,-1,x%
    <A HREF="#CLOSE">CLOSE</A> #1
    <A HREF="#QSORT">QSORT</A> a$<A HREF="#()">()</A> <A HREF="#OFFSET">OFFSET</A> 13,x%
    <A HREF="#OPEN">OPEN</A> "O",#1,"<A HREF="#CON:">CON:</A>"
    <A HREF="#STORE">STORE</A> #1,a$<A HREF="#()">()</A>,x%
    <A HREF="#CLOSE">CLOSE</A> #1

This program gives the directory as a file "LISTE", with <A HREF="#RECALL">RECALL</A> the array a$<A HREF="#()">()</A>
gets the contents, then the directory is sorted and STOREd to "<A HREF="#CON:">CON:</A>"<A HREF="#.">.</A> By giving
the <A HREF="#OFFSET">OFFSET</A> 13 it is not sorted by name but by the length of the files. " " and
"<A HREF="#*">*</A>" and "12345678.123" is skipped.

The instructions <A HREF="#SSORT">SSORT</A> and OSORT allow the elements of an array to be sorted
according to their size. <A HREF="#SSORT">SSORT</A> utilizes the Shellsort and OSORT the Ouicksort.
In the brackets of the array name a plus or minus sign may be inserted, meaning
that the sort is to be done in ascending or descending order respectively. If
neither is specified, the sort by default will be done in ascending order, as
with "<A HREF="#+">+</A>"<A HREF="#.">.</A>

The parameter "n" specifies that only the first "n" elements of the array are
to be sorted. If <A HREF="#OPTION_BASE">OPTION BASE</A> 0 is active (the default) these are the elements
from 0 to n-1; if <A HREF="#OPTION_BASE">OPTION BASE</A> 1 is active then elements from 1 to n are sorted.
If n=-1 then the whole array will be sorted.

When a further integer array is specified as the third parameter, that array
will be sorted along with the first array. Each exchange of elements in the
first array is also carried out in the second. This facility can be used, for
example, if one array contains a sort code, e.g. a post code, and another array
contains related information.

During the sorting of string arrays a sorting criterion can be specified in
form of an array with at least 256 elements by means of WITH. Without
indication of WITH the normal <A HREF="#ASCII">ASCII</A> order is used as a sorting criterion (see
second example)<A HREF="#.">.</A>

<B>Examples:</B>

    <A HREF="#DIM">DIM</A> x%(20)
    <A HREF="#PRINT">PRINT</A> "Unsorted: "<A HREF="#;">;</A>
    <A HREF="#FOR">FOR</A> i%=0 TO 10
      x%(i%)<A HREF="#=">=</A><A HREF="#RAND">RAND</A>(9)+1
      <A HREF="#PRINT">PRINT</A> x%(i%)<A HREF="#;">;</A>" ";
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#'">'</A>
    <A HREF="#QSORT">QSORT</A> x%<A HREF="#()">()</A>,11
    <A HREF="#DIM">DIM</A> <A HREF="#index">index</A><A HREF="#%">%</A>(210)
    <A HREF="#PRINT">PRINT</A> "Descending sort: "<A HREF="#;">;</A>
    <A HREF="#FOR">FOR</A> i%=0 TO 10
      <A HREF="#PRINT">PRINT</A> x%(i%)<A HREF="#;">;</A>" ";
      <A HREF="#index">index</A><A HREF="#%">%</A>(i%)=i%
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#'">'</A>
    <A HREF="#SSORT">SSORT</A> x%(<A HREF="#-">-</A>),11,<A HREF="#index">index</A>%<A HREF="#()">()</A>
    <A HREF="#PRINT">PRINT</A> "Ascending sort: "<A HREF="#;">;</A>
    <A HREF="#FOR">FOR</A> i%=0 TO 10
      <A HREF="#PRINT">PRINT</A> x%(i%)<A HREF="#;">;</A>" ";
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#PRINT">PRINT</A> "Sort WITH array: "<A HREF="#;">;</A>
      <A HREF="#FOR">FOR</A> i%=0 TO 10
      <A HREF="#PRINT">PRINT</A> <A HREF="#index">index</A><A HREF="#%">%</A>(i%)<A HREF="#;">;</A>" ";
    <A HREF="#NEXT">NEXT</A> i%

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Gives an unsorted field and two sorted series from random numbers. In a
    fourth row the values of a second field that was sorted alongside the first
    one displayed.

<B>Memo:</B> These commands use self modifying code internally and may not work
      correctly on CPUs with caches, such as an 060.
<HR SIZE=3><H2 ID="INSERT">INSERT</H2>
<A NAME="DELETE"></A><B><A HREF="#INSERT">INSERT</A> x(i)=y
<A HREF="#DELETE">DELETE</A> x(i)</B>

x: name of an array
i: <A HREF="#iexp">iexp</A>
y: <A HREF="#aexp">aexp</A> or <A HREF="#sexp">sexp</A>, according to variable type of the array

With the instruction <A HREF="#INSERT">INSERT</A> an array element can be inserted. With the
instruction <A HREF="#DELETE">DELETE</A> an array element can be deleted.

<A HREF="#INSERT">INSERT</A> inserts the value of the expression y in the array x() at the position
i. All elements of the array which have an <A HREF="#index">index</A> larger than i are shifted up
one position. Thus if an element stood at position 3 before, then it will be
found at position 4 after the <A HREF="#INSERT">INSERT</A> instruction. The last element of the array
is deleted.

<A HREF="#DELETE">DELETE</A> removes the i-th element of the array x()<A HREF="#.">.</A> All array elements which have
an <A HREF="#index">index</A> larger than i are shifted down one position. The last element of the
array is made zero (or a null string with character string arrays)<A HREF="#.">.</A>

These instructions are highly suitable for the management of lists, in which
elements are constantly being inserted or deleted.

<B>Examples:</B>

    <A HREF="#DIM">DIM</A> x%(5)
    <A HREF="#FOR">FOR</A> i%=1 TO 5
      x%(i%)=i%
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#INSERT">INSERT</A> x%(3)=33
    <A HREF="#FOR">FOR</A> i%=0 TO 5
      <A HREF="#PRINT">PRINT</A> x%(i%)
    <A HREF="#NEXT">NEXT</A> i%

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The numbers 0, 1, 2, 33, 3, and 4 are printed on the screen.

    <A HREF="#DIM">DIM</A> x%(5)
    <A HREF="#FOR">FOR</A> i%=1 TO 5
      x%(i%)=i%
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#DELETE">DELETE</A> x%(3)
    <A HREF="#FOR">FOR</A> i%=0 TO 5
      <A HREF="#PRINT">PRINT</A> x%(i%)
    <A HREF="#NEXT">NEXT</A> i%

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The numbers 0, 1, 4, 5, and 0 are printed on the screen.

<B>Memo:</B> This works in the editor but not compiled: <A HREF="#INSERT">INSERT</A> a%(j&)=a%(j&+1)
      Boolean arrays are not supported by these commands.
<HR SIZE=3><H2 ID="Reserved_Variables">Reserved Variables</H2>
<A HREF="#FALSE">FALSE</A>,<A HREF="#TRUE">TRUE</A>
<A HREF="#PI">PI</A>
<A HREF="#DATE$">DATE$</A>, <A HREF="#TIME$">TIME$</A>
<A HREF="#DATE$=">DATE$=</A>, <A HREF="#TIME$=">TIME$=</A>
<A HREF="#SETTIME">SETTIME</A>
<A HREF="#TIMER">TIMER</A>
<A HREF="#_C">_C</A>, <A HREF="#_X">_X</A>, <A HREF="#_Y">_Y</A>
<HR SIZE=3><H2 ID="PI">PI</H2>
<A NAME="FALSE"></A><A NAME="TRUE"></A><B><A HREF="#FALSE">FALSE</A>
<A HREF="#TRUE">TRUE</A>
<A HREF="#PI">PI</A></B>

The logical constant <A HREF="#FALSE">FALSE</A> returns the value 0.

The logical constant <A HREF="#TRUE">TRUE</A> returns the value -1.

The constant <A HREF="#PI">PI</A> returns the value of the transcendental number pi
(3.14159265359).

<B>Example:</B>

    <A HREF="#PRINT">PRINT</A> <A HREF="#FALSE">FALSE</A>
    <A HREF="#IF">IF</A> <A HREF="#TRUE">TRUE</A>
      <A HREF="#PRINT">PRINT</A> <A HREF="#PI">PI</A>
    <A HREF="#ENDIF">ENDIF</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Prints the numbers 0 and 3.14159265359 on the screen.

<B>Memo:</B> Be very careful porting source code from other languages.
      Often <A HREF="#TRUE">TRUE</A> returns 1 in other languages.
<HR SIZE=3><H2 ID="SETTIME">SETTIME</H2>
<A NAME="DATE$"></A><A NAME="TIME$"></A><A NAME="DATE$="></A><A NAME="TIME$="></A><A NAME="TIMER"></A><B><A HREF="#DATE$">DATE$</A>
<A HREF="#TIME$">TIME$</A>
<A HREF="#SETTIME">SETTIME</A> [time$],date$
<A HREF="#DATE$">DATE$</A>=date$
<A HREF="#TIME$">TIME$</A>=time$
<A HREF="#TIMER">TIMER</A></B>

time$, date$<A HREF="#:">:</A> string variable

<A HREF="#DATE$">DATE$</A> returns the system date in the format:

    DD.MM.YYYY  (Day, Month, Year)

or

    MM/DD/YYYY  (US format, see <A HREF="#MODE">MODE</A>)

<B>Note:</B> Only years between 1980 and 2079 are allowed.

<A HREF="#TIME$">TIME$</A> returns the system time in the format:

    HH:MM:SS  (Hours, Minutes, Seconds)

<B>Note:</B> The time is updated every two seconds.

With the instuction <A HREF="#SETTIME">SETTIME</A> both the date and time can be set. The strings must
have the same format as for <A HREF="#TIME$">TIME$</A> and <A HREF="#DATE$">DATE$</A><A HREF="#.">.</A> If <A HREF="#SETTIME">SETTIME</A> is given strings in the
wrong format, then the current values are not changed.

The date and time can also be set individually with <A HREF="#DATE$=">DATE$=</A> and <A HREF="#TIME$=">TIME$=</A><A HREF="#.">.</A>

<A HREF="#TIMER">TIMER</A> returns the elapsed time in 1/200 of a second since the system was
powered up.

<B>Examples:</B>

    <A HREF="#PRINT">PRINT</A> <A HREF="#DATE$">DATE$</A>,<A HREF="#TIME$">TIME$</A>
    <A HREF="#SETTIME">SETTIME</A> "20:15:30","27.2.1988"
    <A HREF="#PRINT">PRINT</A> <A HREF="#DATE$">DATE$</A>,<A HREF="#TIME$">TIME$</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The system date and time are printed, reset, and printed again.

    t%<A HREF="#=">=</A><A HREF="#TIMER">TIMER</A>
    <A HREF="#FOR">FOR</A> i%=1 to 2500
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#PRINT">PRINT</A> (<A HREF="#TIMER">TIMER</A><A HREF="#-t">-t</A><A HREF="#%">%</A>)/200

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The time in seconds required for the <A HREF="#FOR">FOR</A>-<A HREF="#NEXT">NEXT</A> loop is displayed.

<B>Memo:</B> t%<A HREF="#=">=</A><A HREF="#TIMER">TIMER</A> is the same as t%=<A HREF="#LPEEK">LPEEK</A>(&H4BA)<A HREF="#.">.</A> Returns system timer B.
      I suppose its possible the <A HREF="#TIMER">TIMER</A> could roll over eventually, one idea is
      to use this method: diff%<A HREF="#=">=</A><A HREF="#ABS">ABS</A>(<A HREF="#TIMER">TIMER</A>-tsave%)

      <A HREF="#TIME$">TIME$</A> is returned in 24 hour format, same as <A HREF="#GEMDOS">GEMDOS</A><A HREF="#()">()</A><A HREF="#.">.</A>

Tgetdate()<A HREF="#+">+</A>, Tgettime()+, Tsetdate()+, Tsettime()+, Settime()+
<HR SIZE=3><H2 ID="_C">_C</H2>
<A NAME="_X"></A><A NAME="_Y"></A><B><A HREF="#_C">_C</A>
<A HREF="#_X">_X</A>
<A HREF="#_Y">_Y</A></B>

<A HREF="#_C">_C</A> returns the number of color registers.

<A HREF="#_X">_X</A> returns the current window width in pixels.

<A HREF="#_Y">_Y</A> returns the current window height in pixels.

<B>Memo:</B> <A HREF="#_C">_C</A> <A HREF="#=">=</A> <A HREF="#WORK_OUT">WORK_OUT</A>(13) which is safe to use.
      <A HREF="#_X">_X</A> and <A HREF="#_Y">_Y</A> are initialized via <A HREF="#Line-A">Line-A</A> variables and then changed by some
      window commands if used.

      <A HREF="#_X">_X</A> <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> V_REZ_HZ (<A HREF="#Line-A">Line-A</A> variables)
      <A HREF="#_Y">_Y</A> <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> V_REZ_VT

      Avoid, <A HREF="#_X">_X</A> and <A HREF="#_Y">_Y</A> as they change based on the window commands used.
      <A HREF="#_X">_X</A> and <A HREF="#_Y">_Y</A> return width and height unlike the <A HREF="#WORK_OUT">WORK_OUT</A><A HREF="#()">()</A> values which are
      the maximum coordinates allowed. Thus: <A HREF="#_X">_X</A> <A HREF="#=">=</A> <A HREF="#WORK_OUT">WORK_OUT</A>(0)+1

      ST low resolution example:
      <A HREF="#_X">_X</A>=320           <A HREF="#_Y">_Y</A>=200
      <A HREF="#WORK_OUT">WORK_OUT</A>(0)=319  WORK_OUT(1)=199

<A HREF="#Line-A_Variable_Table">Line-A Variable Table</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="Special">Special</H2>
<A HREF="#LET">LET</A>
<A HREF="#VOID">VOID</A>, <A HREF="#~">~</A>
<HR SIZE=3><H2 ID="LET">LET</H2>
<B><A HREF="#LET">LET</A> x=y</B>

x: <A HREF="#avar">avar</A> or <A HREF="#svar">svar</A>
y: <A HREF="#aexp">aexp</A> or <A HREF="#sexp">sexp</A>

With <A HREF="#LET">LET</A>, values can be assigned to variables whose names are keywords.

By means of <A HREF="#LET">LET</A> one can transfer the value of an expression to a variable.  The
expression and the variable must either be both numerical or both character
strings. Normally <A HREF="#LET">LET</A> is not necessary: it served in older BASIC's to allow the
use of keywords as variable names. However, <A HREF="#GFA-Basic">GFA-Basic</A> usually recognizes
automatically when a keyword is used in this way and allows it.

<B>Example:</B>

    <A HREF="#LET">LET</A> print=3
    <A HREF="#PRINT">PRINT</A> print

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The number '3' is displayed on the screen.
<HR SIZE=3><H2 ID="VOID">VOID</H2>
<A NAME="~"></A><B><A HREF="#VOID">VOID</A> fx
~fi</B>

fx: <A HREF="#aexp">aexp</A>
fi: <A HREF="#iexp">iexp</A>

<A HREF="#VOID">VOID</A> invokes a function but ignores the returned value.

Programming langnages normally differentiate between commands and functions.
Both cause some activity to be carried out, but with functions this activity
'returns' a value, which may be used as an element of an expression, displayed
with <A HREF="#PRINT">PRINT</A> or assigned to a variable etc.

Often, however, the programmer is not interested in the returned value, but
only in the activity carried out. For example, the function <A HREF="#INP">INP</A>(2) returns the
<A HREF="#ASCII">ASCII</A> code of a pressed key. If the program is only supposed to wait for a key,
any key, to be pressed, then the code of the key is irrelevant.

With <A HREF="#GFA-Basic">GFA-Basic</A>, in such a case <A HREF="#VOID">VOID</A> can be used to implement the function,
'forgetting' about the returned value. The alternative form (with a tilde '<A HREF="#~">~</A>'
instead of <A HREF="#VOID">VOID</A> calculates an integer value before forgetting it, making it
faster than <A HREF="#VOID">VOID</A>, which calculates a floating-point value.

<B>Example:</B>

    <A HREF="#VOID">VOID</A> <A HREF="#INP">INP</A>(2)

or

    <A HREF="#~">~</A><A HREF="#INP">INP</A>(2)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Waits for a key to be pressed. Which key it was, however, will be unknown
    to the program, as the returned code is lost.

<B>Memo:</B> Void cannot be used with string functions:
        <A HREF="#VOID">VOID</A> <A HREF="#INPUT$">INPUT$</A>(28,#1)  !syntax error
      This trick works:
        <A HREF="#~">~</A><A HREF="#LEN">LEN</A>(<A HREF="#INPUT$">INPUT$</A>(28,#1))
<HR SIZE=3><H2 ID="Memory_Management">Memory Management</H2>
<A HREF="#FRE">FRE</A><A HREF="#()">()</A>
<A HREF="#BMOVE">BMOVE</A>
<A HREF="#BASEPAGE">BASEPAGE</A>, <A HREF="#HIMEM">HIMEM</A>
<A HREF="#RESERVE">RESERVE</A>
<A HREF="#INLINE">INLINE</A>
<A HREF="#MALLOC">MALLOC</A><A HREF="#()">()</A>, <A HREF="#MSHRINK">MSHRINK</A>(), <A HREF="#MFREE">MFREE</A>()

<B>Memo:</B> For inforamation related to the compiler and memory management see
      section <A HREF="#'">'</A><A HREF="#Reserving_Memory_Space">Reserving Memory Space</A>'<A HREF="#.">.</A>

<HR SIZE=3><H2 ID="FRE">FRE</H2>
<B><A HREF="#FRE">FRE</A>([x])</B>

x: <A HREF="#aexp">aexp</A>

This function computes the amount of free available memory. The parameter x is
ignored, but if it is present a 'Garbage Collection' is carried out first
(non-current versions of strings are deleted and the memory occupied by them
freed)<A HREF="#.">.</A> <A HREF="#FRE">FRE</A><A HREF="#()">()</A> results in the free memory being calculated without the Garbage
Collection.

<B>Example:</B>

    free%<A HREF="#=">=</A><A HREF="#FRE">FRE</A>(0)
    max%=free%/3/4
    <A HREF="#DIM">DIM</A> x%(max%)
    <A HREF="#PRINT">PRINT</A> free%,max%

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> An array is dimensioned so that it occupies for instance a third of the
    free memory space. An integer array occupies 4 bytes per element, thus the
    extra division by 4.

<B>Memo:</B> A compiled program should regularly force a 'Garbage Collection' to
      insure that the program does not run out of string space. There is a bug
      related to the Garbage Collection.  If the string ram drops to low
      (within 16 bytes of running out of ram) a crash can occur.

<B>Example:</B>

    <A HREF="#IF">IF</A> <A HREF="#FRE">FRE</A><A HREF="#()">()</A><A HREF="#&">&</A>#60;32768 !less than 32k of free ram inside our program?
      <A HREF="#~">~</A><A HREF="#FRE">FRE</A>(0)      !force garbage collection and free unused strings
    <A HREF="#ENDIF">ENDIF</A>
<HR SIZE=3><H2 ID="BMOVE">BMOVE</H2>
<B><A HREF="#BMOVE">BMOVE</A> source,destination,length</B>

source, destination, length: <A HREF="#iexp">iexp</A>

<A HREF="#BMOVE">BMOVE</A> copies a block of memory from one area to another. 'source' is the
address of the first byte of the block to be copied, 'destination' is the
address of the first byte of the area to which the block is to be copied, and
'length' is the length of the block.

The instruction works noticeably faster with even parameters than with odd.  It
also works if the source and destination areas overlap.

<B>Example:</B>

    <A HREF="#DIM">DIM</A> screen2%(64000/4)
    adr%<A HREF="#=">=</A><A HREF="#VARPTR">VARPTR</A>(screen2%(0))
    <A HREF="#FOR">FOR</A> i%=0 TO 300 <A HREF="#STEP">STEP</A> 100
      <A HREF="#PBOX">PBOX</A> 0,i%,639,i%+50
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#PRINT">PRINT</A> "hi there!"
    <A HREF="#'">'</A> <A HREF="#XBIOS">XBIOS</A>(2) <A HREF="#=">=</A> the start-of-screen address
    <A HREF="#BMOVE">BMOVE</A> <A HREF="#XBIOS">XBIOS</A>(2),adr%,32000
    <A HREF="#BMOVE">BMOVE</A> <A HREF="#XBIOS">XBIOS</A>(2),adr%+32000,32000
    <A HREF="#REPEAT">REPEAT</A>
      <A HREF="#IF">IF</A> <A HREF="#MOUSEY">MOUSEY</A><A HREF="#&#60;">&#60;</A><A HREF="#&">&</A>#62;my%
        <A HREF="#BMOVE">BMOVE</A> adr%+my%*80,<A HREF="#XBIOS">XBIOS</A>(2),32000
        my%<A HREF="#=">=</A><A HREF="#MOUSEY">MOUSEY</A>
      <A HREF="#ENDIF">ENDIF</A>
    <A HREF="#UNTIL">UNTIL</A> <A HREF="#MOUSEK">MOUSEK</A>=2

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Vertical movement of the mouse scroll the screen up and down.
<HR SIZE=3><H2 ID="BASEPAGE">BASEPAGE</H2>
<A NAME="HIMEM"></A><B><A HREF="#BASEPAGE">BASEPAGE</A>
<A HREF="#HIMEM">HIMEM</A></B>

In the variable <A HREF="#BASEPAGE">BASEPAGE</A> is the address of the Basepage of the <A HREF="#GFA-Basic">GFA-Basic</A>
Interpreter, <A HREF="#BASEPAGE">BASEPAGE</A> is a 256-byte long storage area as follows:

<B>Bytes    Contents</B>
  0-  3  Address of the start of TPA (Transient Program Area)
  4-  7  Address of the end of TPA plus 1
  8- 11  Address of Text segment of the program
 12- 15  Length of the Text segment
 16- 19  Address of the Data segment
 20- 23  Length of the Data segment
 24- 27  Address of the BSS (Block Storage Segment)
 28- 31  Length of the BSS
 32- 35  Address of the <A HREF="#DTA">DTA</A> (Disk Transfer Address)
 36- 39  Address of the Basepage of the calling program
 40- 43  Reserved
 44- 47  Address of the Environment Strings
 48-127  Reserved
128-255  Command line (first byte specifies length of command text)

The variable <A HREF="#HIMEM">HIMEM</A> gives the address of the first free memory location not
used by <A HREF="#GFA-Basic">GFA-Basic</A><A HREF="#.">.</A> This is normally 16384 bytes below the screen area.

<B>Example:</B>

    a%<A HREF="#=">=</A><A HREF="#LONG">LONG</A>{<A HREF="#BASEPAGE">BASEPAGE</A><A HREF="#+">+</A>&H2C}
    <A HREF="#DO">DO</A>
      a$<A HREF="#=">=</A><A HREF="#CHAR">CHAR</A>{a%}
      <A HREF="#EXIT_IF">EXIT IF</A> <A HREF="#LEN">LEN</A>(a$)=0
      <A HREF="#PRINT">PRINT</A> a$
      <A HREF="#ADD">ADD</A> a%,<A HREF="#SUCC">SUCC</A>(<A HREF="#LEN">LEN</A>(a$)) <A HREF="#!">!</A> <A HREF="#SUCC()">SUCC()</A> <A HREF="#=">=</A> next higher integer
    <A HREF="#LOOP">LOOP</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Here the complete BASIC Environment is displayed.

<B>Memo:</B> <A HREF="#BASEPAGE">BASEPAGE</A> as defined by MiNT <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> <A HREF="#BASEPAGE.H">BASEPAGE.H</A>
      <A HREF="#HIMEM">HIMEM</A> should be avoided. If you need additional ram see <A HREF="#MALLOC">MALLOC</A><A HREF="#()">()</A>.
      <A HREF="#BASEPAGE">BASEPAGE</A>+32 will change if one calls <A HREF="#FSETDTA">FSETDTA</A><A HREF="#()">()</A><A HREF="#.">.</A>

      comp_!<A HREF="#=">=</A><A HREF="#BYTE">BYTE</A>{<A HREF="#BASEPAGE">BASEPAGE</A>+256}<A HREF="#&#60;">&#60;</A><A HREF="#&">&</A>#62;96   !false=interpreted/true=compiled
        96 <A HREF="#=">=</A> interpreted (bra.s)
        65 <A HREF="#=">=</A> compiled    (lea)
      dacc_!<A HREF="#=">=</A><A HREF="#LONG">LONG</A>{<A HREF="#BASEPAGE">BASEPAGE</A>+36}=<A HREF="#FALSE">FALSE</A>  !false=prg/true=acc
        0  <A HREF="#=">=</A> acc
        <A HREF="#&">&</A>#62;0 <A HREF="#=">=</A> prg

<A HREF="#BASEPAGE">BASEPAGE</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="RESERVE">RESERVE</H2>
<B><A HREF="#RESERVE">RESERVE</A> [n]</B>

n: <A HREF="#iexp">iexp</A>

The size of the storage area used by <A HREF="#GFA-Basic">GFA-Basic</A> can be specified. If n is
positive, then n bytes are reserved for the Interpreter and the remainder is
released. If n is negative, then the whole of the free memory less n bytes is
reserved.

If no parameter is specified, the state when the Interpreter was started is
restored.

<B>Note:</B> Memory can be reserved only in blocks of 256 bytes.

The instruction can be used, for instance, in order to release a storage area
for data or Resource files. If the storage area for <A HREF="#GFA-Basic">GFA-Basic</A> is reduced with
<A HREF="#RESERVE">RESERVE</A>, then one should not forget to enlarge it again later since otherwise
the available space becomes smaller with each execution of the program.

<B>Example:</B>

    <A HREF="#RESERVE">RESERVE</A> 2560
    <A HREF="#EXEC">EXEC</A> 0,"\PROGRAM.PRG","",""
    <A HREF="#RESERVE">RESERVE</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> 2560 bytes are reserved for the Interpreter, and PROGRAM.PRG (if available)
    is loaded and started. After exiting from PROGRAM.PRG the reserved space is
    restored.

<B>Memo:</B> Should not be used in compiled programs. Use $mx and <A HREF="#MALLOC">MALLOC</A><A HREF="#()">()</A>
      instead. <A HREF="#RESERVE">RESERVE</A> with no parameter appears to be broken. Very unstable
      under multi-tasking operating systems, such as MiNT.

      <A HREF="#-">-</A>-----------------------------------------------------------------------
      Copied from the 'GFA Basic FAQ (English)' (untested by me)
      The following known version problems exist with the function:

      <A HREF="#RESERVE">RESERVE</A> n
      Will often hang the interpreter in v3.5, probably because of fragmented
      variable space.

      <A HREF="#RESERVE">RESERVE</A> -n
      Has no effect in v3.6, but the same effect can be had with
      <A HREF="#'">'</A><A HREF="#RESERVE">RESERVE</A> <A HREF="#FRE">FRE</A>(0)<A HREF="#-s">-s</A>'<A HREF="#.">.</A>

      <A HREF="#RESERVE">RESERVE</A> (no parameter)
      Does not work at all in v3.6, i.e. we cannot restore the reserve state.

      The last fault is the most serious, since repeated running of a program
      which resizes the interpreter's memory will rather quickly crash due to
      memory shortage.
<HR SIZE=3><H2 ID="INLINE">INLINE</H2>
<B><A HREF="#INLINE">INLINE</A> addr,length</B>

addr: 4-byte integer variable, (not an array variable)
length: integer constant, less than 32700

This instruction reserves an area of memory within a program.

No comment is possible on the same line as this instruction, since memory is
internally reserved where otherwise the comment would be.

The reserved area always begins at an even address and it is initially filled
with zeros. When implementing <A HREF="#INLINE">INLINE</A> this address is written to the integer
variable addr. When the program is loaded or saved, the reserved memory area is
also.

Positioning the cursor on the program line which contains the <A HREF="#INLINE">INLINE</A>
instruction and pressing the <A HREF="#Help">Help</A> key causes a menu line with the entries Load,
Save, Dump, and Clear to appear on the top line of the editor.




<B>Load</B> is used to load a machine code program or data into the reserved area.
<B>Save</B> saves the contents of the reserved area to disk.
<B>Dump</B> causes a hexadecimal printout on the printer of the reserved area.
<B>Clear</B> fills the reserved area with zeros.

If the <A HREF="#INLINE">INLINE</A> instruction is deleted, so also is the reserved area.

The default file extension is <A HREF="#'">'</A>.INL'.

In to this storage area, for instance, could be put pictures, tables or machine
code programs.

<B>Example:</B>

    See the example for <A HREF="#C:">C:</A> in the system routines section.

<B>Memo:</B> length&<A HREF="#=">=</A><A HREF="#WORD">WORD</A>{addr%-4} (this works in the interpreter only)
      The editor will not accept values over 32746, entering any value over
      this can cause strange behavior and/or a crash. Enter the value very
      carefully, once the editor issues the 'line to long' error message, it's
      too late!

      The editor will also accept -negative values and crash the moment you
      press the return key!

      The editor will aslo accept 0 as a size which does not appear to be
      fatal. However, one has to wonder what use this would have?

      Loading a file that is too large for the inline does not produce a
      warning of any kind. It will be truncated at the size of the inline.
      However it will complain 'end of file reached' if the file size is
      smaller than the inline size.

      It's not neccessary to strip the 28 byte header from assembler routines.
      The magic number $601A at the start of such a routine is actually a
      'bra.s start_addr+28' instruction. The header is effectively skipped,
      however removing the header will save you 28 bytes and one less
      instruction per call.

      When a program is compiled the INLINEs end up perfectly stacked one after
      another in the order they are encountered. Example: If you have 3 INLINEs
      exactly 10 bytes each, the 3rd <A HREF="#INLINE">INLINE</A> can be located by adding 20 to the
      address of the first <A HREF="#INLINE">INLINE</A><A HREF="#.">.</A> In theory you could reserve 64000 bytes
      simply by defining 2 INLINEs 32000 bytes each one after the other.  This
      however is only valid when compiled.




      ASM only appears if started from GFA Assembler. See GFA Assembler manual.
      Note: The oddly placed clock character appears to be a typo. It does not
            do anything.
<HR SIZE=3><H2 ID="MALLOC">MALLOC</H2>
<A NAME="MSHRINK"></A><A NAME="MFREE"></A><B><A HREF="#MALLOC">MALLOC</A>(x)
<A HREF="#MSHRINK">MSHRINK</A>(y,z)
<A HREF="#MFREE">MFREE</A>(y)</B>

x, y, z: <A HREF="#iexp">iexp</A>

The function <A HREF="#MALLOC">MALLOC</A><A HREF="#()">()</A> (<A HREF="#GEMDOS">GEMDOS</A> 72) is used to reserve (allocate) areas of
memory.

If the parameter x is equal to -1, then the function returns the length of the
largest contiguous free area. If x is a positive number, then this means that x
bytes are to be reserved. In this case <A HREF="#MALLOC">MALLOC</A><A HREF="#()">()</A> returns the start address of
the reserved area. If a fault occurred with the reservation attempt, then the
value 0 is returned.

If larger areas are to be allocated, then first some of <A HREF="#GFA-Basic">GFA-Basic</A>'s memory must
be freed with <A HREF="#RESERVE">RESERVE</A><A HREF="#.">.</A>

Allocated storage areas must always be released before the end of the program,
although this is accomplished automatically when leaving the Interpreter.

<A HREF="#MSHRINK">MSHRINK</A><A HREF="#()">()</A> (<A HREF="#GEMDOS">GEMDOS</A> 74) will reduce the size of a storage area previously
allocated with <A HREF="#MALLOC">MALLOC</A><A HREF="#()">()</A><A HREF="#.">.</A> The parameter y specifies the address of the reserved
storage area (which was returned by <A HREF="#MALLOC">MALLOC</A><A HREF="#()">()</A>)<A HREF="#.">.</A> The second parameter z gives the
required (shrunk) size.

The function <A HREF="#MSHRINK">MSHRINK</A><A HREF="#()">()</A> returns 0 if the reduction was made without difficulty,
-40 if an incorrect address was given as y, or -67, if the new desired size was
larger than the current size. It is important with <A HREF="#MFREE">MFREE</A><A HREF="#()">()</A> and <A HREF="#MSHRINK">MSHRINK</A>() that
an incorrect address is never given.

<A HREF="#MFREE">MFREE</A><A HREF="#()">()</A> (<A HREF="#GEMDOS">GEMDOS</A> 73) releases the storage location reserved with <A HREF="#MALLOC">MALLOC</A>()<A HREF="#.">.</A>  The
parameter y specifies the start address of the memory area to be released
(which was returned by <A HREF="#MALLOC">MALLOC</A><A HREF="#()">()</A>)<A HREF="#.">.</A> If the release occurred without problems, the
value 0 is returned, otherwise a negative number is returned.

<B>Example:</B>

    <A HREF="#RESERVE">RESERVE</A> 1000
    <A HREF="#PRINT">PRINT</A> <A HREF="#MALLOC">MALLOC</A>(-1)
    adr%<A HREF="#=">=</A><A HREF="#MALLOC">MALLOC</A>(60000)
    <A HREF="#PRINT">PRINT</A> adr%
    <A HREF="#IF">IF</A> adr%<A HREF="#&">&</A>#62;0
      x%<A HREF="#=">=</A><A HREF="#MSHRINK">MSHRINK</A>(adr%,30000)
      y%<A HREF="#=">=</A><A HREF="#MFREE">MFREE</A>(adr%)
    <A HREF="#ENDIF">ENDIF</A>
    <A HREF="#RESERVE">RESERVE</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> <A HREF="#GFA-Basic">GFA-Basic</A>'s usable memory is reduced to 1000 bytes, and then the size of
    the largest free memory area is printed. Then an attempt is made with
    <A HREF="#MALLOC">MALLOC</A><A HREF="#()">()</A> to reserve 60000 bytes. If the reservation was successful, i.e.
    adr% is not zero, <A HREF="#MSHRINK">MSHRINK</A><A HREF="#()">()</A> is used to reduce the size of the reserved area
    to 30000 bytes, finally <A HREF="#MFREE">MFREE</A><A HREF="#()">()</A> releases the memory again.

<B>Memo:</B> A desk <A HREF="#accessory">accessory</A> should allocate all the ram it needs prior to
      entering it's main event loop. On older TOS versions the current running
      application will actually own the ram allocated by the <A HREF="#accessory">accessory</A><A HREF="#.">.</A>  This
      will be the desktop itself if you follow this rule, but since the desktop
      cannot be exited it's not a problem.

      <A HREF="#MSHRINK">MSHRINK</A><A HREF="#()">()</A> swaps the parameters when compiled, thus breaking the program.
      Use <A HREF="#GEMDOS">GEMDOS</A>(74) instead or this:

      <A HREF="#MALLOC">MALLOC</A><A HREF="#()">()</A> under MiNT with or without memory protection rounds all values
      up to a page size. Page size <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> 8192 bytes

<A HREF="#'">'</A> method #1
<A HREF="#FUNCTION">FUNCTION</A> mshrink(addr%,size%)
  <A HREF="#$F%">$F%</A>
  <A HREF="#RETURN">RETURN</A> <A HREF="#GEMDOS">GEMDOS</A>(74,W:FALSE,L:addr%,L:size%)
<A HREF="#ENDFUNC">ENDFUNC</A>

<A HREF="#'">'</A> method #2
<A HREF="#FUNCTION">FUNCTION</A> mshrink(addr%,size%)
  <A HREF="#$F%">$F%</A>
  <A HREF="#IF">IF</A> <A HREF="#BYTE">BYTE</A>{<A HREF="#BASEPAGE">BASEPAGE</A>+256}<A HREF="#&#60;">&#60;</A><A HREF="#&">&</A>#62;96 !compiled?
    <A HREF="#SWAP">SWAP</A> addr%,size%
  <A HREF="#ENDIF">ENDIF</A>
  <A HREF="#RETURN">RETURN</A> <A HREF="#MSHRINK">MSHRINK</A>(addr%,size%)
<A HREF="#ENDFUNC">ENDFUNC</A>

Malloc()<A HREF="#+">+</A>, Mxalloc()+, Mshrink()+, Mfree()+
<HR SIZE=3><H2 ID="Chapter__3_-_Operators">Chapter  3 - Operators</H2>
Operators in a programming language serve to link and compare elements in
numeric and logical expressions.

In this chapter the operators available in GFA BASIC V3 are introduced in the
following five sections.

In the first section the numerical operators <A HREF="#+">+</A>, <A HREF="#-">-</A>, <A HREF="#*">*</A>, <A HREF="#/">/</A>, <A HREF="#^">^</A>, <A HREF="#DIV">DIV</A>, \, and <A HREF="#MOD">MOD</A> are
discussed. They link two numerical expressions and produce a number, which can
then be assigned to variables with the equals sign (<A HREF="#=">=</A>)<A HREF="#.">.</A> The operators <A HREF="#+">+</A> and <A HREF="#-">-</A>
have a secondary function as unary operators, giving a sign to a number (+1, -2
etc.).

The second section deals with the logical operators <A HREF="#AND">AND</A>, <A HREF="#OR">OR</A>, <A HREF="#XOR">XOR</A>, <A HREF="#NOT">NOT</A>, <A HREF="#IMP">IMP</A>, and
<A HREF="#EQV">EQV</A><A HREF="#.">.</A> They link two logical expressions and produce a logical result (<A HREF="#TRUE">TRUE</A> or
<A HREF="#FALSE">FALSE</A>)<A HREF="#.">.</A> The operator <A HREF="#NOT">NOT</A> has a special role in that it works on only one
logical expression and reverses its logical value (<A HREF="#TRUE">TRUE</A> becomes <A HREF="#FALSE">FALSE</A> and vice
versa)<A HREF="#.">.</A>

The third section deals with the concatenation (joining) of string expressions
using the plus sign (<A HREF="#+">+</A>)<A HREF="#.">.</A>

The next section describes the comparison operators, which compare two
numerical or two string expressions and produce a logical result (<A HREF="#TRUE">TRUE</A> or
<A HREF="#FALSE">FALSE</A>)<A HREF="#.">.</A>

The last section details the order in which operators are processed if several
occur in one expression, and the use of the bracket symbols ( and ), by means
of which the order of processing can be governed.
<HR SIZE=3><H2 ID="Arithmetic_Operators">Arithmetic Operators</H2>
<A NAME="MOD"></A><A NAME="-"></A><A NAME="^"></A><A NAME="\\"></A><B><A HREF="#+">+</A> <A HREF="#-">-</A> <A HREF="#*">*</A> <A HREF="#/">/</A>
<A HREF="#^">^</A>
<A HREF="#DIV">DIV</A> \
<A HREF="#MOD">MOD</A>
+n -n</B>

n: number

These arithmetic operators link two numerical expressions and produce a number.
This number can then be used as part of another expression, assigned to a
variable, printed out with <A HREF="#PRINT">PRINT</A>, etc. The operators <A HREF="#+">+</A> and <A HREF="#-">-</A> are also used as
signs to indicate whether numbers are positive or negative (-1, +2, etc.).

x+y      Produces the sum of the numbers x and y (addition)

x-y      Produces the difference of the numbers x and y (subtraction)

x*y      Produces the product of the numbers x and y (multiplication)

x/y      Produces the quotient of x divided by y (division)

x^y      Produces x raised to the power y (exponentiation)

x <A HREF="#DIV">DIV</A> y  Results in a fast integer division of x by y

x\y      The backslash <A HREF="#'">'</A>\' character is an alternative form of <A HREF="#DIV">DIV</A>

x <A HREF="#MOD">MOD</A> y  Produces the remainder of the division of x by y.

<A HREF="#+">+</A> provides the value n with a positive sign, unless it was negative, in which
case it is left as it was.

<A HREF="#-">-</A> provides the value n with a negative sign. If is was positive, it is treated
as negative and vise versa.

See also <A HREF="#MOD()">MOD()</A><A HREF="#.">.</A>

The following relations are equivalent:

    x <A HREF="#DIV">DIV</A> y <A HREF="#=">=</A> <A HREF="#TRUNC">TRUNC</A>(x/y)
    x <A HREF="#MOD">MOD</A> y <A HREF="#=">=</A> x-y*<A HREF="#TRUNC">TRUNC</A>(x/y)

(<A HREF="#TRUNC">TRUNC</A><A HREF="#()">()</A> is the Truncate function.)

<B>Example:</B>

    13 <A HREF="#DIV">DIV</A> 4  produces 3
    13 <A HREF="#MOD">MOD</A> 4  produces 1

<B>Memo:</B> Additional reading related to the compiler, see sections
      <A HREF="#'">'</A><A HREF="#Integer_Division">Integer Division</A>' and '<A HREF="#Integer_Multiplication">Integer Multiplication</A>'<A HREF="#.">.</A>
<HR SIZE=3><H2 ID="Logical_Operators">Logical Operators</H2>
<A HREF="#AND">AND</A>, <A HREF="#OR">OR</A>, <A HREF="#XOR">XOR</A>
<A HREF="#NOT">NOT</A>, <A HREF="#IMP">IMP</A>, <A HREF="#EQV">EQV</A>

These logical operators work at the bit level for 32-bit integer values.
Logical operators link two logical expressions and produce a logical result
(<A HREF="#TRUE">TRUE</A> or <A HREF="#FALSE">FALSE</A>)<A HREF="#.">.</A> The operator <A HREF="#NOT">NOT</A> is an exception, in that it negates the value
of a given expression.

The numerical value for <A HREF="#FALSE">FALSE</A> is 0, and for <A HREF="#TRUE">TRUE</A> is -1.

For those interested in why these values should be chosen, the reason is that
<A HREF="#TRUE">TRUE</A> is considered to be all ones in a 32-bit integer, and <A HREF="#FALSE">FALSE</A> to be all
zeros. Thus:

    11111111111111111111111111111111 <A HREF="#=">=</A> <A HREF="#TRUE">TRUE</A>

and

    00000000000000000000000000000000 <A HREF="#=">=</A> <A HREF="#FALSE">FALSE</A>

Those familiar with two's complement arithmetic will recognize that the former
is the two's complement notation for -1.

All logical operators can also be applied to numerical expressions. In this
case the logical operations are implemented bit by bit. The effects of logical
operators will be described with so-called truth tables. In these tables the
logical values of the linked expressions are given in the first columns, and
the result in the last column.
<HR SIZE=3><H2 ID="NOT">NOT</H2>
<B><A HREF="#NOT">NOT</A> x</B>

x: <A HREF="#iexp">iexp</A>

The operator <A HREF="#NOT">NOT</A> negates a given logical expression. It is the only logical
operator, which has a single argument. Each individual bit of the argument is
modified.

    x <A HREF="#&#124;">&#124;</A> <A HREF="#NOT">NOT</A> x
    <A HREF="#-">-</A>-<A HREF="#&#124;">&#124;</A>------
    T <A HREF="#&#124;">&#124;</A> F
    F <A HREF="#&#124;">&#124;</A> T

<B>Examples:</B>

    <A HREF="#PRINT">PRINT</A> <A HREF="#NOT">NOT</A> <A HREF="#FALSE">FALSE</A>
    <A HREF="#PRINT">PRINT</A> <A HREF="#NOT">NOT</A> <A HREF="#TRUE">TRUE</A>
    <A HREF="#PRINT">PRINT</A> <A HREF="#NOT">NOT</A> 0

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The numbers -1, 0, and -1 appear on the screen.

    x=1
    <A HREF="#PRINT">PRINT</A> <A HREF="#BIN$">BIN$</A>(x,2)
    <A HREF="#PRINT">PRINT</A> <A HREF="#BIN$">BIN$</A>(<A HREF="#NOT">NOT</A> x,2)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> 01 and 10 appear on the screen.

    x%=17
    <A HREF="#PRINT">PRINT</A> <A HREF="#BIN$">BIN$</A>(x%,8),x%
    <A HREF="#PRINT">PRINT</A> <A HREF="#BIN$">BIN$</A>(<A HREF="#NOT">NOT</A> x%,8),NOT x%

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Displays 00010001, 17, 11101110, and -18 on the screen.

<B>Memo:</B> <A HREF="#IF">IF</A> <A HREF="#NOT">NOT</A> v
      It's amazing how often even experience programmers will forget that
      <A HREF="#NOT">NOT</A> v is not the same as NOT v! and end up with a logical test that
      doesn't work.
<HR SIZE=3><H2 ID="AND">AND</H2>
<B>x <A HREF="#AND">AND</A> y</B>

x, y: <A HREF="#iexp">iexp</A>

The logical operator <A HREF="#AND">AND</A> (conjunction) checks whether two logical expressions x
and y are both true. Only in this case it produces the value <A HREF="#TRUE">TRUE</A> (-1). If one
or both logical expressions are wrong, then <A HREF="#AND">AND</A> produces a logical <A HREF="#FALSE">FALSE</A><A HREF="#.">.</A> With
<A HREF="#AND">AND</A> each pair of the 32 bits is tested independently.

    x <A HREF="#&#124;">&#124;</A> y <A HREF="#&">&</A>#124; x <A HREF="#AND">AND</A> y
    <A HREF="#-">-</A>-<A HREF="#&#124;">&#124;</A>---<A HREF="#&">&</A>#124;--------
    T <A HREF="#&#124;">&#124;</A> T <A HREF="#&">&</A>#124; T
    T <A HREF="#&#124;">&#124;</A> F <A HREF="#&">&</A>#124; F
    F <A HREF="#&#124;">&#124;</A> T <A HREF="#&">&</A>#124; F
    F <A HREF="#&#124;">&#124;</A> F <A HREF="#&">&</A>#124; F

<B>Examples:</B>

    <A HREF="#PRINT">PRINT</A> <A HREF="#TRUE">TRUE</A> <A HREF="#AND">AND</A> -1
    <A HREF="#PRINT">PRINT</A> <A HREF="#FALSE">FALSE</A> <A HREF="#AND">AND</A> <A HREF="#TRUE">TRUE</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> On the screen the numbers -1 and 0 appear.

    x=3
    y=10
    <A HREF="#PRINT">PRINT</A> <A HREF="#BIN$">BIN$</A>(x,4)
    <A HREF="#PRINT">PRINT</A> <A HREF="#BIN$">BIN$</A>(y,4)
    <A HREF="#PRINT">PRINT</A> <A HREF="#BIN$">BIN$</A>(x <A HREF="#AND">AND</A> y,4),x AND y

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Displays 0011, 1010, 0010, and 2 on the screen.
<HR SIZE=3><H2 ID="OR">OR</H2>
<B>x <A HREF="#OR">OR</A> y</B>

x, y: <A HREF="#iexp">iexp</A>

The command <A HREF="#OR">OR</A> (disjunction) checks whether at least one of two logical
expressions x and y is <A HREF="#TRUE">TRUE</A><A HREF="#.">.</A> Only if x and y are both <A HREF="#FALSE">FALSE</A> will the result
<A HREF="#FALSE">FALSE</A> be produced. Unlike <A HREF="#XOR">XOR</A>, (see below) a <A HREF="#TRUE">TRUE</A> result from <A HREF="#OR">OR</A> means that one
or both arguments are <A HREF="#TRUE">TRUE</A><A HREF="#.">.</A> <A HREF="#OR">OR</A> also works at the bit level with numbers.

    x <A HREF="#&#124;">&#124;</A> y <A HREF="#&">&</A>#124; x <A HREF="#OR">OR</A> y
   <A HREF="#-">-</A>--<A HREF="#&#124;">&#124;</A>---<A HREF="#&">&</A>#124;-------
    T <A HREF="#&#124;">&#124;</A> T <A HREF="#&">&</A>#124; T
    T <A HREF="#&#124;">&#124;</A> F <A HREF="#&">&</A>#124; T
    F <A HREF="#&#124;">&#124;</A> T <A HREF="#&">&</A>#124; T
    F <A HREF="#&#124;">&#124;</A> F <A HREF="#&">&</A>#124; F

<B>Examples:</B>

    <A HREF="#PRINT">PRINT</A> <A HREF="#TRUE">TRUE</A> <A HREF="#OR">OR</A> -1
    <A HREF="#PRINT">PRINT</A> <A HREF="#FALSE">FALSE</A> <A HREF="#OR">OR</A> <A HREF="#TRUE">TRUE</A>
    <A HREF="#PRINT">PRINT</A> 0 <A HREF="#OR">OR</A> <A HREF="#FALSE">FALSE</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The numbers -1, -1, and 0 are displayed.

    x=3
    y=10
    <A HREF="#PRINT">PRINT</A> <A HREF="#BIN$">BIN$</A>(x,4)
    <A HREF="#PRINT">PRINT</A> <A HREF="#BIN$">BIN$</A>(y,4)
    <A HREF="#PRINT">PRINT</A> <A HREF="#BIN$">BIN$</A>(x <A HREF="#OR">OR</A> y,4),x OR y

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Displays 0011, 1010, 1011, and the number 11 appear on the screen.
<HR SIZE=3><H2 ID="XOR">XOR</H2>
<B>x <A HREF="#XOR">XOR</A> y</B>

x, y: <A HREF="#iexp">iexp</A>

The <A HREF="#XOR">XOR</A> operator produces the value <A HREF="#TRUE">TRUE</A> if one, but not both, of the arguments
is <A HREF="#TRUE">TRUE</A><A HREF="#.">.</A> If they are both TRUE, or both <A HREF="#FALSE">FALSE</A>, the result is FALSE.

Unlike <A HREF="#OR">OR</A>, where <A HREF="#TRUE">TRUE</A> OR TRUE <A HREF="#=">=</A> TRUE, TRUE <A HREF="#XOR">XOR</A> TRUE = <A HREF="#FALSE">FALSE</A><A HREF="#.">.</A> (XOR is the
Boolean Exclusive Disjunction operation.)

Again, <A HREF="#XOR">XOR</A> works individually on each of the 32 bits of numeric arguments.

    x <A HREF="#&#124;">&#124;</A> y <A HREF="#&">&</A>#124; x <A HREF="#XOR">XOR</A> y
    <A HREF="#-">-</A>-<A HREF="#&#124;">&#124;</A>---<A HREF="#&">&</A>#124;--------
    T <A HREF="#&#124;">&#124;</A> T <A HREF="#&">&</A>#124; F
    T <A HREF="#&#124;">&#124;</A> F <A HREF="#&">&</A>#124; T
    F <A HREF="#&#124;">&#124;</A> T <A HREF="#&">&</A>#124; T
    F <A HREF="#&#124;">&#124;</A> F <A HREF="#&">&</A>#124; F

<B>Examples:</B>

    <A HREF="#PRINT">PRINT</A> <A HREF="#FALSE">FALSE</A> <A HREF="#XOR">XOR</A> -1
    <A HREF="#PRINT">PRINT</A> -1 <A HREF="#XOR">XOR</A> 1
    <A HREF="#PRINT">PRINT</A> 0 <A HREF="#XOR">XOR</A> <A HREF="#FALSE">FALSE</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The numbers -1, -2, and 0 are printed on the screen.

    x=3
    y=10
    <A HREF="#PRINT">PRINT</A> <A HREF="#BIN$">BIN$</A>(x,4)
    <A HREF="#PRINT">PRINT</A> <A HREF="#BIN$">BIN$</A>(y,4)
    <A HREF="#PRINT">PRINT</A> <A HREF="#BIN$">BIN$</A>(x <A HREF="#XOR">XOR</A> y,4),x XOR y

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Displays 0011, 1010, 1001, and 9 on the screen.
<HR SIZE=3><H2 ID="IMP">IMP</H2>
<B>x <A HREF="#IMP">IMP</A> y</B>

x, y: <A HREF="#iexp">iexp</A>

The operator <A HREF="#IMP">IMP</A> (Implication) corresponds to a logical consequence. The result
is only <A HREF="#FALSE">FALSE</A> if a FALSE expression follows a <A HREF="#TRUE">TRUE</A> one. <A HREF="#IMP">IMP</A> also works at the
bit level. Unlike <A HREF="#AND">AND</A>, <A HREF="#OR">OR</A>, <A HREF="#XOR">XOR</A>, and <A HREF="#EQV">EQV</A>, the sequence of the arguments is
important.

    x <A HREF="#&#124;">&#124;</A> y <A HREF="#&">&</A>#124; x <A HREF="#IMP">IMP</A> y
    <A HREF="#-">-</A>-<A HREF="#&#124;">&#124;</A>---<A HREF="#&">&</A>#124;--------
    T <A HREF="#&#124;">&#124;</A> T <A HREF="#&">&</A>#124; T
    T <A HREF="#&#124;">&#124;</A> F <A HREF="#&">&</A>#124; F
    F <A HREF="#&#124;">&#124;</A> T <A HREF="#&">&</A>#124; T
    F <A HREF="#&#124;">&#124;</A> F <A HREF="#&">&</A>#124; T

<B>Examples:</B>

    <A HREF="#PRINT">PRINT</A> <A HREF="#TRUE">TRUE</A> <A HREF="#IMP">IMP</A> -1
    <A HREF="#PRINT">PRINT</A> 0 <A HREF="#IMP">IMP</A> <A HREF="#FALSE">FALSE</A>
    <A HREF="#PRINT">PRINT</A> <A HREF="#TRUE">TRUE</A> <A HREF="#IMP">IMP</A> 0

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The numbers -1, -1 and, 0 appear on the screen.

    x=3
    y=10
    <A HREF="#PRINT">PRINT</A> <A HREF="#BIN$">BIN$</A>(x,4)
    <A HREF="#PRINT">PRINT</A> <A HREF="#BIN$">BIN$</A>(y,4)
    <A HREF="#PRINT">PRINT</A> <A HREF="#BIN$">BIN$</A>(x <A HREF="#IMP">IMP</A> y,4)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Displays 0011, 1010, and 1110 on the screen.
<HR SIZE=3><H2 ID="EQV">EQV</H2>
<B>x <A HREF="#EQV">EQV</A> y</B>

x, y: <A HREF="#iexp">iexp</A>

The operator <A HREF="#EQV">EQV</A> (Equivalence) produces a <A HREF="#TRUE">TRUE</A> result only if the arguments are
both <A HREF="#TRUE">TRUE</A> or both <A HREF="#FALSE">FALSE</A><A HREF="#.">.</A> <A HREF="#EQV">EQV</A> works at the bit level and sets the bits which are
same in both arguments. This is exactly the opposite of <A HREF="#XOR">XOR</A>, so x <A HREF="#EQV">EQV</A> y is the
same as <A HREF="#NOT">NOT</A> (x <A HREF="#XOR">XOR</A> y)<A HREF="#.">.</A>

    x <A HREF="#&#124;">&#124;</A> y <A HREF="#&">&</A>#124; x <A HREF="#EQV">EQV</A> y
    <A HREF="#-">-</A>-<A HREF="#&#124;">&#124;</A>---<A HREF="#&">&</A>#124;--------
    T <A HREF="#&#124;">&#124;</A> T <A HREF="#&">&</A>#124; T
    T <A HREF="#&#124;">&#124;</A> F <A HREF="#&">&</A>#124; F
    F <A HREF="#&#124;">&#124;</A> T <A HREF="#&">&</A>#124; F
    F <A HREF="#&#124;">&#124;</A> F <A HREF="#&">&</A>#124; T

<B>Example:</B>

    <A HREF="#PRINT">PRINT</A> <A HREF="#TRUE">TRUE</A> <A HREF="#EQV">EQV</A> <A HREF="#FALSE">FALSE</A>
    <A HREF="#PRINT">PRINT</A> <A HREF="#FALSE">FALSE</A> <A HREF="#EQV">EQV</A> FALSE

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> On the screen the numbers 0 and -1 appear.

    x=3
    y=10
    <A HREF="#PRINT">PRINT</A> <A HREF="#BIN$">BIN$</A>(x,4)
    <A HREF="#PRINT">PRINT</A> <A HREF="#BIN$">BIN$</A>(y,4)
    <A HREF="#PRINT">PRINT</A> <A HREF="#BIN$">BIN$</A>(x <A HREF="#EQV">EQV</A> y,4)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Displays 0011, 1011, and 0110 on the screen.
<HR SIZE=3><H2 ID="Concatenation_Operator">Concatenation Operator</H2>
<A NAME="+"></A><B>a$+b$</B>

a$, b$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>

The operator <A HREF="#'">'</A><A HREF="#+">+</A>' also serves to link character strings together. The result is
a character string, composed of a$ and b$<A HREF="#.">.</A>

<B>Example:</B>

    a$<A HREF="#=">=</A>"GFA-"
    <A HREF="#PRINT">PRINT</A> a$<A HREF="#+">+</A>"BASIC"

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The text 'GFA-BASIC' appears on the screen.
<HR SIZE=3><H2 ID="Comparison_Operators">Comparison Operators</H2>
<A HREF="#=">=</A>
<A HREF="#&#60;">&#60;</A>
<A HREF="#&#62;">&#62;</A>
<A HREF="#==">==</A>
<A HREF="#&#60;=">&#60;=</A> (<A HREF="#=&#60;">=&#60;</A>)
<A HREF="#&#62;=">&#62;=</A> (<A HREF="#=&#62;">=&#62;</A>)
<A HREF="#&#60;&#62;">&#60;&#62;</A> (<A HREF="#&#62;&#60;">&#62;&#60;</A>)

With these numerical, logical, and string expressions can be compared with each
other. The result of this comparison is always one of the logical values <A HREF="#TRUE">TRUE</A>
(-1) or <A HREF="#FALSE">FALSE</A> (0)<A HREF="#.">.</A> The operator <A HREF="#'">'</A><A HREF="#==">==</A>' is an exception: string expressions cannot
be compared with it.
<HR SIZE=3><H2 ID="=">=</H2>
<B>x=y</B>

x, y: exp

The operator <A HREF="#'">'</A><A HREF="#=">=</A>' compares two numerical or string expressions for equality. If
the two expressions are equal, then the result is logically <A HREF="#TRUE">TRUE</A>, otherwise it
is <A HREF="#FALSE">FALSE</A><A HREF="#.">.</A>

<B>Example:</B>

    x=6
    <A HREF="#IF">IF</A> 2=x/3
      <A HREF="#PRINT">PRINT</A> "Ok"
    <A HREF="#ENDIF">ENDIF</A>
    <A HREF="#PRINT">PRINT</A> 2=x/3

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> 'Ok' and -1 appear on the screen.
<HR SIZE=3><H2 ID="==">==</H2>
<B>x==y</B>

x, y: <A HREF="#aexp">aexp</A>

The operator <A HREF="#'">'</A><A HREF="#==">==</A>' compares two numerical expressions for approximate equality.
With this operator only eight and one half decimal places (28 bits of the
mantissas of floating-point numbers) are compared. <A HREF="#'">'</A><A HREF="#==">==</A>' is useful for comparing
floating-point numbers, where inaccuracies due to rounding can occur.

<B>Examples:</B>

    <A HREF="#PRINT">PRINT</A> 1.0000000001=1
    <A HREF="#PRINT">PRINT</A> 1.0000000001==1

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The numbers 0 and -1 are displayed.

    a=<A HREF="#SINQ">SINQ</A>(77)     !SINQ() (degrees) is a quick, less accurate SIN() function
    b=<A HREF="#SIN">SIN</A>(<A HREF="#RAD">RAD</A>(77)) !RAD() converts from degrees to radians
    <A HREF="#PRINT">PRINT</A> a=b
    <A HREF="#PRINT">PRINT</A> a==b

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The numbers 0 (logically <A HREF="#FALSE">FALSE</A>) and -1 (<A HREF="#TRUE">TRUE</A>) appear.
<HR SIZE=3><H2 ID="&#60;">&#60;</H2>
<A NAME="&#62;"></A><A NAME="&#60;="></A><A NAME="=&#60;"></A><A NAME="&#62;="></A><A NAME="=&#62;"></A><B>x&#60;y
x&#62;y
x&#60;=y
x&#62;=y</B>

x, y: exp

These operators serve to compare the size of numerical and string expressions.
With numerical expressions the values are compared, and with string expressions
the comparison depends on the <A HREF="#ASCII">ASCII</A> codes of the characters. The string "ABC"
is treated as the number sequence 65, 66,and 67.

In the comparison "ABC"<A HREF="#&#62;">&#62;</A>"AAA", the first characters are compared, which both
have the <A HREF="#ASCII">ASCII</A> code 65. Then the next character is compared. There "B" has a
higher code value than "A", and "B" is then taken as the 'larger'<A HREF="#.">.</A>

Here the comparison of the two strings is broken off, and the statement "ABC"
is larger than "AAA" is deemed logically <A HREF="#TRUE">TRUE</A><A HREF="#.">.</A>

A special case of the comparison crops up if the two strings end before an
inequality is discovered. An example would be: "AA"<A HREF="#&#62;">&#62;</A>"A". This statement is
rated logically <A HREF="#TRUE">TRUE</A>, as is "A"<A HREF="#+">+</A><A HREF="#CHR$">CHR$</A>(0)<A HREF="#&#62;">&#62;</A>"A"<A HREF="#.">.</A>

Now to the individual operators:

    x&#62;y   <A HREF="#TRUE">TRUE</A> if x is greater than y.
    x&#60;y   <A HREF="#TRUE">TRUE</A> if x is less than y.
    x&#62;=y  <A HREF="#TRUE">TRUE</A> if x is greater than, or equal to y.
    x&#60;=y  <A HREF="#TRUE">TRUE</A> if x is less than, or equal to y.

The following are equivalent ways of writing the same expressions:

    x&#60;=y or x=&#60;y
    x&#62;=y or x=&#62;y

<B>Example:</B>

    <A HREF="#PRINT">PRINT</A> "AAA"<A HREF="#&#62;">&#62;</A>"aaa"
    <A HREF="#PRINT">PRINT</A> -1&#60;=4-5

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The numbers -1 and -1 are printed.
<HR SIZE=3><H2 ID="&#60;&#62;">&#60;&#62;</H2>
<A NAME="&#62;&#60;"></A><B>x&#60;&#62;y</B>

x, y: exp

This operator checks whether two numerical or string expressions are unequal.
If this is the case, then the statement x&#60;&#62;y is logically <A HREF="#TRUE">TRUE</A><A HREF="#.">.</A> If x and y are
the same, then the result of x&#60;&#62;y is logically <A HREF="#FALSE">FALSE</A><A HREF="#.">.</A>

The expressions x&#60;&#62;y and x&#62;&#60;y are equivalent.

<B>Example:</B>

    <A HREF="#PRINT">PRINT</A> "test"<A HREF="#&#60;&#62;">&#60;&#62;</A>"test"
    <A HREF="#PRINT">PRINT</A> -1&#60;&#62;4-5

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> 0 and 1 appear on the screen.
<HR SIZE=3><H2 ID="Assignment_Operator">Assignment Operator</H2>
<A NAME="&H"></A><A NAME="&X"></A><A NAME="&O"></A><B>x=y</B>

x: var
y: exp

The equals sign <A HREF="#'">'</A><A HREF="#=">=</A>' can be used not only as a comparison operator, but also to
assign a value to a numeric or string variable. The value of the expression y
on the right of the equals sign is determined and assigned to the variable on
the left.

Numerical expressions can only be assigned to numerical variables, and
character string expressions can only be assigned to string variables.

Optionally, the command <A HREF="#LET">LET</A> may be used, which also permits the assignment of
values to variables which have the same names as keywords.

<B>Example:</B>

    x=<A HREF="#LEN">LEN</A>("TEST")+3
    a$=GF+<A HREF="#CHR$">CHR$</A>(65)
    <A HREF="#PRINT">PRINT</A> x,a$

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> On the screen 7 and 'GFA' appear.

Hexadecimal, Binary, and Octal notation can also be used.

<B>Notation     Prefix</B>
Hexadecimal  <A HREF="#&H">&H</A>
Binary       <A HREF="#&X">&X</A>
Octal        <A HREF="#&O">&O</A>

<B>Example:</B>

    <A HREF="#LET">LET</A> test&<A HREF="#=">=</A>&H80       !hex notation
    <A HREF="#LET">LET</A> test&<A HREF="#=">=</A>&X10000000 !bin notation
    <A HREF="#LET">LET</A> test&<A HREF="#=">=</A>&O200      !oct notation

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> test& is assigned the value '128' in Hex, Bin, and Oct notation
<HR SIZE=3><H2 ID="Operator_Hierarchy">Operator Hierarchy</H2>
<A NAME="()"></A>If several operators are used in an expression, they are processed in a certain
order, which depends on the operator's place in the so-called operator
hierarchy. The operators at the top of this hierarchy are processsed first. The
hierarchy is as follows:

    <A HREF="#()">()</A>                  Brackets
    <A HREF="#+">+</A>                   Character string addition
    <A HREF="#=">=</A> <A HREF="#&#60;">&#60;</A> <A HREF="#&#62;">&#62;</A> <A HREF="#=&#62;">=&#62;</A> <A HREF="#&#60;=">&#60;=</A> <A HREF="#&#60;&#62;">&#60;&#62;</A>      Character string comparison
    <A HREF="#+">+</A> <A HREF="#-">-</A>                 Signing
    <A HREF="#^">^</A>                   Exponentiation
    <A HREF="#*">*</A> <A HREF="#/">/</A>                 <A HREF="#Multiplication">Multiplication</A>, division
    <A HREF="#DIV">DIV</A> <A HREF="#MOD">MOD</A>             Integral and modulo division
    <A HREF="#+">+</A> <A HREF="#-">-</A>                 Addition, subtraction
    <A HREF="#=">=</A> <A HREF="#==">==</A> <A HREF="#&#60;">&#60;</A> <A HREF="#&#60;=">&#60;=</A> <A HREF="#&#62;=">&#62;=</A> <A HREF="#&#62;">&#62;</A> <A HREF="#&#60;&#62;">&#60;&#62;</A>   Numeric and logical comparison
    <A HREF="#AND">AND</A> <A HREF="#OR">OR</A> <A HREF="#XOR">XOR</A> <A HREF="#IMP">IMP</A> <A HREF="#EQV">EQV</A>  Logical operators
    <A HREF="#NOT">NOT</A>                 Negation

By means of the brackets it is possible to force lower-precedence operators to
be processed before those higher up the hierarchy.

<B>Example:</B>

    <A HREF="#PRINT">PRINT</A> 2+4*3
    <A HREF="#PRINT">PRINT</A> (2+4)*3
    <A HREF="#PRINT">PRINT</A> 2+(4*3)
    <A HREF="#PRINT">PRINT</A> 3*2^2

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The numbers 14, 18, 14, and 12 appear on the screen.
<HR SIZE=3><H2 ID="Chapter__4_-_Numerical_Functions">Chapter  4 - Numerical Functions</H2>
There are numerical functions for the following tasks: the functions <A HREF="#ABS">ABS</A><A HREF="#()">()</A> and
<A HREF="#SGN">SGN</A><A HREF="#()">()</A> return the absolute value and the sign of a numerical expression.  <A HREF="#ODD">ODD</A>()
and <A HREF="#EVEN">EVEN</A><A HREF="#()">()</A> check whether a number is odd or even. <A HREF="#INT()">INT()</A>, <A HREF="#TRUNC">TRUNC</A>(), <A HREF="#FIX">FIX</A>(), and
<A HREF="#FRAC">FRAC</A><A HREF="#()">()</A> deal with separate manipulation of the parts of a number to the left and
to the right of the decimal point. <A HREF="#ROUND">ROUND</A><A HREF="#()">()</A> rounds an expression. <A HREF="#MAX">MAX</A>() and
<A HREF="#MIN">MIN</A><A HREF="#()">()</A> return the largest or the smallest of several numerical expressions and
<A HREF="#SQR">SQR</A><A HREF="#()">()</A> the square root of an expression. The trigonometrical functions are
<A HREF="#SIN">SIN</A><A HREF="#()">()</A>, <A HREF="#COS">COS</A>(), <A HREF="#TAN">TAN</A>(), <A HREF="#ASIN">ASIN</A>(), <A HREF="#ACOS">ACOS</A>(), and <A HREF="#ATN">ATN</A>()<A HREF="#.">.</A>  <A HREF="#SINQ">SINQ</A>() and <A HREF="#COSQ">COSQ</A>() are faster,
less accurate alternatives for <A HREF="#SIN">SIN</A><A HREF="#()">()</A> and <A HREF="#COS">COS</A>()<A HREF="#.">.</A> <A HREF="#EXP">EXP</A>() and <A HREF="#LOG">LOG</A>() compute powers
and logarithms. <A HREF="#LOG10">LOG10</A><A HREF="#()">()</A> computes logarithms to base 10. <A HREF="#DEG">DEG</A>() and <A HREF="#RAD">RAD</A>()
transform values from radians to degrees and vice versa. <A HREF="#RND">RND</A><A HREF="#()">()</A>, <A HREF="#RANDOM">RANDOM</A>(),
<A HREF="#RAND">RAND</A><A HREF="#()">()</A>, and <A HREF="#RANDOMIZE">RANDOMIZE</A> deal with the generation of random numbers.

<HR SIZE=3><H2 ID="Mathematical_Functions">Mathematical Functions</H2>
<A HREF="#ABS">ABS</A><A HREF="#()">()</A>, <A HREF="#SGN">SGN</A>()
<A HREF="#EVEN">EVEN</A><A HREF="#()">()</A>, <A HREF="#ODD">ODD</A>()
<A HREF="#INT()">INT()</A>, <A HREF="#TRUNC">TRUNC</A><A HREF="#()">()</A>, <A HREF="#FIX">FIX</A>(), <A HREF="#FRAC">FRAC</A>()
<A HREF="#ROUND">ROUND</A><A HREF="#()">()</A>
<A HREF="#MIN">MIN</A><A HREF="#()">()</A>, <A HREF="#MAX">MAX</A>()
<A HREF="#SQR">SQR</A><A HREF="#()">()</A>
<A HREF="#EXP">EXP</A><A HREF="#()">()</A>, <A HREF="#LOG">LOG</A>(), <A HREF="#LOG10">LOG10</A>()
<A HREF="#SIN">SIN</A><A HREF="#()">()</A>, <A HREF="#COS">COS</A>(), <A HREF="#TAN">TAN</A>()
<A HREF="#ASIN">ASIN</A><A HREF="#()">()</A>, <A HREF="#ACOS">ACOS</A>(), <A HREF="#ATN">ATN</A>()
<A HREF="#SINQ">SINQ</A><A HREF="#()">()</A>, <A HREF="#COSQ">COSQ</A>()
<A HREF="#DEG">DEG</A><A HREF="#()">()</A>, <A HREF="#RAD">RAD</A>()
<A HREF="#FACT">FACT</A><A HREF="#()">()</A>, <A HREF="#VARIAT">VARIAT</A>(), <A HREF="#COMBIN">COMBIN</A>()
<A HREF="#SCALE">SCALE</A><A HREF="#()">()</A>
<HR SIZE=3><H2 ID="ABS">ABS</H2>
<A NAME="SGN"></A><B><A HREF="#ABS">ABS</A>(x)
<A HREF="#SGN">SGN</A>(x)</B>

x: <A HREF="#aexp">aexp</A>

The function <A HREF="#ABS">ABS</A><A HREF="#()">()</A> returns the absolute value of a numerical expression. The
returned value is the same as the given value, except that its sign is ignored.
The sign of the returned value is always made positive.

With the function <A HREF="#SGN">SGN</A><A HREF="#()">()</A> one can determine the sign of a numerical expression
thus:

    <B>x           <A HREF="#SGN">SGN</A>(x)</B>
    Negative    -1
    Equal to 0  0
    Positive    1

<B>Example:</B>

    x=-2
    y=<A HREF="#ABS">ABS</A>(x)
    <A HREF="#PRINT">PRINT</A> <A HREF="#SGN">SGN</A>(x),<A HREF="#ABS">ABS</A>(5-3),SGN(ABS(x*3))

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Displays the numbers -1, 2, and 1.
<HR SIZE=3><H2 ID="EVEN">EVEN</H2>
<A NAME="ODD"></A><B><A HREF="#EVEN">EVEN</A>(x)
<A HREF="#ODD">ODD</A>(x)</B>

x: <A HREF="#aexp">aexp</A>

This function checks whether the numerical expression x is even. <A HREF="#EVEN">EVEN</A><A HREF="#()">()</A> results
in <A HREF="#TRUE">TRUE</A> for an even x and <A HREF="#FALSE">FALSE</A> for an odd x.  Zero (0) is treated as an even
number.

    <B>x     <A HREF="#EVEN">EVEN</A>(x)</B>
    Even  -1 (<A HREF="#TRUE">TRUE</A>)
    Odd   0  (<A HREF="#FALSE">FALSE</A>)
    Zero  -1 (<A HREF="#TRUE">TRUE</A>)

This function checks whether the numerical expression x is odd. <A HREF="#ODD">ODD</A><A HREF="#()">()</A> returns
the value -1 (<A HREF="#TRUE">TRUE</A>), if x is odd and 0 (<A HREF="#FALSE">FALSE</A>) if x is even. Zero (0) is
treated as an even number.

    <B>x     <A HREF="#ODD">ODD</A>(x)</B>
    Even  0  (<A HREF="#FALSE">FALSE</A>)
    Odd   -1 (<A HREF="#TRUE">TRUE</A>)
    Zero  0  (<A HREF="#FALSE">FALSE</A>)

<B>Example:</B>

    x=2
    <A HREF="#PRINT">PRINT</A> <A HREF="#ODD">ODD</A>(x),<A HREF="#EVEN">EVEN</A>(-2),ODD(3*5),EVEN(-3*x)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The numbers 0, -1, -1, and -1 are displayed.

<B>Memo:</B> These functions convert all types to float format regardless.
      For integers only this will work:
      <A HREF="#FUNCTION">FUNCTION</A> odd(int%)
        <A HREF="#$F%">$F%</A>
        <A HREF="#RETURN">RETURN</A> <A HREF="#BTST">BTST</A>(int%,0)
      <A HREF="#ENDFUNC">ENDFUNC</A>
<HR SIZE=3><H2 ID="INT()">INT()</H2>
<A NAME="TRUNC"></A><A NAME="FIX"></A><A NAME="FRAC"></A><B><A HREF="#INT">INT</A>(x)
<A HREF="#TRUNC">TRUNC</A>(x)
<A HREF="#FIX">FIX</A>(x)
<A HREF="#FRAC">FRAC</A>(x)</B>

x: <A HREF="#aexp">aexp</A>

These functions allow independent manipulation of the parts of a numerical
expression to the left and right of the decimal point: <A HREF="#INT()">INT()</A>, <A HREF="#TRUNC">TRUNC</A><A HREF="#()">()</A>, and
<A HREF="#FIX">FIX</A><A HREF="#()">()</A> (<A HREF="#TRUNC">TRUNC</A>() and FIX() are identical) return a whole number.

The function <A HREF="#TRUNC">TRUNC</A><A HREF="#()">()</A> simply cuts off the digits to the right of the decimal
point.

<A HREF="#INT()">INT()</A> returns the largest whole number which is less than or equal to x. There
is no difference between <A HREF="#TRUNC">TRUNC</A><A HREF="#()">()</A> (or <A HREF="#FIX">FIX</A>()) and <A HREF="#INT()">INT()</A> for positive x-values,
however, with a negative, non-integer x a difference arises. So <A HREF="#TRUNC">TRUNC</A>(-1.2)
removes the decimal places and returns -1 as the result. <A HREF="#INT">INT</A>(-1.2), on the
other hand, returns the next smaller whole number, namely -2.

<A HREF="#FRAC">FRAC</A><A HREF="#()">()</A> returns only the fractional part of x, in other words just the decimal
places, with the same sign as x had. <A HREF="#FRAC">FRAC</A><A HREF="#()">()</A> is complementary to <A HREF="#TRUNC">TRUNC</A>() and
not to <A HREF="#INT()">INT()</A><A HREF="#.">.</A> It is always true that x=<A HREF="#TRUNC">TRUNC</A>(x)<A HREF="#+">+</A><A HREF="#FRAC">FRAC</A>(x), but <A HREF="#INT">INT</A>(x)+FRAC(x) is
not equal to x for negative values.

<B>Example:</B>

    x=-1.4
    y=<A HREF="#TRUNC">TRUNC</A>(1.3)
    <A HREF="#PRINT">PRINT</A> y,<A HREF="#INT">INT</A>(x),<A HREF="#FIX">FIX</A>(3*x),<A HREF="#FRAC">FRAC</A>(x-3)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The numbers 1, -2, -4 and -0.4 are displayed.
<HR SIZE=3><H2 ID="ROUND">ROUND</H2>
<B><A HREF="#ROUND">ROUND</A>(x[,n])</B>

x: <A HREF="#aexp">aexp</A>
n: <A HREF="#iexp">iexp</A>

The function <A HREF="#ROUND">ROUND</A>(x) returns x rounded to the nearest whole number. The
variant <A HREF="#ROUND">ROUND</A>(x,n) rounds the expression x to n decimal places. If n is zero,
the effect is the same as for <A HREF="#ROUND">ROUND</A>(x)<A HREF="#.">.</A> If n is negative, the rounding is done
before the decimal point, so <A HREF="#ROUND">ROUND</A>(155,-1) results in the number 160,
(<B>Note:</B> <A HREF="#CINT">CINT</A><A HREF="#()">()</A> also rounds with an Integer result.)

<B>Examples:</B>

    y=<A HREF="#ROUND">ROUND</A>(-1.2)
    <A HREF="#PRINT">PRINT</A> y,<A HREF="#ROUND">ROUND</A>(1.7)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Displays -1 and 2 on the screen.

    <A HREF="#FOR">FOR</A> i%<A HREF="#=">=</A>-5 TO 5
      <A HREF="#PRINT">PRINT</A> i%,<A HREF="#ROUND">ROUND</A>(<A HREF="#PI">PI</A>*100,i%)
    <A HREF="#NEXT">NEXT</A> i%

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Displays the loop variable and the associated formatted expression on the
    screen: <A HREF="#PI">PI</A> is multiplied by 100 and then displayed rounded to i% decimal
    places. Where i% is negative, the rounding is done to the left of the
    decimal point.

<HR SIZE=3><H2 ID="MIN">MIN</H2>
<A NAME="MAX"></A><B><A HREF="#MIN">MIN</A>(x[,y,z,<A HREF="#.">.</A>..])  MIN(x$[,y$,z$,...])
<A HREF="#MAX">MAX</A>(x[,y,z,<A HREF="#.">.</A>..])  MAX(x$[,y$,z$,...])</B>

x, y, z: <A HREF="#aexp">aexp</A>
x$, y$, z$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>

The function <A HREF="#MIN">MIN</A><A HREF="#()">()</A> returns the smallest of the numerical expressions x, y, z,
<A HREF="#.">.</A>.., specified in the parameter list.

The function <A HREF="#MAX">MAX</A><A HREF="#()">()</A> returns the largest of the numerical expressions x, y, z,
<A HREF="#.">.</A>.., specified in the parameter list.

<A HREF="#MIN">MIN</A><A HREF="#()">()</A> and <A HREF="#MAX">MAX</A>() can also be applied to string expressions.

<B>Example:</B>

    x=3
    y=<A HREF="#MAX">MAX</A>(3,5.5-4)
    <A HREF="#PRINT">PRINT</A> <A HREF="#MIN">MIN</A>(x,y),<A HREF="#MAX">MAX</A>(-1,x*2)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Displays the numbers 3 and 6.
<HR SIZE=3><H2 ID="SQR">SQR</H2>
<B><A HREF="#SQR">SQR</A>(x)</B>

x: <A HREF="#aexp">aexp</A>

Produces the square root of the numerical expression x. If the expression x is
negative, an error message is invoked.

<B>Examples:</B>

    x=9
    y=<A HREF="#SQR">SQR</A>(x)
    <A HREF="#PRINT">PRINT</A> y,<A HREF="#SQR">SQR</A>(4*4)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The numbers 3 and 4 appear on the screen.

    <A HREF="#PRINT">PRINT</A> <A HREF="#SQR">SQR</A>(SQR(16))
    <A HREF="#PRINT">PRINT</A> <A HREF="#SQR">SQR</A>(-2)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The number 2 appears, followed by an error message.
<HR SIZE=3><H2 ID="EXP">EXP</H2>
<A NAME="LOG"></A><A NAME="LOG10"></A><B><A HREF="#EXP">EXP</A>(x)
<A HREF="#LOG">LOG</A>(x)
<A HREF="#LOG10">LOG10</A>(x)</B>

x: <A HREF="#aexp">aexp</A>

<A HREF="#EXP">EXP</A><A HREF="#()">()</A> computes e to the power x (Euler's number e=2.1782818284...), and <A HREF="#LOG">LOG</A>()
forms the inverse function, that is the natural logarithm of x. Similarly,
<A HREF="#LOG10">LOG10</A><A HREF="#()">()</A> returns the logarithm of x to the base 10. The numerical expression x
must be larger than zero with the logarithm function, otherwise an error
message results.

<B>Example:</B>

    x=2
    y=<A HREF="#EXP">EXP</A>(2)
    <A HREF="#PRINT">PRINT</A> y,<A HREF="#LOG10">LOG10</A>(2*5),<A HREF="#LOG">LOG</A>(x)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> On the screen 7.389056098931, 1, and 0.6931471805599 appear.

<B>Memo:</B> For FPU use, see function <A HREF="#TT?">TT?</A><A HREF="#.">.</A>
<HR SIZE=3><H2 ID="SIN">SIN</H2>
<A NAME="COS"></A><A NAME="TAN"></A><A NAME="ASIN"></A><A NAME="ACOS"></A><A NAME="ATN"></A><A NAME="DEG"></A><A NAME="RAD"></A><A NAME="SINQ"></A><A NAME="COSQ"></A><B><A HREF="#SIN">SIN</A>(x)
<A HREF="#COS">COS</A>(x)
<A HREF="#TAN">TAN</A>(x)
<A HREF="#ASIN">ASIN</A>(x)
<A HREF="#ACOS">ACOS</A>(x)
<A HREF="#ATN">ATN</A>(x)
<A HREF="#DEG">DEG</A>(x)
<A HREF="#RAD">RAD</A>(degrees)
<A HREF="#SINQ">SINQ</A>(degrees)
<A HREF="#COSQ">COSQ</A>(degrees)</B>

x, degrees: <A HREF="#aexp">aexp</A>

These are the trigonometrical functions. The numerical expression x is assumed
to specify radians. They compute the following:

    <A HREF="#SIN">SIN</A><A HREF="#()">()</A>   Sine
    <A HREF="#COS">COS</A><A HREF="#()">()</A>   Cosine
    <A HREF="#TAN">TAN</A><A HREF="#()">()</A>   Tangent
    <A HREF="#ASIN">ASIN</A><A HREF="#()">()</A>  Arc-sine
    <A HREF="#ACOS">ACOS</A><A HREF="#()">()</A>  Arc-cosine
    <A HREF="#ATN">ATN</A><A HREF="#()">()</A>   Arc-tangent

To convert between radians and degrees one uses the functions <A HREF="#DEG">DEG</A><A HREF="#()">()</A> (radians to
degrees) or the inverse, <A HREF="#RAD">RAD</A><A HREF="#()">()</A><A HREF="#.">.</A> <A HREF="#DEG">DEG</A>(x) and RAD(x) are thus equivalent to
(x*180/PI) and (x*PI/180) respectively.

The functions <A HREF="#SINQ">SINQ</A><A HREF="#()">()</A> and <A HREF="#COSQ">COSQ</A>() return Sine and Cosine values, interpolated in
steps of one sixteenth of a degree from an internal table. For graphics work on
the screen this accuracy is not distinguishable from the values computed with
<A HREF="#SIN">SIN</A><A HREF="#()">()</A> or <A HREF="#COS">COS</A>(), however <A HREF="#SINQ">SINQ</A>() and <A HREF="#COSQ">COSQ</A>() work up to 10 times as fast. Unlike
<A HREF="#SIN">SIN</A><A HREF="#()">()</A> and <A HREF="#COS">COS</A>(), degrees are expected as the arguments for <A HREF="#SINQ">SINQ</A>() and <A HREF="#COSQ">COSQ</A>()<A HREF="#.">.</A>
<A HREF="#SINQ">SINQ</A>(degrees) corresponds to <A HREF="#SIN">SIN</A>(<A HREF="#RAD">RAD</A>(degrees)) and <A HREF="#COSQ">COSQ</A>(degrees) corresponds to
<A HREF="#COS">COS</A>(<A HREF="#RAD">RAD</A>(degrees))<A HREF="#.">.</A>

<B>Examples:</B>

    x=90
    y=<A HREF="#COSQ">COSQ</A>(x*PI/180)
    z=270*PI/180
    <A HREF="#PRINT">PRINT</A> y,<A HREF="#SIN">SIN</A>(z),<A HREF="#TAN">TAN</A>(45),<A HREF="#ATN">ATN</A>(1/2)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The numbers 1, -1, 1.619775190544, and 0.4636476090008 appear.

    alpha%=30
    <A HREF="#PRINT">PRINT</A> <A HREF="#SINQ">SINQ</A>(alpha%)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The number 0.5 is displayed.

<B>Memo:</B> For FPU use, see function <A HREF="#TT?">TT?</A><A HREF="#.">.</A>
      <A HREF="#ASIN">ASIN</A><A HREF="#()">()</A> and <A HREF="#ACOS">ACOS</A>() do not seem to handle errors correctly when compiled.
      Example: <A HREF="#PRINT">PRINT</A> <A HREF="#ASIN">ASIN</A>(-50) !results in a crash
<HR SIZE=3><H2 ID="FACT">FACT</H2>
<A NAME="VARIAT"></A><A NAME="COMBIN"></A><B><A HREF="#FACT">FACT</A>(n)
<A HREF="#VARIAT">VARIAT</A>(n,k)
<A HREF="#COMBIN">COMBIN</A>(n,k)</B>

n, k: <A HREF="#iexp">iexp</A>

Commands from the field of combinatorics.

<A HREF="#FACT">FACT</A>(n) returns the factorial of a natural number n (n!)<A HREF="#.">.</A> A factorial is the
product of the first n natural numbers, where 0!=1.

<A HREF="#VARIAT">VARIAT</A>(n,k) returns the number of variations of n elements to the k-th order
without repetition. The number of variations of n elements to the k-th order
without repition is defined as:

    <A HREF="#VARIAT">VARIAT</A>(n,k)=n!<A HREF="#/">/</A>(n-k)!

    When k <A HREF="#&#62;">&#62;</A> n an error is reported.

<A HREF="#COMBIN">COMBIN</A>(n,k) returns the number of combinations of n elements to the k-th order
without repetition. The number of combinations of n elements to the k-th order
without repition is defined as:

    <A HREF="#COMBIN">COMBIN</A>(n,k)=n!<A HREF="#/">/</A>((n-k)!*k!)

    When k <A HREF="#&#62;">&#62;</A> n an error is reported.

<B>Example:</B>

    x=<A HREF="#FACT">FACT</A>(6)
    y=<A HREF="#VARIAT">VARIAT</A>(6,2)
    z=<A HREF="#COMBIN">COMBIN</A>(6,2)
    <A HREF="#PRINT">PRINT</A> x,y,z
    <A HREF="#~">~</A><A HREF="#INP">INP</A>(2)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The values 720, 30, and 15 appear on the screen. A key is then waited for.
<HR SIZE=3><H2 ID="SCALE">SCALE</H2>
<B><A HREF="#SCALE">SCALE</A>(i,j,k)</B>

i, j, k: <A HREF="#iexp">iexp</A>

Divides an integer into the product of two other integers.

<A HREF="#SCALE">SCALE</A>(i,j,k) multiplies the integer numbers i and j, producing an integer
result. The result is then divided by the integer number k and the quotient is
returned. This is somewhat faster than i*j/k.

The return value is an integer so any decimal places will be lost.

One possible application for this function is for scaling of graphics.

<B>Example:</B>

    i&=64
    j&=8
    k&=16
    <A HREF="#PRINT">PRINT</A> (i&*j&)/k&
    <A HREF="#PRINT">PRINT</A> <A HREF="#SCALE">SCALE</A>(i&,j&,k&)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The values 32 and 32 appear on the screen.

<B>Memo:</B> No error handling division by zero when compiled.
      Only the editor will catch division by zero if <A HREF="#SCALE">SCALE</A><A HREF="#()">()</A> is used.
<HR SIZE=3><H2 ID="Random_Number_Generator">Random Number Generator</H2>
<A HREF="#RND">RND</A><A HREF="#()">()</A>
<A HREF="#RAND">RAND</A><A HREF="#()">()</A>
<A HREF="#RANDOM">RANDOM</A><A HREF="#()">()</A>
<A HREF="#RANDOMIZE">RANDOMIZE</A>

This group of commands deals with the generation of random numbers.
<HR SIZE=3><H2 ID="RANDOM">RANDOM</H2>
<A NAME="RND"></A><A NAME="RAND"></A><A NAME="RANDOMIZE"></A><B><A HREF="#RND">RND</A>[(x)]
<A HREF="#RAND">RAND</A>(y)
<A HREF="#RANDOM">RANDOM</A>(x)
<A HREF="#RANDOMIZE">RANDOMIZE</A> [y]</B>

x: <A HREF="#aexp">aexp</A>
y: <A HREF="#iexp">iexp</A>

This group of commands deal with the generation of random numbrs:

<A HREF="#RND">RND</A><A HREF="#()">()</A> produces a random number between 0 and 1 (including 0, excluding 1)<A HREF="#.">.</A> The
optional parameter (x) has no meaning.

<A HREF="#RAND">RAND</A>(y) produces a 16-bit random integer in the range 0 to y-1. Where y is an
integer with a maximum value of 65535 (&HFFFF)<A HREF="#.">.</A> If y exceeds 65535, then its
low-order word is taken as the argument.

<A HREF="#RANDOM">RANDOM</A>(x) produces a random integer between 0 and x (including 0, excluding
x)<A HREF="#.">.</A> The numerical expression x need not be integer if not all numbers are
required to have the same probability.

<A HREF="#RANDOMIZE">RANDOMIZE</A> y initialises the random number generator with the value y. If the
random number generator is initialised several times with the same y, the same
sequence of random numbers will be produced. Without the use of <A HREF="#RANDOMIZE">RANDOMIZE</A> at
the beginning of a program, different sequences will be generated each time the
program is run, which may be undesirable in some cases. For initialising the
random number generator one can also use <A HREF="#RANDOMIZE">RANDOMIZE</A> (without parameters) or
<A HREF="#RANDOMIZE">RANDOMIZE</A> 0, which initializes the random number generator with a random
number.

<B>Examples:</B>

    x=<A HREF="#RND">RND</A>
    <A HREF="#PRINT">PRINT</A> x,<A HREF="#RND">RND</A>(2)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Two random numbers between 0 and 1 appear on the screen.

    x=<A HREF="#RANDOM">RANDOM</A>(2)
    y=<A HREF="#RAND">RAND</A>(4)
    <A HREF="#PRINT">PRINT</A> x,y,<A HREF="#RAND">RAND</A>(x),<A HREF="#RANDOM">RANDOM</A>(3*x)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Four integer random numbers are displayed.

    <A HREF="#RANDOMIZE">RANDOMIZE</A> 3
    x=<A HREF="#RND">RND</A>
    <A HREF="#RANDOMIZE">RANDOMIZE</A> 3
    <A HREF="#PRINT">PRINT</A> x,<A HREF="#RND">RND</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The same 'random number' is printed twice.

Random()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="Integer_Arithmetic">Integer Arithmetic</H2>
<A NAME="Commands_and_Functions"></A><A HREF="#INC">INC</A>, <A HREF="#DEC">DEC</A>
<A HREF="#ADD">ADD</A>, <A HREF="#SUB">SUB</A>, <A HREF="#MUL">MUL</A>, <A HREF="#DIV">DIV</A>
<A HREF="#PRED()">PRED()</A>, <A HREF="#SUCC()">SUCC()</A>
<A HREF="#ADD()">ADD()</A>, <A HREF="#SUB()">SUB()</A>, <A HREF="#MUL()">MUL()</A>, <A HREF="#DIV()">DIV()</A>
<A HREF="#MOD()">MOD()</A>

These instructions are shorter forms of the following frequently used
statements:

    <B>Instruction  Corresponds to</B>
    <A HREF="#DEC">DEC</A> x        x=x-1
    <A HREF="#INC">INC</A> x        x=x+1

    <A HREF="#ADD">ADD</A> x,y      x=x+y
    <A HREF="#SUB">SUB</A> x,y      x=x-y
    <A HREF="#MUL">MUL</A> x,y      x=x*y
    <A HREF="#DIV">DIV</A> x,y      x=x/y

The statements on the left require less time for their execution than those on
the right, particularly in the case of integer variables. It is important to
note that <A HREF="#INC">INC</A>, <A HREF="#DEC">DEC</A>, <A HREF="#ADD">ADD</A>, <A HREF="#SUB">SUB</A>, <A HREF="#MUL">MUL</A>, and <A HREF="#DIV">DIV</A> do not carry out an overflow check
with integer variables (types <A HREF="#&#124;">&#124;</A>, <A HREF="#&">&</A>, and <A HREF="#%">%</A>)<A HREF="#.">.</A> If overflow occurs, only the
appropriate number of low-order bits (8 for byte, 16 for word, etc.) are used
for the result. Thus for byte-sized variables, if x&#124;=16 and y&#124;=17, <A HREF="#MUL">MUL</A> x&#124;,y&#124;
gives the result 16 in x&#124;<A HREF="#.">.</A> The extra '256' in the 9th bit is ignored.

<B>Memo:</B> For compiler options see section <A HREF="#'">'</A><A HREF="#Integer_Rounding">Integer Rounding</A>'<A HREF="#.">.</A>

      For compiler optimizations see sections <A HREF="#'">'</A><A HREF="#Simple_Additions">Simple Additions</A>', '<A HREF="#Multiplication">Multiplication</A>',
      <A HREF="#'">'</A><A HREF="#Division">Division</A>', and '<A HREF="#More_Complicated_Calculations">More Complicated Calculations</A>'<A HREF="#.">.</A>

      For information about how the compiler handles integer overflow see
      section <A HREF="#'">'</A><A HREF="#Integer_Overflow">Integer Overflow</A>'<A HREF="#.">.</A>
<HR SIZE=3><H2 ID="DEC">DEC</H2>
<A NAME="INC"></A><B><A HREF="#DEC">DEC</A> i
<A HREF="#INC">INC</A> i</B>

i: <A HREF="#avar">avar</A>

The instruction <A HREF="#DEC">DEC</A> decrements the value of the specified variable, in other
words it subtracts one (1) from it's value.

The instruction <A HREF="#INC">INC</A> increments the value of the specified variable, in other
words it adds one (1) to it's value.

These instruction can work with floating-point variables, but are substantially
faster with integers.

<B>Examples:</B>

    x%=4
    y%=7
    <A HREF="#DEC">DEC</A> x%
    <A HREF="#INC">INC</A> y%
    <A HREF="#PRINT">PRINT</A> x%,y%

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The numbers 3 and 8 appear.

    a&#124;=255
    <A HREF="#INC">INC</A> a&#124;
    <A HREF="#INC">INC</A> a&#124;
    <A HREF="#PRINT">PRINT</A> a&#124;

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Results in '1' being displayed, as there is no overflow check.
<HR SIZE=3><H2 ID="ADD">ADD</H2>
<A NAME="SUB"></A><A NAME="MUL"></A><A NAME="DIV"></A><B><A HREF="#ADD">ADD</A> x,y
<A HREF="#SUB">SUB</A> x,y
<A HREF="#MUL">MUL</A> x,y
<A HREF="#DIV">DIV</A> x,y</B>

x: <A HREF="#avar">avar</A>
y: <A HREF="#aexp">aexp</A>

The instruction <A HREF="#ADD">ADD</A> increases the variable x by the value of y. With this
instruction x must be a numeric variable, and y must be a numerical expression.

The instruction <A HREF="#SUB">SUB</A> decreases the variable x by the value of y. With this
instruction x must be a numeric variable, and y must be a numerical expression.

The instruction <A HREF="#MUL">MUL</A> multiplies x by the value of y and assigns the result to x.
With this instruction x must be a numeric variable, and y must be a numerical
expression.

The instruction <A HREF="#DIV">DIV</A> divides x by the value of y and assigns the result to x.
With this instruction x must be a numeric variable, and y must be a numerical
expression.

These instructions can work with floating-point variables, but are
substantially faster with integers.

See also <A HREF="#ADD()">ADD()</A>, <A HREF="#SUB()">SUB()</A>, <A HREF="#MUL()">MUL()</A>, and <A HREF="#DIV()">DIV()</A><A HREF="#.">.</A>

<B>Note:</B> DIViding a variable by zero (0) results in an error.

<B>Example:</B>

    x%=1
    y%=2
    z%=3
    <A HREF="#ADD">ADD</A> x%,y%       !now x% is equal to 3
    <A HREF="#SUB">SUB</A> z%,(x%-1)/2 !the numerical expression (x%-1)/2 restults in 1
    <A HREF="#PRINT">PRINT</A> x%,z%

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The numbers 3 and 2 are displayed.
<HR SIZE=3><H2 ID="PRED">PRED</H2>
<A NAME="SUCC"></A><B><A HREF="#PRED">PRED</A>(i)
<A HREF="#SUCC">SUCC</A>(i)</B>

i: <A HREF="#iexp">iexp</A>

<A HREF="#PRED()">PRED()</A> and <A HREF="#SUCC()">SUCC()</A> determine the next higher or next lower number.

<A HREF="#PRED()">PRED()</A> returns the next lower number than the argument. So <A HREF="#PRED">PRED</A><A HREF="#()">()</A> returns the
PREDecessor of a numerical expression. Note that this instruction operates on
integer expressions, so any decimal places are ignored. This gives rise to the
effect that, for instance, <A HREF="#PRED">PRED</A>(2.1) returns the result of 1, and not 2.

<A HREF="#SUCC()">SUCC()</A> returns the next higher number than the argument. So <A HREF="#SUCC">SUCC</A><A HREF="#()">()</A> returns the
SUCCessor of a numerical expression. Note that this instruction operates on
integer expressions, so any decimal places are ignored.

This function will also operate on string expressions, see the section on
<A HREF="#'">'</A><A HREF="#String_Manipulation">String Manipulation</A>' (<A HREF="#PRED()">PRED()</A> and <A HREF="#SUCC()">SUCC()</A>)<A HREF="#.">.</A>

<B>Example:</B>

    i%=6
    j&<A HREF="#=">=</A><A HREF="#PRED">PRED</A>(i%)
    <A HREF="#PRINT">PRINT</A> j%,<A HREF="#SUCC">SUCC</A>(2),<A HREF="#PRED">PRED</A>(3*i%)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> On the screen, the numbers 5, 3, and 17 appear.
<HR SIZE=3><H2 ID="ADD()">ADD()</H2>
<A NAME="SUB()"></A><A NAME="MUL()"></A><A NAME="DIV()"></A><A NAME="MOD()"></A><B><A HREF="#ADD">ADD</A>(x,y)
<A HREF="#SUB">SUB</A>(x,y)
<A HREF="#MUL">MUL</A>(x,y)
<A HREF="#DIV">DIV</A>(x,y)
<A HREF="#MOD">MOD</A>(x,y)</B>

x, y: <A HREF="#iexp">iexp</A>

<A HREF="#ADD()">ADD()</A>, <A HREF="#SUB()">SUB()</A>, <A HREF="#MUL()">MUL()</A>, <A HREF="#DIV()">DIV()</A>, and <A HREF="#MOD()">MOD()</A> offer quicker integer arithmetic with
Polish notation.

These functions can replace more usual expressions thus:

    <B>Instruction  Corresponds to</B>
    <A HREF="#ADD">ADD</A>(x,y)     x+y
    <A HREF="#SUB">SUB</A>(x,y)     x-y
    <A HREF="#MUL">MUL</A>(x,y)     x*y
    <A HREF="#DIV">DIV</A>(x,y)     x/y or x DIV y
    <A HREF="#MOD">MOD</A>(x,y)     x MOD y

Since these function uses integer arithmetic, any decimal places are ignored.
These function can be nested at will. This method of notation is known as
'Polish'<A HREF="#.">.</A>

See also <A HREF="#ADD">ADD</A>, <A HREF="#SUB">SUB</A>, <A HREF="#MUL">MUL</A>, <A HREF="#DIV">DIV</A>, and <A HREF="#MOD">MOD</A><A HREF="#.">.</A>

After the following program segment is run...

    x%=5
    y%=4
    <A HREF="#ADD">ADD</A> y%,3
    z%<A HREF="#=">=</A><A HREF="#SUB">SUB</A>(x%,3)

<A HREF="#.">.</A>.. x% will have the value 5, y% the value 7, and z% the value 2.

<B>Examples:</B>

    <A HREF="#DEFINT">DEFINT</A> "a-z"
    x=4
    y=<A HREF="#ADD">ADD</A>(x,x)                !y becomes equal to 8
    z=<A HREF="#SUB">SUB</A>(x,2)
    <A HREF="#PRINT">PRINT</A> y,z,<A HREF="#ADD">ADD</A>(x,<A HREF="#MUL">MUL</A>(y,2))

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The numbers 8, 2, and 20 appear on the screen.

    <A HREF="#DEFINT">DEFINT</A> "a-z"
    x=2
    y=<A HREF="#MUL">MUL</A>(x,3)                 !y becomes equal to 6
    <A HREF="#PRINT">PRINT</A> 7,<A HREF="#DIV">DIV</A>(8,x),<A HREF="#MOD">MOD</A>(11,4) !MOD(11,4) is equal to 3

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The numbers 6, 4, and 3 appear on the screen.

    <A HREF="#DEFINT">DEFINT</A> "a-z"
    x=5
    y=<A HREF="#ADD">ADD</A>(<A HREF="#SUB">SUB</A>(x,2),<A HREF="#MUL">MUL</A>(3,4))
    <A HREF="#PRINT">PRINT</A> y,<A HREF="#DIV">DIV</A>(8,<A HREF="#MOD">MOD</A>(14,4))

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Displays the numbers 15 and 4.
<HR SIZE=3><H2 ID="Bit_Operations">Bit Operations</H2>
<A HREF="#BCLR">BCLR</A><A HREF="#()">()</A>, <A HREF="#BSET">BSET</A>(), <A HREF="#BTST">BTST</A>(), <A HREF="#BCHG">BCHG</A>()
<A HREF="#SHL&#124;">SHL&#124;</A><A HREF="#()">()</A>, <A HREF="#SHL&">SHL&</A>(), <A HREF="#SHL">SHL</A>()
<A HREF="#SHR&#124;">SHR&#124;</A><A HREF="#()">()</A>, <A HREF="#SHR&">SHR&</A>(), <A HREF="#SHR">SHR</A>()
<A HREF="#ROL&#124;">ROL&#124;</A><A HREF="#()">()</A>, <A HREF="#ROL&">ROL&</A>(), <A HREF="#ROL">ROL</A>()
<A HREF="#ROR&#124;">ROR&#124;</A><A HREF="#()">()</A>, <A HREF="#ROR&">ROR&</A>(), <A HREF="#ROR">ROR</A>()
<A HREF="#AND()">AND()</A>, <A HREF="#OR()">OR()</A>, <A HREF="#XOR()">XOR()</A>, <A HREF="#IMP()">IMP()</A>, <A HREF="#EQV()">EQV()</A>
<A HREF="#SWAP()">SWAP()</A>
<A HREF="#BYTE()">BYTE()</A>, <A HREF="#CARD()">CARD()</A>, <A HREF="#WORD()">WORD()</A>

These <A HREF="#Bit_Operations">Bit Operations</A> affect numerical expressions at the bit level. The
commands <A HREF="#BCLR">BCLR</A><A HREF="#()">()</A>, <A HREF="#BSET">BSET</A>(), <A HREF="#BTST">BTST</A>(), and <A HREF="#BCHG">BCHG</A>() are direct implementations of the
68000 instructions. Note, however, that they are used as functions, not
commands.

They reset, set, test, and negate individual bits. SHLx(), SHRx(), ROLx(), and
RORx() shift or rotate. <A HREF="#AND()">AND()</A>, <A HREF="#OR()">OR()</A>, <A HREF="#XOR()">XOR()</A>, <A HREF="#IMP()">IMP()</A>, and <A HREF="#EQV()">EQV()</A> are logical
functions. In the following explanations the convention is used that bit 0 is
the least significant bit. With 4-byte integers bit 31 is the most significant
bit and is also the sign bit (if the sign bit is set, i.e. =1, then a negative
number is represented in two's complement form, otherwise it is a positive
number)<A HREF="#.">.</A>

<A HREF="#SWAP()">SWAP()</A> exchanges the high- and low-order words of a 4-byte value. <A HREF="#BYTE()">BYTE()</A> reads
the lower 8 bits and <A HREF="#CARD()">CARD()</A> the lower 16 bits of an expression. <A HREF="#WORD()">WORD()</A> extends
a word to form a long word, i.e. bit 15 is copied into positions 16 to 31.

<B>Memo:</B> <A HREF="#BSET">BSET</A> (<A HREF="#BCLR">BCLR</A>) internally uses and returns a signed 32-bit value. If you
      bit change e.g. a word variable <A HREF="#BSET">BSET</A>(m&,15), the return value is a long
      integer with all bits 15-31 set, i.e. <A HREF="#&">&</A>#60;0. For this reason b&<A HREF="#=">=</A><A HREF="#BSET">BSET</A>(m&,15)
      generates an error, since the result is not a word. The result must be
      masked to 16 bits first, using e.g. <A HREF="#AND">AND</A> &FFFF or <A HREF="#WORD()">WORD()</A>.
<HR SIZE=3><H2 ID="BCLR">BCLR</H2>
<A NAME="BSET"></A><A NAME="BCHG"></A><A NAME="BTST"></A><B><A HREF="#BCLR">BCLR</A>(x,y)
<A HREF="#BSET">BSET</A>(x,y)
<A HREF="#BCHG">BCHG</A>(x,y)
<A HREF="#BTST">BTST</A>(x,y)</B>

x, y: <A HREF="#iexp">iexp</A>

These functions permit the resetting, setting, negating, and testing of bits.
The bit numbers are counted starting from 0 on the 'right' and are internally
ANDed with 31, so that they are always taken as being between 0 and 31.

The function <A HREF="#BCLR">BCLR</A><A HREF="#()">()</A> sets the y-th bit of the numerical expression x to 0.

The function <A HREF="#BSET">BSET</A><A HREF="#()">()</A> sets the y-th bit of the numerical expression x to 1.

The function <A HREF="#BCHG">BCHG</A><A HREF="#()">()</A> sets bit y of numerical expression x to 1 if it was 0, or
sets it to 0 if it was 1.

The function <A HREF="#BTST">BTST</A><A HREF="#()">()</A> returns -1 (<A HREF="#TRUE">TRUE</A>) if bit y of numerical expression x is
equal to 1 and 0 (<A HREF="#FALSE">FALSE</A>) if it is equal to 0.

<B>Examples:</B>

    x=<A HREF="#BSET">BSET</A>(0,3)
    PRINTx,<A HREF="#BSET">BSET</A>(0,5)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The numbers 8 (2^3) and 32 (2^5) appear on the screen.

    <A HREF="#REPEAT">REPEAT</A>
      t&#124;<A HREF="#=">=</A><A HREF="#INP">INP</A>(2)
      <A HREF="#PRINT">PRINT</A> <A HREF="#CHR$">CHR$</A>(t&#124;),CHR$(<A HREF="#BCLR">BCLR</A>(t&#124;,5))
    <A HREF="#UNTIL">UNTIL</A> <A HREF="#CHR$">CHR$</A>(t&#124;)<A HREF="#=">=</A>"x"

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> If CapsLock is off, this program prints the letter corresponding to the key
    pressed, in both lower and upper case. (With lower case letters, bit 5 is
    always set; resetting this bit forces the transformation to upper case)<A HREF="#.">.</A>

    s$<A HREF="#=">=</A>"TESTcase"
    <A HREF="#FOR">FOR</A> i%=1 TO <A HREF="#LEN">LEN</A>(s$)
      <A HREF="#PRINT">PRINT</A> <A HREF="#CHR$">CHR$</A>(<A HREF="#BCHG">BCHG</A>(<A HREF="#ASC">ASC</A>(<A HREF="#MID$">MID$</A>(s$,i%)),5))<A HREF="#;">;</A>
    <A HREF="#NEXT">NEXT</A> i%

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Displays testCASE on the screen. Each lower case letter is changed to upper
    case, and vice versa. (this will not work with umlauted characters).

<B>Memo:</B> This generates the error message 'number not a word':
      r&<A HREF="#=">=</A>-1
      r&<A HREF="#=">=</A><A HREF="#BCLR">BCLR</A>(r&,15)    !seems logical yet it fails
      r&<A HREF="#=">=</A><A HREF="#AND">AND</A>(r&,&H7FFF) !use this instead
      Why does it fail?  The variable is seen as a <A HREF="#LONG">LONG</A> regardless.
<HR SIZE=3><H2 ID="SHR">SHR</H2>
<A NAME="SHR&"></A><A NAME="SHR&#124;"></A><A NAME="SHL"></A><A NAME="SHL&"></A><A NAME="SHL&#124;"></A><A NAME="ROL"></A><A NAME="ROL&"></A><A NAME="ROL&#124;"></A><A NAME="ROR"></A><A NAME="ROR&"></A><A NAME="ROR&#124;"></A><B><A HREF="#SHL&#124;">SHL&#124;</A>(x,y)  <A HREF="#SHL&">SHL&</A>(x,y)  <A HREF="#SHL">SHL</A>(x y)
<A HREF="#SHR&#124;">SHR&#124;</A>(x,y)  <A HREF="#SHR&">SHR&</A>(x,y)  <A HREF="#SHR">SHR</A>(x,y)
<A HREF="#ROL&#124;">ROL&#124;</A>(x,y)  <A HREF="#ROL&">ROL&</A>(x,y)  <A HREF="#ROL">ROL</A>(x,y)
<A HREF="#ROR&#124;">ROR&#124;</A>(x,y)  <A HREF="#ROR&">ROR&</A>(x,y)  <A HREF="#ROR">ROR</A>(x,y)</B>

x, y: <A HREF="#iexp">iexp</A>

These instructions SHift or ROtate the numerical expression x by y bits. If the
variable type is not specified this will occur over long word length (4 bytes)<A HREF="#.">.</A>
If word length is specified (with <A HREF="#&">&</A>), the operation takes place over 2 bytes,
and with byte length (<A HREF="#&#124;">&#124;</A>) over one byte.

The third letter of the function name specifies the direction for the shift,
'L' standing for left, and 'R' for right.

With word-length operations (with <A HREF="#&">&</A>) bit 15 is copied to bits 16 to 31, thus
preserving the sign. With byte-length operations bits 8 to 31 are set to 0.

The following tables show the effect of the shift instructions:

    <B>x%      <A HREF="#SHL&#124;">SHL&#124;</A>(x%,1)    <A HREF="#BIN$">BIN$</A>(x%,16)          BIN$(<A HREF="#SHL&">SHL&</A>#124;(x%,1),16)</B>
    18      36            00000000 00010010    00000000 00100100
    642     4             00000010 10000010    00000000 00000100

    <B>x%      <A HREF="#SHL&">SHL&</A>(x%,1)    <A HREF="#BIN$">BIN$</A>(x%,16)          BIN$(<A HREF="#SHL">SHL</A><A HREF="#&">&</A>(x%,1),16)</B>
    18      36            00000000 00010010    00000000 00100100
    130     260           00000000 10000010    00000001 00000100

    <B>x%      <A HREF="#SHR&">SHR&</A>(x%,2)    <A HREF="#BIN$">BIN$</A>(x%,16)          BIN$(<A HREF="#SHR">SHR</A><A HREF="#&">&</A>(x%,2),16)</B>
    24      6             00000000 00011000    00000000 00000110
    4162    1040          00010000 01000010    00000100 00010000

<B>Note:</B> The bit representations have been grouped as two sets of 8 bits for
      the sake of clarity. <A HREF="#BIN$">BIN$</A><A HREF="#()">()</A> does not do this.

The next examples concern rotation. Here, bits which leave one end of the
argument are pushed in again at the other end. For instance, if only the
highest bit of a byte is set, and the byte is then shifted one bit to the left
(<A HREF="#ROL&#124;">ROL&#124;</A>(128,1)), the set bit which disappears off the left end is re-introduced
on the right as bit 0. With a shift to the left, (say <A HREF="#SHL&#124;">SHL&#124;</A>(128,1)) the set bit
would have been lost, with bit 0 being made zero.

Examples of rotation are:

    <B>x&#124;     <A HREF="#ROL&#124;">ROL&#124;</A>(x&#124;,1)   <A HREF="#BIN$">BIN$</A>(x&#124;,1)   BIN$(<A HREF="#ROL&">ROL&</A>#124;(x&#124;,1),8)</B>
    6      12           00000110     00001100
    130    5            10000010     00000101

    <B>x&#124;     <A HREF="#ROR&#124;">ROR&#124;</A>(x&#124;,3)   <A HREF="#BIN$">BIN$</A>(x&#124;,8)   BIN$(<A HREF="#ROR&">ROR&</A>#124;(x&#124;,3),8)</B>
    66     72           01000010     01001000
    2      64           00000010     01000000

<B>Example:</B>

    x&#124;=128+1                   !bits 7 and 0 set
    y%<A HREF="#=">=</A><A HREF="#ROR&#124;">ROR&#124;</A>(x&#124;,1)              !y becomes 192
    <A HREF="#PRINT">PRINT</A> <A HREF="#SHL">SHL</A>(y%,4),y%*2^4
    <A HREF="#PRINT">PRINT</A> <A HREF="#SHL">SHL</A>(<A HREF="#ROR&#124;">ROR&#124;</A>(128+1,1),4)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The number 3072 is printed three times. The function <A HREF="#SHL">SHL</A>(a,b) is equivalent
    to a*2^b, if no bit is lost off the left end of the four-byte number a. The
    bit-shift formulation, however, is clearly quicker.

<HR SIZE=3><H2 ID="AND()">AND()</H2>
<A NAME="OR()"></A><A NAME="XOR()"></A><A NAME="IMP()"></A><A NAME="EQV()"></A><B><A HREF="#AND">AND</A>(x,y)
<A HREF="#OR">OR</A>(x,y)
<A HREF="#XOR">XOR</A>(x,y)
<A HREF="#IMP">IMP</A>(x,y)
<A HREF="#EQV">EQV</A>(x,y)</B>

x, y: <A HREF="#iexp">iexp</A>

These functions operate logically on two numerical expressions.

The function <A HREF="#AND()">AND()</A> returns a result in which only those bits are set which are
set in both x and y.

The result of <A HREF="#OR()">OR()</A> contains bits set in the places in which bits are set in
either x or y or both.

<A HREF="#XOR()">XOR()</A> sets only those bits which are set in x or y but not both (or, to put it
another way: <A HREF="#XOR()">XOR()</A> sets those bits which are different in x and y)<A HREF="#.">.</A>

<A HREF="#IMP()">IMP()</A> resets a bit to zero if the appropriate bit in x is set and in y is
reset, otherwise the bit is set.

<A HREF="#EQV()">EQV()</A> sets a bit of the result if the appropriate bits in x and y are both set,
or both reset.

See the section on <A HREF="#Logical_Operators">Logical Operators</A> for the truth table for this function.

<B>Examples:</B>

    x=3
    y=2
    z=<A HREF="#AND">AND</A>(x,y)
    <A HREF="#PRINT">PRINT</A> z,<A HREF="#OR">OR</A>(2,7),<A HREF="#XOR">XOR</A>(x,1+4+8)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> On the screen, the numbers 2, 7, and 14 appear.

    <A HREF="#PRINT">PRINT</A> <A HREF="#BIN$">BIN$</A>(15,4),15
    <A HREF="#PRINT">PRINT</A> <A HREF="#BIN$">BIN$</A>(6,4),6
    <A HREF="#PRINT">PRINT</A> <A HREF="#BIN$">BIN$</A>(<A HREF="#IMP">IMP</A>(15,6),4),"IMP(15,6)"
    <A HREF="#PRINT">PRINT</A> <A HREF="#BIN$">BIN$</A>(<A HREF="#EQV">EQV</A>(15,6),4),"EQV(15,6)"

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Displays: 1111 15
              0110 6
              0110 <A HREF="#IMP">IMP</A>(15,6)
              0110 <A HREF="#EQV">EQV</A>(15,6)
<HR SIZE=3><H2 ID="SWAP()">SWAP()</H2>
<B><A HREF="#SWAP">SWAP</A>(x)</B>

x: <A HREF="#iexp">iexp</A>

The function <A HREF="#SWAP()">SWAP()</A> re-formulates (if necessary) the numerical expression x as
a long word (4 bytes) and exchanges its upper and lower words (2 bytes in each
case)<A HREF="#.">.</A> This could be useful when passing longword parameters to an operating
system routine which requires the words in reverse order.

<B>Note:</B> This function has nothing to do with the instruction of the same
      name, which swaps values of variables.

<B>Example:</B>

    x=1044480
    <A HREF="#PRINT">PRINT</A> <A HREF="#BIN$">BIN$</A>(x,32)
    y=<A HREF="#SWAP">SWAP</A>(x)
    <A HREF="#PRINT">PRINT</A> <A HREF="#BIN$">BIN$</A>(y,32)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The following appears on the screen: 00000000000011111111000000000000
                                         11110000000000000000000000001111

An example of <A HREF="#SWAP()">SWAP()</A> in use might be: <A HREF="#~">~</A><A HREF="#WIND_SET">WIND_SET</A>(0,13,<A HREF="#SWAP">SWAP</A>(t%),t%,0,0)
<HR SIZE=3><H2 ID="BYTE()">BYTE()</H2>
<A NAME="CARD()"></A><A NAME="WORD()"></A><B><A HREF="#BYTE">BYTE</A>(x)
<A HREF="#CARD">CARD</A>(x)
<A HREF="#WORD">WORD</A>(x)</B>

x: <A HREF="#iexp">iexp</A>

<A HREF="#BYTE()">BYTE()</A> returns the lower 8 bits of the numerical expression x.

The functions <A HREF="#CARD()">CARD()</A> returns the lower 16 bits of the numerical expression x.

The function <A HREF="#WORD()">WORD()</A> extends a word to long word length (32 bits) by copying bit
15 to bit positions 16 to 31, thus preserving the sign.

<B>Examples:</B>

    <A HREF="#PRINT">PRINT</A> <A HREF="#BYTE">BYTE</A>(255),BYTE(1+255)
    <A HREF="#PRINT">PRINT</A> <A HREF="#HEX$">HEX$</A>(<A HREF="#CARD">CARD</A>(&H1234ABCD))

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> 255, 0, and ABCD are printed.

    x%<A HREF="#=">=</A>&HFFFF
    <A HREF="#PRINT">PRINT</A> <A HREF="#BIN$">BIN$</A>(x%,32)
    x%<A HREF="#=">=</A><A HREF="#WORD">WORD</A>(x%)
    <A HREF="#PRINT">PRINT</A> <A HREF="#BIN$">BIN$</A>(x%,32)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The screen displays: 00000000000000001111111111111111
                         11111111111111111111111111111111
<HR SIZE=3><H2 ID="Chapter__5_-_String_Manipulation">Chapter  5 - String Manipulation</H2>
<A NAME="String_Manipulation"></A><A HREF="#LEFT$">LEFT$</A><A HREF="#()">()</A>, <A HREF="#RIGHT$">RIGHT$</A>()
<A HREF="#MID$">MID$</A> (as a command), <A HREF="#MID$()">MID$()</A> (as a function)
<A HREF="#PRED()">PRED()</A>, <A HREF="#SUCC()">SUCC()</A>
<A HREF="#LEN">LEN</A><A HREF="#()">()</A>
<A HREF="#TRIM$">TRIM$</A><A HREF="#()">()</A>
<A HREF="#INSTR">INSTR</A><A HREF="#()">()</A>, <A HREF="#RINSTR">RINSTR</A>()
<A HREF="#STRING$">STRING$</A><A HREF="#()">()</A>, <A HREF="#SPACE$">SPACE$</A>(), <A HREF="#SPC">SPC</A>()
<A HREF="#UPPER$">UPPER$</A><A HREF="#()">()</A>
<A HREF="#LSET">LSET</A>, <A HREF="#RSET">RSET</A>

These functions allow the manipulation of strings by selectively altering and
concatenating (<A HREF="#+">+</A>) their contents. The functions <A HREF="#LEFT$">LEFT$</A><A HREF="#()">()</A> and <A HREF="#RIGHT$">RIGHT$</A>() return the
left or right part of a character string. <A HREF="#MID$()">MID$()</A>, used as a function, returns a
section from the middle of a string, or, used as a command, allows the
replacement of part of one string with all or part of another. <A HREF="#PRED()">PRED()</A> and
<A HREF="#SUCC()">SUCC()</A> return the character with the <A HREF="#ASCII">ASCII</A> code one lower or one higher than
the first character of the specified string. While <A HREF="#LEN">LEN</A><A HREF="#()">()</A> determines the length
of a character string. <A HREF="#INSTR">INSTR</A><A HREF="#()">()</A> and <A HREF="#RINSTR">RINSTR</A>() search a particular string for the
occurrence of another string. <A HREF="#STRING$">STRING$</A><A HREF="#()">()</A>, <A HREF="#SPACE$">SPACE$</A>(), and <A HREF="#SPC">SPC</A>() generate strings
composed of several identical strings, and <A HREF="#UPPER$">UPPER$</A><A HREF="#()">()</A> transforms all lower case
letters in a string to upper case. Left and right justified insertion of one
string into another is accomplished with <A HREF="#LSET">LSET</A> and <A HREF="#RSET">RSET</A><A HREF="#.">.</A>

<A HREF="#MIN">MIN</A><A HREF="#()">()</A> and <A HREF="#MAX">MAX</A>() also work on string expressions.

<B>Memo:</B> For compiler optimizations see section <A HREF="#'">'</A><A HREF="#Character_Strings">Character Strings</A>'<A HREF="#.">.</A>
      See <A HREF="#FRE">FRE</A><A HREF="#()">()</A> for problems related to string memory handling.
<HR SIZE=3><H2 ID="RIGHT$">RIGHT$</H2>
<A NAME="LEFT$"></A><B><A HREF="#LEFT$">LEFT$</A>(a$[,x])
<A HREF="#RIGHT$">RIGHT$</A>(a$[,x])</B>

a$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>
x: <A HREF="#iexp">iexp</A>

<A HREF="#LEFT$">LEFT$</A><A HREF="#()">()</A> returns the first x characters from the character string a$<A HREF="#.">.</A> If x is
larger than the number of characters in a$, then the whole of a$ is returned.
If x is not specified, the first character of a$ is returned.

<A HREF="#RIGHT$">RIGHT$</A><A HREF="#()">()</A> returns the last x characters from the character string a$<A HREF="#.">.</A> If x is
larger than the number of characters in a$, then the whole of a$ is returned.
If x is not specified, the last character of a$ is returned.

<B>Examples:</B>

    a$<A HREF="#=">=</A>"Right-minded people use GFA BASIC"
    b$<A HREF="#=">=</A><A HREF="#LEFT$">LEFT$</A>("GFA Systemtechnik",4)
    <A HREF="#PRINT">PRINT</A> b$<A HREF="#;">;</A><A HREF="#RIGHT$">RIGHT$</A>(a$,5)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> 'GFA BASIC' is printed on the screen.

    a$<A HREF="#=">=</A>"Oh, don,t"
    b$<A HREF="#=">=</A><A HREF="#LEFT$">LEFT$</A>(a$)<A HREF="#+">+</A><A HREF="#RIGHT$">RIGHT$</A>("look")
    <A HREF="#PRINT">PRINT</A> b$

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> 'Ok' appears on the screen.
<HR SIZE=3><H2 ID="MID$">MID$</H2>
<B><A HREF="#MID$">MID$</A>(a$,x[,y])=b$</B> (as a command)

a$<A HREF="#:">:</A> <A HREF="#svar">svar</A>
b$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>
x, y: <A HREF="#iexp">iexp</A>

<A HREF="#MID$()">MID$()</A> used as an instruction makes possible the replacement of part of a
string variable a$ with the string expression b$<A HREF="#.">.</A> So with <A HREF="#MID$">MID$</A>(a$,x,y)=b$,
characters from b$ will overwrite those in a$, starting at the x-th character
position of a$<A HREF="#.">.</A> The optional parameter y determines how many characters of b$
are used. If y is omitted, then as many characters as possible of a$ are
replaced with those from b$<A HREF="#.">.</A> The length of a$ is unchanged, so that no
characters will be written beyond the end of a$<A HREF="#.">.</A>

<B>Example:</B>

    a$<A HREF="#=">=</A>"GFA SYSTEMTECHNIK"
    <A HREF="#MID$">MID$</A>(a$,5)<A HREF="#=">=</A>"BASIC "
    <A HREF="#'">'</A>
    b$<A HREF="#=">=</A>"Testword"
    <A HREF="#MID$">MID$</A>(b$,6,10)<A HREF="#=">=</A>"are you serious?"
    <A HREF="#PRINT">PRINT</A> a$, b$

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> 'GFA BASIC TECHNIK' and 'Testware' are printed.
<HR SIZE=3><H2 ID="MID$()">MID$()</H2>
<B><A HREF="#MID$">MID$</A>(a$,x[,y])</B> (as a function)

a$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>
x, y: <A HREF="#iexp">iexp</A>

The function <A HREF="#MID$()">MID$()</A> returns y characters starting at position x of the string
a$<A HREF="#.">.</A> If x is larger than the length of a$ then a null string ("") is returned.
If y is omitted, the function returns the whole of the string from position x
onwards.

<B>Example:</B>

    a$<A HREF="#=">=</A>"This is the GFA BASIC manual"
    b$<A HREF="#=">=</A><A HREF="#MID$">MID$</A>(a$,13,9)+MID$("version 3",8)
    <A HREF="#PRINT">PRINT</A> b$

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> On the screen, the text 'GFA BASIC 3' appears.
<HR SIZE=3><H2 ID="PRED()">PRED()</H2>
<A NAME="SUCC()"></A><B><A HREF="#PRED">PRED</A>(a$)
<A HREF="#SUCC">SUCC</A>(a$)</B>

a$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>

<A HREF="#PRED()">PRED()</A> returns the character with the <A HREF="#ASCII">ASCII</A> code one less than that of the
first character of the specified string. (In other words, its PREDecessor in
the <A HREF="#ASCII">ASCII</A> table.)

<A HREF="#SUCC()">SUCC()</A> returns the character with the <A HREF="#ASCII">ASCII</A> code one greater than of the the
first character of the string specified. (In other words, its SUCCessor in the
<A HREF="#ASCII">ASCII</A> table.)

These function are also effective with numbers, see the section on
<A HREF="#'">'</A><A HREF="#Integer_Arithmetic">Integer Arithmetic</A>' (<A HREF="#PRED">PRED</A> and <A HREF="#SUCC">SUCC</A>)<A HREF="#.">.</A>

<A HREF="#PRED">PRED</A>(a$) corresponds to the expression <A HREF="#CHR$">CHR$</A>(<A HREF="#ASC">ASC</A>(a$)-1)<A HREF="#.">.</A>
<A HREF="#SUCC">SUCC</A>(a$) corresponds to the expression <A HREF="#CHR$">CHR$</A>(<A HREF="#ASC">ASC</A>(a$)+1)<A HREF="#.">.</A>

<B>Example:</B>

    character$<A HREF="#=">=</A>"blue moon"
    predecessor$<A HREF="#=">=</A><A HREF="#PRED">PRED</A>(character$)
    successor$<A HREF="#=">=</A><A HREF="#SUCC">SUCC</A>(character$)
    <A HREF="#PRINT">PRINT</A> predecessor$<A HREF="#;">;</A><A HREF="#SUCC">SUCC</A>(predecessor$);successor$

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> 'abc' is displayed on the screen.
<HR SIZE=3><H2 ID="LEN">LEN</H2>
<A NAME="TRIM$"></A><B><A HREF="#LEN">LEN</A>(a$)
<A HREF="#TRIM$">TRIM$</A>(a$)</B>

a$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>

<A HREF="#LEN">LEN</A><A HREF="#()">()</A> returns the number of characters contained in a$<A HREF="#.">.</A>

<A HREF="#TRIM$">TRIM$</A><A HREF="#()">()</A> removes spaces from the left and right ends of strings.

<B>Examples:</B>

    a$<A HREF="#=">=</A>"test"
    x=<A HREF="#LEN">LEN</A>(a$)+1
    <A HREF="#PRINT">PRINT</A> x,<A HREF="#LEN">LEN</A>("word")

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Displays the number 5 and 4.

    b$<A HREF="#=">=</A>"   test  "
    <A HREF="#PRINT">PRINT</A> <A HREF="#LEN">LEN</A>(b$)
    <A HREF="#PRINT">PRINT</A> <A HREF="#TRIM$">TRIM$</A>(b$)
    <A HREF="#PRINT">PRINT</A> <A HREF="#LEN">LEN</A>(<A HREF="#TRIM$">TRIM$</A>(b$))

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Displays 9, the word 'test' (without spaces), and 4.
<HR SIZE=3><H2 ID="INSTR">INSTR</H2>
<B><A HREF="#INSTR">INSTR</A>(a$,b$)
<A HREF="#INSTR">INSTR</A>(a$,b$[,x])
<A HREF="#INSTR">INSTR</A>([x,]a$,b$)</B>

a$, b$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>
x: <A HREF="#iexp">iexp</A>

The function <A HREF="#INSTR">INSTR</A><A HREF="#()">()</A> searches the character string a$ for an occurrence of the
string b$<A HREF="#.">.</A> If x is specified, then the search begins at character position x in
a$, otherwise the whole string is searched.

If b$ is found within a$, the character position at which it begins is
returned, or, if it is not found the function returns zero (0)<A HREF="#.">.</A> This value may
be assigned to a variable or used to determine whether a particular string was
present in a$<A HREF="#.">.</A> If a$ and b$ are both null strings (""), one (1) is returned.

The search goes from left to right.

<B>Example:</B>

    a$<A HREF="#=">=</A>"GFA-Systemtechnik"
    x=<A HREF="#INSTR">INSTR</A>(a$,"System")
    <A HREF="#PRINT">PRINT</A> x,<A HREF="#INSTR">INSTR</A>("GFA-BASIC","BASIC",6)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The numbers 5 and 0 appear on the screen.

    <A HREF="#REPEAT">REPEAT</A>
      a$=123456"
      b$<A HREF="#=">=</A><A HREF="#INKEY$">INKEY$</A>
    <A HREF="#UNTIL">UNTIL</A> <A HREF="#INSTR">INSTR</A>(a$,b$)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Waits until one of the specified keys has been pressed.

<B>Memo:</B> <A HREF="#INSTR">INSTR</A><A HREF="#()">()</A> has a bug which only appears if parameter 'x' is used.
      Use the following code listing instead:

<A HREF="#FUNCTION">FUNCTION</A> instr(a$,b$,i&)
  <A HREF="#$F%">$F%</A>
  <A HREF="#LOCAL">LOCAL</A> v&
  v&<A HREF="#=">=</A><A HREF="#INSTR">INSTR</A>(a$,b$,i&)
  <A HREF="#IF">IF</A> v&&#60;i& !bug?
    v&=0
  <A HREF="#ENDIF">ENDIF</A>
  <A HREF="#RETURN">RETURN</A> v&
<A HREF="#ENDFUNC">ENDFUNC</A>
<HR SIZE=3><H2 ID="RINSTR">RINSTR</H2>
<B><A HREF="#RINSTR">RINSTR</A>(a$,b$)
<A HREF="#RINSTR">RINSTR</A>(a$,b$[,x])
<A HREF="#RINSTR">RINSTR</A>([x,]a$,b$)</B>

a$, b$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>
x: <A HREF="#iexp">iexp</A>

The function <A HREF="#RINSTR">RINSTR</A><A HREF="#()">()</A> searches the character string a$ for an occurrence of the
string b$<A HREF="#.">.</A> If x is specified, then the search begins at character position x in
a$, otherwise the whole string is searched.

If b$ is found within a$, the character position at which it begins is
returned, or, if it is not found the function returns zero (0)<A HREF="#.">.</A> This value may
be assigned to a variable or used to determine whether a particular string was
present in a$<A HREF="#.">.</A> If a$ and b$ are both null strings (""), one (1) is returned.

The search goes from right to left.

<B>Example:</B>

    <A HREF="#PRINT">PRINT</A> <A HREF="#RINSTR">RINSTR</A>("a:\FOLDER\<A HREF="#*">*</A>.GFA","\")

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The string <A HREF="#'">'</A>\' is sought in the string 'a:\FOLDER\<A HREF="#*">*</A>.GFA', starting
    from the end. Its first occurrence is found at position 10.

<B>Memo:</B> <A HREF="#RINSTR">RINSTR</A><A HREF="#()">()</A> has a bug which only appears if parameter 'x' is used.
      Use the following code listing instead:

<A HREF="#FUNCTION">FUNCTION</A> rinstr(a$,b$,i&)
  <A HREF="#$F%">$F%</A>
  <A HREF="#LOCAL">LOCAL</A> v&
  v&<A HREF="#=">=</A><A HREF="#RINSTR">RINSTR</A>(a$,b$,i&)
  <A HREF="#IF">IF</A> i&<A HREF="#=">=</A><A HREF="#LEN">LEN</A>(b$) !bug?
    v&<A HREF="#=">=</A><A HREF="#-">-</A>(<A HREF="#LEFT$">LEFT$</A>(a$,i&)=b$)
  <A HREF="#ELSE_IF">ELSE IF</A> i&&#60;<A HREF="#LEN">LEN</A>(b$) !bug?
    v&=0
  <A HREF="#ENDIF">ENDIF</A>
  <A HREF="#RETURN">RETURN</A> v&
<A HREF="#ENDFUNC">ENDFUNC</A>
<HR SIZE=3><H2 ID="STRING$">STRING$</H2>
<A NAME="SPACE$"></A><A NAME="SPC"></A><B><A HREF="#STRING$">STRING$</A>(x,a$)
<A HREF="#STRING$">STRING$</A>(x,code)
<A HREF="#SPACE$">SPACE$</A>(x)
<A HREF="#SPC">SPC</A>(x)</B>

x, code: <A HREF="#iexp">iexp</A>
a$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>

The function <A HREF="#STRING$">STRING$</A><A HREF="#()">()</A> returns a string which reproduces the expression 'a$'
(or <A HREF="#ASCII">ASCII</A> character whose number is 'code') x times, where x has a maximum
value of 32767.

<A HREF="#SPACE$">SPACE$</A><A HREF="#()">()</A> returns a string consisting of x spaces.

<A HREF="#SPC">SPC</A><A HREF="#()">()</A> inserts x spaces in a <A HREF="#PRINT">PRINT</A> statement without the need to create a string
variable or to explicitly specify the spaces by " "<A HREF="#.">.</A>

<B>Example:</B>

    a$<A HREF="#=">=</A>"GFA "
    b$<A HREF="#=">=</A><A HREF="#SPACE$">SPACE$</A>(5)
    <A HREF="#PRINT">PRINT</A> b$<A HREF="#;">;</A><A HREF="#STRING$">STRING$</A>(3,a$);<A HREF="#SPC">SPC</A>(4);STRING$(5,65)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> <A HREF="#'">'</A>     GFA GFA GFA     AAAAA' appears on the screen.

<B>Memo:</B> <A HREF="#STRING$">STRING$</A><A HREF="#()">()</A> compiled issues the wrong error code (#15)<A HREF="#.">.</A>
      Interpreter issues #10 as it should be.

      <A HREF="#SPACE$">SPACE$</A><A HREF="#()">()</A> and <A HREF="#STRING$">STRING$</A>(count,code) do weird things without of range
      string sizes in compiled applications. No error is generated and the
      string <A HREF="#LEN">LEN</A><A HREF="#()">()</A> ends up -negative.
<HR SIZE=3><H2 ID="UPPER$">UPPER$</H2>
<B><A HREF="#UPPER$">UPPER$</A>(A$)</B>

a$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>

All lower case letters in a$ are converted to upper case.

This also happens to characters containing umlauts.

<B>Example:</B>

    a$<A HREF="#=">=</A>" test"
    b$<A HREF="#=">=</A><A HREF="#UPPER$">UPPER$</A>(a$)+UPPER$("ware")
    <A HREF="#PRINT">PRINT</A> <A HREF="#UPPER$">UPPER$</A>("Gfa basic 3");b$

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> On the screen 'GFA BASIC 3 TESTWARE' appears.

<B>Memo:</B> Umlaut conversion table is as follows:
      Before: <A HREF="#&">&</A>#252;&#233;&#228;&#224;&#229;&#231;&#230;&#246;&#241;&#227;&#245;&#248;&#339;&#307;
      After:  <A HREF="#&">&</A>#252;&#201;&#196;&#192;&#197;&#199;&#198;&#246;&#209;&#195;&#213;&#216;&#338;&#306;
<HR SIZE=3><H2 ID="RSET">RSET</H2>
<A NAME="LSET"></A><B><A HREF="#LSET">LSET</A> a$=b$
<A HREF="#RSET">RSET</A> a$=b$</B>

a$<A HREF="#:">:</A> <A HREF="#svar">svar</A>
b$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>

<A HREF="#LSET">LSET</A> and <A HREF="#RSET">RSET</A> will set the string expression b$ into a$, justified either to
the left or to the right. If b$ is shorter than a$ (the normal situation)
spaces will be inserted to make up the original length of a$<A HREF="#.">.</A> Note that the
actual content of a$ is irrelevant: only its length is significant.

<B>Example:</B>

    a$<A HREF="#=">=</A>"xxxxx"
    <A HREF="#FOR">FOR</A> i%=1 TO 128
      <A HREF="#LSET">LSET</A> a$<A HREF="#=">=</A><A HREF="#STR$">STR$</A>(i%) <A HREF="#!">!</A> left-justified format
      <A HREF="#PRINT">PRINT</A> a$<A HREF="#;">;</A>
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#'">'</A>
    <A HREF="#FOR">FOR</A> i%=1 TO 128
      <A HREF="#RSET">RSET</A> a$<A HREF="#=">=</A><A HREF="#STR$">STR$</A>( i%) !right-justified format
      <A HREF="#PRINT">PRINT</A> a$<A HREF="#;">;</A>
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#~">~</A><A HREF="#INP">INP</A>(2)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Displays left- and right-justified formatted columns of numbers, then waits
    for a key to be pressed.

    a$<A HREF="#=">=</A><A HREF="#STR$">STR$</A>(i%,5,0) could also be used in place of <A HREF="#RSET">RSET</A> a$=STR$(i%)
<HR SIZE=3><H2 ID="Chapter__6_-_Input_and_Output">Chapter  6 - Input and Output</H2>
This first section begins with an examination of the command <A HREF="#INKEY$">INKEY$</A>, which
takes a single character from the keyboard. Next, the family of <A HREF="#INPUT">INPUT</A> commands
is examined, along with the related commands <A HREF="#LINE_INPUT">LINE INPUT</A>, <A HREF="#FORM_INPUT">FORM INPUT</A>, and FORM
<A HREF="#INPUT">INPUT</A> AS. The discussion of output capabilities begins with the most simple
instruction, <A HREF="#PRINT">PRINT</A>, and goes on to extended versions such as <A HREF="#PRINT_AT">PRINT AT</A> and PRINT
USING. <A HREF="#CRSCOL">CRSCOL</A>, <A HREF="#CRSLIN">CRSLIN</A>, and <A HREF="#POS">POS</A><A HREF="#()">()</A> are used to report on the current cursor
position, and <A HREF="#TAB">TAB</A><A HREF="#()">()</A>, <A HREF="#HTAB">HTAB</A>, and <A HREF="#VTAB">VTAB</A> are used to control it. At the end of this
section, the KEYxxx commands are considered, these being a family of commands
for the interrogation of the keyboard, and its configuration while a program is
running.

<B>Memo:</B> Internally GFABASIC uses a 4kb disk caching scheme. How does this work?
      All reads/writes are round to 4096 bytes. If you read one byte from a
      file, it will actually read 4096 bytes and any futher reads up to the
      end of the 4kb buffer will be read from ram. The same applies to writes,
      a 4kb buffer is created and it only purges the cache when its full. This
      speeds up disk reads and writes, especially with floppy disks.

      This disk caching scheme only applies to disk files. It is not used on
      devices like MIDI and serial ports, or the console even if one uses
      <A HREF="#OPEN">OPEN</A> on these devices.

      A warning about files <A HREF="#OPEN">OPEN</A> for output:
      You must make sure you <A HREF="#CLOSE">CLOSE</A> these files before your program exits or
      data could be lost. <A HREF="#CLOSE">CLOSE</A> will force any cached data to be written,
      before closing the file. If you let the operating system close these
      files at pterm(), any cached data will be lost and these files might be
      truncated.
<HR SIZE=3><H2 ID="Keyboard_and_Screen_Handling">Keyboard and Screen Handling</H2>
<A HREF="#INKEY$">INKEY$</A>
<A HREF="#INPUT">INPUT</A>, <A HREF="#LINE_INPUT">LINE INPUT</A>, <A HREF="#FORM_INPUT">FORM INPUT</A>
<A HREF="#PRINT">PRINT</A> (<A HREF="#?">?</A>), <A HREF="#PRINT_AT">PRINT AT</A><A HREF="#()">()</A>, <A HREF="#PRINT_USING">PRINT USING</A>
<A HREF="#WRITE">WRITE</A>
<A HREF="#LOCATE">LOCATE</A>
<A HREF="#MODE">MODE</A>
<A HREF="#DEFNUM">DEFNUM</A>
<A HREF="#CRSCOL">CRSCOL</A>, <A HREF="#CRSLIN">CRSLIN</A>
<A HREF="#POS">POS</A><A HREF="#()">()</A>, <A HREF="#TAB">TAB</A>()
<A HREF="#HTAB">HTAB</A>, <A HREF="#VTAB">VTAB</A>
<HR SIZE=3><H2 ID="INKEY$">INKEY$</H2>
<B><A HREF="#INKEY$">INKEY$</A></B>

<A HREF="#INKEY$">INKEY$</A> reads a character from the keyboard. This function will, however, not
detect depressions of the Shift, Alternate, or Control keys alone. <A HREF="#INKEY$">INKEY$</A> does
not wait for a key to be pressed, but scans the keyboard to check whether a key
has been pressed since the last scan. If it has, the command accepts that
pressed key, otherwise a null string ("") is returned. When the key pressed has
no <A HREF="#ASCII">ASCII</A> code, for example a Function key or the HELP or UNDO keys, then <A HREF="#INKEY$">INKEY$</A>
returns the scan code of the pressed key as a two-character long string
containing <A HREF="#CHR$">CHR$</A>(0) as its first character, and the identification code of the
special key as the second character.

The following example demonstrates how the values returned by <A HREF="#INKEY$">INKEY$</A> can be
examined:

    <A HREF="#DO">DO</A>
      t$<A HREF="#=">=</A><A HREF="#INKEY$">INKEY$</A>
      <A HREF="#IF">IF</A> t$<A HREF="#&#60;&#62;">&#60;&#62;</A>""
        <A HREF="#IF">IF</A> <A HREF="#LEN">LEN</A>(t$)=1
          <A HREF="#PRINT">PRINT</A> "Character: ";t$,"<A HREF="#ASCII">ASCII</A> code: ";<A HREF="#ASC">ASC</A>(t$)
        <A HREF="#ELSE">ELSE</A>
          <A HREF="#PRINT">PRINT</A> "<A HREF="#CHR$">CHR$</A>(0)<A HREF="#+">+</A><A HREF="#Scan">Scan</A> code: "<A HREF="#;">;</A><A HREF="#CVI">CVI</A>(t$)
        <A HREF="#ENDIF">ENDIF</A>
      <A HREF="#ENDIF">ENDIF</A>
    <A HREF="#LOOP">LOOP</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Displays the <A HREF="#ASCII">ASCII</A> or <A HREF="#Scan">Scan</A> code of each key pressed.

<B>Note:</B> <A HREF="#CVI">CVI</A><A HREF="#()">()</A> turns a 2-byte string into an integer. As the first byte of the
      string is zero, in this case it returns the value of the second byte.
<HR SIZE=3><H2 ID="INPUT">INPUT</H2>
<B><A HREF="#INPUT">INPUT</A> ["text",] x [,y,<A HREF="#.">.</A>..]
<A HREF="#INPUT">INPUT</A> ["text"<A HREF="#;">;</A>] x [,y,<A HREF="#.">.</A>..]</B>

x, y: <A HREF="#avar">avar</A> or <A HREF="#svar">svar</A>

The command <A HREF="#INPUT">INPUT</A> can be used in several ways. It accepts the input of
variables or variable lists with or without a text message being displayed on
the screen. For <A HREF="#INPUT">INPUT</A>, the cursor will normally retain its last screen
position; however, by means of <A HREF="#PRINT_AT">PRINT AT</A><A HREF="#()">()</A> followed by a semicolon, or by using
<A HREF="#LOCATE">LOCATE</A>, <A HREF="#VTAB">VTAB</A>, or <A HREF="#HTAB">HTAB</A>, the cursor can be put at a desired screen position.

A text string may follow the <A HREF="#INPUT">INPUT</A> command, separated from the following
variables by a comma or a semicolon. If a semicolon is used, then a question
mark and a space are printed on the screen and the cursor placed at the
succeeding character position. When a comma is used, the question mark and
space are omitted, and the cursor is placed directly after the last character
of the text string.

If no text is to be displayed, then the question mark and space are printed,
and the cursor is put directly after the space (as if a null string ("") had
been used as text, followed by a semicolon)<A HREF="#.">.</A>

When only one variable is to be input, the user types in a number or a
character string and terminates it by pressing either the Return or the Enter
key. When several values are to be entered (if there was a list of variables
after the <A HREF="#INPUT">INPUT</A> statement in the program line), each individual variable can be
terminated by pressing Return or Enter, or they may be typed in separated by
commas and all confirmed together with a single press of the Return or Enter
key.

If a string is to be entered which may contain commas, the instruction <A HREF="#LINE">LINE</A>
<A HREF="#INPUT">INPUT</A> must be used.

If a numeric variable was expected by the <A HREF="#INPUT">INPUT</A> statement, and a non-numeric
string typed in instead, a bell signal sounds, and the input must be repeated.

Prior to the Return or Enter key being pressed the input can be edited by means
of the Backspace, Delete, and Left and Right arrow keys. Pressing the <A HREF="#INSERT">INSERT</A>
key switches between, insert and overwrite modes during editing.  The maximum
length of the input is 255 characters.

<A HREF="#Special">Special</A> symbols can be entered in three different ways:

    <A HREF="#-">-</A> By holding down the Alternate key and typing in the <A HREF="#ASCII">ASCII</A> code of the
      desired character using the numeric pad. When the Alternate key is
      released, the appropriate character is displayed. For instance, with 64
      as the <A HREF="#ASCII">ASCII</A> code, the characeter <A HREF="#'">'</A><A HREF="#@">@</A>' appears. This also works with
      <A HREF="#INKEY$">INKEY$</A>, <A HREF="#INP">INP</A>(2), GEM Dialog Boxes etc., if it is not switched off by the
      command <A HREF="#KEYPAD">KEYPAD</A><A HREF="#.">.</A>

    <A HREF="#-">-</A> By typing Control-S followed by another character, for example Control-S
      C for the Pi character. (Press the Control and S key at the same time,
      then press C.) This feature only works with the <A HREF="#INPUT">INPUT</A> statement or in
      Edit mode, when a program is actually being typed in.

    <A HREF="#-">-</A> By typing Control-A followed by the <A HREF="#ASCII">ASCII</A> code of the desired character,
      e.g.<A HREF="#:">:</A> Control-A 64 for the <A HREF="#'">'</A><A HREF="#@">@</A>' character.

<B>Example:</B>

    <A HREF="#INPUT">INPUT</A> a$
    <A HREF="#INPUT">INPUT</A> "",b$
    <A HREF="#INPUT">INPUT</A> "Enter two numbers <A HREF="#:">:</A>";x,y
    <A HREF="#PRINT">PRINT</A> a$,b$,x,y

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Reads in two strings and two numeric variables. The first input command
    generates a <A HREF="#?">?</A>, the second appears with no text and the third issues the
    message 'Enter two numbers: <A HREF="#?">?</A>'<A HREF="#.">.</A>
<HR SIZE=3><H2 ID="LINE_INPUT">LINE INPUT</H2>
<B><A HREF="#LINE_INPUT">LINE INPUT</A> ["text",] a$ [,b$,<A HREF="#.">.</A>..]
<A HREF="#LINE_INPUT">LINE INPUT</A> ["text"<A HREF="#;">;</A>] a$ [,b$,<A HREF="#.">.</A>..]</B>

a$, b$<A HREF="#:">:</A> <A HREF="#svar">svar</A>

<A HREF="#LINE_INPUT">LINE INPUT</A> is a variant of the <A HREF="#INPUT">INPUT</A> command. Unlike INPUT, it allows commas to
be accepted as part of the input. The preceding description of the input of
variables or a variable list, and the facilities for correction of the input
prior to the pressing of Return or Enter also apply to <A HREF="#LINE_INPUT">LINE INPUT</A><A HREF="#.">.</A> <A HREF="#LINE">LINE</A> <A HREF="#INPUT">INPUT</A>,
however, may only be used with string variables.

<B>Example:</B>

    <A HREF="#LINE_INPUT">LINE INPUT</A> a$
    <A HREF="#INPUT">INPUT</A> b$
    <A HREF="#PRINT">PRINT</A> a$,b$

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> When the program is Run, and the text 'com,ma' inputted twice, a$ is taken
    as 'com,ma' whilst b$ contains 'com', as the 'ma' is taken as a separate
    input and ignored. See also <A HREF="#LINE_INPUT_#">LINE INPUT #</A>.

<B>Memo:</B> The maximum length of the input is 255 characters.
<HR SIZE=3><H2 ID="FORM_INPUT">FORM INPUT</H2>
<A NAME="FORM_INPUT_AS"></A><B><A HREF="#FORM_INPUT">FORM INPUT</A> n,a$
<A HREF="#FORM_INPUT">FORM INPUT</A> n AS a$</B>

n: <A HREF="#iexp">iexp</A>
a$<A HREF="#:">:</A> <A HREF="#svar">svar</A>

<A HREF="#FORM_INPUT">FORM INPUT</A> and <A HREF="#FORM_INPUT_AS">FORM INPUT AS</A> are both used to input string variables. The value
of n specifies the number of characters to be entered, up to a maximum of 255.

Additionally, <A HREF="#FORM_INPUT_AS">FORM INPUT AS</A> displays the current value of a$, which can then be
edited, or taken as a 'default' input by pressing Return or Enter immediately.
The editing facilities are the same as those for the <A HREF="#INPUT">INPUT</A> command.

<B>Example:</B>

    <A HREF="#FORM_INPUT">FORM INPUT</A> 10,a$
    b$<A HREF="#=">=</A>"test"
    <A HREF="#FORM_INPUT">FORM INPUT</A> 5 AS b$
    <A HREF="#PRINT">PRINT</A> a$,b$

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> This asks for two strings to be entered. On the entry of the second string,
    the word 'test' is displayed as a preselected value of b$<A HREF="#.">.</A> This may then be
    edited, or accepted by pressing Return.

<B>Memo:</B> A value of 0 for n is valid and causes the input to auto end.
<HR SIZE=3><H2 ID="PRINT">PRINT</H2>
<A NAME="PRINT_AT"></A><A NAME="WRITE"></A><A NAME="LOCATE"></A><A NAME="?"></A><A NAME=";"></A><B><A HREF="#PRINT">PRINT</A> [expression]
<A HREF="#PRINT_AT">PRINT AT</A>(column,line) [expression]
<A HREF="#WRITE">WRITE</A> [expression]
<A HREF="#LOCATE">LOCATE</A> column,line</B>

expression: arbitrary combination of <A HREF="#sexp">sexp</A> or <A HREF="#aexp">aexp</A>
column, line: <A HREF="#iexp">iexp</A>

The instruction <A HREF="#PRINT">PRINT</A>, without parameters, causes a blank line to be printed.
If the cursor happens to be on the last line, the entire screen is scrolled up
one line. <A HREF="#PRINT">PRINT</A> followed by an expression causes the expression to be printed
at the current cursor position. Text strings must be enclosed in quotes. If the
expression to be printed consists of several elements (constants, variables, or
expressions), the individual parts must separated by a semicolon, comma, or
apostrophe, with the following effects:

<A HREF="#&">&</A>#8226; A comma causes the cursor to move to one position past the next column number
  which is divisible by 16. In other words, the columns 1, 17, 33, etc. are
  used. If this takes the cursor beyond the end of the line, the cursor moves
  to column 1 of the next line.

<A HREF="#&">&</A>#8226; A semicolon causes the output of the corresponding elements, one after the
  other without any spaces being added.

<A HREF="#&">&</A>#8226; An apostrophe inserts one space between the appropriate elements.

<A HREF="#PRINT_AT">PRINT AT</A><A HREF="#()">()</A> makes it possible for the expression to be displayed on a specified
line, starting at a specified column. Depending on the current screen
resolution, up to 80 columns and 25 lines are available.

<B>Note:</B> Column and line numbers begin at 1, and not 0.

If a window is open, the column and line numbers are relative to the top
left-hand corner of the window.

If the output expression (the message) is not terminated with a semicolon, the
cursor is placed at the beginning of the next line. If it was already at the
bottom of the screen, then the screen is scrolled up by one line.

If print control characters (<A HREF="#ASCII">ASCII</A> characters from 0 to 31) are specified, then
these are processed by the <A HREF="#VT-52">VT-52</A> Emulator (see <A HREF="#Appendix">Appendix</A>)<A HREF="#.">.</A>

The <A HREF="#WRITE">WRITE</A> command can be used to send output to the screen. The command is
followed by the numerical or string expressions to be sent, separated by
commas. The output <U>includes the commas</U> and, with string expressions,
the quotation marks are also included. A semicolon may be placed after the last
item to be output, in which case the usual Carriage Return/Line Feed will be
suppressed.

<A HREF="#LOCATE">LOCATE</A> places the cursor at the specified <U>column and line</U>, i.e. in the
<U>same</U> order as <A HREF="#PRINT_AT">PRINT AT</A><A HREF="#()">()</A><A HREF="#.">.</A> It will not, however, actually display
anything. See <A HREF="#VTAB">VTAB</A> and <A HREF="#HTAB">HTAB</A>.

<B>Examples:</B>

    a$<A HREF="#=">=</A>"GFA Systemtechnik"
    <A HREF="#PRINT">PRINT</A> <A HREF="#LEFT$">LEFT$</A>(a$,4)<A HREF="#+">+</A>"BASIC"'1+2;
    <A HREF="#PRINT">PRINT</A> ".0","GFA "<A HREF="#;">;</A><A HREF="#UPPER$">UPPER$</A>(<A HREF="#MID$">MID$</A>(a$,5))

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Displays 'GFA BASIC 3.0' and 'GFA SYSTEMTECHNIK'.

    <A HREF="#PRINT_AT">PRINT AT</A>(5,8)<A HREF="#;">;</A>"Fifth column, eighth line"

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Prints the message starting at the position x=5, y=8.

    <A HREF="#LOCATE">LOCATE</A> 5,8
    <A HREF="#PRINT">PRINT</A> "Eighth line, fifth column"

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Positions the cursor at the fifth column of the eighth line and
    displays the message, again x=5 and y=8.

    <A HREF="#WRITE">WRITE</A> 1+1,"Hello",3*4

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The output is: '2,"Hello",12'<A HREF="#.">.</A>

<B>Memo:</B> The manual originally documented <A HREF="#LOCATE">LOCATE</A> with the parameters
      reversed. However it actually works like so: <A HREF="#LOCATE">LOCATE</A> x,y

      Internally <A HREF="#PRINT">PRINT</A> is really a <A HREF="#BIOS">BIOS</A> call to bconout(DEV_CON)<A HREF="#.">.</A>
      <A HREF="#LOCATE">LOCATE</A> is really a <A HREF="#BIOS">BIOS</A> call to bconout(<A HREF="#VT-52">VT-52</A> ESC+Y)
      <A HREF="#PRINT_AT">PRINT AT</A><A HREF="#()">()</A> is convert to a call to <A HREF="#LOCATE">LOCATE</A><A HREF="#.">.</A>

Bconout()<A HREF="#+">+</A>, Cconws()+, v_curtext()+, vs_curaddress()+
<HR SIZE=3><H2 ID="PRINT_USING">PRINT USING</H2>
<B><A HREF="#PRINT_USING">PRINT USING</A> format$,expression [<A HREF="#;">;</A>]
<A HREF="#PRINT_AT">PRINT AT</A>(column,line);USING format$,expression [;]</B>

format$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>
expression: as many <A HREF="#aexp">aexp</A> or <A HREF="#sexp">sexp</A> as wanted, separated by commas
column, line: <A HREF="#iexp">iexp</A>

<A HREF="#PRINT_USING">PRINT USING</A> and its variant <A HREF="#PRINT_AT">PRINT AT</A><A HREF="#()">()</A> USING serve to format data output on the
screen. These commands work in the same general way as <A HREF="#PRINT">PRINT</A> or <A HREF="#PRINT_AT">PRINT AT</A><A HREF="#()">()</A>.
However, the data in the expression to be displayed are ormatted according to
the contents of format$<A HREF="#.">.</A>

The following symbols may be used to format a numerical expression:

    <A HREF="##">#</A>  Reserves a character position for a number (digit)<A HREF="#.">.</A>

    <A HREF="#.">.</A>  A period specifies the position of the decimal point within several <A HREF="#'">'</A><A HREF="##">#</A>'
       symbols

    ,  A comma in the appropriate place between <A HREF="#'">'</A><A HREF="##">#</A>' signs causes the insertion
       of a comma, e.g. as a 'thousands' separator in 10,000.

    <A HREF="#-">-</A>  The minus sign reserves a character position for a minus sign, in case
       the number to be printed is negative. For a positive number a space will
       be printed instead. (<A HREF="#GFA-Basic">GFA-Basic</A> normally prints nothing preceding a
       positive number.)

    <A HREF="#+">+</A>  Reserves a space for the plus sign of a positive number. If the number
       is positive, the <A HREF="#'">'</A><A HREF="#+">+</A>' sign will be printed, but if it is negative a minus
       sign will appear as usual. (See <A HREF="#'">'</A><A HREF="#-">-</A>' above.)

    <A HREF="#*">*</A>  Replacement for <A HREF="##">#</A> above, with the difference that leading zeros are
       replaced by asterisks, instead of blanks.

    <A HREF="#$">$</A>  Causes one dollar <A HREF="#'">'</A>$' character to be printed before a number, provided
       it is put directly before the first <A HREF="#'">'</A><A HREF="##">#</A>' symbol.

    <A HREF="#^">^</A>  Specifies the length of the exponent (including the 'E+') when a number
       is to be printed in exponential format (e.g. E+123). If the number of
       digits before the decimal point is specified using several <A HREF="#'">'</A><A HREF="##">#</A>' symbols,
       then the exponent is adjusted to take account of this.  For a negative
       exponent, the possibility of a <A HREF="#'">'</A><A HREF="#-">-</A>' must be allowed for by '-' above.

In contrast to <A HREF="#GFA-Basic">GFA-Basic</A> Version 2, the principle 'Formatting First' is adhered
to. That is, in the case of overflows only the digits with character positions
reserved for them will be displayed. Thus, great care must be taken to ensure
that the string to be printed can actually be accommodated within the format
specified.

For formatting strings the following symbols are available:

    <A HREF="#&">&</A>      Causes the output of the entire character string.

    <A HREF="#!">!</A>      The output is limited to the first character of the string.

    \<A HREF="#.">.</A>..\  Specifies the number of characters of the string to be printed.
           (The counting includes the two <A HREF="#'">'</A>\' symbols)<A HREF="#.">.</A>

    _      Causes the output of the character following the underline ('_')
           character. A sequence of characters can be output by placing it
           between two '_' characters.

<B>Examples:</B>

    <A HREF="#PRINT_USING">PRINT USING</A> "<A HREF="##">#</A><A HREF="#.">.</A>####",<A HREF="#PI">PI</A>
    <A HREF="#PRINT_AT">PRINT AT</A>(4,4);USING "PI_._._.<A HREF="##">#</A>.###",PI;

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Displays '3.1416' and '<A HREF="#PI">PI</A>... 3.142'.

    <A HREF="#FOR">FOR</A> i%=1 TO 14
      <A HREF="#PRINT_USING">PRINT USING</A> "<A HREF="##">#</A>##<A HREF="#.">.</A>##<A HREF="#^">^</A>^^^ ",2^i%<A HREF="#;">;</A>
    <A HREF="#NEXT">NEXT</A> i%

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Displays:  1.00E+00  2.00E+00   4.00E+00   8.00E+00  16.00E+00
              32.00E+00 64.00E+00 128.00E+00 256.00E+00 512.00E+00
               1.02E+03  2.05E+03   4.10E+03   8.19E+03  16.38E+03

The functions of commas and periods can be exchanged using the <A HREF="#MODE">MODE</A> command.
<HR SIZE=3><H2 ID="MODE">MODE</H2>
<B><A HREF="#MODE">MODE</A> n</B>

n: <A HREF="#iexp">iexp</A>

With <A HREF="#MODE">MODE</A> the representations of the decimal point and the 'thousands comma' as
interpreted by PRlNT USING (and also by <A HREF="#STR$">STR$</A><A HREF="#()">()</A> with 3 parameters) can be
reversed. This allows the use of the continental method of representing
numbers.

In addition, <A HREF="#MODE">MODE</A> selects the format of the date representation used by <A HREF="#DATE$">DATE$</A>,
<A HREF="#SETTIME">SETTIME</A>, <A HREF="#DATE$=">DATE$=</A>, and <A HREF="#FILES">FILES</A><A HREF="#.">.</A> The parameter n can be between 0 and 3. The
following may then be used:

    <B>Mode  USING     <A HREF="#DATE$">DATE$</A></B>
    0     <A HREF="##">#</A>,###<A HREF="#.">.</A>##  DD.MM.YYYY  (default)
    1     <A HREF="##">#</A>,###<A HREF="#.">.</A>##  MM/DD/YYYY  US
    2     <A HREF="##">#</A><A HREF="#.">.</A>###,##  DD.MM.YYYY
    3     <A HREF="##">#</A><A HREF="#.">.</A>###,##  MM/DD/YYYY

<B>Memo:</B> <A HREF="#MODE">MODE</A> does no range check at all on the parameter.
<HR SIZE=3><H2 ID="DEFNUM">DEFNUM</H2>
<B><A HREF="#DEFNUM">DEFNUM</A> n</B>

n: <A HREF="#iexp">iexp</A>

<A HREF="#DEFNUM">DEFNUM</A> affects the output of numbers by the <A HREF="#PRINT">PRINT</A> command and its variants.
All numbers following the <A HREF="#DEFNUM">DEFNUM</A> instruction are outputted to occupy n
character positions, not counting the decimal point. Rounding takes place based
on the value of the (n+1)-th digit. The internal computational accuracy is not
affected.

<B>Example:</B>

    <A HREF="#PRINT">PRINT</A> 100/6
    <A HREF="#DEFNUM">DEFNUM</A> 5
    <A HREF="#PRINT">PRINT</A> 100/6

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The numbers 16.66666666667 and 16.667 appear on the screen.

<B>Memo:</B> Only values <A HREF="#=">=</A><A HREF="#&">&</A>#62;3 are accepted, lower numbers are ignored.
      The upper limit appears to be 14.
      The default is 13.
      <A HREF="#DEFNUM">DEFNUM</A> 14 seems to work and outputs the result minus the rounding.
<HR SIZE=3><H2 ID="CRSCOL">CRSCOL</H2>
<A NAME="CRSLIN"></A><A NAME="POS"></A><A NAME="TAB"></A><A NAME="HTAB"></A><A NAME="VTAB"></A><B><A HREF="#CRSCOL">CRSCOL</A>
<A HREF="#CRSLIN">CRSLIN</A>
<A HREF="#POS">POS</A>(x)
<A HREF="#TAB">TAB</A>(n)
<A HREF="#HTAB">HTAB</A> column
<A HREF="#VTAB">VTAB</A> line</B>

n, column, line: <A HREF="#iexp">iexp</A>
x: <A HREF="#aexp">aexp</A>

This group of commands serve to return the location of the cursor, or to place
the cursor at a particular position.

<A HREF="#CRSCOL">CRSCOL</A> returns the current column (X) position of the cursor.

<A HREF="#CRSLIN">CRSLIN</A> returns the current line (Y) position of the cursor.

<A HREF="#POS">POS</A><A HREF="#()">()</A> returns the number of characters displayed on the screen (ANDed with 255
to give a maximum of 255) since the last Carriage Return. The expression x is
ignored. The value returned by <A HREF="#POS">POS</A><A HREF="#()">()</A> may, however, not agree with <A HREF="#CRSCOL">CRSCOL</A> e.g.
if a string 120 characters long is displayed, <A HREF="#POS">POS</A>(0) in this case will return
the value 120, where as <A HREF="#CRSCOL">CRSCOL</A> will return 41, the column number of the next
character to be printed counting from the left edge. With the output of control
characters <A HREF="#POS">POS</A><A HREF="#()">()</A> has even less to do with the current cursor column reported by
<A HREF="#CRSCOL">CRSCOL</A>, since <A HREF="#POS">POS</A><A HREF="#()">()</A> will keep track of non-printed characters, e.g.
ESCape=<A HREF="#CHR$">CHR$</A>(27)<A HREF="#.">.</A> <A HREF="#POS">POS</A><A HREF="#()">()</A> will, however, ignore Line Feeds=CHR$(10), be reduced by
one by the printing of a Backspace=<A HREF="#CHR$">CHR$</A>(8), or be reset to zero by a Carriage
Return=<A HREF="#CHR$">CHR$</A>(13)<A HREF="#.">.</A>

<A HREF="#TAB">TAB</A>(n) prints spaces until <A HREF="#POS">POS</A><A HREF="#()">()</A> reaches n. If POS() already exceeds n, then a
Carriage Return/Line Feed is executed first. The value of n is limited to a
maximum of 255 by ANDing it internally with 255.

The instruction <A HREF="#HTAB">HTAB</A> positions the cursor to the specified column (X)<A HREF="#.">.</A>

The instruction <A HREF="#VTAB">VTAB</A> positions the cursor to the specified line (Y)<A HREF="#.">.</A>

<B>Note:</B> The cursor columns and lines are counted from 1, and not 0.

<B>Examples:</B>

    <A HREF="#PRINT_AT">PRINT AT</A>(3,12)<A HREF="#;">;</A>"Test";
    <A HREF="#PRINT">PRINT</A> <A HREF="#CRSCOL">CRSCOL</A><A HREF="#'">'</A><A HREF="#CRSLIN">CRSLIN</A>
    <A HREF="#PRINT">PRINT</A> <A HREF="#TAB">TAB</A>(37)<A HREF="#;">;</A>"Test";
    <A HREF="#PRINT">PRINT</A> <A HREF="#POS">POS</A>(0)
    <A HREF="#INP">INP</A>(2)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> On the screen, 'Test7 12' appears and, underneath it, 'Test41'<A HREF="#.">.</A> (<A HREF="#POS">POS</A><A HREF="#()">()</A>
    returns 41, and not 42, as it is counted from zero rather than 1 as with
    <A HREF="#CRSCOL">CRSCOL</A>)<A HREF="#.">.</A>

    <A HREF="#PRINT_AT">PRINT AT</A>(4,3)<A HREF="#;">;</A>"Word 1"
    <A HREF="#HTAB">HTAB</A> 4
    <A HREF="#VTAB">VTAB</A> 2
    <A HREF="#PRINT">PRINT</A> "Word 2"

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> 'Word 1' appears starting at line 3, column 1, and 'Word 2' at line 2,
     column 4.

<B>Memo:</B> CRSCOL/CRSLIN are actually <A HREF="#Line-A">Line-A</A> variables.
      Internally HTAB/VTAB call CRSCOL/CRSLIN.

      CRSCOL/CRSLIN <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> V_CUR_XY (<A HREF="#Line-A">Line-A</A> variables)

<A HREF="#Line-A_Variable_Table">Line-A Variable Table</A><A HREF="#+">+</A>, vq_curaddress()+, vs_curaddress()+
<HR SIZE=3><H2 ID="KEYxxx_Commands">KEYxxx Commands</H2>
<A HREF="#KEYPAD">KEYPAD</A>
<A HREF="#KEYTEST">KEYTEST</A>
<A HREF="#KEYGET">KEYGET</A>
<A HREF="#KEYLOOK">KEYLOOK</A>
<A HREF="#KEYPRESS">KEYPRESS</A>
<A HREF="#KEYDEF">KEYDEF</A>

This group of functions makes it possible to read the status of the keyboard
shift keys while a program is running as well as assigning freely definable
character strings (max. 31 characters each) to the Function Keys, which will
also be available when using the GFA BASIC Editor.
<HR SIZE=3><H2 ID="KEYPAD">KEYPAD</H2>
<B><A HREF="#KEYPAD">KEYPAD</A> n</B>

n: <A HREF="#iexp">iexp</A>

The numerical expression n is evaluated bit by bit and has the following
meaning:

    <B>Bit  Meaning             0               1</B>
    0    NumLock             On              Off
    1    NumLock             Not switchable  Switchable
    2    CTRL-<A HREF="#KEYPAD">KEYPAD</A>         Normal          Cursor
    3    ALT-<A HREF="#KEYPAD">KEYPAD</A>          Normal          <A HREF="#ASCII">ASCII</A>
    4    <A HREF="#KEYDEF">KEYDEF</A> without ALT  Off             On
    5    <A HREF="#KEYDEF">KEYDEF</A> with ALT     Off             On

With bit 0 set the keypad will act as a 'PC' keypad with NumLock off, i.e. it
responds with cursor movements.

With bit 1 set the 'PC' NumLock mode can be toggled with Control and '<A HREF="#-">-</A>',
otherwise it cannot. Control and <A HREF="#'">'</A>(' also toggles NumLock mode. When NumLock
is on a circumflex (<A HREF="#^">^</A>) appears under the Atari logo in the Menu bar.

With bit 2 set, NumLock is effectively switched off while the Control key is
held down. Thus Control-4 (on the keypad) produces cursor movements.

With bit 3 set <A HREF="#ASCII">ASCII</A> values for characters can be typed in with the ALTernate
key held down. When ALT is released, the character appears.

With bit 4 set, the character strings assigned with <A HREF="#KEYDEF">KEYDEF</A> to the keys F1 to
F10 and Shift-F1 to Shift-F10 are output when the key is pressed.

With bit 5 set the ALTernate key must also be held down.

When turned on, the Atari ST is effectively configured to <A HREF="#KEYPAD">KEYPAD</A> 0. With
<A HREF="#GFA-Basic">GFA-Basic</A> in operation, the default keypad mode is decimal 46, i.e.  bits 1, 2,
3, and 5 are set (&X101110)<A HREF="#.">.</A>
<HR SIZE=3><H2 ID="KEYTEST">KEYTEST</H2>
<A NAME="KEYGET"></A><A NAME="KEYLOOK"></A><B><A HREF="#KEYTEST">KEYTEST</A> n
<A HREF="#KEYGET">KEYGET</A> n
<A HREF="#KEYLOOK">KEYLOOK</A> n</B>

n: <A HREF="#ivar">ivar</A>

<A HREF="#KEYTEST">KEYTEST</A> is similar to <A HREF="#INKEY$">INKEY$</A> and reads a character from the keyboard. If no key
was pressed since the last input (apart from Alternate, Control, Shift, and
Caps Lock) the returned value is zero, otherwise its value corresponds to the
key in the table shown below for <A HREF="#KEYGET">KEYGET</A><A HREF="#.">.</A>

<A HREF="#KEYGET">KEYGET</A> waits for a key to be pressed and then returns a long word value
corresponding to the key. This 32-bit long word is constructed as follows:

    Bits  0- 7: <A HREF="#ASCII">ASCII</A> code
    Bits  8-15: Zero
    Bits 16-23: <A HREF="#Scan">Scan</A> code
    Bits 24-31: Status of Shift, Control, Alternate, and CapsLock as follows:

    <B>Bit  Key</B>
    0    Right shift
    1    Left shift
    2    Control
    3    Alternate
    4    Caps lock

<A HREF="#KEYLOOK">KEYLOOK</A> allows a character to be read from the keyboard buffer, without
changing the buffers contents, as with <A HREF="#KEYGET">KEYGET</A> or <A HREF="#INKEY$">INKEY$</A><A HREF="#.">.</A>

If n is a byte or word variable then an integer conversion takes place
automatically.

<B>Examples:</B>

    <A HREF="#PRINT">PRINT</A> "Please press ESCape"
    <A HREF="#REPEAT">REPEAT</A>                            !The program runs through the loop
    <A HREF="#UNTIL">UNTIL</A> <A HREF="#INKEY$">INKEY$</A><A HREF="#=">=</A><A HREF="#CHR$">CHR$</A>(27)             !until the ESCape key is pressed.
    <A HREF="#'">'</A>
    <A HREF="#PRINT">PRINT</A> "Please press ESCaPe again"
    <A HREF="#REPEAT">REPEAT</A>                            !Again runs through the loop but
      <A HREF="#KEYTEST">KEYTEST</A> n&#124;                      !this time checks the keyboard here for
    <A HREF="#UNTIL">UNTIL</A> n&#124;=27                       !character number 27.

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Waits twice for the ESCape key to be pressed. Note that in the second
    example bits 0 to 7 are masked off automatically by using a byte-sized
    (8-bit) variable.

    <A HREF="#PRINT">PRINT</A> "Please press a key"
    key_1&#124;<A HREF="#=">=</A><A HREF="#INP">INP</A>(2)                    !Waits for a key-press.
    <A HREF="#PRINT">PRINT</A> "Press another key please"
    <A HREF="#KEYGET">KEYGET</A> key_2&#124;                    !Waits again.
    <A HREF="#PRINT">PRINT</A> "<A HREF="#INP">INP</A>(2)<A HREF="#:">:</A> ";key_1&#124;          !The <A HREF="#ASCII">ASCII</A> codes of the depressed
    <A HREF="#PRINT">PRINT</A> "KEYGET: ";key_2&#124;          !keys are printed.

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Waits twice for keys to be pressed, and displays their <A HREF="#ASCII">ASCII</A> codes.

    <A HREF="#REPEAT">REPEAT</A>
      <A HREF="#KEYLOOK">KEYLOOK</A> n%
    <A HREF="#UNTIL">UNTIL</A> n%
    <A HREF="#INPUT">INPUT</A> "Type in something ";a$

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Waits in a loop until a key is pressed, then begins the input of a$ without
    losing the initial character.

    <A HREF="#DO">DO</A>
      <A HREF="#KEYGET">KEYGET</A> a%
      <A HREF="#PRINT">PRINT</A> <A HREF="#HEX$">HEX$</A>(a%,8),<A HREF="#BIN$">BIN$</A>(a%,32),
      <A HREF="#OUT">OUT</A> 5,a%
      <A HREF="#PRINT">PRINT</A>
    <A HREF="#LOOP">LOOP</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Waits for a key to be pressed and displays the value returned by <A HREF="#KEYGET">KEYGET</A> in
    both hexadecimal and binary.

<B>Note:</B> <A HREF="#OUT">OUT</A> 5,a% allows the characters associated with control codes 0-32 to
      be displayed.

Cnecin()<A HREF="#+">+</A> Iorec()+
<HR SIZE=3><H2 ID="KEYPRESS">KEYPRESS</H2>
<B><A HREF="#KEYPRESS">KEYPRESS</A> n</B>

n: <A HREF="#iexp">iexp</A>

The command <A HREF="#KEYPRESS">KEYPRESS</A> simulates the pressing of a key. That is, the character
with the <A HREF="#ASCII">ASCII</A> code contained in the lowest-order 8 bits of n is added to the
keyboard buffer. Additionally, the state of the Control, Shift, and Alternate
keys may be passed in the highest-order byte, as defined by <A HREF="#KEYGET">KEYGET</A><A HREF="#.">.</A> If the
<A HREF="#ASCII">ASCII</A> code given is zero, a scan code may be passed in bits 16 to 23, e.g.
<A HREF="#KEYPRESS">KEYPRESS</A> &H3B0000 presses F1.

<B>Examples:</B>

    <A HREF="#FOR">FOR</A> i&=65 TO 90 !Simulates the pressing
      <A HREF="#KEYPRESS">KEYPRESS</A> i&   !of the keys A-Z <A HREF="#.">.</A>...
    <A HREF="#NEXT">NEXT</A> i&
    <A HREF="#KEYPRESS">KEYPRESS</A> 13     <A HREF="#!">!</A><A HREF="#.">.</A>... followed by a Carriage Return
    <A HREF="#INPUT">INPUT</A> a$        !Characters are taken up to the first Carriage Return
    <A HREF="#PRINT">PRINT</A> a$

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The letters from A to Z are printed.

    <A HREF="#KEYDEF">KEYDEF</A> 1,"Hello"<A HREF="#+">+</A><A HREF="#CHR$">CHR$</A>(13)
    <A HREF="#KEYPRESS">KEYPRESS</A> &H83B0000
    <A HREF="#PAUSE">PAUSE</A> 1
    <A HREF="#LINE_INPUT">LINE INPUT</A> a$
    <A HREF="#PRINT">PRINT</A> a$

<A HREF="#-">-</A>-<A HREF="#&">&</A>#62;A string to be produced by pressing ALT-F1 is defined, then a press of this
   key is simulated, followed by a slight pause to give the associated
   interrupt routine time to process it. The word "Hello" is then taken as the
   inputted a$<A HREF="#.">.</A>

Iorec()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="KEYDEF">KEYDEF</H2>
<B><A HREF="#KEYDEF">KEYDEF</A> n,s$</B>

n: <A HREF="#iexp">iexp</A>
s$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>

The command <A HREF="#KEYDEF">KEYDEF</A> makes it possible to assign an arbitrary character string
(with a maximum length of 31 characters) to the Function Keys. The arithmetic
expression n (with a value from 1 to 20 inclusive) determines the key. A value
of n from 1 to 10 refers to the keys F1 to F10, and from 11 to 20, to the keys
Shift-F1 to Shift-F10. The defined string is available both during the running
of a program and from the <A HREF="#GFA-Basic">GFA-Basic</A> Editor.

However, in the Editor the ALTernate key must also be pressed, as otherwise the
<A HREF="#GFA-Basic">GFA-Basic</A> commands would not be available.

<B>Example:</B>

    <A HREF="#KEYPAD">KEYPAD</A> 16              !Sets ALT key as not required
    <A HREF="#DO">DO</A>
      <A HREF="#KEYDEF">KEYDEF</A> 1,"F1"        !String for F1 key
      <A HREF="#KEYDEF">KEYDEF</A> 11,"Shift+F1" !String for Shift-F1 key
      <A HREF="#INPUT">INPUT</A> x$
    <A HREF="#LOOP">LOOP</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Instead of having to type in a string as the input, pressing F1
    automatically supplies the string 'F1' and pressing Shift-F1 supplies the
    string 'Shift+F1'<A HREF="#.">.</A>

<B>Memo:</B> This command relies on an interrupt and should be avoided.
      If n is over 20 the command exits with no error message.
      If s$ is over 31 characters it gets clipped off.
<HR SIZE=3><H2 ID="Data_Input_and_Output">Data Input and Output</H2>
This section first describes the storing and recalling of constants with <A HREF="#DATA">DATA</A>,
<A HREF="#READ">READ</A>, and <A HREF="#RESTORE">RESTORE</A><A HREF="#.">.</A> Then file management is dealt with starting with the
indexing commands <A HREF="#DIR$">DIR$</A><A HREF="#()">()</A>, <A HREF="#CHDIR">CHDIR</A>, <A HREF="#DIR">DIR</A>, <A HREF="#FILES">FILES</A>, <A HREF="#MKDIR">MKDIR</A>, and <A HREF="#RMDIR">RMDIR</A>, and explaining
the structure of the hierarchical filing system. Next comes the opening,
closing, renaming etc. of files with <A HREF="#EXIST">EXIST</A><A HREF="#()">()</A>, <A HREF="#KILL">KILL</A>, <A HREF="#NAME">NAME</A>, <A HREF="#OPEN">OPEN</A>, and <A HREF="#CLOSE">CLOSE</A>
followed by the facilities for storage of areas of memory with <A HREF="#BLOAD">BLOAD</A>, <A HREF="#BSAVE">BSAVE</A>,
<A HREF="#BGET">BGET</A>, and <A HREF="#BPUT">BPUT</A><A HREF="#.">.</A> Then sequential input and output with <A HREF="#INPUT$">INPUT$</A><A HREF="#()">()</A>, <A HREF="#INPUT_#">INPUT #</A> and
<A HREF="#PRINT_#">PRINT #</A> are covered, together with indexed sequential accessing of files (<A HREF="#SEEK">SEEK</A>,
<A HREF="#RELSEEK">RELSEEK</A>), as well as random accessing (<A HREF="#FIELD">FIELD</A>, <A HREF="#GET_#">GET #</A>, <A HREF="#PUT_#">PUT #</A>, <A HREF="#SEEK">SEEK</A>, RELSEEK)<A HREF="#.">.</A> The
section on peripheral devices describes byte by byte input and output with
<A HREF="#INP()">INP()</A>, <A HREF="#OUT">OUT</A> and their 'query' counterparts <A HREF="#INP?">INP?</A><A HREF="#()">()</A> and <A HREF="#OUT?">OUT?</A>(), and input from the
serial and MIDI interfaces (<A HREF="#INPAUX$">INPAUX$</A>, <A HREF="#INPMID$">INPMID$</A>)<A HREF="#.">.</A>

Finally, the commands are given for the handling of the mouse and joysticks
(<A HREF="#MOUSE">MOUSE</A>, <A HREF="#MOUSEX">MOUSEX</A>, <A HREF="#MOUSEY">MOUSEY</A>, <A HREF="#MOUSEK">MOUSEK</A>, <A HREF="#HIDEM">HIDEM</A>, <A HREF="#SHOWM">SHOWM</A>, <A HREF="#STICK">STICK</A><A HREF="#()">()</A>, <A HREF="#STRIG">STRIG</A>()), and printer
output (<A HREF="#LPRINT">LPRINT</A>, <A HREF="#LPOS">LPOS</A><A HREF="#()">()</A>, <A HREF="#HARDCOPY">HARDCOPY</A>)<A HREF="#.">.</A>
<HR SIZE=3><H2 ID="Data_Commands">Data Commands</H2>
<A NAME="DATA"></A><A NAME="READ"></A><A NAME="RESTORE"></A><A NAME="_DATA"></A><A NAME="_DATA="></A><B><A HREF="#DATA">DATA</A> const [,const1,const2,<A HREF="#.">.</A>..]
<A HREF="#READ">READ</A> var [,var1,var2,<A HREF="#.">.</A>..]
<A HREF="#RESTORE">RESTORE</A> [label]
<A HREF="#_DATA">_DATA</A>
<A HREF="#_DATA=">_DATA=</A> x</B>

const, const1, const2: numerical or string constants
var, var1, var2: <A HREF="#avar">avar</A> or <A HREF="#svar">svar</A>
<A HREF="#label:">label:</A> user-defined label
x: <A HREF="#iexp">iexp</A> (suitable for an address)

<A HREF="#DATA">DATA</A> statements are used to store numeric or string constants which can then be
accessed with <A HREF="#READ">READ</A><A HREF="#.">.</A> Numeric values can be specified in hexadecimal, octal, or
binary form, but string constants must be enclosed in inverted commas if they
contain commas, as commas are normally used to separate items in the <A HREF="#DATA">DATA</A>
statement.

Internally associated with <A HREF="#DATA">DATA</A> and <A HREF="#READ">READ</A> is the so-called data pointer, which
always points to the next item to be <A HREF="#READ">READ</A><A HREF="#.">.</A> When a program is <A HREF="#RUN">RUN</A>, this is the
first item in the first <A HREF="#DATA">DATA</A> statement. The <A HREF="#RESTORE">RESTORE</A> instruction allows the data
pointer to be moved so as to point to any <A HREF="#DATA">DATA</A> statement, provided the DATA
statement is preceded by a label. If no label is specified by <A HREF="#RESTORE">RESTORE</A>, the data
pointer is moved to the first <A HREF="#DATA">DATA</A> statement in the program.

See <A HREF="#GOTO">GOTO</A> for the rules for defining a label.

The variable <A HREF="#_DATA">_DATA</A> returns the position of the <A HREF="#DATA">DATA</A> pointer. _DATA returns 0
if the next <A HREF="#READ">READ</A> would result in an 'out of data' error.

<A HREF="#_DATA=">_DATA=</A> permits the setting of the <A HREF="#DATA">DATA</A> pointer to a value which has been
previously determined with <A HREF="#_DATA">_DATA</A><A HREF="#.">.</A>

Comments cannot be placed behind <A HREF="#DATA">DATA</A> statements.

<B>Examples:</B>

    <A HREF="#FOR">FOR</A> i=1 TO 3
      <A HREF="#READ">READ</A> a
      <A HREF="#PRINT">PRINT</A> a'
    <A HREF="#NEXT">NEXT</A> i
    <A HREF="#'">'</A>
    <A HREF="#RESTORE">RESTORE</A> roman_numbers
    <A HREF="#READ">READ</A> a$,b$,c$,d$
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#PRINT">PRINT</A> a$'b$'c$'d$
    <A HREF="#'">'</A>
    <A HREF="#DATA">DATA</A> 1,2,3,4
    <A HREF="#DATA">DATA</A> a,b,c,d
    <A HREF="#'">'</A>
    roman_numbers:
    <A HREF="#DATA">DATA</A> I,II,III,IV

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> In the loop the numeric values 1, 2, and 3 are read in and printed on the
    screen. After that, by means of <A HREF="#RESTORE">RESTORE</A>, the data pointer is moved to the
    line containing the roman numerals as data. They are also read in and
    printed.

    <A HREF="#DATA">DATA</A> 10,&A,$A,&HA,&O12,&X1010,%1010
    <A HREF="#FOR">FOR</A> i%=1 to 7
      <A HREF="#READ">READ</A> a%
      <A HREF="#PRINT">PRINT</A> a%
    <A HREF="#NEXT">NEXT</A> i%

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The number 10 is read in seven times. Like <A HREF="#INPUT">INPUT</A>, <A HREF="#VAL">VAL</A><A HREF="#()">()</A> etc., <A HREF="#READ">READ</A> can
    interpret Hexadecimal numbers if they are prefixed with <A HREF="#'">'</A><A HREF="#$">$</A>' or '<A HREF="#&H">&H</A>', and
    Binary numbers if they are prefixed with <A HREF="#'">'</A><A HREF="#%">%</A>' or '<A HREF="#&X">&X</A>'<A HREF="#.">.</A>

    <A HREF="#DIM">DIM</A> dp%(100)
    <A HREF="#DATA">DATA</A> 1,2,3,4,5,6,7,8,9
    <A HREF="#DATA">DATA</A> 13,24,328,3242,1,0
    <A HREF="#'">'</A>
    i%=0
    <A HREF="#DO_WHILE">DO WHILE</A> <A HREF="#_DATA">_DATA</A>
      dp%(i%)<A HREF="#=">=</A><A HREF="#_DATA">_DATA</A>
      <A HREF="#INC">INC</A> i%
      <A HREF="#READ">READ</A> a
    <A HREF="#LOOP">LOOP</A>
    <A HREF="#'">'</A>
    <A HREF="#DEC">DEC</A> i%
    <A HREF="#'">'</A>
    <A HREF="#FOR">FOR</A> j%=i% <A HREF="#DOWNTO">DOWNTO</A> 0
      <A HREF="#_DATA">_DATA</A>=dp%(j%)
      <A HREF="#READ">READ</A> a
      <A HREF="#PRINT">PRINT</A> a
    <A HREF="#NEXT">NEXT</A> j%
    <A HREF="#~">~</A><A HREF="#INP">INP</A>(2)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Displays: 0 1 3242 328 24 13 9 8 7 6 5 4 3 2 1
    A key is then waited for.

Note: Using <A HREF="#_DATA">_DATA</A> to detect the 'out of data' state is only useful if you have
      one set of <A HREF="#DATA">DATA</A> statements. If you have more that one set of DATA
      statements used for different purposes, then <A HREF="#_DATA">_DATA</A> cannot be used to
      detect the end of the first set.

<B>Memo:</B> If a string contains a comma or double quotes or spaces on either
      end, the entire string must be enclosed in double quotes.  Certain
      characters cannot be placed in <A HREF="#DATA">DATA</A> statements.  They are <A HREF="#ASCII">ASCII</A> 4, 10,
      and 13.  Example: <A HREF="#DATA">DATA</A> "  spaces, "quotes", and commas in the string  "

      Adding quotes does not increase the size of the compiled binary.

      The <A HREF="#_DATA">_DATA</A> pointer truely is a pointer, as it actually returns the address
      of the item in the <A HREF="#DATA">DATA</A> statement itself.  Thus, this can be done in the
      Editor:

      <A HREF="#DATA">DATA</A> test,this
      <A HREF="#BYTE">BYTE</A>{<A HREF="#_DATA">_DATA</A>}<A HREF="#=">=</A><A HREF="#ASC">ASC</A>("T")
      <A HREF="#READ">READ</A> t$
      <A HREF="#PRINT">PRINT</A> t$

      The word "Test" will appear.
      This will actually change your source code if executed in the Editor!

      When compiled, the commas between data items become nulls which would
      allow the use of <A HREF="#CHAR">CHAR</A><A HREF="#{}">{}</A> to fetch data items.  Thus, this can be done in a
      compiled program:

      <A HREF="#DATA">DATA</A> Hello world,hi
      <A HREF="#PRINT">PRINT</A> <A HREF="#CHAR">CHAR</A>{<A HREF="#_DATA">_DATA</A>}

      The words "Hello world" will appear.

      <A HREF="#_DATA">_DATA</A> seems to work in the interpreter, but I had problems with it in
      compiled programs. I think this is why:

        <A HREF="#RESTORE">RESTORE</A> test
        <A HREF="#READ">READ</A> a$
        <A HREF="#PRINT">PRINT</A> a$<A HREF="#'">'</A><A HREF="#_DATA">_DATA</A>  !interpreter prints 'bug 0' (fails compiled!)
        <A HREF="#EDIT">EDIT</A>
        test:
        <A HREF="#DATA">DATA</A> "bug"

      The editor issues error #72 for <A HREF="#_DATA">_DATA</A>=x if these problems happen:
        <A HREF="#_DATA">_DATA</A>=x and there are no <A HREF="#DATA">DATA</A> statements at all in the listing
        <A HREF="#_DATA">_DATA</A>=x and x is below the first <A HREF="#DATA">DATA</A> statment
        <A HREF="#_DATA">_DATA</A>=x and x is above the last <A HREF="#DATA">DATA</A> statement
      However, it appears as 'Undefined error #72'<A HREF="#.">.</A> It seems Frank forgot to
      include some human readable text for this error code.
      The compiler issues no error and will even allow one to set it to zero.

      If the label used with <A HREF="#RESTORE">RESTORE</A> is undefined, the compiler will not issue
      an error message. Instead the data pointer will be set incorrectly to
      the first data statement in the program.

      Version 2 would issue an error reading strings with unpaired quotes.
      This was changed in version 3 and error code #36 was retired.
      Example____  v2___  v3___
      <A HREF="#DATA">DATA</A> "test"  test   test
      <A HREF="#DATA">DATA</A> "test   error  "test
      <A HREF="#DATA">DATA</A> test"   error  test"
<HR SIZE=3><H2 ID="File_Management">File Management</H2>
In the following section, instructions related to file organisation are
explained.

First, however, it is important to know the structure of a file specification
and the rules of the hierarchical filing system. A file specification consists
of three parts: the drive specification, the file name and the filename
extension. The drive specification contains the disk drive identification in
the range A to P, followed by a colon. The file name is up to 8 characters in
length, with, optionally, an extension comprising a period and up to 3
characters. Groups of files may be gathered into directories (also called
folders), which may themselves be gathered into different sub-directories (or
folders) and so on. The lowest level of grouping (which contains all the files
on the disk in their respective directories and sub-directories) is known as
the root directory. Starting from this root directory, directories may be
accessed, followed by sub-directories, etc. Therefore, for a file to be
accessed, the following information must be given:

    <A HREF="#-">-</A> Drive specification
    <A HREF="#-">-</A> Name of directory if any, sub-directory if any, etc.
    <A HREF="#-">-</A> The actual name of the file and its extension, if any

These parts are separated by reverse diagonal strokes "\" (backslashes)<A HREF="#.">.</A> Names
for directories have the same format as filenames. The access path for a file
is a combination of these elements.

<B>Example:</B>

    A:\<A HREF="#TEXT">TEXT</A>.DOC\MANUAL\CHAPTER1.DOC

This means that the file to be accessed, named CHAPTER1, has the extension .DOC
and is in a sub-directory called MANUAL, which it self is in a sub-directory
called <A HREF="#TEXT">TEXT</A>.DOC. TEXT.DOC is in the root directory of disk drive A:.

Two special symbols are available to make file selection easier, which can be
used within file names and their extensions. These are the question mark (<A HREF="#'">'</A><A HREF="#?">?</A>')
and the asterisk (<A HREF="#'">'</A><A HREF="#*">*</A>')<A HREF="#.">.</A> The question mark acts like a 'wildcard' and will be
accepted as any character whose <A HREF="#ASCII">ASCII</A> value is greater than 32. The asterisk is
similar, except that it can be taken as any sequence of characters in the file
specification.

The command <A HREF="#DIR">DIR</A> will be explained in a moment, but for now, from the Direct
Mode of GFA BASIC (reached by pressing ESCape), you can type in <A HREF="#'">'</A><A HREF="#DIR">DIR</A>', which
will cause all the files on drive A: to be displayed.

Typing <A HREF="#'">'</A><A HREF="#DIR">DIR</A> <A HREF="#*">*</A>.GFA' lists those files which have the extension '.GFA'.

Typing <A HREF="#'">'</A><A HREF="#DIR">DIR</A> ?AB?<A HREF="#.">.</A>*A' lists those files which have four-letter file names with
the middle two letters 'AB', and an extension ending in 'A'<A HREF="#.">.</A>

Typing <A HREF="#'">'</A><A HREF="#DIR">DIR</A> <A HREF="#*">*</A><A HREF="#.">.</A>*' lists all files.

The TOS File System+
<HR SIZE=3><H2 ID="Directory_Handling">Directory Handling</H2>
<A HREF="#DFREE">DFREE</A><A HREF="#()">()</A>
<A HREF="#CHDRIVE">CHDRIVE</A>
<A HREF="#DIR$">DIR$</A><A HREF="#()">()</A>
<A HREF="#CHDIR">CHDIR</A>
<A HREF="#DIR">DIR</A>, <A HREF="#FILES">FILES</A>
<A HREF="#FGETDTA">FGETDTA</A><A HREF="#()">()</A>, <A HREF="#FSETDTA">FSETDTA</A>()
<A HREF="#FSFIRST">FSFIRST</A><A HREF="#()">()</A>, <A HREF="#FSNEXT">FSNEXT</A>()
<A HREF="#MKDIR">MKDIR</A>, <A HREF="#RMDIR">RMDIR</A>
<HR SIZE=3><H2 ID="DFREE">DFREE</H2>
<A NAME="CHDRIVE"></A><A NAME="DIR$"></A><A NAME="CHDIR"></A><B><A HREF="#DFREE">DFREE</A>(n)
<A HREF="#CHDRIVE">CHDRIVE</A> n
<A HREF="#CHDRIVE">CHDRIVE</A> n$
<A HREF="#DIR$">DIR$</A>(n)
<A HREF="#CHDIR">CHDIR</A> name$</B>

n: <A HREF="#iexp">iexp</A>
n$, name$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>

<A HREF="#DFREE">DFREE</A><A HREF="#()">()</A> (disk free) returns the amount of space free for storage on drive n in
bytes. This can take a few seconds, or longer with a partitioned hard disk
drive. See <A HREF="#CHDRIVE">CHDRIVE</A> below for the meaning of the parameter n.

<A HREF="#CHDRIVE">CHDRIVE</A> (Change Drive) sets the default disk drive. This is the drive which is
used by <A HREF="#DIR">DIR</A> etc. if no other drive is specified. Any drive can be made the
default drive with <A HREF="#CHDRIVE">CHDRIVE</A> followed by the drive number from 0 to 16. Drive 0
corresponds to the current default drive, drive 1 corresponds to A:, drive 2 to
B:, etc. The argument of <A HREF="#CHDRIVE">CHDRIVE</A> may also be a string, in which case the first
character (from A to P) identifies the drive.

<A HREF="#DIR$">DIR$</A>(n) returns as a string the current access path for drive n, as set with
<A HREF="#CHDIR">CHDIR</A> below. See <A HREF="#CHDRIVE">CHDRIVE</A> above for the meaning of the parameter n.

<A HREF="#CHDIR">CHDIR</A> sets the current directory. Since the default drive cannot be changed
with <A HREF="#CHDIR">CHDIR</A>, the specified directory must be on the current default drive or a
specified drive.

So, after <A HREF="#CHDIR">CHDIR</A> "B:\TEST", the directory TEST on drive B: becomes the current
directory, which may be accessed without the need to specify the path
'B:\TEST'<A HREF="#.">.</A> With <A HREF="#CHDIR">CHDIR</A> "\", one can return to the root directory from any
sub-directory. The directory required is always looked for as a sub-directory
of the current directory. Thus if, after making B:TEST the current directory as
above, one issued the command <A HREF="#CHDIR">CHDIR</A> "TEST2", the effective path from the root
directory would be B:\TEST\TEST2.

There are two special folder names: <A HREF="#'">'</A><A HREF="#.">.</A>' aud '..', which are shorthand ways of
referring to the 'current' directory path and the 'parent' directory path
respectively. The parent path is that which leads up to, but does not include,
the current directory. For instance, with the path 'B:\TEST\TEST2' above, the
parent path is 'B:\TEST'<A HREF="#.">.</A> Thus to change the current directory to another on
the same level, perhaps TEST2A, it is only necessary to type <A HREF="#CHDIR">CHDIR</A> "<A HREF="#.">.</A>.\TEST2A".

<B>Examples:</B>

    <A HREF="#CHDRIVE">CHDRIVE</A> 1
    <A HREF="#PRINT">PRINT</A> <A HREF="#DFREE">DFREE</A>(0)
    <A HREF="#PRINT">PRINT</A> <A HREF="#DIR$">DIR$</A>(2)
    <A HREF="#CHDRIVE">CHDRIVE</A> "<A HREF="#C:">C:</A>\"

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Disk drive A: is selected as the current default drive, and its free
    storage capacity is printed. Then the current access path for drive B:  is
    printed, and finally drive <A HREF="#C:">C:</A> is made the current default drive.

    <A HREF="#CHDIR">CHDIR</A> "\"
    <A HREF="#CHDIR">CHDIR</A> "<A HREF="#TEXT">TEXT</A>.DOC\MANUAL"
    <A HREF="#CHDIR">CHDIR</A> "APPENDIX"

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> <A HREF="#CHDIR">CHDIR</A> "\" sets the current directory to be the root directory of the
    current drive. In the second line MANUAL, which is a sub-directory of the
    sub-directory <A HREF="#TEXT">TEXT</A>.DOC, is made the current directory. In the third line a
    further sub-directory APPENDIX is made the current directory, so that the
    access path is now \<A HREF="#TEXT">TEXT</A>.DOC\MANUAL\APPENDIX.

<B>Memo:</B> <A HREF="#DFREE">DFREE</A><A HREF="#()">()</A> will fail on large capacity drives, internally it uses word
      values. Call <A HREF="#GEMDOS">GEMDOS</A>(54) directly to get a more accurate value. Due the
      limits of a long%, drives larger than 2gb are still a problem.

      <A HREF="#DIR$">DIR$</A><A HREF="#()">()</A> does not report invalid drive identifiers.

Dfree()<A HREF="#+">+</A>, Dsetdrv()+, Dgetpath()+, Dsetpath()+
<HR SIZE=3><H2 ID="DIR">DIR</H2>
<A NAME="FILES"></A><B><A HREF="#DIR">DIR</A> [p$ [TO name$]]
<A HREF="#FILES">FILES</A> [p$ [TO name$]]</B>

p$, name$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>

The instructions <A HREF="#DIR">DIR</A> and <A HREF="#FILES">FILES</A> allow directories to be printed out, or sent to
a specified device or file with 'TO name$'<A HREF="#.">.</A> If no device is specified, the
output goes to the screen. The desired access path and file mask (e.g. <A HREF="#*">*</A>.*) is
specified in the expression p$<A HREF="#.">.</A> <A HREF="#FILES">FILES</A> is very similar to <A HREF="#DIR">DIR</A>, with the
difference that it also provides information on the length, time and date of
the listed files, and will also list folder names, identified by a <A HREF="#'">'</A><A HREF="#*">*</A>' prefix,
if they fulfill the conditions of the file mask.

If parameter p$ is omitted, the current default drive/directory will be
assumed.

If p$ ends in <A HREF="#'">'</A>\', with no file mask, the mask '<A HREF="#*">*</A><A HREF="#.">.</A>*' will be added
automatically by default.

With the optional extra 'TO name$' the directory information can be sent to a
peripheral device or to a file. In this case name$ must contain the device
identifier (e.g. "<A HREF="#LST:">LST:</A>") or a file specification (e.g. "A:\CONTENTS.LST").

<B>Examples:</B>

    <A HREF="#DIR">DIR</A> "A:\BOOKS\<A HREF="#*">*</A>.DOC"

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> All files with the extension .DOC in the folder BOOKS on drive A: are
    listed on the screen.

    <A HREF="#DIR">DIR</A> "A:\BOOKS\MANUAL\<A HREF="#*">*</A>.DOC" TO "B:\MANUAL\CONTENTS.<A HREF="#ASC">ASC</A>"

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The list of files ending in .DOC in the folder MANUAL, which itself is
    found in the folder BOOKS, is sent to the file CONTENTS.<A HREF="#ASC">ASC</A> in the folder
    MANUAL on drive B:.

    <A HREF="#DIR">DIR</A> "A:\<A HREF="#*">*</A><A HREF="#.">.</A>*" TO "<A HREF="#PRN:">PRN:</A>"

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> All the files on drive A: are listed on the printer.

    <A HREF="#FILES">FILES</A> "A:\<A HREF="#*">*</A>.DOC" TO "<A HREF="#LST:">LST:</A>"

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> All the files on drive A: which have the extension .DOC are listed on the
    printer.

<B>Memo:</B> See section <A HREF="#'">'</A><A HREF="#The_Modifier_Keys">The Modifier Keys</A>'<A HREF="#.">.</A>

      Internally channel #87 is used if the 'TO' parameter is specified.
      This could cause a conflict if channel #87 is already in use.
<HR SIZE=3><H2 ID="FGETDTA">FGETDTA</H2>
<A NAME="FSETDTA"></A><A NAME="DTA"></A><B><A HREF="#FGETDTA">FGETDTA</A><A HREF="#()">()</A>
<A HREF="#FSETDTA">FSETDTA</A>(addr)</B>

addr: <A HREF="#iexp">iexp</A>

The <A HREF="#DTA">DTA</A> (disk transfer address) can be read with the function <A HREF="#FGETDTA">FGETDTA</A><A HREF="#()">()</A> or set
with the instruction <A HREF="#FSETDTA">FSETDTA</A><A HREF="#()">()</A><A HREF="#.">.</A> The default address of the <A HREF="#DTA">DTA</A> is <A HREF="#BASEPAGE">BASEPAGE</A>+128
when a program frist starts up. The <A HREF="#DTA">DTA</A> address will be reset back to
<A HREF="#BASEPAGE">BASEPAGE</A>+128 if the commands <A HREF="#DIR">DIR</A> or <A HREF="#FILES">FILES</A> are used. <A HREF="#EXIST">EXIST</A><A HREF="#()">()</A> does not reset the
<A HREF="#DTA">DTA</A> address.

The <A HREF="#DTA">DTA</A> has the following structure:

    <B>Offset  Bytes  Meaning</B>
     0      21     Reserved for <A HREF="#GEMDOS">GEMDOS</A><A HREF="#()">()</A>
    21       1     File attributes (see below)
    22       2     Time
    24       2     Date
    26       4     File length
    30      14     File name terminated with null byte, without blanks

<B>Memo:</B> The <A HREF="#DTA">DTA</A> structure is exactly 44 bytes.
      A call to <A HREF="#FSETDTA">FSETDTA</A><A HREF="#()">()</A> will change entry <A HREF="#BASEPAGE">BASEPAGE</A>+32.
      Original manual stated: The <A HREF="#DTA">DTA</A> address is changed when a File Select
      Box is used. This not true.
      The commands <A HREF="#FSFIRST">FSFIRST</A><A HREF="#()">()</A> and <A HREF="#FSNEXT">FSNEXT</A>() use the <A HREF="#DTA">DTA</A> address.

Fgetdta()<A HREF="#+">+</A>, Fsetdta()+, <A HREF="#DTA">DTA</A>+
<HR SIZE=3><H2 ID="FSFIRST">FSFIRST</H2>
<A NAME="FSNEXT"></A><B><A HREF="#FSFIRST">FSFIRST</A>(p$,attr)
<A HREF="#FSNEXT">FSNEXT</A><A HREF="#()">()</A></B>

p$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>
attr: <A HREF="#iexp">iexp</A>

The function <A HREF="#FSFIRST">FSFIRST</A><A HREF="#()">()</A> searches for the first file on a disk to fulfill the
criteria specified in p$ (e.g. "<A HREF="#C:">C:</A>\<A HREF="#*">*</A>.GFA"). If such a file is found, the file
name, together with other information, is written into the <A HREF="#DTA">DTA</A> (see <A HREF="#FGETDTA">FGETDTA</A><A HREF="#()">()</A>
and <A HREF="#FSETDTA">FSETDTA</A><A HREF="#()">()</A>)<A HREF="#.">.</A> The parameter attr contains the file attributes which the file
to be found may have; for instance, it is possible to seareh for hidden files
(bit 1) or folders (bit 4)<A HREF="#.">.</A>

The function <A HREF="#FSNEXT">FSNEXT</A><A HREF="#()">()</A> searches for the next file which fulfills the conditions
of <A HREF="#FSFIRST">FSFIRST</A><A HREF="#()">()</A><A HREF="#.">.</A>

The meaning of the attribute bits:

    <B>Bit  Meaning</B> (if the bit is =1)
    0    The file is write protected
    1    The file is hidden (excluded from <A HREF="#DIR">DIR</A> search)
    2    The file is a System file (excluded from <A HREF="#DIR">DIR</A> search)
    3    Disk label
    4    Folder (sub-directory)
    5    Archive bit

<B>Example:</B>

    <A HREF="#~">~</A><A HREF="#FSETDTA">FSETDTA</A>(<A HREF="#BASEPAGE">BASEPAGE</A>+128)            !Set the <A HREF="#DTA">DTA</A>
    e%<A HREF="#=">=</A><A HREF="#FSFIRST">FSFIRST</A>("\<A HREF="#*">*</A>.GFA",-1)           !Set search criteria (-1 = all bits set)
    <A HREF="#DO_UNTIL">DO UNTIL</A> e%
      <A HREF="#IF">IF</A> <A HREF="#BYTE">BYTE</A>{<A HREF="#BASEPAGE">BASEPAGE</A>+149} <A HREF="#AND">AND</A> 16    !If it is a folder
        <A HREF="#PRINT">PRINT</A> "<A HREF="#*">*</A>"<A HREF="#;">;</A><A HREF="#CHAR">CHAR</A>{<A HREF="#BASEPAGE">BASEPAGE</A>+158}, !indicate by a star
      <A HREF="#ELSE">ELSE</A>                            !otherwise
        <A HREF="#PRINT">PRINT</A> <A HREF="#'">'</A><A HREF="#CHAR">CHAR</A>{<A HREF="#BASEPAGE">BASEPAGE</A>+158},    !a space before the file name
      <A HREF="#ENDIF">ENDIF</A>
      e%<A HREF="#=">=</A><A HREF="#FSNEXT">FSNEXT</A><A HREF="#()">()</A>                     !Continue search
    <A HREF="#LOOP">LOOP</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Displays all files with the extension .GFA from the current directory on
    the screen, as well as all folder names with that extension, indicated with
    the prefix <A HREF="#'">'</A><A HREF="#*">*</A>'<A HREF="#.">.</A>

<B>Memo:</B> This will fail:
      e%<A HREF="#=">=</A><A HREF="#FSFIRST">FSFIRST</A>(p$,attr&)
      <A HREF="#DO_UNTIL">DO UNTIL</A> e%
        f$<A HREF="#=">=</A><A HREF="#CHAR">CHAR</A>{<A HREF="#BASEPAGE">BASEPAGE</A>+128+30}
        <A HREF="#IF">IF</A> <A HREF="#EXIST">EXIST</A>(f$)
          <A HREF="#'">'</A> <A HREF="#EXIST">EXIST</A><A HREF="#()">()</A> calls <A HREF="#FSFIRST">FSFIRST</A>() internally and breaks the search criteria!
        <A HREF="#ENDIF">ENDIF</A>
        e%<A HREF="#=">=</A><A HREF="#FSNEXT">FSNEXT</A><A HREF="#()">()</A>
      <A HREF="#LOOP">LOOP</A>

Fsfirst()<A HREF="#+">+</A>, Fsnext()+
<HR SIZE=3><H2 ID="MKDIR">MKDIR</H2>
<A NAME="RMDIR"></A><B><A HREF="#MKDIR">MKDIR</A> name$
<A HREF="#RMDIR">RMDIR</A> name$</B>

name$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>

The instruction <A HREF="#MKDIR">MKDIR</A> (make directory) puts a new directory (folder) on the
disk. The expression name$ contains the associated access path.

The instruction <A HREF="#RMDIR">RMDIR</A> (remove directory) deletes a directory, provided,
however, that it is empty (i.e. contains no files or sub-directories). The
expression name$ contains the associated access path.

<B>Example:</B>

    <A HREF="#MKDIR">MKDIR</A> "A:\PROGS"
    <A HREF="#RMDIR">RMDIR</A> "A:\PROGS"

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The directory "PROGS" is created on drive A:, then deleted.

Dcreate()<A HREF="#+">+</A>, Ddelete()+
<HR SIZE=3><H2 ID="Files">Files</H2>
<A HREF="#EXIST">EXIST</A><A HREF="#()">()</A>
<A HREF="#OPEN">OPEN</A>, <A HREF="#CLOSE">CLOSE</A>
<A HREF="#LOF">LOF</A><A HREF="#()">()</A>, <A HREF="#LOC">LOC</A>(), <A HREF="#EOF">EOF</A>()
<A HREF="#TOUCH">TOUCH</A>
<A HREF="#NAME">NAME</A> (<A HREF="#RENAME">RENAME</A>)
<A HREF="#KILL">KILL</A>
<A HREF="#BLOAD">BLOAD</A>, <A HREF="#BSAVE">BSAVE</A>
<A HREF="#BGET">BGET</A>, <A HREF="#BPUT">BPUT</A>
<HR SIZE=3><H2 ID="EXIST">EXIST</H2>
<B><A HREF="#EXIST">EXIST</A>(name$)</B>

name$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>

By means of <A HREF="#EXIST">EXIST</A><A HREF="#()">()</A> one can determine whether a given file exists on a disk.
The parameter name$ conatins the access path and the file name. The funcition
returns the value <A HREF="#TRUE">TRUE</A> (-1), if the file exists, or <A HREF="#FALSE">FALSE</A> (0) if not.

<B>Example:</B>

    <A HREF="#OPEN">OPEN</A> "O", #1,"TEST.TXT"
    <A HREF="#PRINT">PRINT</A> #1,"EXAMPLE"
    <A HREF="#CLOSE">CLOSE</A> #1
    <A HREF="#PRINT">PRINT</A> <A HREF="#EXIST">EXIST</A>("TEST.TXT")
    <A HREF="#PRINT">PRINT</A> <A HREF="#EXIST">EXIST</A>("TEST.DOC")

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The file TEST.TXT is opened, some sample text is put in it, and the file is
    closed again. The value -1 (<A HREF="#TRUE">TRUE</A>) is the printed, followed by 0 (<A HREF="#FALSE">FALSE</A>), as
    the file TEST.DOC does not exist.

Also see: <A HREF="#FSFIRST">FSFIRST</A><A HREF="#()">()</A>, <A HREF="#FSNEXT">FSNEXT</A>()<A HREF="#.">.</A>

<B>Memo:</B> The <A HREF="#EXIST">EXIST</A><A HREF="#()">()</A> function seems to cause problems in desk <A HREF="#accessories">accessories</A><A HREF="#.">.</A>
      <A HREF="#EXIST">EXIST</A><A HREF="#()">()</A> seems to cause a system crash if you attempt to change the
      resolution after it has been called at least once in a program. The
      <A HREF="#EXIST">EXIST</A><A HREF="#()">()</A> function ruins the command line. Either fetch the command line
      before using <A HREF="#EXIST">EXIST</A><A HREF="#()">()</A> or don't use EXIST(), instead call <A HREF="#GEMDOS">GEMDOS</A>()
      directly.  Commands such as <A HREF="#FILES">FILES</A>, <A HREF="#DIR">DIR</A>, and <A HREF="#FILESELECT">FILESELECT</A> also clobber the
      command line.

      Does not work well with long file names. Use fattrib() instead.

Fattrib()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="OPEN">OPEN</H2>
<B><A HREF="#OPEN">OPEN</A> mode$,#n,name$[,len]</B>
<A NAME="LST:"></A><A NAME="AUX:"></A><A NAME="CON:"></A><A NAME="MID:"></A><A NAME="IKB:"></A><A NAME="VID:"></A><A NAME="PRN:"></A><A NAME="LPT:"></A><A NAME="COM:"></A><A NAME="STD:"></A>
mode$, name$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>
n, len: <A HREF="#iexp">iexp</A>

<A HREF="#OPEN">OPEN</A> opens a data channel to a file or to a peripheral device. The expression
mode$ sets one of the following access modes:

<B>mode$              Description</B>
O  output          A file is opened to receive data. If neccessary the file
                   will be created, or, if the file already exists its contents
                   will be deleted.

I  input           A file is opened for reading.

A  append          An existing file is opened, and the data pointer set to the
                   end of the file. Data output to the file will then be added
                   at that point.

U  update          An existing file is opened for reading and writing.

R  random access   A <A HREF="#Random_Access">Random Access</A> file is opened for reading and writing.
                   This file type is described fully later.

The numerical expression n contains the channel number and can take a value
from 0 to 99. This channel number must be specified when working with the file.
The <A HREF="#'">'</A><A HREF="##">#</A>' sign before the channel number can be omitted, as the Editor will
supply it anyway. The expression name$ contains the access path and the file
name of the required file.

Instead of a file name, a peripheral device can be specified. The numerical
expression len is only used with the <A HREF="#Random_Access">Random Access</A> mode and defines the length
of a data record. The maximum record length is 32767 bytes, and the maximum
number of fields approximately 5000.

The following device names can be used:

<B>name$                                      Device              Internal use</B>
<A HREF="#LST:">LST:</A> List                                  Printer (parallel)  <A HREF="#BIOS">BIOS</A> 0
<A HREF="#AUX:">AUX:</A> Auxiliary                             Serial (RS232)      <A HREF="#BIOS">BIOS</A> 1
<A HREF="#CON:">CON:</A> Console                               Keyboard/Screen     <A HREF="#BIOS">BIOS</A> 2 or <A HREF="#VDI">VDI</A>
<A HREF="#MID:">MID:</A> Musical Instrument Digital Interface  MIDI port           <A HREF="#BIOS">BIOS</A> 3
<A HREF="#IKB:">IKB:</A> Intelligent KeyBoarD controller       Keyboard processor  <A HREF="#BIOS">BIOS</A> 4
<A HREF="#VID:">VID:</A> Video                                 Monitor             <A HREF="#BIOS">BIOS</A> 5 or <A HREF="#VDI">VDI</A>
<A HREF="#PRN:">PRN:</A> Printer                               Printer             <A HREF="#GEMDOS">GEMDOS</A> -3
<A HREF="#STD:">STD:</A> Console (stdin/stdout)                Keyboard/Screen     <A HREF="#GEMDOS">GEMDOS</A> 1

<A HREF="#LPT:">LPT:</A> same as <A HREF="#PRN:">PRN:</A>
<A HREF="#COM:">COM:</A> same as <A HREF="#AUX:">AUX:</A>

<B>Example:</B>

    <A HREF="#OPEN">OPEN</A> "O", #1,"TEST.TXT" !send data to a file

    or

    <A HREF="#OPEN">OPEN</A> "O", #1,"<A HREF="#PRN:">PRN:</A>" !send data to the printer

<B>Memo:</B> From BUGFIXED.TXT from my master disk:
      There is a new device called <A HREF="#'">'</A><A HREF="#STD:">STD:</A>'<A HREF="#.">.</A> This is the same as 'stdin' and
      'stdout' respectively in C-programs. A shell can be used to redirect the
      output of a GFA-BASIC program.

          GFABASIC TEST <A HREF="#&">&</A>#62;DUMMY

      This line starts GFA-BASIC and the program TEST.GFA. Any output via
      <A HREF="#'">'</A><A HREF="#STD:">STD:</A>' is redirected to the file DUMMY.

      IMPORTANT: Control-C will cause termination of the program if pressed
      while reading/writing file DUMMY. The default for input/output is the
      keyboard/console.

      Only the first character of the mode$ parameter matters. The length is
      not checked at all.

      Device numbers <A HREF="#=">=</A><A HREF="#&">&</A>#62;6 are not supported by the <A HREF="#OPEN">OPEN</A> command.
      To access such devices, use Operating System calls instead.

      Device <A HREF="#PRN:">PRN:</A> does not work correctly on the Falcon030.
      Internally GFA uses <A HREF="#GEMDOS">GEMDOS</A> handle -3, which should of been handle 3.

Fopen()<A HREF="#+">+</A>, Fcreate()+, The IKBD Controller+, IKBD command codes+
<HR SIZE=3><H2 ID="CLOSE">CLOSE</H2>
<A NAME="LOF"></A><A NAME="LOC"></A><A NAME="EOF"></A><A NAME="TOUCH"></A><B><A HREF="#LOF">LOF</A>(#n)
<A HREF="#LOC">LOC</A>(#n)
<A HREF="#EOF">EOF</A>(#n)
<A HREF="#CLOSE">CLOSE</A> [#n]
<A HREF="#TOUCH">TOUCH</A> [<A HREF="##">#</A>]n</B>

n: <A HREF="#iexp">iexp</A>

The numerical expression n refers to the channel number previously specified
with <A HREF="#OPEN">OPEN</A><A HREF="#.">.</A>

<A HREF="#LOF">LOF</A><A HREF="#()">()</A> (length of file) returns the length of a file in bytes.

<A HREF="#LOC">LOC</A><A HREF="#()">()</A> (location) returns the current position of the data pointer measured in
bytes from the beginning of the file. (where <A HREF="#LOC">LOC</A><A HREF="#()">()</A> returns zero). See also
<A HREF="#SEEK">SEEK</A><A HREF="#.">.</A>

<A HREF="#EOF">EOF</A><A HREF="#()">()</A> (end of file) determines whether the data pointer points to the end of a
file (or the whole file has been read)<A HREF="#.">.</A> If the data pointer does point to the
end of the file, <A HREF="#TRUE">TRUE</A> (-1) is returned, otherwise <A HREF="#FALSE">FALSE</A> (0)<A HREF="#.">.</A>

<A HREF="#CLOSE">CLOSE</A> closes a data channel to a file or peripheral device previously opened
with <A HREF="#OPEN">OPEN</A><A HREF="#.">.</A> The numerical expression n contains the number of the channel to be
closed. If the channel number is omitted, all open files are closed.

<A HREF="#TOUCH">TOUCH</A> updates the date and time stamps of a file, giving it the current system
date and time.

<B>Examples:</B>

    <A HREF="#OPEN">OPEN</A> "o",#1,"TEST.TXT"
    <A HREF="#FOR">FOR</A> i%=1 to 20
      <A HREF="#PRINT">PRINT</A> #1,<A HREF="#STR$">STR$</A>(i%)
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#CLOSE">CLOSE</A> #1
    <A HREF="#FILES">FILES</A> "TEST.TXT"
    <A HREF="#DELAY">DELAY</A> 20               <A HREF="#!">!</A> Wait 20 seconds
    <A HREF="#OPEN">OPEN</A> "u",#1,"TEST.TXT"
    <A HREF="#TOUCH">TOUCH</A> #1
    <A HREF="#CLOSE">CLOSE</A> #1
    <A HREF="#FILES">FILES</A> "TEST.TXT"

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> In the example the file TEST.TXT is opened, written to, and closed. Then
    the file information is displayed, including the time and date. Twenty
    seconds later the file is opened again, the date and time updated, then
    closed. The file information is displayed again.

    <A HREF="#OPEN">OPEN</A> "i",#1,"TEST.TXT"
    <A HREF="#PRINT">PRINT</A> "file length: "<A HREF="#;">;</A><A HREF="#LOF">LOF</A>(#1)
    <A HREF="#PRINT">PRINT</A>
    <A HREF="#PRINT">PRINT</A> "data","position of the data pointer"
    <A HREF="#DO_UNTIL">DO UNTIL</A> <A HREF="#EOF">EOF</A>(#1)
      <A HREF="#INPUT">INPUT</A> #1,a$
      <A HREF="#PRINT">PRINT</A> "";a$,<A HREF="#LOC">LOC</A>(#1)
    <A HREF="#LOOP">LOOP</A>
    <A HREF="#CLOSE">CLOSE</A> #1

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The example opens the file from the previous example for reading.  First
    the length of the file is displayed by means of <A HREF="#LOF">LOF</A><A HREF="#()">()</A><A HREF="#.">.</A> Then the contents of
    the file are displayed along with the associated data pointer position
    until the termination condition of the loop is met when <A HREF="#EOF">EOF</A><A HREF="#()">()</A> is <A HREF="#TRUE">TRUE</A><A HREF="#.">.</A>

<B>Memo:</B> <A HREF="#TOUCH">TOUCH</A> does not issue an error if the #channel is wrong.
      <A HREF="#TOUCH">TOUCH</A> doesn't work in the editor or compiled, just does nothing.
      <A HREF="#CLOSE">CLOSE</A> #n does not issue an error if the #channel is wrong.
      <A HREF="#EOF">EOF</A><A HREF="#()">()</A>, <A HREF="#LOC">LOC</A>(), and <A HREF="#LOF">LOF</A>() don't issue errors if the #channel is wrong.

Fclose()<A HREF="#+">+</A>, Fdatime()+
<HR SIZE=3><H2 ID="NAME">NAME</H2>
<A NAME="RENAME"></A><A NAME="KILL"></A><B><A HREF="#NAME">NAME</A> old$ AS new$
<A HREF="#RENAME">RENAME</A> old$ AS new$
<A HREF="#KILL">KILL</A> name$</B>

old$, new$, name$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>

<A HREF="#NAME">NAME</A> gives the file specified in old$ the new name specified in new$<A HREF="#.">.</A> The
contents of the file is not changed. Of course, old$ and new$ must refer to the
same disk drive in their file specifications. <A HREF="#NAME">NAME</A> and <A HREF="#RENAME">RENAME</A> are synonymous.

<A HREF="#KILL">KILL</A> deletes the file specified in the expression "name$"<A HREF="#.">.</A>

<B>Example:</B>

    <A HREF="#OPEN">OPEN</A> "o",#1,"TEST.TXT"
    <A HREF="#PRINT">PRINT</A> #1, "example"
    <A HREF="#CLOSE">CLOSE</A> #1
    <A HREF="#'">'</A>
    <A HREF="#NAME">NAME</A> "TEST.TXT" AS "EXAMPLE.TST"
    <A HREF="#DIR">DIR</A>
    <A HREF="#KILL">KILL</A> "EXAMPLE.TST"
    <A HREF="#DIR">DIR</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The file TEST.TXT is opened and some sample data written to it. It is then
    renamed as EXAMPLE.TST and the directory displayed to show its presence.
    EXAMPLE.TST is then deleted and the directory displayed again, this time to
    show its absence.

Frename()<A HREF="#+">+</A>, Fdelete()+
<HR SIZE=3><H2 ID="BLOAD">BLOAD</H2>
<A NAME="BSAVE"></A><A NAME="BGET"></A><A NAME="BPUT"></A><B><A HREF="#BLOAD">BLOAD</A> name$[,addr]
<A HREF="#BSAVE">BSAVE</A> name$,addr,count
<A HREF="#BGET">BGET</A> #n,addr,count
<A HREF="#BPUT">BPUT</A> #n,addr,count</B>

name$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>
n, addr, count: <A HREF="#aexp">aexp</A>

With <A HREF="#BSAVE">BSAVE</A> an area of memory can be stored on disk (or RAM-disk, hard disk
drive etc.), and loaded again e.g. with <A HREF="#BLOAD">BLOAD</A>. The numerical expression addr
specifies the address of the first byte of the area to be saved, or, with
<A HREF="#BLOAD">BLOAD</A>, the address where the data from disk is to be put. If no address is
specified with <A HREF="#BLOAD">BLOAD</A>, the address that was specified with <A HREF="#BSAVE">BSAVE</A> when the area
was saved will be used. <A HREF="#BSAVE">BSAVE</A> must also specify the number of bytes to be
saved. The parameter name$ is the file specification of the file to which the
area is to be saved, or from which it is to be loaded. See the beginning of
"<A HREF="#File_Management">File Management</A>" for details of the specification. <A HREF="#BSAVE">BSAVE</A> and <A HREF="#BLOAD">BLOAD</A> always use
a whole file.

<A HREF="#BGET">BGET</A> reads from channel 'n', the number of bytes 'count', and places the data
at address 'addr'<A HREF="#.">.</A>  <A HREF="#BPUT">BPUT</A> writes to channel 'n', the number of bytes 'count',
starting at address 'addr'<A HREF="#.">.</A> <A HREF="#BGET">BGET</A> and <A HREF="#BPUT">BPUT</A> access a file via its channel number
n, so it is possible to use <A HREF="#BGET">BGET</A> and <A HREF="#BPUT">BPUT</A> to save or load parts of a file.

<B>Examples:</B>

    <A HREF="#DEFFILL">DEFFILL</A> 1,2,4
    <A HREF="#PBOX">PBOX</A> 100,100,200,200
    <A HREF="#BSAVE">BSAVE</A> "RECTANG.PIC",<A HREF="#XBIOS">XBIOS</A>(2),32000 !XBIOS(2) gives screen address
    <A HREF="#CLS">CLS</A>
    <A HREF="#PRINT_AT">PRINT AT</A>(4,20)<A HREF="#;">;</A>"Picture stored. Press a key"
    <A HREF="#~">~</A><A HREF="#INP">INP</A>(2)
    <A HREF="#CLS">CLS</A>
    <A HREF="#BLOAD">BLOAD</A> "RECTANG.PIC"

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Draws a rectangle and stores the screen under the name "RECTANG.PIC". An
    appropriate message is displayed, and, after a key has been pressed, the
    file is re-loaded, again to the screen memory area.

    <A HREF="#DEFFILL">DEFFILL</A> 1,2,4
    <A HREF="#PBOX">PBOX</A> 0,0,639,199
    <A HREF="#DEFFILL">DEFFILL</A> 1,2,2
    <A HREF="#PBOX">PBOX</A> 0,200,639,399
    <A HREF="#DEFTEXT">DEFTEXT</A> 1,0,0,32
    <A HREF="#TEXT">TEXT</A> 10,115,"the upper half"
    <A HREF="#TEXT">TEXT</A> 10,315,"the lower half"
    <A HREF="#'">'</A>
    <A HREF="#OPEN">OPEN</A> "o", #1,"SCREEN.PIC"
    <A HREF="#BPUT">BPUT</A> #1,<A HREF="#XBIOS">XBIOS</A>(2),32000
    <A HREF="#CLOSE">CLOSE</A> #1
    <A HREF="#PAUSE">PAUSE</A> 25
    <A HREF="#CLS">CLS</A>
    <A HREF="#'">'</A>
    <A HREF="#OPEN">OPEN</A> "i",#1,"SCREEN.PIC"
    <A HREF="#BGET">BGET</A> #1,<A HREF="#XBIOS">XBIOS</A>(2)+16000,16000
    <A HREF="#BGET">BGET</A> #1,<A HREF="#XBIOS">XBIOS</A>(2),16000
    <A HREF="#CLOSE">CLOSE</A> #1

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The upper half of the screen is filled with one pattern, the lower half
    with another, and appropriate messages are put in each half. Then the
    entire screen is saved into the file SCREEN.PIC. After a pause, the first
    half of the file is loaded into the bottom half of the screen, and the
    second half of the file is loaded into the top half of the screen.

Fread()<A HREF="#+">+</A>, Fwrite()+

<B>Memo:</B> <A HREF="#BSAVE">BSAVE</A> does not actually save the address of the memory block into
      the file. <A HREF="#BLOAD">BLOAD</A> attempts to load the block at the last address used in
      the last <A HREF="#BSAVE">BSAVE</A> command that was executed with in the same program if no
      address is speficied. Internally GFA uses channel #89 to perform
      BSAVE/BLOAD. Conflicts can occur if you use this channel and leave it
      open and then call <A HREF="#BSAVE">BSAVE</A> or <A HREF="#BLOAD">BLOAD</A><A HREF="#.">.</A>  The result is an error #22.

      <A HREF="#BLOAD">BLOAD</A> is not allowed on devices. The result is an error <A HREF="##">#</A>-1.
<HR SIZE=3><H2 ID="Sequential_Access">Sequential Access</H2>
<A HREF="#INP">INP</A>(<A HREF="##">#</A>), <A HREF="#INP&">INP&</A>(#), <A HREF="#INP%">INP%</A>(#)
<A HREF="#OUT_#">OUT #</A>, <A HREF="#OUT&_#">OUT& #</A>, <A HREF="#OUT%_#">OUT% #</A>
<A HREF="#INPUT$">INPUT$</A><A HREF="#()">()</A>
<A HREF="#INPUT_#">INPUT #</A>
<A HREF="#LINE_INPUT_#">LINE INPUT #</A>
<A HREF="#PRINT_#">PRINT #</A>
<A HREF="#PRINT_#_USING">PRINT # USING</A>
<A HREF="#WRITE_#">WRITE #</A>
<A HREF="#STORE">STORE</A>, <A HREF="#RECALL">RECALL</A>
<A HREF="#SEEK">SEEK</A>, <A HREF="#RELSEEK">RELSEEK</A>
<HR SIZE=3><H2 ID="INP">INP</H2>
<A NAME="INP&"></A><A NAME="INP%"></A><A NAME="OUT_#"></A><A NAME="OUT&_#"></A><A NAME="OUT%_#"></A><B><A HREF="#INP">INP</A>(#n)
<A HREF="#INP&">INP&</A>(#n)
<A HREF="#INP%">INP%</A>(#n)
<A HREF="#OUT">OUT</A> #n,a[,b,c,<A HREF="#.">.</A>..]
<A HREF="#OUT&">OUT&</A> #n,a[,b,c,<A HREF="#.">.</A>..]
<A HREF="#OUT%">OUT%</A> #n,a[,b,c,<A HREF="#.">.</A>..]</B>

n: <A HREF="#iexp">iexp</A>

<A HREF="#INP">INP</A>(#n) reads a byte from a file which has been previously opened with <A HREF="#OPEN">OPEN</A><A HREF="#.">.</A>
The numerical expression n is the channel number under which the file was
OPENed.

<A HREF="#INP&">INP&</A>(#n) reads a word (two-byte value) from a file.

<A HREF="#INP%">INP%</A>(#n) reads a long (four-byte value) from a file. Thus a%<A HREF="#=">=</A><A HREF="#INP">INP</A>%(#1) can
replace a%<A HREF="#=">=</A><A HREF="#CVL">CVL</A>(<A HREF="#INPUT$">INPUT$</A>(4,#1))<A HREF="#.">.</A>

<A HREF="#OUT">OUT</A> #n sends a byte to a file which was been previously opened with <A HREF="#OPEN">OPEN</A><A HREF="#.">.</A> The
numerical expression n is the channel number under which the file was OPENed.
Only the low-order 8 bits of a, b, c, <A HREF="#.">.</A>.. are output, thus limiting their
values to 255.

<A HREF="#OUT&">OUT&</A> #n sends a word (two-byte value) to a file.

<A HREF="#OUT%">OUT%</A> #n sends a long (four-byte value) to a file.

<A HREF="#INP()">INP()</A> and <A HREF="#OUT">OUT</A> without the <A HREF="#'">'</A><A HREF="##">#</A>' can also be used for communication with the
screen, keyboard, etc. (e.g. <A HREF="#INP">INP</A>(2) reads a character from the keyboard). See
the section called "<A HREF="#Communicating_with_Peripherals">Communicating with Peripherals</A>"<A HREF="#.">.</A>

<B>Example:</B>

    <A HREF="#OPEN">OPEN</A> "o",#1,"TEST.TXT"
    <A HREF="#OUT">OUT</A> #1,128
    <A HREF="#CLOSE">CLOSE</A> #1
    <A HREF="#'">'</A>
    <A HREF="#OPEN">OPEN</A> "i",#1,"TEST.TXT"
    a=<A HREF="#INP">INP</A>(#1)
    <A HREF="#CLOSE">CLOSE</A> #1
    <A HREF="#PRINT">PRINT</A> a

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> In the first part of the example a file is opened for output and a byte is
    written to it. In the second part this byte is read back in as the variable
    'a' which when printed is revealed to have the value 128.

<B>Memo:</B> <A HREF="#INP">INP</A>(#n), <A HREF="#INP&">INP&</A>(#n), and <A HREF="#INP%">INP%</A>(#n) incorrectly return error code 0 if
      the #channel number is incorrect.

Fread()<A HREF="#+">+</A>, Fwrite()+
<HR SIZE=3><H2 ID="INPUT$">INPUT$</H2>
<B><A HREF="#INPUT$">INPUT$</A>(count[,#n])</B>

n, count: <A HREF="#iexp">iexp</A>

<A HREF="#INPUT$">INPUT$</A><A HREF="#()">()</A> reads 'count' characters from the keyboard and assigns them to a
string. Optionally, if the channel number n (0 to 99) is specified, the
characters are read in as bytes from a file or peripheral device. In both cases
the numerical expression 'count' determines the number of characters read.

<B>Example:</B>

    <A HREF="#OPEN">OPEN</A> "o",#1,"VERSION.DAT"
    <A HREF="#PRINT">PRINT</A> #1,"GFA BASIC, Version 3.0"
    <A HREF="#CLOSE">CLOSE</A> #1
    <A HREF="#'">'</A>
    <A HREF="#OPEN">OPEN</A> "i",#1,"VERSION.DAT"
    v$<A HREF="#=">=</A><A HREF="#INPUT$">INPUT$</A>(9,#1)
    <A HREF="#CLOSE">CLOSE</A> #1
    <A HREF="#PRINT">PRINT</A> v$
    <A HREF="#PRINT">PRINT</A> "Please type in the Version number: "<A HREF="#;">;</A>
    <A HREF="#PRINT">PRINT</A> <A HREF="#INPUT$">INPUT$</A>(3)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> In the first part of the example the file 'VERSION.DAT' is opened and a
    message printed to it. The second part reads the first 9 characters of this
    file into the variable v$ and displays v$ on the screen. Then a message
    appears, and 3 characters are taken from the keyboard and printed.

<B>Memo:</B> <A HREF="#INPUT$">INPUT$</A>(count,#n) incorrectly returns error code 0 if the #channel
      number is wrong.

Fread()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="INPUT_#">INPUT #</H2>
<A NAME="LINE_INPUT_#"></A><B><A HREF="#INPUT">INPUT</A> #n,var1 [,var2,var3,<A HREF="#.">.</A>..]
<A HREF="#LINE_INPUT">LINE INPUT</A> #n,a1$ [,a2$,a2$,<A HREF="#.">.</A>..]</B>

n: <A HREF="#iexp">iexp</A>
var1, var2, var3, a1$, a2$, a3$<A HREF="#:">:</A> <A HREF="#avar">avar</A> or <A HREF="#svar">svar</A>

Parameter n is the channel number which was previously opened with <A HREF="#OPEN">OPEN</A><A HREF="#.">.</A>

<A HREF="#INPUT">INPUT</A> #n makes it possible to take data from a file or a peripheral device.
Individual variables or variable lists (where the variables are separated by
commas) can be input. This instruction corresponds to <A HREF="#INPUT">INPUT</A>, except that it
deals with files.

<A HREF="#LINE_INPUT_#">LINE INPUT #</A> corresponds to <A HREF="#LINE_INPUT">LINE INPUT</A> except that it deals with files.

<B>Example:</B>

    <A HREF="#OPEN">OPEN</A> "o",#1,"<A HREF="#TEXT">TEXT</A>.DOC"
    <A HREF="#WRITE">WRITE</A> #1,"Goodbye","Hello","Hello, Hello, Hello"
    <A HREF="#CLOSE">CLOSE</A> #1
    <A HREF="#'">'</A>
    <A HREF="#OPEN">OPEN</A> "i",#1,"<A HREF="#TEXT">TEXT</A>.DOC"
    <A HREF="#INPUT">INPUT</A> #1,a$,b$
    <A HREF="#LINE_INPUT">LINE INPUT</A> #1,c$
    <A HREF="#CLOSE">CLOSE</A> #1
    <A HREF="#PRINT">PRINT</A> a$
    <A HREF="#PRINT">PRINT</A> b$
    <A HREF="#PRINT">PRINT</A> c$

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Three strings are written to the file <A HREF="#TEXT">TEXT</A>.DOC. The first two are read back
    in with <A HREF="#INPUT_#">INPUT #</A>, the third with <A HREF="#LINE_INPUT_#">LINE INPUT #</A>, as it contains commas. The
    three strings are printed.

<B>Memo:</B> Issues wrong error code, #35 should #25.

Fread()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="PRINT_#">PRINT #</H2>
<A NAME="PRINT_#_USING"></A><A NAME="WRITE_#"></A><B><A HREF="#PRINT">PRINT</A> #n,expression
<A HREF="#PRINT">PRINT</A> #n,USING form$,expression
<A HREF="#WRITE">WRITE</A> #n,expression</B>

n: <A HREF="#iexp">iexp</A>
form$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>
expression: <A HREF="#aexp">aexp</A> or <A HREF="#sexp">sexp</A> or a combination

<A HREF="#PRINT">PRINT</A> #n outputs data to a specified channel. Parameter n (0 to 99) denotes the
required channel. Otherwise the instruction operates like <A HREF="#PRINT">PRINT</A>. PRINT #n AT,
however, is not possible.

<A HREF="#PRINT">PRINT</A> #n USING allows formatted output to a data channel. The parmater n (0 to
99) denotes the required channel. Otherwise the instruction operates like <A HREF="#PRINT">PRINT</A>
USING.

The instruction <A HREF="#WRITE_#">WRITE #</A> serves primarily for the space-saving storage of data
in sequential files in a format suitable for later reading with <A HREF="#INPUT_#">INPUT #</A><A HREF="#.">.</A> The
expressions are separated by commas and character strings must be enclosed in
quotation marks. The parmater n (0 to 99) denotes the required channel.
Otherwise the instruction operates like <A HREF="#WRITE">WRITE</A><A HREF="#.">.</A>

<B>Examples:</B>

    <A HREF="#OPEN">OPEN</A> "o",#1,"<A HREF="#TEXT">TEXT</A>.DOC"
    <A HREF="#PRINT">PRINT</A> #1,"test"
    <A HREF="#CLOSE">CLOSE</A> #1
    <A HREF="#'">'</A>
    <A HREF="#OPEN">OPEN</A> "i",#1,"<A HREF="#TEXT">TEXT</A>.DOC"
    <A HREF="#INPUT">INPUT</A> #1,a$
    <A HREF="#CLOSE">CLOSE</A> #1
    <A HREF="#PRINT">PRINT</A> a$

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The string 'test' is printed to the file <A HREF="#TEXT">TEXT</A>.DOC, which is then closed and
    re-opened for input. <A HREF="#INPUT_#">INPUT #</A> takes the string from the file as a$, which is
    then printed on the screen.

    <A HREF="#OPEN">OPEN</A> "o",#1,"TEST.DAT"
    <A HREF="#WRITE">WRITE</A> #1,"Version ",3,".0"
    <A HREF="#CLOSE">CLOSE</A> #1
    <A HREF="#'">'</A>
    <A HREF="#OPEN">OPEN</A> "i", #1,"TEST.DAT"
    <A HREF="#INPUT">INPUT</A> #1,v1$,v2$,v3$
    <A HREF="#CLOSE">CLOSE</A> #1
    <A HREF="#PRINT">PRINT</A> v1$+v2$+v3$

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Data separated by commas is put into the file TEST.DAT and afterwards read
    back in again with <A HREF="#INPUT_#">INPUT #</A> and displayed on the screen.

Fwrite()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="STORE">STORE</H2>
<A NAME="RECALL"></A><B><A HREF="#STORE">STORE</A> #i,x$<A HREF="#()">()</A> [,n [TO m]]
<A HREF="#RECALL">RECALL</A> #i,x$<A HREF="#()">()</A>,n [TO m] ,x</B>

i, n, m: <A HREF="#iexp">iexp</A>
x$()<A HREF="#:">:</A> string array
x: variable, at least 32-bit (long)

The instruction <A HREF="#STORE">STORE</A> is used for sending the contents of an array to a file or
data channel (with the elements separated by CR/LFs)<A HREF="#.">.</A> The optional parameter m
specifies how many elements of the array are to be sent to the previously
OPENed channel i; if m is omitted, the whole array is transferred.

The instruction <A HREF="#RECALL">RECALL</A> allows the quick inputting of m lines from a text file
to the array x$<A HREF="#()">()</A><A HREF="#.">.</A> If m=-1 all available lines are read. If m is too large for
the dimension of the array, then the number of lines read in is limited
automatically. If the end of file is reached during reading then the inputting
is broken off without an error occurring. In each case, after the reading has
been completed, the variable x will contain the number of strings actually
read.

In addition to mentioning the number of strings to be read/written you can give
the range of the strings to be stored, e.g, <A HREF="#STORE">STORE</A> #1,a$<A HREF="#()">()</A>,10 TO 20.

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> That stores eleven strings from a$<A HREF="#()">()</A>, starting with number 10 up to 20,
    counting <U>always</U> starts with zero.

<B>Note:</B> <A HREF="#STORE">STORE</A> functions with files and peripheral devices, but <A HREF="#RECALL">RECALL</A> only
      functions with files, since a <A HREF="#SEEK">SEEK</A> (see following) is used internally.

<B>Examples:</B>

    <A HREF="#DIM">DIM</A> A$(1000)
    <A HREF="#FOR">FOR</A> i%=0 TO 499
      a$(i%)<A HREF="#=">=</A><A HREF="#STR$">STR$</A>(<A HREF="#RND">RND</A>) <A HREF="#!">!</A> anything
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#'">'</A>
    <A HREF="#OPEN">OPEN</A> "o",#1,"TESTFILE.TXT"
    <A HREF="#STORE">STORE</A> #1,a$<A HREF="#()">()</A>,500
    <A HREF="#CLOSE">CLOSE</A> #1
    <A HREF="#'">'</A>
    <A HREF="#DIM">DIM</A> b$(2000)
    <A HREF="#OPEN">OPEN</A> "i",#1,"TESTFILE.TXT"
    <A HREF="#RECALL">RECALL</A> #1,b$<A HREF="#()">()</A>,-1,x
    <A HREF="#CLOSE">CLOSE</A> #1
    <A HREF="#PRINT">PRINT</A> x

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The number of text lines read is displayed (500)<A HREF="#.">.</A>

    <A HREF="#PRINT">PRINT</A> "Line counter: "
    <A HREF="#DIM">DIM</A> a$(1000)
    <A HREF="#DO">DO</A>
      <A HREF="#FILESELECT">FILESELECT</A> "\<A HREF="#*">*</A><A HREF="#.">.</A>*","",f$
      <A HREF="#EXIT_IF">EXIT IF</A> f$<A HREF="#=">=</A>""
      lc%=0
      <A HREF="#OPEN">OPEN</A> "i",#1,f$
      <A HREF="#DO">DO</A>
        <A HREF="#RECALL">RECALL</A> #1, a$<A HREF="#()">()</A>,-1,x%
        <A HREF="#ADD">ADD</A> lc%,x%
      <A HREF="#LOOP_WHILE">LOOP WHILE</A> x%
      <A HREF="#CLOSE">CLOSE</A> #1
      <A HREF="#PRINT">PRINT</A> f$<A HREF="#'">'</A>"contains"'lc%'"lines."
    <A HREF="#LOOP">LOOP</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> This program counts the lines in text files.

<B>Memo:</B> <A HREF="#RECALL">RECALL</A> will crash if any line in the file exceeds about 9100 bytes in
      length when compiled.

      <A HREF="#RECALL">RECALL</A> searches for <A HREF="#ASCII">ASCII</A> 10 and not ASCII 13 as one might assume.
      Thus it will read unix text files, but not Apple text files.

Fread()<A HREF="#+">+</A>, Fwrite()+
<HR SIZE=3><H2 ID="SEEK">SEEK</H2>
<A NAME="RELSEEK"></A><B><A HREF="#SEEK">SEEK</A> #n,pos
<A HREF="#RELSEEK">RELSEEK</A> #n,num</B>

n, num, pos: <A HREF="#iexp">iexp</A>

The commands <A HREF="#SEEK">SEEK</A> and <A HREF="#RELSEEK">RELSEEK</A> permit the re-positioning of the data pointer
with an accessed file, allowing the realisation of indexed sequential file
access. The numerical expression n contains the channel number used when the
file was OPENed. Both commands can be used only with files, not with peripheral
devices. The data pointer specifies which byte of a file was read or written
last. Except for access mode 'A' (used to append data to the end of an existing
file) the data pointer has the value 0 when opening a file. Reading or writing
commences with first byte, to which the data pointer subsequently points.

The <A HREF="#SEEK">SEEK</A> command positions the data pointer to a specified byte number in a
file. The pointer can, however be moved a specified number of bytes forwards or
backwards with <A HREF="#RELSEEK">RELSEEK</A> (relative seek)<A HREF="#:">:</A> the pointer is moved the number of
bytes specified in num. <A HREF="#RELSEEK">RELSEEK</A> is generally faster than <A HREF="#SEEK">SEEK</A>.

<A HREF="#SEEK">SEEK</A> may use positive values of pos up to the relevant file length. <A HREF="#RELSEEK">RELSEEK</A>
accepts positive or negative values of num, an error occurring when an attempt
is made to position the data pointer past the end or before the beginning of a
file. <A HREF="#SEEK">SEEK</A> #n,0 takes the pointer to the start of a file.

<B>Example:</B>

    <A HREF="#OPEN">OPEN</A> "o",#1,"X.X"
    <A HREF="#PRINT">PRINT</A> #1,<A HREF="#STRING$">STRING$</A>(20,"<A HREF="#*">*</A>")
    <A HREF="#SEEK">SEEK</A> #1,10
    <A HREF="#PRINT">PRINT</A> #1,"#"<A HREF="#;">;</A>
    <A HREF="#RELSEEK">RELSEEK</A> #1,-5
    <A HREF="#OUT">OUT</A> #1,48,49
    <A HREF="#CLOSE">CLOSE</A> #1
    <A HREF="#'">'</A>
    <A HREF="#OPEN">OPEN</A> "i",#1,"X.X"
    <A HREF="#LINE_INPUT">LINE INPUT</A> #1,a$
    <A HREF="#CLOSE">CLOSE</A> #1
    <A HREF="#PRINT">PRINT</A> a$

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Displays: <A HREF="#*">*</A>*****01**<A HREF="##">#</A>*********

<B>Memo:</B> FSEEK does not issue and error when compiled if the #channel is
      wrong.

      <A HREF="#SEEK">SEEK</A> can except negative values. The offset then specifies the number of
      bytes from the end of the file.  Seems to be an undocumented feature.

Fseek()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="Random_Access">Random Access</H2>
<A HREF="#FIELD">FIELD</A>
<A HREF="#GET_#">GET #</A>, <A HREF="#PUT_#">PUT #</A>
<A HREF="#RECORD_#">RECORD #</A>

In the following section the handling of a <A HREF="#Random_Access">Random Access</A> file is described.
Two terms are particularly important: Data record and data field. A data field
is a single item of information, for instance a name or telephone number. A
data record consists of a number of data fields, and is analogous to one card
in a card <A HREF="#index">index</A><A HREF="#.">.</A> The length of a record (in bytes) must equal the sum of the
lengths of the individual fields.

The difference between a random access file and a sequential file lies in the
method of data access. With a sequential file the entire file must be loaded in
order to be able to access a particular data record, whereas with a random
access file the record may be obtained directly. This is particularly useful
with very large files, although this advantage is offset by greater consumption
of space on the disk, because a random access file uses a fixed record length,
resulting in waste if some records are shorter than others.

<B>Memo:</B> <A HREF="#FIELD">FIELD</A> and related commands when compiled, in most cases issue the
      wrong error code. If you see error #111, it's really some other error.

<HR SIZE=3><H2 ID="FIELD">FIELD</H2>
<A NAME="FIELD_#"></A><B><A HREF="#FIELD">FIELD</A> #n,num AS <A HREF="#svar">svar</A><A HREF="#$">$</A> [,num AS svar$,num AS svar$,<A HREF="#.">.</A>..]
<A HREF="#FIELD">FIELD</A> #n,num AT(x) [,num AT(x),num AT(x),<A HREF="#.">.</A>..]</B>

n, num, x: <A HREF="#iexp">iexp</A>
<A HREF="#svar">svar</A>$<A HREF="#:">:</A> svar (not an array variable)

The command <A HREF="#FIELD_#">FIELD #</A> AS is used to divide data records into fields. The
numerical expression n is the number of the data channel (0 to 99) of a file
previously opened with <A HREF="#OPEN">OPEN</A><A HREF="#.">.</A> The integer expression num determines the field
length. The variable <A HREF="#svar">svar</A><A HREF="#$">$</A> contains data for one field of a data record.  If
the data record is to be divided into several fields, the parts 'num AS <A HREF="#svar">svar</A><A HREF="#$">$</A>'
must be separated by commas. The sum of the individual field lengths must equal
the data reeord length, otherwise an appropriate error message is displayed.
Thus in order to keep the field lengths to those specified in the <A HREF="#FIELD">FIELD</A> command
it is convenient to use the commands <A HREF="#LSET">LSET</A> and <A HREF="#RSET">RSET</A> or <A HREF="#MID$">MID$</A><A HREF="#.">.</A>

By using AT() instead of AS numeric variables can be written to a random access
file. In this case num must contain the length of the variable (1 for
byte-type, 2 for word-type etc.) and the brackets must contain a pointer to the
variable (see <A HREF="#*">*</A>, <A HREF="#VARPTR">VARPTR</A><A HREF="#()">()</A>)<A HREF="#.">.</A> Actually an arbitrary area of memory can be
transferred by specifying the number of bytes (num) and the address of the
first byte (x)<A HREF="#.">.</A> Note that there is no space after the 'AT'.

For example:

    <A HREF="#FIELD">FIELD</A> #1,4 AT(*a%),2 AT(*b&),8 AT(*c#)

Arbitrary combinations of AS and AT() are possible, e.g.<A HREF="#:">:</A>

    <A HREF="#FIELD">FIELD</A> #2,4 AS a$,2 AT(*b&),8 AT(*c#),6 AS d$

Unlike in Version 2, several successive <A HREF="#FIELD">FIELD</A> commands can be used, on
sucessive lines, referring to the same channel number. The effect is the same
as that of one long <A HREF="#FIELD">FIELD</A> command. The maximum record length is 32767 bytes,
and the maximum number of fields approximately 5000.

<B>Memo:</B> Version 1 had a limit of 9 fields.
      Version 2 had a limit of 19 fields.
      Version 3 has no such limit.
      Thus error code #53 was retired.

      Versions 1 <A HREF="#&">&</A> 2 had a limit of one <A HREF="#FIELD">FIELD</A> command per <A HREF="#OPEN">OPEN</A> command.
      Thus error code #51 was retired.
<HR SIZE=3><H2 ID="RECORD">RECORD</H2>
<A NAME="GET_#"></A><A NAME="PUT_#"></A><A NAME="RECORD_#"></A><B><A HREF="#GET">GET</A> #n[,r]
<A HREF="#PUT">PUT</A> #n[,r]
<A HREF="#RECORD">RECORD</A> #n,r</B>

n, r: <A HREF="#iexp">iexp</A>

<A HREF="#GET">GET</A> reads a data record from a random access file. Similarly, <A HREF="#PUT">PUT</A> stores a data
record in such a file. The parameter n (0 to 99) is the channel number under
which the file was OPENed, and the optional parameter r contains a value
between 1 and the number of data records in the file, specifying the number of
the data record to be read or stored. If r is omitted, the next record will be
read or stored.

<A HREF="#RECORD">RECORD</A> sets the number of the record to be read or stored next with <A HREF="#GET">GET</A> or <A HREF="#PUT">PUT</A><A HREF="#.">.</A>
(e.g. after <A HREF="#RECORD">RECORD</A> #1,15 record number 15 will be read by <A HREF="#GET">GET</A> #1.)

<B>Note:</B> Only one record at a time can be added to a file. A <A HREF="#FOR">FOR</A><A HREF="#-">-</A><A HREF="#NEXT">NEXT</A> loop
      etc. must be used for multiple record storage.

<B>Examples:</B>

    <A HREF="#OPEN">OPEN</A> "r",#1,"PERSONAL.INF",62
    <A HREF="#FIELD">FIELD</A> #1,24 AS name$,2 AT(*house&)
    <A HREF="#FIELD">FIELD</A> #1,24 AS road$,12 AS town$
    <A HREF="#FOR">FOR</A> i%=1 TO 3
      <A HREF="#INPUT">INPUT</A> "Name        <A HREF="#:">:</A> ";n$
      <A HREF="#INPUT">INPUT</A> "House number: ";house&
      <A HREF="#INPUT">INPUT</A> "Road        <A HREF="#:">:</A> ";r$
      <A HREF="#INPUT">INPUT</A> "Town        <A HREF="#:">:</A> ";t$
      <A HREF="#LSET">LSET</A> name$=n$
      <A HREF="#LSET">LSET</A> road$=r$
      <A HREF="#LSET">LSET</A> town$=t$
      <A HREF="#PUT">PUT</A> #1,i%
      <A HREF="#CLS">CLS</A>
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#CLOSE">CLOSE</A> #1

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> First a random access file (mode 'r') with a record length of 62 bytes is
    opened. With <A HREF="#FIELD">FIELD</A> a data record is specified as consisting of 4 fields of
    24, 2, 24, and 12 bytes respectively (adding up to 62, the record length
    specified in the <A HREF="#OPEN">OPEN</A> statement)<A HREF="#.">.</A>

    Then the program asks for three names and addresses. Each time the name,
    house number, etc. are inserted left justified into the appropriate
    variables and the whole data record is written to the file.

In older versions of GFA BASIC instead of '2 AT(*house&)' it was necessary to
use '2 AS house$' and then '<A HREF="#LSET">LSET</A> house$<A HREF="#=">=</A><A HREF="#MKI$">MKI$</A>(house&)' etc.

   <A HREF="#OPEN">OPEN</A> "r",#1,"PERSONAL.INF",62
   <A HREF="#FIELD">FIELD</A> #1,24 AS name$,2 AT(*house&)
   <A HREF="#FIELD">FIELD</A> #1,24 AS road$,12 AS town$
   <A HREF="#FOR">FOR</A> i%=1 TO 3
     <A HREF="#GET">GET</A> #1,i%
     <A HREF="#PRINT">PRINT</A> "Record number: ";i%
     <A HREF="#PRINT">PRINT</A>
     <A HREF="#PRINT">PRINT</A> "Name        <A HREF="#:">:</A> ";name$
     <A HREF="#PRINT">PRINT</A> "House number: ";house&
     <A HREF="#PRINT">PRINT</A> "Road        <A HREF="#:">:</A> ";road$
     <A HREF="#PRINT">PRINT</A> "Town        <A HREF="#:">:</A> ";town$
     <A HREF="#PRINT">PRINT</A>
     <A HREF="#PRINT">PRINT</A>
   <A HREF="#NEXT">NEXT</A> i%
   <A HREF="#CLOSE">CLOSE</A> #1

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Here the file PERSONAL.INF is opened in <A HREF="#Random_Access">Random Access</A> mode and the three
    records are read in and printed out.

<B>Memo:</B> <A HREF="#GET_#">GET #</A> and <A HREF="#PUT_#">PUT #</A> compiled issue the wrong error message if the field
      length changes. Should issue error #54 and not error #8.

      Version 2 had a limit of 65535 records, this limit is gone.
      Thus error code #55 was retired.

Fread()<A HREF="#+">+</A>, Fwrite()+
<HR SIZE=3><H2 ID="Communicating_with_Peripherals">Communicating with Peripherals</H2>
<A NAME="Byte_by_Byte_Input_and_Output"></A><A HREF="#INP()">INP()</A>, <A HREF="#INP&()">INP&()</A>, <A HREF="#INP%()">INP%()</A>
<A HREF="#INP?">INP?</A><A HREF="#()">()</A>
<A HREF="#OUT">OUT</A>, <A HREF="#OUT&">OUT&</A>, <A HREF="#OUT%">OUT%</A>
<A HREF="#OUT?">OUT?</A><A HREF="#()">()</A>
<HR SIZE=3><H2 ID="INP()">INP()</H2>
<A NAME="INP&()"></A><A NAME="INP%()"></A><A NAME="INP?"></A><A NAME="OUT"></A><A NAME="OUT&"></A><A NAME="OUT%"></A><A NAME="OUT?"></A><B><A HREF="#INP">INP</A>(n)
<A HREF="#INP&">INP&</A>(n)
<A HREF="#INP%">INP%</A>(n)
<A HREF="#INP?">INP?</A>(n)
<A HREF="#OUT">OUT</A> n,a[,b,c,<A HREF="#.">.</A>..]
<A HREF="#OUT&">OUT&</A> n,a[,b,c,<A HREF="#.">.</A>..]
<A HREF="#OUT%">OUT%</A> n,a[,b,c,<A HREF="#.">.</A>..]
<A HREF="#OUT?">OUT?</A>(n)</B>

n, a, b: <A HREF="#iexp">iexp</A>

<A HREF="#INP()">INP()</A> reads a byte from a peripheral device. The numerical expression n can
accept values from 0 to 5 (see the following table)<A HREF="#.">.</A> The command <A HREF="#OUT">OUT</A> sends a
byte to a peripheral device.

<A HREF="#INP&()">INP&()</A> reads a word (two-byte value) from a peripheral device. <A HREF="#OUT&">OUT&</A> sends a
word to a peripheral device.

<A HREF="#INP%()">INP%()</A> reads a long (four-byte value) from a peripheral device. <A HREF="#OUT%">OUT%</A> sends a
long to a peripheral device.

Unlike <A HREF="#GFA-Basic">GFA-Basic</A> Version 2, one can now send several bytes with one <A HREF="#OUT">OUT</A>
statement.

<A HREF="#INP?">INP?</A><A HREF="#()">()</A> and <A HREF="#OUT?">OUT?</A>() determine the input or output status of a peripheral device.
A non-zero value is returned if the device is ready to send/receive, and zero
(logical <A HREF="#FALSE">FALSE</A>) if it is not.

<A HREF="#INP()">INP()</A> and <A HREF="#OUT">OUT</A> with the <A HREF="#'">'</A><A HREF="##">#</A>' can also be used for sequential file access, (e.g.
<A HREF="#INP">INP</A>(#2) or <A HREF="#OUT">OUT</A> #2,a reads from or writes to an already open file)<A HREF="#.">.</A> See the
section called "<A HREF="#Sequential_Access">Sequential Access</A>"<A HREF="#.">.</A>

Device table is as follows: (See <A HREF="#OPEN">OPEN</A> for more details)

    <B>n  Device            Meaning</B>
    0  <A HREF="#LST:">LST:</A> (list)       Printer
    1  <A HREF="#AUX:">AUX:</A> (auxiliary)  Serial (RS232)
    2  <A HREF="#CON:">CON:</A> (console)    Keyboard/Screen
    3  <A HREF="#MID:">MID:</A> (MIDI)       MIDI interface
    4  <A HREF="#IKB:">IKB:</A> (IKBD)       <B>I</B>ntelligent <B>K</B>ey<B>B</B>oar<B>D</B> controller
    5  <A HREF="#VID:">VID:</A> (video)      Screen

<B>Examples:</B>

    <A HREF="#PRINT_AT">PRINT AT</A>(4,4)<A HREF="#;">;</A>"Press a key please"
    <A HREF="#~">~</A><A HREF="#INP">INP</A>(2)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> A message is displayed and the program then waits for a byte from device 2
    (the keyboard)<A HREF="#.">.</A>

    <A HREF="#OUT">OUT</A> 2,27,69,10,10,10
    <A HREF="#PRINT">PRINT</A> "Hello"

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> This command clears the screen (by means of the <A HREF="#VT-52">VT-52</A> control sequence
    ESCape+E, corresponding to the <A HREF="#ASCII">ASCII</A> codes 27 and 69), then issues three
    Line Feed characters (<A HREF="#ASCII">ASCII</A> code 10)<A HREF="#.">.</A> Thus, 'Hello' is printed on the
    fourth line.

<B>Memo:</B> For some strange reason <A HREF="#~">~</A><A HREF="#INP">INP</A>(2) will fail under MiNT if the
      AES/VDI are not linked at compile time. In fact any command that uses
      bconin() internally most likely won't work. Symptoms are this:
      1) Won't wait for input and returns instantly.
      2) Always returns the value 26.

      Undocumented <A HREF="#INP()">INP()</A> feature allows -negative device numbers.
      Negative device numbers perform an inquire function like <A HREF="#INP?">INP?</A><A HREF="#()">()</A><A HREF="#.">.</A>
      The results for <A HREF="#INP?">INP?</A>(0) and <A HREF="#INP">INP</A>(-0) however are different since you
      can't have negative zero. So that device can't be inquired with <A HREF="#INP">INP</A>(-0).

      <A HREF="#INP">INP</A>(2) (console) returns scancode+128 for any key that has no <A HREF="#ASCII">ASCII</A>
         value.

      Device numbers <A HREF="#=">=</A><A HREF="#&">&</A>#62;6 will cause GFA to overwrite internal data!
      To access such devices, use operating system calls instead.
      Clobbers the internal <A HREF="#POS">POS</A><A HREF="#()">()</A> table and could effects <A HREF="#TAB">TAB</A>() as well.
      Works with device numbers 6 to 9.
        <A HREF="#INP()">INP()</A>
        <A HREF="#INP?">INP?</A><A HREF="#()">()</A>, <A HREF="#OUT?">OUT?</A>()
      Does not work with device numbers 6 to 9.
        <A HREF="#INP&()">INP&()</A>, <A HREF="#INP%()">INP%()</A>
        <A HREF="#OUT">OUT</A>, <A HREF="#OUT&">OUT&</A>, <A HREF="#OUT%">OUT%</A>

      Handy options:
      <A HREF="#OUT">OUT</A> 4,18  !freeze the mouse, disable mouse packet reporting
      <A HREF="#OUT">OUT</A> 4,8   !unfreeze the mouse, enable mouse packet reporting

Bconin()<A HREF="#+">+</A>, Bconout()+, Bconstat()+, Bcostat()+
The IKBD Controller+, IKBD command codes+
<HR SIZE=3><H2 ID="Serial_(RS232)_and_MIDI_Interfaces">Serial (RS232) and MIDI Interfaces</H2>
<A NAME="INPAUX$"></A><A NAME="INPMID$"></A><B><A HREF="#INPAUX$">INPAUX$</A>
<A HREF="#INPMID$">INPMID$</A></B>

By means of <A HREF="#INPAUX$">INPAUX$</A> and <A HREF="#INPMID$">INPMID$</A> data can be read in very quickly from the
serial and MIDI interfaces.

<B>Example:</B>

    <A HREF="#DO">DO</A>
      <A HREF="#PRINT">PRINT</A> <A HREF="#INPAUX$">INPAUX$</A><A HREF="#;">;</A>
    <A HREF="#LOOP_UNTIL">LOOP UNTIL</A> <A HREF="#MOUSEK">MOUSEK</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Reads in all the data from the input buffer of the serial interface. This
    method of data input is much faster than inputting byte by byte.

    inp_aux$<A HREF="#=">=</A>""
    <A HREF="#WHILE">WHILE</A> <A HREF="#INP?">INP?</A>(1)
      inp_aux$=inp_aux$<A HREF="#+">+</A><A HREF="#CHR$">CHR$</A>(<A HREF="#INP">INP</A>(1))
    <A HREF="#WEND">WEND</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> This alternative method is clearly slower.

Bconin()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="Mouse_and_Joysticks">Mouse and Joysticks</H2>
<A HREF="#MOUSEX">MOUSEX</A>, <A HREF="#MOUSEY">MOUSEY</A>, <A HREF="#MOUSEK">MOUSEK</A>
<A HREF="#MOUSE">MOUSE</A>
<A HREF="#SETMOUSE">SETMOUSE</A>
<A HREF="#HIDEM">HIDEM</A>, <A HREF="#SHOWM">SHOWM</A>
<A HREF="#STICK">STICK</A>, STICK(), <A HREF="#STRIG">STRIG</A>()
<A HREF="#PADX">PADX</A><A HREF="#()">()</A>, <A HREF="#PADY">PADY</A>(), <A HREF="#PADT">PADT</A>()
<A HREF="#LPENX">LPENX</A>, <A HREF="#LPENY">LPENY</A>
<HR SIZE=3><H2 ID="MOUSE">MOUSE</H2>
<A NAME="MOUSEX"></A><A NAME="MOUSEY"></A><A NAME="MOUSEK"></A><B><A HREF="#MOUSEX">MOUSEX</A>
<A HREF="#MOUSEY">MOUSEY</A>
<A HREF="#MOUSEK">MOUSEK</A>
<A HREF="#MOUSE">MOUSE</A> mx,my,mk</B>

mx, my, mk: <A HREF="#avar">avar</A>

<A HREF="#MOUSEX">MOUSEX</A>, <A HREF="#MOUSEY">MOUSEY</A>, and <A HREF="#MOUSEK">MOUSEK</A> return the X and Y coordinates of the mouse pointer,
and information on the state of the mouse buttons. <A HREF="#MOUSE">MOUSE</A> allows the gathering
of that information with one statement, giving the current mouse coordinates to
mx and my and the mouse button status to mk. <A HREF="#MOUSEK">MOUSEK</A> (or mk) will return values
betwwen 0 and 3, with the following meaning:

Note: These commands respect the current <A HREF="#CLIP_OFFSET">CLIP OFFSET</A><A HREF="#.">.</A>

    <B>mk  Button(s) pressed</B>
    0   None
    1   Left
    2   Right
    3   Both left and right

<B>Example:</B>

    <A HREF="#REPEAT">REPEAT</A>
      <A HREF="#IF">IF</A> <A HREF="#MOUSEK">MOUSEK</A>=1
        <A HREF="#PLOT">PLOT</A> <A HREF="#MOUSEX">MOUSEX</A>,<A HREF="#MOUSEY">MOUSEY</A>
      <A HREF="#ENDIF">ENDIF</A>
    <A HREF="#UNTIL">UNTIL</A> <A HREF="#MOUSEK">MOUSEK</A>=2
    <A HREF="#'">'</A>
    <A HREF="#REPEAT">REPEAT</A>
      <A HREF="#MOUSE">MOUSE</A> x%,y%,k%
      <A HREF="#IF">IF</A> k%=2
        <A HREF="#PLOT">PLOT</A> x%,y%
      <A HREF="#ENDIF">ENDIF</A>
    <A HREF="#UNTIL">UNTIL</A> k%=1

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> In the first <A HREF="#REPEAT">REPEAT</A>-<A HREF="#UNTIL">UNTIL</A> loop a point is plotted on the screen at the
    mouse pointer position if the left mouse button is pressed. When the right
    button is pressed the second <A HREF="#REPEAT">REPEAT</A><A HREF="#-">-</A><A HREF="#UNTIL">UNTIL</A> loop is entered. In the second
    loop, plotting takes place provided the right mouse button is held down.
    When the left button is pressed, the loop and the program both terminate.

<B>Memo:</B> These are actually <A HREF="#Line-A">Line-A</A> variables.

      <A HREF="#MOUSE">MOUSE</A>  <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> GCURX, GCURY, MOUSE_BT (<A HREF="#Line-A">Line-A</A> variables)
      <A HREF="#MOUSEX">MOUSEX</A> <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> GCURX
      <A HREF="#MOUSEY">MOUSEY</A> <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> GCURY
      <A HREF="#MOUSEK">MOUSEK</A> <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> MOUSE_BT

<A HREF="#Line-A_Variable_Table">Line-A Variable Table</A><A HREF="#+">+</A>, graf_mkstate()+
<HR SIZE=3><H2 ID="SETMOUSE">SETMOUSE</H2>
<B><A HREF="#SETMOUSE">SETMOUSE</A> mx,my[,mk]</B>

mx, my, mk: <A HREF="#iexp">iexp</A>

The command <A HREF="#SETMOUSE">SETMOUSE</A> permits the positioning of the mouse cursor under program
control. The optional parameter mk can simulate the mouse buttons being pressed
or released. This unfortunately is only valid for the <A HREF="#VDI">VDI</A>, not, (or seldom)
with the <A HREF="#AES">AES</A><A HREF="#.">.</A>

<B>Example:</B>

    <A HREF="#FOR">FOR</A> i%=0 to 300
      <A HREF="#HIDEM">HIDEM</A>
      <A HREF="#SETMOUSE">SETMOUSE</A> i%,i%
      <A HREF="#PLOT">PLOT</A> <A HREF="#MOUSEX">MOUSEX</A>,<A HREF="#MOUSEY">MOUSEY</A>
      <A HREF="#SHOWM">SHOWM</A>
      <A HREF="#PAUSE">PAUSE</A> 2
    <A HREF="#NEXT">NEXT</A> i%

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Moves the mouse pointer diagonally down the screen, plotting points at its
    current position as it goes.

<B>Memo:</B> This command should be considered a <A HREF="#Line-A">Line-A</A> call.
      Use with caution or not at all.

      <A HREF="#SETMOUSE">SETMOUSE</A> <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> CUR_X/CUR_Y, GCURX/GCURY, MOUSE_BT (<A HREF="#Line-A">Line-A</A> variables)
                  USER_MOT, USER_BUT, DEV_TAB

      The editor seems to swap the left and right button values:
      As documented by Atari: (the compiler works as documented)
      Bit  Value  Meaning  Bit status
      <A HREF="#-">-</A>--  -----  -------  --------------
      01   1      Left     On=down/Off=up
      10   2      Right    On=down/Off=up
      11   3      Both     On=down/Off=up

<A HREF="#Line-A_Variable_Table">Line-A Variable Table</A><A HREF="#+">+</A>
appl_tplay()<A HREF="#+">+</A>, vsm_locator()+, vex_motv()+, vex_butv()+
<HR SIZE=3><H2 ID="HIDEM">HIDEM</H2>
<A NAME="SHOWM"></A><B><A HREF="#HIDEM">HIDEM</A>
<A HREF="#SHOWM">SHOWM</A></B>

The commands <A HREF="#HIDEM">HIDEM</A> (hide mouse) and <A HREF="#SHOWM">SHOWM</A> (show mouse) cause the mouse pointer
to be made invisible or visible respectively. Use of the <A HREF="#ALERT">ALERT</A> command or other
<A HREF="#AES">AES</A> routines causes the mouse pointer to be switched on, and, if not required,
it must be subsequently re-hidden with <A HREF="#HIDEM">HIDEM</A><A HREF="#.">.</A>

During output to the screen with <A HREF="#PRINT">PRINT</A> or the <A HREF="#VDI">VDI</A> or <A HREF="#Line-A">Line-A</A> routines the mouse
pointer is automatically switched off, but afterwards returned to its previous
state.

<B>Example:</B>

    <A HREF="#REPEAT">REPEAT</A>
      <A HREF="#IF">IF</A> <A HREF="#MOUSEK">MOUSEK</A>=1
        <A HREF="#SHOWM">SHOWM</A>
      <A HREF="#ENDIF">ENDIF</A>
      <A HREF="#IF">IF</A> <A HREF="#MOUSEK">MOUSEK</A>=2
        <A HREF="#HIDEM">HIDEM</A>
      <A HREF="#ENDIF">ENDIF</A>
    <A HREF="#UNTIL">UNTIL</A> <A HREF="#MOUSEK">MOUSEK</A>=3

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The mouse pointer is activated by pressing the left button, and
    de-activated by pressing the right button. Pressing both simultaneously
    ends the program, when the 'Program End' alert box leaves the pointer
    visible.

<B>Memo</B> These are actually <A HREF="#Line-A_calls">Line-A calls</A><A HREF="#.">.</A>

graf_mouse()<A HREF="#+">+</A>, v_hide_c()+, v_show_c()+
<A HREF="#Line-A">Line-A</A> Hide Mouse+, Line-A Show Mouse+
<HR SIZE=3><H2 ID="STICK">STICK</H2>
<A NAME="STRIG"></A><B><A HREF="#STICK">STICK</A> m
<A HREF="#STICK">STICK</A>(p)
<A HREF="#STRIG">STRIG</A>(p)</B>

m, p: <A HREF="#iexp">iexp</A>

The Atari ST is provided with two interfaces (ports) for the attachment of
mouse and joysticks. Port 0 can return mouse or joystick information, but port
1 can only return joystick data.

<A HREF="#STICK">STICK</A> 0 causes port 0 to return mouse information, and STICK 1 causes it to
return joystick information. Port 1 always reads a joystick. Normally it is not
necessary to use the command <A HREF="#STICK">STICK</A>, since mouse queries (<A HREF="#MOUSE">MOUSE</A>, <A HREF="#MOUSEK">MOUSEK</A>, etc.)
and joystick queries (<A HREF="#STICK">STICK</A><A HREF="#()">()</A>, etc.) cause STICK 0 and STICK 1 to be executed
automatically. However, before using <A HREF="#AES">AES</A> functions (<A HREF="#ALERT">ALERT</A>, etc.) the mouse
should be activated if necessary with <A HREF="#STICK">STICK</A> 0.

<B>Note:</B> A program that uses <A HREF="#STICK">STICK</A> 1 must also use STICK 0 before it exits!

The function <A HREF="#STICK">STICK</A>(p) returns the position of a joystick. For p=0 the joystick
at port 0 is read, and for p=1, the joystick at port 1. The values returned
correspond to the position of the stick as follows:













The function <A HREF="#STRIG">STRIG</A>(p) returns the state of the fire button on the joystick
attached to port p as a logical value: <A HREF="#TRUE">TRUE</A> (-1) if it is pressed, or <A HREF="#FALSE">FALSE</A> (0)
if not.

<B>Note:</B> The values for 'p' on the STE can be in the range 0 to 5. 0 and 1
      act the same as normally found on the ST but 2-5 are exclusively for the
      STE, and <A HREF="#DO">DO</A> <A HREF="#NOT">NOT</A> check for the mouse at the same time. This effectively
      speeds up the joystick polling.

<B>Examples:</B>

    <A HREF="#STICK">STICK</A> 1               <A HREF="#!">!</A> Activates joystick if attached to port 0
    <A HREF="#REPEAT">REPEAT</A>
      direction%<A HREF="#=">=</A><A HREF="#STICK">STICK</A>(0)
      fire!<A HREF="#=">=</A><A HREF="#STRIG">STRIG</A>(0)
      <A HREF="#SELECT">SELECT</A> direction%
      <A HREF="#CASE">CASE</A> 4
        <A HREF="#PRINT">PRINT</A> "Left"
      <A HREF="#CASE">CASE</A> 8
        <A HREF="#PRINT">PRINT</A> "Right"
      <A HREF="#CASE">CASE</A> 2
        <A HREF="#PRINT">PRINT</A> "Down"
      <A HREF="#CASE">CASE</A> 1
        <A HREF="#PRINT">PRINT</A> "Up
      <A HREF="#ENDSELECT">ENDSELECT</A>
    <A HREF="#UNTIL">UNTIL</A> fire!
    <A HREF="#WHILE">WHILE</A> <A HREF="#STRIG">STRIG</A>(0)
    <A HREF="#WEND">WEND</A>                  <A HREF="#!">!</A> Waits for fire button to be released

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> With movement of the joystick, appropriate messages are printed until the
    fire button is pressed. After waiting for it to be released, the program
    ends.

Note the difference between the <A HREF="#REPEAT">REPEAT</A> and <A HREF="#WHILE">WHILE</A> constructs:

    <A HREF="#REPEAT">REPEAT</A>
      <A HREF="#'">'</A> program segment
    <A HREF="#UNTIL">UNTIL</A> condition

    <A HREF="#WHILE">WHILE</A> condition
      <A HREF="#'">'</A> program segment
    <A HREF="#WEND">WEND</A>

With <A HREF="#REPEAT">REPEAT</A>, the program segment will certainly be executed at least once,
whereas with <A HREF="#WHILE">WHILE</A> the program segment might not be executed at all if the
condition is false.

<B>Memo:</B> STE <A HREF="#STICK">STICK</A><A HREF="#()">()</A> and <A HREF="#STRIG">STRIG</A>() options are incorrectly detected on some
      machines based on the '_SND' cookie.

      <B><A HREF="#STICK">STICK</A>(p)/STRIG(p)  Hardware        STICK m</B>
      0                  mouse/joystick  yes
      1                  joystick        yes
      2                  ste only        no
      3                  ste only        no
      4                  ste only        no
      5                  ste only        no

      The editor steals the joystick vector in supervisor mode, but the
      library does not. Both the editor and library fail to disable/enable
      interrupts while stealing the joystick vector.
<HR SIZE=3><H2 ID="PADT">PADT</H2>
<A NAME="PADX"></A><A NAME="PADY"></A><A NAME="PADx"></A><B><A HREF="#PADX">PADX</A>(i)
<A HREF="#PADY">PADY</A>(i)
<A HREF="#PADT">PADT</A>(i)</B>

i: <A HREF="#iexp">iexp</A>

These functions are available for reading the STE's paddle controllers.
Parameter 'i' can be 0 or 1 for the two supported paddles.

<A HREF="#PADX">PADX</A>(i) returns the x-position of the paddle.

<A HREF="#PADY">PADY</A>(i) returns the y-position of the paddle.

<A HREF="#PADT">PADT</A>(i) returns the status of the paddle buttons.
        <A HREF="#FALSE">FALSE</A> (0)  <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> not pressed
        <A HREF="#TRUE">TRUE</A>  (-1) -<A HREF="#&#62;">&#62;</A> pressed

<B>Memo:</B> Incorrectly detected on some machines based on the '_SND' cookie.
      <A HREF="#PADT">PADT</A><A HREF="#()">()</A> contains a bug in the library.

<HR SIZE=3><H2 ID="LPENX">LPENX</H2>
<A NAME="LPENY"></A><A NAME="LPENx"></A><B><A HREF="#LPENX">LPENX</A>
<A HREF="#LPENY">LPENY</A></B>

These functions are available for reading the STE's lightpen socket.

<A HREF="#LPENX">LPENX</A> returns the x-position of the lightpen.
      resolution: 0-319 regardless of the mode

LEPNY returns the y-position of the lightpen.
      resolution: 1:1 for all modes

<B>Memo:</B> Incorrectly detected on some machines based on the '_SND' cookie.
      Probably only works correctly in ST modes. Internally it uses the
      shifter value to calculate <A HREF="#LPENX">LPENX</A><A HREF="#.">.</A>
<HR SIZE=3><H2 ID="Printing">Printing</H2>
<A HREF="#LPRINT">LPRINT</A>
<A HREF="#LPOS">LPOS</A><A HREF="#()">()</A>
<A HREF="#HARDCOPY">HARDCOPY</A>
<HR SIZE=3><H2 ID="HARDCOPY">HARDCOPY</H2>
<A NAME="LPRINT"></A><A NAME="LPOS"></A><B><A HREF="#LPRINT">LPRINT</A> expression
<A HREF="#LPOS">LPOS</A>(x)
<A HREF="#HARDCOPY">HARDCOPY</A></B>

expression: <A HREF="#aexp">aexp</A> or <A HREF="#sexp">sexp</A>, arbitrarily mixed
x: <A HREF="#avar">avar</A> (dummy argument)

<A HREF="#LPRINT">LPRINT</A> is identical to the <A HREF="#PRINT">PRINT</A> command and its variants (LPRINT USING, etc.),
except that output goes to the printer instead of the screen, and it is not
possible to use the <A HREF="#PRINT_AT">PRINT AT</A> equivalent, as this would involve re-positioning
the print head. Similarly to <A HREF="#POS">POS</A><A HREF="#()">()</A>, <A HREF="#LPOS">LPOS</A>() returns the number of characters
printed since the last Carriage Return.

<A HREF="#HARDCOPY">HARDCOPY</A> causes a copy of the screen to be output to a suitable printer, in the
same way as by pressing the ALTernate-<A HREF="#Help">Help</A> keys. There is a driver for
non-Epson compatible 9 pin printers which, unlike <A HREF="#HARDCOPY">HARDCOPY</A> does not use
<A HREF="#XBIOS">XBIOS</A>(20)<A HREF="#.">.</A> It is activated by <A HREF="#SDPOKE">SDPOKE</A> &H4EE,0.

Some hard copy drivers don't react on routine <A HREF="#XBIOS">XBIOS</A>(20)<A HREF="#.">.</A> Frank Ostrowski made
last-minute changes to the <A HREF="#HARDCOPY">HARDCOPY</A> command. Now there is a <A HREF="#SPOKE">SPOKE</A> &H4EE,0 and a
<A HREF="#VSYNC">VSYNC</A> that should help even the worst cases.

<B>Examples:</B>

    <A HREF="#LPRINT">LPRINT</A>
    <A HREF="#LPRINT">LPRINT</A> "test"
    <A HREF="#PRINT">PRINT</A> <A HREF="#LPOS">LPOS</A>(x)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The word "test" comes out on the printer (if it is attached, switched on,
    and On-line) and the current print head position appears on the screen.

    <A HREF="#FOR">FOR</A> i%=20 TO 180 <A HREF="#STEP">STEP</A> 10
      <A HREF="#CIRCLE">CIRCLE</A> 320,200,i%
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#HARDCOPY">HARDCOPY</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Concentric circles are drawn on the screen, then a copy of the screen is
    made on the printer.

<B>Memo:</B> <A HREF="#LPRINT">LPRINT</A> does not work on an Atari Falcon030.

Scrdmp()<A HREF="#+">+</A>, v_hardcopy()+
<HR SIZE=3><H2 ID="Sound_Generation">Sound Generation</H2>
<A HREF="#SOUND">SOUND</A>
<A HREF="#WAVE">WAVE</A>
<A HREF="#DMACONTROL">DMACONTROL</A>, <A HREF="#DMASOUND">DMASOUND</A>
<A HREF="#MW_OUT">MW_OUT</A>
<HR SIZE=3><H2 ID="SOUND">SOUND</H2>
<A NAME="WAVE"></A><B><A HREF="#SOUND">SOUND</A> [chan,vol,note,octave,del]
<A HREF="#SOUND">SOUND</A> [chan,vol,#per,del]
<A HREF="#WAVE">WAVE</A> [voice,env,form,freq,del]</B>

chan, vol, note, octave, del, per, voice, env, form, freq: <A HREF="#iexp">iexp</A>

<A HREF="#SOUND">SOUND</A> and <A HREF="#WAVE">WAVE</A> serve to control the three-channel tone generator of the Atari
ST, the three channels having nothing to do with the data channels used to
communicate with peripheral devices and files. The parameters have the
following meanings:

    <B>chan</B>    Channel number (1 to 3)

    <B>vol</B>     Volume (0 to 15)

    <B>note</B>    Note (1 to 12) determines the note as follows:

            Note: 01  02  03  04  05  06  07  08  09  10  11  12
            Tone: C   C#  D   D#  E   F   F#  G   G#  A   A#  B

    <B>octave</B>  Octave (1 to 8)

    <B>del</B>     Delay in 1/50ths second before the next <A HREF="#GFA-Basic">GFA-Basic</A> command is
            executed.

    <B>per</B>     Period of the wave form multiplied by 125000. Thus for a given
            frequency, per=<A HREF="#ROUND">ROUND</A>(125000/frequency)<A HREF="#.">.</A> In the alternative form of
            the <A HREF="#SOUND">SOUND</A> command, #per can be used to replace the note and octave
            parameter, e.g. <A HREF="#SOUND">SOUND</A> 1,15,10,4,250 and SOUND 1,15,#284,250 both
            produce a tone of 440Hz. (Range 0 to 4095)

    <B>voice</B>   Channel combination: with <A HREF="#WAVE">WAVE</A>, any channel or combination of
            channels may be activated simultaneously. The value of 'voice' is
            256 multiplied by the period (0 to 31) of the noise generator, plus
            the sum of the following:

	    <U>Bit  Value  Description</U> (low byte)
            0     1     Channel 1 tone enable
            1     2     Channel 2 tone enable
            2     4     Channel 3 tone enable                noise enable
            3     8     Channel 1 noise enable               <A HREF="#&">&</A>#124;noise enable
            4    16     Channel 2 noise enable               <A HREF="#&#124;">&#124;</A><A HREF="#&">&</A>#124;noise enable
            5    32     Channel 3 noice enable               <A HREF="#&#124;">&#124;</A><A HREF="#&">&</A>#124;&#124;tone enable
            6    64     Port A: 0=input/1=output             <A HREF="#&#124;">&#124;</A><A HREF="#&">&</A>#124;&#124;&#124;tone enable
            7   128     Port B: 0=input/1=output             <A HREF="#&#124;">&#124;</A><A HREF="#&">&</A>#124;&#124;&#124;&#124;tone enable
                                                             <A HREF="#&#124;">&#124;</A><A HREF="#&">&</A>#124;&#124;&#124;&#124;&#124;
            This is a word constructed as follows: <A HREF="#-">-</A>--PPPPPBA321321
                                                      <A HREF="#&#124;">&#124;</A><A HREF="#&">&</A>#124;&#124;&#124;&#124;
                                        (0-31) noise period

    <B>env</B>     Specifies the channels for which the envelope shaper (see
            'form') is to be active. Its value is the sum of the following:

            <U>Bit  Value  Description</U>
            0    1      Channel 1                       channel 3
            1    2      Channel 2                       <A HREF="#&">&</A>#124;channel 2
            2    4      Channel 3                       <A HREF="#&#124;">&#124;</A><A HREF="#&">&</A>#124;channel 1
                                                        <A HREF="#&#124;">&#124;</A><A HREF="#&">&</A>#124;&#124;
            This is a byte constructed as follows: <A HREF="#-">-</A>----321 (Range: 0-3)

    <B>form</B>    Specifies the envelope shape (0 to 15) thus:

            <B>Bit    Value  Description                    Shape</B>
            00xx   0-3    same as 9
            01xx   4-7    same as 15
            1000     8    Falling saw tooth
            1001     9    Falling linearly
            1010    10    Triangle, beginning with fall
            1011    11    Falling linearly, then to max
            1100    12    Rising saw tooth
            1101    13    Rising linearly and holding
            1110    14    Triangle, beginning with rise
            1111    15    Linear rising, then to zero


            This is a byte constructed as follows: <A HREF="#-">-</A>---CAAH
                                                       <A HREF="#&#124;">&#124;</A><A HREF="#&">&</A>#124;&#124;&#124;
                                                       <A HREF="#&#124;">&#124;</A><A HREF="#&">&</A>#124;&#124;hold
                                                       <A HREF="#&#124;">&#124;</A><A HREF="#&">&</A>#124;alternate
                                                       <A HREF="#&">&</A>#124;atack
                                                       continue

    <B>freq</B>    Frequency of the wave form. (Range is 0-65535.)
            Controls the release of the envelope generator.

Tone generation is begun by the <A HREF="#SOUND">SOUND</A> or <A HREF="#WAVE">WAVE</A> command and ended by another
<A HREF="#SOUND">SOUND</A> or <A HREF="#WAVE">WAVE</A> command (SOUND 1,0,0,0,0 produces silence)<A HREF="#.">.</A> As the operating
system uses the sound chip to produce a keyboard click, this also terminates an
on-going sound output situation. The keyboard click can be disabled by:

    <A HREF="#SPOKE">SPOKE</A> &H484,<A HREF="#BCLR">BCLR</A>(<A HREF="#PEEK">PEEK</A>(&H484),0)

<A HREF="#.">.</A>..and enabled by:

    <A HREF="#SPOKE">SPOKE</A> &H484,<A HREF="#BSET">BSET</A>(<A HREF="#PEEK">PEEK</A>(&H484),0)

These two statements have the effect of setting bit 0 of memory location &H484
to zero or one respectively.

The period of the envelope is determined by the parameter 'del'<A HREF="#.">.</A>

With both <A HREF="#SOUND">SOUND</A> and <A HREF="#WAVE">WAVE</A>, the parameters are remembered, so that for subsequent
use with similar parameters, it is only necessary to specify parameters up to
the one that is to change: after <A HREF="#WAVE">WAVE</A> 7,7,0,10000,100, it is only necessary to
type <A HREF="#WAVE">WAVE</A> 1 to change the first parameter, leaving the others the same.

<B>Example:</B>

    <A HREF="#SOUND">SOUND</A> 1,15,1,4,20
    <A HREF="#SOUND">SOUND</A> 2,15,4,4,20
    <A HREF="#SOUND">SOUND</A> 3,15,8,4,20
    <A HREF="#WAVE">WAVE</A> 7,7,0,65535,300

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> A tone is produced with each channel and modulated by means of <A HREF="#WAVE">WAVE</A><A HREF="#.">.</A>

<B>Memo:</B> These commands use movep.w internally and could be fatal on a
      machine fitted with a 68060 cpu. No proper range checking on any of
      these parameters.

      <A HREF="#SOUND">SOUND</A> or <A HREF="#WAVE">WAVE</A> with no parameters, stops all sound.

      <A HREF="#SOUND">SOUND</A> command undocumented behavior:
        Channel: 0 is the same as channel 1.
        Volume:  16 allows envelope control like <A HREF="#WAVE">WAVE</A><A HREF="#.">.</A> (bit 4 <A HREF="#=">=</A> 1)

Dosound()<A HREF="#+">+</A>, Giaccess()+, The Programmable Sound Generator+
<HR SIZE=3><H2 ID="DMASOUND">DMASOUND</H2>
<A NAME="DMACONTROL"></A><B><A HREF="#DMACONTROL">DMACONTROL</A> ctrl
<A HREF="#DMASOUND">DMASOUND</A> beg,end,rate[,ctrl]</B>

beg, end, rate, ctrl: <A HREF="#iexp">iexp</A>

These commands allow sampled 8-bit DMA sound to be played on STE compatible
hardware.

The <A HREF="#DMACONTROL">DMACONTROL</A> command controls the method used to play back the sound as
follows:

    <B>Method        Bits  ctrl</B>
    Stop sound    %00   0
    Play once     %01   1
    <A HREF="#-">-</A>             %10   -
    Play in loop  %11   3

The <A HREF="#DMASOUND">DMASOUND</A> command causes the sound to be played. The parameters are as
follows:

    beg  <A HREF="#-">-</A> Sample starting address
    end  <A HREF="#-">-</A> Sample ending address
    rate <A HREF="#-">-</A> Sample rate:
           0 <A HREF="#=">=</A> 6.25 kHz  (not supported on the Atari Falcon030)
           1 <A HREF="#=">=</A> 12.5 kHz
           2 <A HREF="#=">=</A> 25 kHz
           3 <A HREF="#=">=</A> 50 kHz
    ctrl <A HREF="#-">-</A> See command <A HREF="#DMACONTROL">DMACONTROL</A> above.

<B>Example:</B>

    <A HREF="#'">'</A> Try each of the <A HREF="#DMASOUND">DMASOUND</A> lines for different effect.
    n%=360*32
    <A HREF="#DIM">DIM</A> a&#124;(n%)
    <A HREF="#'">'</A> <A HREF="#DMASOUND">DMASOUND</A> V:a&#124;(0),V:a&#124;(n%),0,3
    <A HREF="#'">'</A> <A HREF="#DMASOUND">DMASOUND</A> V:a&#124;(0),V:a&#124;(n%),1,3
    <A HREF="#'">'</A> <A HREF="#DMASOUND">DMASOUND</A> V:a&#124;(0),V:a&#124;(n%),2,3
    <A HREF="#DMASOUND">DMASOUND</A> V:a&#124;(0),V:a&#124;(n%),3,3
    <A HREF="#FOR">FOR</A> i%=0 TO n%
      a&#124;(i%)=128+<A HREF="#SINQ">SINQ</A>(i%*i%/7200)*127
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#REPEAT">REPEAT</A>
    <A HREF="#UNTIL">UNTIL</A> <A HREF="#MOUSEK">MOUSEK</A>
    <A HREF="#DMACONTROL">DMACONTROL</A> 0

<B>Memo:</B> Sound playback can be prematurely halted with <A HREF="#DMACONTROL">DMACONTROL</A> 0.

      The <A HREF="#DMASOUND">DMASOUND</A> command could allow 16-bit playback on the Falcon030 if
      bit 6 was set in the rate, however GFA clobbers that bit assuming it
      won't ever be used.

      The <A HREF="#DMASOUND">DMASOUND</A> command can be used to play mono sound samples if bit 7 is
      set to 'on' in the rate parameter. Example: rate&<A HREF="#=">=</A><A HREF="#BSET">BSET</A>(rate&,7)

      DMA sound data format: signed (-128 to 127) 8-bit PCM

      Mono: sample must be of even length
      Stereo 8-bit: word (15--left--8/7--right--0)

      <A HREF="#DMASOUND">DMASOUND</A> defaults to 'play in loop' due to a bug if ctrl is omitted.

      <A HREF="#DMASOUND">DMASOUND</A> does not work if the sample buffer is located in fastram!
      Care must be taken when allocating sample buffers and also pay close
      attention to the program header flags when compiling.

      If you use the <A HREF="#XBIOS">XBIOS</A> sound functions, the program header flags must be
      set Global or Super, otherwise a call to Buffoper() results in a crash.

The Falcon030 Sound System+, Locksnd()+, Unlocksnd()+, Soundcmd()+,
Setbuffer()<A HREF="#+">+</A>, Setmode()+, Settracks()+, Setmontracks()+, Setinterrupt()+,
Buffoper()<A HREF="#+">+</A>, Dsptristate()+, Gpio()+, Devconnect()+, Sndstatus()+, Buffptr()+
<HR SIZE=3><H2 ID="MW_OUT">MW_OUT</H2>
<B><A HREF="#MW_OUT">MW_OUT</A> mask,data</B>

mask, data: <A HREF="#iexp">iexp</A>

This command controls the STE Internal Micro Wire Interface, and is used for
controlling sound.

<A HREF="#MW_OUT">MW_OUT</A> &H7FF,x

    x=&X10 011 ddd ddd  Set Master Volume
               000 000  -80 dB
               010 100  -40 dB
               101 xxx    0 dB

    The value of the last 5 Bits is equivalent to Half of the volume in dB.

    x=&X10 101 xdd ddd  Set Front Left Channel
    x=&X10 100 xdd ddd  Set Front Right Channel
    x=&X10 111 xdd ddd  Set Rear Left Channel (reserved)
    x=&X10 110 xdd ddd  Set Rear Right Channel (reserved)
                00 000  -40 dB
                01 010  -20 dB
                10 1xx    0 dB

    The last 4 Bits*2 <A HREF="#=">=</A> dB

    x=&X10 010 xxd ddd  Set Treble
    x=&X10 001 xxd ddd  Set Bass
                 0 000  -12 dB
                 0 110    0 dB (flat)
                 1 100  +12 dB

    x=&X10 000 xxx xdd  Set Mix (input select)
                    00  -12 dB
                    01  Mix GI sound (normal ST)
                    10  Reserved
                    11  Reserved

<B>Example:</B>

    <A HREF="#MW_OUT">MW_OUT</A> &H7FF,&X10000000010 !Switches the ST's sound off.

<B>Memo:</B> This command seems to be fatal (locks up) from the editor if used
      on non-STE hardware. Internally it does not check the hardware at all.
      The library version does check the hardware.
<HR SIZE=3><H2 ID="Chapter__7_-_Program_Structure">Chapter  7 - Program Structure</H2>
In this chapter the commands used for controlling the execution of a program
are discussed, starting with <A HREF="#'">'</A><A HREF="#Decision_Commands">Decision Commands</A>', by means of which the
execution of certain program sections is carried out only if certain criteria
are met. In the case of <A HREF="#IF">IF</A>, <A HREF="#THEN">THEN</A>, <A HREF="#ELSE">ELSE</A>, <A HREF="#ENDIF">ENDIF</A>, and <A HREF="#ELSE_IF">ELSE IF</A>, the criterion is a
logical one: BASIC checks if a logical expression is true or false, in addition
to these are the multiple decision commands <A HREF="#SELECT">SELECT</A>, <A HREF="#CASE">CASE</A>, <A HREF="#DEFAULT">DEFAULT</A>, <A HREF="#ENDSELECT">ENDSELECT</A>,
and <A HREF="#CONT">CONT</A><A HREF="#.">.</A> These not only check for true or false, but can accept arbitrary
values which can be reacted to selectively.

The next section covers the loop commands, which make the repeated execution of
specified sections of a program possible. <A HREF="#GFA-Basic">GFA-Basic</A> 3 is provided with a very
large number of such loop types: <A HREF="#FOR">FOR</A>-TO-<A HREF="#STEP">STEP</A>-<A HREF="#NEXT">NEXT</A>, <A HREF="#REPEAT">REPEAT</A>-<A HREF="#UNTIL">UNTIL</A>, <A HREF="#DO">DO</A>-<A HREF="#LOOP">LOOP</A> or
ENDLOOP, <A HREF="#DO">DO</A><A HREF="#-">-</A><A HREF="#WHILE">WHILE</A>, DO-<A HREF="#UNTIL">UNTIL</A>, LOOP-WHILE, LOOP-UNTIL, and <A HREF="#EXIT_IF">EXIT IF</A><A HREF="#.">.</A>

For structured programming the use of sub-routines is of great importance.
With the commands <A HREF="#PROCEDURE">PROCEDURE</A>, <A HREF="#GOSUB">GOSUB</A> (or <A HREF="#@">@</A>), and <A HREF="#RETURN">RETURN</A> (or <A HREF="#ENDSUB">ENDSUB</A>) new
'commands' can be created in the form of subroutines.

Functions may also be defined by the user. With the commands <A HREF="#DEFFN">DEFFN</A> and <A HREF="#FN">FN</A>
functions are created like formulas. More flexibility is possible with the
commands <A HREF="#FUNCTION">FUNCTION</A>, <A HREF="#ENDFUNC">ENDFUNC</A>, and <A HREF="#RETURN">RETURN</A>, which allow the formation of complete
subroutines that return a value.

Also in this section is a detailed description of the way in which variables
are dealt with by subroutines. Local variables may be declared with <A HREF="#LOCAL">LOCAL</A>, with
the effect that they are only valid in that subroutine.  Variables of the same
name in other parts of the program are unaffected.  Variables can be passed to
subroutines as values, or, with the <A HREF="#VAR">VAR</A> command, the variable itself can be
passed (called by reference), and its value changed without the need to refer
to it directy by name in the subroutine.

The section on conditional branches also explains the commands which deal with
the following two special events: the simultaneous pressing of the 'break keys'
Control-Shift-Alternate, which normally stop a program; and the error situation
which occurs when, for example, an attempt is made to divide by zero, or to
take the square root of a negative number etc. Both of these events can be made
to trigger the execution of a user-defined routine, instead of stopping the
program.

It is possible in <A HREF="#GFA-Basic">GFA-Basic</A> 3 to call a subroutine when a specified amount of
time has elapsed, using the commands <A HREF="#EVERY">EVERY</A> and <A HREF="#AFTER">AFTER</A><A HREF="#.">.</A> This is explained in this
chapter.

Towards the end of the chapter the absolute branch <A HREF="#GOTO">GOTO</A>, the commands <A HREF="#PAUSE">PAUSE</A> and
<A HREF="#DELAY">DELAY</A>, which temporarily suspend program execution, as well as different
methods of ending the program (<A HREF="#QUIT">QUIT</A>, <A HREF="#SYSTEM">SYSTEM</A>, <A HREF="#END">END</A>, <A HREF="#EDIT">EDIT</A>, <A HREF="#NEW">NEW</A>, and <A HREF="#STOP">STOP</A>) are
presented. The last section covers the commands for monitoring the execution of
a program (<A HREF="#TRON">TRON</A>, <A HREF="#TROFF">TROFF</A>, <A HREF="#TRON_proc">TRON proc</A>, <A HREF="#TRACE$">TRACE$</A>, <A HREF="#DUMP">DUMP</A>, <A HREF="#ERR$">ERR$</A><A HREF="#()">()</A>, and <A HREF="#ERROR">ERROR</A>)<A HREF="#.">.</A>
<HR SIZE=3><H2 ID="Decision_Commands">Decision Commands</H2>
<A HREF="#IF">IF</A>, <A HREF="#THEN">THEN</A>
<A HREF="#ELSE_IF">ELSE IF</A>
<A HREF="#ELSE">ELSE</A>
<A HREF="#ENDIF">ENDIF</A>
<HR SIZE=3><H2 ID="IF">IF</H2>
<A NAME="THEN"></A><A NAME="ELSE"></A><A NAME="ENDIF"></A><A NAME="IF-ENDIF"></A><B><A HREF="#IF">IF</A> condition [<A HREF="#THEN">THEN</A>]
  (instructions)
<A HREF="#ELSE">ELSE</A>
  (instructions)
<A HREF="#ENDIF">ENDIF</A></B>

condition: <A HREF="#bexp">bexp</A>

These commands enable one to specify that a section of a program will only be
executed if a logical condition is met. The following example demonstrates
this:

    <A HREF="#IF">IF</A> a=1 <A HREF="#THEN">THEN</A>
      <A HREF="#PRINT">PRINT</A> "a is equal to 1"
      b=2
    <A HREF="#ENDIF">ENDIF</A>

In this case a=1 is the logical condition. The instructions in the lines
between <A HREF="#IF">IF</A> and <A HREF="#ENDIF">ENDIF</A> are processed <B>only</B> if this logical condition is
met.  If it is untrue, then the program continues with the commands after the
<A HREF="#ENDIF">ENDIF</A> and the command <A HREF="#THEN">THEN</A> is not considered. It should be noted that it is
sufficient to use the form:

    <A HREF="#IF">IF</A> a=1   instead of   IF a=1 <A HREF="#THEN">THEN</A>

The following construction is somewhat more complex:

    <A HREF="#IF">IF</A> a=1
      <A HREF="#PRINT">PRINT</A> "a is equal to 1"
    <A HREF="#ELSE">ELSE</A>
      <A HREF="#PRINT">PRINT</A> "a is not equal to 1,"
      <A HREF="#PRINT">PRINT</A> "it is equal to ";a
    <A HREF="#ENDIF">ENDIF</A>

In this case shown above, the instructions between <A HREF="#IF">IF</A> and <A HREF="#ELSE">ELSE</A> are processed if
the logical condition after the <A HREF="#IF">IF</A> is true. The program then continues
execution after the <A HREF="#ENDIF">ENDIF</A><A HREF="#.">.</A> However, if the condition after <A HREF="#IF">IF</A> is not fulfilled,
then the instructions between <A HREF="#ELSE">ELSE</A> and <A HREF="#ENDIF">ENDIF</A> become effective. Again, program
execution is continued after the <A HREF="#ENDIF">ENDIF</A><A HREF="#.">.</A>

<B>Note:</B> Any numerical expression, which is not equal to 0, i.e. is <A HREF="#FALSE">FALSE</A>, is
      considered to be true. The logical value for <A HREF="#TRUE">TRUE</A> is -1 but any non-zero
      value is considered to be equivalent.

<B>Example:</B>

    x=1
    <A HREF="#IF">IF</A> x
      <A HREF="#PRINT">PRINT</A> "x is true"
    <A HREF="#ENDIF">ENDIF</A>
    <A HREF="#INPUT">INPUT</A> y
    <A HREF="#IF">IF</A> x=9 <A HREF="#OR">OR</A> <A HREF="#ODD">ODD</A>(y)
      <A HREF="#PRINT">PRINT</A> "y is an odd number"
    <A HREF="#ELSE">ELSE</A>
      <A HREF="#PRINT">PRINT</A> "y is an even number"
    <A HREF="#ENDIF">ENDIF</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> First the message 'x is true' is displayed and then a numeric input is
    requested. Since x cannot be 9, the text appears 'y is an odd number', if
    you have entered an odd number, otherwise 'y is an even' is displayed.

<B>Memo:</B> This fails compiled:
      <A HREF="#IF">IF</A> <A HREF="#FALSE">FALSE</A>  !the entire <A HREF="#IF-ENDIF">IF-ENDIF</A> structure ends up missing!
      <A HREF="#ENDIF">ENDIF</A>
      Seems ok in the interpreter.
<HR SIZE=3><H2 ID="ELSE_IF">ELSE IF</H2>
<B><A HREF="#ELSE_IF">ELSE IF</A> condition</B>

condition: <A HREF="#bexp">bexp</A>

The command <A HREF="#ELSE_IF">ELSE IF</A> enables nested <A HREF="#IF">IF</A>'s to be more clearly expressed in a
program. The following examples show a simple menu selection made on a single
key-press. If l, s, or e is pressed then, respectively, a load, save or, input
routine is called. In all other cases the message 'unknown command' is printed.
The normal nested version is as follows:

    <A HREF="#DO">DO</A>
      t$<A HREF="#=">=</A><A HREF="#CHR$">CHR$</A>(<A HREF="#INP">INP</A>(2))
      <A HREF="#'">'</A>
      <A HREF="#IF">IF</A> t$<A HREF="#=">=</A>"l"
        <A HREF="#PRINT">PRINT</A> "Load text"
      <A HREF="#ELSE">ELSE</A>
        <A HREF="#IF">IF</A> t$<A HREF="#=">=</A>"s"
          <A HREF="#PRINT">PRINT</A> "Save text"
        <A HREF="#ELSE">ELSE</A>
          <A HREF="#IF">IF</A> t$<A HREF="#=">=</A>"e"
            <A HREF="#PRINT">PRINT</A> "Enter text"
          <A HREF="#ELSE">ELSE</A>
            <A HREF="#PRINT">PRINT</A> "unknown command"
          <A HREF="#ENDIF">ENDIF</A>
        <A HREF="#ENDIF">ENDIF</A>
      <A HREF="#ENDIF">ENDIF</A>
      <A HREF="#'">'</A>
    <A HREF="#LOOP">LOOP</A>

The use of <A HREF="#ELSE_IF">ELSE IF</A> produces a shorter listing with smaller program indents:

    <A HREF="#DO">DO</A>
      t$<A HREF="#=">=</A><A HREF="#CHR$">CHR$</A>(<A HREF="#INP">INP</A>(2))
      <A HREF="#'">'</A>
      <A HREF="#IF">IF</A> t$<A HREF="#=">=</A>"l"
        <A HREF="#PRINT">PRINT</A> "Load text"
      <A HREF="#ELSE_IF">ELSE IF</A> t$<A HREF="#=">=</A>"s"
        <A HREF="#PRINT">PRINT</A> "Save text"
      <A HREF="#ELSE_IF">ELSE IF</A> t$<A HREF="#=">=</A>"e"
        <A HREF="#PRINT">PRINT</A> "Enter text"
      <A HREF="#ELSE">ELSE</A>
        <A HREF="#PRINT">PRINT</A> "unknown command"
      <A HREF="#ENDIF">ENDIF</A>
      <A HREF="#'">'</A>
    <A HREF="#LOOP">LOOP</A>

The program works in the following way:

If the condition after <A HREF="#IF">IF</A> is fulfilled (t$<A HREF="#=">=</A>"l"), then the instructions between
<A HREF="#IF">IF</A> and the next <A HREF="#ELSE_IF">ELSE IF</A> are processed <A HREF="#-">-</A> <A HREF="#PRINT">PRINT</A> "Load text" - and then the
program jumps to the command <A HREF="#ENDIF">ENDIF</A><A HREF="#.">.</A> If the condition for the first <A HREF="#IF">IF</A> is not
true then the other <A HREF="#IF">IF</A>'s are encountered.

In the second case, if the condition after the <A HREF="#ELSE_IF">ELSE IF</A> command is met, then all
instructions up to the next <A HREF="#ELSE">ELSE</A>, <A HREF="#ELSE_IF">ELSE IF</A> or <A HREF="#ENDIF">ENDIF</A> (if no ELSE exists) are
proeessed and the program jumps to the instruction after <A HREF="#ENDIF">ENDIF</A><A HREF="#.">.</A> If neither the
condition after the <A HREF="#IF">IF</A> or the condition after <A HREF="#ELSE_IF">ELSE IF</A> is true, then the
commands between <A HREF="#ELSE">ELSE</A> and <A HREF="#ENDIF">ENDIF</A> are implemented (if an ELSE exists)<A HREF="#.">.</A>
<HR SIZE=3><H2 ID="Multiple_Branching">Multiple Branching</H2>
<A HREF="#ON_GOSUB">ON GOSUB</A>
<A HREF="#SELECT">SELECT</A> (<A HREF="#SWITCH">SWITCH</A>), <A HREF="#CASE">CASE</A>, <A HREF="#CONT">CONT</A>, <A HREF="#DEFAULT">DEFAULT</A> (<A HREF="#OTHERWISE">OTHERWISE</A>), <A HREF="#ENDSELECT">ENDSELECT</A> (<A HREF="#ENDSWITCH">ENDSWITCH</A>)
<HR SIZE=3><H2 ID="ON_GOSUB">ON GOSUB</H2>
<B>ON x <A HREF="#GOSUB">GOSUB</A> proc1,proc2, <A HREF="#.">.</A>..</B>

x: <A HREF="#iexp">iexp</A>
proc1, proc2: procedure name witbout parameter

This command branches the program to a procedure, which is in the list
specified after <A HREF="#GOSUB">GOSUB</A><A HREF="#.">.</A> The x is a numerical (normally integer) expression,
whose decimal part (if any) is ignored. If x is smaller than 1 or larger than
the number of the procedure names after the <A HREF="#GOSUB">GOSUB</A>, then no subroutine is
called. After calling the subroutine the program execution is continued
immediately after the ON x <A HREF="#GOSUB">GOSUB</A><A HREF="#.">.</A> With this command no parameters can be passed
to the procedure.

<B>Example:</B>

    x=3
    ON x <A HREF="#GOSUB">GOSUB</A> proc1,proc2,proc3
    x=1
    ON x+1 <A HREF="#GOSUB">GOSUB</A> proc1,proc2,proc3,proc4

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> First the procedure proc3 is called, then the procedure proc2.

<B>Memo:</B> If the procedure used with <A HREF="#ON_GOSUB">ON GOSUB</A> is undefined the compiler will
      not issue and error message.  Instead the compiler writes a bad binary
      where <A HREF="#ON_GOSUB">ON GOSUB</A> is translated into JSR 0.l!
<HR SIZE=3><H2 ID="SELECT">SELECT</H2>
<A NAME="SWITCH"></A><A NAME="CASE"></A><A NAME="CONT"></A><A NAME="DEFAULT"></A><A NAME="ENDSELECT"></A><A NAME="ENDSWITCH"></A><A NAME="OTHERWISE"></A><B><A HREF="#SELECT">SELECT</A> x
<A HREF="#CASE">CASE</A> y [TO z] or CASE y [,z, <A HREF="#.">.</A>..]
  (instructions)
  <A HREF="#CONT">CONT</A>
<A HREF="#CASE">CASE</A> TO y
  (instructions)
<A HREF="#CASE">CASE</A> y TO
  (instructions)
<A HREF="#DEFAULT">DEFAULT</A>
  (instructions)
<A HREF="#ENDSELECT">ENDSELECT</A></B>

x, y, z: <A HREF="#iexp">iexp</A> or string-constant with a maximum length of 4 characters

The command <A HREF="#SELECT">SELECT</A> makes branching possible using the <A HREF="#CASE">CASE</A> command, on the
basis of the value of the numerical expression x. The following examples give
an explanation of the program structure that results:

    x=0
    <A HREF="#SELECT">SELECT</A> x+2
    <A HREF="#CASE">CASE</A> 1
      <A HREF="#PRINT">PRINT</A> "x is equal to 1"
    <A HREF="#CASE">CASE</A> 2 TO 4
      <A HREF="#PRINT">PRINT</A> "x is equal to 2, 3, or 4"
    <A HREF="#CASE">CASE</A> 5,6
      <A HREF="#PRINT">PRINT</A> "x is equal to 5 or 6"
    <A HREF="#DEFAULT">DEFAULT</A>
      <A HREF="#PRINT">PRINT</A> "x is not equal to 1, 2, 3, 4, 5, or 6"
    <A HREF="#ENDSELECT">ENDSELECT</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The message 'x is equal to 2, 3, or 4' is displayed.

First the numerical expression after <A HREF="#SELECT">SELECT</A> is evaluated, which is the branch
condition, in this case 2. Then the various <A HREF="#CASE">CASE</A> instructions are gone through
and checked as to whether the current value of the branch condition is to be
found.

In this example the argument '1' follows the first <A HREF="#CASE">CASE</A> command. Since the
branch condition is 2, the program jumps to the next <A HREF="#CASE">CASE</A><A HREF="#.">.</A>

After the second <A HREF="#CASE">CASE</A> are the arguments '2 TO 4'<A HREF="#.">.</A> As the value of x falls
within this range the condition is fulfilled and the message printed on the
screen. After that, program execution continues after the command <A HREF="#ENDSELECT">ENDSELECT</A>.
After the third <A HREF="#CASE">CASE</A> command is a further variant of the possible arguments for
the <A HREF="#SELECT">SELECT</A> command. There the desired values are separated, in a list, by
commas.

If none of the current branch criterion after the various <A HREF="#CASE">CASE</A> commands is met,
then the instructions between <A HREF="#DEFAULT">DEFAULT</A> and <A HREF="#ENDSELECT">ENDSELECT</A> are executed (assuming a
<A HREF="#DEFAULT">DEFAULT</A> is present)<A HREF="#.">.</A> In addition, instead of DEFAULT, <A HREF="#OTHERWISE">OTHERWISE</A> can be used
(giving compatibility with other BASICs) but the GFA interpreter replaces it
with <A HREF="#DEFAULT">DEFAULT</A> automatically.

Also, after <A HREF="#CASE">CASE</A> commands, not only numeric values but also strings may be used
as the argument. These may have a maximum length of four characters. If only
one character is specified then its <A HREF="#ASCII">ASCII</A> value is used as the branch
criterion. If two characters are specified, then this value is calculated as
follows:

    <A HREF="#ASCII">ASCII</A> value of first character <A HREF="#+">+</A> 255 <A HREF="#*">*</A> ASCII value the second character.

    <A HREF="#.">.</A>..and so on for the third and fourth characters.

<B>Note:</B> The maximum length of <A HREF="#CASE">CASE</A> is 4 characters, i.e. CASE "ABCD".

<B>Example:</B>

    exit!<A HREF="#=">=</A><A HREF="#FALSE">FALSE</A>
    <A HREF="#REPEAT">REPEAT</A>
      key%<A HREF="#=">=</A><A HREF="#INP">INP</A>(2)
      <A HREF="#SELECT">SELECT</A> key%
      <A HREF="#CASE">CASE</A> "a" TO "z"
        <A HREF="#PRINT">PRINT</A> "the lower-case letter "<A HREF="#+">+</A><A HREF="#CHR$">CHR$</A>(key%)+" was entered"
      <A HREF="#CASE">CASE</A> "A" TO "Z"
        <A HREF="#PRINT">PRINT</A> "the upper-case letter "<A HREF="#+">+</A><A HREF="#CHR$">CHR$</A>(key%) +" was entered"
      <A HREF="#CASE">CASE</A> 27
        exit!<A HREF="#=">=</A><A HREF="#TRUE">TRUE</A> !program ends when <A HREF="#&">&</A>#60;Esc&#62; key is pressed
      <A HREF="#DEFAULT">DEFAULT</A>
        <A HREF="#PRINT">PRINT</A> "an inadmissible key was pressed!"
      <A HREF="#ENDSELECT">ENDSELECT</A>
    <A HREF="#UNTIL">UNTIL</A> exit!

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Within a loop the keyboard is queried and the program jumps according to
    which key was pressed and the appropriate message is displayed. Pressing
    the Esc key is used as an abort criterion for the loop.

The next example illustrates the meaning of the <A HREF="#CONT">CONT</A> command, which is
effective if it comes before a <A HREF="#CASE">CASE</A> or <A HREF="#DEFAULT">DEFAULT</A> command. This <A HREF="#CONT">CONT</A> command must
not be confused with the command of the same name used for resuming execution
of an interrupted program run.

<B>Example:</B>

    x=1
    <A HREF="#SELECT">SELECT</A> x
    <A HREF="#CASE">CASE</A> 1
      <A HREF="#PRINT">PRINT</A> "x is equal to 1"
      <A HREF="#CONT">CONT</A>
    <A HREF="#CASE">CASE</A> 2
      <A HREF="#PRINT">PRINT</A> "x is equal to 2"
    <A HREF="#CASE">CASE</A> 1,3
      <A HREF="#PRINT">PRINT</A> "x is equal to 3"
    <A HREF="#DEFAULT">DEFAULT</A>
      <A HREF="#PRINT">PRINT</A> "x is not equal to 1, 2, or 3"
    <A HREF="#ENDSELECT">ENDSELECT</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Displays 'x is equal to 1' and then 'x is equal to 2'<A HREF="#.">.</A>

The <A HREF="#CONT">CONT</A> command provides a method of jumping over a <A HREF="#CASE">CASE</A> or <A HREF="#DEFAULT">DEFAULT</A> command.
In this example the value x is equal to the argument after the first <A HREF="#CASE">CASE</A>, i.e.
x=1. Therefore the message "x is equal to 1" is printed. Then comes the <A HREF="#CONT">CONT</A>
command, which jumps over the line <A HREF="#CASE">CASE</A> 2 and, although the branch condition is
not fulfilled, the <A HREF="#CONT">CONT</A> command causes the instruction <A HREF="#PRINT">PRINT</A> "x being equal to
2" to be implemented. The normal processing continues with processing jumping
to the <A HREF="#ENDSELECT">ENDSELECT</A> command.

<B>Example:</B>

    <A HREF="#SELECT">SELECT</A> <A HREF="#INP">INP</A>(2)
    <A HREF="#CASE">CASE</A> "a" TO "g"
      <A HREF="#PRINT">PRINT</A> "a to g"
    <A HREF="#DEFAULT">DEFAULT</A>
      <A HREF="#PRINT">PRINT</A> "default"
    <A HREF="#ENDSELECT">ENDSELECT</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> If you press one of the a, b, c, d, e, f, or g keys the text 'a to g' is
    displayed, with any other key (except the shift keys) the message 'default'
    is printed.

With the <A HREF="#CASE">CASE</A> command a number of different possibilities can be combined, it
is not necessary for them to be written separately:

    <A HREF="#SELECT">SELECT</A> a$
    <A HREF="#CASE">CASE</A> "a" TO "z"
      <A HREF="#CONT">CONT</A>
    <A HREF="#CASE">CASE</A> "A" TO "Z"
      <A HREF="#CONT">CONT</A>
    <A HREF="#CASE">CASE</A> "ae","oe","ue","ss","Ae","Oe","Ue"
      <A HREF="#PRINT">PRINT</A> "OK"
    <A HREF="#ENDSELECT">ENDSELECT</A>

and similarly with ranges:

    <A HREF="#SELECT">SELECT</A> a$
    <A HREF="#CASE">CASE</A> "a" TO "z","A" TO "Z","ae","oe","ue",<A HREF="#.">.</A>..
    <A HREF="#.">.</A>..
    <A HREF="#.">.</A>..

<B>Memo:</B> For compiler options see sections <A HREF="#'">'</A><A HREF="#SELECT-CASE_Parameter">SELECT-CASE Parameter</A>' and
      <A HREF="#'">'</A><A HREF="#SELECT-CASE_Optimisation">SELECT-CASE Optimisation</A>'<A HREF="#.">.</A>

      The editor will accept this <A HREF="#CASE">CASE</A> """" however moving the cursor over the
      line will cause strange behavior.

      <A HREF="#CONT">CONT</A> must proceed a <A HREF="#CASE">CASE</A> or <A HREF="#DEFAULT">DEFAULT</A> command or it will not work at all.
      Even a comment between them will cause it to fail.

      The editor will allow this:
      <A HREF="#SELECT">SELECT</A> x
      <A HREF="#PRINT">PRINT</A>     !code placed here won't be executed (dead code)
      <A HREF="#CASE">CASE</A> 1
      <A HREF="#CASE">CASE</A> 2
      <A HREF="#ENDSELECT">ENDSELECT</A>

      <A HREF="#SELECT">SELECT</A> x
      <A HREF="#DEFAULT">DEFAULT</A>          !default is always executed
        <A HREF="#PRINT">PRINT</A> "hello"
      <A HREF="#ENDSELECT">ENDSELECT</A>
<HR SIZE=3><H2 ID="Loops">Loops</H2>
<A HREF="#FOR">FOR</A>, TO, <A HREF="#STEP">STEP</A>, <A HREF="#DOWNTO">DOWNTO</A>, <A HREF="#NEXT">NEXT</A> (<A HREF="#ENDFOR">ENDFOR</A>)
<A HREF="#REPEAT">REPEAT</A>, <A HREF="#UNTIL">UNTIL</A> (<A HREF="#ENDREPEAT">ENDREPEAT</A>)
<A HREF="#WHILE">WHILE</A>, <A HREF="#WEND">WEND</A> (<A HREF="#ENDWHILE">ENDWHILE</A>)
<A HREF="#DO">DO</A>, <A HREF="#LOOP">LOOP</A> (<A HREF="#ENDDO">ENDDO</A>)
<A HREF="#DO_WHILE">DO WHILE</A>, <A HREF="#DO_UNTIL">DO UNTIL</A>
<A HREF="#LOOP_WHILE">LOOP WHILE</A>, <A HREF="#LOOP_UNTIL">LOOP UNTIL</A>
<A HREF="#EXIT_IF">EXIT IF</A>

<A HREF="#GFA-Basic">GFA-Basic</A> 3 is provided with an unusually large selection of loop types.
Normally one differentiates between 'entry testing' and 'exit testing' loops.
'Entry testing' loops are those, such as <A HREF="#WHILE">WHILE</A><A HREF="#-">-</A><A HREF="#WEND">WEND</A>, in which the abort
condition for the loop is checked before entry into the loop. While with 'exit
testing loops', such as <A HREF="#FOR">FOR</A><A HREF="#-">-</A><A HREF="#NEXT">NEXT</A>, this condition is examined at the end of the
loop, consequently such are gone through at least once. A special loop type,
<A HREF="#DO">DO</A><A HREF="#-">-</A><A HREF="#LOOP">LOOP</A>, is also available in <A HREF="#GFA-Basic">GFA-Basic</A><A HREF="#.">.</A> This type acts as a continuous loop
without an abort condition. In <A HREF="#GFA-Basic">GFA-Basic</A> this command can be very flexibly
used. Both after <A HREF="#DO">DO</A> and after <A HREF="#LOOP">LOOP</A> the extensions <A HREF="#WHILE">WHILE</A> and <A HREF="#UNTIL">UNTIL</A> can be used
so that the loops begin or end with a logical condition. In all of the loop
types mentioned here, as many as abort conditions as required may be used in
the loop body using the <A HREF="#EXIT_IF">EXIT IF</A> command.

<B>Memo:</B> For compiler optimizations see section <A HREF="#'">'</A><A HREF="#Loop_Commands">Loop Commands</A>'
<HR SIZE=3><H2 ID="FOR">FOR</H2>
<A NAME="STEP"></A><A NAME="DOWNTO"></A><A NAME="NEXT"></A><A NAME="ENDFOR"></A><B><A HREF="#FOR">FOR</A> c=b TO e [<A HREF="#STEP">STEP</A> s]
  (instructions)
<A HREF="#NEXT">NEXT</A> i
<A HREF="#FOR">FOR</A> c=b <A HREF="#DOWNTO">DOWNTO</A> e
  (instructions)
<A HREF="#NEXT">NEXT</A> i</B>

c: <A HREF="#avar">avar</A>
b, e, s: <A HREF="#aexp">aexp</A>

The <A HREF="#FOR">FOR</A><A HREF="#-">-</A><A HREF="#NEXT">NEXT</A> command (also called a counting loop) is used for repeated
processing a group of instructions between the commands <A HREF="#FOR">FOR</A> and <A HREF="#NEXT">NEXT</A><A HREF="#.">.</A> For this
purpose the count variable c is incremented (or decremented), beginning with
the initial value b, as far as the end value 'e'<A HREF="#.">.</A>

The instructions in the loop body are gone through, until <A HREF="#NEXT">NEXT</A> is reached.
There the count variable c is increased by the value s given after <A HREF="#STEP">STEP</A><A HREF="#.">.</A> If no
<A HREF="#STEP">STEP</A> value is given, then an increment of one is assumed. Next c is checked to
see whether it has exceeded the value e. If this is the case, the loop is
exited and the program continued with the command after the <A HREF="#NEXT">NEXT</A><A HREF="#.">.</A> If not, the
program loops back again to the first instruction, this process is repeated,
until c is larger than e. A consequence of this exit method is that c, after
the loop is left, is equal to e+s, i.e. the first value which exceeds the abort
criterion. Also, the contents of a <A HREF="#FOR">FOR</A><A HREF="#-">-</A><A HREF="#NEXT">NEXT</A> loop will always be gone through at
least once.

<B>Note:</B> In place of a <A HREF="#STEP">STEP</A> value of -1 the command <A HREF="#DOWNTO">DOWNTO</A> can be used instead
      of TO. However, with <A HREF="#DOWNTO">DOWNTO</A> the use of <A HREF="#STEP">STEP</A> is not possible.

In general, for the count variable c one should use integer variables, because
thereby the loop can be processed more quickly than with floating-point
variables. This is naturally not possible with non-integer <A HREF="#STEP">STEP</A> increments. In
place of the command <A HREF="#NEXT">NEXT</A> followed by the count variable, the command <A HREF="#ENDFOR">ENDFOR</A> i%
can be used, but the Interpreter automatically replaces it with <A HREF="#NEXT">NEXT</A> i%<A HREF="#.">.</A>

<B>Examples:</B>

    <A HREF="#FOR">FOR</A> c=1 TO 10
      <A HREF="#PRINT">PRINT</A> c'
    <A HREF="#NEXT">NEXT</A> c
    <A HREF="#FOR">FOR</A> c=-1 <A HREF="#DOWNTO">DOWNTO</A> -10
      <A HREF="#PRINT">PRINT</A> c'
    <A HREF="#NEXT">NEXT</A> c

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Displays on the screen, the numbers:
    1 2 3 4 5 6 7 8 9 10 -1 -2 -3 -4 -5 -6 -7 -8 -9 -10

    a$<A HREF="#=">=</A>"T*e*s*t*w*o*r*d"
    <A HREF="#FOR">FOR</A> j=1 TO <A HREF="#LEN">LEN</A>(a$) <A HREF="#STEP">STEP</A> 2
      <A HREF="#PRINT">PRINT</A> <A HREF="#MID$">MID$</A>(a$,j,1)<A HREF="#;">;</A>
    <A HREF="#NEXT">NEXT</A> j

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Displays the word 'Testword' on the screen.

<B>Memo:</B> For compiler options see section <A HREF="#'">'</A><A HREF="#FOR-NEXT_Loop_Checking">FOR-NEXT Loop Checking</A>'<A HREF="#.">.</A>

      A <A HREF="#FOR">FOR</A><A HREF="#-">-</A><A HREF="#NEXT">NEXT</A> loop going backwards with a byte&#124; counter using <A HREF="#STEP">STEP</A> will
      completely fail when compiled. Such a loop will work in the interpreter
      however. Somehow the loop ends up missing entirely when compiled!

      <A HREF="#FOR">FOR</A> i&#124;=200 TO 100 <A HREF="#STEP">STEP</A> -1  !does not work compiled
        <A HREF="#PRINT">PRINT</A> i&#124;;",";
      <A HREF="#NEXT">NEXT</A> i&#124;
      <A HREF="#FOR">FOR</A> i&#124;=200 <A HREF="#DOWNTO">DOWNTO</A> 100      !this works compiled
        <A HREF="#PRINT">PRINT</A> i&#124;;",";
      <A HREF="#NEXT">NEXT</A> i&#124;

      <A HREF="#FOR">FOR</A><A HREF="#-">-</A><A HREF="#NEXT">NEXT</A> loops using floats can possibly issue error code #8 if <A HREF="#FRE">FRE</A><A HREF="#()">()</A>
      goes too low. One would expect error code #91, however it's never
      actually used anywhere, including the library.
<HR SIZE=3><H2 ID="REPEAT">REPEAT</H2>
<A NAME="UNTIL"></A><A NAME="ENDREPEAT"></A><B><A HREF="#REPEAT">REPEAT</A>
  (instructions)
<A HREF="#UNTIL">UNTIL</A> condition</B>

condition: <A HREF="#bexp">bexp</A>

The <A HREF="#REPEAT">REPEAT</A><A HREF="#-">-</A><A HREF="#UNTIL">UNTIL</A> command provides an 'exit tested' loop in which a number of
instructions are repeated until a logical condition is true.

When the command <A HREF="#REPEAT">REPEAT</A> is reached in a program, the group of instructions up
to the <A HREF="#UNTIL">UNTIL</A> are processed. Then it checks whether the logical condition after
<A HREF="#UNTIL">UNTIL</A> is true (-1)<A HREF="#.">.</A> If this is the case, then the instructions after the UNTIL
are implemented. However, if the condition is false (0), then the program
execution jumps to the <A HREF="#REPEAT">REPEAT</A><A HREF="#.">.</A> The instructions between REPEAT and <A HREF="#UNTIL">UNTIL</A> are
processed at least once, as long as the loop is not left by an <A HREF="#EXIT_IF">EXIT IF</A> or <A HREF="#GOTO">GOTO</A>
command. <A HREF="#ENDREPEAT">ENDREPEAT</A> can be used in place of <A HREF="#UNTIL">UNTIL</A>, which the Interpreter
automatically replaces by <A HREF="#UNTIL">UNTIL</A><A HREF="#.">.</A>

<B>Examples:</B>

    <A HREF="#REPEAT">REPEAT</A>
    <A HREF="#UNTIL">UNTIL</A> <A HREF="#MOUSEK">MOUSEK</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Waits for a mouse key to be depressed.

    i=1
    <A HREF="#REPEAT">REPEAT</A>
      <A HREF="#INC">INC</A> i
      j=<A HREF="#SQR">SQR</A>(i)
    <A HREF="#UNTIL">UNTIL</A> i&#62;10 <A HREF="#AND">AND</A> <A HREF="#FRAC">FRAC</A>(j)=0
    <A HREF="#PRINT">PRINT</A> i

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Displays the number '16' on the screen.
<HR SIZE=3><H2 ID="WHILE">WHILE</H2>
<A NAME="WEND"></A><A NAME="ENDWHILE"></A><B><A HREF="#WHILE">WHILE</A> condition
  (instructions)
<A HREF="#WEND">WEND</A></B>

condition: <A HREF="#bexp">bexp</A>

The commands <A HREF="#WHILE">WHILE</A> and <A HREF="#WEND">WEND</A> can include a group of commands, which are
processed as long as the logical condition is met. If <A HREF="#GFA-Basic">GFA-Basic</A> meets a <A HREF="#WHILE">WHILE</A>
command, then the logical condition following it is checked. If it is true,
then the instructions between <A HREF="#WHILE">WHILE</A> and <A HREF="#WEND">WEND</A> are implemented. When the WEND is
reached the program jumps to the <A HREF="#WHILE">WHILE</A> and the cycle begins again, until
condition is false. <A HREF="#ENDWHILE">ENDWHILE</A> can be written instead of <A HREF="#WEND">WEND</A>, which the
Interpreter automatically replaces with <A HREF="#WEND">WEND</A><A HREF="#.">.</A>

<B>Example:</B>

    <A HREF="#WHILE">WHILE</A> <A HREF="#INKEY$">INKEY$</A><A HREF="#=">=</A>""
      <A HREF="#PLOT">PLOT</A> <A HREF="#MOUSEX">MOUSEX</A>,<A HREF="#MOUSEY">MOUSEY</A>
    <A HREF="#WEND">WEND</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Enables drawing with the mouse, until a key is pressed. If a character is
    already in the keyboard buffer, then no point is set.
<HR SIZE=3><H2 ID="DO">DO</H2>
<A NAME="LOOP"></A><A NAME="ENDDO"></A><B><A HREF="#DO">DO</A>
  (instructions)
<A HREF="#LOOP">LOOP</A></B>

The commands <A HREF="#DO">DO</A> <A HREF="#LOOP">LOOP</A> produce a continuous loop. The program processes the
instructions between <A HREF="#DO">DO</A> and <A HREF="#LOOP">LOOP</A> and returns upon meeting LOOP to the command
<A HREF="#DO">DO</A><A HREF="#.">.</A> The loop can only be left by means of <A HREF="#EXIT_IF">EXIT IF</A>, <A HREF="#GOTO">GOTO</A>, or other such commands
to abandon its execution. In place of <A HREF="#LOOP">LOOP</A>, <A HREF="#ENDDO">ENDDO</A> can be written, which the
Interpreter replaces with <A HREF="#LOOP">LOOP</A><A HREF="#.">.</A>

<B>Example:</B>

    <A HREF="#DEFFILL">DEFFILL</A> 1,2,4
    <A HREF="#DO">DO</A>
      <A HREF="#MOUSE">MOUSE</A> mx,my,mk
      <A HREF="#IF">IF</A> mk
        <A HREF="#PBOX">PBOX</A> mx,my,mx+25,my+25
      <A HREF="#ENDIF">ENDIF</A>
    <A HREF="#LOOP">LOOP</A>


<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Draws filled rectangles at the current mouse pointer position when a mouse
    key is pressed.
<HR SIZE=3><H2 ID="DO_WHILE">DO WHILE</H2>
<A NAME="DO_UNTIL"></A><A NAME="LOOP_WHILE"></A><A NAME="LOOP_UNTIL"></A><B><A HREF="#DO_WHILE">DO WHILE</A> condition
<A HREF="#DO_UNTIL">DO UNTIL</A> condition
<A HREF="#LOOP_WHILE">LOOP WHILE</A> condition
<A HREF="#LOOP_UNTIL">LOOP UNTIL</A> condition</B>

condition: <A HREF="#bexp">bexp</A>

The commands <A HREF="#DO">DO</A> and <A HREF="#LOOP">LOOP</A> can be extended using <A HREF="#UNTIL">UNTIL</A> and <A HREF="#WHILE">WHILE</A><A HREF="#.">.</A> The loop
command <A HREF="#DO_WHILE">DO WHILE</A> causes the instructions in the loop to be executed only as
long as condition is true. If the loop begins with <A HREF="#DO_UNTIL">DO UNTIL</A>, then it is entered
only if the condition is not true. <A HREF="#LOOP_WHILE">LOOP WHILE</A> causes the program to jump back
to the <A HREF="#DO">DO</A> command as long as condition is true. <A HREF="#LOOP_UNTIL">LOOP UNTIL</A> requires that the
condition must be false for the program to loop back.  Below, the conditions at
<A HREF="#DO">DO</A> are testing for true and at <A HREF="#LOOP">LOOP</A> are testing for false.

    <A HREF="#DO_WHILE">DO WHILE</A> condition                        <A HREF="#WHILE">WHILE</A> condition
    <A HREF="#'">'</A>                       <B>corresponds to</B>    '
    <A HREF="#LOOP">LOOP</A>                                      <A HREF="#WEND">WEND</A>

    <A HREF="#DO">DO</A>                                        <A HREF="#REPEAT">REPEAT</A>
    <A HREF="#'">'</A>                       <B>corresponds to</B>    '
    <A HREF="#LOOP_UNTIL">LOOP UNTIL</A> condition                      <A HREF="#UNTIL">UNTIL</A> condition

The command variants <A HREF="#DO">DO</A>, <A HREF="#DO_WHILE">DO WHILE</A>, and <A HREF="#DO_UNTIL">DO UNTIL</A> can be combined at will with
<A HREF="#LOOP">LOOP</A>, <A HREF="#LOOP_WHILE">LOOP WHILE</A>, and <A HREF="#LOOP_UNTIL">LOOP UNTIL</A>, so forming altogether nine types of loops.

<B>Examples:</B>

    <A HREF="#DO">DO</A>
    <A HREF="#LOOP_UNTIL">LOOP UNTIL</A> <A HREF="#MOUSEK">MOUSEK</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Waits for a mouse button to be pressed.

    <A HREF="#DO_UNTIL">DO UNTIL</A> <A HREF="#MOUSEK">MOUSEK</A>=2
      <A HREF="#DO_WHILE">DO WHILE</A> <A HREF="#MOUSEK">MOUSEK</A>=1
        <A HREF="#LINE">LINE</A> 0,0,<A HREF="#MOUSEX">MOUSEX</A>,<A HREF="#MOUSEY">MOUSEY</A>
      <A HREF="#LOOP">LOOP</A>
    <A HREF="#LOOP_UNTIL">LOOP UNTIL</A> <A HREF="#INKEY$">INKEY$</A><A HREF="#=">=</A>"a"

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Draws lines when left mouse button is held down. If the right mouse button
    is pressed or the 'a' key is struck the program ends.

    <A HREF="#DO_UNTIL">DO UNTIL</A> <A HREF="#EOF">EOF</A>(#1)
      <A HREF="#INPUT">INPUT</A> #1,a$
    <A HREF="#LOOP">LOOP</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Reads character strings from channel 1 sequentially, until the file end is
    reached.

    <A HREF="#WHILE">WHILE</A> <A HREF="#NOT">NOT</A> <A HREF="#EOF">EOF</A>(#1)
      <A HREF="#INPUT">INPUT</A> #1,a$
    <A HREF="#WEND">WEND</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Using <A HREF="#WHILE">WHILE</A>-<A HREF="#WEND">WEND</A> is slower, since, additionally, <A HREF="#NOT">NOT</A> is required.
<HR SIZE=3><H2 ID="EXIT_IF">EXIT IF</H2>
<B><A HREF="#EXIT_IF">EXIT IF</A> condition</B>

condition: <A HREF="#bexp">bexp</A>

By means of <A HREF="#EXIT_IF">EXIT IF</A> loops can be jumped out of, if the Boolian (logical)
condition is fulfilled. The actual loop type is arbitrarily selectable. <A HREF="#EXIT_IF">EXIT IF</A>
can be used within <A HREF="#IF-ENDIF">IF-ENDIF</A> and <A HREF="#SELECT">SELECT</A><A HREF="#-">-</A><A HREF="#ENDSELECT">ENDSELECT</A><A HREF="#.">.</A>

<B>Example:</B>

    <A HREF="#DO">DO</A>
      <A HREF="#EXIT_IF">EXIT IF</A> <A HREF="#MOUSEK">MOUSEK</A>
    <A HREF="#LOOP">LOOP</A>
    <A HREF="#REPEAT">REPEAT</A>
      <A HREF="#EXIT_IF">EXIT IF</A> <A HREF="#INKEY$">INKEY$</A><A HREF="#=">=</A>"x"
    <A HREF="#UNTIL">UNTIL</A> <A HREF="#FALSE">FALSE</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The program terminates, if first a mouse button is pressed and then the 'x'
    key is pressed.

<B>Memo:</B> This fails compiled:
      <A HREF="#DO">DO</A>
        <A HREF="#EXIT_IF">EXIT IF</A> <A HREF="#FALSE">FALSE</A>  !generates 2 linker errors (<A HREF="#?">?</A>)
      <A HREF="#LOOP">LOOP</A>
      Seems ok in the interpreter.
<HR SIZE=3><H2 ID="Procedures_and_Functions">Procedures and Functions</H2>
<A HREF="#GOSUB">GOSUB</A> (<A HREF="#@">@</A>, <A HREF="#proc">proc</A>)
<A HREF="#PROCEDURE">PROCEDURE</A> (<A HREF="#SUB">SUB</A>), <A HREF="#RETURN">RETURN</A> (<A HREF="#ENDSUB">ENDSUB</A>, <A HREF="#ENDPROC">ENDPROC</A>)
<A HREF="#VAR">VAR</A>
<A HREF="#LOCAL">LOCAL</A>
<A HREF="#FUNCTION">FUNCTION</A>, <A HREF="#RETURN_x">RETURN x</A>, <A HREF="#ENDFUNC">ENDFUNC</A>
<A HREF="#DEFFN">DEFFN</A>, <A HREF="#FN">FN</A> (<A HREF="#@func">@func</A>)

In <A HREF="#GFA-Basic">GFA-Basic</A> 3 subroutines, as in most modern programming languages, are given
names. These subroutines can have parameters handed over to them and can then
work on these parameters. There are two forms of parameters available, one
where a value is passed to the subroutine and the second where the variable
itself is passed. In the second case the variable can be changed by the
procedure without the necessity of referring to the variable by name. These two
forms are known as "call by value" and "call by reference"<A HREF="#.">.</A>

Likewise the use of local variables is possible, i.e. no consideration has to
be taken on possible name clashes when calling procedures or functions. By
means of <A HREF="#DEFFN">DEFFN</A> single-line functions can be defined and addressed using the <A HREF="#FN">FN</A>
function name. Multi-line functions are also possible. These are a special form
of procedure and return a result (with <A HREF="#RETURN">RETURN</A>)<A HREF="#.">.</A>

<B>Memo:</B> For compiler options see section <A HREF="#'">'</A><A HREF="#Subroutines">Subroutines</A>'<A HREF="#.">.</A>

      Parameters passed to built in GFA commands are register based.
      Parameters passed to user subroutines are stack based.
        Using no parameters and passing parameters in globals is techincally
        faster but will make your code very hard to read.
<HR SIZE=3><H2 ID="PROCEDURE">PROCEDURE</H2>
<A NAME="RETURN"></A><A NAME="GOSUB"></A><A NAME="@"></A><A NAME="proc"></A><A NAME="ENDSUB"></A><A NAME="ENDPROC"></A><B>[<A HREF="#GOSUB">GOSUB</A><A HREF="#&">&</A>#124;<A HREF="#@">@</A>]<A HREF="#proc">proc</A>[(par1,par2,<A HREF="#.">.</A>..)]
<A HREF="#PROCEDURE">PROCEDURE</A> <A HREF="#proc">proc</A>[(var1,var2,<A HREF="#.">.</A>..)]
  (instructions)
<A HREF="#RETURN">RETURN</A></B>

proc: procedure name
par1,par2: <A HREF="#sexp">sexp</A>,<A HREF="#aexp">aexp</A>
var1,var2: <A HREF="#svar">svar</A>,<A HREF="#avar">avar</A>

Between the commands <A HREF="#PROCEDURE">PROCEDURE</A> and <A HREF="#RETURN">RETURN</A> are the instructions of a subroutine.
After <A HREF="#PROCEDURE">PROCEDURE</A> the name of the subroutine and possibly the list of the
variables to be received are placed. Calling a <A HREF="#PROCEDURE">PROCEDURE</A> takes place by giving
its name at the beginning of the line, along with a list of appropriate
parameters, which are placed in parentheses. For the sake of clarity, the
option of placing <A HREF="#@">@</A> or <A HREF="#GOSUB">GOSUB</A> in front of the procedure name is available. This
also avoids the possibility of confusing procedure names with <A HREF="#GFA-Basic">GFA-Basic</A>
commands, e.g. @rem, <A HREF="#GOSUB">GOSUB</A> stop. Parameters can be constants, variables, and
expressions. Not only the values, but also variables can be passed (see <A HREF="#VAR">VAR</A>).

The command <A HREF="#RETURN">RETURN</A> is used to end a procedure. When it is reached during the
program execution, the program resumes execution from the instruction after the
<A HREF="#GOSUB">GOSUB</A><A HREF="#.">.</A> In place of the command <A HREF="#PROCEDURE">PROCEDURE</A> one can write <A HREF="#SUB">SUB</A> and instead of
<A HREF="#RETURN">RETURN</A>, <A HREF="#ENDPROC">ENDPROC</A>, or <A HREF="#ENDSUB">ENDSUB</A> can be used which the Interpreter replaces itself.

<B>Example:</B>

    <A HREF="#GOSUB">GOSUB</A> slow_print("<A HREF="#*">*</A>* Manual for **")
    @slow_print("<A HREF="#*">*</A> GFA BASIC 3 *")
    slow_print("GFA SYSTEMTECHNIK")
    <A HREF="#'">'</A>
    <A HREF="#PROCEDURE">PROCEDURE</A> slow_print(t$)
      <A HREF="#LOCAL">LOCAL</A> i%
      <A HREF="#FOR">FOR</A> i%=1 TO <A HREF="#LEN">LEN</A>(t$)
        <A HREF="#PRINT">PRINT</A> <A HREF="#MID$">MID$</A>(t$,i%,1)<A HREF="#;">;</A>
        <A HREF="#PAUSE">PAUSE</A> 3
      <A HREF="#NEXT">NEXT</A> i%
      <A HREF="#PRINT">PRINT</A>
    <A HREF="#RETURN">RETURN</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Slowly prints the message character by character.

    a=8
    @cube_root(a)
    <A HREF="#PRINT">PRINT</A> a
    <A HREF="#'">'</A>
    <A HREF="#PROCEDURE">PROCEDURE</A> cube_root(<A HREF="#VAR">VAR</A> x)
      x=x^(1/3)
    <A HREF="#RETURN">RETURN</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Computes the cube root of 8 displaying 2 on the screen.
<HR SIZE=3><H2 ID="VAR">VAR</H2>
<A HREF="#PROCEDURE">PROCEDURE</A> <A HREF="#proc">proc</A>(var,<B><A HREF="#VAR">VAR</A> var1[,var2,<A HREF="#.">.</A>..]</B>)
<A HREF="#FUNCTION">FUNCTION</A> func(var,<B><A HREF="#VAR">VAR</A> var1[,var2,<A HREF="#.">.</A>..]</B>)

var1, var2: any variable type

<A HREF="#VAR">VAR</A>-parameters allow variables themselves to be passed and not just their
contents. They make it possible, not only to pass values into a procedure or
function but also, to pass variables which can then be changed within the
procedure or function. If the command <A HREF="#VAR">VAR</A> is found in the parameter list of a
procedure or function, all of the variables that follow will be treated as
<A HREF="#VAR">VAR</A>-parameters.

With <A HREF="#VAR">VAR</A>-parameters, unlike with global variables there is no danger of
unintended side-effects. Using <A HREF="#VAR">VAR</A>-parameters complete arrays can be passed.
<A HREF="#VAR">VAR</A>-parameters are not allowed within the calling line to a procedure or
function, only within its definition.

<B>Note:</B> <A HREF="#VAR">VAR</A>-parameters must always appear as the last elements of a
      parameter list.

The use of <A HREF="#VAR">VAR</A>-parameters is generally quicker than the use of ordinary
parameters or pointers.

<B>Examples:</B>

    sum(13,12,a)
    sum(7,9,b)
    <A HREF="#PRINT">PRINT</A> a,b
    <A HREF="#PROCEDURE">PROCEDURE</A> sum(x,y,<A HREF="#VAR">VAR</A> z)
      z=x+y
    <A HREF="#RETURN">RETURN</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Two pairs of numbers are added, the values being passed to the variables a
    and b. Then the numbers 25 and 16 are printed on the screen.

    <A HREF="#DIM">DIM</A> a(9)
    <A HREF="#FOR">FOR</A> i%=0 TO 9
      a(i%)<A HREF="#=">=</A><A HREF="#RND">RND</A>
    <A HREF="#NEXT">NEXT</A> i%
    mean(0,9,a(),m)
    <A HREF="#PRINT">PRINT</A> "mean <A HREF="#=">=</A> ";m
    <A HREF="#PROCEDURE">PROCEDURE</A> mean(from%,to%,<A HREF="#VAR">VAR</A> array(),mean)
      mean=0
      <A HREF="#FOR">FOR</A> i%=from% TO to%
        <A HREF="#ADD">ADD</A> mean,array(i%)
      <A HREF="#NEXT">NEXT</A> i%
      <A HREF="#DIV">DIV</A> mean,to%-from%+1
    <A HREF="#RETURN">RETURN</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The arithmetic array filled with random numbers is calculated and printed
    out.

<B>Note:</B> In Version 2 it was possible to achieve the effect of passing local
      variables by passing their pointers. Using this method in Version 3 may
      result in the error message 'Pointer (*x) error'<A HREF="#.">.</A> It is therefore
      strongly recommended that <A HREF="#VAR">VAR</A>-parameters are used to pass local
      variables.
<HR SIZE=3><H2 ID="LOCAL">LOCAL</H2>
<B><A HREF="#LOCAL">LOCAL</A> var1[,var2,var3,<A HREF="#.">.</A>..]</B>

var1, var2, var3: <A HREF="#avar">avar</A>, <A HREF="#svar">svar</A>

It is possible using the command <A HREF="#LOCAL">LOCAL</A> to limit the area of application of
variables. The variables specified after <A HREF="#LOCAL">LOCAL</A> are only valid in the procedure
in which the <A HREF="#LOCAL">LOCAL</A> command is used. Also any variables in all subroutines
called by this procedure will be local. Thus it is possible for variables
specified after <A HREF="#LOCAL">LOCAL</A> to have the same name as variables in the main program,
i.e. global variables. These global variables cannot be addressed then in the
subroutine but are available after leaving the procedure and remain unchanged.

<B>Note:</B> The parameter list given to a procedure or function are always local.

<B>Example:</B>

    x=2
    <A HREF="#GOSUB">GOSUB</A> test
    <A HREF="#PRINT">PRINT</A> x,y
    <A HREF="#'">'</A>
    <A HREF="#PROCEDURE">PROCEDURE</A> test
      <A HREF="#LOCAL">LOCAL</A> x,y
      x=3
      y=4
    <A HREF="#RETURN">RETURN</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The numbers 2 and 0 are displayed on the screen.

<B>Memo:</B> For compiler optimizations see section <A HREF="#'">'</A><A HREF="#Local_and_Global_Variables">Local and Global Variables</A>'<A HREF="#.">.</A>

      The original manual doesn't state it, but it seems all local variable are
      initialized to 0 or ""<A HREF="#.">.</A>
<HR SIZE=3><H2 ID="FUNCTION">FUNCTION</H2>
<A NAME="ENDFUNC"></A><A NAME="RETURN_x"></A><B><A HREF="#@func">@func</A>[(par1,par2,<A HREF="#.">.</A>..)]
<A HREF="#FUNCTION">FUNCTION</A> func [(var1,var2,<A HREF="#.">.</A>..)]
  (instructions)
  <A HREF="#RETURN">RETURN</A> exp
<A HREF="#ENDFUNC">ENDFUNC</A></B>

func: function name
par1, par2: <A HREF="#sexp">sexp</A>, <A HREF="#aexp">aexp</A>
var1, var2: <A HREF="#svar">svar</A>, <A HREF="#avar">avar</A>
exp: <A HREF="#sexp">sexp</A>, <A HREF="#aexp">aexp</A>

The commands <A HREF="#FUNCTION">FUNCTION</A> and <A HREF="#ENDFUNC">ENDFUNC</A> form a subroutine, in a similar manner to
<A HREF="#PROCEDURE">PROCEDURE</A><A HREF="#.">.</A> The name of the subroutine and, optionally, the list of variables
are given after <A HREF="#FUNCTION">FUNCTION</A> command. Calling the subroutine takes place by the use
of <A HREF="#@">@</A> or <A HREF="#FN">FN</A> and the function name, followed by a parameter list if necessary.
The parameters can be constants, variables or expressions. Not only the values,
but also the variables can be handed over by the parameter (see <A HREF="#VAR">VAR</A>)<A HREF="#.">.</A>

If the command <A HREF="#RETURN">RETURN</A> is reached during program execution, then the value given
after it or the value of the variable named is returned. However, in a function
<A HREF="#RETURN">RETURN</A> can be used several times, with <A HREF="#IF">IF</A> or the like. A function cannot be
terminated without a <A HREF="#RETURN">RETURN</A> command by <A HREF="#ENDFUNC">ENDFUNC</A><A HREF="#.">.</A> In a function name ending with
the <A HREF="#$">$</A> character the functions will produce a string result.

<B>Example:</B>

    fl%<A HREF="#=">=</A>@fac_loop(15)
    fr%<A HREF="#=">=</A>@fac_recurs(10)
    <A HREF="#'">'</A>
    <A HREF="#PRINT">PRINT</A> "loop: fac(15) <A HREF="#=">=</A> ";fl%
    <A HREF="#PRINT">PRINT</A> "recursion: fac(10) <A HREF="#=">=</A> ";fr%
    <A HREF="#'">'</A>
    <A HREF="#FUNCTION">FUNCTION</A> fac_loop(f%)
      w=1
      <A HREF="#FOR">FOR</A> j%=1 TO f%
        <A HREF="#MUL">MUL</A> w,j%
      <A HREF="#NEXT">NEXT</A> j%
      <A HREF="#RETURN">RETURN</A> w
    <A HREF="#ENDFUNC">ENDFUNC</A>
    <A HREF="#'">'</A>
    <A HREF="#FUNCTION">FUNCTION</A> fac_recurs(f%)
      <A HREF="#IF">IF</A> f%<A HREF="#&">&</A>#60;2
        <A HREF="#RETURN">RETURN</A> 1
      <A HREF="#ELSE">ELSE</A>
        <A HREF="#RETURN">RETURN</A> f%<A HREF="#*">*</A>@fac_recurs(<A HREF="#PRED">PRED</A>(f%))
      <A HREF="#ENDIF">ENDIF</A>
    <A HREF="#ENDFUNC">ENDFUNC</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The factorials of 15 and 10 are, respectively, computed within a loop and
    recursively.

<B>Memo:</B> For compiler options see sections <A HREF="#'">'</A><A HREF="#Return_Value_of_a_Function">Return Value of a Function</A>' and
      <A HREF="#'">'</A><A HREF="#ENDFUNC_Generation">ENDFUNC Generation</A>'<A HREF="#.">.</A>

      How to code a safe multi-line <A HREF="#FUNCTION">FUNCTION</A> that cannot fail.

      <A HREF="#FUNCTION">FUNCTION</A> example(p) !poor method
        <A HREF="#IF">IF</A> p=<A HREF="#&">&</A>#62;0 <A HREF="#AND">AND</A> p&#60;=7
          <A HREF="#RETURN">RETURN</A> 8
        <A HREF="#ELSE_IF">ELSE IF</A> p=<A HREF="#&">&</A>#62;8 <A HREF="#AND">AND</A> p&#60;=15
          <A HREF="#RETURN">RETURN</A> 16
        <A HREF="#ENDIF">ENDIF</A>
      <A HREF="#ENDFUNC">ENDFUNC</A> !expect unpredictable results if you reach this point

      <A HREF="#FUNCTION">FUNCTION</A> example(p) !better method
        <A HREF="#LOCAL">LOCAL</A> r
        <A HREF="#IF">IF</A> p=<A HREF="#&">&</A>#62;0 <A HREF="#AND">AND</A> p&#60;=7
          r=8
        <A HREF="#ELSE_IF">ELSE IF</A> p=<A HREF="#&">&</A>#62;8 <A HREF="#AND">AND</A> p&#60;=15
          r=6
        <A HREF="#ENDIF">ENDIF</A>
        <A HREF="#RETURN">RETURN</A> r !this method insures that RETURN is never missed
      <A HREF="#ENDFUNC">ENDFUNC</A>

      An undefined function in the interpreter issues wrong error code,
      #19 should be #44.
<HR SIZE=3><H2 ID="DEFFN">DEFFN</H2>
<A NAME="FN"></A><A NAME="@func"></A><B><A HREF="#DEFFN">DEFFN</A> func[(x1,x2,<A HREF="#.">.</A>..)]=expression
<A HREF="#FN">FN</A> func[(y1,y2,<A HREF="#.">.</A>..)]</B>

func: function name
x1, x2: var
expression, y1, y2: exp

The command <A HREF="#DEFFN">DEFFN</A> allows the definition of single-line functions. These
functions can appear at any point in the program.

The term 'expression' can be any numeric or string expression which can include
any of the parameters x1, x2, etc listed in the definition. These parameters
are local variables to the function, and if they are also globally defined, no
reference can be made to them in the expression as the local variables will be
used instead. When the function is called these variables will contain the
values listed within the brackets of the function call.

<B>Note:</B> The function can be called using either <A HREF="#'">'</A><A HREF="#FN">FN</A> func' or '<A HREF="#@func">@func</A>'<A HREF="#.">.</A>

Functions can be nested at will, to any depth. However, recursion is not
possible and if attempted, the break-key combination will not work.

<B>Examples:</B>

    <A HREF="#DEFFN">DEFFN</A> test(y,a$)=x-y+<A HREF="#LEN">LEN</A>(a$)
    x=2
    <A HREF="#PRINT">PRINT</A> @test(4,"abcdef")

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The number 4, i.e. 2-4+6 is displayed on the screen.

    <A HREF="#DEFFN">DEFFN</A> first_last$(a$)<A HREF="#=">=</A><A HREF="#LEFT$">LEFT$</A>(a$)<A HREF="#+">+</A><A HREF="#RIGHT$">RIGHT$</A>(a$)
    b$<A HREF="#=">=</A>@first_last$("TEST")
    <A HREF="#PRINT">PRINT</A> b$

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The text "TT" is displayed on the screen.

    <A HREF="#DEFFN">DEFFN</A> fourth_power(x)=x^4
    <A HREF="#DEFFN">DEFFN</A> fourth_root(x)=x^(1/4)
    <A HREF="#PRINT">PRINT</A> @fourth_root(@fourth_power(1024))

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The number 1024 is displayed on the screen.

<B>Note:</B> Return value is always a float, thus slower.

<B>Memo:</B> If placed directly after a <A HREF="#PROCEDURE">PROCEDURE</A> or <A HREF="#FUNCTION">FUNCTION</A> definition
      which has no parameters, a bug in the compiler occurs. In the editor
      it seems ok.

      Symptoms: Program works fine in the editor but when compiled acts really
                strange. Doing things you know it should not be doing. The
                problem will persist even if the <A HREF="#DEFFN">DEFFN</A> is not called!

      Further investigation shows that the compiler compiles the functions
      right where it encounters them. Thus, if the <A HREF="#DEFFN">DEFFN</A> is defined inside
      another routine, it jumps over it with a BRAnch always statement.
      This makes for some really messing looking code in the dis-assembler!
      Regardless of where you place them the compiler generates needless
      BRAnch statements anyway, making the binary larger.

      If one if going to use this command, do not define them inside other
      routines. Best place to put them is between the main body of code and
      the first subroutine or at the very end of the listing after the last
      subroutine.

      <A HREF="#'">'</A> works in the editor, fails compiled
      <A HREF="#'">'</A> insert a line of code above the <A HREF="#DEFFN">DEFFN</A>, then it works compiled
      @test
      <A HREF="#EDIT">EDIT</A>
      <A HREF="#PROCEDURE">PROCEDURE</A> test !no parameters
        <A HREF="#DEFFN">DEFFN</A> dummy=0
        <A HREF="#PRINT">PRINT</A> "test"
      <A HREF="#RETURN">RETURN</A>

      I recommend this command be avoided. The multi-line <A HREF="#FUNCTION">FUNCTION</A> command is
      much more flexible and you can control what type of variable is passed
      back via compiler commands. Use the <A HREF="#FUNCTION">FUNCTION</A> command instead.
<HR SIZE=3><H2 ID="Error_Handling">Error Handling</H2>
<A HREF="#ON_BREAK">ON BREAK</A>, <A HREF="#ON_BREAK_CONT">ON BREAK CONT</A>, <A HREF="#ON_BREAK_GOSUB">ON BREAK GOSUB</A>
<A HREF="#ON_ERROR">ON ERROR</A>, <A HREF="#ON_ERROR_GOSUB">ON ERROR GOSUB</A>
<A HREF="#RESUME">RESUME</A>, <A HREF="#RESUME_NEXT">RESUME NEXT</A>, <A HREF="#RESUME_label">RESUME label</A>
<A HREF="#ERROR">ERROR</A>, <A HREF="#ERR">ERR</A>, <A HREF="#ERR$">ERR$</A><A HREF="#()">()</A>
<A HREF="#FATAL">FATAL</A>

In this section two different types of events are considered. Non <A HREF="#GFA-Basic">GFA-Basic</A>
specific events such as checking for mouse clicks, selecting pull-down menus.
ets, are dealt with in other chapters (Menu and Window Programming and <A HREF="#AES">AES</A>
Libraries)<A HREF="#.">.</A>

The first of these two events to be discussed is the simultaneous pressing of
the Control, Shift, and Alternate keys. The second type of event is the
occurrence of an error during program execution.

<HR SIZE=3><H2 ID="ON_BREAK">ON BREAK</H2>
<A NAME="ON_BREAK_CONT"></A><A NAME="ON_BREAK_GOSUB"></A><A NAME="Break_Keys"></A><B><A HREF="#ON_BREAK">ON BREAK</A>
<A HREF="#ON_BREAK_CONT">ON BREAK CONT</A>
<A HREF="#ON_BREAK_GOSUB">ON BREAK GOSUB</A> <A HREF="#proc">proc</A></B>

proc: procedure name

These three commands control the response to the simultaneous pressing of the
Control, Shift (left shift-key only), and Altemate keys. Normally, pressing
this key combination causes the termination of a program but, it can also be
used to call a particular procedure. To do this, the procedure to be called is
defined by means of the instruction <A HREF="#ON_BREAK_GOSUB">ON BREAK GOSUB</A> <A HREF="#proc">proc</A><A HREF="#.">.</A>

When an <A HREF="#ON_BREAK_CONT">ON BREAK CONT</A> is present in a program, the Control, Shift, and
Alternate key combination is deactivated. An <A HREF="#ON_BREAK">ON BREAK</A> reactivates this key
combination once again.

<B>Example:</B>

    <A HREF="#ON_BREAK_GOSUB">ON BREAK GOSUB</A> test
    <A HREF="#PRINT">PRINT</A> "Press CONTROL, SHIFT, (the left one) and ALTERNATE"
    <A HREF="#DO">DO</A>
    <A HREF="#LOOP">LOOP</A>
    <A HREF="#'">'</A>
    <A HREF="#PROCEDURE">PROCEDURE</A> test
      <A HREF="#PRINT">PRINT</A> "that was it"
      <A HREF="#ON_BREAK">ON BREAK</A>
    <A HREF="#RETURN">RETURN</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The request to press the key combination is displayed. When they are
    pressed, the procedure 'test' switches the normal BREAK routine on again.

<B>Memo:</B> Return code will be -128 if the program is stopped (compiled)<A HREF="#.">.</A>

      For compiler related options see sections <A HREF="#'">'</A><A HREF="#Interrupt_Routines">Interrupt Routines</A>' and
      <A HREF="#'">'</A><A HREF="#Checking_the_BREAK_keys,_EVERY_and_AFTER">Checking the BREAK keys, EVERY and AFTER</A>'<A HREF="#.">.</A>

      If the procedure used with <A HREF="#ON_BREAK_GOSUB">ON BREAK GOSUB</A> is undefined the compiler will
      not issue and error message. Instead the compiler writes a bad binary
      where <A HREF="#ON_BREAK_GOSUB">ON BREAK GOSUB</A> is translated into JSR 0.l!

      The editor does not report a missing procedure with <A HREF="#ON_BREAK_GOSUB">ON BREAK GOSUB</A><A HREF="#.">.</A>
<HR SIZE=3><H2 ID="ON_ERROR">ON ERROR</H2>
<A NAME="ON_ERROR_GOSUB"></A><A NAME="RESUME"></A><A NAME="RESUME_NEXT"></A><A NAME="RESUME_label"></A><B><A HREF="#ON_ERROR">ON ERROR</A>
<A HREF="#ON_ERROR_GOSUB">ON ERROR GOSUB</A> <A HREF="#proc">proc</A>
<A HREF="#RESUME">RESUME</A> [<A HREF="#NEXT">NEXT</A>]
<A HREF="#RESUME">RESUME</A> [label]</B>

proc: procedure name
<A HREF="#label:">label:</A> label name

The occurrence of a fault (a TOS or <A HREF="#GFA-Basic">GFA-Basic</A> specific fault) normally causes
the output of an error message and an abnormal termination. With <A HREF="#ON_ERROR_GOSUB">ON ERROR GOSUB</A>
there is the possibility of branching to a specified procedure, following the
detection of an error. In the procedure one can then determine the appropriate
reaction to the error.

With the command <A HREF="#ON_ERROR">ON ERROR</A> one switches back to the normal error-trapping, so as
to display the appropriate error message and bring about an abnormal
termination. Under these conditions, therefore, when an error arises, an ON
<A HREF="#ERROR">ERROR</A> command is implemented automatically. In order to be able to react to a
number of errors which occur one after the other, the <A HREF="#ON_ERROR_GOSUB">ON ERROR GOSUB</A> <A HREF="#proc">proc</A>
command must be contained within the error-trapping routine.

The <A HREF="#RESUME">RESUME</A> command allows one to react in different ways when errors have
arisen and it is only used in an error-trapping procedure. When used on its own
as <A HREF="#'">'</A><A HREF="#RESUME">RESUME</A>', this command causes the error to be repeated. <A HREF="#RESUME_NEXT">RESUME NEXT</A>
continues execution with the command which follows the command causing the
error. <A HREF="#RESUME_label">RESUME label</A> causes the program to continue from the point 'label'. The
label for <A HREF="#RESUME">RESUME</A> may be located either in a procedure or in the main program.
If a fatal error occurred (see <A HREF="#FATAL">FATAL</A>), then only <A HREF="#RESUME_label">RESUME label</A> can be used and
not <A HREF="#RESUME_NEXT">RESUME NEXT</A> or <A HREF="#RESUME">RESUME</A> without a label.

<B>Example:</B>

    <A HREF="#ON_ERROR_GOSUB">ON ERROR GOSUB</A> error_trapping
    <A HREF="#ERROR">ERROR</A> 5
    <A HREF="#PRINT">PRINT</A> "and again..."
    <A HREF="#ERROR">ERROR</A> 5
    <A HREF="#PRINT">PRINT</A> "is not reached"
    <A HREF="#'">'</A>
    <A HREF="#PROCEDURE">PROCEDURE</A> error_trapping
      <A HREF="#PRINT">PRINT</A> "Ok, error intercepted"
      <A HREF="#RESUME_NEXT">RESUME NEXT</A>
    <A HREF="#RETURN">RETURN</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The texts 'Ok, error intercepted' is displayed and then 'and again...'.
    Then the error message 'Square root only for positive numbers', is brought
    about by <A HREF="#ERROR">ERROR</A> 5. The label for <A HREF="#RESUME">RESUME</A> may be located either in a procedure
    or in the main program.

<B>Memo:</B> If the label used with <A HREF="#RESUME">RESUME</A> is undefined the compiler will not
      issue and error message.  Instead the compiler writes a bad binary where
      <A HREF="#RESUME">RESUME</A> is translated into JMP 0.l!

      If the procedure used with <A HREF="#ON_ERROR_GOSUB">ON ERROR GOSUB</A> is undefined the compiler will
      not issue and error message.  Instead the compiler writes a bad binary
      where <A HREF="#ON_ERROR_GOSUB">ON ERROR GOSUB</A> is translated into JSR 0.l!

      The editor does not report a missing procedure with <A HREF="#ON_ERROR_GOSUB">ON ERROR GOSUB</A><A HREF="#.">.</A>

      <A HREF="#Division">Division</A> by zero <A HREF="#=">=</A> error code 0
      When passed out via pterm() (<A HREF="#END">END</A>) it cannot be detected.

      The label for <A HREF="#RESUME">RESUME</A> cannot be located inside a <A HREF="#FUNCTION">FUNCTION</A><A HREF="#.">.</A>
<HR SIZE=3><H2 ID="ERROR">ERROR</H2>
<A NAME="ERR"></A><A NAME="ERR$"></A><A NAME="FATAL"></A><B><A HREF="#ERROR">ERROR</A> x
<A HREF="#ERR">ERR</A>
<A HREF="#ERR$">ERR$</A>(x)
<A HREF="#FATAL">FATAL</A></B>

x: <A HREF="#aexp">aexp</A>

With <A HREF="#ERROR">ERROR</A> x, the occurrence of error number x can be simulated. (For the table
of error messages, see <A HREF="#Appendix">Appendix</A><A HREF="#.">.</A>) This command is particularly useful for
example, when testing an error processing routine.

The number of the error that has arisen is returned in the variable <A HREF="#ERR">ERR</A> and, by
means of this, one can determine the appropriate reaction to the occurrence of
a specific error.

The function <A HREF="#ERR$">ERR$</A>(x) returns, as a string, the <A HREF="#GFA-Basic">GFA-Basic</A> error message with the
number x.

The variable <A HREF="#FATAL">FATAL</A> is true if an error in the program generates an unknown
address. This can happen, for example, when the error arose from the processing
of an operating system routine. When this happens, a <A HREF="#RESUME">RESUME</A> or <A HREF="#RESUME_NEXT">RESUME NEXT</A> can
no longer be correctly executed.

<B>Examples:</B>

    <A HREF="#ON_ERROR_GOSUB">ON ERROR GOSUB</A> error_trapping
    <A HREF="#INPUT">INPUT</A> "Which error do you want: ",e
    <A HREF="#ERROR">ERROR</A> e
    <A HREF="#'">'</A>
    <A HREF="#PROCEDURE">PROCEDURE</A> error_trapping
      <A HREF="#PRINT">PRINT</A> "That was error no.<A HREF="#:">:</A> "<A HREF="#;">;</A><A HREF="#ERR">ERR</A>
      <A HREF="#IF">IF</A> <A HREF="#FATAL">FATAL</A>
        <A HREF="#PRINT">PRINT</A> "It was a fatal error"
      <A HREF="#ENDIF">ENDIF</A>
    <A HREF="#RETURN">RETURN</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The user is asked to select an error by means of its error number and it is
    displayed on the screen. The program then asks for the next error number.

    <A HREF="#~">~</A><A HREF="#FORM_ALERT">FORM_ALERT</A>(1,<A HREF="#ERR$">ERR$</A>(100))

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The error message with the identification 100 is displayed, i.e. the
    copyright message, as an alert box.

<B>Memo:</B> For compiler options see sections <A HREF="#'">'</A><A HREF="#Error_Messages">Error Messages</A>' and
      <A HREF="#'">'</A><A HREF="#Error_Numbers_Instead_of_Bombs">Error Numbers Instead of Bombs</A>'<A HREF="#.">.</A>

      <A HREF="#ERR">ERR</A> is intialized to 0 only when the editor is first started.
      However, <A HREF="#ERR">ERR</A> is not reset to 0 at each 'Run'<A HREF="#.">.</A>
      This should be considered a bug in the editor.

      <A HREF="#ERR$">ERR$</A><A HREF="#()">()</A> will accept any value. The actual range should be -128 to 127.
<HR SIZE=3><H2 ID="Interrupt_Programming">Interrupt Programming</H2>
<A NAME="EVERY"></A><A NAME="AFTER"></A><A NAME="EVERY_GOSUB"></A><A NAME="EVERY_CONT"></A><A NAME="EVERY_STOP"></A><A NAME="AFTER_GOSUB"></A><A NAME="AFTER_CONT"></A><A NAME="AFTER_STOP"></A><B><A HREF="#EVERY">EVERY</A> ticks <A HREF="#GOSUB">GOSUB</A> <A HREF="#proc">proc</A>
<A HREF="#EVERY_STOP">EVERY STOP</A>
<A HREF="#EVERY_CONT">EVERY CONT</A>
<A HREF="#AFTER">AFTER</A> ticks <A HREF="#GOSUB">GOSUB</A> <A HREF="#proc">proc</A>
<A HREF="#AFTER_STOP">AFTER STOP</A>
<A HREF="#AFTER_CONT">AFTER CONT</A></B>

ticks: <A HREF="#iexp">iexp</A>
proc: procedure name

By means of the commands <A HREF="#EVERY">EVERY</A> and <A HREF="#AFTER">AFTER</A>, procedures can be called after the
expiration of a certain amount of time 'ticks'<A HREF="#.">.</A> The command <A HREF="#EVERY">EVERY</A> causes the
procedure 'proc' to be called every 'ticks' clock units. <A HREF="#AFTER">AFTER</A> causes this
procedure to be called once only on the expiration of 'ticks' clock units.

The clock unit (tick) is defined as one two-hundredth of a second so ticks=200
sets an elapsed time of one second. However, a branch to the specified
procedure can only be called on every fourth clock unit, resulting in an
effective time resolution of one fiftieth of a second.

By means of <A HREF="#EVERY_STOP">EVERY STOP</A>, the calling of a procedure can be prevented on
expiration of the time period. With <A HREF="#EVERY_CONT">EVERY CONT</A>, the calling of the procedure is
again is allowed. The commands <A HREF="#AFTER_STOP">AFTER STOP</A> and <A HREF="#AFTER_CONT">AFTER CONT</A> work similarly, being
implemented internally by means of the etv_timer vector ($400)<A HREF="#.">.</A>

It is only after the complete processing of a command that a check is made to
ascertain whether such a procedure is to be implemented. Thus commands which
are executed slowly, such as <A HREF="#INP">INP</A>(2), <A HREF="#QSORT">QSORT</A>, file operations, or the like, can
obstruct these routines.

<B>Examples:</B>

    <A HREF="#EVERY">EVERY</A> 4 <A HREF="#GOSUB">GOSUB</A> lines
    lines!<A HREF="#=">=</A><A HREF="#TRUE">TRUE</A>
    <A HREF="#GRAPHMODE">GRAPHMODE</A> 3
    <A HREF="#DEFFILL">DEFFILL</A> 1
    <A HREF="#PLOT">PLOT</A> <A HREF="#MOUSEX">MOUSEX</A>,<A HREF="#MOUSEY">MOUSEY</A>
    <A HREF="#REPEAT">REPEAT</A>
      <A HREF="#IF">IF</A> <A HREF="#MOUSEK">MOUSEK</A>=1
        <A HREF="#EVERY_STOP">EVERY STOP</A>
      <A HREF="#ELSE">ELSE</A>
        <A HREF="#EVERY_CONT">EVERY CONT</A>
      <A HREF="#ENDIF">ENDIF</A>
      <A HREF="#DRAW_TO">DRAW TO</A> <A HREF="#MOUSEX">MOUSEX</A>,<A HREF="#MOUSEY">MOUSEY</A>
    <A HREF="#UNTIL">UNTIL</A> <A HREF="#MOUSEK">MOUSEK</A>=2
    <A HREF="#'">'</A>
    <A HREF="#PROCEDURE">PROCEDURE</A> lines
      <A HREF="#INC">INC</A> y%
      <A HREF="#LINE">LINE</A> 320,y%,639,y%
      <A HREF="#IF">IF</A> y%=399
        y%=0
      <A HREF="#ENDIF">ENDIF</A>
    <A HREF="#RETURN">RETURN</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Draws lines in the right half of the screen from top to bottom and, at the
    same time, permits the user to draw using the mouse. Pressing the left
    mouse button switches the moving lines in or out. The program can be
    terminated by means of the right mouse button.

    <A HREF="#PRINT">PRINT</A> "Text follows in 3 seconds, "
    <A HREF="#PRINT">PRINT</A> "if you do not press a key"
    <A HREF="#AFTER">AFTER</A> 600 <A HREF="#GOSUB">GOSUB</A> text
    <A HREF="#REPEAT">REPEAT</A>
    <A HREF="#UNTIL">UNTIL</A> <A HREF="#INKEY$">INKEY$</A><A HREF="#&#60;&#62;">&#60;&#62;</A>"" <A HREF="#OR">OR</A> exit!
    <A HREF="#AFTER_STOP">AFTER STOP</A>
    <A HREF="#'">'</A>
    <A HREF="#PROCEDURE">PROCEDURE</A> text
      <A HREF="#PRINT">PRINT</A>
      <A HREF="#PRINT">PRINT</A> "here is the text"
      exit!<A HREF="#=">=</A><A HREF="#TRUE">TRUE</A>
    <A HREF="#RETURN">RETURN</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> If no key is pressed in the three seconds after the program starts, then
    the message appears. If a key is pressed, then this terminates the program.

<B>Memo:</B> For compiler related options see sections <A HREF="#'">'</A><A HREF="#Interrupt_Routines">Interrupt Routines</A>' and
      <A HREF="#'">'</A><A HREF="#Checking_the_BREAK_keys,_EVERY_and_AFTER">Checking the BREAK keys, EVERY and AFTER</A>'<A HREF="#.">.</A>

      <A HREF="#EVERY">EVERY</A> and <A HREF="#AFTER">AFTER</A> rely on system timer B.

      If the procedure used with <A HREF="#EVERY">EVERY</A> and <A HREF="#AFTER">AFTER</A> is undefined the compiler will
      not issue and error message. Instead the compiler writes a bad binary
      where <A HREF="#EVERY">EVERY</A> and <A HREF="#AFTER">AFTER</A> are translated into JSR 0.l!

      The editor does not report missing procedures with EVERY/AFTER.
<HR SIZE=3><H2 ID="Other_Commands">Other Commands</H2>
<A HREF="#REM">REM</A> (<A HREF="#/">/</A>, <A HREF="#//">//</A>, <A HREF="#/*">/*</A>), <A HREF="#!">!</A>, <A HREF="#'">'</A>
<A HREF="#GOTO">GOTO</A>, <A HREF="#label:">label:</A>
<A HREF="#DELAY">DELAY</A>, <A HREF="#PAUSE">PAUSE</A>
<A HREF="#END">END</A>, <A HREF="#EDIT">EDIT</A>, <A HREF="#STOP">STOP</A>
<A HREF="#NEW">NEW</A>
<A HREF="#LOAD">LOAD</A>
<A HREF="#SAVE">SAVE</A>, <A HREF="#PSAVE">PSAVE</A>
<A HREF="#LIST">LIST</A>, <A HREF="#LLIST">LLIST</A>
<A HREF="#CHAIN">CHAIN</A>, <A HREF="#RUN">RUN</A>
<A HREF="#QUIT">QUIT</A>, <A HREF="#SYSTEM">SYSTEM</A>
<HR SIZE=3><H2 ID="REM">REM</H2>
<A NAME="!"></A><A NAME="'"></A><A NAME="/"></A><A NAME="//"></A><A NAME="/*"></A><B><A HREF="#REM">REM</A> x
<A HREF="#'">'</A> x
<A HREF="#&">&</A>#60;command&#62; !x</B>

x: arbitrary text

A line which begins with a <A HREF="#REM">REM</A> or <A HREF="#'">'</A> command, can contain any text which is
placed after these. The text, known as a REMark or comment, is not part of the
program proper or subject to the syntax control of the editor and during
program execution are not considered. They are usually used to make clearer how
the program works. In addition, comments can be added to the end of a command
line, other than one with <A HREF="#DATA">DATA</A> or <A HREF="#INLINE">INLINE</A> commands. This is done by ending the
executable portion of the program by means of an exclamation mark <A HREF="#'">'</A><A HREF="#!">!</A>'<A HREF="#.">.</A>

<B>Note:</B> The forward slash '/' can also be used, however the editor will
      replace "<A HREF="#/">/</A> comment" with "<A HREF="#'">'</A> comment"<A HREF="#.">.</A>

<B>Example:</B>

    <A HREF="#REM">REM</A> comment
    <A HREF="#'">'</A> <A HREF="#PRINT">PRINT</A> "comment"
    <A HREF="#PRINT">PRINT</A> "<A HREF="#REM">REM</A>" <A HREF="#!">!</A> comment

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The word <A HREF="#'">'</A><A HREF="#REM">REM</A>' appears on the sereen. Everthing else is ignored.
<HR SIZE=3><H2 ID="GOTO">GOTO</H2>
<A NAME="label:"></A><A NAME=":"></A><B><A HREF="#GOTO">GOTO</A> label</B>

<A HREF="#label:">label:</A> label name

By means of a 'label', specific locations in the program can be defined and a
program started from this point with the instruction <A HREF="#'">'</A><A HREF="#GOTO">GOTO</A> label'<A HREF="#.">.</A> Program
execution is commenced from the label position. The label can consist of
letters, numbers, underlines, and periods. However, unlike variable names, it
may also begin with a number. It must, however, end with a colon. The colon
should be left off when refering to a label in a <A HREF="#GOTO">GOTO</A> command.

The use of <A HREF="#GOTO">GOTO</A> is not allowed for jumping out of procedures, functions, or
<A HREF="#FOR">FOR</A><A HREF="#-">-</A><A HREF="#NEXT">NEXT</A> loops into the main part of the program. The use of this command also
leads to unclear program structures which are not easy to follow and, it is
generally considered, <A HREF="#GOTO">GOTO</A>'s should be avoided wherever possible.

<B>Example:</B>

    <A HREF="#PRINT">PRINT</A> "place 1"
    <A HREF="#GOTO">GOTO</A> jump_point
    <A HREF="#PRINT">PRINT</A> "place 2"
    jump_point:
    <A HREF="#PRINT">PRINT</A> "place 3"

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The texts "place 1" and "place 3" appear on the screen.

<B>Memo:</B> If the label used with <A HREF="#GOTO">GOTO</A> is undefined the compiler will not
      issue and error message.  Instead the compiler writes a bad binary where
      <A HREF="#GOTO">GOTO</A> is translated into JMP 0.l!

This example shows what is and what is not valid when using the <A HREF="#GOTO">GOTO</A> command:
<A HREF="#FOR">FOR</A> j=0 TO 31
  <A HREF="#IF">IF</A> i=15
    <A HREF="#'">'</A> <A HREF="#GOTO">GOTO</A> label3   !no good
  <A HREF="#ENDIF">ENDIF</A>
<A HREF="#NEXT">NEXT</A> j
<A HREF="#FOR">FOR</A> i=0 TO 31
  <A HREF="#IF">IF</A> i=15
    <A HREF="#'">'</A> <A HREF="#GOTO">GOTO</A> main1    !no good
    <A HREF="#GOTO">GOTO</A> label3     !ok       jump within the same loop
  <A HREF="#ENDIF">ENDIF</A>
label3:
<A HREF="#NEXT">NEXT</A> i
<A HREF="#'">'</A> <A HREF="#GOTO">GOTO</A> label1       !no good
<A HREF="#'">'</A> <A HREF="#GOTO">GOTO</A> label2       !no good
<A HREF="#'">'</A> <A HREF="#GOTO">GOTO</A> label3       !no good
main1:
<A HREF="#'">'</A>
<A HREF="#PROCEDURE">PROCEDURE</A> proc1
  <A HREF="#GOTO">GOTO</A> label1       !ok       jump into aonther procedure from a procedure
  <A HREF="#'">'</A> <A HREF="#GOTO">GOTO</A> label2     !no good
  <A HREF="#'">'</A> <A HREF="#GOTO">GOTO</A> main1      !no good
<A HREF="#RETURN">RETURN</A>
<A HREF="#PROCEDURE">PROCEDURE</A> proc2
  <A HREF="#GOTO">GOTO</A> label1       !ok       jump within the same procedure
label1:
<A HREF="#RETURN">RETURN</A>
<A HREF="#FUNCTION">FUNCTION</A> func1
  <A HREF="#GOTO">GOTO</A> label2       !ok       jump into another function from a function
  <A HREF="#'">'</A> <A HREF="#GOTO">GOTO</A> label1     !no good
  <A HREF="#'">'</A> <A HREF="#GOTO">GOTO</A> main1      !no good
  <A HREF="#RETURN">RETURN</A> 0
<A HREF="#ENDFUNC">ENDFUNC</A>
<A HREF="#FUNCTION">FUNCTION</A> func2
  <A HREF="#GOTO">GOTO</A> label2       !ok       jump within the same function
label2:
  <A HREF="#RETURN">RETURN</A> 0
<A HREF="#ENDFUNC">ENDFUNC</A>
<HR SIZE=3><H2 ID="DELAY">DELAY</H2>
<A NAME="PAUSE"></A><B><A HREF="#PAUSE">PAUSE</A> x
<A HREF="#DELAY">DELAY</A> x</B>

x: <A HREF="#aexp">aexp</A>

The command <A HREF="#PAUSE">PAUSE</A> suspends program execution for x/50 seconds. <A HREF="#DELAY">DELAY</A> has a
similar effect but the argument x is specified in seconds with a theoretical
resolution in milliseconds. <A HREF="#DELAY">DELAY</A> uses the GEM routine <A HREF="#EVNT_TIMER">EVNT_TIMER</A><A HREF="#()">()</A> and is,
therefore, recommended for use in GEM programs.

<B>Example:</B>

    <A HREF="#PRINT">PRINT</A> "start"
    <A HREF="#PAUSE">PAUSE</A> 100
    <A HREF="#PRINT">PRINT</A> "a pause"
    <A HREF="#DELAY">DELAY</A> 2
    <A HREF="#PRINT">PRINT</A> "end"

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The text 'start' appears then, two seconds later the further message 'a
    pause' is displayed. This is followed after a further two seconds by 'end'.

<B>Memo:</B> <A HREF="#PAUSE">PAUSE</A> <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> Internally uses <A HREF="#TIMER">TIMER</A><A HREF="#.">.</A> Uses system timer B.
      <A HREF="#DELAY">DELAY</A> <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> Internally uses <A HREF="#EVNT_TIMER">EVNT_TIMER</A><A HREF="#()">()</A><A HREF="#.">.</A>

evnt_timer()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="EDIT">EDIT</H2>
<A NAME="END"></A><A NAME="STOP"></A><B><A HREF="#END">END</A>
<A HREF="#EDIT">EDIT</A>
<A HREF="#STOP">STOP</A></B>

These commands terminate the execution of a program. The command <A HREF="#END">END</A> terminates
the program's execution and displays a box with the text 'Program end' on the
screen. On clicking on the 'Return' button, <A HREF="#GFA-Basic">GFA-Basic</A> 3 returns to the Editor.

<A HREF="#EDIT">EDIT</A> terminates program execution and returns control to the Editor
immediately.

<A HREF="#STOP">STOP</A> causes an Alert box to appear with the choice of STOP and <A HREF="#CONT">CONT</A><A HREF="#.">.</A> When the
choice <A HREF="#CONT">CONT</A> is made, program execution continues. When the choice is <A HREF="#STOP">STOP</A>,
<A HREF="#GFA-Basic">GFA-Basic</A> goes into Direct mode. At this stage, one can test and change the
values of variables and, by means of <A HREF="#CONT">CONT</A>, continue program execution.

<B>Example:</B>

    x=3
    <A HREF="#STOP">STOP</A>
    <A HREF="#PRINT">PRINT</A> x

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Select the button <A HREF="#'">'</A><A HREF="#STOP">STOP</A>' when the appropriate Alert box appears. Now enter,
    in direct mode, the following commands:

    <A HREF="#PRINT">PRINT</A> x

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The number 3 appears, next enter:

    x=4
    <A HREF="#CONT">CONT</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The last command of the program (<A HREF="#PRINT">PRINT</A> x) is now processed and the number 4
    appears, demonstrating that the value specified in Direct mode has been
    assigned to the variable x.

<B>Memo:</B> These commands don't always generate code when compiled.
      This is some odd bug in the compiler.
      The same problem can happen inside a <A HREF="#FUNCTION">FUNCTION</A><A HREF="#.">.</A>
      Depending on its placement they sometimes fails, examples:
      <A HREF="#PROCEDURE">PROCEDURE</A> test
        <A HREF="#'">'</A> add a code generating line here, then it works
        <A HREF="#EDIT">EDIT</A>     !if it follows a <A HREF="#proc">proc</A> def it fails
      <A HREF="#RETURN">RETURN</A>
<HR SIZE=3><H2 ID="NEW">NEW</H2>
<B><A HREF="#NEW">NEW</A></B>

This command deletes the program currently in memory. In Direct mode, for
safety's sake, the wishes of the user are queried. When in the Editor this
command can be executed by means of Shift-F4 or a mouse click and, again a
safety query is made.

<B>Memo:</B> The command <A HREF="#NEW">NEW</A> is translated to <A HREF="#END">END</A> when compiled.
<HR SIZE=3><H2 ID="LOAD">LOAD</H2>
<B><A HREF="#LOAD">LOAD</A> f$</B>

f$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>

The command <A HREF="#LOAD">LOAD</A> loads a <A HREF="#GFA-Basic">GFA-Basic</A> program. The expression f$ must contain the
file name along with the full access path for the file. When no extension is
specified for the file, the default extension <A HREF="#'">'</A>.GFA' is used.

<B>Example:</B>

    <A HREF="#LOAD">LOAD</A> "A:\TEST.GFA"

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The program loads TEST.GFA from the root directory of drive A.
<HR SIZE=3><H2 ID="SAVE">SAVE</H2>
<A NAME="PSAVE"></A><B><A HREF="#SAVE">SAVE</A> f$
<A HREF="#PSAVE">PSAVE</A> f$</B>

f$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>

The command <A HREF="#SAVE">SAVE</A> stores a program on disk, under the specified name, f$<A HREF="#.">.</A> By
means of the command <A HREF="#PSAVE">PSAVE</A>, the specified file can be saved with list
protection and cannot subsequently be listed after re-loading with <A HREF="#LOAD">LOAD</A> as it
is run immediately. In both cases, when no extension is specified for the file,
the default extension <A HREF="#'">'</A>.GFA' is used.

<B>Example:</B>

    <A HREF="#SAVE">SAVE</A> "A:\TEST.GFA"

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Saves the current program under the file name TEST.GFA on drive A.
<HR SIZE=3><H2 ID="LIST">LIST</H2>
<A NAME="LLIST"></A><B><A HREF="#LIST">LIST</A> [f$]
<A HREF="#LLIST">LLIST</A> [f$]</B>

f$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>

The command <A HREF="#LIST">LIST</A> displays the current program on the screen. Optionally, an
access path can be specified, by which the program can be stored in <A HREF="#ASCII">ASCII</A>
format. Program sections that are to be inserted in to other programs by means
of 'MERGE', must be saved with <A HREF="#LIST">LIST</A> or <A HREF="#SAVE">SAVE</A>,A from the Editor Menu, in <A HREF="#ASCII">ASCII</A>
format.

When no extension is specified for the saving of a file, <A HREF="#'">'</A>.LST' is used as the
default extension.

By means of the command <A HREF="#LLIST">LLIST</A>, the current program can be output to the
printer. The printer listing can be interrupted only by the switching off the
printer. Once switched off, the printer will probably continue to print for
some seconds before the program resumes or control is returned to the Editor.
(See <A HREF="#LLIST">LLIST</A> and the <A HREF="#.dot_commands">.dot commands</A> in the section covering the Editor.) In
addition, it is also possible to send text to a printer (see <A HREF="#OPEN">OPEN</A>)<A HREF="#.">.</A>

<B>Examples:</B>

    <A HREF="#LIST">LIST</A> "A:\TEST,LST"

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The current program is stored under the name "TEST.LST" in <A HREF="#ASCII">ASCII</A> format on
    drive A.

    .ll 70
    .pl 66
    <A HREF="#LLIST">LLIST</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The current program is output to the printer with a line length of 70
    characters and a page length of 66 lines.

<HR SIZE=3><H2 ID="CHAIN">CHAIN</H2>
<B><A HREF="#CHAIN">CHAIN</A> f$</B>

f$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>

The command <A HREF="#CHAIN">CHAIN</A> loads a <A HREF="#GFA-Basic">GFA-Basic</A> program into memory and starts execution
immediately when the program is loaded. When no extension is specified, the
extension <A HREF="#'">'</A>.GFA' is assumed.

<B>Example:</B>

    <A HREF="#CHAIN">CHAIN</A> "A:\EXAMPLE.GFA"

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The program EXAMPLE.GFA is loaded from disk and is immediately <A HREF="#RUN">RUN</A>.

<B>Memo:</B> This command works a bit differently compiled.
      See section <A HREF="#'">'</A><A HREF="#Interpreter_-_Compiler_Differences">Interpreter - Compiler Differences</A>'<A HREF="#.">.</A>
<HR SIZE=3><H2 ID="RUN">RUN</H2>
<B><A HREF="#RUN">RUN</A> [f$]</B>

f$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>

The command <A HREF="#RUN">RUN</A> starts the current program. Additionally, if a complete file
name with access path is specified, then the appropriate program is loaded and
started, replacing any program currently in memory.

<B>Example:</B>

    <A HREF="#RUN">RUN</A> "A:\PART2.GFA"

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The program PART2.GFA is loaded from drive A and <A HREF="#RUN">RUN</A>.
<HR SIZE=3><H2 ID="QUIT">QUIT</H2>
<A NAME="SYSTEM"></A><B><A HREF="#SYSTEM">SYSTEM</A> [n]
<A HREF="#QUIT">QUIT</A> [n]</B>

n: <A HREF="#iexp">iexp</A>

The commands <A HREF="#SYSTEM">SYSTEM</A> and <A HREF="#QUIT">QUIT</A> are equivalent in their effect, as they both
terminate program execution and leave <A HREF="#GFA-Basic">GFA-Basic</A><A HREF="#.">.</A> Unlike in Version 2, <A HREF="#SYSTEM">SYSTEM</A>
and <A HREF="#QUIT">QUIT</A> return a 2 byte integer value to the calling routine (normally the
Desktop)<A HREF="#.">.</A> This integer has a value of zero if the Interpreter was terminated
correctly and left the calling program to hand over to the Desktop.

The convention applied in this case is that zero signals an error free run. A
positive 16 bit number signals the occurrence of an internal error or a warning
and a negative 16 bit number mostly points to the appropriate operating system
error message. However this is not adhered to by all programs.

<B>Example:</B>

    <A HREF="#RESERVE">RESERVE</A> 100
    <A HREF="#PRINT">PRINT</A> <A HREF="#EXEC">EXEC</A>(0,"GFABASIC.PRG","","")

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> This short program starts by reducing the work space for BASIC to 100
    bytes, it then loads and runs a second copy of the <A HREF="#GFA-Basic">GFA-Basic</A> program. If
    the program below is run, the operation of the second copy of <A HREF="#GFA-Basic">GFA-Basic</A> is
    terminated and returns the value 23 to the original <A HREF="#GFA-Basic">GFA-Basic</A><A HREF="#.">.</A> This value
    will then be printed.

    <A HREF="#PRINT">PRINT</A> "This is the second level GFA BASIC"
    <A HREF="#QUIT">QUIT</A> 23

<B>Memo:</B> Trying to pass error code 0 out is a bit of a problem since
      the documentation for Pterm() states that 0 <A HREF="#=">=</A> Ok. GFA really should
      not have defined 0 as an error code.

Pterm()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="Program_Tracing">Program Tracing</H2>
<A HREF="#TRON">TRON</A>, <A HREF="#TROFF">TROFF</A>
<A HREF="#TRON_#">TRON #</A>
<A HREF="#TRON_proc">TRON proc</A>
<A HREF="#TRACE$">TRACE$</A>
<A HREF="#DUMP">DUMP</A>

<B>Memo:</B> The tracing commands are not usable in compiled applications.
<HR SIZE=3><H2 ID="TRON">TRON</H2>
<A NAME="TROFF"></A><A NAME="TRON_#"></A><B><A HREF="#TRON">TRON</A>
<A HREF="#TRON">TRON</A> #n
<A HREF="#TROFF">TROFF</A></B>

n: <A HREF="#iexp">iexp</A>

The command <A HREF="#TRON">TRON</A> (TRace ON) causes each command to be listed on the screen as
they are executed. This list can be diverted to a printer or the serial
interface by specifying the relevant channel number. The command <A HREF="#TROFF">TROFF</A> turns
the TRace OFF again.

<B>Example:</B>

    <A HREF="#PRINT">PRINT</A> "Start:"
    <A HREF="#TRON">TRON</A>
    <A HREF="#FOR">FOR</A> i%=1 TO 5
      <A HREF="#PRINT">PRINT</A> i%
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#TROFF">TROFF</A>
    <A HREF="#PRINT">PRINT</A> "End"

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The word 'Start:' appears on the screen, then the numbers from 1 to 5 are
    displayed, along with the commands which lead to their display. After that
    the word 'End' is displayed.

    <A HREF="#OPEN">OPEN</A> "o",#1,"\tron.lst"
    <A HREF="#TRON">TRON</A> #1
    <A HREF="#FOR">FOR</A> i%=1 TO 10
      <A HREF="#PRINT">PRINT</A> i%
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#TROFF">TROFF</A>
    <A HREF="#CLOSE">CLOSE</A> #1
    <A HREF="#'">'</A>
    <A HREF="#OPEN">OPEN</A> "O",#2,"prn:"
    <A HREF="#TRON">TRON</A> #2
    <A HREF="#FOR">FOR</A> i%=10 TO 630 <A HREF="#STEP">STEP</A> 10
      <A HREF="#LINE">LINE</A> i%,0,i%,100
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#TROFF">TROFF</A>
    <A HREF="#CLOSE">CLOSE</A> #2

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The numbers from 1 to 10 are displayed, along with the relevant commands
    and a row of vertical lines at a distance of 10 pixels. This output is
    directed to disk or printer.

<B>Memo:</B> See section <A HREF="#'">'</A><A HREF="#The_Modifier_Keys">The Modifier Keys</A>'<A HREF="#.">.</A>
      <A HREF="#TRON">TRON</A> is not usable in compiled applications.
<HR SIZE=3><H2 ID="TRACE$">TRACE$</H2>
<A NAME="TRON_proc"></A><B><A HREF="#TRON_proc">TRON proc</A>
<A HREF="#TRACE$">TRACE$</A></B>

proc: procedure name

With help of the instruction <A HREF="#'">'</A><A HREF="#TRON_proc">TRON proc</A>', a procedure can be specified which is
called before the execution of each individual command. The variable <A HREF="#TRACE$">TRACE$</A>
then contains the command which is to be processed next. The command <A HREF="#TRON_proc">TRON proc</A>
makes for very efficient error tracing when used in conjunction with <A HREF="#TRACE$">TRACE$</A><A HREF="#.">.</A> In
addition, as well the next command to be processed being displayed, specified
variables can be output to screen or printer, allowing changes in the variables
to be followed during the course of the program run.

It is important that the <A HREF="#TRON">TRON</A> procedure should not affect the program itself
while running, so while in use, no <A HREF="#PRINT">PRINT</A> commands should be made to the screen
(<A HREF="#TEXT">TEXT</A>, <A HREF="#ATEXT">ATEXT</A>, <A HREF="#.">.</A>..) and the use of <A HREF="#VDI">VDI</A> routines should be avoided because of
GDOS's use of <A HREF="#DEFTEXT">DEFTEXT</A>, <A HREF="#Line-A">Line-A</A>, etc.

<B>Example:</B>

    <A HREF="#TRON">TRON</A> tr_proc
    <A HREF="#GRAPHMODE">GRAPHMODE</A> 3
    <A HREF="#DO_UNTIL">DO UNTIL</A> <A HREF="#MOUSEK">MOUSEK</A>
      x1%=100+<A HREF="#RAND">RAND</A>(200)
      y1%=100+<A HREF="#RAND">RAND</A>(100)
      x2%=200+<A HREF="#RAND">RAND</A>(200)
      y2%=200+<A HREF="#RAND">RAND</A>(100)
      <A HREF="#PBOX">PBOX</A> xl%,y1%,x2%,y2%
    <A HREF="#LOOP">LOOP</A>
    <A HREF="#'">'</A>
    <A HREF="#PROCEDURE">PROCEDURE</A> tr_proc
      <A HREF="#IF">IF</A> <A HREF="#BIOS">BIOS</A>(11,-1) <A HREF="#AND">AND</A> 4 <A HREF="#!">!</A> Control key
        adr%<A HREF="#=">=</A><A HREF="#XBIOS">XBIOS</A>(2)
        <A HREF="#BMOVE">BMOVE</A> adr%+1280,adr%,4*1280
        <A HREF="#PRINT_AT">PRINT AT</A>(1,5)<A HREF="#;">;</A><A HREF="#SPACE$">SPACE$</A>(80);
        <A HREF="#PRINT_AT">PRINT AT</A>(1,5)<A HREF="#;">;</A><A HREF="#LEFT$">LEFT$</A>(<A HREF="#TRACE$">TRACE$</A>,79);
        <A HREF="#PAUSE">PAUSE</A> 20
      <A HREF="#ENDIF">ENDIF</A>
    <A HREF="#RETURN">RETURN</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> This program draws randomly-distributed rectangles on the screen. Pressing
    the Control key causes the command just processed to appear on the screen.
    The program is terminated by the pressing of a mouse button.

<B>Memo:</B> <A HREF="#TRON">TRON</A> is not usable in compiled applications.
      The editor does not report a missing procedure with <A HREF="#TRON_proc">TRON proc</A><A HREF="#.">.</A>
<HR SIZE=3><H2 ID="DUMP">DUMP</H2>
<B><A HREF="#DUMP">DUMP</A> [a$[TO b$]]</B>

a$, b$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>

With the help of the <A HREF="#DUMP">DUMP</A> command, the contents of variables can be displayed
during a program run; or labels, procedures, and functions listed.  In addition
the string expression a$ can accept the following:

<B>Examples:</B>

    <A HREF="#DUMP">DUMP</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Returns all values of variables and the dimensioning of arrays.

    <A HREF="#DUMP">DUMP</A> "a"

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> As above but only operates on variables or arrays which begin with 'a'<A HREF="#.">.</A>

    <A HREF="#DUMP">DUMP</A> "<A HREF="#:">:</A>"
    <A HREF="#DUMP">DUMP</A> ":b"

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Lists all labels and specifies the Editor line number where each label is
    used. The variation (:b) lists only those labels which begin with 'b'.

    <A HREF="#DUMP">DUMP</A> "<A HREF="#@">@</A>"
    <A HREF="#DUMP">DUMP</A> "@b"

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Lists all procedures and functions and specifies the Editor line number
    where each is found. The variation (@b) lists only those procedures and
    functions which begin with 'b'<A HREF="#.">.</A>

    proc_name <A HREF="#@">@</A> 100     (procedure)
    func_name <A HREF="#FN">FN</A> 200    (function returning a numerical value)
    func_name <A HREF="#$">$</A> <A HREF="#FN">FN</A> 300  (function returning a string)

Labels, procedures, and functions which are no longer defined, are specified
without Editor line numbers. If the program listing was saved with the <A HREF="#SAVE">SAVE</A>,A
option and then newly reloaded, these undefined names no longer appear. However
labels, procedures, and function names which are still usable but not defined,
are displayed without Editor line numbers.

<A HREF="#The_Editor">The Editor</A> line number specified after the name can be jumped to in the Editor
by means of Control+G.

When the contents of a string is output, a maximum of 60 characters is
displayed. If the character string is longer than this, then the last character
displayed is <A HREF="#'">'</A><A HREF="#&#62;">&#62;</A>'<A HREF="#.">.</A> If a control character, i.e. <A HREF="#ASCII">ASCII</A> value <A HREF="#&#60;">&#60;</A> 32, is to be
displayed, this is replaced by a period.

The outputs mentioned above can also be directed to a file and, in this case,
the file name must be specified in b$<A HREF="#.">.</A>

If no extension is specified a default extension of <A HREF="#'">'</A>.DMP' is used.

<B>Memo:</B> See section <A HREF="#'">'</A><A HREF="#The_Modifier_Keys">The Modifier Keys</A>'<A HREF="#.">.</A>
      Only the first two characters of parameter a$ are evaluated.
      Parameters other than the ones noted above are simply ignored.
<HR SIZE=3><H2 ID="Chapter__8_-_Graphics">Chapter  8 - Graphics</H2>
Three different graphic modes are available on the Atari ST: one black and
white mode and two color modes. The actual screen coordinates available for the
graphic commands and the colors representable with them depend on the current
resolution. An overview of the available graphic modes is given below:

    <B>Mode       Resolution  Color  Palette      Memory</B>
    ST Low     320x200     16     512/4096     32000
    ST Medium  640x200     4      512/4096     32000
    ST High    640x400     2      back/white   32000
    TT Low     320x240     256    4096         153600
    TT Medium  640x480     16     4096         153600
    TT High    1280x960    2      black/white  153600

<B>Note:</B> With the release of the STe the palette was expanded from 512 to
      4096 colors. ST high on the TT is actually duo-chrome, meaning any two
      colors can be used instead of the usual black and white.

In the first section, the commands for the selection of colors (<A HREF="#SETCOLOR">SETCOLOR</A>,
<A HREF="#COLOR">COLOR</A>) are covered. After that, the commands for the selection and generation
of different types of mouse pointers, display symbols, fill patterns, frames,
and line types (<A HREF="#DEFMOUSE">DEFMOUSE</A>, <A HREF="#DEFMARK">DEFMARK</A>, <A HREF="#DEFFILL">DEFFILL</A>, <A HREF="#BOUNDARY">BOUNDARY</A>, <A HREF="#DEFLINE">DEFLINE</A>) are explained.

The next section describes the <A HREF="#CLIP">CLIP</A> commands, which are used to trim graphic
displays, and the general graphic commands for drawing different geometrical
basic forms (<A HREF="#PLOT">PLOT</A>, <A HREF="#LINE">LINE</A>, <A HREF="#BOX">BOX</A>, <A HREF="#CIRCLE">CIRCLE</A>, and <A HREF="#ELLIPSE">ELLIPSE</A>)<A HREF="#.">.</A> The various options for
producing polygons (<A HREF="#POLYLINE">POLYLINE</A>, <A HREF="#POLYMARK">POLYMARK</A>, and <A HREF="#POLYFILL">POLYFILL</A>) are described along with
the graphic text command <A HREF="#TEXT">TEXT</A><A HREF="#.">.</A>  The section ends with a description of the
instruction <A HREF="#FILL">FILL</A><A HREF="#.">.</A>

In the last part of this chapter, the treatment of screen sections with <A HREF="#SGET">SGET</A>,
<A HREF="#SPUT">SPUT</A>, <A HREF="#GET">GET</A>, and <A HREF="#PUT">PUT</A> is described.

<B>Memo:</B> The start-up code initializes the following:
      <A HREF="#BOUNDARY">BOUNDARY</A>     vsf_perimeter(1)    PERIMETER_ON
      <A HREF="#CLIP">CLIP</A>         vs_clip(1)          CLIP_ON (0,0,<A HREF="#WORK_OUT">WORK_OUT</A>(0),WORK_OUT(1))
      <A HREF="#CLIP_OFFSET">CLIP OFFSET</A>                      0,0
      <A HREF="#COLOR">COLOR</A>        vsl_color(1)        1
      <A HREF="#GRAPHMODE">GRAPHMODE</A>    vswr_mode(1)        MD_REPLACE
      <A HREF="#DEFFILL">DEFFILL</A>      vsf_color(1)        1
      <A HREF="#DEFFILL">DEFFILL</A>      vsf_interior(1)     FIS_SOLID
      <A HREF="#DEFFILL">DEFFILL</A>      vsf_style(0)        0
      <A HREF="#DEFLINE">DEFLINE</A>      vsl_type(0)         SOLID
      <A HREF="#DEFLINE">DEFLINE</A>      vsl_width(1)        1
      <A HREF="#DEFLINE">DEFLINE</A>      vsl_ends(0,0)       SQUARE,SQUARE
      <A HREF="#DEFMARK">DEFMARK</A>      vsm_color(1)        1
      <A HREF="#DEFMARK">DEFMARK</A>      vsm_type(1)         FIS_SOLID
      <A HREF="#DEFMARK">DEFMARK</A>      vsm_height(1)       1
      <A HREF="#DEFTEXT">DEFTEXT</A>      vst_color(1)        1
      <A HREF="#DEFTEXT">DEFTEXT</A>      vst_effects(0)      normal (none)
      <A HREF="#DEFTEXT">DEFTEXT</A>      vst_rotation(0)     left to right
      <A HREF="#DEFTEXT">DEFTEXT</A>      vst_height(<A HREF="#?">?</A>)       workstation default
      <A HREF="#DEFTEXT">DEFTEXT</A>      vst_font(<A HREF="#?">?</A>)         workstation default
      <A HREF="#TEXT">TEXT</A>         vst_alignment(0,1)  left justified/base line
<HR SIZE=3><H2 ID="Graphics_Definition_Commands">Graphics Definition Commands</H2>
<A HREF="#SETCOLOR">SETCOLOR</A>, <A HREF="#VSETCOLOR">VSETCOLOR</A>
<A HREF="#COLOR">COLOR</A>
<A HREF="#DEFMOUSE">DEFMOUSE</A>
<A HREF="#DEFMARK">DEFMARK</A>
<A HREF="#DEFFILL">DEFFILL</A>
<A HREF="#BOUNDARY">BOUNDARY</A>
<A HREF="#DEFLINE">DEFLINE</A>
<A HREF="#DEFTEXT">DEFTEXT</A>
<A HREF="#GRAPHMODE">GRAPHMODE</A>

<B>Memo:</B> The interpreter doesn't do any range checking on the parameters
      passed to the graphics commands. How the <A HREF="#VDI">VDI</A> handles such situations
      will be the end result, as the parameters are passed as is.
<HR SIZE=3><H2 ID="SETCOLOR">SETCOLOR</H2>
<A NAME="VSETCOLOR"></A><A NAME="COLOR"></A><B><A HREF="#COLOR">COLOR</A> color
<A HREF="#SETCOLOR">SETCOLOR</A> register,red,green,blue
<A HREF="#SETCOLOR">SETCOLOR</A> register,composite
<A HREF="#VSETCOLOR">VSETCOLOR</A> color,red,green,blue
<A HREF="#VSETCOLOR">VSETCOLOR</A> color,composite</B>

register, red, green, blue, composite, color: <A HREF="#iexp">iexp</A>

The command <A HREF="#COLOR">COLOR</A> determines the line color. Values between 0 and 255,
dependant on the current resolution, are valid.

The first variant of <A HREF="#SETCOLOR">SETCOLOR</A> determines the proportion of the colors red,
green, and blue in a particular color register. The intensity of the color
element is specified on a scale from 0 (low) to 15 (high) and the number of
available color registers depends on the current resolution. In the second
variant of <A HREF="#SETCOLOR">SETCOLOR</A>, the color setting is defined by a single parameter whose
value is computed by the following formula:

    composite <A HREF="#=">=</A> red <A HREF="#*">*</A> 256 <A HREF="#+">+</A> green * 16 + blue * 1

and, as with the other setting, the values for red, green, and blue are
specified on a scale from 0 to 15.

The setting of color elements in the color registers is, naturally, only
applicable when in the color modes. However, in the monochrome mode, when a
composite value other than 0 or 1 is specified, even numbers have the same
effect as 0 and odd numbers the same effect as 1.

<B>Example:</B>

    <A HREF="#SETCOLOR">SETCOLOR</A> 0,0

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> On a mono monitor, the display appears as white on a black background.

Through an apparently unexpected mix-up in the design of the operating system,
the color registers used by <A HREF="#SETCOLOR">SETCOLOR</A> do not correspond directly to the numbers
used by <A HREF="#COLOR">COLOR</A><A HREF="#.">.</A> To overcome this the command <A HREF="#VSETCOLOR">VSETCOLOR</A> is available.

The values of red, green, and blue are numbers in the range 0 to 15. The term
composite is calculated in the same manner as <A HREF="#SETCOLOR">SETCOLOR</A>, i.e.<A HREF="#:">:</A>

    composite <A HREF="#=">=</A> red <A HREF="#*">*</A> 256 <A HREF="#+">+</A> green * 16 + blue * 1

<A HREF="#VSETCOLOR">VSETCOLOR</A> 1,2,3,4 is the same as VSETCOLOR 1,&H234

The syntax of the <A HREF="#VSETCOLOR">VSETCOLOR</A> command is virtually identical to that of <A HREF="#SETCOLOR">SETCOLOR</A>,
the sole difference being in the parameters 'register' and 'color'<A HREF="#.">.</A> They are
related as shown:

For monochrome modes:
<A HREF="#SETCOLOR">SETCOLOR</A> 0,even   corresponds to   <A HREF="#VSETCOLOR">VSETCOLOR</A> 0,0
<A HREF="#SETCOLOR">SETCOLOR</A> 0,odd    corresponds to   <A HREF="#VSETCOLOR">VSETCOLOR</A> 0,&HFFF

For 4 color modes:
<A HREF="#SETCOLOR">SETCOLOR</A>   00  01  02  03
<A HREF="#VSETCOLOR">VSETCOLOR</A>  00  02  03  01

For 16 color modes:
<A HREF="#SETCOLOR">SETCOLOR</A>   00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15
<A HREF="#VSETCOLOR">VSETCOLOR</A>  00  02  03  06  04  07  05  08  09  10  11  14  12  15  13  01

For 256 color modes:
See <A HREF="#256_color_VDI/Hardware_table">256 color VDI/Hardware table</A><A HREF="#.">.</A>

<B>Example:</B>

    <A HREF="#'">'</A> In Low resolution
    <A HREF="#FOR">FOR</A> i%=0 TO 15
      <A HREF="#DEFFILL">DEFFILL</A> i%
      <A HREF="#PBOX">PBOX</A> i%+20,0,319,199
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#DO">DO</A>
      a%<A HREF="#=">=</A><A HREF="#INP">INP</A>(2)
      <A HREF="#EXIT_IF">EXIT IF</A> a%=27
      <A HREF="#VSETCOLOR">VSETCOLOR</A> a% <A HREF="#AND">AND</A> 15,<A HREF="#RAND">RAND</A>(-1)
    <A HREF="#LOOP">LOOP</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> This program draws overlapping color boxes, the result being 16 vertical
    bars (the left hand one is the same color as the border, i.e.  color 0). By
    ANDing the key code with 15, a color register number can be chosen and this
    register is then set to a random value. The program is left by using the
    Escape key.

<B>Memo:</B> <A HREF="#'">'</A><A HREF="#VSETCOLOR">VSETCOLOR</A> i,rgb' contains a bug such that the red and blue values
      end up swapped. This happens in the editor and compiled.

      <A HREF="#SETCOLOR">SETCOLOR</A> uses a 15-bit mask that should be 12-bits (editor bug only)<A HREF="#.">.</A>
        'rrrrggggbbbb'

      When using vq_color() always set 'flag' to 1, otherwise you can get
      values greater than 1000.

vsl_color()<A HREF="#+">+</A>, vs_color()+, EsetColor()+, Setcolor()+, vq_color()+
<HR SIZE=3><H2 ID="DEFMOUSE">DEFMOUSE</H2>
<B><A HREF="#DEFMOUSE">DEFMOUSE</A> symbol
<A HREF="#DEFMOUSE">DEFMOUSE</A> bitpattern$</B>

symbol: <A HREF="#iexp">iexp</A>
bitpattern$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>

The first <A HREF="#DEFMOUSE">DEFMOUSE</A> variant determines the current mouse pointer, selected from
the eight pre-defind types. The value of 'symbol' defines the type of the
pointer in the following way:

    0  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Arrow

    1  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Text cursor

    2  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Busy bee

    3  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Pointing hand

    4  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Open hand

    5  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Thin cross-hair

    6  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Thick cross-hair

    7  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Outlined cross-hair

    8  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Arrows all directions      NAES

    9  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Arrows left and right      NAES

   10  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Arrows up and down         NAES

The second variant of the <A HREF="#DEFMOUSE">DEFMOUSE</A> command allows the user to define a mouse
pointer. The action point, the mask color, the pointer color, the bit design
pattern for the appearance of the mask, and the appearance of the mouse pointer
are specified by means of a character string. The action point, is that point
of the mouse pointer whose coordinates are defined as the mouse position. If
the mouse position is interrogated, it is the coordinates of the action point
which are returned.

All these values must be entered as word size values and the command <A HREF="#MKI$">MKI$</A><A HREF="#()">()</A> can
be used for this purpose. Thus, bitpattern$ is assembled as follows:

bitpattern$ <A HREF="#=">=</A> <A HREF="#MKI$">MKI$</A>(x-coordinate action point)
            <A HREF="#+">+</A> <A HREF="#MKI$">MKI$</A>(y-coordinate action point)
            <A HREF="#+">+</A> <A HREF="#MKI$">MKI$</A>(1)                         !1=bit-planes (required)
            <A HREF="#+">+</A> <A HREF="#MKI$">MKI$</A>(mask color)                !normally 0
            <A HREF="#+">+</A> <A HREF="#MKI$">MKI$</A>(cursor color)              !normally 1
            <A HREF="#+">+</A> mask$                           !bit pattern of the mask
            <A HREF="#+">+</A> cursor$                         !bit pattern of the cursor

mask$ and cursor$ consist of 16 words each, each word being the bit pattern of
a line.

<B>Example:</B>

    <A HREF="#DEFMOUSE">DEFMOUSE</A> 2
    <A HREF="#DELAY">DELAY</A> 1
    m$<A HREF="#=">=</A><A HREF="#MKI$">MKI$</A>(0)+MKI$(0)+MKI$(1)+MKI$(0)+MKI$(1)
    <A HREF="#FOR">FOR</A> i%=1 TO 16
      m$=m$<A HREF="#+">+</A><A HREF="#MKI$">MKI$</A>(65535)
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#FOR">FOR</A> i%=1 TO 16
      m$=m$<A HREF="#+">+</A><A HREF="#MKI$">MKI$</A>(1)
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#PBOX">PBOX</A> 200,150,400,250
    <A HREF="#DEFMOUSE">DEFMOUSE</A> m$
    <A HREF="#REPEAT">REPEAT</A>
    <A HREF="#UNTIL">UNTIL</A> <A HREF="#MOUSEK">MOUSEK</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> First, a bee appears as a mouse pointer. Then after one second, the mouse
    pointer turns into a line. When the mouse is placed on the black background
    at the center of the screen, the mouse changes to a rectangle, the mask
    having been defined as this rectangle. The final loop is then left by
    pressing a mouse button.

<B>Memo:</B> Values larger than 7 for 'symbol' do not work.
      To use values over 7 one must call <A HREF="#GRAF_MOUSE">GRAF_MOUSE</A><A HREF="#()">()</A> instead.
      <A HREF="#DEFMOUSE">DEFMOUSE</A> m  <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> <A HREF="#AES">AES</A> call to <A HREF="#GRAF_MOUSE">GRAF_MOUSE</A><A HREF="#()">()</A>
      <A HREF="#DEFMOUSE">DEFMOUSE</A> m$ <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> <A HREF="#VDI">VDI</A> call to vsc_form()

      The string should be exactly 74 bytes.
      No error handling on the string length at all.

graf_mouse()<A HREF="#+">+</A>, vsc_form()+
<HR SIZE=3><H2 ID="DEFMARK">DEFMARK</H2>
<B><A HREF="#DEFMARK">DEFMARK</A> [color],[type],[height]</B>

color, type, height: <A HREF="#iexp">iexp</A>

<A HREF="#DEFMARK">DEFMARK</A> determines the color, type, and height of the marks, at the corner
points of a polygon, which are displayed by the command <A HREF="#POLYMARK">POLYMARK</A><A HREF="#.">.</A> According to
the actual screen resolution, values between 0 and 255 can be assigned to the
numerical expression 'color' (see the start of this chapter)<A HREF="#.">.</A> The 'type'
parameter gives the following corner marks:

    <B>Type  Description  Output</B>
    1     Dot              (single pixel)
    2     Plus
    3     Star
    4     Square
    5     Cross
    6     Diamond

Values larger than 6 result in the use of the star as the corner mark. Values
for the 'height' of the shape are specified in pixels. Thus a value of 8 will
produce a mark that is 8 x 8 pixels in height. When only the second parameter
or third parameter of the command are required, one can omit the parameter in
question and enter only the parameter-separating commas. Thus,

    <A HREF="#DEFMARK">DEFMARK</A> ,,4

means that the first two parameters keep their current value and the height of
the marks is set to 4.

<B>Example:</B>

    <A HREF="#DIM">DIM</A> x%(1),y%(1)
    x%(0)=50
    y%(0)=50
    x%(1)=150
    y%(1)=150
    <A HREF="#DEFMARK">DEFMARK</A> 1,4,2
    <A HREF="#POLYMARK">POLYMARK</A> 2,x%<A HREF="#()">()</A>,y%()
    <A HREF="#DEFMARK">DEFMARK</A> ,3,4
    <A HREF="#POLYMARK">POLYMARK</A> 2,x%<A HREF="#()">()</A>,y%() <A HREF="#OFFSET">OFFSET</A> 100,0

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> This draws two pairs of points with different corner marks.

    <A HREF="#VDI">VDI</A> calls:
    <A HREF="#DEFMARK">DEFMARK</A> vsm_color(),vsm_type(),vsm_height()

vsm_color()<A HREF="#+">+</A>, vsm_type()+, vsm_height()+
<HR SIZE=3><H2 ID="DEFFILL">DEFFILL</H2>
<B><A HREF="#DEFFILL">DEFFILL</A> [color],[interior],[style]
<A HREF="#DEFFILL">DEFFILL</A> [color],bitpattern$</B>

color, interior, style: <A HREF="#iexp">iexp</A>
bitpattern$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>

This command determines the fill used for the commands <A HREF="#PBOX">PBOX</A>, <A HREF="#PCIRCLE">PCIRCLE</A>,
<A HREF="#PELLIPSE">PELLIPSE</A>, <A HREF="#POLYFILL">POLYFILL</A>, and <A HREF="#FILL">FILL</A><A HREF="#.">.</A> It sets the color, interior, and style of the
filling and enables one to define one's own patterns. The fill color can be
assigned values from 0 to 255, depending on the currnet screen resolution (see
the beginning of this chapter)<A HREF="#.">.</A> The following results are obtained from
assignment of values to 'interior'<A HREF="#:">:</A>

    <B>interior  Description    Comment</B>
    0         Hollow         always color <A HREF="#index">index</A> 0
    1         Solid          as set by vsf_color()
    2         Pattern        style set by vsf_style()
    3         Hatch          style set by vsf_style()
    4         User defined   as set by vsf_udpat()     (default <A HREF="#&">&</A>#47;&#92; symbol)

Style can be selected from 24 pattern fills or 12 hatch fills by means of the
'style' parameter (see Appendix: <A HREF="#Fill_Pattern_Table">Fill Pattern Table</A>)<A HREF="#.">.</A> Parameters can be
omitted from this definition, as long as the parameter-separating commas are
included. Thus,

    DEFILL ,2,4

selects the fill-pattern 2,4 and leaves the fill color as previously defined.

In the second variation of the command <A HREF="#DEFFILL">DEFFILL</A>, using the 32 byte parameter
'bitpattern$', a 16 x 16 pixel pattern can be defined. This information must be
presented in word format and can be assembled by means of the <A HREF="#MKI$">MKI$</A><A HREF="#()">()</A> command.

The medium resolution fill pattern is represented by two bit-planes which are
combined to define the actual colors produced. The 16 words for the second
bit-plane optionally follow the 16 words of the first.

The first bits from each of these bit-planes are combined, this two bit number
(in the range 0 to 3) represents the color of the pixel at the top left corner
of the block. The second pair of bits represents the color of the second pixel,
to the right of the first, and so on.

For low resolution, four bit-planes are needed to represent a color fill
pattern (one plane could be used but this would giva a single color pattern),
therefore the bit pattern must be 64 words (128 bytes) in length.

The first bit-plane represents the least significant bit of the color. If
however the second of these planes is left off, this will result in a single
color fill pattern, the color being that chosen in the parameter 'color'<A HREF="#.">.</A>

<B>Example:</B>

    <A HREF="#DEFFILL">DEFFILL</A> 1,2,4
    <A HREF="#PBOX">PBOX</A> 10,10,40,40
    <A HREF="#BOX">BOX</A> 50,50,100,100
    <A HREF="#FILL">FILL</A> 70,70
    <A HREF="#FOR">FOR</A> i=1 TO 16
      f$=f$<A HREF="#+">+</A><A HREF="#MKI$">MKI$</A>(<A HREF="#RAND">RAND</A>(65535))
    <A HREF="#NEXT">NEXT</A> i
    <A HREF="#BOX">BOX</A> 100,100,150,150
    <A HREF="#DEFFILL">DEFFILL</A> 1,f$
    <A HREF="#FILL">FILL</A> 120,120

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Draws two boxes filled with a standard pattern and a third filled with a
    random pattern.

    <A HREF="#DO">DO</A>
      <A HREF="#FOR">FOR</A> j%=0 TO 15
        f$<A HREF="#=">=</A>""
        s%<A HREF="#=">=</A><A HREF="#BCHG">BCHG</A>(s%,j%)
        <A HREF="#FOR">FOR</A> i%=1 TO 16
          f$=f$<A HREF="#+">+</A><A HREF="#MKI$">MKI$</A>(s%)
        <A HREF="#NEXT">NEXT</A> i%
        <A HREF="#DEFFILL">DEFFILL</A> 1,f$
        <A HREF="#PBOX">PBOX</A> 0,0,639,399
      <A HREF="#NEXT">NEXT</A> j%
    <A HREF="#LOOP">LOOP</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Parallel vertical bars are displayed and increase in size until they fill
    the screen. This is done by defining and altering a fill pattern and
    displaying a rectangle filled with this pattern.

    <A HREF="#FOR">FOR</A> i%=1 TO 64 !64 for low, 32 for medium, and 16 for high resolution
      <A HREF="#READ">READ</A> a%
      a$=a$<A HREF="#+">+</A><A HREF="#MKI$">MKI$</A>(a%)
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#DEFFILL">DEFFILL</A> ,a$
    <A HREF="#PBOX">PBOX</A> 20,20,300,200
    <A HREF="#'">'</A> First Bit-plane:
    <A HREF="#DATA">DATA</A> -1,-1,-1,-1,-1,-1,-1,-1,0,0,0,0,0,0,0,0
    <A HREF="#'">'</A> Second Bit-plane:
    <A HREF="#DATA">DATA</A> -1,-1,-1,-1,0,0,0,0,-1,-1,-1,-1,0,0,0,0
    <A HREF="#'">'</A> Third Bit-plane:
    <A HREF="#DATA">DATA</A> -1,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0
    <A HREF="#'">'</A> Fourth Bit-plane:
    <A HREF="#DATA">DATA</A> -1,0,-1,0,-1,0,-1,0,-1,0,-1,0,-1,0,-1,0

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> This routine creates a filled pattern which, on a mono monitor, has two
    broad black and white strips. In medium resolution, four strips of half the
    width are produced in the four possible colors. In the case of the low
    resolution mode, 16 strips of one line height result, in all 16 colors.
    This pattern is then used to fill a box by <A HREF="#PBOX">PBOX</A><A HREF="#.">.</A>

    <A HREF="#VDI">VDI</A> calls:
    <A HREF="#DEFFILL">DEFFILL</A> vsf_color(),vsf_interior(),vsf_style()
    <A HREF="#DEFFILL">DEFFILL</A> vsf_color(),vsf_udpat()

<B>Memo:</B> No error handling on the string length at all.

      Planes   <A HREF="#LEN">LEN</A><A HREF="#()">()</A> in bytes     Words
      <A HREF="#-">-</A>------  -----------------  -----
      1        32    (16*16*1)/8  16  (works in any mode)
      2        64    (16*16*2)/8  32
      4        128   (16*16*4)/8  64
      8        256   (16*16*8)/8  128
      15       1024  16*16*4      512 (exceeds <A HREF="#INTIN">INTIN</A><A HREF="#()">()</A> array limits)
      16       1024  <A HREF="#.">.</A>.           ..
      24       1024  <A HREF="#.">.</A>.           ..
      32       1024  <A HREF="#.">.</A>.           ..

      If the mode is High or True color, pass a pattern with 32-bit pixels.
      The format is always 'xrgb', one long per pixel.

vsf_color()<A HREF="#+">+</A>, vsf_interior()+, vsf_style()+, vsf_udpat()+
<HR SIZE=3><H2 ID="BOUNDARY">BOUNDARY</H2>
<B><A HREF="#BOUNDARY">BOUNDARY</A> n</B>

n: <A HREF="#iexp">iexp</A>

The command <A HREF="#BOUNDARY">BOUNDARY</A> uses the Function vsf_perimeter() to switch off (or on)
the border normally drawn round a filled shape (with <A HREF="#PBOX">PBOX</A>, <A HREF="#PCIRCLE">PCIRCLE</A>, etc)<A HREF="#.">.</A> When
n is not zero, a border is drawn around the filled area, when it is zero, no
border is drawn.

<B>Example:</B>

    <A HREF="#DEFFILL">DEFFILL</A> 1,2,2
    <A HREF="#BOUNDARY">BOUNDARY</A> 1          !switch on border
    <A HREF="#PBOX">PBOX</A> 50,50,100,100
    <A HREF="#BOUNDARY">BOUNDARY</A> 0          !swith off border
    <A HREF="#PBOX">PBOX</A> 150,50,200,100

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Draws two filled rectangles, one with and one without a border.

    Internally calls vsf_perimeter()<A HREF="#.">.</A>

vsf_perimeter()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="DEFLINE">DEFLINE</H2>
<B><A HREF="#DEFLINE">DEFLINE</A> [style],[width],[start],[end]</B>

style, width, start, end: <A HREF="#iexp">iexp</A>

The command <A HREF="#DEFLINE">DEFLINE</A> determines the appearance of lines drawn with the commands
<A HREF="#LINE">LINE</A>, <A HREF="#BOX">BOX</A>, <A HREF="#RBOX">RBOX</A>, <A HREF="#CIRCLE">CIRCLE</A>, <A HREF="#ELLIPSE">ELLIPSE</A>, and <A HREF="#POLYLINE">POLYLINE</A><A HREF="#.">.</A> The first parameter 'style'
determines the line style, with a choice between pre-defined and user-defined
styles. The following styles are available:

    <B>Style  Description    Output</B>
    1      Solid                            (default)
    2      Long dash
    3      Dotted
    4      Dash dot dash
    5      Short dash
    6      Dash dot dot
    7      User defined   N/A

User-defined patterns can be created from a 16-bit value in which each bit
corresponds to a set point in the monochrome mode. This is a special case and
must be a -negative 16-bit value.

The second parameter 'width' sets the width of the line in pixels and this
parameter must only have odd values. If even, the line width is rounded down
to the next smallest odd number. The start and end symbols of a line are
defined my means of 'start' and 'end'<A HREF="#.">.</A> The available options are:

    <B>Start/End  Description  Output</B>
    0          Square                          (default)
    1          Arrow
    2          Round

Parameters can be omitted in the definition providing the parameter-separating
commas are entered. Thus,

    <A HREF="#DEFLINE">DEFLINE</A> ,,1,1

specifies an arrow as a symbol for the line beginning and end, leaving the
style and width unchanged (see Appendix: <A HREF="#Line_Style_Table">Line Style Table</A>)<A HREF="#.">.</A>

<B>Example:</B>

    <A HREF="#FOR">FOR</A> i=1 TO 6
      <A HREF="#DEFLINE">DEFLINE</A> i
      <A HREF="#LINE">LINE</A> 50,i*50,200,i*50
    <A HREF="#NEXT">NEXT</A> i
    <A HREF="#DEFLINE">DEFLINE</A> 1,1,1,2
    <A HREF="#FOR">FOR</A> i=2 to 12 <A HREF="#STEP">STEP</A> 2
      <A HREF="#DEFLINE">DEFLINE</A> ,i
      <A HREF="#LINE">LINE</A> 250,i*25,400,i*25
    <A HREF="#NEXT">NEXT</A> i
    <A HREF="#DEFLINE">DEFLINE</A> <A HREF="#-">-</A>&X101010101010101,1,0,0
    <A HREF="#LINE">LINE</A> 500,10,500,390
    <A HREF="#VOID">VOID</A> <A HREF="#INP">INP</A>(2)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Lines in the six pre-defined styles are drawn followed by lines of
    different thickness. The line in the user-defined pattern is dotted.
    Finally, the program waits for a key to be pressed.

    <A HREF="#VDI">VDI</A> calls:
    <A HREF="#DEFLINE">DEFLINE</A> vsl_type(),vsl_width(),vsl_ends(),vsl_ends()

<B>Memo:</B> User defined examples: dotted line (&HAAAA)
      <A HREF="#DEFLINE">DEFLINE</A> &HFFFF5556
      <A HREF="#DEFLINE">DEFLINE</A> &X11111111111111110101010101010110
      Internally 'neg.w d0' is applied to the style parameter in this case.

      Parameters 'start' and 'end' are passed on to vsl_ends()<A HREF="#.">.</A> If you don't
      set both at once the other one gets reset to zero. Example:
        <A HREF="#DEFLINE">DEFLINE</A> ,,1   <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> start=1/end=0
        <A HREF="#DEFLINE">DEFLINE</A> ,,,1  <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> start=0/end=1
        <A HREF="#DEFLINE">DEFLINE</A> ,,1,1 <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> start=1/end=1
      If you want the opposite end to be reset to zero that's fine, but
      otherwise this seems odd to me. Normally settings stay set until
      changed, this one is an expection to the rule. To avoid confusion always
      set parameters 'start' and 'end' together.

vsl_type()<A HREF="#+">+</A>, vsl_width()+, vsl_ends()+, vsl_udsty()+
<HR SIZE=3><H2 ID="DEFTEXT">DEFTEXT</H2>
<B><A HREF="#DEFTEXT">DEFTEXT</A> [color],[attr],[angle],[height],[fontnr]</B>

color, attr, angle, height, fontnr: <A HREF="#iexp">iexp</A>

This command determines the appearance of a character string that is to be
displayed with <A HREF="#TEXT">TEXT</A><A HREF="#.">.</A> The parameter 'color', depending on the current
resolution, may contain a value between 0 and 255. The second parameter 'attr'
sets the text attributes which can be created by combinations of the values
given below:

    <B>Bit Value    Effect      Example</B>
    <A HREF="#-">-</A>    0  --<A HREF="#&#62;">&#62;</A>  Normal      Normal
    0    1  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Bold        <B>Bold</B>
    1    2  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Light       Light
    2    4  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Italic      <I>Italic</I>
    3    8  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Underlined  <U>Underlined</U>
    4   16  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Outlined    Outlined

The parameter 'angle' determines the direction of the text characters, the
value being specified in 1/10 degree steps in a clockwise direction.
















<B>Note:</B> However, only the following values are permitted by GEM:

       0  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  From left to right (default)
     900  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  From bottom to top
    1800  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  From right to left, upside down
    2700  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  From top to bottom

If a value other than one of the above is given, the nearest multiple of 900
is used.

The parameter 'height' specifies the text height of a capitol letter in pixels,
and with the normal character set only the following character heights are
actually readable:

     4  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Icon
     6  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Subscript
    13  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Normal character height
    32  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Expanded character height

Finally, the parameter 'fontnr' specifies the number of the desired character
set. This font must have previously been installed (see also GDOS:
<A HREF="#VST_LOAD_FONTS">VST_LOAD_FONTS</A><A HREF="#()">()</A>, <A HREF="#VQT_NAME">VQT_NAME</A>(), <A HREF="#.">.</A>..).

<B>Example:</B>

    <A HREF="#FOR">FOR</A> i&#124;=0 TO 5
      <A HREF="#DEFTEXT">DEFTEXT</A> 1,2^i&#124;,0,13
      <A HREF="#TEXT">TEXT</A> 100,i&#124;*16+100,"This is the text attribute "+<A HREF="#STR$">STR$</A>(i&#124;)
    <A HREF="#NEXT">NEXT</A> i&#124;

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Displays the example text with different attributes.

    <A HREF="#VDI">VDI</A> calls:
    <A HREF="#DEFTEXT">DEFTEXT</A> vst_color(),vst_effects(),vst_rotation(),vts_height(),vst_font()

vst_color()<A HREF="#+">+</A>, vst_effects()+, vst_rotation()+, vst_height()+, vst_font()+

<B>Memo:</B> Internally any call to this command also executes vqt_attributes()<A HREF="#.">.</A>
      This is done so text effects in windows will look the same.

      Only parameters used generate code. Example: <A HREF="#DEFTEXT">DEFTEXT</A> ,,,,font
      This example generates code only for vst_font()<A HREF="#.">.</A>
<HR SIZE=3><H2 ID="GRAPHMODE">GRAPHMODE</H2>
<B><A HREF="#GRAPHMODE">GRAPHMODE</A> n</B>

n: <A HREF="#iexp">iexp</A>

The command <A HREF="#GRAPHMODE">GRAPHMODE</A> determines the way in which graphics is output to the
screen with relation to what is already there and is important when pictures
are to be drawn on top of one another. Four possible modes can be represented
by the numerical expression n:

    1  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Replace
    2  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Transparent
    3  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Xor
    4  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Reverse transparent (inverted and transparent)

When 'n' has the value 1, the new drawing is simply drawn over the existing
screen contents obliterating it completely.

When n is equal to 2, the new drawing is ORed with the existing one, which
means that the old picture can still be seen behind the new one.

With n equal to 3, the new drawing is XORed with the existing one. This means
that, at each pixel where a graphic point was already present, that graphic dot
is deleted, and for all other points, the image is drawn normally. The
importance of this mode is that the process is reversible. By XORing the new
drawing with itself the original screen is restored. Thus, by using this mode,
animation is possible by repeated drawing and 'undrawing' of a figure as it is
moved around the screen.

In the case where n <A HREF="#=">=</A> 4, the new drawing is inverted and then ORed with the
existing one. In this way, a display similar to mode 2 is produced (n=2), but
the new picture is shown in reverse video.

<B>Example:</B>

    <A HREF="#FOR">FOR</A> i%=1 TO 4
      <A HREF="#GRAPHMODE">GRAPHMODE</A> i%
      <A HREF="#DEFFILL">DEFFILL</A> 1,3,8
      <A HREF="#PBOX">PBOX</A> 150*i%-100,10,150*i*,100
      <A HREF="#DEFFILL">DEFFILL</A> 1,2,10
      <A HREF="#PBOX">PBOX</A> 150*i%-140,50,150*i%-40,150
    <A HREF="#NEXT">NEXT</A> i%

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Four filled rectangles are drawn, and a further four are drawn partly
    overlapping the previous ones. Each pair is combined using a different
    <A HREF="#GRAPHMODE">GRAPHMODE</A> setting.

    Internally calls vswr_mode()<A HREF="#.">.</A>

vswr_mode()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="General_Graphics_Commands">General Graphics Commands</H2>
<A HREF="#CLIP">CLIP</A>, <A HREF="#CLIP_OFF">CLIP OFF</A>, <A HREF="#CLIP_OFFSET">CLIP OFFSET</A>
<A HREF="#PLOT">PLOT</A>
<A HREF="#LINE">LINE</A>
<A HREF="#DRAW">DRAW</A>, <A HREF="#DRAW_TO">DRAW TO</A>
<A HREF="#DRAW()">DRAW()</A>, <A HREF="#SETDRAW">SETDRAW</A>
<A HREF="#BOX">BOX</A>, <A HREF="#PBOX">PBOX</A>
<A HREF="#RBOX">RBOX</A>, <A HREF="#PRBOX">PRBOX</A>
<A HREF="#CIRCLE">CIRCLE</A>, <A HREF="#PCIRCLE">PCIRCLE</A>
<A HREF="#ELLIPSE">ELLIPSE</A>, <A HREF="#PELLIPSE">PELLIPSE</A>
<A HREF="#POLYLINE">POLYLINE</A>, <A HREF="#POLYMARK">POLYMARK</A>, <A HREF="#POLYFILL">POLYFILL</A>
<A HREF="#POINT">POINT</A><A HREF="#()">()</A>
<A HREF="#FILL">FILL</A>
<A HREF="#CLS">CLS</A>
<A HREF="#TEXT">TEXT</A>
<A HREF="#SPRITE">SPRITE</A>
<A HREF="#CURVE">CURVE</A>

First of all in this section, the use of the <A HREF="#CLIP">CLIP</A> commands in graphic displays
is considered.

The general graphic commands <A HREF="#PLOT">PLOT</A>, <A HREF="#LINE">LINE</A>, <A HREF="#BOX">BOX</A>, <A HREF="#RBOX">RBOX</A>, <A HREF="#CIRCLE">CIRCLE</A>, and <A HREF="#ELLIPSE">ELLIPSE</A> are
considered next. These draw points, lines, rectangles, rectangles with rounded
corners, circles, and ellipses, and by means of <A HREF="#PBOX">PBOX</A>, <A HREF="#PRBOX">PRBOX</A>, <A HREF="#PCIRCLE">PCIRCLE</A>, and
<A HREF="#PELLIPSE">PELLIPSE</A>, they can be filled with colors or patterns.

<A HREF="#POLYLINE">POLYLINE</A> draws a polygonal shape, and corner points made up of symbols defined
with <A HREF="#DEFMARK">DEFMARK</A> can be added using <A HREF="#POLYMARK">POLYMARK</A><A HREF="#.">.</A> <A HREF="#POLYFILL">POLYFILL</A> fills this Polygon with a
defined pattern, in a defind color. <A HREF="#POINT">POINT</A><A HREF="#()">()</A> returns the color of a particular
screen point. <A HREF="#FILL">FILL</A> fills a bordered area and <A HREF="#TEXT">TEXT</A> makes it possible to display
character strings in arbitrary places on the screen. <A HREF="#CLS">CLS</A> clears the entire
screen. At the end of the section, the command, <A HREF="#BITBLT">BITBLT</A> is covered.

The Origin (location 0,0) with all these graphic commands is located in the
top-left corner of the screen. The coordinates of graphic elements can lie
outside the actual screen display area but only the visible parts of the
graphics are represented.
<HR SIZE=3><H2 ID="CLIP">CLIP</H2>
<A NAME="CLIP_OFF"></A><A NAME="CLIP_OFFSET"></A><A NAME="OFFSET"></A><B><A HREF="#CLIP">CLIP</A> x,y,w,h [<A HREF="#OFFSET">OFFSET</A> x0,y0]
<A HREF="#CLIP">CLIP</A> x1,y1 TO x2,y2 [<A HREF="#OFFSET">OFFSET</A> x0,y0]
<A HREF="#CLIP">CLIP</A> #n [<A HREF="#OFFSET">OFFSET</A> x0,y0]
<A HREF="#CLIP_OFFSET">CLIP OFFSET</A> x0,y0
<A HREF="#CLIP_OFF">CLIP OFF</A></B>

x, y, w, h, x0, y0, x1, y1, x2, y2, n: <A HREF="#iexp">iexp</A>

This group of commands provides the 'Clipping' function, i.e. the limiting of
graphic displays within a specified rectangle screen area. <A HREF="#CLIP">CLIP</A> defines a
clipping rectangle for the <A HREF="#VDI">VDI</A> graphic commands. <A HREF="#ACLIP">ACLIP</A> does this for <A HREF="#Line-A">Line-A</A>
graphic routines. The screen area to be operated on, (clipping rectangle) can
be defined by the coordinates of the diagonally-opposite corner points; as well
as the top-left coordinate and the width and height of the clipping rectangle.

The command <A HREF="#CLIP">CLIP</A> x,y,w,h allows the input of the upper y-coordiante 'y', left
x-coordinate 'x' as well as the width 'w' and height 'h' of the clipping
rectangle.

The command <A HREF="#CLIP">CLIP</A> x1,y2 TO x2,y2 offers a further option by accepting the
coordinates of diagonally-opposite corner points (x1,y1) and (x2,y2)<A HREF="#.">.</A>

The third variant makes it possible to define the limits of the window 'n'<A HREF="#.">.</A>
The optional additional command <A HREF="#OFFSET">OFFSET</A> x0,y0 makes it possible to redefine the
origin of the graphic display.

In addition, the command <A HREF="#CLIP_OFFSET">CLIP OFFSET</A> x0,y0 can
also be used as a command in its own right, and in this case serves the same
purpose in setting the origin for the graphic displays at the ponit (x0,y0)<A HREF="#.">.</A>

The command <A HREF="#CLIP_OFF">CLIP OFF</A> swithes off the clipping function.

The limiting of graphic displays by CLIPping does not apply to the commands
<A HREF="#GET">GET</A>, <A HREF="#PUT">PUT</A>, and <A HREF="#BITBLT">BITBLT</A>, nor to the <A HREF="#Line-A_calls">Line-A calls</A> (where <A HREF="#ACLIP">ACLIP</A> should be used) or
<A HREF="#AES">AES</A> commands.

<B>Memo:</B> <A HREF="#CLIP">CLIP</A> #0 sets the clipping rectangle to the Desktop area. It's
      the same as doing this:
        <A HREF="#~">~</A><A HREF="#WIND_GET">WIND_GET</A>(0,4,x&,w&,y&,h&)  !desktop handle is always 0
        <A HREF="#CLIP">CLIP</A> x&,y&,w&,h& <A HREF="#OFFSET">OFFSET</A> 0,0

      The <A HREF="#OFFSET">OFFSET</A> option is not a real <A HREF="#VDI">VDI</A> function.  The x/y values are
      actually noted by <A HREF="#GFA-Basic">GFA-Basic</A> itself and then internally added to all
      further graphics commands.  Thus if you call the <A HREF="#VDI">VDI</A> directly, this
      <A HREF="#OFFSET">OFFSET</A> will have no effect at all, and must be simulated.

      There's a bug in the startup code related to <A HREF="#CLIP">CLIP</A><A HREF="#.">.</A> The initial clipping
      rectangle is set from values taken from the <A HREF="#Line-A">Line-A</A> variables. Thus it
      fails on non-ST video modes. If the graphics commands appear to be not
      working and you are in some non-ST mode, add this to the top of the
      program: <A HREF="#CLIP">CLIP</A> 0,0 TO <A HREF="#WORK_OUT">WORK_OUT</A>(0),WORK_OUT(1)

vs_clip()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="PLOT">PLOT</H2>
<A NAME="LINE"></A><A NAME="DRAW"></A><A NAME="DRAW_TO"></A><B><A HREF="#PLOT">PLOT</A> x,y
<A HREF="#LINE">LINE</A> x1,y1,x2,y2
<A HREF="#DRAW">DRAW</A> [TO][x,y]
<A HREF="#DRAW">DRAW</A> [x1,y1][TO x2,y2][TO x3,y3][TO...]</B>

x, y, x1, y1, x2, y2, x3, y3: <A HREF="#iexp">iexp</A>

<A HREF="#PLOT">PLOT</A> draws a point with the coordinates x,y on the screen. <A HREF="#LINE">LINE</A> draws a line
between the coordinate pairs x1,y1 and x2,y2. The style and color of this line
can be defined by means of the commands <A HREF="#DEFLINE">DEFLINE</A> and <A HREF="#COLOR">COLOR</A><A HREF="#.">.</A>

<A HREF="#DRAW">DRAW</A> x,y corresponds to the command <A HREF="#PLOT">PLOT</A><A HREF="#.">.</A> By means of <A HREF="#DRAW_TO">DRAW TO</A> x,y, a line is
drawn between the coordinates x,y and the last set point, regardless of whether
this point was set by <A HREF="#PLOT">PLOT</A>, <A HREF="#LINE">LINE</A>, or <A HREF="#DRAW">DRAW</A><A HREF="#.">.</A>

A further variant of the command, <A HREF="#DRAW">DRAW</A> x1,y1 TO x2,y2 corresponds to the <A HREF="#LINE">LINE</A>
command, and addionally with this command, further coordinates can be specified
allowing shapes such as polygons to be produced. This latter variant of the
command makes it possible to create structures which are similar to the
turtle-graphic commands of Logo and the Hewlett-Packard standard plotter
language, HPGL. In this way, it is possible to simulate a plotter on the
screen.

<B>Examples:</B>

    x=50
    y=50
    <A HREF="#LET">LET</A> color=<A HREF="#POINT">POINT</A>(x,y)
    <A HREF="#PRINT">PRINT</A> color
    <A HREF="#PLOT">PLOT</A> x,2*50
    <A HREF="#LINE">LINE</A> 200,200,400,100
    <A HREF="#PRINT">PRINT</A> <A HREF="#POINT">POINT</A>(x,100)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The program examines the color of the point 50,50 and prints this out on
    the screen. It then plots a second point, plots a line and reports on the
    color of the second point plotted.

    <A HREF="#DO">DO</A>
      <A HREF="#MOUSE">MOUSE</A> mx,my,mk
      <A HREF="#IF">IF</A> mk=1
        <A HREF="#DRAW_TO">DRAW TO</A> mx,my
      <A HREF="#ENDIF">ENDIF</A>
      <A HREF="#EXIT_IF">EXIT IF</A> mk=2
    <A HREF="#LOOP">LOOP</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> When the left mouse key is pressed a line is drawn between the last set
    point and the absolute coordinates mx,my. The loop is terminated by
    pressing the right mouse button.

v_pline()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="SETDRAW">SETDRAW</H2>
<A NAME="DRAW()"></A><B><A HREF="#DRAW">DRAW</A> expression
<A HREF="#DRAW">DRAW</A>(i)
<A HREF="#SETDRAW">SETDRAW</A> x,y,a</B>

i, x, y, a: <A HREF="#iexp">iexp</A>
expression: a mixture of <A HREF="#sexp">sexp</A> and <A HREF="#aexp">aexp</A>, a sexp must be first and the individual
            parameters must be seperated by a comma (,), semicolon (<A HREF="#;">;</A>), or an
            apostrophe (<A HREF="#'">'</A>)

With <A HREF="#DRAW">DRAW</A> an imaginary pen is moved over the screen and draws relative to the
last point. The <A HREF="#DRAW">DRAW</A> command's structure resembles the turtle-graphic commands
of the programming language Logo. The parameters of the <A HREF="#DRAW">DRAW</A> command can
contain a large number of individual commands, which are all passed to the
command in the form of a string. Parts of the expression can be given in
floating-point format, allowing for the use of variables. In this 'Logo like'
convention, an imaginary 'pen' is controlled by means of the graphic commands
and its movement over the 'paper' creates the graphic image. The statement
below is given as an example of how these commands may be used:

    <A HREF="#DRAW">DRAW</A> "FD 100 RT ",angle," PU BK ";50

The available commands are:

FD n  ForwarD          Moves the pen 'n' pixels forward.

BK n  BacKward         Moves the pen 'n' pixels backwards.

SX x  Scale X          Scales the 'pen movement' for FD and BK by the
SY y  Scale Y          specified factor. The scale with SX an SY works only
                       with the commands FD and BK. With SX0 or SY0 the scale
                       is switched off. This is quicker than scaling with the
                       factor 1 (SX1, SY1)<A HREF="#.">.</A>

LT a  Left Turn        Turns the pen to the left through the specified angle
                       'a', this being given in degrees.

RT a  Right Turn       Turns the pen as LT, but to the right.

TT a  Turn To          Turns the pen to the absolute angle 'a'<A HREF="#.">.</A> (See notation
                       below:)

                               0
                               <A HREF="#&#124;">&#124;</A>
                               <A HREF="#&#124;">&#124;</A>
                       270-Zero point-90
                               <A HREF="#&#124;">&#124;</A>
                               <A HREF="#&#124;">&#124;</A>
                              180

                       The data for the angle, 'a' is specified in degrees.

MA x,y  Move Absolute  Moves the pen to the absolute coordinates for x and y.

DA x,y  Draw Absolute  Moves the pen to the absolute coordinates for x and y
                       and draws a line in the current color from the last
                       position to the point (x,y)<A HREF="#.">.</A>

MR x,y  Move Relative  Moves the pen position in the x and y directions
                       releative to the last position.

<A HREF="#DR">DR</A> x,y  Draw Relative  Moves the pen by the specified displacement relative to
                       its last position and draws a line in the current color
                       from the last position to this point.

CO c    COlor          Sets the drawing color to 'c' (see <A HREF="#COLOR">COLOR</A> command)<A HREF="#.">.</A>

PU      Pen Up         Lift the pen up from the paper.

PD      Pen Down       Lowers the pen down onto the paper.

The command <A HREF="#SETDRAW">SETDRAW</A> x,y,a is an abbreviation for the expression
<A HREF="#DRAW">DRAW</A> "MA ";x,y;"TT ";a.

Additionally the following pen interrogation functions are available:

    <B>Index    Description             Default</B>
    <A HREF="#DRAW">DRAW</A>(0)  x-position              0
    <A HREF="#DRAW">DRAW</A>(1)  y-position              0
    <A HREF="#DRAW">DRAW</A>(2)  Angle in degrees        0
    <A HREF="#DRAW">DRAW</A>(3)  x-axis scale factor     0
    <A HREF="#DRAW">DRAW</A>(4)  y-axis scale factor     0
    <A HREF="#DRAW">DRAW</A>(5)  Pen flag (-1=PD, 0=PU)  -1

<B>Note:</B> All of these functions return floating point values.

<B>Example:</B>

    <A HREF="#DRAW">DRAW</A> "ma 160,200 tt 0"   !start at 160,200 and angle 0
    <A HREF="#FOR">FOR</A> i&=3 TO 10
      polygon(i&,90)         !draws a Polygon with i& corners
    <A HREF="#NEXT">NEXT</A> i&
    <A HREF="#'">'</A>
    <A HREF="#PROCEDURE">PROCEDURE</A> polygon(n&,r&) !n&=number of corners and r&=length of sides
      <A HREF="#LOCAL">LOCAL</A> i&
      <A HREF="#FOR">FOR</A> i&=1 TO n&
        <A HREF="#DRAW">DRAW</A> "fd ",r&," rt ",360/n&
      <A HREF="#NEXT">NEXT</A> i&
    <A HREF="#RETURN">RETURN</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Draws a set of ploygons with an increasing number of sides.

    <A HREF="#FOR">FOR</A> i=0 TO 639 <A HREF="#STEP">STEP</A> 8
      <A HREF="#SETDRAW">SETDRAW</A> 320,200,i
      <A HREF="#GRAPHMODE">GRAPHMODE</A> 3
      <A HREF="#DRAW">DRAW</A> "fd 45 rt 90 fd 45 rt 90 fd 45 rt 90 fd 45"
      <A HREF="#DRAW">DRAW</A> "bk 90 rt 90 bk 90 rt 90 bk 90 rt 90 bk 90"
      <A HREF="#GRAPHMODE">GRAPHMODE</A> 1
      <A HREF="#DRAW">DRAW</A> "fd 45 rt 90 fd 45 rt 90 fd 45 rt 90 fd 45"
      <A HREF="#DRAW">DRAW</A> "bk 90 rt 90 bk 90 rt 90 bk 90 rt 90 bk 90"
    <A HREF="#NEXT">NEXT</A> i

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Forms a shape from two small sqaures and two large ones, and then rotates
    it through 360 degrees.

    l%=48
    <A HREF="#'">'</A> Square:
    <A HREF="#DRAW">DRAW</A> "ma 60,100 tt 45"
    <A HREF="#DRAW">DRAW</A> "fd ",l%,"rt 90 fd ",l%,"rt 90 fd ",l%,"rt 90 fd ",l%,"rt 90"
    <A HREF="#'">'</A> Diamond, tall:
    <A HREF="#DRAW">DRAW</A> "mr 100,0 tt 45"
    <A HREF="#DRAW">DRAW</A> "sx 0.5 sy 0"
    <A HREF="#DRAW">DRAW</A> "fd ",l%,"rt 90 fd ",l%,"rt 90 fd ",l%,"rt 90 fd ",l%,"rt 90"
    <A HREF="#'">'</A> Diamond, wide:
    <A HREF="#DRAW">DRAW</A> "mr 100,0 tt 45"
    <A HREF="#DRAW">DRAW</A> "sx 0 sy 0.5"
    <A HREF="#DRAW">DRAW</A> "fd ",l%,"rt 90 fd ",l%,"rt 90 fd ",l%,"rt 90 fd ",l%,"rt 90"
    <A HREF="#'">'</A> Diamons, large and tall
    <A HREF="#DRAW">DRAW</A> "mr 100,0 tt 45"
    <A HREF="#DRAW">DRAW</A> "sx 3 sy 2"
    <A HREF="#DRAW">DRAW</A> "fd ",l%,"rt 90 fd ",l%,"rt 90 fd ",l%,"rt 90 fd ",l%,"rt 90"

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Draws a square at an angle, followed by three diamonds of various sizes.
    These diamonds are produced by changing the x and y scales and redrawing
    the original square.

    <A HREF="#SETDRAW">SETDRAW</A> 100,100,90
    <A HREF="#DRAW">DRAW</A> "PU FD 40 PD FD 40"
    <A HREF="#PRINT">PRINT</A> <A HREF="#DRAW">DRAW</A>(0)            !x-coodinate
    <A HREF="#PRINT">PRINT</A> <A HREF="#DRAW">DRAW</A>(5)            !Pen flag

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> A horizontal line is drawn and the numbers 180 and -1 printed.

<B>Memo:</B> y=<A HREF="#DRAW">DRAW</A>(x) does not do a proper range check on the value of x.
      Any value over 5 for x returns <A HREF="#index">index</A> 5.

      <A HREF="#DRAW">DRAW</A> "XX" does not check for invalid commands. In some cases they are
      ignored or it crashes the editor.

      Example: <A HREF="#DRAW">DRAW</A> "BX 8" !crashes the editor

      Spaces, commas, and semicolons are ingnored within string parameters:
      <A HREF="#DRAW">DRAW</A> "PU FD 40,PD;FD 40"
              <A HREF="#&#124;">&#124;</A>     <A HREF="#&">&</A>#124;  &#124;
          space comma  semicolon

v_pline()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="BOX">BOX</H2>
<A NAME="PBOX"></A><A NAME="RBOX"></A><A NAME="PRBOX"></A><B><A HREF="#BOX">BOX</A> x1,y1,x2,y2
<A HREF="#PBOX">PBOX</A> x1,y1,x2,y2
<A HREF="#RBOX">RBOX</A> x1,y1,x2,y2
<A HREF="#PRBOX">PRBOX</A> x1,y1,x2,y2</B>

x1, y1, x2, y2: <A HREF="#iexp">iexp</A>

These commands draw filled or unfilled rectangles on the screen. The
coordinates of the two opposite corners are specified by x1,y1 and x2,y2.

<A HREF="#BOX">BOX</A> draws an unfilled rectangle.

<A HREF="#PBOX">PBOX</A> draws a filled rectangle.

<A HREF="#RBOX">RBOX</A> draws an unfilled rectangle with rounded corners.

<A HREF="#PRBOX">PRBOX</A> draws a filled rectangle with rounded corners.

<B>Example:</B>

    <A HREF="#BOX">BOX</A> 20,20,120,120
    <A HREF="#RBOX">RBOX</A> 170,20,270,120
    x=150
    <A HREF="#DEFFILL">DEFFILL</A> 1,2,4
    <A HREF="#PBOX">PBOX</A> 20,20+x,120,120+x
    <A HREF="#PRBOX">PRBOX</A> 170,20+x,270,120+x
    <A HREF="#~">~</A><A HREF="#INP">INP</A>(2)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> An ordinary rectangle is drawn, followed by one with rounded off corners.
    Finally both shapes are drawn again but with a different fill pattern. A
    key press is then waited for.

v_pline()<A HREF="#+">+</A>, v_bar()+, v_rbox()+, v_rfbox()+
<HR SIZE=3><H2 ID="CIRCLE">CIRCLE</H2>
<A NAME="PCIRCLE"></A><A NAME="ELLIPSE"></A><A NAME="PELLIPSE"></A><B><A HREF="#CIRCLE">CIRCLE</A> x,y,r[,w1,w2]
<A HREF="#PCIRCLE">PCIRCLE</A> x,y,r[,w1,w2]
<A HREF="#ELLIPSE">ELLIPSE</A> x,y,rx,ry[,w1,w2]
<A HREF="#PELLIPSE">PELLIPSE</A> x,y,rx,ry[,w1,w2]</B>

x, y, r, rx, ry, w1, w2: <A HREF="#iexp">iexp</A>

<A HREF="#CIRCLE">CIRCLE</A> draws a circle with center coodinates x,y and radius r. Addtional
starting and ending angles w1 and w2 can be specified to draw a circular arc.
Similarly, <A HREF="#PCIRCLE">PCIRCLE</A> draws a filled circle or filled circular arc.

<A HREF="#ELLIPSE">ELLIPSE</A> draws an ellipse with the center coordinates x,y and horizontal radius
rx and vertical radius ry. Optional starting and ending angles w1 and w2 can be
specified to draw an elliptical arc. Similarly, <A HREF="#PELLIPSE">PELLIPSE</A> draws a filled ellipse
or a filled elliptical arc. The angles should be specified in 1/10 degress
(0-3600) and are measured in an anti-clockwise direction with zero pointing to
the right. See notation below.

         900
          <A HREF="#&#124;">&#124;</A>
    1800-angle-0
          <A HREF="#&#124;">&#124;</A>
         2700

<B>Example:</B>

    <A HREF="#CIRCLE">CIRCLE</A> 320,200,100
    <A HREF="#ELLIPSE">ELLIPSE</A> 320,200,200,100,900,1800
    <A HREF="#PCIRCLE">PCIRCLE</A> 320,200,100,1800,2700
    <A HREF="#PELLIPSE">PELLIPSE</A> 320,200,200,100,2700,3600

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> A circle is drawn along with 3 more arc segments.

v_arc()<A HREF="#+">+</A>, v_circle()+, v_ellarc()+, v_ellipse()+, v_ellpie()+, v_pieslice()+
<HR SIZE=3><H2 ID="POLYLINE">POLYLINE</H2>
<A NAME="POLYMARK"></A><A NAME="POLYFILL"></A><B><A HREF="#POLYLINE">POLYLINE</A> n,x(),y() [<A HREF="#OFFSET">OFFSET</A> x_off,y_off]
<A HREF="#POLYMARK">POLYMARK</A> n,x(),y() [<A HREF="#OFFSET">OFFSET</A> x_off,y_off]
<A HREF="#POLYFILL">POLYFILL</A> n,x(),y() [<A HREF="#OFFSET">OFFSET</A> x_off,y_off]</B>

n, x_off, y_off: <A HREF="#iexp">iexp</A>
x(), y()<A HREF="#:">:</A> <A HREF="#avar">avar</A>-array

<A HREF="#POLYLINE">POLYLINE</A> draws a polygon with n corners. The x,y coordinates for the corner
points are given in arrays x() and y()<A HREF="#.">.</A> The first corner points are in x(0) and
y(0), the last in x(n-1) and y(n-1)<A HREF="#.">.</A> An optional parameter, <A HREF="#OFFSET">OFFSET</A>, can be
added to these coordinates, the magnitude of offset being given by x_off and
y_off. Parameter 'n' equals the number of points to connect.

<A HREF="#POLYMARK">POLYMARK</A> marks the corner points with the shape defined by <A HREF="#DEFMARK">DEFMARK</A><A HREF="#.">.</A> Parameter
'n' equals the number of marks to be drawn.

<A HREF="#POLYFILL">POLYFILL</A> fills the polygon with the pattern and color previously defined by
<A HREF="#DEFFILL">DEFFILL</A><A HREF="#.">.</A> The first and last corner points are connected automatically.

<B>Example:</B>

    <A HREF="#DIM">DIM</A> x%(3),y%(3)
    <A HREF="#FOR">FOR</A> i%=0 TO 3
      <A HREF="#READ">READ</A> x%(i%),y%(i%)
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#DATA">DATA</A> 120,120,170,170,70,170,120,120
    <A HREF="#POLYLINE">POLYLINE</A> 4,x%<A HREF="#()">()</A>,y%()
    <A HREF="#POLYFILL">POLYFILL</A> 3,x%<A HREF="#()">()</A>,Y%() <A HREF="#OFFSET">OFFSET</A> -50,-50
    <A HREF="#DEFMARK">DEFMARK</A> ,4,10
    <A HREF="#POLYMARK">POLYMARK</A> 3,x%<A HREF="#()">()</A>,y%() <A HREF="#OFFSET">OFFSET</A> 40,-80
    <A HREF="#~">~</A><A HREF="#INP">INP</A>(2)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Draws an outline triangle and a filled triangle, as well as rectangular
    corner marks of a further triangle. A key is then waited for.

<B>Memo:</B> Byte arrays are not accepted.
      The first and last corner points are connected automatically only in the
      case of <A HREF="#POLYFILL">POLYFILL</A><A HREF="#.">.</A>

      Parameter 'n' is limited to 512. If exceeded:
        Interpreted: An error is generated.
        Compiled: Only the first 512 points will be drawn.
      This limit does not match error message #27 which states a maximum of
        128 points. Anything over 128 points causes an internal buffer overrun.

v_pline()<A HREF="#+">+</A>, v_pmarker()+, v_fillarea()+
<HR SIZE=3><H2 ID="POINT">POINT</H2>
<B><A HREF="#POINT">POINT</A>(x,y)</B>

x, y: <A HREF="#iexp">iexp</A>

The color of the point with coordinate x,y is determined with this function.
Values between 0 and 15 are returned for a low resolution screen, between 0 and
3 for medium, and 0 and 1 for high resolution.

<B>Example:</B>

    a=<A HREF="#POINT">POINT</A>(100,100)
    <A HREF="#PLOT">PLOT</A> 100,100
    <A HREF="#PRINT">PRINT</A> a,<A HREF="#POINT">POINT</A>(100,100)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The computer read the color at 100,100, plots a point there and rereads its
    color.

<B>Memo:</B> Normally, this command only works on palette based modes.
      It only returns <A HREF="#INTOUT">INTOUT</A>(1) as the results.
      For high color and true color modes you must do a little extra work:
        <A HREF="#~">~</A><A HREF="#POINT">POINT</A>(x,y)
        <A HREF="#WORD">WORD</A>{<A HREF="#LONG">LONG</A>{<A HREF="#GB">GB</A>+80}}   <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> <A HREF="#INTOUT">INTOUT</A>(0)
        <A HREF="#WORD">WORD</A>{<A HREF="#LONG">LONG</A>{<A HREF="#GB">GB</A>+80}+2} <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> <A HREF="#INTOUT">INTOUT</A>(1)
      or:
        pixel%<A HREF="#=">=</A><A HREF="#LONG">LONG</A>{LONG{<A HREF="#GB">GB</A>+80}} !get TC results from gfa's internal vdi array
        pixel%<A HREF="#=">=</A><A HREF="#LONG">LONG</A>{<A HREF="#INTOUT">INTOUT</A>+256}  !same result, slightly faster
      See <A HREF="#GB">GB</A> for more information.

      For an information regarding 16/24/32-bit pixel formats, see: ATARI.RSC
      The Atari Developer's Resource <A HREF="#-">-</A> Volume V - Issue 2 - Dec 1992

v_get_pixel()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="FILL">FILL</H2>
<B><A HREF="#FILL">FILL</A> x,y[,f]</B>

x, y, f: <A HREF="#iexp">iexp</A>

This command fills any enclosed area. The filling procedure begins at the
coordinates x,y. If the optional paramter 'f' is present then the filling
procedure is limited only by points of the color 'f' and the edges of the
screen. If 'f' is not present, or with f=-1, any point with a color other than
the starting point x,y will be taken to be the edge of the area to be filled.

<B>Examples:</B>

    <A HREF="#LINE">LINE</A> 0,180,639,180
    <A HREF="#FOR">FOR</A> i=1 TO 19
      <A HREF="#BOX">BOX</A> i*20,100,i*20+18,180
      <A HREF="#TEXT">TEXT</A> i*20-4,195,i
      <A HREF="#DEFFILL">DEFFILL</A> ,2,i
      <A HREF="#FILL">FILL</A> i*20+1,101
    <A HREF="#NEXT">NEXT</A> i
    <A HREF="#PAUSE">PAUSE</A> 100
    <A HREF="#FILL">FILL</A> 0,180

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> This draws a straight line, placing a row of filled boxes above it. After a
    seconds pause, the computer proceeds to fill in the straight line, and
    anything joining it, thus partly destroying the fill patterns.

    <A HREF="#LINE">LINE</A> 0,280,639,280
    <A HREF="#FOR">FOR</A> i=1 TO 19
      <A HREF="#BOX">BOX</A> i*20,200,i*20+20-i,280
      <A HREF="#TEXT">TEXT</A> i*20-4,295,i
      <A HREF="#DEFFILL">DEFFILL</A> ,2,i
      <A HREF="#FILL">FILL</A> i*20+1,201,1
    <A HREF="#NEXT">NEXT</A> i

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The same result as above occurs, except that the resulting fill patterns
    will be different, due to the extra parameter in the fill commmand causing
    a slightly different fill mechanism to be used.

v_contourfill()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="CLS">CLS</H2>
<B><A HREF="#CLS">CLS</A> [#n]</B>

n: <A HREF="#iexp">iexp</A>

Erases the screen by using ESC-E-CR (<A HREF="#CHR$">CHR$</A>(27)<A HREF="#+">+</A>"E"+CHR$(13)) of the <A HREF="#VT-52">VT-52</A>
Emulator. It can also be rerouted to a data file.

<B>Example:</B>

    <A HREF="#PBOX">PBOX</A> 100,100,500,200
    <A HREF="#REPEAT">REPEAT</A>
    <A HREF="#UNTIL">UNTIL</A> <A HREF="#MOUSEK">MOUSEK</A>
    <A HREF="#CLS">CLS</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Fills the screen partly with a rectangle and deletes it after a mouse
    button it pressed.

<B>Memo:</B> <A HREF="#CLS">CLS</A> #n appears to be almost useless. What's the point of writing
      ESC-E-CR (3 bytes) to a file? Might be ok for other devices.
      The extra CR is also not needed.

      This is actually a bios() call to bconout(DEV_CON) using a <A HREF="#VT-52">VT-52</A> ESCape.
<HR SIZE=3><H2 ID="TEXT">TEXT</H2>
<B><A HREF="#TEXT">TEXT</A> x,y[,l],expression</B>

x, y, l: <A HREF="#iexp">iexp</A>
expression: <A HREF="#aexp">aexp</A> or <A HREF="#sexp">sexp</A>

Displays the text in 'expression' starting at the point with the graphic
coodinates x,y. This point refers to the bottom left corner of the first
character of the expression. The parameter 'l' sets the length of the text in
pixels. With 'l' as positive, the spacing between characters will be adjusted
to achieve the length, whereas with 'l' negative, the length is achieved by
altering the size of the spaces between words. When 'l' is zero, the unchanged
text is displayed.

Using <A HREF="#DEFTEXT">DEFTEXT</A>, various attributes of text can be altered. DEFTEXT however, only
works with the <A HREF="#TEXT">TEXT</A> command and with the <A HREF="#PRINT">PRINT</A> command when used inside a
window.

<B>Example:</B>

    s$<A HREF="#=">=</A>"this is an example"
    <A HREF="#FOR">FOR</A> i=0 TO 23
      <A HREF="#DEFTEXT">DEFTEXT</A> 1,i,0,6
      <A HREF="#TEXT">TEXT</A> 50,i*16+16,s$
    <A HREF="#NEXT">NEXT</A> i
    <A HREF="#DEFTEXT">DEFTEXT</A> 1,0,0,13
    <A HREF="#TEXT">TEXT</A> 350,50,350-50
    <A HREF="#TEXT">TEXT</A> 350,100,s$
    <A HREF="#TEXT">TEXT</A> 350,150,250,s$
    <A HREF="#TEXT">TEXT</A> 350,200,-250,s$
    <A HREF="#~">~</A><A HREF="#INP">INP</A>(2)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Writes text in various forms on the screen and then waits for a key to be
    pressed.

<B>Memo:</B> Clips text off at 119 characters.

v_gtext()<A HREF="#+">+</A>, v_justified()+, vst_alignment()+
<HR SIZE=3><H2 ID="SPRITE">SPRITE</H2>
<B><A HREF="#SPRITE">SPRITE</A> bit_pattern$[,x,y]</B>

bit_pattern$<A HREF="#:">:</A> <A HREF="#svar">svar</A>
x, y: <A HREF="#aexp">aexp</A>

The <A HREF="#SPRITE">SPRITE</A> command enables a 16x16 pixel block to be moved around the screen.
The appropriate bit information for the pattern and its mask is put into the
string bit_pattern$<A HREF="#.">.</A> All values must be given in word size. For this purpose
one can use the command <A HREF="#MKI$">MKI$</A><A HREF="#()">()</A>, so bit_pattern$ is formed as follows:

bit_pattern$ <A HREF="#=">=</A> <A HREF="#MKI$">MKI$</A>(x-coordinate of action point)
             <A HREF="#+">+</A> <A HREF="#MKI$">MKI$</A>(y-coordinate of action point)
             <A HREF="#+">+</A> <A HREF="#MKI$">MKI$</A>(0)            !0=normal or -1=<A HREF="#XOR">XOR</A>
             <A HREF="#+">+</A> <A HREF="#MKI$">MKI$</A>(mask color)   !usually 0
             <A HREF="#+">+</A> <A HREF="#MKI$">MKI$</A>(sprite color) !usually 1
             <A HREF="#+">+</A> sprite$

With <A HREF="#'">'</A><A HREF="#SPRITE">SPRITE</A> bit_pattern$,x,y' the sprite is first drawn or moved if already on
the screen. With <A HREF="#'">'</A><A HREF="#SPRITE">SPRITE</A> bit_pattern$' the sprite is erased from the screen
display.

Contained in sprite$ is the bit information for the sprite shape and its mask,
which must be specified, unlike <A HREF="#DEFMOUSE">DEFMOUSE</A>, not successively but alternately.

<B>Example:</B>

    gfa$<A HREF="#=">=</A><A HREF="#MKI$">MKI$</A>(1)+MKI$(1)+MKI$(0)
    gfa$=gfa$<A HREF="#+">+</A><A HREF="#MKI$">MKI$</A>(0)+MKI$(1)
    <A HREF="#FOR">FOR</A> i%=1 TO 16
      <A HREF="#READ">READ</A> pattern%,mask%
      gfa$=gfa$<A HREF="#+">+</A><A HREF="#MKI$">MKI$</A>(mask%)+MKI$(pattern%)
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#DATA">DATA</A> 0,0,0,32256,15360,16896,8192,24064
    <A HREF="#DATA">DATA</A> 8192,24560,11744,21008,9472,23280,9472,23295
    <A HREF="#DATA">DATA</A> 15838,16929,274,32493,274,749,286,737
    <A HREF="#DATA">DATA</A> 18,1005,18,45,18,45,0,63
    <A HREF="#REPEAT">REPEAT</A>
      <A HREF="#ADD">ADD</A> mx%,(<A HREF="#MOUSEX">MOUSEX</A>-mx%)/50
      <A HREF="#ADD">ADD</A> my%,(<A HREF="#MOUSEY">MOUSEY</A>-my%)/50
      <A HREF="#SPRITE">SPRITE</A> gfa$,mx%,my%
    <A HREF="#UNTIL">UNTIL</A> <A HREF="#MOUSEK">MOUSEK</A>=2
    <A HREF="#SPRITE">SPRITE</A> gfa$

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> A sprite moves over the screen, following the movement of the mouse
    pointer.

<B>Memo:</B> This should be considered a <A HREF="#Line-A">Line-A</A> command.
      Use it carefully or not at all.
      Sprite strings must be exactly 74 bytes in length.

<A HREF="#Line-A">Line-A</A> Draw Sprite+, Line-A Undraw Sprite+
<HR SIZE=3><H2 ID="CURVE">CURVE</H2>
<B><A HREF="#CURVE">CURVE</A> x0,y0,x1,y1,x2,y2,x3,y3</B>

x0, y0, x1, y1, x2, y2, x3, y3: <A HREF="#iexp">iexp</A>

The command <A HREF="#CURVE">CURVE</A> is based upon the Bezier Curve function.

The Bezier Curve starts at x0,y0, and ends at x3,y3. The curve at x0,y0 is at a
tangent with a line from x0,y0 to x1,y1; and at x3,y3 is at a tangent with a
line between x3,y3 and x2,y2.

<B>Example:</B>

    x0=10
    y0=10
    x1=50
    y1=110
    x2=150
    y2=200
    x3=350
    y3=300
    <A HREF="#LINE">LINE</A> x0,y0,x1,y1
    <A HREF="#LINE">LINE</A> x2,y2,x3,y3
    <A HREF="#CURVE">CURVE</A> x0,y0,x1,y1,x2,y2,x3,y3

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Draws a sample Bezier Curve on the screen.

<B>Memo:</B> GFA computes the curve itself and draws it with <A HREF="#VDI">VDI</A> function
      v_pline()<A HREF="#.">.</A> GFA does not call <A HREF="#VDI">VDI</A> function v_bez() at all.
      The compiler uses twice as many iterations when drawing the curve.

v_bez()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="Grabbing_Sections_of_the_Screen">Grabbing Sections of the Screen</H2>
<A HREF="#SGET">SGET</A>, <A HREF="#SPUT">SPUT</A>
<A HREF="#GET">GET</A>, <A HREF="#PUT">PUT</A>
<A HREF="#VSYNC">VSYNC</A>
<A HREF="#BITBLT">BITBLT</A>
<A HREF="#GETSIZE">GETSIZE</A><A HREF="#()">()</A>
<HR SIZE=3><H2 ID="SGET">SGET</H2>
<A NAME="SPUT"></A><B><A HREF="#SGET">SGET</A> screen$
<A HREF="#SPUT">SPUT</A> screen$</B>

screen$<A HREF="#:">:</A> <A HREF="#svar">svar</A>

<A HREF="#SGET">SGET</A> copies the entire screen (32000 bytes) into a string. Similarly, <A HREF="#SPUT">SPUT</A>
copies a 32000 byte long string into the screen memory, thus displaying it.

<B>Example:</B>

    <A HREF="#PCIRCLE">PCIRCLE</A> 100,100,50
    <A HREF="#SGET">SGET</A> b$
    <A HREF="#~">~</A><A HREF="#INP">INP</A>(2)
    <A HREF="#CLS">CLS</A>
    <A HREF="#~">~</A><A HREF="#INP">INP</A>(2)
    <A HREF="#SPUT">SPUT</A> b$

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Draws a filled circle on the screen. After a key is pressed it disappears,
    after a another key is pressed it reappears.

<B>Memo:</B> Only works in ST compatible modes that require exactly 32000 bytes.

vro_cpyfm()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="GET">GET</H2>
<A NAME="PUT"></A><B><A HREF="#GET">GET</A> x1,y1,x2,y2,section$
<A HREF="#PUT">PUT</A> x1,y1,section$[,mode]</B>

x1, y1, x2, y2, mode: <A HREF="#iexp">iexp</A>
section$<A HREF="#:">:</A> <A HREF="#svar">svar</A>

<A HREF="#GET">GET</A> puts a section of screen into a string variable (x1,y1 and x2,y2 are
coordinates of diagonally opposite corners)<A HREF="#.">.</A> Similarly <A HREF="#PUT">PUT</A> places a screen
section (read in with <A HREF="#GET">GET</A>) onto the screen at coordinates x1,y1. Using 'mode'
it is possible to control the way the string is placed on the screen in
relation to the existing screen contents. In the following table the
relationship between the new picture and the existing one are shown for each
value of mode. The term 's' represents a pixel from the new picture (the source
picture), and 'd' the corresponding pixel from the existing screen (the
destination)<A HREF="#.">.</A>

<B>Mode  Placing rule   Effect</B>
0     0              All points are cleared.
1     s <A HREF="#AND">AND</A> d        Only the points which are set in both screens remain set.
2     s <A HREF="#AND">AND</A> (<A HREF="#NOT">NOT</A> d)  Sets only the points which are set in the source and clear
                     in the destination.
3     s              The new source screen is simply transferred (<A HREF="#GRAPHMODE">GRAPHMODE</A> 1 <A HREF="#-">-</A>
                     <A HREF="#-">-</A> Default)<A HREF="#.">.</A>
4     (<A HREF="#NOT">NOT</A> s) <A HREF="#AND">AND</A> d  Only the points which are clear in the source and set in
                     the destination are set.
5     d              The screen remains unchanged.
6     s <A HREF="#XOR">XOR</A> d        Only those points which are set in one but not both remain
                     set (<A HREF="#GRAPHMODE">GRAPHMODE</A> 3)<A HREF="#.">.</A>
7     s <A HREF="#OR">OR</A> d         All points are set in which either or both the source and
                     destination are set (<A HREF="#GRAPHMODE">GRAPHMODE</A> 2)<A HREF="#.">.</A>
8     <A HREF="#NOT">NOT</A> (s <A HREF="#OR">OR</A> d)   All points which are clear in both screens become set.
9     <A HREF="#NOT">NOT</A> (s <A HREF="#XOR">XOR</A> d)  All points where both source and destination are set, or
                     both are clear, are set.
10    <A HREF="#NOT">NOT</A> d          The destination screen is inverted.
11    s <A HREF="#OR">OR</A> (<A HREF="#NOT">NOT</A> d)   A point is set if either the source is set, or the
                     destination is clear, or both.
12    <A HREF="#NOT">NOT</A> s          The source screen is inverted before the placing.
13    (<A HREF="#NOT">NOT</A> s) <A HREF="#OR">OR</A> d   <A HREF="#GRAPHMODE">GRAPHMODE</A> 4
14    <A HREF="#NOT">NOT</A> (s <A HREF="#AND">AND</A> d)  All points which were not set in both screens become set.
15    1              All points are set.

The important modes are:

     3 Replace (default)
     4 <A HREF="#XOR">XOR</A>
     7 Transparent
    13 Inverse transparent


<B>Memo:</B> Only works if the block requires no more than 32000 bytes.
      The resulting string will always be 6 bytes larger than expected.
      The header is as follows: <A HREF="#MKI$">MKI$</A>(width&-1)+MKI$(height&-1)+MKI$(planes&)

      There is some undocumented option related to the mode parameter.
      If bit 4 of the mode parameter is set, it calls <A HREF="#VDI">VDI</A> function vro_cpyfm()
      instead of the <A HREF="#Line-A">Line-A</A> blit function. However it's so buggy that it's
      non-functional and results in a crash.

Original manual said this: (There are no such blitmodes supported by the <A HREF="#VDI">VDI</A><A HREF="#.">.</A>)
In addition, if the current fill pattern is a user-defined one and bit 4 of
'mode' is set, then the result of the above calculations will be ANDed with the
user-defined pattern.

<A HREF="#Line-A">Line-A</A> BitBlt+, vro_cpyfm()+
<HR SIZE=3><H2 ID="VSYNC">VSYNC</H2>
<B><A HREF="#VSYNC">VSYNC</A></B>

This command is used for the synchronisation of the screen display. When this
command is issued, the computer pauses until the vertical scanning line (raster
scan) reaches the top of the screen. This results in much less screen flicker.
<A HREF="#VSYNC">VSYNC</A> can be used, for example, in the animation of screen sections using <A HREF="#GET">GET</A>
and <A HREF="#PUT">PUT</A><A HREF="#.">.</A>

<B>Example:</B>

    t%<A HREF="#=">=</A><A HREF="#TIMER">TIMER</A>
    <A HREF="#FOR">FOR</A> i%=1 TO 100
      <A HREF="#VSYNC">VSYNC</A>
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#PRINT">PRINT</A> <A HREF="#SUB">SUB</A>(<A HREF="#TIMER">TIMER</A>,t%)/200

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> This displays the time for 100 scans of the screen to occur.

Vsync()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="BITBLT">BITBLT</H2>
<B><A HREF="#BITBLT">BITBLT</A> s_mfdb%<A HREF="#()">()</A>,d_mfdb%(),par%()</B>

s_mfdb%<A HREF="#()">()</A>, d_mfdb%(), par%()<A HREF="#:">:</A> integer-array

The command <A HREF="#BITBLT">BITBLT</A> allows the copying of rectangular screen sections. It is
similar to the commands <A HREF="#GET">GET</A> and <A HREF="#PUT">PUT</A> but it is quicker and more flexible.
However, it is also more complicated to use.

The parameters of the command are stored in three arrays. The first one,
s_mfdb%<A HREF="#()">()</A>, contains the structure of the source screen <A HREF="#-">-</A> the one to be copied.
In the same way, d_mfdb%<A HREF="#()">()</A> contains the structure of the destination, i.e. the
place where the picture is to be copied to. The third array contains the
coordinates of the source and target areas and also the copy mode.

This command has a <A HREF="#VDI">VDI</A> routine as its basis. During <A HREF="#BITBLT_adr%">BITBLT adr%</A> and <A HREF="#BITBLT_x%()">BITBLT x%()</A>
a <A HREF="#Line-A">Line-A</A> routine is called (see the section on <A HREF="#Line-A_calls">Line-A calls</A>)<A HREF="#.">.</A>

The structure of the source (s_mfdb%) is same as that of the destination screen
(d_mfdb%)<A HREF="#.">.</A> The abbreviations mean:

    s_mfdb%<A HREF="#()">()</A> Source Memory Form Description Block
    d_mfdb%<A HREF="#()">()</A> Destination Memory Form Description Block

The Array Elements are: (<A HREF="#OPTION_BASE">OPTION BASE</A> 0 is assumed)

x_mfdb%(0)  Contains the source/destination address. This address must be an
            even number. Usually either s_mfdb%(0) or d_mfdb%(0) equals the
            screen address (<A HREF="#XBIOS">XBIOS</A>(2))<A HREF="#.">.</A>
x_mfdb%(1)  Width of the screen in pixels. This value must be divisible by 16.
x_mfdb%(2)  Height of the screen in pixels.
x_mfdb%(3)  Screen width in words (equals pixel count/16)<A HREF="#.">.</A>
x_mfdb%(4)  Format type.
            0 <A HREF="#=">=</A> Device specific (normally this is used)
            1 <A HREF="#=">=</A> <A HREF="#VDI">VDI</A> format
x_mfdb%(5)  Number of bit planes:
             1 <A HREF="#=">=</A> 2 colors (mono)
             2 <A HREF="#=">=</A> 4 colors
             4 <A HREF="#=">=</A> 16 colors
             8 <A HREF="#=">=</A> 256 colors
            16 <A HREF="#=">=</A> 32768/65536 high color
            24 <A HREF="#=">=</A> True color
            32 <A HREF="#=">=</A> True color (extra alpha byte)
x_mfdb%(6)  Reserved field. (should be set to 0)
x_mfdb%(7)  Reserved field.
x_mfdb%(8)  Reserved field.

If x_mfdb%(0)=0, the <A HREF="#VDI">VDI</A> will fill in the rest of the x_mfdb() parameters by
itself, pointing to the current screen.

The array par%<A HREF="#()">()</A> has the following structure:

    par%(0)  Left x-coordinate of the source block
    par%(1)  Upper y-coordinate of the source block
    par%(2)  Right x-coordinate of the source block
    par%(3)  Lower y-coordinate of the source block
    par%(4)  Left x-coordinate of the destination block
    par%(5)  Upper y-coordinate of the destination block
    par%(6)  Right x-coordinate of the destination block
    par%(7)  Lower y-coordinate of the destination block
    par%(8)  Copy mode

The values for 'copy mode' correspond to those with GET/PUT. The important ones
are:

     3 <A HREF="#=">=</A> Replace             <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> <A HREF="#GRAPHMODE">GRAPHMODE</A> 1
     6 <A HREF="#=">=</A> <A HREF="#XOR">XOR</A>                 <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> <A HREF="#GRAPHMODE">GRAPHMODE</A> 2
     7 <A HREF="#=">=</A> Transparent         <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> <A HREF="#GRAPHMODE">GRAPHMODE</A> 3
    13 <A HREF="#=">=</A> Inverse transparent <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> <A HREF="#GRAPHMODE">GRAPHMODE</A> 4

<B>Example:</B>

    <A HREF="#DIM">DIM</A> smfdb%(8),dmfdb%(8),p%(8)
    <A HREF="#'">'</A>
    <A HREF="#FOR">FOR</A> i%=0 TO 639 <A HREF="#STEP">STEP</A> 8
      <A HREF="#LINE">LINE</A> i%,0,639,399
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#'">'</A>
    <A HREF="#GET">GET</A> 0,0,639,399,a$
    mirrorput(0,0,a$)
    <A HREF="#'">'</A>
    <A HREF="#PROCEDURE">PROCEDURE</A> mirrorput(x%,y%,<A HREF="#VAR">VAR</A> x$)
      <A HREF="#IF">IF</A> <A HREF="#LEN">LEN</A>(x$)<A HREF="#&">&</A>#62;6 !Only if something there
        a%=V:x$
        b%<A HREF="#=">=</A><A HREF="#INT">INT</A>{a%}
        h%<A HREF="#=">=</A><A HREF="#INT">INT</A>{a%+2}
        <A HREF="#'">'</A>
        smfdb%(0)=a%+6
        smfdb%(1)<A HREF="#=">=</A>(b%+16) <A HREF="#AND">AND</A> &HFFF0
        smfdb%(2)=h%+1
        smfdb%(3)=smfdb%(1)/16
        smfdb%(5)<A HREF="#=">=</A><A HREF="#DPEEK">DPEEK</A>(a%+4)
        <A HREF="#'">'</A>
        dmfdb%(0)<A HREF="#=">=</A><A HREF="#XBIOS">XBIOS</A>(3)
        dmfdb%(1)=640
        dmfdb%(2)=400
        dmfdb%(3)=40
        dmfdb%(5)=1
        <A HREF="#'">'</A>
        p%(1)=0
        p%(3)=h%
        p%(4)=x%+b%
        p%(5)=y%
        p%(6)=x%+b%
        p%(7)=y%+h%
        p%(8)=3
        <A HREF="#FOR">FOR</A> i%=0 TO b%
          p%(0)=i%
          p%(2)=i%
          <A HREF="#BITBLT">BITBLT</A> smfdb%<A HREF="#()">()</A>,dmfdb%(),p%()
          <A HREF="#DEC">DEC</A> p%(4)
          <A HREF="#DEC">DEC</A> p%(6)
        <A HREF="#NEXT">NEXT</A> i%
        <A HREF="#'">'</A>
      <A HREF="#ENDIF">ENDIF</A>
    <A HREF="#RETURN">RETURN</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Draws a set of lines, forming a triangle. The entire screen is read into a
    string and then each pixel-wide column is placed back on the screen on the
    other side. This has the effect of reflecting the screen in an axis down
    the center of the screen (see <A HREF="#BITBLT">BITBLT</A> in the section on <A HREF="#Line-A_calls">Line-A calls</A>)<A HREF="#.">.</A>

<B>Memo:</B> This is the only variation of <A HREF="#BITBLT">BITBLT</A> that is based on a <A HREF="#VDI">VDI</A> call.
      The other variants are <A HREF="#Line-A_calls">Line-A calls</A> and should be avoided.
      This call does not fill in the reserved fields even if you pass them.

      If you pass 0 for the source or destination address the <A HREF="#VDI">VDI</A> will assume
      the screen and fill in the MFDB itself.

vro_cpyfm()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="GETSIZE">GETSIZE</H2>
<B><A HREF="#GETSIZE">GETSIZE</A>(x1,y1,x2,y2)</B>

x1, y1, x2, y2: <A HREF="#iexp">iexp</A>

The TT does not have a constant screen memory of 32000 bytes like the ST. A
screen could require much more memory (153600 bytes)<A HREF="#.">.</A> The commands <A HREF="#GET">GET</A> and <A HREF="#PUT">PUT</A>
are limited to 32000 bytes and therefore a function has been introduced to
support the larger screen resolutions that require more than 32000 bytes.

This function will return the number of bytes required by the screen between
the coordinates x1,y1 and x2,y2. Several <A HREF="#GET">GET</A> or <A HREF="#PUT">PUT</A> commands could be used to
address the entire screen.

Note: If any of the coordinates are offscreen, this function returns 0.

<B>Example:</B>

    <A HREF="#'">'</A> low resolution
    <A HREF="#PRINT">PRINT</A> <A HREF="#GETSIZE">GETSIZE</A>(0,0,319,199)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Prints the value 32006 on the screen.

<B>Memo:</B> Seems to only work correctly in standard ST and TT video modes.
      Internally this command uses the <A HREF="#Line-A">Line-A</A> variables.
      The extra 6 bytes account for the string header used by <A HREF="#GET">GET</A> and <A HREF="#PUT">PUT</A><A HREF="#.">.</A>

      <A HREF="#GETSIZE">GETSIZE</A><A HREF="#()">()</A> <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> V_REZ_HZ, V_REZ_VT, PLANES (<A HREF="#Line-A">Line-A</A> variables)

      To get the current screen buffer size:
      size%<A HREF="#=">=</A><A HREF="#GETSIZE">GETSIZE</A>(0,0,<A HREF="#_X">_X</A>-1,<A HREF="#_Y">_Y</A>-1)-6

<A HREF="#Line-A_Variable_Table">Line-A Variable Table</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="Chapter__9_-_Event,_Menu,_and_Window_Management">Chapter  9 - Event, Menu, and Window Management</H2>
<A NAME="Event_Management"></A><A HREF="#MENU">MENU</A>
<A HREF="#MENU()">MENU()</A>
<A HREF="#ON_MENU">ON MENU</A>
<A HREF="#ON_MENU_BUTTON">ON MENU BUTTON</A>
<A HREF="#ON_MENU_KEY">ON MENU KEY</A>
<A HREF="#ON_MENU_IBOX">ON MENU IBOX</A>
<A HREF="#ON_MENU_OBOX">ON MENU OBOX</A>
<A HREF="#ON_MENU_MESSAGE">ON MENU MESSAGE</A>

There are commands in <A HREF="#GFA-Basic">GFA-Basic</A> which allow the monitoring of GEM Events in a
straightforward way. These events are the pressing of a key or a mouse button,
the arrival of the mouse pointer inside or outside one of two specified
rectangular screen areas, and the arrival of a 'GEM message', in which
information about window management is passed.

The monitoring of these events is set up by <A HREF="#ON_MENU">ON MENU</A> xxx <A HREF="#GOSUB">GOSUB</A>, where xxx is the
event to be reacted to, and is actually invoked within a program by the <A HREF="#ON_MENU">ON MENU</A>
command. Each time this command is encountered, a check is made to see if an
Event has occured. If so, and if there was a previous <A HREF="#ON_MENU">ON MENU</A> xxx <A HREF="#GOSUB">GOSUB</A> to
define the reaction to that event, then the program branches to the appropriate
procedure.
<HR SIZE=3><H2 ID="ON_MENU">ON MENU</H2>
<B><A HREF="#ON_MENU">ON MENU</A> [t]</B>

t: <A HREF="#iexp">iexp</A>

The command <A HREF="#ON_MENU">ON MENU</A> supervises Event handling. Before using it, the required
reaction should have been specified with an <A HREF="#ON_MENU">ON MENU</A> xxx <A HREF="#GOSUB">GOSUB</A> command, the
variants of which are explained in the remainder of this chapter. For constant
supervision of Events it is necessary to use this command repeatedly. For this
reason, the <A HREF="#ON_MENU">ON MENU</A> command is normally found in a loop.

The parameter 't' contains the time (in thousandths of a second) to elapse
before the <A HREF="#ON_MENU">ON MENU</A> command is terminated. The reason for this delay is that
occasionally GEM does not notice the releasing of a mouse button (typical
effect: When the 'Close' box of a window is clicked, the window sometimes
remains open until the button is energetically clicked a few times)<A HREF="#.">.</A> By giving
a suitable value to 't', this should be prevented.

It is a good idea to use the parameter 't' even if a program is not
specifically concerned with the mouse buttons, as other programs, or GEM
routines called from within it, may do so.

<B>Example:</B>

    <A HREF="#ON_MENU_BUTTON">ON MENU BUTTON</A> 1,1,1 <A HREF="#GOSUB">GOSUB</A> test
    t%<A HREF="#=">=</A><A HREF="#TIMER">TIMER</A>
    <A HREF="#REPEAT">REPEAT</A>
      <A HREF="#PRINT">PRINT</A> (<A HREF="#TIMER">TIMER</A><A HREF="#-t">-t</A><A HREF="#%">%</A>)/200
      <A HREF="#ON_MENU">ON MENU</A> 2000
    <A HREF="#UNTIL">UNTIL</A> <A HREF="#MOUSEK">MOUSEK</A>=2
    <A HREF="#PROCEDURE">PROCEDURE</A> test
    <A HREF="#RETURN">RETURN</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The time since the program started is displayed every two seconds. If the
    left mouse button is pressed, then the Event occurs, and <A HREF="#ON_MENU">ON MENU</A> is
    terminated before the expiry of the two second period. A press of the right
    mouse button ends the program. If one changes the first line to <A HREF="#'">'</A><A HREF="#ON_MENU">ON MENU</A>
    BUTTON 0,0,0 <A HREF="#GOSUB">GOSUB</A> test' then the mouse monitoring is switched off, and the
    time parameter behind <A HREF="#ON_MENU">ON MENU</A> will have no effect.

evnt_multi()<A HREF="#+">+</A>, evnt_timer()+
<HR SIZE=3><H2 ID="MENU()">MENU()</H2>
<B><A HREF="#MENU">MENU</A>(x)</B>

x: <A HREF="#aexp">aexp</A> (from -2 to 15 inclusive)

The variables <A HREF="#MENU">MENU</A>(-2) to MENU(15) contain all the relevant information from an
Event. In the case when an item in a menu is selected, the <A HREF="#index">index</A> of the
selected item in the item list will be found in <A HREF="#MENU">MENU</A>(0) (see next section on
<A HREF="#Pull-down_Menus">Pull-down Menus</A>)<A HREF="#.">.</A>

<A HREF="#MENU">MENU</A>(-2) and MENU(-1) contain the address of the Message buffer and the address
of the menu Object tree respectively. The Message buffer lies in the variables
<A HREF="#MENU">MENU</A>(1) to MENU(8) and the <A HREF="#AES">AES</A> Integer Output Block in MENU(9) to MENU(15)<A HREF="#.">.</A> The
use of these variables to determine specific information is only briefly
discussed here, starting with <A HREF="#MENU">MENU</A>(1) and the Message buffer.

The Identification number of an Event when it occurs can be found in <A HREF="#MENU">MENU</A>(1)<A HREF="#.">.</A>
The other elements of the message buffer contain various values, the
interpretation of which depends on the value in <A HREF="#MENU">MENU</A>(1), as shown in the
following table, where different possible values of <A HREF="#MENU">MENU</A>(1) are listed together
with the meanings of other relevant <A HREF="#MENU">MENU</A>(x) variables in each case. The values
relating to window management will tend to be the most extensively used.

<A HREF="#MENU">MENU</A>(1)=10  A menu item was chosen:
  <A HREF="#MENU">MENU</A>(0)   Menu item <A HREF="#index">index</A> in the item list
  <A HREF="#MENU">MENU</A>(4)   Object number of the menu title
  <A HREF="#MENU">MENU</A>(5)   Object number of the chosen menu item

<A HREF="#MENU">MENU</A>(1)=20  A redraw of a rectangular window area is required:
  <A HREF="#MENU">MENU</A>(4)   Identification number (handle) of the window
  <A HREF="#MENU">MENU</A>(5)   x-coordinate of top-left corner
  <A HREF="#MENU">MENU</A>(6)   y-coordinate of top-left corner
  <A HREF="#MENU">MENU</A>(7)   Width of the redraw area
  <A HREF="#MENU">MENU</A>(8)   Height of the redraw area
            (See <A HREF="#ON_MENU_MESSAGE">ON MENU MESSAGE</A> for example.)

<A HREF="#MENU">MENU</A>(1)=21  A window was clicked (this normally means that a user wishes to
            activate this window)<A HREF="#:">:</A>
  <A HREF="#MENU">MENU</A>(4)   ID (handle) of the clicked window

<A HREF="#MENU">MENU</A>(1)=22  The 'Close' box (top left) of a window was clicked:
  <A HREF="#MENU">MENU</A>(4)   ID of the window

<A HREF="#MENU">MENU</A>(1)=23  The 'Full' box (top right) of a window was clicked (this normally
            means that the user wants to bring that window to maximum size)<A HREF="#:">:</A>
  <A HREF="#MENU">MENU</A>(4)   ID of the window

<A HREF="#MENU">MENU</A>(1)=24  One of the four arrow boxes or a slider bar area of the window
            border was clicked. The movement of the slider bar is reported by
            <A HREF="#MENU">MENU</A>(1)=25 or MENU(26)<A HREF="#.">.</A> MENU(1)=24 only shows that one of the gray
            areas was clicked:
  <A HREF="#MENU">MENU</A>(4)   ID of the window
  <A HREF="#MENU">MENU</A>(5)   The area that was clicked:
            0: Above the vertical slider
            1: Below the vertical slider
            2: Up arrow
            3: Down arrow
            4: To the left of the horizontal slider
            5: To the right of the horizontal slider
            6: Left arrow
            7: Right arrow

<A HREF="#MENU">MENU</A>(1)=25  The horizontal slider was moved:
  <A HREF="#MENU">MENU</A>(4)   ID of the window
  <A HREF="#MENU">MENU</A>(5)   Position of the moved slider (a number between 1 and 1000)

<A HREF="#MENU">MENU</A>(1)=26  The vertical slider was moved:
  <A HREF="#MENU">MENU</A>(4)   ID of the window
  <A HREF="#MENU">MENU</A>(5)   Position of the moved slider (a number between 1 and 1000)

<A HREF="#MENU">MENU</A>(1)=27  The size of the window was changed by means of the 'Size' box
            (lower right)<A HREF="#:">:</A>
  <A HREF="#MENU">MENU</A>(4)   ID of the window
  <A HREF="#MENU">MENU</A>(5)   New x-coordinate of top-left corner
  <A HREF="#MENU">MENU</A>(6)   New y-coordinate of top-left corner
  <A HREF="#MENU">MENU</A>(7)   New width of the window
  <A HREF="#MENU">MENU</A>(8)   New height of the window

<A HREF="#MENU">MENU</A>(1)=28  The position of the window was changed:
  <A HREF="#MENU">MENU</A>(4)   ID of the window
  <A HREF="#MENU">MENU</A>(5)   New x-coordinate of top-left corner
  <A HREF="#MENU">MENU</A>(6)   New y-coordinate of top-left corner
  <A HREF="#MENU">MENU</A>(7)   New width of the window
  <A HREF="#MENU">MENU</A>(8)   New height of the window

<A HREF="#MENU">MENU</A>(1)=29  A new GEM window was activated. This can happen with the closing of
            another active window, for example one which was used by a Desk
            Accessory:
  <A HREF="#MENU">MENU</A>(4)   ID of the window

<A HREF="#MENU">MENU</A>(1)=40  An <A HREF="#accessory">accessory</A> was selected:
  <A HREF="#MENU">MENU</A>(5)   Menu identification number of the <A HREF="#accessory">accessory</A>

<A HREF="#MENU">MENU</A>(1)=41  Current application terminated. This value can only be received by
            an <A HREF="#accessory">accessory</A>, but serves no purpurse under a multi-tasking
            operating system.
  <A HREF="#MENU">MENU</A>(4)   Menu identification number of the <A HREF="#accessory">accessory</A>

The variable <A HREF="#MENU">MENU</A>(9) contains bit information on which kind of event has
occured. If the bit for the appropriate event is set, the variables <A HREF="#MENU">MENU</A>(9) to
<A HREF="#MENU">MENU</A>(15) and <A HREF="#GINTOUT">GINTOUT</A>(0) to GINTOUT(7) will contain information as follows:

    <B>Bit  Event</B>
    0    Keyboard
    1    Mouse button
    2    Mouse has entered/exited rectangle 1
    3    Mouse has entered/exited rectangle 2
    4    A message arrived in the message buffer
    5    Timer

<A HREF="#MENU">MENU</A>(10)  x-position of the mouse when event terminated
<A HREF="#MENU">MENU</A>(11)  y-position of the mouse when event terminated
<A HREF="#MENU">MENU</A>(12)  Mouse buttons pressed:
          0: None
          1: Left
          2: Right
          3: Both buttons
          (See <A HREF="#ON_MENU_BUTTON">ON MENU BUTTON</A> for an example.)
<A HREF="#MENU">MENU</A>(13)  Returns the status of the keyboard 'modifier' keys, for each pressed
          key a bit is set as follows:
          0: Right shift
          1: Left shift
          2: Control
          3: Alternate
          (See <A HREF="#ON_MENU_KEY">ON MENU KEY</A> for an example.)
<A HREF="#MENU">MENU</A>(14)  Returns information about a pressed key. The low-order byte contains
          the <A HREF="#ASCII">ASCII</A> code of the character, and the high-order byte contains the
          keyboard <A HREF="#Scan">Scan</A> Code. (See <A HREF="#ON_MENU_KEY">ON MENU KEY</A> for an example.)
<A HREF="#MENU">MENU</A>(15)  Returns the number of mouse clicks (single click, double-click, etc.)
          that caused the event.

<B>Memo:</B> This table does not seem to have a limit. Values less than -2 or
      greater than 15 do not generate an error message.

evnt_mesag()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="ON_MENU_BUTTON">ON MENU BUTTON</H2>
<B><A HREF="#ON_MENU_BUTTON">ON MENU BUTTON</A> clicks,but,state <A HREF="#GOSUB">GOSUB</A> <A HREF="#proc">proc</A></B>

clicks, but, state: <A HREF="#iexp">iexp</A>
proc: procedure name

This sets up the action to be taken when one or more clicks of the mouse are
received. With a subsequent <A HREF="#ON_MENU">ON MENU</A> command, the named procedure will be
branched to if the conditions imposed by the parameters are met:

clicks <A HREF="#-">-</A> Sets the maximum number of clicks which generates a responce.

but    <A HREF="#-">-</A> The expected button combination as follows:
         0: None
         1: Left
         2: Right
         3: Both

state  <A HREF="#-">-</A> Specifies which button state (up or down) will cause the Event. With
         state=0, the Event will be prompted by the button(s) being up, and
         with state=1, the button(s) being down will cause the Event.

<A HREF="#proc">proc</A>   <A HREF="#-">-</A> The name of the procedure to which the program will branch if the
         above conditions are met.

<B>Example:</B>

    <A HREF="#ON_MENU_BUTTON">ON MENU BUTTON</A> 1,1,0 <A HREF="#GOSUB">GOSUB</A> box
    <A HREF="#GRAPHMODE">GRAPHMODE</A> 3
    <A HREF="#REPEAT">REPEAT</A>
      <A HREF="#ON_MENU">ON MENU</A>
    <A HREF="#UNTIL">UNTIL</A> <A HREF="#MOUSEK">MOUSEK</A>=2
    <A HREF="#'">'</A>
    <A HREF="#PROCEDURE">PROCEDURE</A> box
      <A HREF="#ADD">ADD</A> i%,7
      <A HREF="#IF">IF</A> i%<A HREF="#&">&</A>#62;200
        i%=3
      <A HREF="#ENDIF">ENDIF</A>
      <A HREF="#BOX">BOX</A> 320-i%,200-i%,320+i%,200+i%
    <A HREF="#RETURN">RETURN</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Boxes increasing in size are drawn on the screen so long as the left mouse
    button is not pressed. The program will terminate if the right mouse button
    is pressed.

<B>Memo:</B> If the procedure used with <A HREF="#ON_MENU_BUTTON">ON MENU BUTTON</A> is undefined the compiler
      will not issue and error message.  Instead the compiler writes a bad
      binary where <A HREF="#ON_MENU_BUTTON">ON MENU BUTTON</A> is translated into JSR 0.l!

evnt_button()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="ON_MENU_KEY">ON MENU KEY</H2>
<B><A HREF="#ON_MENU_KEY">ON MENU KEY</A> <A HREF="#GOSUB">GOSUB</A> <A HREF="#proc">proc</A></B>

proc: procedure name

This command enables the monitoring of the keyboad. The parameter <A HREF="#proc">proc</A> is the
name of a procedure to which the program branches, if a key was pressed during
an <A HREF="#ON_MENU">ON MENU</A> command.

<B>Example:</B>

    <A HREF="#ON_MENU_KEY">ON MENU KEY</A> <A HREF="#GOSUB">GOSUB</A> key_output
    <A HREF="#REPEAT">REPEAT</A>
      <A HREF="#ON_MENU">ON MENU</A>
    <A HREF="#UNTIL">UNTIL</A> <A HREF="#MOUSEK">MOUSEK</A>=2
    <A HREF="#'">'</A>
    <A HREF="#PROCEDURE">PROCEDURE</A> key_output
      <A HREF="#PRINT">PRINT</A> "keyboard shift keys: "<A HREF="#;">;</A><A HREF="#MENU">MENU</A>(13)
      <A HREF="#PRINT">PRINT</A> "<A HREF="#ASCII">ASCII</A>-code: "<A HREF="#;">;</A><A HREF="#BYTE">BYTE</A>(<A HREF="#MENU">MENU</A>(14))
      <A HREF="#PRINT">PRINT</A> "<A HREF="#Scan">Scan</A>-code: "<A HREF="#;">;</A><A HREF="#SHR">SHR</A>(<A HREF="#MENU">MENU</A>(14),8)
      <A HREF="#PRINT">PRINT</A>
    <A HREF="#RETURN">RETURN</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> With the press of a key the current condition of the keyboard modifier keys
    (Shift, Control, Alternate) is displayed as well as the <A HREF="#ASCII">ASCII</A> code and <A HREF="#Scan">Scan</A>
    Code of the pressed key. A press of the right mouse button terminates the
    program. For the meaning of <A HREF="#MENU">MENU</A>(13) and MENU(14) see function <A HREF="#MENU()">MENU()</A>.

<B>Memo:</B> If the procedure used with <A HREF="#ON_MENU_KEY">ON MENU KEY</A> is undefined the compiler
      will not issue and error message.  Instead the compiler writes a bad
      binary where <A HREF="#ON_MENU_KEY">ON MENU KEY</A> is translated into JSR 0.l!

evnt_keybd()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="ON_MENU_IBOX">ON MENU IBOX</H2>
<A NAME="ON_MENU_OBOX"></A><B><A HREF="#ON_MENU_IBOX">ON MENU IBOX</A> n,x,y,w,h <A HREF="#GOSUB">GOSUB</A> <A HREF="#proc">proc</A>
<A HREF="#ON_MENU_OBOX">ON MENU OBOX</A> n,x,y,w,h <A HREF="#GOSUB">GOSUB</A> <A HREF="#proc">proc</A></B>

n, x, y, w, h: <A HREF="#iexp">iexp</A>
proc: procedure name

These two commands monitor the mouse coordinates. If the mouse enters (IBOX) or
leaves (OBOX) a rectangle display area, the procedure proc is branched to.

It is possible to define two rectangle display areas which are supervised
seperately. 'n' is the number (1 or 2) of the appropriate rectangle, x is left
x-coordinate, y the upper y-coordinate, w the width, and h the height of the
rectangle. The monitoring takes place during the execution of an <A HREF="#ON_MENU">ON MENU</A>
command.

<B>Example:</B>

    <A HREF="#ON_MENU_IBOX">ON MENU IBOX</A> 1,250,130,140,140 <A HREF="#GOSUB">GOSUB</A> enter_box
    <A HREF="#ON_MENU_OBOX">ON MENU OBOX</A> 2,50,50,540,300 <A HREF="#GOSUB">GOSUB</A> exit_box
    <A HREF="#'">'</A>
    <A HREF="#GRAPHMODE">GRAPHMODE</A> 3
    <A HREF="#BOX">BOX</A> 250,130,390,270
    <A HREF="#BOX">BOX</A> 50,50,590,350
    <A HREF="#REPEAT">REPEAT</A>
      <A HREF="#ON_MENU">ON MENU</A>
    <A HREF="#UNTIL">UNTIL</A> <A HREF="#MOUSEK">MOUSEK</A>=2
    <A HREF="#'">'</A>
    <A HREF="#PROCEDURE">PROCEDURE</A> enter_box
      <A HREF="#BOX">BOX</A> 250+i%,130+i%,390-i%,270-i%
      <A HREF="#IF">IF</A> i%=70
        i%=0
      <A HREF="#ENDIF">ENDIF</A>
      <A HREF="#ADD">ADD</A> i%,2
    <A HREF="#RETURN">RETURN</A>
    <A HREF="#'">'</A>
    <A HREF="#PROCEDURE">PROCEDURE</A> exit_box
      <A HREF="#BOX">BOX</A> 0+j%,0+j%,639-j%,399-j%
      <A HREF="#IF">IF</A> j%=0
        j%=50
      <A HREF="#ENDIF">ENDIF</A>
      <A HREF="#SUB">SUB</A> j%,2
    <A HREF="#RETURN">RETURN</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> When the mouse enters the inner rectangle, shrinking boxes appear inside
    it. When it leaves the outside rectangle, growing boxes appear there.
    Pressing the right mouse button terminates the program.

<B>Memo:</B> If the procedure used with IBOX or OBOX is undefined the compiler
      will not issue and error message. Instead the compiler writes a bad
      binary where IBOX or OBOX are translated into JSR 0.l!

evnt_mouse()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="ON_MENU_MESSAGE">ON MENU MESSAGE</H2>
<B><A HREF="#ON_MENU_MESSAGE">ON MENU MESSAGE</A> <A HREF="#GOSUB">GOSUB</A> <A HREF="#proc">proc</A></B>

proc: procedure name

If a message arrives in the message buffer, then the program branches to the
procedure with the name proc. The monitoring of the message buffer takes place
with each <A HREF="#ON_MENU">ON MENU</A> command. The structure of the message buffer is discussed in
the section concerning <A HREF="#MENU()">MENU()</A><A HREF="#.">.</A>

<B>Example:</B>

    <A HREF="#DIM">DIM</A> m$(10)
    <A HREF="#FOR">FOR</A> i%=0 TO 10
      <A HREF="#READ">READ</A> m$(i%)
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#DATA">DATA</A> Desk,Redraw,<A HREF="#-">-</A>------------------------
    <A HREF="#DATA">DATA</A> 1,2,3,4,5,6,"",""
    <A HREF="#OPENW">OPENW</A> 4,0,0
    <A HREF="#MENU">MENU</A> m$<A HREF="#()">()</A>
    <A HREF="#ON_MENU_MESSAGE">ON MENU MESSAGE</A> <A HREF="#GOSUB">GOSUB</A> read_message
    <A HREF="#PRINT_AT">PRINT AT</A>(1,1)<A HREF="#;">;</A>
    <A HREF="#REPEAT">REPEAT</A>
      <A HREF="#ON_MENU">ON MENU</A>
    <A HREF="#UNTIL">UNTIL</A> <A HREF="#MOUSEK">MOUSEK</A>=2
    <A HREF="#'">'</A>
    <A HREF="#PROCEDURE">PROCEDURE</A> read_message
      <A HREF="#IF">IF</A> <A HREF="#MENU">MENU</A>(1)=20
        <A HREF="#PRINT">PRINT</A> <A HREF="#CHR$">CHR$</A>(7)<A HREF="#;">;</A>
        <A HREF="#PRINT">PRINT</A> "A screen section must be redrawn"
      <A HREF="#ELSE">ELSE</A>
        <A HREF="#PRINT">PRINT</A> <A HREF="#CHR$">CHR$</A>(7)<A HREF="#;">;</A>
        <A HREF="#PRINT">PRINT</A> "Something has happened <A HREF="#!">!</A>!!"
      <A HREF="#ENDIF">ENDIF</A>
    <A HREF="#RETURN">RETURN</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> To test this program, an <A HREF="#accessory">accessory</A> must be loaded. If selected, then the
    program announces that a screen section was covered and has to be redrawn
    (see also <A HREF="#MENU()">MENU()</A>)<A HREF="#.">.</A> At the beginning this message appears once.  The program
    can be terminated with a press of the right mouse button.

<B>Memo:</B> If the procedure used with <A HREF="#ON_MENU_MESSAGE">ON MENU MESSAGE</A> is undefined the compiler
      will not issue and error message. Instead the compiler writes a bad
      binary where <A HREF="#ON_MENU_MESSAGE">ON MENU MESSAGE</A> is translated into JSR 0.l!

evnt_mesag()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="Pull-down_Menus">Pull-down Menus</H2>
<A HREF="#ON_MENU_GOSUB">ON MENU GOSUB</A>
<A HREF="#MENU">MENU</A>, <A HREF="#MENU_OFF">MENU OFF</A>, <A HREF="#MENU_KILL">MENU KILL</A>

In this section the commands specific to GFA BASIC 3 for control of
pull-down-menus are given. Unfortunately a certain confusion prevails in the
literature on this topic as to the meaning of some of the terms used. They
shall therefore be stated here as they are used in this manual. We use the term
'pull-down-menu' as a general term for menu titles or headings. In the top
screen line the constantly visible part of the menu, is where the menu list is
located. This contains the individual headings. If the mouse arrow arrives at
one of these headings, then under it a so-called menu which unfolds.  Each part
of this menu can be selected individually as a menu entry. This choice of
terminology is not generally obligatory but is used throughout this manual,
elsewhere slightly different definitions are used.

During the creation of a menu its entries are set in an array m$<A HREF="#()">()</A><A HREF="#.">.</A> With the
command <A HREF="#MENU">MENU</A> m$<A HREF="#()">()</A> this pull-down-menu is displayed on the screen. The command
<A HREF="#ON_MENU_GOSUB">ON MENU GOSUB</A> determines which procedure the program branches to on the
selection of a menu entry. When the program is running, a check is made to see
whether an entry was selected on each occurrence of an <A HREF="#ON_MENU">ON MENU</A> command.

The command <A HREF="#MENU_OFF">MENU OFF</A> returns reverse video entries in the menu list to normal
display. With <A HREF="#MENU_KILL">MENU KILL</A> the menu is switched off. The command <A HREF="#MENU">MENU</A> x,y enables
menu entries to be provided with checkmarks or to be displayed in light text,
making this menu entry non-selectable.

<B>Memo:</B> If the procedure used with <A HREF="#ON_MENU">ON MENU</A> is undefined the compiler will
      not issue and error message. Instead the compiler writes a bad binary
      where <A HREF="#ON_MENU">ON MENU</A> is translated into JSR 0.l!
<HR SIZE=3><H2 ID="ON_MENU_GOSUB">ON MENU GOSUB</H2>
<A NAME="MENU"></A><A NAME="MENU_OFF"></A><A NAME="MENU_KILL"></A><B><A HREF="#ON_MENU_GOSUB">ON MENU GOSUB</A> <A HREF="#proc">proc</A>
<A HREF="#MENU">MENU</A> m$<A HREF="#()">()</A>
<A HREF="#MENU_OFF">MENU OFF</A>
<A HREF="#MENU_KILL">MENU KILL</A>
<A HREF="#MENU">MENU</A> x,y
<A HREF="#MENU">MENU</A> x,text$</B>

proc: procedure name
m$()<A HREF="#:">:</A> string-array
x, y: <A HREF="#iexp">iexp</A>
text$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>

These commands are responsible for generating and managing a menu, and are
supported by the commands and variables in the previous section (<A HREF="#ON_MENU">ON MENU</A>,
<A HREF="#MENU()">MENU()</A>)<A HREF="#.">.</A>

With <A HREF="#ON_MENU_GOSUB">ON MENU GOSUB</A> <A HREF="#proc">proc</A>, the procedure to which control will be passed on
selection of a menu entry is determined. If an <A HREF="#accessory">accessory</A> is currently open, the
procedure will not be called. Within the procedure, which menu entry was
selected can be found by using the variable <A HREF="#MENU">MENU</A>(0)<A HREF="#.">.</A> MENU(0) is the <A HREF="#index">index</A> of
the selected entry in the array of the entries m$<A HREF="#()">()</A>, and m$(<A HREF="#MENU">MENU</A>(0)) indicates
the text clicked on the menu if <A HREF="#OPTION_BASE">OPTION BASE</A> 0 is currently selected. If <A HREF="#OPTION">OPTION</A>
BASE 1 has been chosen, then the text of the selected item is in m$(<A HREF="#MENU">MENU</A>(0)+1)<A HREF="#.">.</A>

The command <A HREF="#MENU">MENU</A> m$<A HREF="#()">()</A> puts the menu onto the screen. The string array m$()
contains the headings, entries and reserved space for the <A HREF="#accessories">accessories</A><A HREF="#.">.</A> The
following format must be used during the arrangement of the entries in the
array m$()<A HREF="#:">:</A>

    m$(0)          Heading of the first menu in which <A HREF="#accessories">accessories</A> can exist.

    m$(1)          Name of the first entry in the first menu.

    m$(2)          A line of minus signs.

    m$(3) <A HREF="#-">-</A> m$(8)  Reserved space for <A HREF="#accessories">accessories</A><A HREF="#.">.</A> These elements need only be
                   a single character long, as their contents are ignored. If
                   an <A HREF="#accessory">accessory</A> was loaded when the computer was switched on,
                   this will take up one of these strings. Otherwise they will
                   not be printed.

    m$(9)          An empty string, which marks the end of the first menu.

All further menus have the following format:

    1. Heading of the menu.
    2. List of the menu entries.
    3. An empty string which marks the end of the menu.

After the last menu another further empty-string marks the end of the entire
Pull-down-menu. A menu entry which begins with a minus sign is represented but
is not selectable and is shown in light text.

<A HREF="#MENU_OFF">MENU OFF</A> returns a menu title to 'normal video' display mode. (After an item is
chosen from a menu, the menu title is displayed in inverse video)<A HREF="#.">.</A>

<A HREF="#MENU_KILL">MENU KILL</A> deactivates a menu but does not, however, remove the menu title list
from the screen. In addition <A HREF="#MENU_KILL">MENU KILL</A> turns off the <A HREF="#ON_MENU_GOSUB">ON MENU GOSUB</A> options.

With the <A HREF="#MENU">MENU</A> x,y instruction the x-th entry in a menu can be given certain
attributes. The numbering of the entries corresponds to the indexing of the
array of menu entries, counting from zero and including titles, entries for
Accessories and null strings ("")<A HREF="#.">.</A>

The second parameter y specifies the attribute to be given, or removed from,
the x-th menu entry as follows:

    <B>y  Effect</B>
    0  Checkmark to be removed, if present, from in front of a menu item
    1  Checkmark to be placed in front of a menu item <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> 
    2  Menu item to be made non-selectable, and printed in light characters
    3  Menu item to be made selectable, and written in normal characters

With the <A HREF="#MENU">MENU</A> x,text$ instruction the x-th entry of a menu can have it's text
altered. The numbering of the entries corresponds to the indexing of the array
of menu entries, counting from zero and including titles, entries for
Accessories and null strings ("")<A HREF="#.">.</A>

Sample Pull-down menu program:

    <A HREF="#DIM">DIM</A> entry$(20)
    <A HREF="#DATA">DATA</A> "Desk","  Test "
    <A HREF="#DATA">DATA</A> <A HREF="#-">-</A>---------------,1,2,3,4,5,6,""
    <A HREF="#DATA">DATA</A> "File","  Load ","  Save "
    <A HREF="#DATA">DATA</A> <A HREF="#-">-</A>--------,"  Quit ",""
    <A HREF="#DATA">DATA</A> "Titles","  Entry 1 ","  Entry 2 ",""
    <A HREF="#DATA">DATA</A> End
    <A HREF="#'">'</A>
    i%<A HREF="#=">=</A>-1
    <A HREF="#REPEAT">REPEAT</A>
      <A HREF="#INC">INC</A> i%
      <A HREF="#READ">READ</A> entry$(i%)
    <A HREF="#UNTIL">UNTIL</A> entry$(i%)<A HREF="#=">=</A>"End"
    entry$(i%)<A HREF="#=">=</A>""
    <A HREF="#'">'</A>
    <A HREF="#MENU">MENU</A> entry$<A HREF="#()">()</A>
    <A HREF="#ON_MENU_GOSUB">ON MENU GOSUB</A> evaluate
    <A HREF="#OPENW">OPENW</A> 0
    <A HREF="#'">'</A>
    <A HREF="#REPEAT">REPEAT</A>
      <A HREF="#ON_MENU">ON MENU</A>
    <A HREF="#UNTIL">UNTIL</A> <A HREF="#MOUSEK">MOUSEK</A>=2
    <A HREF="#'">'</A>
    <A HREF="#PROCEDURE">PROCEDURE</A> evaluate
      <A HREF="#MENU_OFF">MENU OFF</A>
      <A HREF="#'">'</A> <A HREF="#MENU">MENU</A>(0) contains array <A HREF="#index">index</A> of selected item
      m%<A HREF="#=">=</A><A HREF="#MENU">MENU</A>(0)
      <A HREF="#PRINT">PRINT</A> entry$(m%)
      <A HREF="#'">'</A>
      <A HREF="#ALERT">ALERT</A> 0,"Checkmark before item?",0," Yes <A HREF="#&#124;">&#124;</A> No ",a%
      <A HREF="#IF">IF</A> a%=1
        <A HREF="#MENU">MENU</A> m%,1
      <A HREF="#ELSE">ELSE</A>
        <A HREF="#MENU">MENU</A> m%,0
      <A HREF="#ENDIF">ENDIF</A>
      <A HREF="#'">'</A>
      <A HREF="#ALERT">ALERT</A> 0,"Lightened characters?<A HREF="#&#124;">&#124;</A>(Not selectable)",0," Yes <A HREF="#&">&</A>#124; No ",a%
      <A HREF="#IF">IF</A> a%=1
        <A HREF="#MENU">MENU</A> m%,2
      <A HREF="#ELSE">ELSE</A>
        <A HREF="#MENU">MENU</A> m%,3
      <A HREF="#ENDIF">ENDIF</A>
    <A HREF="#RETURN">RETURN</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> A menu is created and monitored. When a menu item is selected, its text is
    printed and the user is asked first if it is to be checkmarked, and then
    whether it should be 'non-selectable' or not.

<B>Memo:</B> Menu titles are limited to 10 characters.
      Menus don't display correctly in N.Aes if hidemenu=true. This happens in
      the editor or compiled.
      The library does not honor the character width returned from
      graf_handle() and assumes 8. However the editor is ok.
      The <A HREF="#MENU">MENU</A> m$<A HREF="#()">()</A> commmand is limted to 18 titles.
        Object count is limited to 200 entries.
        String space is limted to about 4000 bytes.
        Internally calls <A HREF="#MENU_KILL">MENU KILL</A> if an menubar is already active.

      <A HREF="#MENU">MENU</A> x,y will accept any value for y and not complain.

      All the <A HREF="#MENU">MENU</A> commands will do nothing if no menu bar is active.
      No error will be issued, they are simply ignored.

menu_bar()<A HREF="#+">+</A>, menu_tnormal()+, menu_icheck()+, menu_ienable()+, menu_text()+
<HR SIZE=3><H2 ID="Window_Commands">Window Commands</H2>
<A HREF="#OPENW">OPENW</A>, <A HREF="#CLOSEW">CLOSEW</A>
<A HREF="#W_HAND">W_HAND</A><A HREF="#()">()</A>, <A HREF="#W_INDEX">W_INDEX</A>()
<A HREF="#CLEARW">CLEARW</A>
<A HREF="#TITLEW">TITLEW</A>, <A HREF="#INFOW">INFOW</A>
<A HREF="#TOPW">TOPW</A>
<A HREF="#FULLW">FULLW</A>
<A HREF="#WINDTAB">WINDTAB</A>, WINDTAB()

<A HREF="#GFA-Basic">GFA-Basic</A> offers a number of commands for simple window management: (<A HREF="#OPENW">OPENW</A>,
<A HREF="#CLOSEW">CLOSEW</A>, <A HREF="#CLEARW">CLEARW</A>, <A HREF="#TITLEW">TITLEW</A>, <A HREF="#INFOW">INFOW</A>), but if one wants to program windows more
efficiently, taking full advantage of the GEM facilities, then the appropriate
<A HREF="#AES">AES</A> routines will need to be used (see <A HREF="#Chapter_11_-_AES_Libraries">Chapter 11 - AES Libraries</A>)<A HREF="#.">.</A>
Additionally the functions <A HREF="#W_HAND">W_HAND</A><A HREF="#()">()</A> and <A HREF="#W_INDEX">W_INDEX</A>() are available as a link
between the simpler window management commands and the more extensive <A HREF="#AES">AES</A>
functions in the <A HREF="#Window_Library">Window Library</A><A HREF="#.">.</A>

With the simplest of the instructions, <A HREF="#OPENW">OPENW</A>, all four windows share a common
corner, their other corners all lying on the screen edges. When this method is
used, only one pair of coordinates is needed to define the size and position of
all four windows, these being the coordinates of the common corner.

After a window has been opened, most commands (<A HREF="#PRINT">PRINT</A>, <A HREF="#PRINT_AT">PRINT AT</A>, <A HREF="#TEXT">TEXT</A>, etc.)
will take as their origin, the top left corner of the work-area of the window,
but commands such as <A HREF="#GET">GET</A>, <A HREF="#PUT">PUT</A>, and <A HREF="#BITBLT">BITBLT</A>, which access the screen memory
directly, will still take the top left corner of the screen for their origin.
Graphics and text which leave the current window area are automatically
clipped.
<HR SIZE=3><H2 ID="OPENW">OPENW</H2>
<A NAME="CLOSEW"></A><B><A HREF="#OPENW">OPENW</A> n[,x_pos,y_pos]
<A HREF="#OPENW">OPENW</A> #n,x,y,w,h,attr
<A HREF="#CLOSEW">CLOSEW</A> [<A HREF="##">#</A>]n</B>

n, x, y, w, h, attr, x_pos, y_pos: <A HREF="#aexp">aexp</A>

With <A HREF="#'">'</A><A HREF="#OPENW">OPENW</A> n' window number n is opened. The parameters x_pos and y_pos
determine the position of the 'free' window corner, i.e. the one which is not
on the edge of the screen. The <A HREF="#AES">AES</A> routines, <A HREF="#'">'</A><A HREF="#OPENW">OPENW</A> #n' or <A HREF="#WINDTAB">WINDTAB</A><A HREF="#()">()</A> are
required for more flexible window management. The coordinates of the possible
windows set up with this instruction (assuming high-resolution mode) will be:

    <B>Number  Top left corner  Lower right corner</B>
    1       0,19             x_pos,y_pos
    2       x_pos,19         639,y_pos
    3       0,y_pos          x_pos,399
    4       x_pos,y_pos      639,399

Arranged as follows:

          0            x_pos           639
     19    <A HREF="#-">-</A>----------------------------
          <A HREF="#&#124;">&#124;</A>              <A HREF="#&">&</A>#124;              &#124;
          <A HREF="#&#124;">&#124;</A>      1       <A HREF="#&">&</A>#124;      2       &#124;
          <A HREF="#&#124;">&#124;</A>              <A HREF="#&">&</A>#124;              &#124;
    y_pos <A HREF="#&#124;">&#124;</A><A HREF="#-">-</A>-------------<A HREF="#&">&</A>#124;--------------&#124;
          <A HREF="#&#124;">&#124;</A>              <A HREF="#&">&</A>#124;              &#124;
          <A HREF="#&#124;">&#124;</A>      3       <A HREF="#&">&</A>#124;      4       &#124;
          <A HREF="#&#124;">&#124;</A>              <A HREF="#&">&</A>#124;              &#124;
    399    <A HREF="#-">-</A>----------------------------

The point (x_pos,y_pos) is thus the point of contact of the four possible
windows.

With the instruction <A HREF="#'">'</A><A HREF="#OPENW">OPENW</A> 0' no genuine window is opened, but the coordinate
origin is moved to (0,19)<A HREF="#.">.</A> Thus the upper 19 lines of the screen are protected
from graphical or text output. This usually protects a menu bar against
accidental overwriting.

The instruction <A HREF="#'">'</A><A HREF="#CLOSEW">CLOSEW</A> n' closes the window with number n, 'CLOSEW #n'
closes the window with the arbitrarily assigned number n. (See also example
program at the end of this section.)

<B>Example:</B>

    <A HREF="#REPEAT">REPEAT</A>
      <A HREF="#IF">IF</A> <A HREF="#MOUSEK">MOUSEK</A>=1
        <A HREF="#CLOSEW">CLOSEW</A> 1
        <A HREF="#OPENW">OPENW</A> 4,320,200
      <A HREF="#ENDIF">ENDIF</A>
      <A HREF="#IF">IF</A> <A HREF="#MOUSEK">MOUSEK</A>=2
        <A HREF="#CLOSEW">CLOSEW</A> 4
        <A HREF="#OPENW">OPENW</A> 1,100,100
      <A HREF="#ENDIF">ENDIF</A>
    <A HREF="#UNTIL">UNTIL</A> <A HREF="#MOUSEK">MOUSEK</A>=3
    <A HREF="#CLOSEW">CLOSEW</A> #1
    <A HREF="#CLOSEW">CLOSEW</A> #4

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Pressing the left mouse button opens window 4 and closes window 1, or
    pressing the right mouse button opens window 1 and closes window 4.
    Simultaneously pressing both mouse buttons terminates the program.

The second variant, <A HREF="#'">'</A><A HREF="#OPENW">OPENW</A> #n', opens a window with the arbitrarily assigned
number 'n', with the position, size, and attributes specified in x, y, w, h,
and attr. The expression attr determines which window components (title bar,
sliders, etc.) the window is to have (see <A HREF="#WINDTAB">WINDTAB</A><A HREF="#()">()</A> below or <A HREF="#WIND_CREATE">WIND_CREATE</A>() in
the <A HREF="#AES">AES</A> section)<A HREF="#.">.</A> 'n' is then the number to be used with <A HREF="#TITLEW">TITLEW</A>, <A HREF="#INFOW">INFOW</A>, etc. <A HREF="#-">-</A>
it is <A HREF="#NOT">NOT</A> the GEM 'handle' of the window.

<A HREF="#'">'</A><A HREF="#CLOSEW">CLOSEW</A> #n' closes such a window.

<B>Example:</B>

    <A HREF="#TITLEW">TITLEW</A> #1," Title 1 "                 !Gives title to window #1
    <A HREF="#INFOW">INFOW</A> #1,<A HREF="#STRING$">STRING$</A>(15,"<A HREF="#.">.</A>..<A HREF="#&#124;">&#124;</A> ")          !Allocates info line
    <A HREF="#OPENW">OPENW</A> #1,16,32,600,300,&X111111111111 !Sets coords <A HREF="#+">+</A> attributes and opens a window
    <A HREF="#~">~</A><A HREF="#INP">INP</A>(2)
    <A HREF="#CLOSEW">CLOSEW</A> #1                             !Important! Closes window

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Opens a window with a title and an info line. Pressing a key terminates the
    program.

<B>Memo:</B> None of these commands properly check the window number.
      This is true for the editor and the library.

      <A HREF="#'">'</A><A HREF="#OPENW">OPENW</A> n,x,y' will ignore the command if the x or y are off screen.

      <A HREF="#'">'</A><A HREF="#OPENW">OPENW</A> #n,x,y,w,h,a' will accept <A HREF="#index">index</A> 0 then ignore the rest of the
      parameters. This appears to be a bug.

      <A HREF="#CLOSEW">CLOSEW</A> 0 will restore <A HREF="#_X">_X</A> and <A HREF="#_Y">_Y</A> back to the screen width and height.

wind_create()<A HREF="#+">+</A>, wind_open()+, wind_close()+, wind_delete()+
<HR SIZE=3><H2 ID="W_HAND">W_HAND</H2>
<A NAME="W_INDEX"></A><B><A HREF="#W_HAND">W_HAND</A>(#n)
<A HREF="#W_INDEX">W_INDEX</A>(#hd)</B>

n, hd: <A HREF="#aexp">aexp</A>

<A HREF="#W_HAND">W_HAND</A><A HREF="#()">()</A> returns the GEM 'handle' (identification number) of the window whose
'channel number' was specified in 'n' (1 to 4)<A HREF="#.">.</A>

<A HREF="#W_INDEX">W_INDEX</A><A HREF="#()">()</A> performs the inverse function and returns the window number (1 to 4)
for the specified GEM handle (1 to <A HREF="#?">?</A>)<A HREF="#.">.</A>

<B>Note:</B> The window number is the value used in the simple window control
      commands. The GEM handle is a different value (used by <A HREF="#AES">AES</A>) which refers
      to the same window. The GEM handle should be used to specify a
      particular window when using the <A HREF="#AES">AES</A> routines.

<B>Example:</B>

    <A HREF="#OPENW">OPENW</A> 2
    <A HREF="#PRINT">PRINT</A> <A HREF="#W_HAND">W_HAND</A>(#2)
    <A HREF="#~">~</A><A HREF="#INP">INP</A>(2)
    <A HREF="#CLOSEW">CLOSEW</A> #2

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Prints the <A HREF="#AES">AES</A> 'handle' of the window numbered 2 on the screen. Pressing a
    key terminates the program.

<B>Memo:</B> <A HREF="#W_HAND">W_HAND</A><A HREF="#()">()</A> does not return the desktop handle correctly.
      Negative offsets result in access below the table.
      Too large of values not checked, results in access beyond the table.

      <A HREF="#W_INDEX">W_INDEX</A><A HREF="#()">()</A> returns 0 for any <A HREF="#AES">AES</A> handle it cannont find.

      These problems occur in the editor as well as the library.

wind_get()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="CLEARW">CLEARW</H2>
<A NAME="TITLEW"></A><A NAME="INFOW"></A><A NAME="TOPW"></A><A NAME="FULLW"></A><B><A HREF="#CLEARW">CLEARW</A> [<A HREF="##">#</A>]n
<A HREF="#TITLEW">TITLEW</A> #n,title$
<A HREF="#INFOW">INFOW</A> #n,info$
<A HREF="#TOPW">TOPW</A> #n
<A HREF="#FULLW">FULLW</A> [<A HREF="##">#</A>]n</B>

n: <A HREF="#aexp">aexp</A>
title$, info$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>

<A HREF="#CLEARW">CLEARW</A> deletes the contents of window number 'n'<A HREF="#.">.</A>

<A HREF="#TITLEW">TITLEW</A> writes the text in 'title$' in the top line of the window.

<A HREF="#INFOW">INFOW</A> writes the text 'info$' on the second (information) line of the window.

<A HREF="#TOPW">TOPW</A> activates the window number 'n'<A HREF="#.">.</A>

<A HREF="#FULLW">FULLW</A> brings window 'n' to full screen size.

<A HREF="#CLEARW">CLEARW</A> clears every visible part of a window, without activating it.
Internally it is done by <A HREF="#WIND_UPDATE">WIND_UPDATE</A><A HREF="#()">()</A> and <A HREF="#WIND_GET">WIND_GET</A>()<A HREF="#.">.</A>

<B>Example:</B>

    <A HREF="#DEFFILL">DEFFILL</A> 1,2,4
    <A HREF="#PBOX">PBOX</A> 0,0,639,399
    <A HREF="#OPENW">OPENW</A> 1
    <A HREF="#PAUSE">PAUSE</A> 50
    <A HREF="#FULLW">FULLW</A> #1
    <A HREF="#PRINT">PRINT</A> " Window 1 "
    <A HREF="#OPENW">OPENW</A> 4,100,100
    <A HREF="#PAUSE">PAUSE</A> 50
    <A HREF="#CLEARW">CLEARW</A> 1
    <A HREF="#OPENW">OPENW</A> 3
    <A HREF="#PAUSE">PAUSE</A> 50
    <A HREF="#TOPW">TOPW</A> #1
    <A HREF="#PAUSE">PAUSE</A> 50
    <A HREF="#CLOSEW">CLOSEW</A> #1
    <A HREF="#TITLEW">TITLEW</A> 4," Window 4 "
    <A HREF="#INFOW">INFOW</A> 3," Window 3 "
    <A HREF="#PAUSE">PAUSE</A> 100
    <A HREF="#CLOSEW">CLOSEW</A> #3
    <A HREF="#CLOSEW">CLOSEW</A> 4

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Some windows are opened, altered and then closed again.

<B>Memo:</B> <A HREF="#TITLEW">TITLEW</A> and <A HREF="#INFOW">INFOW</A> internally clip the string off at 78 characters.

      The compiler contains a bug such that <A HREF="#CLEARW">CLEARW</A> x and CLEARW #x call
      the same library routine. The library contains two routines:
      <A HREF="#CLEARW">CLEARW</A> x  <A HREF="#-">-</A> tops the window then clears it (never used)
      <A HREF="#CLEARW">CLEARW</A> #x <A HREF="#-">-</A> walks the rectangle list (all calls end up here)

      <A HREF="#FULLW">FULLW</A> x and FULLW #x call different routines in the library:
      <A HREF="#FULLW">FULLW</A> x  <A HREF="#-">-</A> not sure exactly what this one does yet
      <A HREF="#FULLW">FULLW</A> #x <A HREF="#-">-</A> seems more straight forward

      If you don't use any of the GFA window commands the buffers for the
      <A HREF="#TITLEW">TITLEW</A> and <A HREF="#INFOW">INFOW</A> strings are not even linked, so no memory is wasted.

      None of these commands properly check the window number.
      This is true for the editor and the library.

wind_set()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="WINDTAB">WINDTAB</H2>
<B><A HREF="#WINDTAB">WINDTAB</A>
<A HREF="#WINDTAB">WINDTAB</A>(i,j)</B>

i, j: <A HREF="#iexp">iexp</A>

The value of <A HREF="#WINDTAB">WINDTAB</A> gives the address of the Window Parameter table, where the
information which determines the appearance of a window is stored. The next
piece of information following the table is the coordinates of the graphics
origin.

The table consists of 68 bytes and is constructed in word (2-byte) format. The
use of the table is shown at the end of the section in a sample program, where
the parameters of the window to be created are placed directly into the window
table and the window then opened with a simple <A HREF="#OPENW">OPENW</A> instruction.

<A HREF="#WINDTAB">WINDTAB</A>, in a similar way to <A HREF="#INTIN">INTIN</A><A HREF="#()">()</A>, etc., can be used as a two-dimensional
array, <A HREF="#WINDTAB">WINDTAB</A><A HREF="#()">()</A><A HREF="#.">.</A> The first <A HREF="#index">index</A> refers to the number of the window (1 to 4,
or 0)<A HREF="#.">.</A> Zero is a special case and refers to the Desktop. The second <A HREF="#index">index</A> is:

    0  Handle
    1  Attributes
    2  x-coordinate
    3  y-coordinate
    4  Width
    5  Height

The Window Parameter table can also be modified by using
<A HREF="#'">'</A><A HREF="#DPOKE">DPOKE</A> <A HREF="#WINDTAB">WINDTAB</A>+offset', the offsets have the following meanings:

    <B>Offset  Description</B>
     0      Window 1: Handle
     2      Window 1: Attributes (see structure below)
     4      Window 1: x-coordinate
     6      Window 1: y-coordinate
     8      Window 1: Width
    10      Window 1: Height
    12-22   Window 2: Handle, Attributes, x, y, w, h
    24-34   Window 3: Handle, Attributes, x, y, w, h
    36-46   Window 4: Handle, Attributes, x, y, w, h
    48-58   Window 0: Handle (-1), Attributes (0), x, y, w, h (Desktop window)
    60-62   Coordinates of the 'join point' of the four windows (<A HREF="#OPENW">OPENW</A> x,y)
    64-66   Origin for graphic instructions (<A HREF="#CLIP_OFFSET">CLIP OFFSET</A> x,y)

The graphic origin is applicable to <A HREF="#AES">AES</A>, <A HREF="#Line-A">Line-A</A>, and direct <A HREF="#VDI">VDI</A> calls but <A HREF="#PUT">PUT</A>,
<A HREF="#GET">GET</A>, and <A HREF="#BITBLT">BITBLT</A> always use the top left corner of the screen as their origin.

The window attribute word is constructed bit by bit, with each set bit denoting
the presence of a particular window component.

    <B>Bit  Component</B>
     0   Window title
     1   Close box (top left)
     2   Full box (top right)
     3   Move line, with which the window can be moved
     4   Information line
     5   Size box (bottom right)
     6   Up arrow
     7   Down arrow
     8   Vertical slider bar (right)
     9   Left arrow
    10   Right arrow
    11   Horizontal slider bar (bottom)

<B>Example:</B>

    <A HREF="#'">'</A> It is also possible to imply <A HREF="#WINDTAB">WINDTAB</A> manipulation
    <A HREF="#'">'</A> using the <A HREF="#OPENW">OPENW</A> #n,x,y,w,h,attr instruction,
    <A HREF="#'">'</A> where with Version 2 only <A HREF="#WINDTAB">WINDTAB</A> was available.
    <A HREF="#'">'</A>
    <A HREF="#OPENW">OPENW</A> #1,100,120,200,70,&HFFF
    <A HREF="#'">'</A>
    <A HREF="#'">'</A> corresponds to
    <A HREF="#'">'</A>
    <A HREF="#DPOKE">DPOKE</A> <A HREF="#WINDTAB">WINDTAB</A>+2,&HFFF
    <A HREF="#DPOKE">DPOKE</A> <A HREF="#WINDTAB">WINDTAB</A>+4,100
    <A HREF="#DPOKE">DPOKE</A> <A HREF="#WINDTAB">WINDTAB</A>+6,120
    <A HREF="#DPOKE">DPOKE</A> <A HREF="#WINDTAB">WINDTAB</A>+8,200
    <A HREF="#DPOKE">DPOKE</A> <A HREF="#WINDTAB">WINDTAB</A>+10,70
    <A HREF="#OPENW">OPENW</A> 1
    <A HREF="#'">'</A>
    <A HREF="#'">'</A> or
    <A HREF="#'">'</A>
    <A HREF="#WINDTAB">WINDTAB</A>(1,1)<A HREF="#=">=</A>&HFFF
    <A HREF="#WINDTAB">WINDTAB</A>(1,2)=100
    <A HREF="#WINDTAB">WINDTAB</A>(1,3)=120
    <A HREF="#WINDTAB">WINDTAB</A>(1,4)=200
    <A HREF="#WINDTAB">WINDTAB</A>(1,5)=70
    <A HREF="#OPENW">OPENW</A> 1

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Three methods for opening a window are shown. This example is not meant to
    be executed.

<B>Memo:</B> The editor has a bug and does not catch negative window numbers.
      The <A HREF="#WINDTAB">WINDTAB</A> structure is 34 words (68 bytes) in size.
      This function has the following limits: <A HREF="#WINDTAB">WINDTAB</A>(0-4,0-5)
      Only the first 30 words (60 bytes) can be read/written with <A HREF="#WINDTAB">WINDTAB</A><A HREF="#()">()</A><A HREF="#.">.</A>

      If you do not use any of the GFA window commands, the first 64 bytes
      (0-63) can be used to store any data you like.
      Example:
        <A HREF="#CHAR">CHAR</A>{<A HREF="#WINDTAB">WINDTAB</A>}<A HREF="#=">=</A>"Test"
        <A HREF="#PRINT">PRINT</A> <A HREF="#CHAR">CHAR</A>{<A HREF="#WINDTAB">WINDTAB</A>}
        <A HREF="#'">'</A> or...
        <A HREF="#BYTE">BYTE</A>{<A HREF="#WINDTAB">WINDTAB</A>}=2
        <A HREF="#PRINT">PRINT</A> <A HREF="#BYTE">BYTE</A>{<A HREF="#WINDTAB">WINDTAB</A>}

      Avoid <A HREF="#OPENW">OPENW</A>, <A HREF="#CLOSEW">CLOSEW</A>, <A HREF="#CLEARW">CLEARW</A>, <A HREF="#FULLW">FULLW</A>, <A HREF="#TITLEW">TITLEW</A>, <A HREF="#INFOW">INFOW</A>, <A HREF="#TOPW">TOPW</A>, <A HREF="#W_HAND">W_HAND</A><A HREF="#()">()</A>, and
      <A HREF="#W_INDEX">W_INDEX</A><A HREF="#()">()</A> or your data could be clobbered.
<HR SIZE=3><H2 ID="Other_Window-related_Commands">Other Window-related Commands</H2>
<A HREF="#RC_INTERSECT">RC_INTERSECT</A><A HREF="#()">()</A>
<A HREF="#RC_COPY">RC_COPY</A>
<A HREF="#ALERT">ALERT</A>
<A HREF="#FILESELECT">FILESELECT</A>
<HR SIZE=3><H2 ID="RC_INTERSECT">RC_INTERSECT</H2>
<B><A HREF="#RC_INTERSECT">RC_INTERSECT</A>(x1,y1,w1,h1,x2,y2,w2,h2)</B>

x1, y1, w1, h1: <A HREF="#iexp">iexp</A>
x2, y2, w2, h2: <A HREF="#ivar">ivar</A>

The function <A HREF="#RC_INTERSECT">RC_INTERSECT</A><A HREF="#()">()</A> (rectangle intersection) can be used to find
whether two rectangles overlap. The rectangles are specified by the coordinates
of the top left corner 'x,y', and the width 'w' and height 'h'<A HREF="#.">.</A>

If the rectangles overlap, then the logical value <A HREF="#TRUE">TRUE</A> (-1) is returned and,
after the function call, x2, y2, w2, and h2 will contain the coordinates and
size of the rectangular area which is common to both rectangles.

If they do not overlap, <A HREF="#FALSE">FALSE</A> (0) is returned and x2, y2, w2, and h2 will
contain the coordinates and size of a rectangle which lies between the two
specified rectangles. In this case, either the width 'w2' or the height 'h2',
or both, will be negative or zero.

This function is normally used for the control of 'Redraws' with GEM windows.

<B>Examples:</B>

    <A HREF="#BOX">BOX</A> 100,100,400,300
    x=200
    y=200
    w=300
    h=150
    <A HREF="#BOX">BOX</A> x,y,x+w,y+h
    <A HREF="#'">'</A>
    <A HREF="#IF">IF</A> <A HREF="#RC_INTERSECT">RC_INTERSECT</A>(100,100,300,200,x,y,w,h)
      <A HREF="#PBOX">PBOX</A> x,y,x+w,y+h
    <A HREF="#ENDIF">ENDIF</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Two rectangles are drawn and the common area is represented in black.

    oldmx=0
    oldmy=0
    <A HREF="#DO">DO</A>
      <A HREF="#MOUSE">MOUSE</A> mx,my,mk
      <A HREF="#IF">IF</A> mx&#60;&#62;oldmx <A HREF="#OR">OR</A> my&#60;&#62;oldmy
        <A HREF="#CLS">CLS</A>
        oldmx=mx
        oldmy=my
        x=120
        y=100
        w=75
        h=75
        <A HREF="#BOX">BOX</A> x,y,x+w,y+h
        <A HREF="#BOX">BOX</A> mx,my,mx+50,my+50
        <A HREF="#PRINT">PRINT</A> <A HREF="#RC_INTERSECT">RC_INTERSECT</A>(mx,my,50,50,x,y,w,h)
        <A HREF="#PBOX">PBOX</A> x,y,x+w,y+h
      <A HREF="#ENDIF">ENDIF</A>
    <A HREF="#LOOP">LOOP</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Two boxes are drawn on the screen, one which can be moved about with the
    mouse. The rectangle returned by the function <A HREF="#RC_INTERSECT">RC_INTERSECT</A><A HREF="#()">()</A> is shown in
    black. The value -1 (<A HREF="#TRUE">TRUE</A>), or 0 (<A HREF="#FALSE">FALSE</A>) is shown in the top left corner of
    the screen, depending on whether or not the moving rectangle overlaps the
    fixed one.

<B>Memo:</B> For compiler options see section <A HREF="#'">'</A><A HREF="#RC_INTERSECT()_Parameters">RC_INTERSECT() Parameters</A>'<A HREF="#.">.</A>
<HR SIZE=3><H2 ID="RC_COPY">RC_COPY</H2>
<B><A HREF="#RC_COPY">RC_COPY</A> s_adr,sx,sy,w,h TO d_adr,dx,dy[,m]</B>

s_adr, sx, sy, w, h, d_adr, dx, dy, m: <A HREF="#iexp">iexp</A>

The instruction <A HREF="#RC_COPY">RC_COPY</A> makes possible the copying of rectangular 'screen'
sections between areas of memory, each of which represents a screen display
which may be sent to the monitor by specifying the screen address appropriately
(see <A HREF="#XBIOS">XBIOS</A>(2))<A HREF="#.">.</A> The parameters s_adr and d_adr contain the starting addresses
of the source and destination screens. The coordinates of the top left corner
and the width and height of the rectangle to be copied should be specified in
sx, sy, w, and h. The coordinates of the top left corner of the destination
rectangle are dx and dy. An optional logical operation may be preformed between
the source and destination rectangles, given by 'm' in the range 0 to 15 (see
<A HREF="#PUT">PUT</A>)<A HREF="#.">.</A> The default value for 'm' is 3 (replace mode).

<B>Example:</B>

    <A HREF="#FOR">FOR</A> r=1 TO 400
      <A HREF="#CIRCLE">CIRCLE</A> 320,200,r
    <A HREF="#NEXT">NEXT</A> r
    <A HREF="#SGET">SGET</A> pic$
    s_adr=V:pic$
    d_adr=<A HREF="#XBIOS">XBIOS</A>(2)
    <A HREF="#'">'</A>
    <A HREF="#FOR">FOR</A> i%=1 TO 1000
      <A HREF="#RC_COPY">RC_COPY</A> s_adr,<A HREF="#RAND">RAND</A>(10)*64,RAND(10)*40,64,40 TO d_adr,RAND(10)*64,RAND(10)*40
    <A HREF="#NEXT">NEXT</A> i%

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> A simple picture is drawn and stored in pic$<A HREF="#.">.</A> <A HREF="#RC_COPY">RC_COPY</A> then copies random
    'screen' sections from pic$ in memory to the current screen memory (given
    by <A HREF="#XBIOS">XBIOS</A>(2))<A HREF="#.">.</A>

<B>Memo:</B> Undocumented feature. If mode is <A HREF="#&">&</A>#62;255 the value is used as an
      op_tab parameter. This is a <A HREF="#Line-A">Line-A</A> call.

      There's no bounds checking on the right and bottom edges of the screen.

vro_cpyfm()<A HREF="#+">+</A>, <A HREF="#Line-A">Line-A</A> BitBlt+
<HR SIZE=3><H2 ID="ALERT">ALERT</H2>
<B><A HREF="#ALERT">ALERT</A> icon,message$,default,button$,choice</B>

icon, default: <A HREF="#iexp">iexp</A>
message$, button$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>
choice: <A HREF="#avar">avar</A>

The command <A HREF="#ALERT">ALERT</A> creates an Alert box. The expression 'icon' determines which
icon is to appear in the box. The following are valid:

    <B>icon  Image</B>
    <A HREF="#-">-</A>---  -------------------------
    0     None


    1     Exclamation mark


    2     Question mark


    3     Stop sign


    <A HREF="#=">=</A><A HREF="#&">&</A>#62;4   See <A HREF="#FORM_ALERT">FORM_ALERT</A><A HREF="#()">()</A>

The text to appear in the box is given by the expression 'message$'<A HREF="#.">.</A> A maximum
of 4 lines is permitted, with a maximum of 30 characters per line, seperated
by 'pipe' (<A HREF="#&#124;">&#124;</A>) characters. Lines which are longer than 30 characters are
truncated.

The expression 'default' specifies which of the box's buttons is to be the one
with a bold border, selectable by pressing Return or Enter. As no more than
three buttons are allowed, 'default' can take a value form 0 to 3, 0 indicating
that there will be no default button and selection can only be made by clicking
with the mouse.

The string expression 'button$' contains the text for the buttons, with a
maximum of 8 characters per button. The individual button are seperated by
'pipe' (<A HREF="#&#124;">&#124;</A>) characters. Buttons which are longer than 8 characters are
truncated.

On exiting from the Alert box, the variable 'choice' contains the number (1 to
3) of the selected button (see <A HREF="#FORM_ALERT">FORM_ALERT</A><A HREF="#()">()</A>)<A HREF="#.">.</A>

<B>Example:</B>

    <A HREF="#ALERT">ALERT</A> 1,"Pick a&#124;button",1,"Left&#124;Right",a%
    <A HREF="#ALERT">ALERT</A> 0,"You pressed&#124;button "<A HREF="#+">+</A><A HREF="#STR$">STR$</A>(a%),0,"Ok",a%

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> A box with two buttons appears. After the selection has been made a second
    box materialises stating which button in the first box was chosen. The
    second Alert box has no icon and no default button.

<B>Memo:</B> Values larger than 3 for parameter 'icon' do not work.
      To use the newer alert icons one must call <A HREF="#FORM_ALERT">FORM_ALERT</A><A HREF="#()">()</A> instead. <A HREF="#ALERT">ALERT</A>
      can be fatal on some <A HREF="#AES">AES</A> versions if the default button exceeds the
      actual button count.

      <A HREF="#ALERT">ALERT</A> doesn't throw any errors for anything out of range.
      It also crops all strings that exceed the set limits.

form_alert()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="FILESELECT">FILESELECT</H2>
<B><A HREF="#FILESELECT">FILESELECT</A> [#title$,]path$,default$,name$</B>

title$, path$, default$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>
name$<A HREF="#:">:</A> <A HREF="#svar">svar</A>

This instruction causes a File Select box to be created on the screen, enabling
the user-friendly selection of a file name.

The expression 'title$' can be a maximum of 30 characters and allows a header
to be placed in the File Select box <A HREF="#-">-</A> available from TOS 1.4 onwards. In the
expression 'path$' the initial drive- and path-name should be specified. If no
drive is specified, then the current drive is assumed. 'default$' contains the
name of the file which will appear as the current choice. This can be selected
by pressing Return, edited or deleted (by pressing ESCape)<A HREF="#.">.</A> After exiting from
the File Select box, the name of the selected file will be found in the string
'name$'<A HREF="#.">.</A> If the Cancel button was selected, then 'name$' will contain a null
string ("")<A HREF="#.">.</A>

The format of path$, default$, and name$ conform to the conventions of the
Hierarchical Filing system, described in <A HREF="#'">'</A><A HREF="#Chapter__6_-_Input_and_Output">Chapter  6 - Input and Output</A>',
section <A HREF="#'">'</A><A HREF="#File_Management">File Management</A>'<A HREF="#.">.</A>

See also <A HREF="#FSEL_INPUT">FSEL_INPUT</A><A HREF="#()">()</A><A HREF="#.">.</A>

<B>Example:</B>

    <A HREF="#DO">DO</A>
      <A HREF="#FILESELECT">FILESELECT</A> "A:\<A HREF="#*">*</A>.PRG","GFABASIC.PRG",name$
      <A HREF="#IF">IF</A> name$<A HREF="#=">=</A>""
        <A HREF="#PRINT">PRINT</A> "You clicked the Cancel button"
      <A HREF="#ELSE_IF">ELSE IF</A> <A HREF="#RIGHT$">RIGHT$</A>(name$)<A HREF="#=">=</A>"\"
        <A HREF="#PRINT">PRINT</A> "You clicked the Ok button without naming a file"
      <A HREF="#ELSE">ELSE</A>
        <A HREF="#PRINT">PRINT</A> "You have selected the file ";name$
      <A HREF="#ENDIF">ENDIF</A>
    <A HREF="#LOOP">LOOP</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> A File Select box appears and responds to the choice made by the user.

<B>Note:</B> The parameter 'title$' is optional and if left out the older File
      Select routine is called which does not allow a user-defined header.

<B>Memo:</B> Avoid using the built in <A HREF="#FILESELECT">FILESELECT</A> command as it only buffers
      older 32k ST video modes properly. If you want your application to
      function properly in all video modes call <A HREF="#FSEL_INPUT">FSEL_INPUT</A><A HREF="#()">()</A> via the <A HREF="#AES">AES</A>
      directly. Your program might receive an <A HREF="#AES">AES</A> redraw message when calling
      <A HREF="#FSEL_INPUT">FSEL_INPUT</A><A HREF="#()">()</A><A HREF="#.">.</A>

      Does not handle long file names correctly.
      The path and file name are both forced to upper case.
      Paths over 150 characters will be truncated.
      File names over 12 characters will be ignored.
      Internal TOS v1.4 check is incorrect, it actually checks for v1.04.

fsel_input()<A HREF="#+">+</A>, <A HREF="#fsel_exinput">fsel_exinput</A>()+
<HR SIZE=3><H2 ID="Chapter_10_-_System_Routines">Chapter 10 - System Routines</H2>
<A NAME="System_Routines"></A><A HREF="#BIOS">BIOS</A><A HREF="#()">()</A>, <A HREF="#XBIOS">XBIOS</A>(), <A HREF="#GEMDOS">GEMDOS</A>()
<A HREF="#W:">W:</A>, <A HREF="#L:">L:</A>
<A HREF="#Cookie_Jar">Cookie Jar</A>
<HR SIZE=3><H2 ID="BIOS,_XBIOS,_and_GEMDOS">BIOS, XBIOS, and GEMDOS</H2>
<A NAME="BIOS"></A><A NAME="XBIOS"></A><A NAME="GEMDOS"></A><B><A HREF="#BIOS">BIOS</A>(n[,x,y,<A HREF="#.">.</A>..])
<A HREF="#XBIOS">XBIOS</A>(n[,x,y,<A HREF="#.">.</A>..])
<A HREF="#GEMDOS">GEMDOS</A>(n[,x,y,<A HREF="#.">.</A>..])</B>

n, x, y: <A HREF="#iexp">iexp</A>

These functions are used to call <A HREF="#BIOS">BIOS</A><A HREF="#()">()</A>, <A HREF="#XBIOS">XBIOS</A>(), and <A HREF="#GEMDOS">GEMDOS</A>() routines, in
each case the optional parameter list is passed to the function number n. In
order to be able to pass the parameters in the correct variable size, they can
be prefixed with <A HREF="#W:">W:</A> or <A HREF="#L:">L:</A>, to denote word (16-bit) and longword (32-bit) sized
values respectively.

The number and meaning of the parameters depends, as does the returned value,
on the system routine being called. (See also <A HREF="#Appendix">Appendix</A>.)

<B>Examples:</B>

    <A HREF="#IF">IF</A> <A HREF="#GEMDOS">GEMDOS</A>(17)
      <A HREF="#PRINT">PRINT</A> "Printer ready"
    <A HREF="#ELSE">ELSE</A>
      <A HREF="#PRINT">PRINT</A> "Printer not ready"
    <A HREF="#ENDIF">ENDIF</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Checks if the printer is ready to receive data through the parallel
    interface and reports the status as a logical (<A HREF="#TRUE">TRUE</A> or <A HREF="#FALSE">FALSE</A>) value.

    <A HREF="#REPEAT">REPEAT</A>
    <A HREF="#UNTIL">UNTIL</A> <A HREF="#BIOS">BIOS</A>(11,-1) <A HREF="#AND">AND</A> 4

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Waits until the Control key is pressed. <A HREF="#BIOS">BIOS</A>(11,-1) reports on the current
    status of the keyboard 'shift' keys:

    <B>Bit  Key</B>
    0    Right shift
    1    Left shift
    2    Control
    3    Alternate
    4    Caps Lock

    <A HREF="#CIRCLE">CIRCLE</A> 320,200,180
    <A HREF="#PAUSE">PAUSE</A> 30
    <A HREF="#BMOVE">BMOVE</A> <A HREF="#XBIOS">XBIOS</A>(2),XBIOS(2)+16000,16000

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Draws a circle and copies its upper half to the lower part of the screen.
    <A HREF="#XBIOS">XBIOS</A>(2) returns the address at which the physical screen memory begins.

<B>Memo:</B> <A HREF="#GEMDOS">GEMDOS</A><A HREF="#()">()</A> functions that do not exist always return -32.
      <A HREF="#XBIOS">XBIOS</A><A HREF="#()">()</A> functions that do not exist seem to return the opcode.
        This is not very reliable for detecting invalid calls.
      <A HREF="#BIOS">BIOS</A><A HREF="#()">()</A> functions that do not exist seem to return the opcode.
        This is not very reliable for detecting invalid calls.
        However, under MiNT the return value seems to be -32.

      Internally, the Editor uses d7 to save and restore the stack during
      these system calls. If d7 is altered by a custom trap handler the Editor
      will crash. UNSQUISH.PRG does this with two custom calls. In my opinion
      DC Squish II is to blame here as it breaks the most basic OS rules.
      The compiler however works differently and the same call won't crash.

      Clean way to get <A HREF="#Cookie_Jar">Cookie Jar</A> pointer:
        <A HREF="#LPEEK">LPEEK</A>(&H5A0) <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> <A HREF="#BIOS">BIOS</A>(5,W:SHR&(&H5A0,2),L:TRUE)
        This only works for addresses divisible by 4.

<A HREF="#BIOS">BIOS</A><A HREF="#()">()</A><A HREF="#+">+</A>, <A HREF="#XBIOS">XBIOS</A>()+, <A HREF="#GEMDOS">GEMDOS</A>()+
<HR SIZE=3><H2 ID="W:">W:</H2>
<A NAME="L:"></A><B>W:x
L:x</B>

x: <A HREF="#iexp">iexp</A>

These two functions enable the user to pass numerical expressions to Operating
System functions and C-routines as either word (2-byte, <A HREF="#W:">W:</A>) or longword
(4-byte, <A HREF="#L:">L:</A>)<A HREF="#.">.</A> By default the word format is used.

<B>Example:</B>

    <A HREF="#DIM">DIM</A> screen_2&#124;(32255)
    phys_base%<A HREF="#=">=</A><A HREF="#XBIOS">XBIOS</A>(2)
    old_screen%=phys_base%
    log_base%=V:screen_2&#124;(0)+255 <A HREF="#AND">AND</A> &HFFFFFF00
    <A HREF="#~">~</A><A HREF="#XBIOS">XBIOS</A>(5,L:log_base%,L:phys_base%,-1)
    <A HREF="#SWAP">SWAP</A> log_base%,phys_base%
    <A HREF="#REPEAT">REPEAT</A>
      <A HREF="#IF">IF</A> <A HREF="#MOUSEK">MOUSEK</A>=1
        <A HREF="#~">~</A><A HREF="#XBIOS">XBIOS</A>(5,L:log_base%,L:phys_base%,-1)
        <A HREF="#SWAP">SWAP</A> log_base%,phys_base%
        <A HREF="#REPEAT">REPEAT</A>
        <A HREF="#UNTIL">UNTIL</A> <A HREF="#MOUSEK">MOUSEK</A>=0
      <A HREF="#ENDIF">ENDIF</A>
      <A HREF="#PLOT">PLOT</A> <A HREF="#MOUSEX">MOUSEX</A>,<A HREF="#MOUSEY">MOUSEY</A>
    <A HREF="#UNTIL">UNTIL</A> <A HREF="#MOUSEK">MOUSEK</A>=2
    <A HREF="#~">~</A><A HREF="#XBIOS">XBIOS</A>(5,L:old_screen%,L:old_screen%,-1)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> <A HREF="#XBIOS">XBIOS</A>(5) is used to switch between two display screens each time the left
    mouse button is pressed. Moving the mouse causes points to be plotted on
    the screen which is not currently visible. Pressing the right mouse button
    terminates the program.
<HR SIZE=3><H2 ID="Line-A_Calls">Line-A Calls</H2>
<A NAME="Line-A"></A><A NAME="Line-A_calls"></A><A NAME="LINE-A"></A><A HREF="#ACLIP">ACLIP</A>
<A HREF="#PSET">PSET</A>, <A HREF="#PTST">PTST</A><A HREF="#()">()</A>
<A HREF="#ALINE">ALINE</A>, <A HREF="#HLINE">HLINE</A>
<A HREF="#ARECT">ARECT</A>
<A HREF="#APOLY">APOLY</A>
<A HREF="#ACHAR">ACHAR</A>, <A HREF="#ATEXT">ATEXT</A>
<A HREF="#BITBLT_adr%">BITBLT adr%</A>, <A HREF="#BITBLT_x%()">BITBLT x%()</A>
<A HREF="#L~A">L~A</A>

In the following section a group of instructions are discussed which correspond
in principle to instuctions that have already been presented in the graphics
chapter. The output is substantially quicker, however a slightly different
syntax is used. For <A HREF="#Line-A">Line-A</A> graphics, clipping should always be switch on (with
<A HREF="#ACLIP">ACLIP</A>), since areas of memory can be overwritten by a line leaving the screen
area, for example. Otherwise the clipping area is that set by the last used
graphics command (<A HREF="#AES">AES</A> or <A HREF="#VDI">VDI</A>), for example <A HREF="#OPENW">OPENW</A>, <A HREF="#FILESELECT">FILESELECT</A>, <A HREF="#ALERT">ALERT</A>, etc.

A <A HREF="#VDI">VDI</A> call changes the <A HREF="#ACLIP">ACLIP</A> setting previously set with ACLIP. <A HREF="#Line-A_calls">Line-A calls</A>
are independent of the <A HREF="#VDI">VDI</A> DEFxxx commands.

<B>Note:</B> The colors specified in the <A HREF="#Line-A">Line-A</A> routines correspond to the
      hardware color register numbers (as used by <A HREF="#SETCOLOR">SETCOLOR</A>) and <A HREF="#NOT">NOT</A> to the
      numbers used by the <A HREF="#VDI">VDI</A> (<A HREF="#COLOR">COLOR</A>)<A HREF="#.">.</A> They convert as follows:

VDI:    00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
Line-A: 00 15 01 02 04 06 03 05 07 08 09 10 12 14 11 13

Line-A: 00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
VDI:    00 02 03 06 04 07 05 08 09 10 11 14 12 15 13 01

<B>Memo:</B> Do not use any <A HREF="#Line-A_calls">Line-A calls</A><A HREF="#!">!</A>  Your application will surely fail on
      different computer models if you do use <A HREF="#Line-A_calls">Line-A calls</A><A HREF="#.">.</A> If you don't want
      your application to run on all systems or don't care then you can use the
      <A HREF="#Line-A">Line-A</A> calls/variables.

      Opcode Function           GFA command
      <A HREF="#-">-</A>----- ------------------ --------------------------------------
      $A000  Initialization     done automatically by the start-up code
      $A001  Put pixel          <A HREF="#PSET">PSET</A>
      $A002  Get pixel          <A HREF="#PTST">PTST</A><A HREF="#()">()</A>
      $A003  Arbitrary line     <A HREF="#ALINE">ALINE</A>
      $A004  Horizontal line    <A HREF="#HLINE">HLINE</A>
      $A005  Filled rectangle   <A HREF="#ARECT">ARECT</A>
      $A006  Filled polygon     <A HREF="#APOLY">APOLY</A>
      $A007  Bit block transfer <A HREF="#GET">GET</A>, <A HREF="#PUT">PUT</A>, <A HREF="#BITBLT">BITBLT</A>, <A HREF="#RC_COPY">RC_COPY</A>
      $A008  Text block         <A HREF="#ACHAR">ACHAR</A>, <A HREF="#ATEXT">ATEXT</A>
      $A009  Show mouse         <A HREF="#SHOWM">SHOWM</A>
      $A00A  Hide mouse         <A HREF="#HIDEM">HIDEM</A>
      $A00B  Transform mouse    n/a
      $A00C  Undraw sprite      <A HREF="#SPRITE">SPRITE</A>
      $A00D  Draw sprite        <A HREF="#SPRITE">SPRITE</A>
      $A00E  Copy raster        n/a
      $A00F  Seedfill           n/a

<A HREF="#Line-A">Line-A</A><A HREF="#+">+</A>, <A HREF="#Line-A_Variable_Table">Line-A Variable Table</A>+, Line-A Function Reference+
<HR SIZE=3><H2 ID="ACLIP">ACLIP</H2>
<B><A HREF="#ACLIP">ACLIP</A> flag,xmin,ymin,xmax,ymax</B>

flag, xmin, ymin, xmax, ymax: <A HREF="#iexp">iexp</A>

This instruction makes it possible to define a 'clipping' rectangle, to which
<A HREF="#Line-A">Line-A</A> screen output will be limited. The coordinates of the top left and
bottom right corners of the Clipping rectangle are given by xmin, ymin, xmax,
and ymax. If 'flag' is given a non-zero value the clipping is active, otherwise
(if flag=0) it is switched off. <A HREF="#ACLIP">ACLIP</A> is not valid (unfortunately) for <A HREF="#PSET">PSET</A>,
<A HREF="#PTST">PTST</A><A HREF="#()">()</A>, <A HREF="#ALINE">ALINE</A>, <A HREF="#HLINE">HLINE</A>, and <A HREF="#BITBLT">BITBLT</A><A HREF="#.">.</A>

<B>Memo:</B> This is not really a <A HREF="#Line-A">Line-A</A> function per say.
      It simply writes the parameters into the <A HREF="#Line-A">Line-A</A> variables.

      <A HREF="#ACLIP">ACLIP</A> <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> <A HREF="#CLIP">CLIP</A>, XMINCL, YMINCL, XMAXCL, YMAXCL (<A HREF="#Line-A">Line-A</A> variables)

<A HREF="#Line-A_Variable_Table">Line-A Variable Table</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="PSET">PSET</H2>
<B><A HREF="#PSET">PSET</A> x,y,f</B>

x, y, f: <A HREF="#iexp">iexp</A>

<A HREF="#PSET">PSET</A> corresponds to the <A HREF="#PLOT">PLOT</A> command, and will set the point x,y to color f,
which can take values from 0 to 15, depending on the current screen resolution.

<B>Example:</B>

    <A HREF="#FOR">FOR</A> x%=0 to 15
      <A HREF="#FOR">FOR</A> y%=0 to 100 <A HREF="#STEP">STEP</A> 2
        <A HREF="#PSET">PSET</A> x%,y%,x%
      <A HREF="#NEXT">NEXT</A> y%
    <A HREF="#NEXT">NEXT</A> x%

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Draws vertical dotted lines in the 15 colors.

<A HREF="#Line-A">Line-A</A> Plot Pixel+
<HR SIZE=3><H2 ID="PTST">PTST</H2>
<B><A HREF="#PTST">PTST</A>(x,y)</B>

x, y: <A HREF="#iexp">iexp</A>

The function <A HREF="#PTST">PTST</A><A HREF="#()">()</A> corresponds to the function <A HREF="#POINT">POINT</A>()<A HREF="#.">.</A> It returns the color
of the pixel at screen position x,y.

<B>Example:</B>

    <A HREF="#PSET">PSET</A> 100,100,6
    x=<A HREF="#PTST">PTST</A>(200,100)
    <A HREF="#PRINT">PRINT</A> x,<A HREF="#PTST">PTST</A>(100,100)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Prints the colors of the pixels at screen positions (200,100) and
    (100,100)<A HREF="#.">.</A>

<A HREF="#Line-A">Line-A</A> Get Pixel+
<HR SIZE=3><H2 ID="ALINE">ALINE</H2>
<B><A HREF="#ALINE">ALINE</A> x1,y1,x2,y2,f,ls,m</B>

x1, y1, x2, y2, f, ls, m: <A HREF="#iexp">iexp</A>

<A HREF="#ALINE">ALINE</A> corresponds to the command <A HREF="#LINE">LINE</A>, where (x1,y1) and (x2,y2) are the
coordinates of the end points of the line. The expression f contains the color,
which, depending on the current screen resolution, takes values from 0 to 15.
'ls' contains 16 bits of information for the desired style of line (solid,
dashed, dotted, etc.). Each set bit corresponds to one point to be plotted.

The paramter m determines the graphic mode and can take values from 0 to 3:

    <B>m  Mode</B>
    0  Replace
    1  Transparent
    2  Xor
    3  Reverse Transparent

<B>Example:</B>

    ym%<A HREF="#=">=</A><A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>-4}-1
    <A HREF="#FOR">FOR</A> i%=0 to 255
      style%=256*i%+i%
      <A HREF="#ALINE">ALINE</A> i%,0,i%,ym%,1,style%,0
    <A HREF="#NEXT">NEXT</A> i%

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Draws vertical lines of varying dottedness extending from the top to the
    bottom of the screen. The term <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>-4} returns the maximum y coordinate
    of the screen, this being stored four bytes before the beginning of the
    <A HREF="#Line-A_Variable_Table">Line-A Variable Table</A> (which starts at the address <A HREF="#L~A">L~A</A>)<A HREF="#.">.</A>

<A HREF="#Line-A">Line-A</A> Arbitrary Line+
<HR SIZE=3><H2 ID="HLINE">HLINE</H2>
<B><A HREF="#HLINE">HLINE</A> x1,y,x2,f,m,addr,num_pattern</B>

x1, y, x2, f, m, addr, num_pattern: <A HREF="#iexp">iexp</A>

<A HREF="#HLINE">HLINE</A> is similar to the <A HREF="#ALINE">ALINE</A> command, but only horizontal lines can be drawn.
x1 and x2 contain the x-coordinates of the line end points, and y the common
y-coordinate. The expression f contains the color which, depending on the
current screen resolution, takes values from 0 to 15. The parameter m
determines the graphics mode as with <A HREF="#ALINE">ALINE</A><A HREF="#.">.</A>

addr is the address of a block of memory which contains bit information for
several line styles (each 16 bits)<A HREF="#.">.</A> Which style is used for a given line
depends on both the y-coordinate and the parameter num_pattern. They are ANDed
together and the resulting number used as an <A HREF="#index">index</A> to the style table. Thus
num_pattern should generally be one smaller than the power of two (0, 1, 3, 7,
15, etc.), giving the effect that, with num_pattern=7, the first eight styles
will be used sequentially as the y-coordinate moves down the screen. If
num_pattern=3, one of the first four styles will be used, depending on the
y-coordinate.

<B>Example:</B>

    <A HREF="#ACLIP">ACLIP</A> 1,0,0,639,399
    <A HREF="#'">'</A>
    pattern%<A HREF="#=">=</A>&X11111111111111111010101010101010
    x%=V:pattern%
    <A HREF="#'">'</A>
    <A HREF="#FOR">FOR</A> i%=0 to 199
      <A HREF="#HLINE">HLINE</A> 0,i%,639,1,0,z%,1
    <A HREF="#NEXT">NEXT</A> i%

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Two 16-bit line patterns are put into the variable pattern%<A HREF="#.">.</A> The last
    parameter is 1 (implying 2 possible styles)<A HREF="#.">.</A> The lines drawn then use the
    two 16-bit line patterns in pattern% alternately.

<B>Memo:</B> Internally <A HREF="#Line-A">Line-A</A> offset MFILL is set to <A HREF="#FALSE">FALSE</A><A HREF="#.">.</A>
      Thus only single plane patterns can be used.

<A HREF="#Line-A">Line-A</A> Horizontal Line+
<HR SIZE=3><H2 ID="ARECT">ARECT</H2>
<B><A HREF="#ARECT">ARECT</A> x1,y1,x2,y2,f,m,addr,num_pattern</B>

x1, y1, x2, y2, f, m, addr, num_pattern: <A HREF="#iexp">iexp</A>

<A HREF="#ARECT">ARECT</A> corresponds to <A HREF="#PBOX">PBOX</A><A HREF="#.">.</A> (x1,y1) and (x2,y2) are the coordinates of the two
opposite corners of the rectangle. The parameters f, m, addr, and num_pattern
have the same meaning as for <A HREF="#HLINE">HLINE</A><A HREF="#.">.</A>

<B>Example:</B>

    <A HREF="#ACLIP">ACLIP</A> 1,0,0,639,399
    <A HREF="#DIM">DIM</A> pattern&(1)
    <A HREF="#'">'</A>
    pattern&(0)<A HREF="#=">=</A>-21846
    pattern&(1)=21845
    <A HREF="#'">'</A>
    pattern_adr%=V:pattern&(0)
    <A HREF="#ARECT">ARECT</A> 100,100,200,200,1,0,pattern_adr%,1

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> A rectangle filled with a checker-board pattern (equivalent to using <A HREF="#PBOX">PBOX</A>
    after <A HREF="#DEFFILL">DEFFILL</A> 2,2,4 except that no border is drawn)<A HREF="#.">.</A>

<B>Memo:</B> Internally <A HREF="#Line-A">Line-A</A> offset MFILL is set to <A HREF="#FALSE">FALSE</A><A HREF="#.">.</A>
      Thus only single plane patterns can be used.

<A HREF="#Line-A">Line-A</A> Filled Rectangle+
<HR SIZE=3><H2 ID="APOLY">APOLY</H2>
<B><A HREF="#APOLY">APOLY</A> adr_pnt,num_pnt,y0 to y1,f,m,addr,num_pattern</B>

adr_pnt, num_pnt, y0, y1, f, m, addr, num_pattern: <A HREF="#iexp">iexp</A>

<A HREF="#APOLY">APOLY</A> is similar to the <A HREF="#POLYFILL">POLYFILL</A> command. It draws an (invisible) sequence of
joined lines, with 'num_pnt' corners and fills the resulting area with a user
defined pattern. 'adr_pnt' is the address of the array which contains
alternating x- and y-coordinates of the corner points. The parameter 'num_pnt'
contains the number of corner points. y0 and y1 specify the lowest and highest
parts of the screen where filling can take place <A HREF="#-">-</A> it is like a vertical-only
clipping facility. The parameters f, m, addr, and num_pattern correspond to
those of <A HREF="#HLINE">HLINE</A><A HREF="#.">.</A>

<B>Example:</B>

    <A HREF="#DIM">DIM</A> x&(9),pattern&(1)
    <A HREF="#FOR">FOR</A> i%=0 to 7
      x&(i%)<A HREF="#=">=</A><A HREF="#RAND">RAND</A>(100)
    <A HREF="#NEXT">NEXT</A> i%
    x&(8)=x&(0)
    x&(9)=x&(1)
    <A HREF="#'">'</A>
    adr_corners%=V:x&(0)
    pattern&(0)<A HREF="#=">=</A>-1
    adr_pattern%=V:pattern&(0)
    <A HREF="#'">'</A>
    <A HREF="#ACLIP">ACLIP</A> 1,0,0,200,200
    <A HREF="#APOLY">APOLY</A> adr_corners%,4,0 TO 100,1,1,adr_pattern%,0

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Draws a random filled quadrilateral.

<B>Memo:</B> Internally <A HREF="#APOLY">APOLY</A> does not set <A HREF="#Line-A">Line-A</A> offset MFILL even though
      the documentation states the pattern parameters are identical to <A HREF="#HLINE">HLINE</A><A HREF="#.">.</A>
      Internally <A HREF="#HLINE">HLINE</A> always sets <A HREF="#Line-A">Line-A</A> offset MFILL.
        <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+52}=0 ;mfill (mono)

<A HREF="#Line-A">Line-A</A> Filled Polygon+
<HR SIZE=3><H2 ID="ACHAR">ACHAR</H2>
<B><A HREF="#ACHAR">ACHAR</A> code,x,y,font,style,angle</B>

code, x, y, font, style, angle: <A HREF="#iexp">iexp</A>

By means of <A HREF="#ACHAR">ACHAR</A> an individual character with the <A HREF="#ASCII">ASCII</A> value 'code' can be
displayed at the point with graphics coordinates (x,y)<A HREF="#.">.</A> The numerical
expression 'font' can except values between 0 and 2 as follows:

    <B>Font  Size</B>
    0     6x6  (Icon font)
    1     8x8  (Normal color font)
    2     8x16 (Normal monochrome font)

Larger values for 'font' are taken to be Font-Header addresses. The font must
be present in the format into which it is converted by GDOS on loading, that is
in the Motorola format High-byte before Low-byte.

Text 'style' (bold, light, etc: 0 to 31) and output 'angle' (0, 900, 1800,
2700) can be specified as for <A HREF="#TEXT">TEXT</A> with <A HREF="#DEFTEXT">DEFTEXT</A><A HREF="#.">.</A> In contrast to these TEXT
commands, the x and y coordinates refer to the top left corner of the
character, not the bottom left corner.

<B>Memo:</B> This command will not render the <U>underlined</U> (bit 3) effect.
      For some odd reason it is ignored by this <A HREF="#Line-A">Line-A</A> call.
      This is not a bug in <A HREF="#GFA-Basic">GFA-Basic</A><A HREF="#.">.</A>

<A HREF="#Line-A">Line-A</A> TextBlt+
<HR SIZE=3><H2 ID="ATEXT">ATEXT</H2>
<B><A HREF="#ATEXT">ATEXT</A> x,y,font,s$</B>

x, y, font: <A HREF="#iexp">iexp</A>
s$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>

The command <A HREF="#ATEXT">ATEXT</A> outputs character strings at arbitrary screen positions but,
unlike with <A HREF="#ACHAR">ACHAR</A>, no character style or output angle can be specified. The
parameters x, y, and font are the same as for <A HREF="#ACHAR">ACHAR</A><A HREF="#.">.</A>

<B>Example:</B>

    <A HREF="#OPENW">OPENW</A> 0                    !Protect the top line from overwriting
    <A HREF="#EVERY">EVERY</A> 400 <A HREF="#GOSUB">GOSUB</A> a_clock    !Every 2 seconds call a_clock
    <A HREF="#FOR">FOR</A> i%=1 TO 100000
      <A HREF="#PRINT_USING">PRINT USING</A> "<A HREF="##">#</A>#####",i%<A HREF="#;">;</A> !Display numbers
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#'">'</A>
    <A HREF="#PROCEDURE">PROCEDURE</A> a_clock
      <A HREF="#ACLIP">ACLIP</A> 1,20,0,120,15      !Switch clipping on,
      <A HREF="#'">'</A>                         oterwise it will remain as set by <A HREF="#OPENW">OPENW</A> 0,
      <A HREF="#'">'</A>                         i.e. nothing will be seen
      <A HREF="#ATEXT">ATEXT</A> 20,20,2,<A HREF="#TIME$">TIME$</A>      !Display the time
    <A HREF="#RETURN">RETURN</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Numbers are printed continuously, but every 2 seconds a time display is
    updated on the top line.

<A HREF="#Line-A">Line-A</A> TextBlt+
<HR SIZE=3><H2 ID="BITBLT_adr%">BITBLT adr%</H2>
<A NAME="BITBLT_x%()"></A><B><A HREF="#BITBLT_adr%">BITBLT adr%</A>
<A HREF="#BITBLT_x%()">BITBLT x%()</A></B>

adr%<A HREF="#:">:</A> <A HREF="#iexp">iexp</A>
x%()<A HREF="#:">:</A> four byte integer array

The command <A HREF="#BITBLT">BITBLT</A> calls the <A HREF="#Line-A">Line-A</A> routine of the same name, where as the
command with three parameter arrays calls a <A HREF="#VDI">VDI</A>-routine. In the command
variation for which an address is given as a parameter, a 76 byte long table
must start at this address. The meaning of the values in this storage area can
be taken from the table that follows. The offset distances of the elements from
the start of the table are shown in the column 'offset'<A HREF="#.">.</A>

In the command variation with the one four byte-Integer array, this array must
have at least 23 elements, a specified parameter standing in each. Which
parameter must stand in which array element can be seen in the column <A HREF="#'">'</A><A HREF="#index">index</A>'
in the following table.

The parameters marked with a star are affected by the routine, therefore one
should normally work with the command variant which uses an array parameter,
since a copy of the array is used by the <A HREF="#BITBLT">BITBLT</A> routine, the array itself will
not be altered. In contrast, the table elements which were given by the passing
of an address will be changed.

<B>Name        Index  Offset  Meaning</B>
B_WD        00     00      Screen width in pixels
B_HT        01     02      Screen height in pixels
PLANE_CT <A HREF="#*">*</A>  02     04      Number of bit-planes
FG_COL   <A HREF="#*">*</A>  03     06      Foreground color
BG_COL   <A HREF="#*">*</A>  04     08      Background color
OP_TAB      05     10      Logical 'put' mode 0 to 15 (see <A HREF="#PUT">PUT</A>)
S_XMIN      06     14      x offset for source
S_YMIN      07     16      y offset for source
S_FORM      08     18      Address of the source screen
S_NXWD      09     22      Offset to the next word of the same bit-plane
S_NXLN      10     24      Offset to the next line of the source screen
S_NXPL      11     26      Offset to the next bit-plane (always 2)
D_XMIN      12     28      x offset for destination
D_YMIN      13     30      y offset for destination
D_FORM      14     32      Address ofthe destination screen
D_NXWD      15     36      Offset to the next word of the same bit-plane
D_NXLN      16     38      Offset to the next line of the destination screen
D_NXPL      17     40      Offset to the next bit-plane (always 2)
P_ADDR      18     42      Pointer to fill pattern table (0=no pattern,
                           Source ANDed with pattern before moving)
P_NXLN      19     46      Offset to the next line of the mask
P_NXPL      20     48      Offset to the next plane of the pattern
P_MASK      21     50      Mask as for <A HREF="#HLINE">HLINE</A>
SPACE    <A HREF="#*">*</A>  22     52      Next 24 bytes are workspace for the Blitter

<B>Examples:</B>

    <A HREF="#DIM">DIM</A> x%(1000)
    <A HREF="#'">'</A>
    <A HREF="#FOR">FOR</A> i%=0 TO 639 <A HREF="#STEP">STEP</A> 8
      <A HREF="#LINE">LINE</A> i%,0,639,399
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#'">'</A>
    <A HREF="#GET">GET</A> 0,0,639,399,a$
    mirrorput(0,0,a$)
    <A HREF="#'">'</A>
    <A HREF="#PROCEDURE">PROCEDURE</A> mirrorput(x%,y%,<A HREF="#VAR">VAR</A> x$)
      <A HREF="#IF">IF</A> <A HREF="#LEN">LEN</A>(x$)<A HREF="#&">&</A>#62;6 <A HREF="#!">!</A> Only do it if something present
        xx%=V:x%(0)
        a%=V:x$
        b%<A HREF="#=">=</A><A HREF="#INT">INT</A>{a%}
        h%<A HREF="#=">=</A><A HREF="#INT">INT</A>{a%+2}
        <A HREF="#'">'</A>
        <A HREF="#INT">INT</A>{xx%}=1
        <A HREF="#INT">INT</A>{xx%+2}=h%
        <A HREF="#INT">INT</A>{xx%+4}=1
        <A HREF="#INT">INT</A>{xx%+6}=1
        <A HREF="#INT">INT</A>{xx%+8}=0
        {xx%+10}<A HREF="#=">=</A>&H3030303
        <A HREF="#INT">INT</A>{xx%+14}=9999
        <A HREF="#INT">INT</A>{xx%+16}=0
        {xx%+18}=a%+6
        <A HREF="#INT">INT</A>{xx%+22}=2
        <A HREF="#INT">INT</A>{xx%+24}<A HREF="#=">=</A><A HREF="#SHR">SHR</A>(b%+16,4)*2
        <A HREF="#INT">INT</A>{xx%+26}=2
        <A HREF="#INT">INT</A>{xx%+28}=9999
        <A HREF="#INT">INT</A>{xx%+30}=0
        {xx%+32}<A HREF="#=">=</A><A HREF="#XBIOS">XBIOS</A>(3)
        <A HREF="#INT">INT</A>{xx%+36}=2
        <A HREF="#INT">INT</A>{xx%+38}=80
        <A HREF="#INT">INT</A>{xx%+40}=2
        {xx%+42}=0    <A HREF="#!">!</A> p_addr
        <A HREF="#INT">INT</A>{xx%+46}=0 <A HREF="#!">!</A> p_nxln
        <A HREF="#INT">INT</A>{xx%+48}=0 <A HREF="#!">!</A> p_nxpl
        <A HREF="#INT">INT</A>{xx%+50}=0 <A HREF="#!">!</A> p_mask
        <A HREF="#'">'</A>
        <A HREF="#ABSOLUTE">ABSOLUTE</A> i&,xx%+14
        <A HREF="#ABSOLUTE">ABSOLUTE</A> di&,xx%+28
        <A HREF="#'">'</A>
        <A HREF="#FOR">FOR</A> i&=0 TO b%
          <A HREF="#INT">INT</A>{xx%+4}=1
          di&<A HREF="#=">=</A><A HREF="#SUB">SUB</A>(639,i&)
          <A HREF="#BITBLT">BITBLT</A> xx%
        <A HREF="#NEXT">NEXT</A> i&
        <A HREF="#'">'</A>
      <A HREF="#ENDIF">ENDIF</A>
    <A HREF="#RETURN">RETURN</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> An example of <A HREF="#BITBLT_adr%">BITBLT adr%</A><A HREF="#.">.</A>

    <A HREF="#DIM">DIM</A> x%(1000)
    <A HREF="#'">'</A>
    <A HREF="#FOR">FOR</A> i%=0 TO 639 <A HREF="#STEP">STEP</A> 8
      <A HREF="#LINE">LINE</A> i%,0,639,399
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#'">'</A>
    <A HREF="#GET">GET</A> 0,0,639,399,a$
    mirrorput(0,0,a$)
    <A HREF="#'">'</A>
    <A HREF="#PROCEDURE">PROCEDURE</A> mirrorput(x%,y%,<A HREF="#VAR">VAR</A> x$)
      <A HREF="#IF">IF</A> <A HREF="#LEN">LEN</A>(x$)<A HREF="#&">&</A>#62;6 <A HREF="#!">!</A> Only do if something present
        a%=V:x$
        b%<A HREF="#=">=</A><A HREF="#INT">INT</A>{a%}
        h%<A HREF="#=">=</A><A HREF="#INT">INT</A>{a%+2}
        <A HREF="#'">'</A>
        x%(0)=1
        x%(1)=h%
        x%(2)=1
        x%(3)=1
        x%(4)=0
        x%(5)<A HREF="#=">=</A>&H3030303
        x%(6)=9999
        x%(7)=0
        x%(8)=V:x$+6
        x%(9)=2
        x%(10)<A HREF="#=">=</A><A HREF="#SHR">SHR</A>(b%+16,4)*2
        x%(11)=2
        x%(12)=9999
        x%(13)=0
        x%(14)<A HREF="#=">=</A><A HREF="#XBIOS">XBIOS</A>(3)
        x%(15)=2
        x%(16)=80
        x%(17)=2
        x%(18)=0 <A HREF="#!">!</A> p_addr
        x%(19)=0 <A HREF="#!">!</A> p_nxln
        x%(20)=0 <A HREF="#!">!</A> p_nxpl
        x%(21)=0 <A HREF="#!">!</A> p_mask
        <A HREF="#'">'</A>
        <A HREF="#FOR">FOR</A> i%=0 TO b%
          x%(6)=i%
          x%(12)=639-i%
          <A HREF="#BITBLT_x%()">BITBLT x%()</A>
        <A HREF="#NEXT">NEXT</A> i%
        <A HREF="#'">'</A>
      <A HREF="#ENDIF">ENDIF</A>
    <A HREF="#RETURN">RETURN</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> An example of <A HREF="#BITBLT_x%()">BITBLT x%()</A><A HREF="#.">.</A>

Both routines reflect a picture about a vertical line down the center of the
screen. In the routine which uses <A HREF="#BITBLT_adr%">BITBLT adr%</A>, the number of bit-planes must be
re-specified each time the instruction is issued. Which routine to use is more
or less a matter of taste, as there is very little difference in speed between
the two. A <A HREF="#VDI">VDI</A> version of the program producing the same effect is listed under
<A HREF="#BITBLT">BITBLT</A> in <A HREF="#'">'</A><A HREF="#Chapter__8_-_Graphics">Chapter  8 - Graphics</A>'<A HREF="#.">.</A>

<A HREF="#Line-A">Line-A</A> BitBlt+
<HR SIZE=3><H2 ID="L~A">L~A</H2>
<B><A HREF="#L~A">L~A</A></B>

The function <A HREF="#L~A">L~A</A> returns the base address of the <A HREF="#Line-A_Variable_Table">Line-A Variable Table</A> (see
<A HREF="#Appendix">Appendix</A>)<A HREF="#.">.</A>

<B>Example:</B>

    <A HREF="#PRINT">PRINT</A> <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>}

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Gives the number of bit planes in the current resolution. See also the
    examples under <A HREF="#BITBLT">BITBLT</A><A HREF="#.">.</A>

<B>Memo:</B> <A HREF="#Line-A">Line-A</A> variables as defined by Atari VDI:
      See <A HREF="#LINEAVAR.H">LINEAVAR.H</A> and <A HREF="#LINEAEQU.S">LINEAEQU.S</A>

<A HREF="#Line-A">Line-A</A> Initialize+
<HR SIZE=3><H2 ID="VDI_Routines">VDI Routines</H2>
<A NAME="VDI"></A><A HREF="#CONTRL">CONTRL</A>, CONTRL()
<A HREF="#INTIN">INTIN</A>, INTIN()
<A HREF="#INTOUT">INTOUT</A> ,INTOUT()
<A HREF="#PTSIN">PTSIN</A>, PTSIN()
<A HREF="#PTSOUT">PTSOUT</A>, PTSOUT()
<A HREF="#VDISYS">VDISYS</A>
<A HREF="#VDIBASE">VDIBASE</A>
<A HREF="#WORK_OUT">WORK_OUT</A><A HREF="#()">()</A>

The <A HREF="#VDI_functions">VDI functions</A> are divided into seven categories:

    Control functions
    Output functions
    Attribute functions
    Raster functions
    Input functions
    Inquire functions
    Escape functions

Three kinds of parameters are distinguished: Input, Output, and those used for
both input and output. These parameters belong in five arrays:

    <A HREF="#CONTRL">CONTRL</A>  Control
    <A HREF="#INTIN">INTIN</A>   Integer input
    <A HREF="#PTSIN">PTSIN</A>   Point coordinate input
    <A HREF="#INTOUT">INTOUT</A>  Integer output
    <A HREF="#PTSOUT">PTSOUT</A>  Point coordinate output

The input parameters are stored in:

    <A HREF="#CONTRL">CONTRL</A>(0)  Function opcode
    <A HREF="#CONTRL">CONTRL</A>(1)  Number of points in the <A HREF="#PTSIN">PTSIN</A> array
    <A HREF="#CONTRL">CONTRL</A>(3)  Length of the <A HREF="#INTIN">INTIN</A> array
    <A HREF="#CONTRL">CONTRL</A>(5)  Sub-opcode
    <A HREF="#INTIN">INTIN</A><A HREF="#()">()</A>    Integer value input array
    <A HREF="#PTSIN">PTSIN</A><A HREF="#()">()</A>    Point coordinate input array

The output parameters are:

    <A HREF="#CONTRL">CONTRL</A>(2)  Number of points in the <A HREF="#PTSOUT">PTSOUT</A> array
    <A HREF="#CONTRL">CONTRL</A>(4)  Length of the <A HREF="#INTOUT">INTOUT</A> array
    <A HREF="#INTOUT">INTOUT</A><A HREF="#()">()</A>   Output array of integer values
    <A HREF="#PTSOUT">PTSOUT</A><A HREF="#()">()</A>   Output array of point coordinates

Input and output parameters are:

    <A HREF="#CONTRL">CONTRL</A>(6)    Workstation handle
    <A HREF="#CONTRL">CONTRL</A>(7-n)  Opcode dependent information

The array elements meaning depends on which <A HREF="#VDI">VDI</A> function is being called.

<B>Memo:</B> Programs which use the <A HREF="#VDI">VDI</A> to do all graphics output will work on
      machines equiped with video graphics cards.

      The compiler only initializes the <A HREF="#VDI">VDI</A> if some module is linked that
      actually calls the <A HREF="#VDI">VDI</A><A HREF="#.">.</A> The editor on the other hand always does this.
      If you suspect the <A HREF="#VDI">VDI</A> is not initialized it can be forced with a
      call to any <A HREF="#VDI">VDI</A> function. I suggest using some inquire function like
      <A HREF="#~">~</A><A HREF="#POINT">POINT</A>(0,0)<A HREF="#.">.</A>

      When GFA starts up, it opens a workstation and copies the handle to
      <A HREF="#CONTRL">CONTRL</A>(6)<A HREF="#.">.</A> This is why you don't need set CONTRL(6) when writing custom
      bindings. This scheme relies on the fact that the <A HREF="#VDI">VDI</A> won't alter
      <A HREF="#CONTRL">CONTRL</A>(6)<A HREF="#.">.</A> In some rare cases, depending on the <A HREF="#VDI">VDI</A> call made, the
      contents of <A HREF="#CONTRL">CONTRL</A>(6) could be destroyed. If you discover this has
      happened you can restore <A HREF="#CONTRL">CONTRL</A>(6) by issuing the command <A HREF="#V~H">V~H</A><A HREF="#=">=</A>-1.

<A HREF="#VDI">VDI</A><A HREF="#+">+</A>, VDI Functions by Opcode+
<HR SIZE=3><H2 ID="CONTRL">CONTRL</H2>
<A NAME="INTIN"></A><A NAME="INTOUT"></A><A NAME="PTSIN"></A><A NAME="PTSOUT"></A>These functions give the addresses in the <A HREF="#VDI">VDI</A> Parameter Block, which are the
addresses of the first bytes of the <A HREF="#CONTRL">CONTRL</A>, <A HREF="#INTIN">INTIN</A> etc. arrays. The arrays can
be accessed by placing an <A HREF="#index">index</A> value in brackets after the array name, for
example <A HREF="#CONTRL">CONTRL</A>(2)=x& corresponds to <A HREF="#DPOKE">DPOKE</A> CONTRL+4,x& and x&=CONTRL(2) to
x&<A HREF="#=">=</A><A HREF="#DPEEK">DPEEK</A>(<A HREF="#CONTRL">CONTRL</A>+4)<A HREF="#.">.</A> The other arrays are also organised in word format.

The meanings are:

    <A HREF="#CONTRL">CONTRL</A>  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Address of the <A HREF="#VDI">VDI</A> control table
    <A HREF="#INTIN">INTIN</A>   <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Address of the <A HREF="#VDI">VDI</A> integer input table
    <A HREF="#PTSIN">PTSIN</A>   <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Address of the <A HREF="#VDI">VDI</A> point coordinate input table
    <A HREF="#INTOUT">INTOUT</A>  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Address of the <A HREF="#VDI">VDI</A> integer output table
    <A HREF="#PTSOUT">PTSOUT</A>  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Address of the <A HREF="#VDI">VDI</A> point coordinate output table

These tables (2-byte word arrays) contain the parameters for <A HREF="#VDI">VDI</A> calls.

<B>Memo:</B> These built in tables have the following limits:
      <A HREF="#CONTRL">CONTRL</A>(0-11)
      <A HREF="#INTIN">INTIN</A>(0-127)
      <A HREF="#PTSIN">PTSIN</A>(0-31)   <A HREF="#&#60;">&#60;</A>- Bug in the editor, should be 0-255
      <A HREF="#INTOUT">INTOUT</A>(0-127)
      <A HREF="#PTSOUT">PTSOUT</A>(0-255)

      This appears to be a 'worst case senerio', as newer <A HREF="#VDI">VDI</A> versions allow
      larger table sizes. If you exceed these values in a compiled program
      there is no error message, instead some memory location gets changed
      unexpectedly.
<HR SIZE=3><H2 ID="VDISYS">VDISYS</H2>
<B><A HREF="#VDISYS">VDISYS</A> [opcode[,int_cnt,pts_cnt[,subopc]]]</B>

opcode, int_cnt, pts_cnt, subopc: <A HREF="#iexp">iexp</A>

With the instruction <A HREF="#VDISYS">VDISYS</A> the <A HREF="#VDI">VDI</A> function with the function code 'opcode'
is called. If opcode is not specified, then the function code must, like the
other parameters, be place in the control block with <A HREF="#'">'</A><A HREF="#DPOKE">DPOKE</A> <A HREF="#CONTRL">CONTRL</A>,opcode' or
<A HREF="#'">'</A><A HREF="#CONTRL">CONTRL</A>(0)=opcode'<A HREF="#.">.</A>

The number of values in the integer and point-coordinate input arrays can be
specified in the parameters int_cnt and pts_cnt. These values need not then be
placed into the Control Block. The optional parameter 'subopc' contains the
sub-opcode of the routine to be called. This must only be specified for some
<A HREF="#VDI">VDI</A> routines, for example Escape function routines. The parameters int_cnt,
pts_cnt, and subopc will be inserted into the <A HREF="#CONTRL">CONTRL</A> block like so:

    opcode  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> <A HREF="#CONTRL">CONTRL</A>(0)
    int_cnt <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> <A HREF="#CONTRL">CONTRL</A>(3)
    pts_cnt <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> <A HREF="#CONTRL">CONTRL</A>(1)
    subopc  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> <A HREF="#CONTRL">CONTRL</A>(5)

<B>Examples:</B>

    <A HREF="#'">'</A> example #1: long form
    <A HREF="#CONTRL">CONTRL</A>(0)=11
    <A HREF="#CONTRL">CONTRL</A>(1)=3
    <A HREF="#CONTRL">CONTRL</A>(3)=0
    <A HREF="#CONTRL">CONTRL</A>(5)=4
    <A HREF="#PTSIN">PTSIN</A>(0)=320
    <A HREF="#PTSIN">PTSIN</A>(1)=200
    <A HREF="#PTSIN">PTSIN</A>(4)=190
    <A HREF="#VDISYS">VDISYS</A>
    <A HREF="#PAUSE">PAUSE</A> 25
    <A HREF="#CLS">CLS</A>
    <A HREF="#'">'</A>
    <A HREF="#'">'</A> example #2: short form
    <A HREF="#PTSIN">PTSIN</A>(0)=320
    <A HREF="#PTSIN">PTSIN</A>(1)=200
    <A HREF="#PTSIN">PTSIN</A>(4)=190
    <A HREF="#VDISYS">VDISYS</A> 11,0,3,4
    <A HREF="#PAUSE">PAUSE</A> 25
    <A HREF="#CLS">CLS</A>
    <A HREF="#'">'</A>
    <A HREF="#PCIRCLE">PCIRCLE</A> 320,200,190
    <A HREF="#PAUSE">PAUSE</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Three different ways of drawing the same filled circle.

    <A HREF="#VDISYS">VDISYS</A> 5,0,0,13
    <A HREF="#PRINT">PRINT</A> "Inverted"
    <A HREF="#VDISYS">VDISYS</A> 5,0,0,14
    <A HREF="#PRINT">PRINT</A> "Normal"

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Prints 'Inverted' in inverse video and 'Normal' normally.

<B>Memo:</B> Calling a function which does not exist is usually fatal.

      Generates less code: short form
      Faster interpreted: short form
      Faster compiled: short form
<HR SIZE=3><H2 ID="VDIBASE">VDIBASE</H2>
<B><A HREF="#VDIBASE">VDIBASE</A></B>

The system variable <A HREF="#VDIBASE">VDIBASE</A> contains the address starting from which the
current GEM version puts parameters for use in the <A HREF="#VDI">VDI</A> routines (text style,
clipping, etc)<A HREF="#.">.</A> The structure of this area could well be different in future
versions of GEM. <A HREF="#VDIBASE">VDIBASE</A> is contained as a keyword in <A HREF="#GFA-Basic">GFA-Basic</A> in order to
give programmers the ability to access all <A HREF="#VDI">VDI</A> parameters.

<B>Memo:</B> See <A HREF="#VDIBASE.TXT">VDIBASE.TXT</A> and <A HREF="#ATTRDEF.H">ATTRDEF.H</A> for more information.
      Far as I can tell <A HREF="#VDIBASE">VDIBASE</A> has been inaccurate since TOS 1.02.
      This pointer should never be used. In some cases it points outside
      the programs memory space.
<HR SIZE=3><H2 ID="WORK_OUT">WORK_OUT</H2>
<B><A HREF="#WORK_OUT">WORK_OUT</A>(x)</B>

x: <A HREF="#iexp">iexp</A>

This function determines the values found in <A HREF="#INTOUT">INTOUT</A>(0) to INTOUT(44), <A HREF="#PTSOUT">PTSOUT</A>(0)
and <A HREF="#PTSOUT">PTSOUT</A>(11) after returning from the function <A HREF="#V_OPNWK">V_OPNWK</A><A HREF="#()">()</A><A HREF="#.">.</A> The <A HREF="#index">index</A> 'x' can
take values from 0 to 56 (see section <A HREF="#VDI_WORK_OUT()_Array_Table">VDI WORK_OUT() Array Table</A> in the
<A HREF="#Appendix">Appendix</A>)<A HREF="#.">.</A>

<B>Example:</B>

    screen_width&<A HREF="#=">=</A><A HREF="#WORK_OUT">WORK_OUT</A>(0)
    screen_height&<A HREF="#=">=</A><A HREF="#WORK_OUT">WORK_OUT</A>(1)
    <A HREF="#PRINT">PRINT</A> screen_width&,screen_height&,<A HREF="#WORK_OUT">WORK_OUT</A>(10)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The numbers 639 and 399 (in monochrome mode) for the screen width and
    height are printed, followed by a 1 for the number of the available
    character sets (<A HREF="#WORK_OUT">WORK_OUT</A>(10))<A HREF="#.">.</A>

<B>Memo:</B> This table has the following limit:
      <A HREF="#WORK_OUT">WORK_OUT</A>(0-56)
<HR SIZE=3><H2 ID="Special_VDI_Routines_and_GDOS">Special VDI Routines and GDOS</H2>
<A NAME="VDI_functions"></A><A HREF="#GDOS?">GDOS?</A>
<A HREF="#V~H">V~H</A>
<A HREF="#V_OPNWK">V_OPNWK</A><A HREF="#()">()</A>, <A HREF="#V_CLSWK">V_CLSWK</A>()
<A HREF="#V_OPNVWK">V_OPNVWK</A><A HREF="#()">()</A>, <A HREF="#V_CLSVWK">V_CLSVWK</A>()
<A HREF="#V_CLRWK">V_CLRWK</A><A HREF="#()">()</A>
<A HREF="#V_UPDWK">V_UPDWK</A><A HREF="#()">()</A>
<A HREF="#VST_LOAD_FONTS">VST_LOAD_FONTS</A><A HREF="#()">()</A>, <A HREF="#VST_UNLOAD_FONTS">VST_UNLOAD_FONTS</A>()
<A HREF="#VQT_EXTENT">VQT_EXTENT</A><A HREF="#()">()</A>
<A HREF="#VQT_NAME">VQT_NAME</A><A HREF="#()">()</A>

The following <A HREF="#VDI">VDI</A> Workstation and query functions are available only if GDOS
(release 1.0 and later) has been installed and a valid ASSIGN.SYS file is
available.

The machine independent GDOS (Graphics DEVICE Operating System) contains
graphics functions and works together with device dependant drivers for
different output devices (screen, printer, plotter, metafiles, etc.).

The <A HREF="#ASCII">ASCII</A> file ASSIGN.SYS contains all necessary data concerning the current
device configuration. In this file all current Operating System and character
sets must be registered, and if necessary the access path to the Operating
System must be specified, if it is not on drive A:. The following syntax should
be noted:

    PATH=d:\path\
    id DEVICE.SYS
    <A HREF="#;">;</A> Remarks
    PART1.FNT
    PART2.FNT
    <A HREF="#.">.</A>..
    PARTN.FNT

id contains a number between 1 and 32767. With it the type of device is
determined as follows:

    01  <A HREF="#.">.</A>..  Screen
    11  <A HREF="#.">.</A>..  Plotter
    21  <A HREF="#.">.</A>..  Printer
    31  <A HREF="#.">.</A>..  Metafile
    41  <A HREF="#.">.</A>..  Camera
    51  <A HREF="#.">.</A>..  Graphic-Tablet

If the Operating System is located on drive <A HREF="#C:">C:</A> in the folder <A HREF="#GEMSYS">GEMSYS</A>, then the
associated ASSIGN.SYS file looks, for example, like this:

    PATH=c:\gemsys\
    01p SCREEN.SYS ;Screen driver in ROM, therefore a 'p' after the ID
    ATSS10.FNT
    ATSS12.FNT
    02p SCREEN.SYS ;Driver for low resolution
    ATSS10.FNT
    ATSS12.FNT
    03p SCREEN.SYS ;Driver for medium resolution
    ATSS10CG.FNT
    ATSS12CG.FNT
    04p SCREEN.SYS ;Driver for high resolution
    ATSS10.FNT
    ATSS12.FNT
    21 FX80.SYS    ;Printer driver for the FX-80 and compatible
    ATSS10EP.FNT
    ATSS12EP.FNT
    31 META.SYS    ;Metafile driver
    ATSS10MF.FNT
    ATSS12MF.FNT

The screen drivers SCREEN.SYS are only dummy entries, required by the GDOS
syntax checker. The ID's (2, 3, and 4) have only to assign, for each
resolution, the order of the given fonts. Therefore the call to open a virtual
screen memory workstation is <A HREF="#V_OPNVWK">V_OPNVWK</A>(<A HREF="#XBIOS">XBIOS</A>(4)+2))<A HREF="#.">.</A> <A HREF="#GFA-Basic">GFA-Basic</A> 3 makes this call
internally.
<HR SIZE=3><H2 ID="GDOS?">GDOS?</H2>
<B><A HREF="#GDOS?">GDOS?</A></B>

<A HREF="#GDOS?">GDOS?</A> returns <A HREF="#TRUE">TRUE</A> if GDOS (release 1.0 or later) is resident and <A HREF="#FALSE">FALSE</A>
otherwise.

<B>Example:</B>

    <A HREF="#IF">IF</A> <A HREF="#NOT">NOT</A> <A HREF="#GDOS?">GDOS?</A>
      <A HREF="#ALERT">ALERT</A> 1,"GDOS not found.",1," OK ",r%
      <A HREF="#END">END</A>
    <A HREF="#ENDIF">ENDIF</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> If GDOS is not installed an alert box appears.

GDOS+, vq_gdos()+
<HR SIZE=3><H2 ID="V~H">V~H</H2>
<B><A HREF="#V~H">V~H</A></B>

With the following functions, 'hd' stands for the <A HREF="#VDI">VDI</A> handle and 'id' for the
identification of an output device. With this in mind, consider the following
functions:

<A HREF="#V~H">V~H</A>     Returns the internal <A HREF="#VDI">VDI</A> handle of GFA Basic. (e.g. <A HREF="#PRINT">PRINT</A> V~H)

<A HREF="#V~H">V~H</A>=x   Sets the internal <A HREF="#VDI">VDI</A> handle (accessible through <A HREF="#CONTRL">CONTRL</A>(6)) to the
        value x.

<A HREF="#V~H">V~H</A><A HREF="#=">=</A>-1  Sets the <A HREF="#VDI">VDI</A> handle (<A HREF="#CONTRL">CONTRL</A>(6)) to the value resulting from the
        internal <A HREF="#V_OPNVWK">V_OPNVWK</A><A HREF="#()">()</A><A HREF="#.">.</A>

<B>Memo:</B> The compiler/linker can build applications that do not initialize
      the <A HREF="#VDI">VDI</A><A HREF="#.">.</A> <A HREF="#V~H">V~H</A> will equal zero if this occurs.
<HR SIZE=3><H2 ID="V_OPNWK">V_OPNWK</H2>
<A NAME="V_CLSWK"></A><B><A HREF="#V_OPNWK">V_OPNWK</A>(id[,1,1,1,1,1,1,1,1,1,2])
<A HREF="#V_CLSWK">V_CLSWK</A><A HREF="#()">()</A></B>

id: <A HREF="#iexp">iexp</A>

The numbers 1 and 2 are default values for the settings of the <A HREF="#VDI">VDI</A> parameters.
They can be changed (see <A HREF="#WORK_OUT">WORK_OUT</A><A HREF="#()">()</A>)<A HREF="#.">.</A>

The function <A HREF="#V_OPNWK">V_OPNWK</A><A HREF="#()">()</A> (Open Workstation) returns the handle 'hd' for the
specified device 'id'<A HREF="#.">.</A> In addition, further information about the device may be
requested by means of <A HREF="#INTOUT">INTOUT</A><A HREF="#()">()</A> and <A HREF="#PTSOUT">PTSOUT</A>() (see <A HREF="#VDISYS">VDISYS</A> in the section 'System
Routines')<A HREF="#.">.</A>

The optional 10 parameters are as follows:
   1   Default line type      vsl_type()
   2   Default line color     vsl_color()
   3   Default marker type    vsm_type()
   4   Default marker color   vsm_color()
   5   Default font           vst_font()
   6   Default text color     vst_color()
   7   Default fill interior  vsf_interior()
   8   Default fill style     vsf_style()
   9   Default fill color     vsf_color()
  10   Coordinate type flag   0 <A HREF="#=">=</A> NDC (Normalized Device Coordinates)
                              2 <A HREF="#=">=</A> RC (Raster Coordinates)

If the parameters are left out, the values '1,1,1,1,1,1,1,1,1,2' are used.

The function <A HREF="#V_CLSWK">V_CLSWK</A><A HREF="#()">()</A> (Close Workstation) closes the current workstation
opened with <A HREF="#V_OPNWK">V_OPNWK</A><A HREF="#()">()</A> and flushes its buffers. In addition a <A HREF="#V~H">V~H</A><A HREF="#=">=</A>-1 is carried
out.

<B>Example:</B> See <A HREF="#V_CLRWK">V_CLRWK</A><A HREF="#()">()</A><A HREF="#.">.</A>

<B>Memo:</B> <A HREF="#V_OPNWK">V_OPNWK</A><A HREF="#()">()</A> with the extra parameters does not work correctly in the
      editor or compiled.

      <A HREF="#V_CLSWK">V_CLSWK</A><A HREF="#()">()</A> seems to return <A HREF="#INTOUT">INTOUT</A>(0), but it's useless. This <A HREF="#VDI">VDI</A> call is
      documented as not having a return value.

v_opnwk()<A HREF="#+">+</A>, v_clswk()+
<HR SIZE=3><H2 ID="V_OPNVWK">V_OPNVWK</H2>
<A NAME="V_CLSVWK"></A><B><A HREF="#V_OPNVWK">V_OPNVWK</A>(id[,1,1,1,1,1,1,1,1,1,2])
<A HREF="#V_CLSVWK">V_CLSVWK</A><A HREF="#()">()</A></B>

id: <A HREF="#iexp">iexp</A>

The function <A HREF="#V_OPNWK">V_OPNWK</A><A HREF="#()">()</A> (Open Virtual Workstation) opens a virtual screen driver
and returns the handle 'hd' for the specified device 'id' (see <A HREF="#V_OPNWK">V_OPNWK</A><A HREF="#()">()</A>)<A HREF="#.">.</A>

See <A HREF="#V_OPNWK">V_OPNWK</A><A HREF="#()">()</A> for an explaination of the optional 10 parameters.

The function <A HREF="#V_CLSVWK">V_CLSVWK</A><A HREF="#()">()</A> (Close Virtual Workstation) closes a virtual workstation
opened with V_OPVNWK()<A HREF="#.">.</A> In addition a <A HREF="#V~H">V~H</A><A HREF="#=">=</A>-1 is issued.

<B>Memo:</B> <A HREF="#V_OPNVWK">V_OPNVWK</A><A HREF="#()">()</A> with the extra parameters does not work correctly in the
      editor or compiled.

<B>Memo:</B> <A HREF="#V_CLSVWK">V_CLSVWK</A><A HREF="#()">()</A> seems to return <A HREF="#INTOUT">INTOUT</A>(0), but it's useless. This <A HREF="#VDI">VDI</A>
      call is documented as not having a return value.

v_opnvwk()<A HREF="#+">+</A>, v_clsvwk()+
<HR SIZE=3><H2 ID="V_CLRWK">V_CLRWK</H2>
<A NAME="V_UPDWK"></A><B><A HREF="#V_CLRWK">V_CLRWK</A><A HREF="#()">()</A>
<A HREF="#V_UPDWK">V_UPDWK</A><A HREF="#()">()</A></B>

The function <A HREF="#V_CLRWK">V_CLRWK</A><A HREF="#()">()</A> (Clear Workstation) clears the output buffer. For
example, the screen or printer buffer is cleared.

For output of graphics to a printer, all commands are collected in a buffer.
The function <A HREF="#V_UPDWK">V_UPDWK</A><A HREF="#()">()</A> (Update Workstation) sends these buffered graphic
instructions to the attached device. Unlike printer graphics, for example, all
graphic instructions sent to the screen are implemented immediately.

<B>Example:</B>

    <A HREF="#'">'</A> If GDOS is resident
    <A HREF="#RESERVE">RESERVE</A> 25600       !Reserve sufficient storage memory
    handle&<A HREF="#=">=</A><A HREF="#V_OPNWK">V_OPNWK</A>(21) !Determine identification for output device
    <A HREF="#'">'</A>
    <A HREF="#IF">IF</A> handle&=0
      <A HREF="#ALERT">ALERT</A> 3,"Installation error!",1,"Cancel",r%
      <A HREF="#END">END</A>
    <A HREF="#ENDIF">ENDIF</A>
    <A HREF="#'">'</A>
    x_res&<A HREF="#=">=</A><A HREF="#INTOUT">INTOUT</A>(0) !Determine x- and y-resolution
    y_res&<A HREF="#=">=</A><A HREF="#INTOUT">INTOUT</A>(1) !of the attached device
    <A HREF="#'">'</A>
    <A HREF="#V~H">V~H</A>=handle& !Sets the internal <A HREF="#VDI">VDI</A> handle to printer identification
    <A HREF="#~">~</A><A HREF="#V_CLRWK">V_CLRWK</A><A HREF="#()">()</A> !Clear buffer
    <A HREF="#'">'</A>
    <A HREF="#CLIP">CLIP</A> 0,0,x_res&,y_res&
    <A HREF="#BOX">BOX</A> 0,0,x_res&,y_res&
    <A HREF="#LINE">LINE</A> 0,0,x_res&,y_res&
    <A HREF="#LINE">LINE</A> 0,y_res&,x_res&,0
    <A HREF="#'">'</A>
    <A HREF="#~">~</A><A HREF="#V_UPDWK">V_UPDWK</A><A HREF="#()">()</A> !Carry out Graphic commands
    <A HREF="#~">~</A><A HREF="#V_CLSWK">V_CLSWK</A><A HREF="#()">()</A>
    <A HREF="#'">'</A>
    <A HREF="#RESERVE">RESERVE</A>    !Return memory to GFA Basic

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Sends a rectangle with a diagonal line through it to an attached printer,
    if GDOS is resident.

<B>Memo:</B> Neither of these return any useful result. The <A HREF="#VDI">VDI</A> documentation
      lists them as not returning anything. They seem to return <A HREF="#INTOUT">INTOUT</A>(0) but
      it's useless.

v_clrwk()<A HREF="#+">+</A>, v_updwk()+
<HR SIZE=3><H2 ID="VST_LOAD_FONTS">VST_LOAD_FONTS</H2>
<A NAME="VST_UNLOAD_FONTS"></A><B><A HREF="#VST_LOAD_FONTS">VST_LOAD_FONTS</A>(x)
<A HREF="#VST_UNLOAD_FONTS">VST_UNLOAD_FONTS</A>(x)</B>

x: <A HREF="#iexp">iexp</A>

The function <A HREF="#VST_LOAD_FONTS">VST_LOAD_FONTS</A><A HREF="#()">()</A> loads any additional fonts specified in
ASSIGN.SYS, if sufficient memory is available, then the number of loaded fonts
is returned. If no fonts are available, zero is returned.

The parameter x should be zero with present versions of GEM, though this may
change in the future. It is important to reserve sufficient memory for the
additional fonts, using <A HREF="#RESERVE">RESERVE</A><A HREF="#.">.</A>

The function <A HREF="#VST_UNLOAD_FONTS">VST_UNLOAD_FONTS</A><A HREF="#()">()</A> removes the fonts loaded previously
with <A HREF="#VST_LOAD_FONTS">VST_LOAD_FONTS</A><A HREF="#()">()</A> from memory. The parameter x is currently zero, same as
<A HREF="#VST_LOAD_FONTS">VST_LOAD_FONTS</A><A HREF="#()">()</A><A HREF="#.">.</A>

<B>Example:</B>

    <A HREF="#RESERVE">RESERVE</A> 25600
    <A HREF="#'">'</A>
    num_fonts%<A HREF="#=">=</A><A HREF="#VST_LOAD_FONTS">VST_LOAD_FONTS</A>(0) !how many additional fonts?
    <A HREF="#ADD">ADD</A> num_fonts%,<A HREF="#WORK_OUT">WORK_OUT</A>(10)  !add system fonts, gives the true total
    <A HREF="#'">'</A>
    <A HREF="#FOR">FOR</A> i%=1 to num_fonts%
      face%<A HREF="#=">=</A><A HREF="#VQT_NAME">VQT_NAME</A>(i%,font$)   <A HREF="#!">!</A><A HREF="#index">index</A> and name of loaded font
      <A HREF="#DEFTEXT">DEFTEXT</A> ,,,,face%
      <A HREF="#TEXT">TEXT</A> 80,80,"This is "+font$+" font."
      <A HREF="#~">~</A><A HREF="#INP">INP</A>(2)
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#'">'</A>
    <A HREF="#~">~</A><A HREF="#VST_UNLOAD_FONTS">VST_UNLOAD_FONTS</A>(0)         !remove fonts
    <A HREF="#'">'</A>
    <A HREF="#RESERVE">RESERVE</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Displays the names of all available fonts in their own font face.

<B>Memo:</B> <A HREF="#VST_UNLOAD_FONTS">VST_UNLOAD_FONTS</A><A HREF="#()">()</A> seems to return <A HREF="#INTOUT">INTOUT</A>(0), but it's useless.
      This <A HREF="#VDI">VDI</A> call is documented as not having a return value.

vst_load_fonts()<A HREF="#+">+</A>, vst_unload_fonts()+
<HR SIZE=3><H2 ID="VQT_EXTENT">VQT_EXTENT</H2>
<B><A HREF="#VQT_EXTENT">VQT_EXTENT</A>(text$[,x1,y1,x2,y2,x3,y3,x4,y4])</B>

text$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>
x1, y1, x2, y2, x3, y3, x4, y4: <A HREF="#ivar">ivar</A>

The function <A HREF="#VQT_EXTENT">VQT_EXTENT</A><A HREF="#()">()</A> returns the corner coordinates of a rectangle which
will surround the text in text$<A HREF="#.">.</A> The coordinates can either be found in the
variables x1,y1 to x4,y4, or in <A HREF="#PTSOUT">PTSOUT</A>(0) to PTSOUT(7)<A HREF="#.">.</A> The corner points are
numbered in a counter-clockwise direction:

    <B>Variable  <A HREF="#PTSOUT">PTSOUT</A>(x/y)  Position</B>
    x1,y1     0/1          P1
    x2,y2     2/3          P2
    x3,y3     4/5          P3
    x4,y4     6/7          P4

Which would be interpreted as:













<B>Example</B>

    <A HREF="#INPUT">INPUT</A> text$
    <A HREF="#CLS">CLS</A>
    <A HREF="#ATEXT">ATEXT</A> 100,25,2,text$
    <A HREF="#~">~</A><A HREF="#VQT_EXTENT">VQT_EXTENT</A>(text$,x1,y1,x2,y2,x3,y3,x4,y4)
    <A HREF="#BOX">BOX</A> x4+100,y4+25,x2+100,y2+25

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The input text is put at the arbitrary screen position (100,25), and a box
    is neatly put around it.

<B>Memo:</B> <A HREF="#VQT_EXTENT">VQT_EXTENT</A><A HREF="#()">()</A> seems to return <A HREF="#INTOUT">INTOUT</A>(0), but it's useless.
      This <A HREF="#VDI">VDI</A> call is documented as not having a return value.

vqt_extent()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="VQT_NAME">VQT_NAME</H2>
<B><A HREF="#VQT_NAME">VQT_NAME</A>(i,font_name$)</B>

i: <A HREF="#ivar">ivar</A>
font_name$<A HREF="#:">:</A> <A HREF="#svar">svar</A>

The function <A HREF="#VQT_NAME">VQT_NAME</A><A HREF="#()">()</A> returns the handle of the font with the identification
number 'i' and places the name of the loaded character set into the string
variable font_name$<A HREF="#.">.</A>

Note: Parameter i must start at 1.

<B>Example:</B>

    <A HREF="#RESERVE">RESERVE</A> 25600
    <A HREF="#'">'</A>
    num_fonts%<A HREF="#=">=</A><A HREF="#VST_LOAD_FONTS">VST_LOAD_FONTS</A>(0)
    face%<A HREF="#=">=</A><A HREF="#VQT_NAME">VQT_NAME</A>(num_fonts%,font$) !Index and name of loaded Font
    <A HREF="#'">'</A>
    h%=12                            !Text height
    s$<A HREF="#=">=</A>"example text"
    x0%=80                           !Output coordinats for s$
    y0%=80
    <A HREF="#DEFTEXT">DEFTEXT</A> 1,0,0,h%,face%
    <A HREF="#'">'</A>
    <A HREF="#~">~</A><A HREF="#VQT_EXTENT">VQT_EXTENT</A>(s$,x1%,y1%,x2%,y2%,x3%,y3%,x4%,y4%)
    <A HREF="#'">'</A>
    <A HREF="#GRAPHMODE">GRAPHMODE</A> 4
    <A HREF="#TEXT">TEXT</A> x0%,y0%,s$
    <A HREF="#PBOX">PBOX</A> x0%+x1%,y0%+y1%-h%-1,x0%+x3%,y0%+y3%-h%
    <A HREF="#'">'</A>
    <A HREF="#~">~</A><A HREF="#VST_UNLOAD_FONTS">VST_UNLOAD_FONTS</A>(0)             !Remove fonts
    <A HREF="#'">'</A>
    <A HREF="#RESERVE">RESERVE</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The string s$ is displayed inverted on the screen at (x0%,y0%)<A HREF="#.">.</A>

<B>Memo:</B> Clobbers <A HREF="#INTOUT">INTOUT</A>(33) thus the font type can't be discovered.

vqt_name()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="Non-BASIC_Routine_Calls">Non-BASIC Routine Calls</H2>
<A HREF="#C:">C:</A>
<A HREF="#MONITOR">MONITOR</A>
<A HREF="#CALL">CALL</A>
<A HREF="#RCALL">RCALL</A>
<A HREF="#EXEC">EXEC</A>, <A HREF="#EXEC()">EXEC()</A>

The commands explained in this section enable subroutines which are written in
C or assembler to be called.

<B>Memo:</B> For an alternate method of calling non-BASIC routines via the
      compiler see section <A HREF="#'">'</A><A HREF="#Externally_Linked_Routines">Externally Linked Routines</A>'<A HREF="#.">.</A>
<HR SIZE=3><H2 ID="C:">C:</H2>
<B>C:addr([x,y,<A HREF="#.">.</A>..])</B>

addr: <A HREF="#avar">avar</A> (at least 32-bit, ideally integer-type: adr%)
x, y: <A HREF="#iexp">iexp</A>

The function <A HREF="#C:">C:</A> calls a C or assembler subroutine, located at the address addr.
The parameters in brackets (x, y...) will be passed to the routine. The
parameter passing is via the stack, as in C. The parameters can be sent as
32-bit longwords with the prefix <A HREF="#'">'</A><A HREF="#L:">L:</A>', or 16-bit words with the prefix '<A HREF="#W:">W:</A>'<A HREF="#.">.</A>
If there is no prefix, a word value will be sent. When the function is called,
first the return address and then the parameters will be found on the stack.

So, for example:

<A HREF="#VOID">VOID</A> C:adr%(L:x,W:y,z) leads to the following situation on the stack:

      (sp)  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Return address (4 bytes)
     4(sp)  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  x (4 bytes)
     8(sp)  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  y (2 bytes)
    10(sp)  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  z (2 bytes)

The value returned by the function is the contents of register d0 on return
from the subroutine (for which RTS must be used)<A HREF="#.">.</A>

<B>Example:</B>

The assembler program used here fills an area of memory (e.g. an array)
starting from a certain address with the numbers (longwords) from 0 to n.

206F0004         move.l   4(sp),a0  <A HREF="#;">;</A> Start address
202F0008         move.l   8(sp),d0  <A HREF="#;">;</A> Number of values
7200             moveq.l  #0,d1     <A HREF="#;">;</A> Counter
6004             bra.s    ct_2      <A HREF="#;">;</A> Loop re-entry point
20C1      ct_1:  move.l   d1,(a0)<A HREF="#+">+</A>  <A HREF="#;">;</A> Loop, value write
5281             addq.l   #1,d1     <A HREF="#;">;</A> Increment counter
B081      ct_2:  cmp.l    d1,d0     <A HREF="#;">;</A> finished?
64F8             bcc.s    ct_1      <A HREF="#;">;</A> no, around again <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A>
4E75             rts                <A HREF="#;">;</A> Return to GFA BASIC

The <A HREF="#GFA-Basic">GFA-Basic</A> program is:

    <A HREF="#FOR">FOR</A> i%=1 TO 11
      <A HREF="#READ">READ</A> a%
      asm$=asm$<A HREF="#+">+</A><A HREF="#MKI$">MKI$</A>(a%)
    <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#DATA">DATA</A> $206F,$0004,$202F,$0008,$7200,$6004
    <A HREF="#DATA">DATA</A> $20C1,$5281,$B081,$64F8,$4E75
    <A HREF="#'">'</A>
    <A HREF="#DIM">DIM</A> x%(10000)
    asm%=V:asm$
    ~C:asm%(L:V:x%(0),L:10000)
    <A HREF="#PRINT">PRINT</A> "E.g. x%(12) <A HREF="#=">=</A> ";x%(12)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The array x%<A HREF="#()">()</A> is filled with the numbers from 0 to 10000, corresponding
    to:

    <A HREF="#FOR">FOR</A> i%=1 TO n%
      x%(i%)=i%
    <A HREF="#NEXT">NEXT</A> i%

To insert an assembler program in a GFA BASIC 3 program, the <A HREF="#INLINE">INLINE</A> command can
also be used. First a file is created containing the assembler code above by
using (after the above read-data loop)<A HREF="#:">:</A>

    <A HREF="#BSAVE">BSAVE</A> "COUNT.INL",V:asm$,22

Then type in the following program:

    <A HREF="#INLINE">INLINE</A> asm%,22
    <A HREF="#DIM">DIM</A> x%(10000)
    ~C:asm%(L:V:x%(0),L:10000)

Then, while still in the Editor with the cursor on the line containing the
<A HREF="#INLINE">INLINE</A> instruction, press the <A HREF="#Help">Help</A> key. From the resulting menu choose 'Load',
and from the File select box select the file COUNT.INL. It will be loaded into
and area specially allocated within the program, and will be saved with the
program when it is Saved in the normal way. See <A HREF="#INLINE">INLINE</A>, Chapter 2, section
<A HREF="#Memory_Management">Memory Management</A><A HREF="#.">.</A>

<B>Memo:</B> For compiler options see section <A HREF="#'">'</A><A HREF="#Register_Saving">Register Saving</A>'<A HREF="#.">.</A>

      The 'C' routine must be written using the '<A HREF="#cdecl">cdecl</A>' parameter passing
      method. Registers a3 to a7 must remain unchanged.
<HR SIZE=3><H2 ID="MONITOR">MONITOR</H2>
<B><A HREF="#MONITOR">MONITOR</A> [x]</B>

x: <A HREF="#iexp">iexp</A>

This instruction enables one to call assembler subroutines or debugging
programs or other utilities. For this purpose the 'illegal instruction vector'
(address 16) must be set to the address of the subroutine. The <A HREF="#MONITOR">MONITOR</A>
instruction then produces an illegal Instruction exception, which causes the
computer to branch to the subroutine. This subroutine must end with RTE (ReTurn
from Exception)<A HREF="#.">.</A> The parameter x is passed to the subroutine in register d0.

An example of its use is with tracing a C program, using a debugger. <A HREF="#GFA-Basic">GFA-Basic</A>
should be loaded and started from the debugger. Then, after inputting the C
program, insert the line <A HREF="#'">'</A><A HREF="#MONITOR">MONITOR</A> asm%' directly before the <A HREF="#INLINE">INLINE</A> statement.
After the start of the C program the debugger will respond because of the
'Illegal Instruction exception' generated by the <A HREF="#MONITOR">MONITOR</A> command. Now one can
disassemble, single-step or edit the C program at the address now in register
d0. When the C program has been edited/examined satisfactorily, one can
continue the execution of the program with the 'GO' instruction of the
debugger. If the 'Break' keys Shift-Control-Alternate are pressed whilst in the
debugger, a flag will be set which will cause the BASIC program to halt as soon
as control is returned to it.

<B>CAUTION:</B>

Before using this command you must make sure that a machine language monitor
has initialized the monitor vector. <A HREF="#GFA-Basic">GFA-Basic</A> cannot set this vector before
the jump to its address because it does not know where the monitor is. If the
monitor is not at the current vector address this results in the program or
system crash (bombs error #4)<A HREF="#.">.</A>
<HR SIZE=3><H2 ID="CALL">CALL</H2>
<B><A HREF="#CALL">CALL</A> addr[(x,y$,<A HREF="#.">.</A>..)]</B>

addr: <A HREF="#avar">avar</A> (at least 32-bit, ideally integer-type: adr%)
x: <A HREF="#iexp">iexp</A>
y: <A HREF="#sexp">sexp</A>

Assembler or C subroutines can also be called with the instruction <A HREF="#CALL">CALL</A>, where
'addr' is the address of the assembler program, which must end with an RTS
instruction. It is possible to pass a parameter list to the routine.  When the
<A HREF="#CALL">CALL</A> is made, the return address is found at the top of the stack followed by
the number of parameters given as a 16-bit word, and finally the address, as a
32-bit longword, of the parameter list. All parameters will be put into memory
as long (32-bit) words.

Strings may also be passed to the subroutine, in which case it will be the
address of the string which is found in the parameter list.

Stack structure:

     (sp)  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Return address
    4(sp)  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Number of parameters (16-bit)
    6(sp)  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Address of the parameters (32-bit)

Example: <A HREF="#CALL">CALL</A> addr%(a&,b&)

To locate the parameters:
    lea 6(sp),a0

     (a0)  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  a& (4 bytes)
    4(a0)  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  b& (4 bytes)

<B>Memo:</B> This command is broken in the editor, but works compiled.
      For compiler options see section <A HREF="#'">'</A><A HREF="#Register_Saving">Register Saving</A>'<A HREF="#.">.</A>
      Registers a3 to a7 must remain unchanged.
<HR SIZE=3><H2 ID="RCALL">RCALL</H2>
<B><A HREF="#RCALL">RCALL</A> addr,reg%<A HREF="#()">()</A></B>

addr: <A HREF="#iexp">iexp</A>
reg%()<A HREF="#:">:</A> integer array (4-byte)

The instruction <A HREF="#RCALL">RCALL</A> enables the assembler routine to start with pre-allocated
values in the registers, and the BASIC program to query the register contents
when the routine returns. The integer-sized array reg%<A HREF="#()">()</A>, which must have at
least 16 elements, serves this purpose. Before the assembler routine is
started, the entries in this array are automatically copied into the
appropriate registers. At the end of the routine the contents of the registers
are written back into the appropriate elements. The registers and array
elements are related as follows (assuming <A HREF="#OPTION_BASE">OPTION BASE</A> 0)<A HREF="#:">:</A>

    Data registers      d0 to d7  <A HREF="#&#60;">&#60;</A><A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  reg%(0)  to reg%(7)
    Address registers   a0 to a6  <A HREF="#&#60;">&#60;</A><A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  reg%(8)  to reg%(14)
    User stack pointer  (a7)       <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  reg%(15) (return only)

<B>Example:</B>

The assembler listing below expects the address (logical or physical) of the
screen memory in a0. It then inverts the screen display between the given y
coordinates, which are passed in d0 and d1. With a color display, the y
coordinates will have to be adjusted accordingly.

       sub     d0,d1    <A HREF="#;">;</A> Number of lines to invert
       mulu    #20,d1   <A HREF="#;">;</A> Number of bytes to invert
       subq    #1,d1    <A HREF="#;">;</A> Number of bytes to invert
       mulu    #80,d0   <A HREF="#;">;</A> Number bytes not to be inverted
       add.l   d0,a0    <A HREF="#;">;</A> Address of first byte to be inverted
loop:                   <A HREF="#;">;</A> Loop start
       not.l  (a0)<A HREF="#+">+</A>     <A HREF="#;">;</A> Long (4-byte) inversion, also a0=a0+4
       dbra    d1,loop  <A HREF="#;">;</A> Decrement byte count and loop round
       rts              <A HREF="#;">;</A> Return to GFA BASIC

The <A HREF="#GFA-Basic">GFA-Basic</A> program to call this routine reads:

    <A HREF="#DO">DO</A>
      <A HREF="#READ">READ</A> a%
      <A HREF="#EXIT_IF">EXIT IF</A> a%<A HREF="#=">=</A>-1
      a$=a$<A HREF="#+">+</A><A HREF="#MKI$">MKI$</A>(a%)
    <A HREF="#LOOP">LOOP</A>
    <A HREF="#DATA">DATA</A> 37440,49916,20,21313
    <A HREF="#DATA">DATA</A> 49404,80,53696
    <A HREF="#DATA">DATA</A> 18072,20937,65532,20085,-1
    <A HREF="#'">'</A>
    <A HREF="#DIM">DIM</A> r%(16)
    xb2%<A HREF="#=">=</A><A HREF="#XBIOS">XBIOS</A>(2)
    <A HREF="#HIDEM">HIDEM</A>
    <A HREF="#FOR">FOR</A> j%=1 TO 50
      <A HREF="#FOR">FOR</A> i%=0 TO 190 <A HREF="#STEP">STEP</A> 10
        r%(0)=i%
        r%(1)=399-i%
        r%(8)=xb2%
        <A HREF="#RCALL">RCALL</A> V:a$,r%<A HREF="#()">()</A>
      <A HREF="#NEXT">NEXT</A> i%
    <A HREF="#NEXT">NEXT</A> j%

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The program produces a graphic display. It is also possible, as with <A HREF="#C:">C:</A>, to
    use the <A HREF="#INLINE">INLINE</A> command.

<B>Memo:</B> Registers a3 to a6 are saved/restored automatically by the compiler.
      If the array is to small, issues wrong error code (#16)<A HREF="#.">.</A>
      <A HREF="#DIM">DIM</A> asm%(15) is the bare minimum.
<HR SIZE=3><H2 ID="EXEC">EXEC</H2>
<A NAME="EXEC()"></A><B><A HREF="#EXEC">EXEC</A> mod,nam,cmdl,envs
ret=<A HREF="#EXEC">EXEC</A>(mod,nam,cmdl,envs)</B>

mod: <A HREF="#iexp">iexp</A>
ret: <A HREF="#ivar">ivar</A> (always use a long)
nam, cmdl, envs: <A HREF="#sexp">sexp</A>

<A HREF="#EXEC">EXEC</A> can be used as a command or as a function (returns a long)<A HREF="#.">.</A> It enables
the loading and starting of programs from disk, which return to the calling
program after completion. Before the <A HREF="#EXEC">EXEC</A> call, the calling program must have
allocated enough memory space for the program (see example)<A HREF="#.">.</A> The parameter
'mod' specifies the 'Call mode' as follows:

    0  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Load and Start program.
    3  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A>  Load program only.

The string expression 'nam' contains the file name of the program to be loaded
(and optionally started)<A HREF="#.">.</A> The format of the file name conforms to the rules of
the hierarchical filing system, described in <A HREF="#'">'</A><A HREF="#Chapter__6_-_Input_and_Output">Chapter  6 - Input and Output</A>'<A HREF="#.">.</A>

The expression 'cmdl' contains the command line, which is stored in the
<A HREF="#BASEPAGE">BASEPAGE</A> of the called program. The first character of the command line
contains it's length (maximum 127)<A HREF="#.">.</A> This is known as a Pascal style string.

The string 'envs' contains the Environment. This is a string terminated by
<A HREF="#CHR$">CHR$</A>(0)<A HREF="#.">.</A> The Environment is a series of strings, each terminated by CHR$(0).
THe Environment is used in different ways and varies depending on the program
being started.

If one calls <A HREF="#EXEC">EXEC</A> as a function, then one receives the program's returned
value, or, for mod=3, the address of the <A HREF="#BASEPAGE">BASEPAGE</A> of the called program. <A HREF="#EXEC">EXEC</A> 3
is only for special programs which include overlays, debugging programs etc.

<B>Example:</B>

    c$<A HREF="#=">=</A>"a:\imgage.pi1"                               !build command line
    cmd$<A HREF="#=">=</A><A HREF="#CHR$">CHR$</A>(<A HREF="#LEN">LEN</A>(c$))+c$                            <A HREF="#!">!</A>  pascal style string
    <A HREF="#'">'</A>
    env$<A HREF="#=">=</A>"SIZE=NORMAL"<A HREF="#+">+</A><A HREF="#CHR$">CHR$</A>(0)+"OUTPUT=NEO"+CHR$(0)  !environment string
    <A HREF="#'">'</A>
    f$<A HREF="#=">=</A>"c:\gfx\imgtool.prg"                          !program to be started
    <A HREF="#'">'</A>
    <A HREF="#RESERVE">RESERVE</A> 100
    <A HREF="#SHOWM">SHOWM</A>
    a%<A HREF="#=">=</A><A HREF="#EXEC">EXEC</A>(0,f$,cmd$,env$)
    <A HREF="#RESERVE">RESERVE</A>
    <A HREF="#PRINT">PRINT</A> "Back in GFA BASIC. Returned value=";a%

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> A program is loaded and called (if it does not require too much memory) and
    returns to the interpreter on completion. The returned value, which is
    returned by the <A HREF="#EXEC">EXEC</A> function, can also be given by <A HREF="#GFA-Basic">GFA-Basic</A> programs by
    terminating them with <A HREF="#QUIT">QUIT</A> n or <A HREF="#SYSTEM">SYSTEM</A> n.

<B>Memo:</B> At the moment a process is started the processor looks like this:
      d0-d7 -<A HREF="#&#62;">&#62;</A> <A HREF="#?">?</A>
      a0    <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> <A HREF="#BASEPAGE">BASEPAGE</A> - Application was started as a desk accossory (<A HREF="#&#60;">&#60;</A><A HREF="#&">&</A>#62;0)
      a1-a6 -<A HREF="#&#62;">&#62;</A> <A HREF="#?">?</A>
      a7    <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> End of application memory
      4(a7) <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> <A HREF="#BASEPAGE">BASEPAGE</A> - Application was started as a normal program

      Internally <A HREF="#EXEC">EXEC</A> will clip strings to the following limits:
        Editor:
          cmdl$ <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> 4000 characters
          encs$ <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> 4000 characters
        Library:
          cmdl$ <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> 200 characters
          envs$ <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> 2000 characters

       Internally <A HREF="#EXEC">EXEC</A> also terminates all 3 strings with a double NULL.
       This however doesn't seem matter.

       <A HREF="#EXEC">EXEC</A> is really a wrapper for Pexec(), but since the parameters are
       limited to strings, some modes cannot be called without using a custom
       binding.

Pexec()<A HREF="#+">+</A>, shel_write()+
<HR SIZE=3><H2 ID="Other_System-related_Commands">Other System-related Commands</H2>
<A NAME="TT?"></A><A NAME="STE?"></A><B><A HREF="#STE?">STE?</A>
<A HREF="#TT?">TT?</A></B>

These commands allow one to detect which hardware your <A HREF="#GFA-Basic">GFA-Basic</A> programs are
running on.

The function <A HREF="#STE?">STE?</A> returns the following:
    0 <A HREF="#=">=</A> Stereo 8-bit playback not available
    2 <A HREF="#=">=</A> Stereo 8-bit playback available

The function <A HREF="#TT?">TT?</A> returns the following:
    0 <A HREF="#=">=</A> 68000 (normal ST)
    1 <A HREF="#=">=</A> 68030 or 68020
    3 <A HREF="#=">=</A> 68881 or 68882 fitted

These functions will use the FPU: <A HREF="#SIN">SIN</A>, <A HREF="#COS">COS</A>, <A HREF="#TAN">TAN</A>, <A HREF="#EXP">EXP</A>, <A HREF="#LOG">LOG</A>, and <A HREF="#LOG10">LOG10</A>

<B>Example:</B>

    <A HREF="#PRINT">PRINT</A> <A HREF="#TT?">TT?</A> !Prints 3 if ran on an Atari TT030

<B>Memo:</B> These functions should not be used to determine what hardware an
      application might be running on, instead look in the system cookie jar.
      The cookie jar contains much more detailed information about the
      hardware.

      The <A HREF="#STE?">STE?</A> function doesn't seem to work as the documentation states.
      Original documentation states this:
      The function <A HREF="#STE?">STE?</A> returns -1 for STE (or TT), otherwise 0.

      The <A HREF="#TT?">TT?</A> function doesn't seem to work as the documentation states.
      Original documentation states this:
      The function <A HREF="#TT?">TT?</A> returns -1 for 68020 or 68030 processor, otherwise 0.

      The <A HREF="#TT?">TT?</A> function when compiled uses self modifying code and thus is
      rather unstable if used on a cpu (68040/060) with the caches enabled.

      These functions <A HREF="#SIN">SIN</A>, <A HREF="#COS">COS</A>, <A HREF="#TAN">TAN</A>, <A HREF="#EXP">EXP</A>, <A HREF="#LOG">LOG</A>, and <A HREF="#LOG10">LOG10</A> by default do not use
      the FPU even if its present.  The function <A HREF="#TT?">TT?</A> must be called at least
      once to activate the faster math functions.  It cannot be disabled once
      activated.  Example:

      <A HREF="#CLS">CLS</A>
      t=<A HREF="#TIMER">TIMER</A>
      <A HREF="#FOR">FOR</A> x=1 TO 65000
        y=<A HREF="#LOG">LOG</A>(x)
      <A HREF="#NEXT">NEXT</A> x
      <A HREF="#PRINT">PRINT</A> "time: "<A HREF="#;">;</A>(<A HREF="#TIMER">TIMER</A><A HREF="#-t">-t</A>)/200
      <A HREF="#~">~</A><A HREF="#TT?">TT?</A>                         !activate the faster math functions
      t=<A HREF="#TIMER">TIMER</A>
      <A HREF="#FOR">FOR</A> x=1 TO 65000
        y=<A HREF="#LOG">LOG</A>(x)
      <A HREF="#NEXT">NEXT</A> x
      <A HREF="#PRINT">PRINT</A> "time: "<A HREF="#;">;</A>(<A HREF="#TIMER">TIMER</A><A HREF="#-t">-t</A>)/200

The <A HREF="#Cookie_Jar">Cookie Jar</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="Chapter_11_-_AES_Libraries">Chapter 11 - AES Libraries</H2>
<A NAME="AES"></A><A NAME="GCONTRL"></A><A NAME="GINTIN"></A><A NAME="GINTOUT"></A><A NAME="ADDRIN"></A><A NAME="ADDROUT"></A><A NAME="GB"></A><A HREF="#GCONTRL">GCONTRL</A>, GCONTRL()
<A HREF="#GINTIN">GINTIN</A>, GINTIN()
<A HREF="#ADDRIN">ADDRIN</A>, ADDRIN()
<A HREF="#GINTOUT">GINTOUT</A>, GINTOUT()
<A HREF="#ADDROUT">ADDROUT</A>, ADDROUT()
<A HREF="#GEMSYS">GEMSYS</A>

This chapter gives an overview of the <A HREF="#AES_Library">AES Library</A> (<A HREF="#AES">AES</A> <A HREF="#=">=</A> Application
Environment Services)<A HREF="#.">.</A> A detailed description of these routines would be beyond
the scope of this manual (we refer the reader to the extensive literature
already published on GEM), hence information is given in compressed form, as
follows:

    a) The name of the appropriate library routine.
    b) A short description of the function.
    c) The complete GFA BASIC 3 syntax for the function call, with the meaning
       of all the applicable variables explained.

The chapter closes with longer example programs.

Before beginning the descriptions of the functions in the 11 <A HREF="#AES">AES</A> Libraries, it
is important that the reader becomes familiar with the most important data
structures used by the <A HREF="#AES">AES</A><A HREF="#.">.</A> These are the <A HREF="#OBJECT">OBJECT</A>, <A HREF="#TEDINFO">TEDINFO</A>, <A HREF="#ICONBLK">ICONBLK</A>, <A HREF="#CICONBLK">CICONBLK</A>,
<A HREF="#BITBLK">BITBLK</A>, <A HREF="#APPLBLK">APPLBLK</A>, and <A HREF="#PARMBLK">PARMBLK</A> structures.

The following <A HREF="#AES">AES</A> functions are implemented in a similar way to GFA BASIC
version 2:

    <A HREF="#GB">GB</A>
    <A HREF="#GCONTRL">GCONTRL</A>
    <A HREF="#GINTIN">GINTIN</A>
    <A HREF="#GINTOUT">GINTOUT</A>
    <A HREF="#ADDRIN">ADDRIN</A>
    <A HREF="#ADDROUT">ADDROUT</A>

They represent the addresses of the <A HREF="#AES">AES</A> parameter blocks. Specifically:

    <A HREF="#GB">GB</A>      <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> address of the <A HREF="#AES">AES</A> Parameter block
    <A HREF="#GCONTRL">GCONTRL</A> <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> address of the <A HREF="#AES">AES</A> Control block
    <A HREF="#GINTIN">GINTIN</A>  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> address of the <A HREF="#AES">AES</A> Integer Input block
    <A HREF="#GINTOUT">GINTOUT</A> <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> address of the <A HREF="#AES">AES</A> Integer Output block
    <A HREF="#ADDRIN">ADDRIN</A>  <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> address of the <A HREF="#AES">AES</A> Address Input block
    <A HREF="#ADDROUT">ADDROUT</A> <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> address of the <A HREF="#AES">AES</A> Address Output block

With an <A HREF="#index">index</A> in brackets after these functions, the appropriate parameter
positions within the block are accessed directly, for instance, x=<A HREF="#GCONTRL">GCONTRL</A>(3)
corresponds to x=<A HREF="#DPEEK">DPEEK</A>(<A HREF="#GCONTRL">GCONTRL</A>+6), or GCONTRL(3)=x corresponds to <A HREF="#DPOKE">DPOKE</A>
<A HREF="#GCONTRL">GCONTRL</A>+6,x.

<A HREF="#GCONTRL">GCONTRL</A>, <A HREF="#GINTIN">GINTIN</A>, and <A HREF="#GINTOUT">GINTOUT</A> expect words (2 bytes) as their parameters,
whereas <A HREF="#ADDRIN">ADDRIN</A> and <A HREF="#ADDROUT">ADDROUT</A> expect long words (4 bytes)<A HREF="#.">.</A> So ADDRIN(2)=x
corresponds to <A HREF="#LPOKE">LPOKE</A> <A HREF="#ADDRIN">ADDRIN</A>+2*4,x.

The <A HREF="#GB">GB</A> block address cannot be used with an <A HREF="#index">index</A>, on grounds of compatibility
with ST-BASIC; with <A HREF="#GINTIN">GINTIN</A> etc. indices are available. For example, the second
long word in the <A HREF="#GB">GB</A> block ({GB+4}) is the address of the GEM internal global
array.

<B>Memo:</B> Not all TOS machines have the same <A HREF="#AES">AES</A> version so care should be
      taken when calling these functions. For the most part all <A HREF="#AES">AES</A> calls in
      <A HREF="#GFA-Basic">GFA-Basic</A> work fine except a few. Functions denoted in lower case are not
      built into <A HREF="#GFA-Basic">GFA-Basic</A><A HREF="#.">.</A>

      These tables have the following limits:
      <A HREF="#GCONTRL">GCONTRL</A>(0-5)
      <A HREF="#GINTIN">GINTIN</A>(0-19)
      <A HREF="#GINTOUT">GINTOUT</A>(0-19)
      <A HREF="#ADDRIN">ADDRIN</A>(0-9)
      <A HREF="#ADDROUT">ADDROUT</A>(0-9)

      <A HREF="#GB">GB</A> (GEM Base) consists of the following pointers:
      <A HREF="#GB">GB</A>  +0 <A HREF="#GCONTRL">GCONTRL</A>    6 words
      <A HREF="#GB">GB</A>  +4 global    15 words  (0-14)
      <A HREF="#GB">GB</A>  +8 <A HREF="#GINTIN">GINTIN</A>    20 words
      <A HREF="#GB">GB</A> +12 <A HREF="#GINTOUT">GINTOUT</A>   20 words
      <A HREF="#GB">GB</A> +16 <A HREF="#ADDRIN">ADDRIN</A>    10 longs
      <A HREF="#GB">GB</A> +20 <A HREF="#ADDROUT">ADDROUT</A>   10 longs
      <A HREF="#GB">GB</A> +24 <A HREF="#CONTRL">CONTRL</A>    12 words
      <A HREF="#GB">GB</A> +28 <A HREF="#INTIN">INTIN</A>    128 words
      <A HREF="#GB">GB</A> +32 <A HREF="#PTSIN">PTSIN</A>    256 words
      <A HREF="#GB">GB</A> +36 <A HREF="#INTOUT">INTOUT</A>   128 words
      <A HREF="#GB">GB</A> +40 <A HREF="#PTSOUT">PTSOUT</A>   256 words
      <A HREF="#GB">GB</A> +44 gcontrl    6 words
      <A HREF="#GB">GB</A> +48 global    15 words  (shared, same as GB+4)
      <A HREF="#GB">GB</A> +52 gintin    20 words
      <A HREF="#GB">GB</A> +56 gintout   20 words
      <A HREF="#GB">GB</A> +60 addrin    10 longs
      <A HREF="#GB">GB</A> +64 addrout   10 longs
      <A HREF="#GB">GB</A> +68 contrl    12 words
      <A HREF="#GB">GB</A> +72 intin    128 words
      <A HREF="#GB">GB</A> +76 ptsin    256 words
      <A HREF="#GB">GB</A> +80 intout   128 words
      <A HREF="#GB">GB</A> +84 ptsout    30 words

<B>Memo:</B> Example how to access the <A HREF="#AES">AES</A> Global array:
      bit_planes&<A HREF="#=">=</A><A HREF="#WORD">WORD</A>{<A HREF="#LONG">LONG</A>{<A HREF="#GB">GB</A>+4}+20}
      rsrc_base%<A HREF="#=">=</A><A HREF="#LONG">LONG</A>{LONG{<A HREF="#GB">GB</A>+4}+10}
      mtos_!<A HREF="#=">=</A><A HREF="#WORD">WORD</A>{<A HREF="#LONG">LONG</A>{<A HREF="#GB">GB</A>+4}+2}<A HREF="#&#60;">&#60;</A><A HREF="#&">&</A>#62;1     !false=SingleTOS/true=multi-tasking

      ST-BASIC originally defined <A HREF="#GB">GB</A> as only 24 bytes (6 longs)<A HREF="#.">.</A>

      The compiler only initializes the <A HREF="#AES">AES</A> if some module is linked that
      actually calls the <A HREF="#AES">AES</A><A HREF="#.">.</A> The editor on the other hand always does this.
      If you suspect the <A HREF="#AES">AES</A> is not initialized it can be forced with a
      call to any <A HREF="#AES">AES</A> function. I suggest using some inquire function like
      <A HREF="#GRAF_HANDLE">GRAF_HANDLE</A><A HREF="#()">()</A><A HREF="#.">.</A>

      <A HREF="#GEMSYS">GEMSYS</A> 'n' will only look up table values for <A HREF="#AES">AES</A> opcodes 10 to 131.
      If its outside this range <A HREF="#GCONTRL">GCONTRL</A>(1-3) will not be auto-filled.

      Some of these arrays appear to be larger than needed. Per TOS 4.04 sources:
      <A HREF="#GCONTRL">GCONTRL</A>(0-4)  The <A HREF="#AES">AES</A> never uses <A HREF="#index">index</A> 5.
      GLOBAL(0-14)  Exactly 15 words.
      <A HREF="#GINTIN">GINTIN</A>(0-15)  <A HREF="#EVNT_MULTI">EVNT_MULTI</A><A HREF="#()">()</A> has the most input parameters (16)<A HREF="#.">.</A>
      <A HREF="#GINTOUT">GINTOUT</A>(0-6)  <A HREF="#EVNT_MULTI">EVNT_MULTI</A><A HREF="#()">()</A> has the most output parameters (7)<A HREF="#.">.</A>
      <A HREF="#ADDRIN">ADDRIN</A>(0-1)   Several calls use indexes 0 and 1.
      <A HREF="#ADDROUT">ADDROUT</A>(0)    <A HREF="#RSRC_GADDR">RSRC_GADDR</A><A HREF="#()">()</A> is the only call that uses <A HREF="#index">index</A> 0.

      <A HREF="#GB">GB</A> pointers +44 and on were never documented. These are GFA's internal
      <A HREF="#AES">AES</A> and <A HREF="#VDI">VDI</A> paremeter blocks. They are used for all the built in
      commands and functions. You can easily inquire the results of any built
      in commnad or function with these pointers and avoid having to use
      custom bindings. See <A HREF="#POINT">POINT</A><A HREF="#()">()</A> for an example.

      If maximum speed is your goal, then use these:
        <A HREF="#INTIN">INTIN</A>(ndx)=val
        <A HREF="#WORD">WORD</A>{<A HREF="#INTIN">INTIN</A>+ndx}=val   !slightly faster

        val=<A HREF="#INTOUT">INTOUT</A>(ndx)       !slightly faster
        val=<A HREF="#WORD">WORD</A>{<A HREF="#INTOUT">INTOUT</A>+ndx}

appl_init()<A HREF="#+">+</A>, <A HREF="#AES">AES</A>+, AES Functions by Opcode+
<HR SIZE=3><H2 ID="GEMSYS">GEMSYS</H2>
<B><A HREF="#GEMSYS">GEMSYS</A> [n]</B>

n: <A HREF="#iexp">iexp</A>

The commnad <A HREF="#GEMSYS">GEMSYS</A> calls an <A HREF="#AES">AES</A> routine by specifying the routine number n.
The parameters necessary for the operation of the routine must first be placed
in the appropriate <A HREF="#AES">AES</A> parameter blocks.

<B>Example:</B>

    <A HREF="#REPEAT">REPEAT</A>
      <A HREF="#GINTIN">GINTIN</A>(0)=60
      <A HREF="#GINTIN">GINTIN</A>(1)=30
      <A HREF="#GINTIN">GINTIN</A>(2)=10
      <A HREF="#GINTIN">GINTIN</A>(3)=10
      <A HREF="#GINTIN">GINTIN</A>(4)=200
      <A HREF="#GINTIN">GINTIN</A>(5)=200
      <A HREF="#GEMSYS">GEMSYS</A> 72
    <A HREF="#UNTIL">UNTIL</A> <A HREF="#MOUSEK">MOUSEK</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> A moving rectangle is drawn on the screen, as function number 72 is
    <A HREF="#GRAF_MOVEBOX">GRAF_MOVEBOX</A><A HREF="#()">()</A><A HREF="#.">.</A>

<B>Memo:</B> The parameter n is optional. If parameter n is omitted then the
      necessary parameters for the call must be place in the <A HREF="#GCONTRL">GCONTRL</A><A HREF="#()">()</A>
      parameter block. See <A HREF="#appl_search">appl_search</A><A HREF="#()">()</A> for an example listing. Calling a
      function which does not exist is usually fatal.

      <A HREF="#'">'</A> example #1: with parameter, GFA fills in the <A HREF="#GCONTRL">GCONTRL</A><A HREF="#()">()</A> array itself
      <A HREF="#'">'</A> method: short form
      <A HREF="#FUNCTION">FUNCTION</A> graf_mouse(mode&,ptr%)
        <A HREF="#GINTIN">GINTIN</A>(0)=mode&
        <A HREF="#ADDRIN">ADDRIN</A>(0)=ptr%
        <A HREF="#GEMSYS">GEMSYS</A> 78                      !opcode
        <A HREF="#RETURN">RETURN</A> <A HREF="#GINTOUT">GINTOUT</A>(0)
      <A HREF="#ENDFUNC">ENDFUNC</A>

      <A HREF="#.">.</A>.. versus ...

      <A HREF="#'">'</A> example #2: with no parameter, <A HREF="#GCONTRL">GCONTRL</A><A HREF="#()">()</A> values must be supplied
      <A HREF="#'">'</A> method: long form
      <A HREF="#FUNCTION">FUNCTION</A> graf_mouse(mode&,ptr%)
        <A HREF="#GCONTRL">GCONTRL</A>(0)=78                  !opcode
        <A HREF="#GCONTRL">GCONTRL</A>(1)=1                   !number of <A HREF="#GINTIN">GINTIN</A><A HREF="#()">()</A> input parameters
        <A HREF="#GCONTRL">GCONTRL</A>(2)=1                   !number of <A HREF="#GINTOUT">GINTOUT</A><A HREF="#()">()</A> output parameters
        <A HREF="#GCONTRL">GCONTRL</A>(3)=1                   !number of <A HREF="#ADDRIN">ADDRIN</A><A HREF="#()">()</A> input paramerers
        <A HREF="#GCONTRL">GCONTRL</A>(4)=0                   !number of <A HREF="#ADDROUT">ADDROUT</A><A HREF="#()">()</A> output parameters
        <A HREF="#GINTIN">GINTIN</A>(0)=mode&
        <A HREF="#ADDRIN">ADDRIN</A>(0)=ptr%
        <A HREF="#GEMSYS">GEMSYS</A>
        <A HREF="#RETURN">RETURN</A> <A HREF="#GINTOUT">GINTOUT</A>(0)
      <A HREF="#ENDFUNC">ENDFUNC</A>

      Generates less code: short form
      Faster interpreted: short form
      Faster compiled: short form

      GFA fetches the <A HREF="#GCONTRL">GCONTRL</A><A HREF="#()">()</A> values from a built-in table. The table
      entries are null for all <A HREF="#AES">AES</A> calls not supported by GFA at the time of
      its release. Thus, if want to call any newer <A HREF="#AES">AES</A> routines, you must not
      pass an opcode via <A HREF="#GEMSYS">GEMSYS</A><A HREF="#.">.</A> Example #2 format must be use in this case.

      According TOS.HYP, <A HREF="#GCONTRL">GCONTRL</A>(2) and GCONTRL(4) are not needed. This
      appears to be true for newer <A HREF="#AES">AES</A> implementations, like <A HREF="#N.AES">N.AES</A>, but not
      for older TOS versions.

      Opcodes that should not be used with <A HREF="#GEMSYS">GEMSYS</A> n (with a parameter)<A HREF="#:">:</A>
      16
      18
      27 to 29
      36 to 39
      48 to 49
      57 to 69
      82 to 89
      92 to 99
      115 to 119
      127 to 131
      These fill the <A HREF="#GCONTRL">GCONTRL</A><A HREF="#()">()</A> entries 1 to 3 with incorrect values.
      <A HREF="#GCONTRL">GCONTRL</A>(4) is left untouched.

      According to the TOS 4.04 source code (see GEMBIND.S) <A HREF="#GCONTRL">GCONTRL</A>(4) is not
      actually used. GFA exploits this fact.
<HR SIZE=3><H2 ID="Object_Structure">Object Structure</H2>
<A NAME="OBJECT"></A><A NAME="OB_NEXT"></A><A NAME="OB_HEAD"></A><A NAME="OB_TAIL"></A><A NAME="OB_TYPE"></A><A NAME="OB_FLAGS"></A><A NAME="OB_STATE"></A><A NAME="OB_SPEC"></A><A NAME="OB_X"></A><A NAME="OB_Y"></A><A NAME="OB_W"></A><A NAME="OB_H"></A><A NAME="OB_ADR"></A>    <B>Offset  Name      Type  Meaning</B>
    00      ob_next   word  pointer to the next object
    02      ob_head   word  pointer to the first child
    04      ob_tail   word  pointer to the last child
    06      ob_type   word  type of object
    08      ob_flags  word  object information (see below)
    10      ob_state  word  status of the object (see below)
    12      ob_spec   long  pointer to further information (see below)
    16      ob_x      word  x-position of the object
    18      ob_y      word  y-position of the object
    20      ob_w      word  width of the object
    22      ob_h      word  height of the object

So the memory requirements of an object are these 24 bytes plus further
descriptive structures, e.g. <A HREF="#TEDINFO">TEDINFO</A> or <A HREF="#BITBLK">BITBLK</A> structures.

<A HREF="#OB_NEXT">OB_NEXT</A> points to the following object on the same level, or, if it is the last
        object on that level, to the parent object, or contains -1 if none.

<A HREF="#OB_HEAD">OB_HEAD</A> points to the object's first child, or contains -1 if none.

<A HREF="#OB_TAIL">OB_TAIL</A> points to the object's last child, or contains -1 if none.

The value -1 in this context is also referred to as NIL (Not In List)<A HREF="#.">.</A>

Depending on the value in <A HREF="#OB_TYPE">OB_TYPE</A>, <A HREF="#OB_SPEC">OB_SPEC</A> has the address of different data
structures, as shown in the following table:

    <B><A HREF="#OB_TYPE">OB_TYPE</A>  Name        <A HREF="#OB_SPEC">OB_SPEC</A></B>
    20       G_BOX       BOX information, see below
    21       G_TEXT      Pointer to <A HREF="#TEDINFO">TEDINFO</A> graphic text
    22       G_BOXTEXT   Pointer to <A HREF="#TEDINFO">TEDINFO</A> text-in-a-box
    23       G_IMAGE     Pointer to <A HREF="#BITBLK">BITBLK</A> bit image graphic
    24       G_USERDEF   Pointer to <A HREF="#APPLBLK">APPLBLK</A> structure
    25       G_IBOX      BOX information, see below.
    26       G_BUTTON    Pointer to centered C-string, to go in a box
    27       G_BOXCHAR   BOX information, see below.
    28       G_STRING    Pointer to C-string menu item structure
    29       G_FTEXT     Pointer to <A HREF="#TEDINFO">TEDINFO</A> editable graphic text
    30       G_FBOXTEXT  Pointer to <A HREF="#TEDINFO">TEDINFO</A> editable text-in-a-box
    31       G_ICON      Pointer to <A HREF="#ICONBLK">ICONBLK</A> structure
    32       G_TITLE     Pointer to C-string menu title structure
    33       G_CICON     Pointer to <A HREF="#CICONBLK">CICONBLK</A> structure (<A HREF="#AES">AES</A> <A HREF="#=&#62;">=&#62;</A> v3.3)

For G_BOX, G_IBOX and G_BOXCHAR, <A HREF="#OB_SPEC">OB_SPEC</A> contains information concerning
character-content, border-type and color of the appropriate object. The upper 8
bits are only used by G_BOXCHAR and contain the <A HREF="#ASCII">ASCII</A> code of the character to
appear in the box.

They contain the following values for the border:

             0 <A HREF="#=">=</A> no border
     1 to  128 <A HREF="#=">=</A> the border extends 1 to 128 pixels inside the object
    -1 to -128 <A HREF="#=">=</A> the border extends 1 to 128 pixels outside the object

The bit allocation for the object color word is:

    1111 2222 3444 5555

where:

    1 <A HREF="#=">=</A> Border color (0 to 15)
    2 <A HREF="#=">=</A> Text color (0 to 15)
    3 <A HREF="#=">=</A> Text mode (0 = transparent, 1 = overwritten)
    4 <A HREF="#=">=</A> Fill pattern (0 to 7)
    5 <A HREF="#=">=</A> Color of object interior (0 to 15)

    <B><A HREF="#OB_FLAGS">OB_FLAGS</A>    Hex     Bit</B>
    NORMAL      &H0000  <A HREF="#-">-</A>
    SELECTABLE  &H0001  0
    <A HREF="#DEFAULT">DEFAULT</A>     &H0002  1
    EXIT        &H0004  2
    EDITABLE    &H0008  3
    RBUTTON     &H0010  4
    LASTOB      &H0020  5
    TOUCHEXIT   &H0040  6
    HIDETREE    &H0080  7
    INDIRECT    &H0100  8

    <B><A HREF="#OB_STATE">OB_STATE</A>  Hex     Bit</B>
    NORMAL    &H0000  <A HREF="#-">-</A>
    SELECTED  &H0001  0
    CROSSED   &H0002  1
    CHECKED   &H0004  2
    DISABLED  &H0008  3
    OUTLINED  &H0010  4
    SHADOWED  &H0020  5

The structures described in the preceding section are addressed in <A HREF="#GFA-Basic">GFA-Basic</A> 3
with the following syntax (for both reading and writing)<A HREF="#:">:</A>

    <A HREF="#OB_NEXT">OB_NEXT</A>(tree%,obj&)
    <A HREF="#OB_HEAD">OB_HEAD</A>(tree%,obj&)
    <A HREF="#OB_TAIL">OB_TAIL</A>(tree%,obj&)
    <A HREF="#OB_TYPE">OB_TYPE</A>(tree%,obj&)
    <A HREF="#OB_FLAGS">OB_FLAGS</A>(tree%,obj&)
    <A HREF="#OB_STATE">OB_STATE</A>(tree%,obj&)
    <A HREF="#OB_SPEC">OB_SPEC</A>(tree%,obj&)
    <A HREF="#OB_X">OB_X</A>(tree%,obj&)
    <A HREF="#OB_Y">OB_Y</A>(tree%,obj&)
    <A HREF="#OB_W">OB_W</A>(tree%,obj&)
    <A HREF="#OB_H">OB_H</A>(tree%,obj&)
    <A HREF="#OB_ADR">OB_ADR</A>(tree%,obj&)   !only works as a function

<A HREF="#.">.</A>..where tree% is the address of the object tree and obj& the object number.
In addition the address of an individual object can be determined with
address=<A HREF="#OB_ADR">OB_ADR</A>(tree%,obj&)<A HREF="#.">.</A>

<B>Memo:</B> <A HREF="#OB_TYPE">OB_TYPE</A><A HREF="#()">()</A> always reads and writes a word value. The following
      code can be used to read/write the extended and standard object types
      seperately.

<A HREF="#'">'</A> read/write extended object type
<A HREF="#FUNCTION">FUNCTION</A> ob_extype(tr%,ob&)
  <A HREF="#$F%">$F%</A>
  <A HREF="#RETURN">RETURN</A> <A HREF="#BYTE">BYTE</A>{tr%<A HREF="#+">+</A><A HREF="#MUL">MUL</A>(ob&,24)+6}
<A HREF="#ENDFUNC">ENDFUNC</A>
<A HREF="#PROCEDURE">PROCEDURE</A> ob_extype(tr%,ob&,ty&)
  <A HREF="#BYTE">BYTE</A>{tr%<A HREF="#+">+</A><A HREF="#MUL">MUL</A>(ob&,24)+6}=ty&
<A HREF="#RETURN">RETURN</A>
<A HREF="#'">'</A> read/write standard object type
<A HREF="#FUNCTION">FUNCTION</A> ob_type(tr%,ob&)
  <A HREF="#$F%">$F%</A>
  <A HREF="#RETURN">RETURN</A> <A HREF="#BYTE">BYTE</A>{tr%<A HREF="#+">+</A><A HREF="#MUL">MUL</A>(ob&,24)+7}
<A HREF="#ENDFUNC">ENDFUNC</A>
<A HREF="#PROCEDURE">PROCEDURE</A> ob_type(tr%,ob&,ty&)
  <A HREF="#BYTE">BYTE</A>{tr%<A HREF="#+">+</A><A HREF="#MUL">MUL</A>(ob&,24)+7}=ty&
<A HREF="#RETURN">RETURN</A>

<A HREF="#OBJECT">OBJECT</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="Text_Data_Structure_(TEDINFO)">Text Data Structure (TEDINFO)</H2>
<A NAME="TEDINFO"></A><B>Offset  Name          Type  Meaning</B>
00      te_ptext      long  Pointer to text
04      te_ptmplt     long  Pointer to text mask
08      te_pvaiid     long  Pointer to validation string for input
12      te_font       word  Font
14      te_resvd      word  -reserved-
16      te_just       word  Text justification
18      te_color      word  Color of the surrounding box
20      te_resvd2     word  -reserved-
22      te_thickness  word  Character thickness
24      te_txtlen     word  Text length
26      te_tmplen     word  Text mask length

<A HREF="#TEDINFO">TEDINFO</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="Icon_Data_Structure_(ICONBLK)">Icon Data Structure (ICONBLK)</H2>
<A NAME="ICONBLK"></A><B>Offset  Name      Type  Meaning</B>
00      ib_pmask  long  Pointer to icon mask
04      ib_pdata  long  Pointer to icon data
08      ib_ptext  long  Pointer to icon text
12      ib_char   word  The single character within the icon
14      ib_xchar  word  x-position of the character relative to icon origin
16      ib_ychar  word  y-position of the character relative to icon origin
18      ib_xicon  word  x-position of the icon relative to icon origin
20      ib_yicon  word  y-position of the icon relative to icon origin
22      ib_wicon  word  Width of the icon
24      ib_hicon  word  Height of the icon
26      ib_xtext  word  x-position of the text relative to icon origin
28      ib_ytext  word  y-position of the text relative to icon origin
30      ib_wtext  word  Text width in pixels
32      ib_htext  word  Text height in pixels
34      ib_resvd  word  -reserved-

<B>Memo:</B> To display an icon without a text label set the x/y of the text
      beyond the clipping rectangle.

<A HREF="#ICONBLK">ICONBLK</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="Bit_Image_Block_Structure_(BITBLK)">Bit Image Block Structure (BITBLK)</H2>
<A NAME="BITBLK"></A><B>Offset  Name      Type  Meaning</B>
00      bi_pdata  long  Pointer to image data
04      bi_wb     word  Width of the image in bytes
06      bi_hi     word  Height of the image in pixels
08      bi_x      word  x-position of the image
10      bi_y      word  y-position of the image
12      bi_color  word  Image color

<A HREF="#BITBLK">BITBLK</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="Application_Block_Structure_(APPLBLK)">Application Block Structure (APPLBLK)</H2>
<A NAME="APPLBLK"></A><B>Offset  Name     Type  Meaning</B>
00      ab_code  long  Pointer to a user assembly language routine to draw the
                       object.
04      ab_parm  long  Pointer to a <A HREF="#PARMBLK">PARMBLK</A> structure.

<A HREF="#APPLBLK">APPLBLK</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="Parameter_Block_Structure_(PARMBLK)">Parameter Block Structure (PARMBLK)</H2>
<A NAME="PARMBLK"></A><B>Offset  Name          Type  Meaning</B>
00      pb_tree       long  Pointer to object tree
04      pb_obj        word  Object number
06      pb_prevstate  word  Previous status
08      pb_currstate  word  Current status
10      pb_x          word  x-position of object
12      pb_y          word  y-position of object
14      pb_w          word  Width of object
16      pb_h          word  Height of object
18      pb_xc         word  x-position of clipping rectangle
20      pb_yc         word  y-position of clipping rectangle
22      pb_wc         word  Width of the clipping rectangle
24      pb_hc         word  Height of the clipping rectangle
28      pb_parm       long  Parameter from the <A HREF="#APPLBLK">APPLBLK</A> structure

It should be noted that some functions return not only a function value, but
also return values in variables made available for that purpose. If the
function value is to be ignored, then the function should be called with <A HREF="#VOID">VOID</A>
or its abbreviation <A HREF="#'">'</A><A HREF="#~">~</A>'<A HREF="#.">.</A> (In the same way as for the <A HREF="#INP()">INP()</A> function: the
returned function value may be printed with <A HREF="#PRINT">PRINT</A> <A HREF="#INP">INP</A>(2), or ignored with
<A HREF="#~">~</A><A HREF="#INP">INP</A>(2)<A HREF="#.">.</A>) When parameters have to indicate addresses, at least 4-byte long
variable types must be used, and coordinate entries must take place in variable
types of at least 2 bytes (word or greater)<A HREF="#.">.</A>

<A HREF="#PARMBLK">PARMBLK</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="Color_Icon_Data_Structure_(CICONBLK)">Color Icon Data Structure (CICONBLK)</H2>
<A NAME="CICONBLK"></A><B>Offset  Name      Type  Meaning</B>
00      monoblk   <A HREF="#-">-</A>---  Same structure as an <A HREF="#ICONBLK">ICONBLK</A>
<A HREF="#.">.</A>.
34      mainlist  long  Pointer to linked list (<A HREF="#CICON">CICON</A> structure)

<A HREF="#CICONBLK">CICONBLK</A><A HREF="#+">+</A>, ciconblk+
<HR SIZE=3><H2 ID="Color_Icon_Structure_(CICON)">Color Icon Structure (CICON)</H2>
<A NAME="CICON"></A><B>Offset  Name          Type  Meaning</B>
00      num_planes    word  Bit planes
02      col_data      long  Pointer to unselected data
06      col_mask      long  Pointer to unselected mask
10      sel_data      long  Pointer to selected data
14      sel_mask      long  Pointer to selected mask
18      next_res      long  Pointer to next <A HREF="#CICON">CICON</A> structure (null <A HREF="#=">=</A> end list)

<A HREF="#CICON">CICON</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="Application_Services_Library">Application Services Library</H2>
<A HREF="#appl_control">appl_control</A><A HREF="#()">()</A>
<A HREF="#APPL_EXIT">APPL_EXIT</A><A HREF="#()">()</A>
<A HREF="#APPL_FIND">APPL_FIND</A><A HREF="#()">()</A>
<A HREF="#appl_getinfo">appl_getinfo</A><A HREF="#()">()</A>
<A HREF="#APPL_INIT">APPL_INIT</A><A HREF="#()">()</A>
<A HREF="#APPL_READ">APPL_READ</A><A HREF="#()">()</A>
<A HREF="#appl_search">appl_search</A><A HREF="#()">()</A>
<A HREF="#APPL_TPLAY">APPL_TPLAY</A><A HREF="#()">()</A>
<A HREF="#APPL_TRECORD">APPL_TRECORD</A><A HREF="#()">()</A>
<A HREF="#APPL_WRITE">APPL_WRITE</A><A HREF="#()">()</A>
<A HREF="#appl_yield">appl_yield</A>
<A HREF="#_appl_yield">_appl_yield</A>

The <A HREF="#Application_Services_Library">Application Services Library</A> controls the accessing of other <A HREF="#AES">AES</A> libraries.
The functions <A HREF="#APPL_INIT">APPL_INIT</A><A HREF="#()">()</A> and <A HREF="#APPL_EXIT">APPL_EXIT</A>() are called automatically by <A HREF="#GFA-Basic">GFA-Basic</A>
when a program is started or ended.

<A HREF="#Application_Services_Library">Application Services Library</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="appl_control">appl_control</H2>
<B><A HREF="#appl_control">appl_control</A><A HREF="#()">()</A></B>

<B>Memo:</B> This call is not built into <A HREF="#GFA-Basic">GFA-Basic</A> so it's listed below:

<A HREF="#FUNCTION">FUNCTION</A> <A HREF="#appl_control">appl_control</A>(ap_cid&,ap_cwhat&,<A HREF="#VAR">VAR</A> ap_cout%)
  <A HREF="#$F%">$F%</A>
  <A HREF="#GCONTRL">GCONTRL</A>(0)=129
  <A HREF="#GCONTRL">GCONTRL</A>(1)=2
  <A HREF="#GCONTRL">GCONTRL</A>(2)=1
  <A HREF="#GCONTRL">GCONTRL</A>(3)=1
  <A HREF="#GCONTRL">GCONTRL</A>(4)=0
  <A HREF="#GINTIN">GINTIN</A>(0)=ap_cid&
  <A HREF="#GINTIN">GINTIN</A>(1)=ap_cwhat&
  <A HREF="#ADDRIN">ADDRIN</A>(0)=V:ap_cout%
  <A HREF="#GEMSYS">GEMSYS</A>
  <A HREF="#RETURN">RETURN</A> <A HREF="#GINTOUT">GINTOUT</A>(0)
<A HREF="#ENDFUNC">ENDFUNC</A>
<HR SIZE=3><H2 ID="APPL_EXIT">APPL_EXIT</H2>
<B><A HREF="#APPL_EXIT">APPL_EXIT</A><A HREF="#()">()</A></B>

<A HREF="#APPL_EXIT">APPL_EXIT</A><A HREF="#()">()</A> informs the system that the program (application) has finished,
causing its identification number to be released and made available for other
programs.

<A HREF="#APPL_EXIT">APPL_EXIT</A><A HREF="#()">()</A> exists in <A HREF="#GFA-Basic">GFA-Basic</A> only as a dummy function, since a <A HREF="#QUIT">QUIT</A> or
<A HREF="#SYSTEM">SYSTEM</A> command accomplishes this automatically.

In case of error, 0 is returned.

appl_exit()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="APPL_FIND">APPL_FIND</H2>
<B><A HREF="#APPL_FIND">APPL_FIND</A>(fname$)</B>

fname$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>

The identification number of another application in the system is determined
from its file name, e.g. for information exchange with other current programs.

    fname$ <A HREF="#-">-</A> The 8-character file name (without extension) of the sought-after
             application. The file name supplied must be exactly 8 characters
             long, if necessary padded out with spaces, and characters must be
             in upper case.

If no error occurs, the requested ID is returned, otherwise (if the application
is not found), -1 is returned.

<B>Example:</B>

    <A HREF="#PRINT">PRINT</A> <A HREF="#APPL_FIND">APPL_FIND</A>("CONTROL ")

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Prints '65535' (-1) if the Control desk <A HREF="#accessory">accessory</A> cannot be found. If it is
    found, the ID number (e.g. 2) is printed. Besides Accessories, one can also
    find the ID of <A HREF="#GFA-Basic">GFA-Basic</A> (ap_id=0) and the screen manager "SCRENMGR"
    (ap_id=1), which is responsible for the menu handling.

<B>Memo:</B> Due to the string parameter, a custom binding is required to use the
      <A HREF="#AES">AES</A> v4.1 extended options.

<A HREF="#FUNCTION">FUNCTION</A> appl_find(fname%)
  <A HREF="#$F%">$F%</A>
  <A HREF="#ADDRIN">ADDRIN</A>(0)=fname%
  <A HREF="#GEMSYS">GEMSYS</A> 13 !auto fill gcontrl()
  <A HREF="#RETURN">RETURN</A> <A HREF="#GINTOUT">GINTOUT</A>(0)
<A HREF="#ENDFUNC">ENDFUNC</A>

appl_find()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="appl_getinfo">appl_getinfo</H2>
<B><A HREF="#appl_getinfo">appl_getinfo</A>(type,out1,out2,out4,out4)</B>

type: <A HREF="#iexp">iexp</A>
out1, out2, out3, out4: <A HREF="#ivar">ivar</A>

This call returns information about the <A HREF="#AES">AES</A><A HREF="#.">.</A>

    type <A HREF="#-">-</A> Specifies the type of information to be returned.
    out1 <A HREF="#-">-</A> Requested information is returned in this variable.
    out2 <A HREF="#-">-</A> Requested information is returned in this variable.
    out3 <A HREF="#-">-</A> Requested information is returned in this variable.
    out4 <A HREF="#-">-</A> Requested information is returned in this variable.

Returns 1 if an error occured or 0 otherwise.

<B>Note:</B> <A HREF="#appl_getinfo">appl_getinfo</A><A HREF="#()">()</A> returns different values for different <A HREF="#AES">AES</A> verisons
      so one should seek the proper documentation before using this call.

<B>Memo:</B> This call is not bulit into <A HREF="#GFA-Basic">GFA-Basic</A> so it is included below:

<A HREF="#FUNCTION">FUNCTION</A> <A HREF="#appl_getinfo">appl_getinfo</A>(gtype&,<A HREF="#VAR">VAR</A> gout1&,gout2&,gout3&,gout4&)
  <A HREF="#$F%">$F%</A>
  <A HREF="#GCONTRL">GCONTRL</A>(0)=130
  <A HREF="#GCONTRL">GCONTRL</A>(1)=1
  <A HREF="#GCONTRL">GCONTRL</A>(2)=5
  <A HREF="#GCONTRL">GCONTRL</A>(3)=0
  <A HREF="#GCONTRL">GCONTRL</A>(4)=0
  <A HREF="#GINTIN">GINTIN</A>(0)=gtype&
  <A HREF="#GEMSYS">GEMSYS</A>
  gout1&<A HREF="#=">=</A><A HREF="#GINTOUT">GINTOUT</A>(1)
  gout2&<A HREF="#=">=</A><A HREF="#GINTOUT">GINTOUT</A>(2)
  gout3&<A HREF="#=">=</A><A HREF="#GINTOUT">GINTOUT</A>(3)
  gout4&<A HREF="#=">=</A><A HREF="#GINTOUT">GINTOUT</A>(4)
  <A HREF="#RETURN">RETURN</A> <A HREF="#GINTOUT">GINTOUT</A>(0)
<A HREF="#ENDFUNC">ENDFUNC</A>

<A HREF="#appl_getinfo">appl_getinfo</A><A HREF="#()">()</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="APPL_INIT">APPL_INIT</H2>
<B><A HREF="#APPL_INIT">APPL_INIT</A><A HREF="#()">()</A></B>

Returns the identicifation number (ap_id) of the application (program)<A HREF="#.">.</A>

The current program is announced as an application. The function <A HREF="#APPL_INIT">APPL_INIT</A><A HREF="#()">()</A>
returns an Application ID that acts as the 'handle' of the current <A HREF="#GFA-Basic">GFA-Basic</A>
program. This identification number is, for example, important for the
installation of additional fonts.

<A HREF="#APPL_INIT">APPL_INIT</A><A HREF="#()">()</A> is used for <A HREF="#APPL_READ">APPL_READ</A>(), <A HREF="#APPL_WRITE">APPL_WRITE</A>(), and <A HREF="#MENU_REGISTER">MENU_REGISTER</A>()<A HREF="#.">.</A>

This function in <A HREF="#GFA-Basic">GFA-Basic</A> is a dummy function, which carries out no operating
system call, since <A HREF="#APPL_INIT">APPL_INIT</A><A HREF="#()">()</A> is already impemented by the start of the
<A HREF="#GFA-Basic">GFA-Basic</A> interpreter.

This call does the same as appl_id&<A HREF="#=">=</A><A HREF="#WORD">WORD</A>{<A HREF="#LONG">LONG</A>{<A HREF="#GB">GB</A>+4}+4}

<B>Memo:</B> See <A HREF="#GB">GB</A> for information on accessing the <A HREF="#AES">AES</A> Global array.
      Auto folder detection:
        If <A HREF="#APPL_INIT">APPL_INIT</A><A HREF="#()">()</A> <A HREF="#=">=</A> 0 then GEM is not initialized.
      Desk ACC detection:
        dacc_!<A HREF="#=">=</A><A HREF="#LONG">LONG</A>{<A HREF="#ADD">ADD</A>(<A HREF="#BASEPAGE">BASEPAGE</A>,36)}=<A HREF="#FALSE">FALSE</A> !desk acc flag [false=prg true=acc]

appl_init()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="APPL_READ">APPL_READ</H2>
<B><A HREF="#APPL_READ">APPL_READ</A>(id,len,adr_buffer)</B>

id, len, adr_buffer: <A HREF="#iexp">iexp</A>

With this instruction bytes can be read from an event buffer (message pipe)<A HREF="#.">.</A>

    id         <A HREF="#-">-</A> Identification number of the application, from whose buffer
                 reading is to be done.
    len        <A HREF="#-">-</A> Number of bytes to be read.
    adr_buffer <A HREF="#-">-</A> Address of the buffer.

Returns 0 if an error occured.

appl_read()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="appl_search">appl_search</H2>
<B><A HREF="#appl_search">appl_search</A>(mode,fname$,type,ap_id)</B>

mode: <A HREF="#iexp">iexp</A>
fname$<A HREF="#:">:</A> <A HREF="#svar">svar</A>
type, app_id: <A HREF="#ivar">ivar</A>

Provides a method for identifying all of the currently running processes.

    mode  <A HREF="#-">-</A> Specifies the search mode.
    fname <A HREF="#-">-</A> Returns the file name.
    type  <A HREF="#-">-</A> Returns the type.
    ap_id <A HREF="#-">-</A> Returns the application identifier.

Returns 0 if no more applications exist or 1 when more processes exist that
meet the search criteria.

<B>Note:</B> Please refer to other <A HREF="#AES">AES</A> documentation for proper use.

<B>Memo:</B> This call is not built into <A HREF="#GFA-Basic">GFA-Basic</A> so it is included below:

<A HREF="#FUNCTION">FUNCTION</A> <A HREF="#appl_search">appl_search</A>(mode&,<A HREF="#VAR">VAR</A> fname$,type&,apid&)
  <A HREF="#$F%">$F%</A>
  <A HREF="#INLINE">INLINE</A> fname%,32
  <A HREF="#GCONTRL">GCONTRL</A>(0)=18
  <A HREF="#GCONTRL">GCONTRL</A>(1)=1
  <A HREF="#GCONTRL">GCONTRL</A>(2)=3
  <A HREF="#GCONTRL">GCONTRL</A>(3)=1
  <A HREF="#GCONTRL">GCONTRL</A>(4)=0
  <A HREF="#GINTIN">GINTIN</A>(0)=mode&
  <A HREF="#ADDRIN">ADDRIN</A>(0)=fname%
  <A HREF="#GEMSYS">GEMSYS</A>
  fname$<A HREF="#=">=</A><A HREF="#CHAR">CHAR</A>{fname%}
  type&<A HREF="#=">=</A><A HREF="#GINTOUT">GINTOUT</A>(1)
  apid&<A HREF="#=">=</A><A HREF="#GINTOUT">GINTOUT</A>(2)
  <A HREF="#RETURN">RETURN</A> <A HREF="#GINTOUT">GINTOUT</A>(0)
<A HREF="#ENDFUNC">ENDFUNC</A>

<A HREF="#appl_search">appl_search</A><A HREF="#()">()</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="APPL_TPLAY">APPL_TPLAY</H2>
<A NAME="APPL_TRECORD"></A><B><A HREF="#APPL_TPLAY">APPL_TPLAY</A>(num,speed,mem)
<A HREF="#APPL_TRECORD">APPL_TRECORD</A>(mem,num)</B>

num, speed, mem: <A HREF="#iexp">iexp</A>

<A HREF="#APPL_TRECORD">APPL_TRECORD</A><A HREF="#()">()</A> makes a record of user activities (mouse movement, key presses,
etc.), and <A HREF="#APPL_TPLAY">APPL_TPLAY</A><A HREF="#()">()</A> plays it back at a specified speed (speed <A HREF="#=">=</A> 1 to 1000).
These functions do not work as specified in some older documentation.

With newer ROM versions these functions work approximately as specified, except
that instead of 6 bytes per event 8 bytes are used and also the speed factor
works differently. Everything else appears reliable, but these functions should
be used advisedly.

    num   <A HREF="#-">-</A> Number of events to record or playback.
              Thus 8 events would require a buffer 64 (8*8) bytes in size.
    speed <A HREF="#-">-</A> Playback speed. (1-1000)
              200 <A HREF="#=">=</A> Double speed
              100 <A HREF="#=">=</A> Normal speed
              50  <A HREF="#=">=</A> Half speed
              Other values are interpreted accordingly.
    mem   <A HREF="#-">-</A> Address of an array of EVNTREC structures for recording or
            playback. Each EVNTREC structure is 8 bytes (2 longs).
              Data format: <A HREF="#&">&</A>#60;event&#62;&#60;value&#62;,&#60;event&#62;&#60;value&#62;,&#60;event&#62;&#60;value&#62;,<A HREF="#.">.</A>..
              Name                Event     Value
              <A HREF="#-">-</A>-----------------  --------  -------------------------------
              0 APPEVNT_TIMER     Timer     Elapsed time in milliseconds
              1 APPEVNT_BUTTON    Button    high word <A HREF="#=">=</A> number of clicks
                                            low word  <A HREF="#=">=</A> state (1 = down)
              2 APPEVNT_MOUSE     Mouse     high word <A HREF="#=">=</A> X position
                                            low word  <A HREF="#=">=</A> Y position
              3 APPEVNT_KEYBOARD  Keyboard  bits 0-7   <A HREF="#=">=</A> <A HREF="#ASCII">ASCII</A> code
                                            bits 8-15  <A HREF="#=">=</A> scan code
                                            bits 16-31 <A HREF="#=">=</A> modifier key state

Note: See kbshift() for modifier key state.

    Example:

    x&=100
    y&=100
    <A HREF="#INLINE">INLINE</A> adr%,8
    <A HREF="#LONG">LONG</A>{adr%}=2
    <A HREF="#LONG">LONG</A>{adr%+4}<A HREF="#=">=</A><A HREF="#OR">OR</A>(<A HREF="#SHL">SHL</A>(x&,16),y&)
    <A HREF="#~">~</A><A HREF="#APPL_TPLAY">APPL_TPLAY</A>(1,100,adr%)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The mouse cursor jumps to coordinates 100,100

<B>Memo:</B> The parameters for <A HREF="#APPL_TPLAY">APPL_TPLAY</A><A HREF="#()">()</A> are documented incorrectly in the
      GFA manual. Parameter order does not match offical docs.
      <A HREF="#APPL_TPLAY">APPL_TPLAY</A><A HREF="#()">()</A> does not work compiled as the library contains a bug.

appl_tplay()<A HREF="#+">+</A>, appl_trecord()+, Kbshift()+
<HR SIZE=3><H2 ID="APPL_WRITE">APPL_WRITE</H2>
<B><A HREF="#APPL_WRITE">APPL_WRITE</A>(id,len,adr_buffer)</B>

id, len, adr_buffer: <A HREF="#iexp">iexp</A>

With this instruction bytes can be written into an event buffer (message pipe)<A HREF="#.">.</A>

    id         <A HREF="#-">-</A> Identification number of the application, into whose buffer
                 writing is to be done.
    len        <A HREF="#-">-</A> Number of bytes to be written.
    adr_buffer <A HREF="#-">-</A> Address of the buffer.

Returns 0 if an error occured.

appl_write()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="appl_yield">appl_yield</H2>
<B><A HREF="#appl_yield">appl_yield</A></B>

<B>Memo:</B> This call is not built into <A HREF="#GFA-Basic">GFA-Basic</A> so it's listed below:

<A HREF="#FUNCTION">FUNCTION</A> <A HREF="#appl_yield">appl_yield</A>
  <A HREF="#$F%">$F%</A>
  <A HREF="#GCONTRL">GCONTRL</A>(0)=17
  <A HREF="#GCONTRL">GCONTRL</A>(1)=0
  <A HREF="#GCONTRL">GCONTRL</A>(2)=1
  <A HREF="#GCONTRL">GCONTRL</A>(3)=0
  <A HREF="#GCONTRL">GCONTRL</A>(4)=0
  <A HREF="#GEMSYS">GEMSYS</A>
  <A HREF="#RETURN">RETURN</A> <A HREF="#GINTOUT">GINTOUT</A>(0)
<A HREF="#ENDFUNC">ENDFUNC</A>
<HR SIZE=3><H2 ID="_appl_yield">_appl_yield</H2>
<B><A HREF="#_appl_yield">_appl_yield</A></B>

Forces the <A HREF="#AES">AES</A> event dispatcher to perform a task switch.

<B>Note:</B> This call should work on all TOS versions.

<B>Memo:</B> This call is not built into <A HREF="#GFA-Basic">GFA-Basic</A> so it's listed below:

<A HREF="#PROCEDURE">PROCEDURE</A> <A HREF="#appl_yield">appl_yield</A>
  <A HREF="#'">'</A> _appl_yield:
  <A HREF="#'">'</A>   move.w <A HREF="##">#</A>$c9,d0
  <A HREF="#'">'</A>   trap #2
  <A HREF="#'">'</A>   rts
  <A HREF="#'">'</A> .end
  <A HREF="#LOCAL">LOCAL</A> asm%
  <A HREF="#INLINE">INLINE</A> asm%,8
  <A HREF="#LONG">LONG</A>{asm%}<A HREF="#=">=</A>&H303C00C9
  <A HREF="#LONG">LONG</A>{asm%+4}<A HREF="#=">=</A>&H4E424E75
  ~C:asm%<A HREF="#()">()</A>
<A HREF="#RETURN">RETURN</A>
<HR SIZE=3><H2 ID="Event_Library">Event Library</H2>
<A HREF="#EVNT_BUTTON">EVNT_BUTTON</A><A HREF="#()">()</A>
<A HREF="#EVNT_DCLICK">EVNT_DCLICK</A><A HREF="#()">()</A>
<A HREF="#EVNT_KEYBD">EVNT_KEYBD</A><A HREF="#()">()</A>
<A HREF="#EVNT_MESAG">EVNT_MESAG</A><A HREF="#()">()</A>
<A HREF="#EVNT_MOUSE">EVNT_MOUSE</A><A HREF="#()">()</A>
<A HREF="#EVNT_MULTI">EVNT_MULTI</A><A HREF="#()">()</A>
<A HREF="#EVNT_TIMER">EVNT_TIMER</A><A HREF="#()">()</A>

The <A HREF="#Event_Library">Event Library</A> allows a program to react to input from the mouse, keyboard,
etc, or to time-dependant events.

<A HREF="#Event_Library">Event Library</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="EVNT_BUTTON">EVNT_BUTTON</H2>
<B><A HREF="#EVNT_BUTTON">EVNT_BUTTON</A>(clicks,mask,state[,mx,my,button,k_state])</B>

clicks, mask, state: <A HREF="#iexp">iexp</A>
mx, my, button, k_state: <A HREF="#ivar">ivar</A>

Waits for one or more mouse clicks, e.g. double-click, triple click, etc.

Returns the number of clicks.

    clicks  <A HREF="#-">-</A> Maximum allowable clicks.
    mask    <A HREF="#-">-</A> Mask for the desired mouse button:
              Bit 0: Left button
              Bit 1: Right button
    state   <A HREF="#-">-</A> Desired status, in order to terminate the event.
              Bit allocation as for 'mask'

    mx      <A HREF="#-">-</A> Returns x-coordinate of mouse pointer when event is terminated.
    my      <A HREF="#-">-</A> Returns y-coordinate of mouse pointer when event is terminated.
    button  <A HREF="#-">-</A> Returns state of mouse buttons when event is terminated.
    k_state <A HREF="#-">-</A> Returns state of keyboard 'shift' keys when event is terminated.
              Bit 0: Right shift key
              Bit 1: Left shift key
              Bit 2: Control key
              Bit 3: Alternate key
              Bit 7: AltGr (Milan)

The parameters mx, my, button, and k_state are optional, these values can also
be found by querying <A HREF="#GINTOUT">GINTOUT</A>(1) to GINTOUT(4)<A HREF="#.">.</A>

<B>Example:</B>

    <A HREF="#DO">DO</A>
      <A HREF="#SELECT">SELECT</A> <A HREF="#EVNT_BUTTON">EVNT_BUTTON</A>(2,1,1,mx%,my%,bu%,kb%)
      <A HREF="#CASE">CASE</A> 1
        <A HREF="#TEXT">TEXT</A> mx%,my%,"1"
      <A HREF="#CASE">CASE</A> 2
        <A HREF="#TEXT">TEXT</A> mx%,my%,"2"
      <A HREF="#CASE">CASE</A> 3
        <A HREF="#TEXT">TEXT</A> mx%,my%<A HREF="#.">.</A>"3"
      <A HREF="#ENDSELECT">ENDSELECT</A>
    <A HREF="#LOOP_UNTIL">LOOP UNTIL</A> <A HREF="#BTST">BTST</A>(kb%,2) !until Control key also pressed

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Waits for mouse clicks with the left mouse button. The number of clicks
    appears on the screen at the mouse position. The program is ended by
    holding down the Control key as well as clicking.

evnt_button()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="EVNT_DCLICK">EVNT_DCLICK</H2>
<B><A HREF="#EVNT_DCLICK">EVNT_DCLICK</A>(new,get_set)</B>

Sets the mouse double-click response rate.

    new     <A HREF="#-">-</A> New rate (0 to 4)<A HREF="#.">.</A>
    get_set <A HREF="#-">-</A> Determines whether the rate is to be set, or just read.
              0: Return the current rate (then 'new' is a dummy)<A HREF="#.">.</A>
              1: Sets 'new' as new rate.

evnt_dclick()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="EVNT_KEYBD">EVNT_KEYBD</H2>
<B><A HREF="#EVNT_KEYBD">EVNT_KEYBD</A><A HREF="#()">()</A></B>

Waits for a key to be pressed and returns a word-sized value, with the
low-order byte containing the <A HREF="#ASCII">ASCII</A> code, and the high-order byte containing
the keyboard <A HREF="#Scan">Scan</A> code.

<B>Example:</B>

    <A HREF="#DO">DO</A>
      <A HREF="#PRINT">PRINT</A> <A HREF="#HEX$">HEX$</A>(<A HREF="#EVNT_KEYBD">EVNT_KEYBD</A><A HREF="#()">()</A>,4)
    <A HREF="#LOOP">LOOP</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Prints values corresponding to pressed keys.

evnt_keybd()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="EVNT_MESAG">EVNT_MESAG</H2>
<B><A HREF="#EVNT_MESAG">EVNT_MESAG</A>(adr_buffer)</B>

adr_buffer: <A HREF="#iexp">iexp</A>

Waits for the arrival of a message in the event buffer.

The returned value is always 1.

    adr_buffer <A HREF="#-">-</A> address of a 16-byte buffer for the message. If 0 is given for
                 adr_buffer, the system message buffer is used, i.e. <A HREF="#MENU">MENU</A>(1) to
                 <A HREF="#MENU">MENU</A>(8)<A HREF="#.">.</A>

evnt_mesag()<A HREF="#+">+</A>, MU_MESAG+
<HR SIZE=3><H2 ID="EVNT_MOUSE">EVNT_MOUSE</H2>
<B><A HREF="#EVNT_MOUSE">EVNT_MOUSE</A>(flag,mx,my,mw,mh[,mcur_x,mcur_y,button,k_state])</B>

flag, mx, my, mw ,mh: <A HREF="#iexp">iexp</A>
mcur_x, mcur_y, button, k_state: <A HREF="#ivar">ivar</A>

Waits for the mouse pointer to be located inside (or, optionally, outside) a
specified rectangular area of the screen.

The returned value is always 1.

    flag    <A HREF="#-">-</A> Presence inside (0) or outside (1) of the area is detected.
    mx      <A HREF="#-">-</A> x-coordinate of top left corner of rectangle.
    my      <A HREF="#-">-</A> y-coordinate of top left corner of rectangle.
    mw      <A HREF="#-">-</A> Width of rectangle.
    mh      <A HREF="#-">-</A> Height of rectangle.
    mcur_x  <A HREF="#-">-</A> Returns x-coordinate of mouse pointer when event occurs.
    mcur_y  <A HREF="#-">-</A> Returns y-coordinate of mouse poniter when event occurs.
    button  <A HREF="#-">-</A> Returns mouse button status when event occurs.
              Bit 0: Right button
              Bit 1: Left button
    k_state <A HREF="#-">-</A> Returns state of the keyboard 'shift' keys when event occurs.
              Bit 0: Right shift key
              Bit 1: Left shift key
              Bit 2: Control key
              Bit 3: Alternate key
              Bit 7: AltGr (Milan)

The parameters mcur_x, mcur_y, button, and k_state are optional, these values
can also be found by querying <A HREF="#GINTOUT">GINTOUT</A>(1) to GINTOUT(4)<A HREF="#.">.</A>

<B>Example:</B>

    <A HREF="#DO">DO</A>
      <A HREF="#~">~</A><A HREF="#EVNT_MOUSE">EVNT_MOUSE</A>(0,100,100,200,90,mx%,my%,bu%,kb%)
      <A HREF="#IF">IF</A> bu%
        <A HREF="#PBOX">PBOX</A> mx%-10,my%-10,mx%+10,my%+10
      <A HREF="#ELSE">ELSE</A>
        <A HREF="#PLOT">PLOT</A> mx%,my%
      <A HREF="#ENDIF">ENDIF</A>
    <A HREF="#LOOP_UNTIL">LOOP UNTIL</A> <A HREF="#BTST">BTST</A>(kb%,2)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The program waits until the mouse pointer is located inside the rectangle.
    Then a point is plotted at the mouse position, or a small square is drawn
    if the left mouse button is pressed. The program is ended if the Control
    key is held down while the pointer is within the rectangle. Compare the
    effect produced by making the first parameter 1 instead of 0.

<B>Note:</B> While a GEM routine is being executed, the 'break' keys
      (Control-Shift-Alternate) can be pressed, but will not take effect until
      execution has returned to the BASIC part of the program. In general
      though, it is best to exit from programs in the manner provided by the
      program, otherwise memory restoration, etc, may not take place.

evnt_mouse()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="EVNT_MULTI">EVNT_MULTI</H2>
<B><A HREF="#EVNT_MULTI">EVNT_MULTI</A>(flag,clicks,mask,state,
m1_flags,m1_x,m1_y,m1_w,m1_h,m2_flags,m2_x,m2_y,m2_w,m2_h,
adr_buffer,count[,mcur_x,mcur_y,button,k_state,key,num_clicks])</B>

flag, clicks, mask, state: <A HREF="#iexp">iexp</A>
m1_flags, m1_x, m1_y, m1_w, m1_h: <A HREF="#iexp">iexp</A>
m2_flags, m2_x, m2_y, m2_w, m2_h: <A HREF="#iexp">iexp</A>
adr_buffer, count: <A HREF="#iexp">iexp</A>
mcur_x, mcur_y, button, k_state, key, num_clicks: <A HREF="#ivar">ivar</A>

Waits for the occurrence of selected events.

Returns the event which actually occured (see 'flag' below)<A HREF="#.">.</A>

    flag       <A HREF="#-">-</A> Sets the events to be awaited as follows:
                 Bit 0: Keyboard            MU_KEYBD
                 Bit 1: Mouse button        MU_BUTTON
                 Bit 2: First mouse event   MU_M1
                 Bit 3: Second mouse event  MU_M2
                 Bit 4: Message event       MU_MESAG
                 Bit 5: Timer               MU_TIMER
    num_clicks <A HREF="#-">-</A> Returns the number of mouse clicks.

The parameters were already described for <A HREF="#EVNT_BUTTON">EVNT_BUTTON</A><A HREF="#()">()</A>, <A HREF="#EVNT_KEYBD">EVNT_KEYBD</A>(),
<A HREF="#EVNT_MESAG">EVNT_MESAG</A><A HREF="#()">()</A>, and <A HREF="#EVNT_MOUSE">EVNT_MOUSE</A>()<A HREF="#.">.</A> However, it should be noted that two different
mouse events (m1 and m2) can be awaited. With <A HREF="#ON_MENU">ON MENU</A>, which uses this routine
internally, the parameters are installed for the instruction <A HREF="#ON_MENU">ON MENU</A> xxx <A HREF="#GOSUB">GOSUB</A>,
e.g. 'count' is specified directly.

The parameters mcur_x, mcur_y, button, k_state, key, and num_clicks are
optional, these values can also be found by querying <A HREF="#GINTOUT">GINTOUT</A>(1) to GINTOUT(6)<A HREF="#.">.</A>

    <A HREF="#MENU">MENU</A>(1) to MENU(8)   Message buffer
    <A HREF="#MENU">MENU</A>(9)              Return value
    <A HREF="#MENU">MENU</A>(10)=mcur_x      x mouse position
    <A HREF="#MENU">MENU</A>(11)=mcur_y      y mouse position
    <A HREF="#MENU">MENU</A>(12)=button      Mouse button state
    <A HREF="#MENU">MENU</A>(13)=k_state     'Shift' key state (<A HREF="#BIOS">BIOS</A>(11,-1))
    <A HREF="#MENU">MENU</A>(14)=key         <A HREF="#ASCII">ASCII</A> and <A HREF="#Scan">Scan</A> code
    <A HREF="#MENU">MENU</A>(15)=num_clicks  Number of mouse clicks

evnt_multi()<A HREF="#+">+</A>, MU_MESAG+
<HR SIZE=3><H2 ID="EVNT_TIMER">EVNT_TIMER</H2>
<B><A HREF="#EVNT_TIMER">EVNT_TIMER</A>(count)</B>

count: <A HREF="#iexp">iexp</A>

This function waits for a period of time expressed in milliseconds (see <A HREF="#DELAY">DELAY</A>)<A HREF="#.">.</A>

The returned value is always 1.

    count <A HREF="#-">-</A> Number of milliseconds.

evnt_timer()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="Menu_Library">Menu Library</H2>
<A HREF="#menu_attach">menu_attach</A><A HREF="#()">()</A>
<A HREF="#MENU_BAR">MENU_BAR</A><A HREF="#()">()</A>
<A HREF="#MENU_ICHECK">MENU_ICHECK</A><A HREF="#()">()</A>
<A HREF="#MENU_IENABLE">MENU_IENABLE</A><A HREF="#()">()</A>
<A HREF="#menu_istart">menu_istart</A><A HREF="#()">()</A>
<A HREF="#menu_popup">menu_popup</A><A HREF="#()">()</A>
<A HREF="#MENU_REGISTER">MENU_REGISTER</A><A HREF="#()">()</A>
<A HREF="#menu_settings">menu_settings</A><A HREF="#()">()</A>
<A HREF="#MENU_TEXT">MENU_TEXT</A><A HREF="#()">()</A>
<A HREF="#MENU_TNORMAL">MENU_TNORMAL</A><A HREF="#()">()</A>

Used for drawing the Menu Bar and managing its operation.

<A HREF="#Menu_Library">Menu Library</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="menu_attach">menu_attach</H2>
<B><A HREF="#menu_attach">menu_attach</A>(flag,tree,item,mdata)</B>

flag, tree, item, mdata: <A HREF="#iexp">iexp</A>

Allows an application to attach, change, or remove a sub-menu.

Returns 0 if if an error occured and the sub-menu could not be attached or 1 if
the operation was successful.

    flag  <A HREF="#-">-</A> Action to be carried out.
    tree  <A HREF="#-">-</A> Pointer to tree.
    item  <A HREF="#-">-</A> Object number within tree.
    mdata <A HREF="#-">-</A> Pointer to <A HREF="#MENU">MENU</A> structure.

<B>Note:</B> Please refer to <A HREF="#AES">AES</A> documentation for proper use.

<B>Memo:</B> This call is not built info <A HREF="#GFA-Basic">GFA-Basic</A> and is included below:

<A HREF="#FUNCTION">FUNCTION</A> <A HREF="#menu_attach">menu_attach</A>(flag&,tree%,item&,mdata%)
  <A HREF="#$F%">$F%</A>
  <A HREF="#GCONTRL">GCONTRL</A>(0)=37
  <A HREF="#GCONTRL">GCONTRL</A>(1)=2
  <A HREF="#GCONTRL">GCONTRL</A>(2)=1
  <A HREF="#GCONTRL">GCONTRL</A>(3)=2
  <A HREF="#GCONTRL">GCONTRL</A>(4)=0
  <A HREF="#GINTIN">GINTIN</A>(0)=flag&
  <A HREF="#GINTIN">GINTIN</A>(1)=item&
  <A HREF="#ADDRIN">ADDRIN</A>(0)=tree%
  <A HREF="#ADDRIN">ADDRIN</A>(1)=mdata%
  <A HREF="#GEMSYS">GEMSYS</A>
  <A HREF="#RETURN">RETURN</A> <A HREF="#GINTOUT">GINTOUT</A>(0)
<A HREF="#ENDFUNC">ENDFUNC</A>

<A HREF="#menu_attach">menu_attach</A><A HREF="#()">()</A><A HREF="#+">+</A>, <A HREF="#MENU">MENU</A>+
<HR SIZE=3><H2 ID="MENU_BAR">MENU_BAR</H2>
<B><A HREF="#MENU_BAR">MENU_BAR</A>(tree,flag)</B>

tree, flag: <A HREF="#iexp">iexp</A>

Displays or erases a menu bar (loaded from a Resource file)<A HREF="#.">.</A> Compare to <A HREF="#MENU">MENU</A>
x$<A HREF="#()">()</A> and <A HREF="#MENU_KILL">MENU KILL</A><A HREF="#.">.</A>

Returns 0 if an error occured.

    tree <A HREF="#-">-</A> Address of the menu object tree.
    flag <A HREF="#-">-</A> 0: Erase menu bar (happens automatically at the end of a program)<A HREF="#.">.</A>
           1: Display menu bar.

menu_bar()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="MENU_ICHECK">MENU_ICHECK</H2>
<B><A HREF="#MENU_ICHECK">MENU_ICHECK</A>(tree,item,flag)</B>

tree, item, flag: <A HREF="#iexp">iexp</A>

Adds or reomves a checkmark in front of a menu item (which should have at least
2 spaces reserved for it.)

Returns 0 if an error occured.

    tree <A HREF="#-">-</A> Address of the menu object tree.
    item <A HREF="#-">-</A> Object number of the menu item.
    flag <A HREF="#-">-</A> 0: Delete checkmark
           1: Add checkmark <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> 

menu_icheck()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="MENU_IENABLE">MENU_IENABLE</H2>
<B><A HREF="#MENU_IENABLE">MENU_IENABLE</A>(tree,item,flag)</B>

tree, item, flag: <A HREF="#iexp">iexp</A>

This causes the enabling or disabling of menu items. The menu item will then
appear with normal characters (selectable), or gray characters (not selectable)
respectively. Compare to <A HREF="#MENU">MENU</A> x,2 and MENU x,3.

Returns 0 if an error occured.

    tree <A HREF="#-">-</A> Address of menu object tree.
    item <A HREF="#-">-</A> Object number of menu entry.
    flag <A HREF="#-">-</A> 0: Disabled -<A HREF="#&#62;">&#62;</A> Sample
           1: Enabled

menu_ienable()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="menu_istart">menu_istart</H2>
<B><A HREF="#menu_istart">menu_istart</A>(flag,tree,imenu,item)</B>

flag, tree, imenu, item: <A HREF="#iexp">iexp</A>

Shifts a sub-menu that is attached to a menu item to align vertically with the
specified object in the sub-menu.

Returns 0 if an error occured or the positive object <A HREF="#index">index</A> of the sub-menu item
which is currently aligned with its parent menu item.

    flag  <A HREF="#-">-</A> Action to be carried out.
    tree  <A HREF="#-">-</A> Pointer to object tree.
    imenu <A HREF="#-">-</A> Object number.
    item  <A HREF="#-">-</A> Object number.

<B>Note:</B> Please refer to <A HREF="#AES">AES</A> documentation for proper use.

<B>Memo:</B> This call is not built into <A HREF="#GFA-Basic">GFA-Basic</A> and is included below:

<A HREF="#FUNCTION">FUNCTION</A> <A HREF="#menu_istart">menu_istart</A>(flag&,tree%,imenu&,item&)
  <A HREF="#$F%">$F%</A>
  <A HREF="#GCONTRL">GCONTRL</A>(0)=38
  <A HREF="#GCONTRL">GCONTRL</A>(1)=3
  <A HREF="#GCONTRL">GCONTRL</A>(2)=1
  <A HREF="#GCONTRL">GCONTRL</A>(3)=1
  <A HREF="#GCONTRL">GCONTRL</A>(4)=0
  <A HREF="#GINTIN">GINTIN</A>(0)=flag&
  <A HREF="#GINTIN">GINTIN</A>(1)=imenu&
  <A HREF="#GINTIN">GINTIN</A>(2)=item&
  <A HREF="#ADDRIN">ADDRIN</A>(0)=tree%
  <A HREF="#GEMSYS">GEMSYS</A>
  <A HREF="#RETURN">RETURN</A> <A HREF="#GINTOUT">GINTOUT</A>(0)
<A HREF="#ENDFUNC">ENDFUNC</A>

<A HREF="#menu_istart">menu_istart</A><A HREF="#()">()</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="menu_popup">menu_popup</H2>
<B><A HREF="#menu_popup">menu_popup</A>(menu,xpos,ypos,mdata)</B>

menu, xpos, ypos, mdata: <A HREF="#iexp">iexp</A>

Displays a popup menu and returns the user's selection.

Returns 0 if an error occured or 1 is successful.

    menu  <A HREF="#-">-</A> Pointer to <A HREF="#MENU">MENU</A> structure.
    xpos  <A HREF="#-">-</A> x-coordinate of upper left corner.
    ypos  <A HREF="#-">-</A> y-coordinate of upper left corner.
    mdata <A HREF="#-">-</A> Pointer to <A HREF="#MENU">MENU</A> structure.

<B>Note:</B> Please refer to <A HREF="#AES">AES</A> documentation for proper use.

<B>Memo:</B> This call is not built into <A HREF="#GFA-Basic">GFA-Basic</A> and is included below:

<A HREF="#FUNCTION">FUNCTION</A> <A HREF="#menu_popup">menu_popup</A>(menu%,xpos&,ypos&,mdata%)
  <A HREF="#$F%">$F%</A>
  <A HREF="#GCONTRL">GCONTRL</A>(0)=36
  <A HREF="#GCONTRL">GCONTRL</A>(1)=2
  <A HREF="#GCONTRL">GCONTRL</A>(2)=1
  <A HREF="#GCONTRL">GCONTRL</A>(3)=2
  <A HREF="#GCONTRL">GCONTRL</A>(4)=0
  <A HREF="#GINTIN">GINTIN</A>(0)=xpos&
  <A HREF="#GINTIN">GINTIN</A>(1)=ypos&
  <A HREF="#ADDRIN">ADDRIN</A>(0)=menu%
  <A HREF="#ADDRIN">ADDRIN</A>(1)=mdata%
  <A HREF="#GEMSYS">GEMSYS</A>
  <A HREF="#RETURN">RETURN</A> <A HREF="#GINTOUT">GINTOUT</A>(0)
<A HREF="#ENDFUNC">ENDFUNC</A>

<A HREF="#menu_popup">menu_popup</A><A HREF="#()">()</A><A HREF="#+">+</A>, <A HREF="#MENU">MENU</A>+
<HR SIZE=3><H2 ID="MENU_REGISTER">MENU_REGISTER</H2>
<B><A HREF="#MENU_REGISTER">MENU_REGISTER</A>(ap_id,m_text$)</B>

ap_id: <A HREF="#iexp">iexp</A>
m_text$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>

Registers desk <A HREF="#accessories">accessories</A> in the 'Desk' menu and renames MultiTOS applications
which appear there.

Returns -1 if an error occured or a menu identifier if successful.

    ap_id   <A HREF="#-">-</A> Application identifier of the <A HREF="#accessory">accessory</A><A HREF="#.">.</A>
    m_text$ <A HREF="#-">-</A> Name under which the <A HREF="#accessory">accessory</A> is to be entered into the menu
              (normally this is the <A HREF="#accessory">accessory</A> name)<A HREF="#.">.</A>

<B>Memo:</B> Never use the built in <A HREF="#MENU_REGISTER">MENU_REGISTER</A><A HREF="#()">()</A> funtion, instead call the
      <A HREF="#AES">AES</A> directly. Calling <A HREF="#MENU_REGISTER">MENU_REGISTER</A><A HREF="#()">()</A> seems to work but for some reason
      the entry itself under the 'Desk' drop down turns to garbage after a
      while.

<A HREF="#FUNCTION">FUNCTION</A> menu_register(ap_id&,m_text%)
  <A HREF="#$F%">$F%</A>
  <A HREF="#GCONTRL">GCONTRL</A>(0)=35
  <A HREF="#GCONTRL">GCONTRL</A>(1)=1
  <A HREF="#GCONTRL">GCONTRL</A>(2)=1
  <A HREF="#GCONTRL">GCONTRL</A>(3)=1
  <A HREF="#GCONTRL">GCONTRL</A>(4)=0
  <A HREF="#GINTIN">GINTIN</A>(0)=ap_id&
  <A HREF="#ADDRIN">ADDRIN</A>(0)=m_text%
  <A HREF="#GEMSYS">GEMSYS</A>
  <A HREF="#RETURN">RETURN</A> <A HREF="#GINTOUT">GINTOUT</A>(0)
<A HREF="#ENDFUNC">ENDFUNC</A>

menu_register()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="menu_settings">menu_settings</H2>
<B><A HREF="#menu_settings">menu_settings</A>(flag,set)</B>

flag, set: <A HREF="#iexp">iexp</A>

Changes the global settings for popup and scrollable menus.

Return value will always be 1.

    flag <A HREF="#-">-</A> Action to be carried out.
    set  <A HREF="#-">-</A> Pointer to a MN_SET structure.

<B>Note:</B> Please refer to <A HREF="#AES">AES</A> documentation for proper use.

<B>Memo:</B> This call is not built into <A HREF="#GFA-Basic">GFA-Basic</A> and is included below:

<A HREF="#FUNCTION">FUNCTION</A> <A HREF="#menu_settings">menu_settings</A>(flag&,set%)
  <A HREF="#$F%">$F%</A>
  <A HREF="#GCONTRL">GCONTRL</A>(0)=39
  <A HREF="#GCONTRL">GCONTRL</A>(1)=1
  <A HREF="#GCONTRL">GCONTRL</A>(2)=1
  <A HREF="#GCONTRL">GCONTRL</A>(3)=1
  <A HREF="#GCONTRL">GCONTRL</A>(4)=0
  <A HREF="#GINTIN">GINTIN</A>(0)=flag&
  <A HREF="#ADDRIN">ADDRIN</A>(0)=set%
  <A HREF="#GEMSYS">GEMSYS</A>
  <A HREF="#RETURN">RETURN</A> <A HREF="#GINTOUT">GINTOUT</A>(0)
<A HREF="#ENDFUNC">ENDFUNC</A>

<A HREF="#menu_settings">menu_settings</A><A HREF="#()">()</A><A HREF="#+">+</A>, MN_SET+
<HR SIZE=3><H2 ID="MENU_TEXT">MENU_TEXT</H2>
<B><A HREF="#MENU_TEXT">MENU_TEXT</A>(tree,item,new_text$)</B>

tree, item: <A HREF="#iexp">iexp</A>
new_text$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>

Changes the text of a menu item. This functions permits the adapting of menu
entries while a program is running.

Returns 0 if an error occured.

    tree      <A HREF="#-">-</A> Address of menu object tree.
    item      <A HREF="#-">-</A> Object number of the item to be modified.
    new_text$ <A HREF="#-">-</A> A string containing the new menu item (may not exceed the
                length of the old one)<A HREF="#.">.</A>

<B>Memo:</B> This command copies the characters of new_text$ into the object tree
      structure. Effectively overwriting the old string data. Care must be
      taken not to exceed the length of the old string buffer.

<B>Memo:</B> Fails in the editor, but works compiled.

menu_text()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="MENU_TNORMAL">MENU_TNORMAL</H2>
<B><A HREF="#MENU_TNORMAL">MENU_TNORMAL</A>(tree,item,flag)</B>

tree, item, flag: <A HREF="#iexp">iexp</A>

Menu title switches to inverse or normal text. Compare to <A HREF="#MENU_OFF">MENU OFF</A>.

Returns 0 if an error occured.

    tree <A HREF="#-">-</A> Address of the menu object tree.
    item <A HREF="#-">-</A> Object number of the menu item.
    flag <A HREF="#-">-</A> 0: Inverse text
           1: Normal text

menu_tnormal()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="Object_Library">Object Library</H2>
<A HREF="#OBJC_ADD">OBJC_ADD</A><A HREF="#()">()</A>
<A HREF="#OBJC_CHANGE">OBJC_CHANGE</A><A HREF="#()">()</A>
<A HREF="#OBJC_DELETE">OBJC_DELETE</A><A HREF="#()">()</A>
<A HREF="#OBJC_DRAW">OBJC_DRAW</A><A HREF="#()">()</A>
<A HREF="#OBJC_EDIT">OBJC_EDIT</A><A HREF="#()">()</A>
<A HREF="#OBJC_FIND">OBJC_FIND</A><A HREF="#()">()</A>
<A HREF="#OBJC_OFFSET">OBJC_OFFSET</A><A HREF="#()">()</A>
<A HREF="#OBJC_ORDER">OBJC_ORDER</A><A HREF="#()">()</A>
<A HREF="#objc_sysvar">objc_sysvar</A><A HREF="#()">()</A>
<A HREF="#objc_xfind">objc_xfind</A><A HREF="#()">()</A>

The <A HREF="#Object_Library">Object Library</A> contains routines for the definition, drawing, and
alteration of objects.

See section <A HREF="#'">'</A><A HREF="#Object_Structure">Object Structure</A>' for commands related object manipulation.

<A HREF="#Object_Library">Object Library</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="OBJC_ADD">OBJC_ADD</H2>
<B><A HREF="#OBJC_ADD">OBJC_ADD</A>(tree,parent,child)</B>

tree, parent, child: <A HREF="#iexp">iexp</A>

An object is added to a given object tree and pointers between existing objects
and the new object are created.

Returns 0 if an error occured.

    tree   <A HREF="#-">-</A> Address of the object tree.
    parent <A HREF="#-">-</A> Object number of the parent object, of which the new object is to
             be a child.
    child  <A HREF="#-">-</A> Object number of the 'child object' to be added.

objc_add()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="OBJC_CHANGE">OBJC_CHANGE</H2>
<B><A HREF="#OBJC_CHANGE">OBJC_CHANGE</A>(tree,obj,res,cx,cy,cw,ch,new_status,re_draw)</B>

tree, obj, res, cx, cy, cw, ch, new_status, re_draw: <A HREF="#iexp">iexp</A>

This function changes the status of an object (<A HREF="#OB_STATE">OB_STATE</A>) and, if necessary,
inverts (displays in inverse video) that section of the object lying inside the
clipping rectangle. (Normally <A HREF="#OB_STATE">OB_STATE</A> would be changed directly and the object
redrawn with <A HREF="#OBJC_DRAW">OBJC_DRAW</A><A HREF="#()">()</A><A HREF="#.">.</A>)

Returns 0 if an error occured.

    tree       <A HREF="#-">-</A> Address of the object tree.
    obj        <A HREF="#-">-</A> Number of the object to be changed.
    res        <A HREF="#-">-</A> Reserved (always 0)<A HREF="#.">.</A>
    cx         <A HREF="#-">-</A> x-coordinate of the top left corner of clipping rectangle
    cy         <A HREF="#-">-</A> y-coordinate of the top left corner of clipping rectangle
    cw         <A HREF="#-">-</A> Width of clipping rectangle
    ch         <A HREF="#-">-</A> Height of clipping rectangle.
    new_status <A HREF="#-">-</A> New object status (see <A HREF="#OB_STATE">OB_STATE</A><A HREF="#()">()</A>)
    re_draw    <A HREF="#-">-</A> 0: Do not redraw object
                 1: Redraw object

<B>Memo:</B> This call only updates the state. This will appear to fail:
      <A HREF="#CHAR">CHAR</A>{<A HREF="#OB_SPEC">OB_SPEC</A>(tree%,obj&}<A HREF="#=">=</A>"blah..." !this change won't be seen
      ~OB_CHANGE(tree%,obj&,0,x&,y&,w&,h&,&X1,1) !object will be selected
      <A HREF="#'">'</A> however, if you call objc_draw() the new text string will be seen
      <A HREF="#'">'</A> tested under SingleTOS and N.Aes

objc_change()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="OBJC_DELETE">OBJC_DELETE</H2>
<B><A HREF="#OBJC_DELETE">OBJC_DELETE</A>(tree,del_obj)</B>

tree, del_obj: <A HREF="#iexp">iexp</A>

An object is deleted from an object tree by changing pointers in the tree. The
object itself will still be there and can be restored later by restoring the
pointers.

Returns 0 if an error occured.

    tree    <A HREF="#-">-</A> Address of the object tree.
    del_obj <A HREF="#-">-</A> Object number of the object to be deleted.

objc_delete()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="OBJC_DRAW">OBJC_DRAW</H2>
<B><A HREF="#OBJC_DRAW">OBJC_DRAW</A>(tree,start_obj,depth,cx,cy,cw,ch)</B>

tree, start_obj, depth, cx, cy, cw, ch: <A HREF="#iexp">iexp</A>

This function draws whole objects or parts of objects on the screen. A clipping
rectangle can be specified, to which the drawing is limited.

Returns 0 if an error occured.

    tree      <A HREF="#-">-</A> Address of the object tree.
    start_obj <A HREF="#-">-</A> Object number of the first object to be drawn.
    depth     <A HREF="#-">-</A> Number of object levels to be drawn (0 <A HREF="#=">=</A> only first object)<A HREF="#.">.</A>
    cx        <A HREF="#-">-</A> x-coordinate of top left corner of clipping rectangle
    cy        <A HREF="#-">-</A> y-coordinate of top left corner of clipping rectangle
    cw        <A HREF="#-">-</A> Width of clipping rectangle.
    ch        <A HREF="#-">-</A> Height of clipping rectangle.

objc_draw()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="OBJC_EDIT">OBJC_EDIT</H2>
<B><A HREF="#OBJC_EDIT">OBJC_EDIT</A>(tree,obj,char,old_pos,flag,new_pos)</B>

tree, obj, char, old_pos, flag: <A HREF="#iexp">iexp</A>
new_pos: <A HREF="#ivar">ivar</A>

Facilitates the input and editing of text in the G_TEXT and G_BOXTEXT object
types.

Returns 0 if and error occured.

    tree    <A HREF="#-">-</A> Address of the object tree.
    obj     <A HREF="#-">-</A> Object number.
    char    <A HREF="#-">-</A> Input character (including <A HREF="#Scan">Scan</A> code)<A HREF="#.">.</A>
    old_pos <A HREF="#-">-</A> Current cursor position in input string.
    flag    <A HREF="#-">-</A> Function selection:
              0: Reserved (function call does nothing)        ED_START
              1: String is formatted and cursor switched on   ED_INIT
              2: Character processed and string re-displayed  ED_CHAR
              3: Text cursor switched off                     ED_END
    new_pos <A HREF="#-">-</A> Returns the new cursor position in input string.

<B>Memo:</B> ED_INIT always places the cursor at the end of the string.

      The code inside the editor seems to indicate that parameter 'new_pos'
      should be optional, however the syntax rule doesn't seem to allow it.

objc_edit()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="OBJC_FIND">OBJC_FIND</H2>
<B><A HREF="#OBJC_FIND">OBJC_FIND</A>(tree,start_obj,depth,fx,fy)</B>

tree, start, depth: <A HREF="#iexp">iexp</A>
fx, fy: <A HREF="#ivar">ivar</A>

This function determines which object is found at a given coordinate.

Returns the object number, or -1 if no object is found at the given coordinate.

    tree      <A HREF="#-">-</A> Address of the object tree to be examined.
    start_obj <A HREF="#-">-</A> Number of the object from which the search is begun.
    depth     <A HREF="#-">-</A> Number of object levels to be searched (0=only first object)<A HREF="#.">.</A>
    fx        <A HREF="#-">-</A> x-coordinate
    fy        <A HREF="#-">-</A> y-coordinate

objc_find()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="OBJC_OFFSET">OBJC_OFFSET</H2>
<B><A HREF="#OBJC_OFFSET">OBJC_OFFSET</A>(tree,obj[,x_abs,y_abs])</B>

tree, obj: <A HREF="#iexp">iexp</A>
x_abs, y_abs: <A HREF="#ivar">ivar</A>

Computes the absolute screen coordinates of the specified object.

Returns 0 is an error occured.

    tree  <A HREF="#-">-</A> Address of the object tree.
    obj   <A HREF="#-">-</A> Object number.
    x_abs <A HREF="#-">-</A> Returns the computed x-coordinate.
    y_abs <A HREF="#-">-</A> Returns the computed y-coordinate.

The parameters x_abs and y_abs are optional, these values can also be found
by querying <A HREF="#GINTOUT">GINTOUT</A>(1) to GINTOUT(2)<A HREF="#.">.</A>

objc_offset()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="OBJC_ORDER">OBJC_ORDER</H2>
<B><A HREF="#OBJC_ORDER">OBJC_ORDER</A>(tree,obj,new_pos)</B>

tree, obj, new_pos: <A HREF="#iexp">iexp</A>

Re-positions an object within a tree.

Returns 0 if an error occured.

    tree    <A HREF="#-">-</A> Address of the object tree.
    obj     <A HREF="#-">-</A> Object number.
    new_pos <A HREF="#-">-</A> New level number:
              -1: One level higher
               0: Bottom level
               1: Bottom level <A HREF="#+">+</A> 1
               2: Bottom level <A HREF="#+">+</A> 2
              etc.

objc_order()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="objc_sysvar">objc_sysvar</H2>
<B><A HREF="#objc_sysvar">objc_sysvar</A>(mode,which,in1,in2,out1,out2)</B>

mode, which, in1, in2: <A HREF="#iexp">iexp</A>
out1, out2: <A HREF="#ivar">ivar</A>

Modifies or returns information about the color and placement of 3D object
effects.

Returns 0 if an error occured or non-zero if successful.

    mode  <A HREF="#-">-</A> Action to be carried out.
    which <A HREF="#-">-</A> Attribute to be modified or read.
    in1   <A HREF="#-">-</A> New attribute.
    in2   <A HREF="#-">-</A> New attribute.
    out1  <A HREF="#-">-</A> Return attribute.
    out2  <A HREF="#-">-</A> Return attribute.

<B>Note:</B> Please refer to <A HREF="#AES">AES</A> documentation for proper use.

<B>Memo:</B> This call is not built into <A HREF="#GFA-Basic">GFA-Basic</A> and is included below:

<A HREF="#FUNCTION">FUNCTION</A> <A HREF="#objc_sysvar">objc_sysvar</A>(mode&,which&,in1&,in2&,<A HREF="#VAR">VAR</A> out1&,out2&)
  <A HREF="#$F%">$F%</A>
  <A HREF="#GCONTRL">GCONTRL</A>(0)=48
  <A HREF="#GCONTRL">GCONTRL</A>(1)=4
  <A HREF="#GCONTRL">GCONTRL</A>(2)=3
  <A HREF="#GCONTRL">GCONTRL</A>(3)=0
  <A HREF="#GCONTRL">GCONTRL</A>(4)=0
  <A HREF="#GINTIN">GINTIN</A>(0)=mode&
  <A HREF="#GINTIN">GINTIN</A>(1)=which&
  <A HREF="#GINTIN">GINTIN</A>(2)=in1&
  <A HREF="#GINTIN">GINTIN</A>(3)=in2&
  <A HREF="#GEMSYS">GEMSYS</A>
  out1&<A HREF="#=">=</A><A HREF="#GINTOUT">GINTOUT</A>(1)
  out2&<A HREF="#=">=</A><A HREF="#GINTOUT">GINTOUT</A>(2)
  <A HREF="#RETURN">RETURN</A> <A HREF="#GINTOUT">GINTOUT</A>(0)
<A HREF="#ENDFUNC">ENDFUNC</A>

<A HREF="#objc_sysvar">objc_sysvar</A><A HREF="#()">()</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="objc_xfind">objc_xfind</H2>
<B><A HREF="#objc_xfind">objc_xfind</A><A HREF="#()">()</A></B>

<B>Memo:</B> This call is not built into <A HREF="#GFA-Basic">GFA-Basic</A> so it's listed below:

<A HREF="#FUNCTION">FUNCTION</A> <A HREF="#objc_xfind">objc_xfind</A>(obj%,start&,depth&,x&,y&)
  <A HREF="#$F%">$F%</A>
  <A HREF="#GCONTRL">GCONTRL</A>(0)=49
  <A HREF="#GCONTRL">GCONTRL</A>(1)=4
  <A HREF="#GCONTRL">GCONTRL</A>(2)=1
  <A HREF="#GCONTRL">GCONTRL</A>(3)=1
  <A HREF="#GCONTRL">GCONTRL</A>(4)=0
  <A HREF="#ADDRIN">ADDRIN</A>(0)=obj%
  <A HREF="#GINTIN">GINTIN</A>(0)=start&
  <A HREF="#GINTIN">GINTIN</A>(1)=depth&
  <A HREF="#GINTIN">GINTIN</A>(2)=x&
  <A HREF="#GINTIN">GINTIN</A>(3)=y&
  <A HREF="#GEMSYS">GEMSYS</A>
  <A HREF="#RETURN">RETURN</A> <A HREF="#GINTOUT">GINTOUT</A>(0)
<A HREF="#ENDFUNC">ENDFUNC</A>
<HR SIZE=3><H2 ID="Form_Library">Form Library</H2>
<A HREF="#FORM_ALERT">FORM_ALERT</A><A HREF="#()">()</A>
<A HREF="#FORM_BUTTON">FORM_BUTTON</A><A HREF="#()">()</A>
<A HREF="#FORM_CENTER">FORM_CENTER</A><A HREF="#()">()</A>
<A HREF="#FORM_DIAL">FORM_DIAL</A><A HREF="#()">()</A>
<A HREF="#FORM_DO">FORM_DO</A><A HREF="#()">()</A>
<A HREF="#FORM_ERROR">FORM_ERROR</A><A HREF="#()">()</A>
<A HREF="#FORM_KEYBD">FORM_KEYBD</A><A HREF="#()">()</A>
<A HREF="#form_popup">form_popup</A><A HREF="#()">()</A>

The <A HREF="#Form_Library">Form Library</A> contains routines to Form management, i.e. manipulation of
objects in Dialog bexes etc.

<A HREF="#Form_Library">Form Library</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="FORM_ALERT">FORM_ALERT</H2>
<B><A HREF="#FORM_ALERT">FORM_ALERT</A>(button,string$)</B>

button: <A HREF="#iexp">iexp</A>
string$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>

Creates a general-purpose Alert box (see <A HREF="#ALERT">ALERT</A> command)<A HREF="#.">.</A>

Returns the number of the clicked button which caused the function to
terminate.

    button  <A HREF="#-">-</A> Number of the default (thick-bordered) button:
              0: None
              1: First
              2: Second
              3: Third
    string$ <A HREF="#-">-</A> A string defining the contents of the Alert box. The string has
              the following format (note that the square brackets are part of
              the string)<A HREF="#:">:</A>
              [i][Message][Buttons]
              The meaning of the sections inside the brackets is as follows:
              'i'       The required symbol in the Alert box:
                        0: None


                        1: Exclamation mark


                        2: Question mark


                        3: Stop sign


                        4: Information                      <A HREF="#AES">AES</A> <A HREF="#=&#62;">=&#62;</A> v4.1


                        5: Floppy disk                      <A HREF="#AES">AES</A> <A HREF="#=&#62;">=&#62;</A> v4.1


                        6: Bomb                             XaAES


                        7: Floppy disk/question mark        XaAES


              'Message' Can be at the most 5 lines of text, with a maximum of
                        30 characters per line, with the lines seperated with
                        the pipe <A HREF="#'">'</A><A HREF="#&#124;">&#124;</A>' character.
              'Buttons' Can be a maximum of 3 button names, seperated by the
                        pipe <A HREF="#'">'</A><A HREF="#&#124;">&#124;</A>' character.

<B>Example:</B>

    a$<A HREF="#=">=</A>"[1][This is the first line&#124;<A HREF="#+">+</A>&#124;+&#124;+&#124;This is the fifth line][One&#124;Two&#124;Three]"
    <A HREF="#DO">DO</A>
      <A HREF="#PRINT">PRINT</A> <A HREF="#FORM_ALERT">FORM_ALERT</A>(1,a$)
    <A HREF="#LOOP">LOOP</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Prints 1, 2, or 3 depending on which button is clicked, or pressing Return
    selects the highlighted button. The program can be exited by pressing the
    break keys (Shift-Control-Alternate) but this will only take effect after
    the next click.

<B>Memo:</B> <A HREF="#FORM_ALERT">FORM_ALERT</A><A HREF="#()">()</A> can be fatal on some <A HREF="#AES">AES</A> versions if the default button
      exceeds the actual button count.

form_alert()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="FORM_BUTTON">FORM_BUTTON</H2>
<B><A HREF="#FORM_BUTTON">FORM_BUTTON</A>(tree,obj,clicks,new_obj)</B>

tree, obj, clicks: <A HREF="#iexp">iexp</A>
new_obj: <A HREF="#ivar">ivar</A>

Makes possible mouse input in a Form.

Returns 0 if the Form was left by clicking on an object with EXIT or TOUCHEXIT
status. Returns a value <A HREF="#&">&</A>#62;0 if the Form should continue to be processed.

    tree    <A HREF="#-">-</A> Address of the object tree.
    obj     <A HREF="#-">-</A> Currnet object number.
    clicks  <A HREF="#-">-</A> Maximum expected number of mouse clicks.
    new_obj <A HREF="#-">-</A> Returns the next object to be edited.

Explanation: This routine is a subroutine of <A HREF="#FORM_DO">FORM_DO</A><A HREF="#()">()</A><A HREF="#.">.</A>

form_button()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="FORM_CENTER">FORM_CENTER</H2>
<B><A HREF="#FORM_CENTER">FORM_CENTER</A>(tree[,fx,fy,fw,fh])</B>

tree: <A HREF="#iexp">iexp</A>
fx, fy, fw, fh: <A HREF="#ivar">ivar</A>

This function centers the tree, i.e. Dialog box, ect, on the screen. Its
position can then be found.

Return value will always be 1.

    tree <A HREF="#-">-</A> Address of the object tree.
    fx   <A HREF="#-">-</A> Returns the x-coordinate of the top left corner.
    fy   <A HREF="#-">-</A> Returns the y-coordinate of the top left corner.
    fw   <A HREF="#-">-</A> Returns the width of the centered box.
    fh   <A HREF="#-">-</A> Returns the height of the centered box.

The parameters fx, fy, fw, and fh are optional, these values can also be found
by querying <A HREF="#GINTOUT">GINTOUT</A>(1) to GINTOUT(4)<A HREF="#.">.</A>

form_center()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="FORM_DIAL">FORM_DIAL</H2>
<B><A HREF="#FORM_DIAL">FORM_DIAL</A>(flag,mi_x,mi_y,mi_w,mi_h,ma_x,ma_y,ma_w,ma_h)</B>

flag, mi_x, mi_y, mi_w, mi_h, ma_x, ma_y, ma_w, ma_h: <A HREF="#iexp">iexp</A>

This function serves to reserve (or release) a rectangular screen area and for
drawing expanding or shrinking rectangles.

Returns 0 if an error occured.

    flag <A HREF="#-">-</A> Function type:
           0: Reserves a display area         FMD_START
           1: Draws an expanding rectangle    FMD_GROW
           2: Draws a shrinking rectangle     FMD_SHRINK
           3: Releases reserved display area  FMD_FINISH
    mi_x <A HREF="#-">-</A> x-coordinate of top left corner at minimum size
    mi_y <A HREF="#-">-</A> y-coordinate of top left corner at minimum size
    mi_w <A HREF="#-">-</A> Width of rectangle at minimum size
    mi_h <A HREF="#-">-</A> Height of rectangle at minimum size
    ma_x <A HREF="#-">-</A> x-coordinate of top left corner at maximum size
    ma_y <A HREF="#-">-</A> y-coordinate of top left corner at maximum size
    ma_w <A HREF="#-">-</A> Width of rectangle at maximum size
    ma_h <A HREF="#-">-</A> Height of rectangle at maximum size

<B>Example:</B>

    <A HREF="#~">~</A><A HREF="#FORM_DIAL">FORM_DIAL</A>(1,0,0,0,0,100,100,300,100)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Draws an expanding rectangle. The parameter group '0,0,0,0' means that the
    rectangle grows from the center of what will be the full-size rectangle.

form_dial()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="FORM_DO">FORM_DO</H2>
<B><A HREF="#FORM_DO">FORM_DO</A>(tree,start_obj)</B>

tree, start_obj: <A HREF="#iexp">iexp</A>

This function takes over the complete management of a Form object, until and
object with EXIT or TOUCHEXIT status is clicked.

Returns the number of the object whose clicking or double-clicking caused the
function to be ended. If it was a double-click, bit 15 will be set.

    tree      <A HREF="#-">-</A> Address of the object tree.
    start_obj <A HREF="#-">-</A> Number of the first editable object in the object tree, where
                the cursor is initially to be positioned. If there is no
                editable object the value in this parameter should be 0.

form_do()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="FORM_ERROR">FORM_ERROR</H2>
<B><A HREF="#FORM_ERROR">FORM_ERROR</A>(err)</B>

err: <A HREF="#iexp">iexp</A>

Displays the warning Alert box associated with the DOS Error 'err'<A HREF="#.">.</A>

Returns the number of the button which terminated the function.

    err <A HREF="#-">-</A> Error number.

<B>Example:</B>

    <A HREF="#FOR">FOR</A> x=0 TO 63
      <A HREF="#PRINT">PRINT</A> <A HREF="#FORM_ERROR">FORM_ERROR</A>(x)<A HREF="#;">;</A>
    <A HREF="#NEXT">NEXT</A> x

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The boxed error messages are displayed.

form_error()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="FORM_KEYBD">FORM_KEYBD</H2>
<B><A HREF="#FORM_KEYBD">FORM_KEYBD</A>(tree,obj,char,next_obj[,new_obj,next_char])</B>

tree, obj, char, next_obj: <A HREF="#iexp">iexp</A>
new_obj, next_char: <A HREF="#ivar">ivar</A>

Allows a form to be filled out via the keyboard (see <A HREF="#OBJC_EDIT">OBJC_EDIT</A><A HREF="#()">()</A>)<A HREF="#.">.</A>

Returns 0 if the Form was left by clicking on an object with EXIT or TOUCHEXIT
status. Returns a value <A HREF="#&">&</A>#62;0 if the Form should continue to be processed.

    tree      <A HREF="#-">-</A> Address of the object tree.
    obj       <A HREF="#-">-</A> Number of the object to be edited.
    char      <A HREF="#-">-</A> Input character.
    next_obj  <A HREF="#-">-</A> Number of the next EDITable object in the tree.
    new_obj   <A HREF="#-">-</A> Returns the object to be EDITed on the next call.
    next_char <A HREF="#-">-</A> Returns the next character (derived form the keyboard, etc)<A HREF="#.">.</A>

The parameters new_obj and next_char are optional, these values can also be
found by querying <A HREF="#GINTOUT">GINTOUT</A>(1) to GINTOUT(2)<A HREF="#.">.</A>

Explanation: This routine is a subroutine of <A HREF="#FORM_DO">FORM_DO</A><A HREF="#()">()</A> and makes it possible to
test a character in BASIC before it is passed to GEM, e.g. to test for Return
character, which would normally cause an exit from the Form and allow it to be
used to terminate an individual enrty, etc.

<B>Memo:</B> In the original manual parameters 'char' and 'next_obj' are swapped.
      The function works fine. Parameter order does not match offical docs.

form_keybd()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="form_popup">form_popup</H2>
<B><A HREF="#form_popup">form_popup</A><A HREF="#()">()</A></B>

<B>Memo:</B> This call is not built into <A HREF="#GFA-Basic">GFA-Basic</A> so it's listed below:

<A HREF="#FUNCTION">FUNCTION</A> <A HREF="#form_popup">form_popup</A>(tree%,x&,y&)
  <A HREF="#$F%">$F%</A>
  <A HREF="#GCONTRL">GCONTRL</A>(0)=135
  <A HREF="#GCONTRL">GCONTRL</A>(1)=2
  <A HREF="#GCONTRL">GCONTRL</A>(2)=1
  <A HREF="#GCONTRL">GCONTRL</A>(3)=1
  <A HREF="#GCONTRL">GCONTRL</A>(4)=0
  <A HREF="#GINTIN">GINTIN</A>(0)=x&
  <A HREF="#GINTIN">GINTIN</A>(1)=y&
  <A HREF="#ADDRIN">ADDRIN</A>(0)=tree%
  <A HREF="#GEMSYS">GEMSYS</A>
  <A HREF="#RETURN">RETURN</A> <A HREF="#GINTOUT">GINTOUT</A>(0)
<A HREF="#ENDFUNC">ENDFUNC</A>
<HR SIZE=3><H2 ID="Graphics_Library">Graphics Library</H2>
<A HREF="#GRAF_DRAGBOX">GRAF_DRAGBOX</A><A HREF="#()">()</A>
<A HREF="#GRAF_GROWBOX">GRAF_GROWBOX</A><A HREF="#()">()</A>
<A HREF="#GRAF_HANDLE">GRAF_HANDLE</A><A HREF="#()">()</A>
<A HREF="#GRAF_MKSTATE">GRAF_MKSTATE</A><A HREF="#()">()</A>
<A HREF="#GRAF_MOUSE">GRAF_MOUSE</A><A HREF="#()">()</A>
<A HREF="#GRAF_MOVEBOX">GRAF_MOVEBOX</A><A HREF="#()">()</A>
<A HREF="#graf_multirubber">graf_multirubber</A><A HREF="#()">()</A>
<A HREF="#GRAF_RUBBERBOX">GRAF_RUBBERBOX</A><A HREF="#()">()</A>
<A HREF="#GRAF_SHRINKBOX">GRAF_SHRINKBOX</A><A HREF="#()">()</A>
<A HREF="#GRAF_SLIDEBOX">GRAF_SLIDEBOX</A><A HREF="#()">()</A>
<A HREF="#GRAF_WATCHBOX">GRAF_WATCHBOX</A><A HREF="#()">()</A>

The <A HREF="#Graphics_Library">Graphics Library</A> provides routines for screen effects, mouse control, and
obtaining basic screen attributes.

<A HREF="#Graphics_Library">Graphics Library</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="GRAF_DRAGBOX">GRAF_DRAGBOX</H2>
<B><A HREF="#GRAF_DRAGBOX">GRAF_DRAGBOX</A>(iw,ih,ix,iy,rx,ry,rw,rh[,last_ix,last_iy])</B>

iw, ih, ix, iy, rx, ry, rw, rh: <A HREF="#iexp">iexp</A>
last_ix, last_iy: <A HREF="#ivar">ivar</A>

This function allows a rectangle to be moved about the screen with the mouse.
Its movement is restricted to the interior of a larger specified rectangle. The
function should only be called when the left mouse button is held down, as it
terminates when the button is released.

Returns 0 is an error occurred.

    iw      <A HREF="#-">-</A> Width of moving rectangle.
    ih      <A HREF="#-">-</A> Height of moving rectangle.
    ix      <A HREF="#-">-</A> Initial x-coordinate of top left corner of moving rectangle.
    iy      <A HREF="#-">-</A> Initial y-coordinate of top left corner of moving rectangle.
    rx      <A HREF="#-">-</A> x-coodinate of top left corner of limiting rectangle.
    ry      <A HREF="#-">-</A> y-coodinate of top left corner of limiting rectangle.
    rw      <A HREF="#-">-</A> Width of limiting rectangle.
    rh      <A HREF="#-">-</A> Height of limiting rectangle.
    last_ix <A HREF="#-">-</A> Returns x-coordinate of top left corner of moving rectangle when
              function terminates.
    last_iy <A HREF="#-">-</A> Returns y-coordinate of top left corner of moving rectangle when
              function terminates.

The parameters last_ix and last_iy are optional, these values can also be found
by querying <A HREF="#GINTOUT">GINTOUT</A>(1) to GINTOUT(2)<A HREF="#.">.</A>

<B>Example:</B>

    <A HREF="#REPEAT">REPEAT</A>
    <A HREF="#UNTIL">UNTIL</A> <A HREF="#MOUSEK">MOUSEK</A>=1
    ~GRAF_DRAWBOX(25,25,50,50,10,10,150,150,lx%,ly%)
    <A HREF="#BOX">BOX</A> lx%,ly%,lx%+25,ly%+25

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> When the left mouse button is pressed, a small rectangle will move with the
    mouse pointer, provided that this does not take it outside the specified
    larger rectangle (in this case 10, 10 <A HREF="#-">-</A> 160, 160)<A HREF="#.">.</A> When the button is
    released, the function terminates and the smaller rectangle is redrawn at
    its final position with the standard <A HREF="#BOX">BOX</A> command.

graf_dragbox()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="GRAF_GROWBOX">GRAF_GROWBOX</H2>
<B><A HREF="#GRAF_GROWBOX">GRAF_GROWBOX</A>(sx,sy,sw,sh,dx,dy,dw,dh)</B>

sx, sy, sw, sh, dx, dy, dw, dh: <A HREF="#iexp">iexp</A>

This function draws an expanding rectangle.

Returns 0 if an error occurred.

    sx <A HREF="#-">-</A> Initial x-coordinate of the top left corner of the rectangle.
    sy <A HREF="#-">-</A> Initial y-coordinate of the top left corner of the rectangle.
    sw <A HREF="#-">-</A> Initial width of the rectangle.
    sh <A HREF="#-">-</A> Initial height of the rectangle.
    dx <A HREF="#-">-</A> Final x-coordinate of the top left corner.
    dy <A HREF="#-">-</A> Final y-coordinate of the top left corner.
    dw <A HREF="#-">-</A> Final width.
    dh <A HREF="#-">-</A> Final height.

<B>Example:</B>

    <A HREF="#BOX">BOX</A> 100,100,110,110
    <A HREF="#PAUSE">PAUSE</A> 25
    <A HREF="#~">~</A><A HREF="#GRAF_GROWBOX">GRAF_GROWBOX</A>(100,100,10,10,0,0,300,180)
    <A HREF="#BOX">BOX</A> 0,0,300,180

graf_growbox()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="GRAF_HANDLE">GRAF_HANDLE</H2>
<B><A HREF="#GRAF_HANDLE">GRAF_HANDLE</A>([char_w,char_h,box_w,box_h])</B>

char_w, char_h, box_w, box_h: <A HREF="#ivar">ivar</A>

Returns the identification number of the current <A HREF="#VDI">VDI</A> Workstation, which is used
internally for <A HREF="#AES">AES</A> calls, and returns the size of a character from the system
character set.

    char_w <A HREF="#-">-</A> Returns the width in pixels of a character from the standard set.
    char_h <A HREF="#-">-</A> Returns the height in pixels of a character from the standard set.
    box_w  <A HREF="#-">-</A> Returns the width of a standard character cell.
    box_h  <A HREF="#-">-</A> Returns the height of a standard character cell.

The parameters char_w, char_h, box_w, and box_h are optional, these values can
also be found by querying <A HREF="#GINTOUT">GINTOUT</A>(1) to GINTOUT(4)<A HREF="#.">.</A>

graf_handle()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="GRAF_MKSTATE">GRAF_MKSTATE</H2>
<B><A HREF="#GRAF_MKSTATE">GRAF_MKSTATE</A>([mx,my,m_state,k_state])</B>

mx, my, m_state, k_state: <A HREF="#ivar">ivar</A>

This function returns the current mouse pointer coordinates and the status of
the mouse buttons and the keyboard 'shift' keys.

This is an <A HREF="#AES">AES</A> routine to query the mouse. Unlike <A HREF="#MOUSEX">MOUSEX</A> etc., the function
gives valid results if the pointer is within a menu bar.

Return value will always be 1.

    mx      <A HREF="#-">-</A> Currnet x-coordinate of the mouse.
    my      <A HREF="#-">-</A> Current y-coordinate of the mouse.
    m_state <A HREF="#-">-</A> Mouse button status:
              Bit 0: Left button
              Bit 1: Right button
    k_state <A HREF="#-">-</A> Status of keyboard 'modifier' keys (if key is pressed bit is set)<A HREF="#:">:</A>
              Bit 0: Right shift key
              Bit 1: Left shift key
              Bit 2: Control key
              Bit 3: Alternate key

The parameters mx, my, m_state, and k_state are optional, these values can
also be found by querying <A HREF="#GINTOUT">GINTOUT</A>(1) to GINTOUT(4)<A HREF="#.">.</A>

<B>Memo:</B> <A HREF="#GRAF_MKSTATE">GRAF_MKSTATE</A><A HREF="#()">()</A> with no parameters crashes the compiler.

graf_mkstate()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="GRAF_MOUSE">GRAF_MOUSE</H2>
<B><A HREF="#GRAF_MOUSE">GRAF_MOUSE</A>(m_form,pattern_adr)</B>

m_form, pattern_adr: <A HREF="#iexp">iexp</A>

This function allows the appearance of the mouse pointer to be changed. Eight
pre-defined pointers are available, or on may be defined by the user.
(However, the command <A HREF="#DEFMOUSE">DEFMOUSE</A> is more convenient to use.)

Returns 0 if an error occurred.

    m_form      <A HREF="#-">-</A> Number of the mouse pointer shape:
                      0  <A HREF="#:">:</A> Arrow
                      1  <A HREF="#:">:</A> Text cursor
                      2  <A HREF="#:">:</A> Busy bee
                      3  <A HREF="#:">:</A> Pointing hand
                      4  <A HREF="#:">:</A> Open hand
                      5  <A HREF="#:">:</A> Thin cross-hair
                      6  <A HREF="#:">:</A> Thick cross-hair
                      7  <A HREF="#:">:</A> Outlined cross-hair
                      8  <A HREF="#:">:</A> Arrows pointing in all directions  NAES
                      9  <A HREF="#:">:</A> Arrows pointing left and right     NAES
                      10 <A HREF="#:">:</A> Arrows pointing up and down        NAES
                      255: User defined
                      256: Hide mouse pointer (<A HREF="#HIDEM">HIDEM</A>)
                      257: Show mouse pointer (<A HREF="#SHOWM">SHOWM</A>)
                      258: Save current mouse form            AES4
                      259: Restore saved mouse form           AES4
                      260: Restore previous mouse form        AES4
    pattern_adr <A HREF="#-">-</A> Address of bit information defining the mouse pointer as
                  desired. 37 word-sized values are expected, as follows:
                      1       <A HREF="#:">:</A> x-coordinate of the action point (i.e. the
                                point referred to by <A HREF="#MOUSEX">MOUSEX</A>, <A HREF="#MOUSEY">MOUSEY</A> etc.)
                      2       <A HREF="#:">:</A> y-coordinate of the action point
                      3       <A HREF="#:">:</A> Number of color levels, always 1
                      4       <A HREF="#:">:</A> Mask color, always 0
                      5       <A HREF="#:">:</A> Pointer color, always 1
                      6 to 21 <A HREF="#:">:</A> Mask definition (16 words, i.e. 16x16 bits)
                      22 to 37: Pointer definition (16 words, i.e. 16x16 bits)

graf_mouse()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="GRAF_MOVEBOX">GRAF_MOVEBOX</H2>
<B><A HREF="#GRAF_MOVEBOX">GRAF_MOVEBOX</A>(w,h,sx,sy,dx,dy)</B>

w, h, sx, sy, dx, dy: <A HREF="#iexp">iexp</A>

This function draws a moving rectangle with constant width and height.

Returns 0 if an error occurred.

    w  <A HREF="#-">-</A> Width of the rectangle.
    h  <A HREF="#-">-</A> Height of the rectangle.
    sx <A HREF="#-">-</A> Initial x-coordinate of top left corner of the rectangle.
    sy <A HREF="#-">-</A> Initial y-coordinate of top left corner of the rectangle.
    dx <A HREF="#-">-</A> Final x-coordinate of the top left corner.
    dx <A HREF="#-">-</A> Final y-coordinate of the top left corner.

<B>Example:</B>

    <A HREF="#~">~</A><A HREF="#GRAF_MOVEBOX">GRAF_MOVEBOX</A>(25,25,0,0,150,150)

graf_movebox()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="graf_multirubber">graf_multirubber</H2>
<B><A HREF="#graf_multirubber">graf_multirubber</A>(x, y, minw, minh, rec, wout, hout)</B>

x, y, minw, minh, rec: <A HREF="#iexp">iexp</A>
wout, hout: <A HREF="#ivar">ivar</A>

If 'rec' is null, the call functions the same as <A HREF="#GRAF_RUBBERBOX">GRAF_RUBBERBOX</A><A HREF="#()">()</A><A HREF="#.">.</A>

Parameter 'rec' if used is defined as offests:
  <A HREF="#INLINE">INLINE</A> rec%,8
  <A HREF="#WORD">WORD</A>{rec%+0}=1   !offset from x,y
  <A HREF="#WORD">WORD</A>{rec%+2}=1
  <A HREF="#WORD">WORD</A>{rec%+4}<A HREF="#=">=</A>-16 !offset from mouse x,y
  <A HREF="#WORD">WORD</A>{rec%+6}<A HREF="#=">=</A>-16

<B>Memo:</B> This call is not built into <A HREF="#GFA-Basic">GFA-Basic</A> so it's listed below:

<A HREF="#FUNCTION">FUNCTION</A> <A HREF="#graf_multirubber">graf_multirubber</A>(x&,y&,minw&,minh&,rec%,<A HREF="#VAR">VAR</A> outw&,outh&)
  <A HREF="#$F%">$F%</A>
  <A HREF="#GCONTRL">GCONTRL</A>(0)=69
  <A HREF="#GCONTRL">GCONTRL</A>(1)=4
  <A HREF="#GCONTRL">GCONTRL</A>(2)=3
  <A HREF="#GCONTRL">GCONTRL</A>(3)=1
  <A HREF="#GCONTRL">GCONTRL</A>(4)=0
  <A HREF="#GINTIN">GINTIN</A>(0)=x&
  <A HREF="#GINTIN">GINTIN</A>(1)=y&
  <A HREF="#GINTIN">GINTIN</A>(2)=minw&
  <A HREF="#GINTIN">GINTIN</A>(3)=minh&
  <A HREF="#ADDRIN">ADDRIN</A>(0)=rec%
  <A HREF="#GEMSYS">GEMSYS</A>
  outw&<A HREF="#=">=</A><A HREF="#GINTOUT">GINTOUT</A>(1)
  outh&<A HREF="#=">=</A><A HREF="#GINTOUT">GINTOUT</A>(2)
  <A HREF="#RETURN">RETURN</A> <A HREF="#GINTOUT">GINTOUT</A>(0)
<A HREF="#ENDFUNC">ENDFUNC</A>
<HR SIZE=3><H2 ID="GRAF_RUBBERBOX">GRAF_RUBBERBOX</H2>
<B><A HREF="#GRAF_RUBBERBOX">GRAF_RUBBERBOX</A>(lx,ty,min_w,min_h[,last_w,last_h])</B>

lx, ty, min_w, min_h: <A HREF="#iexp">iexp</A>
last_w, last_h: <A HREF="#ivar">ivar</A>

This function draws an outline of a rectangle while the left button is held
down. The top left corner is fixed, but the width and height of the rectangle
change with the position of the mouse. The function should be called only when
a button is pressed, since it terminates when the button is released.

Returns 0 if an error occured.

    lx     <A HREF="#-">-</A> x-coordinate of top left corner.
    ty     <A HREF="#-">-</A> y-coordinate of top left corner.
    min_w  <A HREF="#-">-</A> Minimum width of rectangle.
    min_h  <A HREF="#-">-</A> Minimum height of rectangle.
    last_w <A HREF="#-">-</A> Returns width of rectangle when function terminates.
    last_h <A HREF="#-">-</A> Returns heigth of rectangle when function terminates.

The parameters last_w and last_h are optional, these values can also be found
by querying <A HREF="#GINTOUT">GINTOUT</A>(1) to GINTOUT(2)<A HREF="#.">.</A>

<B>Example:</B>

    <A HREF="#DO">DO</A>
      <A HREF="#~">~</A><A HREF="#EVNT_BUTTON">EVNT_BUTTON</A>(1,1,1,mx%,my%,bu%,kb%)
      ~GRAP_RUBBERBOX(mx%,my%,1,1,w%,h%)
      <A HREF="#BOX">BOX</A> mx%,my%,mx%+w%,my%+h%
    <A HREF="#LOOP_UNTIL">LOOP UNTIL</A> <A HREF="#BTST">BTST</A>(kb%,3)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> <A HREF="#EVNT_BUTTON">EVNT_BUTTON</A><A HREF="#()">()</A> waits for the left button to be pressed, then puts the mouse
    coordinates into mx% and my%, and the status of the keyboard 'modifier'
    keys into kb%<A HREF="#.">.</A> The variables mx% and my% are then passed to
    GFAF_RUBBERBOX(), which continuously draws rectangles from (mx%, my%) to
    the current mouse position. When the function is terminated by releasing
    the button, <A HREF="#GRAF_RUBBERBOX">GRAF_RUBBERBOX</A><A HREF="#()">()</A> puts the last width and height into w% and h%<A HREF="#.">.</A>
    A fixed box is then drawn with the standard <A HREF="#BOX">BOX</A> command. The program then
    ends if the Alternate key was held down when the mouse button was first
    pressed (i.e. bit 3 of kb% is set to 1), or otherwise loops around to draw
    another box.

graf_rubberbox()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="GRAF_SHRINKBOX">GRAF_SHRINKBOX</H2>
<B><A HREF="#GRAF_SHRINKBOX">GRAF_SHRINKBOX</A>(sx,sy,sw,sh,dx,dy,dw,dh)</B>

sx, sy, sw, sh, dx, dy, dw, dh: <A HREF="#iexp">iexp</A>

This function draws an shrinking rectangle.

Returns 0 if an error occurred.

    sx <A HREF="#-">-</A> Final x-coordinate of the top left corner of the rectangle.
    sy <A HREF="#-">-</A> Final y-coordinate of the top left corner of the rectangle.
    sw <A HREF="#-">-</A> Final width of the rectangle.
    sh <A HREF="#-">-</A> Final height of the rectangle.
    dx <A HREF="#-">-</A> Initial x-coordinate of the top left corner.
    dy <A HREF="#-">-</A> Initial y-coordinate of the top left corner.
    dw <A HREF="#-">-</A> Initial width.
    dh <A HREF="#-">-</A> Initial height.

<B>Note:</B> The final coordinates are given first.

<B>Example:</B>

    <A HREF="#BOX">BOX</A> 0,0,300,180
    <A HREF="#PAUSE">PAUSE</A> 25
    <A HREF="#~">~</A><A HREF="#GRAF_SHRINKBOX">GRAF_SHRINKBOX</A>(100,100,10,10,0,0,300,180)
    <A HREF="#BOX">BOX</A> 100,100,110,110

graf_shrinkbox()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="GRAF_SLIDEBOX">GRAF_SLIDEBOX</H2>
<B><A HREF="#GRAF_SLIDEBOX">GRAF_SLIDEBOX</A>(tree,parent_obj,slider_obj,flag)</B>

tree, parent_obj, slider_obj, flag: <A HREF="#iexp">iexp</A>

This function also really should be in the <A HREF="#Object_Library">Object Library</A><A HREF="#.">.</A> It moves one
rectangle object within another in a similar way to GFAF_DRAGBOX()<A HREF="#.">.</A> However,
the object can only be moved horizontally or vertically and, in addition, it
must be a 'child' of the limiting rectangle (object)<A HREF="#.">.</A> The function call should
only take place when a mouse button is pressed, since the function terminates
when the button is released. The most common application is the movement of
slider bars in windows.

Returns the position of the sliding rectangle relative to the limiting
rectangle:

    Horizontally: 0=far left  1000=far right
    Vertically  <A HREF="#:">:</A> 0=top       1000=bottom

    tree       <A HREF="#-">-</A> Address of the object tree.
    parent_obj <A HREF="#-">-</A> Object number of the limiting rectangle.
    slider_obj <A HREF="#-">-</A> Object number of the sliding rectangle.
    flag       <A HREF="#-">-</A> Direction:
                 0: Horizontal
                 1: Vertical

graf_slidebox()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="GRAF_WATCHBOX">GRAF_WATCHBOX</H2>
<B><A HREF="#GRAF_WATCHBOX">GRAF_WATCHBOX</A>(tree,obj,in_state,out_state)</B>

tree, obj, instate, out_state: <A HREF="#iexp">iexp</A>

This function (which really belongs in the <A HREF="#Object_Library">Object Library</A>) monitors an object
in a tree while a mouse button is pressed, checking whether the mouse pointer
is inside it or outside. When the button is released, the status of the object
takes one of two specified values (normal selected/normal), depending on
whether the pointer was located inside the object, or outside.

Returns 1 if the mouse pointer was inside the object when the button was
released, or 0 if it was outside.

    tree      <A HREF="#-">-</A> Address of the object tree.
    obj       <A HREF="#-">-</A> Number of the object to be monitored.
    in_state  <A HREF="#-">-</A> Status (<A HREF="#OB_STATE">OB_STATE</A>) to be given to the object if the mouse is
                found to be within it.
    out_state <A HREF="#-">-</A> Status (<A HREF="#OB_STATE">OB_STATE</A>) to be given to the object if the mouse
                pointer is found to be outside it. The appropriate bit
                allocation is found under <A HREF="#OB_STATE">OB_STATE</A><A HREF="#()">()</A><A HREF="#.">.</A>

graf_watchbox()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="Scrap_Library">Scrap Library</H2>
<A HREF="#SCRP_READ">SCRP_READ</A><A HREF="#()">()</A>
<A HREF="#SCRP_WRITE">SCRP_WRITE</A><A HREF="#()">()</A>

Conatins routines enabling the exchange of data between different applications.

<A HREF="#Scrap_Library">Scrap Library</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="SCRP_READ">SCRP_READ</H2>
<B><A HREF="#SCRP_READ">SCRP_READ</A>(path$)</B>

path$<A HREF="#:">:</A> <A HREF="#svar">svar</A>

This function returns the current clipboard directory.

Returns 0 if the clipboard path was never set, and non-zero if set correctly.

    path$ <A HREF="#-">-</A> Returns the current clipboard path.

<B>Examle:</B>

    <A HREF="#~">~</A><A HREF="#SCRP_READ">SCRP_READ</A>(c$)
    <A HREF="#PRINT">PRINT</A> c$

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Displays <A HREF="#'">'</A><A HREF="#C:">C:</A>\CLIPBRD\' on the screen, assuming the clipboard path was
    previously set correctly.

scrp_read()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="SCRP_WRITE">SCRP_WRITE</H2>
<B><A HREF="#SCRP_WRITE">SCRP_WRITE</A>(path$)</B>

path$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>

This function sets the location of the clipboard directory.

Returns 0 if an error occured or non-zero otherwise.

    path$ <A HREF="#-">-</A> String containing a valid path. (i.e. "<A HREF="#C:">C:</A>\CLIPBRD\")

<B>Example:</B>

    <A HREF="#~">~</A><A HREF="#SCRP_WRITE">SCRP_WRITE</A>("<A HREF="#C:">C:</A>\CLIPBRD\")

scrp_write()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="File_Selector_Library">File Selector Library</H2>
<A HREF="#fsel_exinput">fsel_exinput</A><A HREF="#()">()</A>
<A HREF="#FSEL_INPUT">FSEL_INPUT</A><A HREF="#()">()</A>

The <A HREF="#File_Selector_Library">File Selector Library</A> contains routines to allow the user to select a file
from a displayed directory, or to specify a file by typing its name.

<A HREF="#File_Selector_Library">File Selector Library</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="fsel_exinput">fsel_exinput</H2>
<B><A HREF="#fsel_exinput">fsel_exinput</A>(title$,path$,file$,button)</B>

title$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>
path$, file$<A HREF="#:">:</A> <A HREF="#svar">svar</A>
button: <A HREF="#ivar">ivar</A>

Displays the systen File Selector Box and offers the user an opportunity to
chose a complete <A HREF="#GEMDOS">GEMDOS</A> path specification. See also the <A HREF="#FILESELECT">FILESELECT</A> command.

Returns 0 if an error occured or 1 otherwise.

On entry:
    title$ <A HREF="#-">-</A> Title to appear (maximum of 30 characters)<A HREF="#.">.</A>
    path$  <A HREF="#-">-</A> Initial directory.
    file$  <A HREF="#-">-</A> Default file name.

On exit:
    path$  <A HREF="#-">-</A> Final directory.
    file$  <A HREF="#-">-</A> Chosen file name.
    button <A HREF="#-">-</A> Returns the button clicked:
             0: 'Cancel' was clicked.
             1: 'Ok' was clicked.

<B>Note:</B> Please refer to <A HREF="#AES">AES</A> documentation for proper use.

<B>Memo:</B> This call is not built into <A HREF="#GFA-Basic">GFA-Basic</A> and is included below:

<A HREF="#FUNCTION">FUNCTION</A> <A HREF="#fsel_exinput">fsel_exinput</A>(title$,<A HREF="#VAR">VAR</A> path$,file$,button&)
  <A HREF="#$F%">$F%</A>
  title$<A HREF="#=">=</A><A HREF="#MID$">MID$</A>(title$,1,30)<A HREF="#+">+</A><A HREF="#CHR$">CHR$</A>(0)
  path$=path$<A HREF="#+">+</A><A HREF="#CHR$">CHR$</A>(0)+<A HREF="#STRING$">STRING$</A>(256,0)
  file$=file$<A HREF="#+">+</A><A HREF="#CHR$">CHR$</A>(0)+<A HREF="#STRING$">STRING$</A>(256,0)
  <A HREF="#GCONTRL">GCONTRL</A>(0)=91
  <A HREF="#GCONTRL">GCONTRL</A>(1)=0
  <A HREF="#GCONTRL">GCONTRL</A>(2)=2
  <A HREF="#GCONTRL">GCONTRL</A>(3)=3
  <A HREF="#GCONTRL">GCONTRL</A>(4)=0
  <A HREF="#ADDRIN">ADDRIN</A>(0)=V:path$
  <A HREF="#ADDRIN">ADDRIN</A>(1)=V:file$
  <A HREF="#ADDRIN">ADDRIN</A>(2)=V:title$
  <A HREF="#GEMSYS">GEMSYS</A>
  path$<A HREF="#=">=</A><A HREF="#CHAR">CHAR</A>{V:path$}
  file$<A HREF="#=">=</A><A HREF="#CHAR">CHAR</A>{V:file$}
  button&<A HREF="#=">=</A><A HREF="#GINTOUT">GINTOUT</A>(1)
  <A HREF="#RETURN">RETURN</A> <A HREF="#GINTOUT">GINTOUT</A>(0)
<A HREF="#ENDFUNC">ENDFUNC</A>

<A HREF="#fsel_exinput">fsel_exinput</A><A HREF="#()">()</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="FSEL_INPUT">FSEL_INPUT</H2>
<B><A HREF="#FSEL_INPUT">FSEL_INPUT</A>(path$,name$[,button])</B>

path$, name$<A HREF="#:">:</A> <A HREF="#svar">svar</A>
button: <A HREF="#ivar">ivar</A>

This function invokes the standard File Selector Box, and corresponds to the
<A HREF="#FILESELECT">FILESELECT</A> instruction. The initial directory path and the default file name
are contained in the string variables path$ and name$<A HREF="#.">.</A> After the file selector
box has been used in the normal way, and the function exited by clicking on
'Ok' or 'Cancel', these strings contain the last used directory path and chosen
file name respectively. The optional integer variable 'button' contains 1 or 0,
depending on whether the 'Ok' or 'Cancel' button was clicked.

Returns 0 if an error occured or 1 otherwise.

On entry:
    path$  <A HREF="#-">-</A> Initial directory path.
    mane$  <A HREF="#-">-</A> Default file name.

On exit:
    path$  <A HREF="#-">-</A> Final directory path.
    name$  <A HREF="#-">-</A> Chosen file.
    button <A HREF="#-">-</A> Returns the button clicked:
             0: 'Cancel' was clicked.
             1: 'Ok' was clicked.

The parameter button is optional, this value can also be found by querying
<A HREF="#GINTOUT">GINTOUT</A>(1)<A HREF="#.">.</A>

<B>Example:</B>

    p$<A HREF="#=">=</A>"a:\<A HREF="#*">*</A><A HREF="#.">.</A>*"
    n$<A HREF="#=">=</A>""
    <A HREF="#DO">DO</A>
      <A HREF="#~">~</A><A HREF="#FSEL_INPUT">FSEL_INPUT</A>(p$,n$,b)
      <A HREF="#CLS">CLS</A>
      <A HREF="#PRINT">PRINT</A> p$
      <A HREF="#PRINT">PRINT</A> n$
      <A HREF="#PRINT">PRINT</A> b
    <A HREF="#LOOP_UNTIL">LOOP UNTIL</A> b=0

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Various file names can be slected and displayed. The program finishes when
    the 'Cancel' button is clicked.

<B>Memo:</B> Does not handle long file names correctly.
      Paths over 100 characters will be truncated.
      File names over 50 characters will be truncated.
      A bug in the editor causes path$ to be +1 longer than it should be.
        A hidden trailing null is left on the end of the string.

fsel_input()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="Window_Library">Window Library</H2>
<A HREF="#WIND_CALC">WIND_CALC</A><A HREF="#()">()</A>
<A HREF="#WIND_CLOSE">WIND_CLOSE</A><A HREF="#()">()</A>
<A HREF="#WIND_CREATE">WIND_CREATE</A><A HREF="#()">()</A>
<A HREF="#WIND_DELETE">WIND_DELETE</A><A HREF="#()">()</A>
<A HREF="#wind_draw">wind_draw</A><A HREF="#()">()</A>
<A HREF="#WIND_FIND">WIND_FIND</A><A HREF="#()">()</A>
<A HREF="#WIND_GET">WIND_GET</A><A HREF="#()">()</A>
<A HREF="#wind_new">wind_new</A><A HREF="#()">()</A>
<A HREF="#WIND_OPEN">WIND_OPEN</A><A HREF="#()">()</A>
<A HREF="#WIND_SET">WIND_SET</A><A HREF="#()">()</A>
<A HREF="#wind_sget">wind_sget</A><A HREF="#()">()</A>
<A HREF="#WIND_UPDATE">WIND_UPDATE</A><A HREF="#()">()</A>

The <A HREF="#Window_Library">Window Library</A> contains all the functions relating to window management.

<A HREF="#Window_Library">Window Library</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="WIND_CALC">WIND_CALC</H2>
<B><A HREF="#WIND_CALC">WIND_CALC</A>(w_type,attr,ix,iy,iw,ih[,ox,oy,ow,oh])</B>

w_type, attr, ix, iy, iw, ih: <A HREF="#iexp">iexp</A>
ox, oy, ow, oh: <A HREF="#ivar">ivar</A>

This function computes the total size of a window (including slider bars, etc.)
from the size of the work area, or conversely, the size of the work area from
the total size of the window.

Returns 0 if an error occurred.

    w_type <A HREF="#-">-</A> Type of calculation to preform:
             0: Compute total size
             1: Compute work area size
    attr   <A HREF="#-">-</A> Window attributes as follows:         Bit
             &H0001  <A HREF="#NAME">NAME</A>     Title bar with name  0
             &H0002  <A HREF="#CLOSE">CLOSE</A>    Close box            1
             &H0004  FULL     Full box             2
             &H0008  MOVE     Move box             3
             &H0010  INFO     Information line     4
             &H0020  SIZE     Size box             5
             &H0040  UPARROW  Up arrow             6
             &H0080  DNARROW  Down arrow           7
             &H0100  VSLIDE   Vertical slider bar  8
             &H0200  LFARROW  Left arrow           9
             &H0400  RTARROW  Right arrow          10
             &H0800  HSLIDE   Horizontal slider    11
    ix     <A HREF="#-">-</A> Known left x-coordinate.
    iy     <A HREF="#-">-</A> Known top y-coordinate.
    iw     <A HREF="#-">-</A> Known width.
    ih     <A HREF="#-">-</A> Known height.
    ox     <A HREF="#-">-</A> Returns computed left x-coordinate.
    oy     <A HREF="#-">-</A> Returns computed top y-coordinate.
    ow     <A HREF="#-">-</A> Returns computed width.
    oh     <A HREF="#-">-</A> Returns computed height.

The parameters ox, oy, ow, and oh are optional, these values can also be found
by querying <A HREF="#GINTOUT">GINTOUT</A>(1) to GINTOUT(4)<A HREF="#.">.</A>

wind_calc()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="WIND_CLOSE">WIND_CLOSE</H2>
<B><A HREF="#WIND_CLOSE">WIND_CLOSE</A>(handle)</B>

handle: <A HREF="#iexp">iexp</A>

This function is the counterpart of <A HREF="#WIND_OPEN">WIND_OPEN</A><A HREF="#()">()</A> and closes the specified
window. Compare to <A HREF="#CLOSEW">CLOSEW</A>.

Returns 0 is an error occured.

    handle <A HREF="#-">-</A> Identification number of the window.

wind_close()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="WIND_CREATE">WIND_CREATE</H2>
<B><A HREF="#WIND_CREATE">WIND_CREATE</A>(attr,wx,wy,ww,wh)</B>

attr, wx, wy, ww, wh: <A HREF="#iexp">iexp</A>

This function allocates a new window, specifying the attributes and maximum
size. The window identification number (handle) is returned. Compare to <A HREF="#OPENW">OPENW</A>
#n,x,y,w,h,attr.

Returns window identification handle, or a negative value if an error occured.

    attr <A HREF="#-">-</A> Window attributes as follows:         Bit
           &H0001  <A HREF="#NAME">NAME</A>     Title bar with name  0
           &H0002  <A HREF="#CLOSE">CLOSE</A>    Close box            1
           &H0004  FULL     Full box             2
           &H0008  MOVE     Move box             3
           &H0010  INFO     Information line     4
           &H0020  SIZE     Size box             5
           &H0040  UPARROW  Up arrow             6
           &H0080  DNARROW  Down arrow           7
           &H0100  VSLIDE   Vertical slider bar  8
           &H0200  LFARROW  Left arrow           9
           &H0400  RTARROW  Right arrow          10
           &H0800  HSLIDE   Horizontal slider    11
           &H4000  ICONIFY  Iconifier            14 (<A HREF="#AES">AES</A> v4.1)
    wx   <A HREF="#-">-</A> Maximum x-position of left edge
    wy   <A HREF="#-">-</A> Maximum y-position of left edge
    ww   <A HREF="#-">-</A> Maximum width of the window
    wh   <A HREF="#-">-</A> Maximum height of the window

wind_create()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="WIND_DELETE">WIND_DELETE</H2>
<B><A HREF="#WIND_DELETE">WIND_DELETE</A>(handle)</B>

handle: <A HREF="#iexp">iexp</A>

This function deletes a window allocation and frees the reserved memory and
window identification number for re-use.

Returns 0 if an error occurred.

    handle <A HREF="#-">-</A> Identification number of the window.

wind_delete()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="wind_draw">wind_draw</H2>
<B><A HREF="#wind_draw">wind_draw</A><A HREF="#()">()</A></B>

<B>Memo:</B> This command is not built into <A HREF="#GFA-Basic">GFA-Basic</A> and is included below:

<A HREF="#FUNCTION">FUNCTION</A> <A HREF="#wind_draw">wind_draw</A>(wi_dhandle&,wi_dstartob&)
  <A HREF="#$F%">$F%</A>
  <A HREF="#GCONTRL">GCONTRL</A>(0)=99
  <A HREF="#GCONTRL">GCONTRL</A>(1)=2
  <A HREF="#GCONTRL">GCONTRL</A>(2)=1
  <A HREF="#GCONTRL">GCONTRL</A>(3)=0
  <A HREF="#GCONTRL">GCONTRL</A>(4)=0
  <A HREF="#GINTIN">GINTIN</A>(0)=wi_dhandle&
  <A HREF="#GINTIN">GINTIN</A>(1)=wi_dstartob&
  <A HREF="#GEMSYS">GEMSYS</A>
  <A HREF="#RETURN">RETURN</A> <A HREF="#GINTOUT">GINTOUT</A>(0)
<A HREF="#ENDFUNC">ENDFUNC</A>
<HR SIZE=3><H2 ID="WIND_FIND">WIND_FIND</H2>
<B><A HREF="#WIND_FIND">WIND_FIND</A>(fx,fy)</B>

fx,fy: <A HREF="#iexp">iexp</A>

This funtion determines the identification number of a window at a specified
coordinate.

Returns the identification number of the window found, or 0 meaning no window
(desktop was found instead)<A HREF="#.">.</A>

    fx <A HREF="#-">-</A> x-coordinate.
    fy <A HREF="#-">-</A> y-coordinate.

wind_find()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="WIND_GET">WIND_GET</H2>
<B><A HREF="#WIND_GET">WIND_GET</A>(handle,code[,w1,w2,w3,w4])</B>

handle, code: <A HREF="#iexp">iexp</A>
w1, w2, w3, w4: <A HREF="#ivar">ivar</A>

This function returns information about a window.

Returns 0 if an error occurred.

    handle <A HREF="#-">-</A> Identification number of the window.
    code   <A HREF="#-">-</A> Depending on the code specified, information is returned in
             w1, w2, w3, and w4 as follows:
                 4 <A HREF="#:">:</A> WF_WORKXYWH returns the size of the window work area:
                     w1 <A HREF="#-">-</A> returns left x-coordinate
                     w2 <A HREF="#-">-</A> returns top y-coordinate
                     w3 <A HREF="#-">-</A> returns width
                     w4 <A HREF="#-">-</A> returns height
                 5 <A HREF="#:">:</A> WF_CURRXYWH returns the total size of the entire window
                     including the borders:
                     w1 <A HREF="#-">-</A> returns left x-coordinate
                     w2 <A HREF="#-">-</A> returns top y-coordinate
                     w3 <A HREF="#-">-</A> returns width
                     w4 <A HREF="#-">-</A> returns height
                 6 <A HREF="#:">:</A> WF_PREVXYWH returns the total size of the previous window:
                     w1 <A HREF="#-">-</A> returns left x-coordinate
                     w2 <A HREF="#-">-</A> returns top y-coordinate
                     w3 <A HREF="#-">-</A> returns width
                     w4 <A HREF="#-">-</A> returns height
                 7 <A HREF="#:">:</A> WF_FULLXYWH returns the total maximum size of the window
                     (set by <A HREF="#WIND_CREATE">WIND_CREATE</A><A HREF="#()">()</A>)<A HREF="#:">:</A>
                     w1 <A HREF="#-">-</A> returns left x-coordinate
                     w2 <A HREF="#-">-</A> returns top y-coordinate
                     w3 <A HREF="#-">-</A> returns width
                     w4 <A HREF="#-">-</A> returns height
                 8 <A HREF="#:">:</A> WF_HSLIDE returns the position of the horizontal slider:
                     w1 <A HREF="#-">-</A> returns slider position (0=far left, 1000=far right)
                 9 <A HREF="#:">:</A> WF_VSLIDE returns the position of the vertical slider:
                     w1 <A HREF="#-">-</A> returns slider position (0=top, 1000=bottom)
                 10: WF_TOP returns the identification number of the top
                     (active) window:
                     w1 <A HREF="#-">-</A> returns the identication number
                 11: WF_FIRSTXYWH returns the coordinates of the first
                     rectangle in the specified window's rectangle list. (The
                     list of rectangles required to build up the window: an
                     unobscured window has one rectangle in its list, a window
                     partially obscured by another window has several, a
                     totally obscured window has none)<A HREF="#:">:</A>
                     w1 <A HREF="#-">-</A> returns left x-coordinate
                     w2 <A HREF="#-">-</A> returns top y-coordinate
                     w3 <A HREF="#-">-</A> returns width
                     w4 <A HREF="#-">-</A> returns height
                 12: WF_NEXTXYWH returns the coordinates of the next rectangle
                     in the specified window's rectangle list:
                     w1 <A HREF="#-">-</A> returns left x-coordinate
                     w2 <A HREF="#-">-</A> returns top y-coordinate
                     w3 <A HREF="#-">-</A> returns width
                     w4 <A HREF="#-">-</A> returns height
                 13: WF_RESVD reserved
                 15: WF_HSLIZE returns the size of the horizontal slider bar
                     compared to its maximum possible size:
                     w1 <A HREF="#-">-</A> returns slider size (1=small, 1000=full width)
                 16: WF_VSLIZE returns the size of the vertical slider bar
                     compared to its maximum possible size:
                     w1 <A HREF="#-">-</A> returns slider size (1=small, 1000=full height)

The parameters w1, w2, w3, and w4 are optional, these values can also be found
by querying <A HREF="#GINTOUT">GINTOUT</A>(1) to GINTOUT(4)<A HREF="#.">.</A>

wind_get()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="wind_new">wind_new</H2>
<B><A HREF="#wind_new">wind_new</A></B>

This function closes and deletes all of the application's windows. In addition,
the state of <A HREF="#WIND_UPDATE">WIND_UPDATE</A><A HREF="#()">()</A>, and the mouse pointer hide count is reset. This
call should only be used to clean up after a fatal error.

Return value is not used.

<B>Note:</B> Please refer to <A HREF="#AES">AES</A> documentation for proper use.

<B>Memo:</B> This command is not built into <A HREF="#GFA-Basic">GFA-Basic</A> and is included below:

<A HREF="#FUNCTION">FUNCTION</A> <A HREF="#wind_new">wind_new</A>
  <A HREF="#$F%">$F%</A>
  <A HREF="#GCONTRL">GCONTRL</A>(0)=109
  <A HREF="#GCONTRL">GCONTRL</A>(1)=0
  <A HREF="#GCONTRL">GCONTRL</A>(2)=1
  <A HREF="#GCONTRL">GCONTRL</A>(3)=0
  <A HREF="#GCONTRL">GCONTRL</A>(4)=0
  <A HREF="#GEMSYS">GEMSYS</A>
  <A HREF="#RETURN">RETURN</A> <A HREF="#GINTOUT">GINTOUT</A>(0)
<A HREF="#ENDFUNC">ENDFUNC</A>

<A HREF="#wind_new">wind_new</A><A HREF="#()">()</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="WIND_OPEN">WIND_OPEN</H2>
<B><A HREF="#WIND_OPEN">WIND_OPEN</A>(handle,wx,wy,ww,wh)</B>

handle, wx, wy, ww, wh: <A HREF="#iexp">iexp</A>

This function draws on the screen a window previously created with
<A HREF="#WIND_CREATE">WIND_CREATE</A><A HREF="#()">()</A><A HREF="#.">.</A> Compare to <A HREF="#OPENW">OPENW</A>.

Returns 0 if an error occurred.

    handle <A HREF="#-">-</A> Identification number of the window.
    wx     <A HREF="#-">-</A> Left x-coordinate.
    wy     <A HREF="#-">-</A> Top y-coordinate.
    ww     <A HREF="#-">-</A> Initial width of the window.
    wh     <A HREF="#-">-</A> Initial height of the window.

wind_set()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="WIND_SET">WIND_SET</H2>
<B><A HREF="#WIND_SET">WIND_SET</A>(handle,code,w1,w2,w3,w4)</B>

handle, code, w1, w2, w3, w4: <A HREF="#iexp">iexp</A>

This function changes parts of a window according to the specified function
code.

Returns 0 if an error occured.

    handle <A HREF="#-">-</A> Identification number of the window.
    code   <A HREF="#-">-</A> Specifies components to be changed:
                 1 <A HREF="#:">:</A> WF_KIND sets new window components (as with
                     <A HREF="#WIND_CREATE">WIND_CREATE</A><A HREF="#()">()</A>)<A HREF="#:">:</A>
                     w1 <A HREF="#-">-</A> New window part
                 2 <A HREF="#:">:</A> WF_NAME sets the title
                     w1 <A HREF="#-">-</A> High-word of the address of the string
                     w2 <A HREF="#-">-</A> Low-word of the address of the string
                     Note the string must be terminated with a null (0) byte.
                 3 <A HREF="#:">:</A> WF_INFO sets the information line:
                     w1 <A HREF="#-">-</A> High-word of the address of the string
                     w2 <A HREF="#-">-</A> Low-word of the address of the string
                     Note the string must be terminated with a null (0) byte.
                 5 <A HREF="#:">:</A> WF_CURRXYWH sets the total window size:
                     w1 <A HREF="#-">-</A> Left x-coordinate
                     w2 <A HREF="#-">-</A> Top y-coordinate
                     w3 <A HREF="#-">-</A> Width
                     w4 <A HREF="#-">-</A> Height
                 8 <A HREF="#:">:</A> WF_HSLIDE set the position of the horizontal slider:
                     w1 <A HREF="#-">-</A> Slider position (1=far left, 1000=far right)
                 9 <A HREF="#:">:</A> WF_VSLIDE set the position of the vertical slider:
                     w1 <A HREF="#-">-</A> Slider position (1=top, 1000=bottom)
                 10: WF_TOP Sets the top (currently active) window:
                     w1 <A HREF="#-">-</A> Handle of window to make active
                 14: WF_NEWDESK sets a new desktop background
                     w1 <A HREF="#-">-</A> High-word of the address of the tree
                     w2 <A HREF="#-">-</A> Low-word of the address of the tree
                 15: WF_HSLIZE sets the size of the horizontal slider bar
                     compared to its maximum possible size:
                     w1 <A HREF="#-">-</A> Slider size (1=small, 1000=full width)
                 16: WF_VSLIZE sets the size of the vertical slider bar
                     compared to its maximum possible size:
                     w1 <A HREF="#-">-</A> Slider size (1=small, 1000=full height)

wind_set()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="wind_sget">wind_sget</H2>
<B><A HREF="#wind_sget">wind_sget</A><A HREF="#()">()</A></B>

<B>Memo:</B> This call is not built into <A HREF="#GFA-Basic">GFA-Basic</A> so it's listed below:

<A HREF="#FUNCTION">FUNCTION</A> <A HREF="#wind_sget">wind_sget</A>(w_handle&,w_field&,buff%)
  <A HREF="#$F%">$F%</A>
  <A HREF="#GCONTRL">GCONTRL</A>(0)=104
  <A HREF="#GCONTRL">GCONTRL</A>(1)=4
  <A HREF="#GCONTRL">GCONTRL</A>(2)=1
  <A HREF="#GCONTRL">GCONTRL</A>(3)=0
  <A HREF="#GCONTRL">GCONTRL</A>(4)=0
  <A HREF="#GINTIN">GINTIN</A>(0)=w_handle&
  <A HREF="#GINTIN">GINTIN</A>(1)=w_field&
  <A HREF="#GINTIN">GINTIN</A>(2)<A HREF="#=">=</A><A HREF="#CARD">CARD</A>(<A HREF="#SWAP">SWAP</A>(buff%))
  <A HREF="#GINTIN">GINTIN</A>(3)<A HREF="#=">=</A><A HREF="#CARD">CARD</A>(buff%)
  <A HREF="#GEMSYS">GEMSYS</A>
  <A HREF="#RETURN">RETURN</A> <A HREF="#GINTOUT">GINTOUT</A>(0)
<A HREF="#ENDFUNC">ENDFUNC</A>
<HR SIZE=3><H2 ID="WIND_UPDATE">WIND_UPDATE</H2>
<B><A HREF="#WIND_UPDATE">WIND_UPDATE</A>(flag)</B>

flag: <A HREF="#iexp">iexp</A>

This function coordinates all functions connected with screen redrawing, in
particular in combination with Pull-dowm Menus.

Returns 0 if and error occurred.

    flag <A HREF="#-">-</A> Function:
           0: Screen redraw completed                     END_UPDATE
           1: Screen redraw starting                      BEG_UPDATE
           2: Application relinquishes mouse supervision  END_MCTRL
           3: Application takes over mouse supervision    BEG_MCTRL
              GEM functions for menus and window handling are inactive.

wind_update()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="Resource_Library">Resource Library</H2>
<A HREF="#RSRC_FREE">RSRC_FREE</A><A HREF="#()">()</A>
<A HREF="#RSRC_GADDR">RSRC_GADDR</A><A HREF="#()">()</A>
<A HREF="#RSRC_LOAD">RSRC_LOAD</A><A HREF="#()">()</A>
<A HREF="#RSRC_OBFIX">RSRC_OBFIX</A><A HREF="#()">()</A>
<A HREF="#rsrc_rcfix">rsrc_rcfix</A><A HREF="#()">()</A>
<A HREF="#RSRC_SADDR">RSRC_SADDR</A><A HREF="#()">()</A>

The <A HREF="#Resource_Library">Resource Library</A> provides routines for the creation of a graphical user
interface (i.e. dialog boxes, etc.) which allows, independantly of the current
screen resolution, the exchange of data between the user and program.

<A HREF="#Resource_Library">Resource Library</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="RSRC_FREE">RSRC_FREE</H2>
<B><A HREF="#RSRC_FREE">RSRC_FREE</A><A HREF="#()">()</A></B>

This function releases the memory space reserved by <A HREF="#RSRC_LOAD">RSRC_LOAD</A><A HREF="#()">()</A><A HREF="#.">.</A>

Returns 0 if an error occured.

<B>Example:</B>

    <A HREF="#~">~</A><A HREF="#RSRC_FREE">RSRC_FREE</A><A HREF="#()">()</A>

rsrc_free()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="RSRC_GADDR">RSRC_GADDR</H2>
<B><A HREF="#RSRC_GADDR">RSRC_GADDR</A>(type,<A HREF="#index">index</A>,addr)</B>

type, index: <A HREF="#iexp">iexp</A>
addr: <A HREF="#ivar">ivar</A>

The function determines the address of a resource structure after it has been
loaded with <A HREF="#RSRC_LOAD">RSRC_LOAD</A><A HREF="#()">()</A><A HREF="#.">.</A> Depending on the version of GEM, this function may
only work for object trees and alerts (ad_frstr)<A HREF="#.">.</A>

Returns 0 if an error occured.

    type  <A HREF="#-">-</A> Type of structure whose address is to be found:
            0 <A HREF="#:">:</A> Object tree  the tree loaded with <A HREF="#RSRC_LOAD">RSRC_LOAD</A><A HREF="#()">()</A>
            1 <A HREF="#:">:</A> <A HREF="#OBJECT">OBJECT</A>       object
            2 <A HREF="#:">:</A> <A HREF="#TEDINFO">TEDINFO</A>      text information
            3 <A HREF="#:">:</A> <A HREF="#ICONBLK">ICONBLK</A>      icon information
            4 <A HREF="#:">:</A> <A HREF="#BITBLK">BITBLK</A>       bit-mapped graphic information
            5 <A HREF="#:">:</A> STRING       text
            6 <A HREF="#:">:</A> image data   bit-mapped graphic
            7 <A HREF="#:">:</A> obspec       object specification
            8 <A HREF="#:">:</A> te_ptext     string
            9 <A HREF="#:">:</A> te_ptmplt    text template
            10: te_pvalid    text validation string
            11: ib_pmask     icon display mask
            12: ib_data      icon bit map
            13: ib_text      icon text
            14: bi_pdata     image data
            15: ad_frstr     address of pointer to free string
            15: ad_frimg     address of pointer to free string
    <A HREF="#index">index</A> <A HREF="#-">-</A> The number (not the object number) of the object whose address is
            requested, counting objects of that type one by one from the
            beginning of the Resource file.
    addr  <A HREF="#-">-</A> Returns the requested address.

<B>Example:</B>

    <A HREF="#~">~</A><A HREF="#RSRC_GADDR">RSRC_GADDR</A>(0,0,tree%)

<B>Memo:</B> The code inside the editor seems to indicate that parameter 'addr'
      should be optional, however the syntax rule doesn't seem to allow it.

rsrc_gaddr()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="RSRC_LOAD">RSRC_LOAD</H2>
<B><A HREF="#RSRC_LOAD">RSRC_LOAD</A>(name$)</B>

name$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>

This function reserves memory and loads a resource file. Then internal pointers
are set and the coordinates of characters converted into pixel format. (For
Resources which have been defined directly in memory, with <A HREF="#POKE">POKE</A>, etc,
<A HREF="#RSRC_OBFIX">RSRC_OBFIX</A><A HREF="#()">()</A> must be used to do this)<A HREF="#.">.</A> If the file cannot be found, RSC_LOAD()
automatically does a little searching, as detailed under <A HREF="#SHEL_FIND">SHEL_FIND</A><A HREF="#()">()</A><A HREF="#.">.</A>

Returns 0 if an error occured.

    name$ <A HREF="#-">-</A> File specification of the Resource file.

<B>Example:</B>

    <A HREF="#~">~</A><A HREF="#RSRC_LOAD">RSRC_LOAD</A>("TEST.RSC")

<B>Memo:</B> If your <A HREF="#*">*</A>.ACC uses a resource file it should either be contained
      within the binary itself or loaded by you and then fixed up. If you call
      <A HREF="#RSRC_LOAD">RSRC_LOAD</A><A HREF="#()">()</A> to load it and a resolution change takes place then TOS does
      not free the ram allocated to the resource.

rsrc_load()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="RSRC_OBFIX">RSRC_OBFIX</H2>
<B><A HREF="#RSRC_OBFIX">RSRC_OBFIX</A>(tree,obj)</B>

tree, obj: <A HREF="#iexp">iexp</A>

This function converts the coordinates of an object within a tree, from
character coordinates to pixel coordinates, taking into account the current
screen resolution. It is called automatically by <A HREF="#RSRC_LOAD">RSRC_LOAD</A><A HREF="#()">()</A>, but must be used
if the object is created directly in memory by <A HREF="#POKE">POKE</A>, etc.

Return value will always be 1.

    tree <A HREF="#-">-</A> Address of the appropriate object tree.
    obj  <A HREF="#-">-</A> Object number of the object to be adjusted.

rsrc_obfix()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="rsrc_rcfix">rsrc_rcfix</H2>
<B><A HREF="#rsrc_rcfix">rsrc_rcfix</A>(rc_header)</B>

rc_header: <A HREF="#iexp">iexp</A>

Fixes up coordinates and memory pointers of raw resource data in memory.

Returns 0 if successful or non-zero otherwise.

    rc_header <A HREF="#-">-</A> Address of raw resource data in memory.

<B>Note:</B> Please refer to <A HREF="#AES">AES</A> documentation for proper use.

<B>Memo:</B> This call is not built into <A HREF="#GFA-Basic">GFA-Basic</A> and is included below.

<A HREF="#FUNCTION">FUNCTION</A> <A HREF="#rsrc_rcfix">rsrc_rcfix</A>(header%)
  <A HREF="#$F%">$F%</A>
  <A HREF="#GCONTRL">GCONTRL</A>(0)=115
  <A HREF="#GCONTRL">GCONTRL</A>(1)=0
  <A HREF="#GCONTRL">GCONTRL</A>(2)=1
  <A HREF="#GCONTRL">GCONTRL</A>(3)=1
  <A HREF="#GCONTRL">GCONTRL</A>(4)=0
  <A HREF="#ADDRIN">ADDRIN</A>(0)=header%
  <A HREF="#RETURN">RETURN</A> <A HREF="#GINTOUT">GINTOUT</A>(0)
<A HREF="#ENDFUNC">ENDFUNC</A>

<A HREF="#rsrc_rcfix">rsrc_rcfix</A><A HREF="#()">()</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="RSRC_SADDR">RSRC_SADDR</H2>
<B><A HREF="#RSRC_SADDR">RSRC_SADDR</A>(type,<A HREF="#index">index</A>,addr)</B>

type, <A HREF="#index">index</A>, addr: <A HREF="#iexp">iexp</A>

This function sets the address of a resource structure.

Returns 0 if an error occurred.

    type  <A HREF="#-">-</A> Type of structure to modify (see <A HREF="#RSRC_GADDR">RSRC_GADDR</A><A HREF="#()">()</A>)<A HREF="#.">.</A>
    <A HREF="#index">index</A> <A HREF="#-">-</A> The number (not the object number) of the object whose address is
            to be set, counted object by object from the beginning of the
            Resource file.
    addr  <A HREF="#-">-</A> The address.

rsrc_saddr()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="Shell_Library">Shell Library</H2>
<A HREF="#SHEL_ENVRN">SHEL_ENVRN</A><A HREF="#()">()</A>
<A HREF="#SHEL_FIND">SHEL_FIND</A><A HREF="#()">()</A>
<A HREF="#SHEL_GET">SHEL_GET</A><A HREF="#()">()</A>
<A HREF="#shel_help">shel_help</A><A HREF="#()">()</A>
<A HREF="#SHEL_PUT">SHEL_PUT</A><A HREF="#()">()</A>
<A HREF="#SHEL_READ">SHEL_READ</A><A HREF="#()">()</A>
<A HREF="#shel_rdef">shel_rdef</A><A HREF="#()">()</A>
<A HREF="#shel_wdef">shel_wdef</A><A HREF="#()">()</A>
<A HREF="#SHEL_WRITE">SHEL_WRITE</A><A HREF="#()">()</A>

The <A HREF="#Shell_Library">Shell Library</A> routines enable one application to call another, preserving
both the original application and it's environment.

<A HREF="#Shell_Library">Shell Library</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="SHEL_ENVRN">SHEL_ENVRN</H2>
<B><A HREF="#SHEL_ENVRN">SHEL_ENVRN</A>(addr,search$)</B>

addr: <A HREF="#avar">avar</A> (32-bit)
search$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>

This function determines the values of variables in the GEM environment.

Return value is always 1.

    addr    <A HREF="#-">-</A> Returns the address of the byte following the specified string.
    search$ <A HREF="#-">-</A> The string to be sought.

<B>Example:</B>

    <A HREF="#PRINT">PRINT</A> <A HREF="#SHEL_ENVRN">SHEL_ENVRN</A>(a%,"PATH")
    <A HREF="#PRINT">PRINT</A> <A HREF="#CHAR">CHAR</A>{a%-4}

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Displays 'PATH=;A:\' on the screen.

shel_envrn()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="SHEL_FIND">SHEL_FIND</H2>
<B><A HREF="#SHEL_FIND">SHEL_FIND</A>(path$)</B>

path$<A HREF="#:">:</A> <A HREF="#svar">svar</A>

This function searches for a specified file and returns the full file
specification. Frist, the specified path on the current drive is searched, then
the root directory of the current drive, then the root directory of drive A:.

Returns 0 if the file name was not found, or 1 if it was.

On entry:
    path$ <A HREF="#-">-</A> String containing the sought-after file name.

On exit:
    path$ <A HREF="#-">-</A> Returns the full file specification if the file was found,
            otherwise it is unchanged.

<B>Memo:</B> A bug in the editor causes path$ to be +1 longer than it should be.
        A hidden trailing null is left on the end of the string.

shel_find()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="SHEL_GET">SHEL_GET</H2>
<B><A HREF="#SHEL_GET">SHEL_GET</A>(len,x$)</B>

len: <A HREF="#iexp">iexp</A>
x$<A HREF="#:">:</A> <A HREF="#svar">svar</A>

This function reads data from the <A HREF="#GEMDOS">GEMDOS</A> environmental string buffer (into
which the file DEKTOP.INF is read on start-up).

Returns 0 if an error occurred.

    len <A HREF="#-">-</A> Number of byte to be read.
    x$  <A HREF="#-">-</A> Returns data read.

<B>Example:</B>

    <A HREF="#PRINT">PRINT</A> <A HREF="#SHEL_GET">SHEL_GET</A>(500,x$)
    <A HREF="#PRINT">PRINT</A> x$
    <A HREF="#~">~</A><A HREF="#INP">INP</A>(2)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Either the contents of DESKTOP.INF or data for the default Desktop is read
    into x$, and printed.

shel_get()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="shel_help">shel_help</H2>
<B><A HREF="#shel_help">shel_help</A><A HREF="#()">()</A></B>

<B>Memo:</B> This call is not built into <A HREF="#GFA-Basic">GFA-Basic</A> so it's listed below:

<A HREF="#FUNCTION">FUNCTION</A> <A HREF="#shel_help">shel_help</A>(sh_hmode&,sh_hfile%,sh_hkey%)
  <A HREF="#$F%">$F%</A>
  <A HREF="#GCONTRL">GCONTRL</A>(0)=128
  <A HREF="#GCONTRL">GCONTRL</A>(1)=1
  <A HREF="#GCONTRL">GCONTRL</A>(2)=1
  <A HREF="#GCONTRL">GCONTRL</A>(3)=2
  <A HREF="#GCONTRL">GCONTRL</A>(4)=0
  <A HREF="#GINTIN">GINTIN</A>(0)=sh_hmode&
  <A HREF="#ADDRIN">ADDRIN</A>(0)=sh_hfile%
  <A HREF="#ADDRIN">ADDRIN</A>(1)=sh_hkey%
  <A HREF="#GEMSYS">GEMSYS</A>
  <A HREF="#RETURN">RETURN</A> <A HREF="#GINTOUT">GINTOUT</A>(0)
<A HREF="#ENDFUNC">ENDFUNC</A>
<HR SIZE=3><H2 ID="SHEL_PUT">SHEL_PUT</H2>
<B><A HREF="#SHEL_PUT">SHEL_PUT</A>(len,x$)</B>

len: <A HREF="#iexp">iexp</A>
x$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>

This function writes data into the <A HREF="#GEMDOS">GEMDOS</A> environmental string buffer.

Returns 0 if an error occurred.

    len <A HREF="#-">-</A> Number of bytes to be written.
    x$  <A HREF="#-">-</A> Data to be written.

<B>Example:</B>

    <A HREF="#'">'</A> Register GFA-BASIC
    <A HREF="#~">~</A><A HREF="#SHEL_GET">SHEL_GET</A>(2000,a$)
    q%<A HREF="#=">=</A><A HREF="#INSTR">INSTR</A>(a$,<A HREF="#CHR$">CHR$</A>(26))
    <A HREF="#IF">IF</A> q%
      a$=LEFT(a$,q%-1)
      <A HREF="#IF">IF</A> <A HREF="#INSTR">INSTR</A>(a$,"GFABASIC.PRG")=0
        a$=a$<A HREF="#+">+</A>"#G 03 04 A:\GFABASIC.PRG@<A HREF="#*">*</A>.GFA@"+<A HREF="#MKI$">MKI$</A>(&HD0A)+<A HREF="#CHR$">CHR$</A>(26)
        <A HREF="#~">~</A><A HREF="#SHEL_PUT">SHEL_PUT</A>(<A HREF="#LEN">LEN</A>(A$),a$)
      <A HREF="#ENDIF">ENDIF</A>
    <A HREF="#ENDIF">ENDIF</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The program 'registers' A:\GFABASIC.PRG, so that with a double-click on a
    .GFA program file, <A HREF="#GFA-Basic">GFA-Basic</A> is loaded which then loads and runs the
    program which was clicked on.

<B>Note:</B> To save this in the DESKTOP.INF file:

    <A HREF="#~">~</A><A HREF="#SHEL_GET">SHEL_GET</A>(3000,a$)
    <A HREF="#OPEN">OPEN</A> "O",#1,"A:\DESKTOP.INF"
    <A HREF="#PRINT">PRINT</A> #1,<A HREF="#LEFT$">LEFT$</A>(A$,<A HREF="#INSTR">INSTR</A>(A$,<A HREF="#CHR$">CHR$</A>(26)))<A HREF="#'">'</A>
    <A HREF="#CLOSE">CLOSE</A> #1
    <A HREF="#'">'</A> The <A HREF="#CHR$">CHR$</A>(26) is important

shel_put()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="SHEL_READ">SHEL_READ</H2>
<B><A HREF="#SHEL_READ">SHEL_READ</A>(cmd$,tail$)</B>

cmd$, tail$<A HREF="#:">:</A> <A HREF="#svar">svar</A>

This function allows the program to identify the command by which it was
invoked, and returns the name and the command line, if any.

Returns 0 if an error occurred.

    cmd$  <A HREF="#-">-</A> Returns the program name.
    tail$ <A HREF="#-">-</A> Returns the command line.

<B>Memo:</B> A bug in the editor causes cmd$ to be +1 longer than it should be.
        A hidden trailing null is left on the end of the string.

shel_read()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="shel_rdef">shel_rdef</H2>
<B><A HREF="#shel_rdef">shel_rdef</A><A HREF="#()">()</A></B>

<B>Memo:</B> This call is not built into <A HREF="#GFA-Basic">GFA-Basic</A> so it's listed below:

<A HREF="#FUNCTION">FUNCTION</A> <A HREF="#shel_rdef">shel_rdef</A>(lpcmd%,lpdir%)
  <A HREF="#$F%">$F%</A>
  <A HREF="#GCONTRL">GCONTRL</A>(0)=126
  <A HREF="#GCONTRL">GCONTRL</A>(1)=0
  <A HREF="#GCONTRL">GCONTRL</A>(2)=1
  <A HREF="#GCONTRL">GCONTRL</A>(3)=2
  <A HREF="#GCONTRL">GCONTRL</A>(4)=0
  <A HREF="#ADDRIN">ADDRIN</A>(0)=lpcmd%
  <A HREF="#ADDRIN">ADDRIN</A>(1)=lpdir%
  <A HREF="#GEMSYS">GEMSYS</A>
  <A HREF="#RETURN">RETURN</A> <A HREF="#GINTOUT">GINTOUT</A>(0)
<A HREF="#ENDFUNC">ENDFUNC</A>
<HR SIZE=3><H2 ID="shel_wdef">shel_wdef</H2>
<B><A HREF="#shel_wdef">shel_wdef</A><A HREF="#()">()</A></B>

<B>Memo:</B> This call is not built into <A HREF="#GFA-Basic">GFA-Basic</A> so it's listed below:

<A HREF="#FUNCTION">FUNCTION</A> <A HREF="#shel_wdef">shel_wdef</A>(lpcmd%,lpdir%)
  <A HREF="#$F%">$F%</A>
  <A HREF="#GCONTRL">GCONTRL</A>(0)=127
  <A HREF="#GCONTRL">GCONTRL</A>(1)=0
  <A HREF="#GCONTRL">GCONTRL</A>(2)=1
  <A HREF="#GCONTRL">GCONTRL</A>(3)=2
  <A HREF="#GCONTRL">GCONTRL</A>(4)=0
  <A HREF="#ADDRIN">ADDRIN</A>(0)=lpcmd%
  <A HREF="#ADDRIN">ADDRIN</A>(1)=lpdir%
  <A HREF="#GEMSYS">GEMSYS</A>
  <A HREF="#RETURN">RETURN</A> <A HREF="#GINTOUT">GINTOUT</A>(0)
<A HREF="#ENDFUNC">ENDFUNC</A>
<HR SIZE=3><H2 ID="SHEL_WRITE">SHEL_WRITE</H2>
<B><A HREF="#SHEL_WRITE">SHEL_WRITE</A>(mode,gr,cr,tail$,cmd$)</B>

mode, gr, cr: <A HREF="#iexp">iexp</A>
tail$, cmd$<A HREF="#:">:</A> <A HREF="#sexp">sexp</A>

This function informs the <A HREF="#AES">AES</A> that another application is to be started after
the current one has terminated. In contrast to Pexec() (<A HREF="#GEMDOS">GEMDOS</A> 75), however,
the current program does not remain resident in memory.

Returns 0 if an error occurred.

    mode  <A HREF="#-">-</A> 0: Back to the Desktop.
            1: Load new program.
    gr    <A HREF="#-">-</A> 0: TOS program.
            1: Graphics application.
    cr    <A HREF="#-">-</A> 0: Not GEM application.
            1: GEM application.
    tail$ <A HREF="#-">-</A> Command line string.
    cmd$  <A HREF="#-">-</A> Name of next application.

<B>Example:</B>

    <A HREF="#~">~</A><A HREF="#SHEL_WRITE">SHEL_WRITE</A>(1,1,1,"","GFABASIC.PRG")

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> After running this, quitting BASIC and returning to the Desktop will
    result in BASIC being restarted.

<B>Memo:</B> The built in command <A HREF="#SHEL_WRITE">SHEL_WRITE</A><A HREF="#()">()</A> has parameters tail$ and cmd$
      swapped when compared to other <A HREF="#AES">AES</A> manuals. However it does work. The
      information about the command itself is not very accurate. One should
      consult additional documentation for the proper use of this call.

shel_write()<A HREF="#+">+</A>
<HR SIZE=3><H2 ID="Sample_Programs">Sample Programs</H2>
In this last section example programs are provided, dealing with the Graphics
Library, Dialog boxes, Menus, and Window programming. Note that it is important
to exit from all these programs in the ways specified, not by just breaking in
with Shift-Control-Alternate, otherwise memory re-allocation, etc. will not
take place and the programs (or other programs) may subsequently fail to work
without resetting the computer.

<A HREF="#GRAF_SMP.GFA">GRAF_SMP.GFA</A> <A HREF="#-">-</A> <A HREF="#Graphics_Library">Graphics Library</A>
<A HREF="#DIAL_SMP.GFA">DIAL_SMP.GFA</A> <A HREF="#-">-</A> Dialog Boxes Example
<A HREF="#MENU_SMP.GFA">MENU_SMP.GFA</A> <A HREF="#-">-</A> Menu management
<A HREF="#WIND_SMP.GFA">WIND_SMP.GFA</A> <A HREF="#-">-</A> Window demonstration
<HR SIZE=3><H2 ID="GRAF_SMP.GFA">GRAF_SMP.GFA</H2>
<A HREF="#'">'</A> <A HREF="#*">*</A>* <A HREF="#Graphics_Library">Graphics Library</A>
<A HREF="#'">'</A> <A HREF="#GRAF_SMP.GFA">GRAF_SMP.GFA</A>
<A HREF="#'">'</A>
<A HREF="#REPEAT">REPEAT</A>
  <A HREF="#CLS">CLS</A>
  <A HREF="#PRINT">PRINT</A> <A HREF="#CHR$">CHR$</A>(27)<A HREF="#+">+</A>"p"<A HREF="#;">;</A>
  <A HREF="#PRINT">PRINT</A> "<A HREF="#&#124;">&#124;</A> <A HREF="#&">&</A>#60;F1&#62; rubber &#124; &#60;F2&#62; drag &#124; &#60;F3&#62; move &#124;";
  <A HREF="#PRINT">PRINT</A> " <A HREF="#&">&</A>#60;F4&#62; grow_shrink <A HREF="#&#124;">&#124;</A> &#60;F10&#62; quit &#124;"
  choice&#124;<A HREF="#=">=</A><A HREF="#INP">INP</A>(2)
  <A HREF="#'">'</A>
  <A HREF="#SELECT">SELECT</A> choice&#124;
  <A HREF="#CASE">CASE</A> 187        <A HREF="#!">!</A> F1
    rubber
  <A HREF="#CASE">CASE</A> 188        <A HREF="#!">!</A> F2
    drag
  <A HREF="#CASE">CASE</A> 189        <A HREF="#!">!</A> F3
    move
  <A HREF="#CASE">CASE</A> 190        <A HREF="#!">!</A> F4
    grow_shrink
  <A HREF="#ENDSELECT">ENDSELECT</A>
  <A HREF="#'">'</A>
  <A HREF="#PRINT">PRINT</A> <A HREF="#CHR$">CHR$</A>(27)<A HREF="#+">+</A>"q"<A HREF="#;">;</A>
  <A HREF="#'">'</A>
<A HREF="#UNTIL">UNTIL</A> choice&#124;=196 <A HREF="#!">!</A> quit with F10
<A HREF="#'">'</A>
<A HREF="#EDIT">EDIT</A>
<A HREF="#'">'</A>
<A HREF="#PROCEDURE">PROCEDURE</A> rubber
  <A HREF="#GRAPHMODE">GRAPHMODE</A> 3
  <A HREF="#DEFFILL">DEFFILL</A> 1,2,4
  <A HREF="#REPEAT">REPEAT</A>
    <A HREF="#MOUSE">MOUSE</A> mx%,my%,mk%
    <A HREF="#IF">IF</A> mk% <A HREF="#AND">AND</A> 1
      x1%=mx%
      y1%=my%
      <A HREF="#~">~</A><A HREF="#GRAF_RUBBERBOX">GRAF_RUBBERBOX</A>(x1%,y1%,16,16,lx%,ly%)
      <A HREF="#PBOX">PBOX</A> x1%,y1%,x1%+lx%,y1%+ly%
    <A HREF="#ENDIF">ENDIF</A>
  <A HREF="#UNTIL">UNTIL</A> mk% <A HREF="#AND">AND</A> 2
<A HREF="#RETURN">RETURN</A>
<A HREF="#'">'</A>
<A HREF="#PROCEDURE">PROCEDURE</A> drag
  <A HREF="#GRAPHMODE">GRAPHMODE</A> 3
  <A HREF="#BOX">BOX</A> 40,40,400,300
  lx%=50
  ly%=50
  <A HREF="#REPEAT">REPEAT</A>
    <A HREF="#BOX">BOX</A> lx%,ly%,lx%+150,ly%+100
    <A HREF="#'">'</A>
    <A HREF="#REPEAT">REPEAT</A>
      mk%<A HREF="#=">=</A><A HREF="#MOUSEK">MOUSEK</A>
    <A HREF="#UNTIL">UNTIL</A> mk%                     <A HREF="#!">!</A> i.e. until mousek&#60;&#62;0
    <A HREF="#'">'</A>
    <A HREF="#IF">IF</A> mk% <A HREF="#AND">AND</A> 1                  <A HREF="#!">!</A> left button
      <A HREF="#BOX">BOX</A> lx%,ly%,lx%+150,ly%+100
      <A HREF="#~">~</A><A HREF="#GRAF_DRAGBOX">GRAF_DRAGBOX</A>(150,100,lx%,ly%,40,40,360,260,lx%,ly%)
      <A HREF="#BOX">BOX</A> lx%,ly%,lx%+150,ly%+100
    <A HREF="#ENDIF">ENDIF</A>
    <A HREF="#BOX">BOX</A> lx%,ly%,lx%+150,ly%+100
  <A HREF="#UNTIL">UNTIL</A> mk% <A HREF="#AND">AND</A> 2                 <A HREF="#!">!</A> right button
  <A HREF="#GRAPHMODE">GRAPHMODE</A> 1
<A HREF="#RETURN">RETURN</A>
    <A HREF="#'">'</A>
<A HREF="#PROCEDURE">PROCEDURE</A> move
  <A HREF="#GRAPHMODE">GRAPHMODE</A> 1
  <A HREF="#DEFFILL">DEFFILL</A> 1,2,4
  w%=100
  h%=100
  <A HREF="#FOR">FOR</A> i%=0 TO 639-w% <A HREF="#STEP">STEP</A> w%
    <A HREF="#FOR">FOR</A> j%=0 TO 399-h% <A HREF="#STEP">STEP</A> h%
      <A HREF="#~">~</A><A HREF="#GRAF_MOVEBOX">GRAF_MOVEBOX</A>(w%,h%,i%,j%,639-i%,399-j%)
    <A HREF="#NEXT">NEXT</A> j%
  <A HREF="#NEXT">NEXT</A> i%
<A HREF="#RETURN">RETURN</A>
<A HREF="#'">'</A>
<A HREF="#PROCEDURE">PROCEDURE</A> grow_shrink
  <A HREF="#GRAPHMODE">GRAPHMODE</A> 1
  <A HREF="#~">~</A><A HREF="#GRAF_GROWBOX">GRAF_GROWBOX</A>(319,199,16,16,0,0,639,399)
  <A HREF="#ALERT">ALERT</A> 0,"That was a growing box!",1,"Continue",r%
  <A HREF="#~">~</A><A HREF="#GRAF_SHRINKBOX">GRAF_SHRINKBOX</A>(319,199,16,16,0,0,639,399)
  <A HREF="#ALERT">ALERT</A> 0,"That was a shrinking box!",1," Yes ",r%
<A HREF="#RETURN">RETURN</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> Pressing F1 to F4 causes the program to branch to the appropriate
    procedure. If F1 is pressed, the outline of a rectangle appears on the
    screen when the left mouse button is pressed and held down. The top left
    corner is fixed, but the diagonally opposite corner moves with the mouse.
    When the rectangle has the desired shape and size, and the left button is
    released, the rectangle is fixed and filled. More rectangles can be drawn,
    or the procedure exited by pressing the right button.

    Pressing F2 causes a small rectangle to be drawn within a larger one. With
    the left button pressed and held down, the smaller rectangle can be moved
    about within the limits imposed by the larger one. Pressing the right
    button ends the procedure.

    F3 calls up the demonstration of <A HREF="#GRAF_MOVEBOX">GRAF_MOVEBOX</A><A HREF="#()">()</A>, where sequences of boxes
    move round the screen. This procedure ends by itself after a few seconds.

    Finally, with F4, a growing box is drawn with <A HREF="#GRAF_GROWBOX">GRAF_GROWBOX</A><A HREF="#()">()</A>, and, after
    pressing Return, a shrinking box is drawn with <A HREF="#GRAF_SHRINKBOX">GRAF_SHRINKBOX</A><A HREF="#()">()</A><A HREF="#.">.</A>

    Pressing F10 ends the whole program.

<HR SIZE=3><H2 ID="DIAL_SMP.GFA">DIAL_SMP.GFA</H2>
<A HREF="#*">*</A>* Dialog Box Example
<A HREF="#'">'</A> <A HREF="#DIAL_SMP.GFA">DIAL_SMP.GFA</A>
<A HREF="#'">'</A>
<A HREF="#DIM">DIM</A> r%(3)
<A HREF="#'">'</A>
form1%=0   <A HREF="#!">!</A> 0 = Dialog
icon1%=1   <A HREF="#!">!</A> ICON in tree FORM1
ch_name%=2 <A HREF="#!">!</A> FTEXT in tree FORM1
sur%=3     <A HREF="#!">!</A> FTEXT in tree FORM1
str%=4     <A HREF="#!">!</A> FTEXT in tree FORM1
town%=5    <A HREF="#!">!</A> FTEXT in tree FORM1
cancel%=6  <A HREF="#!">!</A> BUTTON in tree FORM1
ok%=7      <A HREF="#!">!</A> BUTTON in tree FORMl
r%(1)=8    <A HREF="#!">!</A> BUTTON in tree FORM1
r%(2)=9    <A HREF="#!">!</A> BUTTON in tree FORM1
r%(3)=10   <A HREF="#!">!</A> BUTTON in tree FORM1
output%=11 <A HREF="#!">!</A> STRING in tree FORM1
<A HREF="#'">'</A>
<A HREF="#~">~</A><A HREF="#RSRC_FREE">RSRC_FREE</A><A HREF="#()">()</A>
<A HREF="#~">~</A><A HREF="#RSRC_LOAD">RSRC_LOAD</A>("\DIALOG.RSC")           <A HREF="#!">!</A> Load Resource file
<A HREF="#~">~</A><A HREF="#RSRC_GADDR">RSRC_GADDR</A>(0,0,tree_adr%)          <A HREF="#!">!</A> Get address of Object tree
<A HREF="#~">~</A><A HREF="#FORM_CENTER">FORM_CENTER</A>(tree_adr%,x%,y%,w%,h%) <A HREF="#!">!</A> Center the coordinates, depending on the current resolution
<A HREF="#'">'</A>
<A HREF="#'">'</A> Define initial editable strings
<A HREF="#CHAR">CHAR</A>{{<A HREF="#OB_SPEC">OB_SPEC</A>(tree_adr%,ch_name%)}}<A HREF="#=">=</A>"Sherlock"
<A HREF="#CHAR">CHAR</A>{{<A HREF="#OB_SPEC">OB_SPEC</A>(tree_adr%,sur%)}}<A HREF="#=">=</A>"Holmes"
<A HREF="#CHAR">CHAR</A>{{<A HREF="#OB_SPEC">OB_SPEC</A>(tree_adr%,str%)}}<A HREF="#=">=</A>"221b Baker Street"
<A HREF="#CHAR">CHAR</A>{{<A HREF="#OB_SPEC">OB_SPEC</A>(tree_adr%,town%)}}<A HREF="#=">=</A>"London N1"
<A HREF="#'">'</A>
<A HREF="#~">~</A><A HREF="#OBJC_DRAW">OBJC_DRAW</A>(tree_adr%,0,1,x%,y%,w%,h%) <A HREF="#!">!</A> Draw Object tree
<A HREF="#'">'</A>
<A HREF="#REPEAT">REPEAT</A>
  ex%<A HREF="#=">=</A><A HREF="#FORM_DO">FORM_DO</A>(tree_adr%,0)            <A HREF="#!">!</A> Clicked an object with EXIT status?
  <A HREF="#'">'</A>
  <A HREF="#'">'</A> Put the texts from the Edit fields into the appropriate strings
  ch_name$<A HREF="#=">=</A><A HREF="#CHAR">CHAR</A>{{<A HREF="#OB_SPEC">OB_SPEC</A>(tree_adr%,ch_name%)}}
  surname$<A HREF="#=">=</A><A HREF="#CHAR">CHAR</A>{{<A HREF="#OB_SPEC">OB_SPEC</A>(tree_adr%,sur%)}}
  street$<A HREF="#=">=</A><A HREF="#CHAR">CHAR</A>{{<A HREF="#OB_SPEC">OB_SPEC</A>(tree_adr%,str%)}}
  town$<A HREF="#=">=</A><A HREF="#CHAR">CHAR</A>{{<A HREF="#OB_SPEC">OB_SPEC</A>(tree_adr%,town%)}}
  <A HREF="#'">'</A>
  <A HREF="#FOR">FOR</A> i%=1 TO 3
    <A HREF="#IF">IF</A> <A HREF="#BTST">BTST</A>(<A HREF="#OB_STATE">OB_STATE</A>(tree_adr%,r%(i%)),0) <A HREF="#!">!</A> Which radio-button was selected?
      radio%=r%(i%)
    <A HREF="#ENDIF">ENDIF</A>
  <A HREF="#NEXT">NEXT</A> i%
<A HREF="#UNTIL">UNTIL</A> ex%=ok% <A HREF="#OR">OR</A> ex%=cancel%
<A HREF="#'">'</A>
<A HREF="#~">~</A><A HREF="#RSRC_FREE">RSRC_FREE</A><A HREF="#()">()</A>                              <A HREF="#!">!</A> Release reserved memory
<A HREF="#'">'</A>
<A HREF="#CLS">CLS</A>
<A HREF="#PRINT">PRINT</A> "Ended with     <A HREF="#:">:</A> ";ex%
<A HREF="#PRINT">PRINT</A> "Christian name <A HREF="#:">:</A> ";ch_name$
<A HREF="#PRINT">PRINT</A> "Surname        <A HREF="#:">:</A> ";surname$
<A HREF="#PRINT">PRINT</A> "Street         <A HREF="#:">:</A> ";street$
<A HREF="#PRINT">PRINT</A> "Town           <A HREF="#:">:</A> ";town$
<A HREF="#PRINT">PRINT</A> "Radio          <A HREF="#:">:</A> ";radio%

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> The file "DIALOG.RSC" is loaded, the address of the object tree is
    determined and the object tree coordinates are centered.

    Then the function <A HREF="#OB_SPEC">OB_SPEC</A><A HREF="#()">()</A> is used to define the initial editable strings:

    <A HREF="#OB_SPEC">OB_SPEC</A><A HREF="#()">()</A> returns a pointer to a <A HREF="#TEDINFO">TEDINFO</A> structure, which itself contains
    pointers to data pertaining to editable text (validation string, color,
    text, and template addresses, etc.). So the 'pointer path' to the actual
    information is shown overleaf:

    <B>Object <A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> <A HREF="#TEDINFO">TEDINFO</A> structure --<A HREF="#&">&</A>#62; String</B>

    <A HREF="#OB_SPEC">OB_SPEC</A>(tree%,ch_name%) returns a pointer to the <A HREF="#TEDINFO">TEDINFO</A> structure.

    {<A HREF="#OB_SPEC">OB_SPEC</A>(tree%,ch_name%)} returns the address held at that point in
    <A HREF="#TEDINFO">TEDINFO</A><A HREF="#.">.</A>

    <A HREF="#CHAR">CHAR</A>{{<A HREF="#OB_SPEC">OB_SPEC</A>(tree%,ch_name%)}} gives the string initially inserted by the
    Resource Construction Set, in this case: 0123456789012345678901.

    <A HREF="#CHAR">CHAR</A>{{<A HREF="#OB_SPEC">OB_SPEC</A>(tree%,ch_name%)}}<A HREF="#=">=</A>"Sherlock'" assigns this preset character
    string a new value (namely 'Sherlock')<A HREF="#.">.</A> This is repeated for the rest of
    the initial data.

    Then the object tree is drawn and, inside the <A HREF="#REPEAT">REPEAT</A><A HREF="#-">-</A><A HREF="#UNTIL">UNTIL</A> loop, the main
    <A HREF="#FORM_DO">FORM_DO</A><A HREF="#()">()</A> routine is called. Its returned value 'ex%' determines when the
    loop is exited.

    The (edited) strings are then put back into their respective variables,
    after which the object status (found by <A HREF="#OB_STATE">OB_STATE</A><A HREF="#()">()</A>) of the 'radio' buttons
    is examined in a <A HREF="#FOR">FOR</A><A HREF="#-">-</A><A HREF="#NEXT">NEXT</A> loop. Specifically, Bit 0 is tested with <A HREF="#BTST">BTST</A><A HREF="#()">()</A>.
    If it is set (=1), then the corresponding button must have been selected
    (only one radio button can be selected at a time), and the object number of
    the button is stored in radio%<A HREF="#.">.</A>

    Finally the memory space reserved for the Resource is released again with
    <A HREF="#RSRC_FREE">RSRC_FREE</A><A HREF="#()">()</A><A HREF="#.">.</A> (This is important!!, since otherwise the available free
    memory shrinks each time the program is started, which soon causes the
    computer to crash.)

    The button which caused the exit of the <A HREF="#REPEAT">REPEAT</A><A HREF="#-">-</A><A HREF="#UNTIL">UNTIL</A> loop is printed (6 <A HREF="#=">=</A>
    Cancel, 7 <A HREF="#=">=</A> Ok), followed by the data strings as they were when <A HREF="#FORM_DO">FORM_DO</A><A HREF="#()">()</A>
    was done for the last time and the object number of the last-selected radio
    button.

<HR SIZE=3><H2 ID="MENU_SMP.GFA">MENU_SMP.GFA</H2>
<A HREF="#'">'</A> <A HREF="#*">*</A>* Menu management
<A HREF="#'">'</A> <A HREF="#MENU_SMP.GFA">MENU_SMP.GFA</A>
<A HREF="#'">'</A>
<A HREF="#RESERVE">RESERVE</A> <A HREF="#FRE">FRE</A>(0)-33000 <A HREF="#!">!</A> Reserve space for the Resource file
<A HREF="#'">'</A> File is not in 'folder' but <A HREF="#RSRC_LOAD">RSRC_LOAD</A><A HREF="#()">()</A> looks further and should find it on current drive
<A HREF="#IF">IF</A> <A HREF="#RSRC_LOAD">RSRC_LOAD</A>("folder\RCS2.RSC")=0
  <A HREF="#ALERT">ALERT</A> 1,"Resource not found",1,"End",a%
  <A HREF="#END">END</A>
<A HREF="#ENDIF">ENDIF</A>
<A HREF="#~">~</A><A HREF="#RSRC_GADDR">RSRC_GADDR</A>(0,0,menu_adr%) <A HREF="#!">!</A> Get menu address
<A HREF="#~">~</A><A HREF="#MENU_BAR">MENU_BAR</A>(menu_adr%,1)     <A HREF="#!">!</A> Display menu bar
<A HREF="#'">'</A>
<A HREF="#'">'</A> Reserve a Message Buffer of 16 bytes and give variable names to positions within it:
<A HREF="#DIM">DIM</A> message_buffer&(7)     <A HREF="#!">!</A> Eight words (including 0)
mesg_adr%=V:message_buffer&(0)
<A HREF="#ABSOLUTE">ABSOLUTE</A> mesg_type&,mesg_adr%
<A HREF="#ABSOLUTE">ABSOLUTE</A> m_title&,mesg_adr%+6
<A HREF="#ABSOLUTE">ABSOLUTE</A> m_item&,mesg_adr%+8
<A HREF="#'">'</A>
<A HREF="#REPEAT">REPEAT</A>
  ev%<A HREF="#=">=</A><A HREF="#EVNT_MULTI">EVNT_MULTI</A>(&X110000,0,0,0,0,0,0,0,0,0,0,0,0,0,mesg_adr%,500)
  <A HREF="#IF">IF</A> <A HREF="#BTST">BTST</A>(ev%,4)                                    <A HREF="#!">!</A> a new message has arrived
    <A HREF="#IF">IF</A> mesg_type&=10                                <A HREF="#!">!</A> reporting a menu event
      title$<A HREF="#=">=</A><A HREF="#CHAR">CHAR</A>{<A HREF="#OB_SPEC">OB_SPEC</A>(menu_adr%,m_title&)}      <A HREF="#!">!</A> find out what it was
      item$<A HREF="#=">=</A><A HREF="#CHAR">CHAR</A>{<A HREF="#OB_SPEC">OB_SPEC</A>(menu_adr%,m_item&)}
      <A HREF="#PRINT_AT">PRINT AT</A>(3,20)<A HREF="#;">;</A>"Menu title <A HREF="#:">:</A> ";title$;<A HREF="#SPC">SPC</A>(10)
      <A HREF="#PRINT_AT">PRINT AT</A>(3,21)<A HREF="#;">;</A>"Menu item  <A HREF="#:">:</A> ";item$;<A HREF="#SPC">SPC</A>(10)
      <A HREF="#~">~</A><A HREF="#MENU_TNORMAL">MENU_TNORMAL</A>(menu_adr%,m_title&,1)           <A HREF="#!">!</A> Un-invert menu title display
    <A HREF="#ENDIF">ENDIF</A>
  <A HREF="#ENDIF">ENDIF</A>
<A HREF="#UNTIL">UNTIL</A> <A HREF="#MOUSEK">MOUSEK</A>=2
<A HREF="#'">'</A>
<A HREF="#~">~</A><A HREF="#MENU_BAR">MENU_BAR</A>(menu_adr%,0) <A HREF="#!">!</A> Remove menu bar
<A HREF="#~">~</A><A HREF="#RSRC_FREE">RSRC_FREE</A><A HREF="#()">()</A>           <A HREF="#!">!</A> Release Resource memory
<A HREF="#RESERVE">RESERVE</A>                <A HREF="#!">!</A> Return reserved memory to GFA BASIC
<A HREF="#END">END</A>

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> At the beginning of the program a 33k byte area of memory is reserved. It
    is returned to the <A HREF="#GFA-Basic">GFA-Basic</A> interpreter at the end of the program.

    The Resource file is then loaded into the freed memory area, the address of
    the menu tree is determined and the menu is displayed.

    <A HREF="#EVNT_MULTI">EVNT_MULTI</A><A HREF="#()">()</A> supervises the menu tree, and, in the event that a menu item
    is selected, appropriate messages are written into the Message buffer. This
    is a 16-byte long area of memory, divided into eight 2-byte words,
    conveniently allocated by means of a word-sized array. Using the <A HREF="#ABSOLUTE">ABSOLUTE</A>
    command, some variables are defined as being located in this array,
    enabling elements of it to be referred to by name.

    In a <A HREF="#REPEAT">REPEAT</A><A HREF="#-">-</A><A HREF="#UNTIL">UNTIL</A> loop (exited by pressing the right mouse button),
    <A HREF="#EVNT_MULTI">EVNT_MULTI</A><A HREF="#()">()</A> is called. The first word of the Message buffer (defined as
    mesg_type&) then contains the value 10 if a menu item was selected. The
    fourth word (m_title&, the 6th and 7th bytes) contains the object number of
    the menu title, from beneath which the item was chosen. The object number
    of the item is in the fifth word (m_item&, bytes 8 and 9)<A HREF="#.">.</A> The other
    elements of the buffer are not required here.

    Knowing the object numbers of the menu title and the menu item, and that
    <A HREF="#OB_SPEC">OB_SPEC</A>(<A HREF="#.">.</A>..), in the case of Dialog Box Buttons and Menu items, returns the
    address of text terminated with a zero byte, <A HREF="#CHAR">CHAR</A><A HREF="#{}">{}</A> can be used to extract
    the texts and put them into strings.

    After displaying the menu title and item on the screen, the inverted menu
    title is returned to its normal state with <A HREF="#MENU_TNORMAL">MENU_TNORMAL</A><A HREF="#()">()</A><A HREF="#.">.</A>

<HR SIZE=3><H2 ID="WIND_SMP.GFA">WIND_SMP.GFA</H2>
<A HREF="#'">'</A> <A HREF="#*">*</A>* Window demonstration
<A HREF="#'">'</A> <A HREF="#WIND_SMP.GFA">WIND_SMP.GFA</A>
<A HREF="#'">'</A>
<A HREF="#DEFFILL">DEFFILL</A> 1,2,4
<A HREF="#PBOX">PBOX</A> 0,19,639,399
<A HREF="#DEFFILL">DEFFILL</A> 1,0
<A HREF="#'">'</A>
<A HREF="#DIM">DIM</A> message_buffer&(7)        <A HREF="#!">!</A> 16 Bytes
adr_mes%=V:message_buffer&(0)
<A HREF="#'">'</A>
<A HREF="#ABSOLUTE">ABSOLUTE</A> word0&,adr_mes%
<A HREF="#ABSOLUTE">ABSOLUTE</A> x&,adr_mes%+8
<A HREF="#ABSOLUTE">ABSOLUTE</A> y&,adr_mes%+10
<A HREF="#ABSOLUTE">ABSOLUTE</A> w&,adr_mes%+12
<A HREF="#ABSOLUTE">ABSOLUTE</A> h&,adr_mes%+14
<A HREF="#'">'</A>
handle&<A HREF="#=">=</A><A HREF="#WIND_CREATE">WIND_CREATE</A>(&X101111,0,19,639,380)
<A HREF="#'">'</A>
title$<A HREF="#=">=</A>"Window"<A HREF="#+">+</A><A HREF="#CHR$">CHR$</A>(0)
adr_title%=V:title$
<A HREF="#~">~</A><A HREF="#WIND_SET">WIND_SET</A>(handle&,2,<A HREF="#CARD">CARD</A>(<A HREF="#SWAP">SWAP</A>(adr_title%)),CARD(adr_title%),0,0)
<A HREF="#~">~</A><A HREF="#WIND_OPEN">WIND_OPEN</A>(handle&,100,100,200,100)
<A HREF="#~">~</A><A HREF="#WIND_GET">WIND_GET</A>(handle&,4,wx&,wy&,ww&,wh&)
<A HREF="#PBOX">PBOX</A> wx&,wy&,wx&+ww&,wy&+wh&
<A HREF="#'">'</A>
finish!<A HREF="#=">=</A><A HREF="#FALSE">FALSE</A>
<A HREF="#REPEAT">REPEAT</A>
  <A HREF="#~">~</A><A HREF="#EVNT_MULTI">EVNT_MULTI</A>(&X110000,0,0,0,0,0,0,0,0,0,0,0,0,0,adr_mes%,100,d%,d%,d%,d%,d%,d%)
  <A HREF="#SELECT">SELECT</A> word0&
    <A HREF="#'">'</A> Depending on word0&, one of the following cases is dealt with:
  <A HREF="#CASE">CASE</A> 22        <A HREF="#!">!</A> WM_CLOSED <A HREF="#-">-</A> closed
    finish!<A HREF="#=">=</A><A HREF="#TRUE">TRUE</A>
  <A HREF="#CASE">CASE</A> 23        <A HREF="#!">!</A> WM_FULLED <A HREF="#-">-</A> full size
    <A HREF="#~">~</A><A HREF="#WIND_SET">WIND_SET</A>(handle&,5,1,19,638,380)
    <A HREF="#~">~</A><A HREF="#WIND_GET">WIND_GET</A>(handle&,4,wx&,wy&,ww&,wh&)
    <A HREF="#PBOX">PBOX</A> wx&,wy&,wx&+ww&,wy&+wh&
    word0&=0
  <A HREF="#CASE">CASE</A> 27,28     <A HREF="#!">!</A> WM_SIZED, WM_MOVED <A HREF="#-">-</A> re-sized or moved
    <A HREF="#IF">IF</A> w&&#60;100
      w&=100
    <A HREF="#ENDIF">ENDIF</A>
    <A HREF="#IF">IF</A> h&&#60;80
      h&=80
    <A HREF="#ENDIF">ENDIF</A>
    <A HREF="#~">~</A><A HREF="#WIND_SET">WIND_SET</A>(handle&,5,x&,y&,w&,h&)
    <A HREF="#~">~</A><A HREF="#WIND_GET">WIND_GET</A>(handle&,4,wx&,wy&,ww&,wh&)
    <A HREF="#PBOX">PBOX</A> wx&,wy&,wx&+ww&,wy&+wh&
    word0&=0
  <A HREF="#ENDSELECT">ENDSELECT</A>
<A HREF="#UNTIL">UNTIL</A> finish!
<A HREF="#~">~</A><A HREF="#WIND_CLOSE">WIND_CLOSE</A>(handle&)
<A HREF="#~">~</A><A HREF="#WIND_DELETE">WIND_DELETE</A>(handle&)

<A HREF="#-">-</A>-<A HREF="#&#62;">&#62;</A> First a Message Buffer is allocated, as in the example program
    <A HREF="#MENU_SMP.GFA">MENU_SMP.GFA</A>, and some words within it are given variable names.

    Then the window is created and its handle number determined with
    <A HREF="#WIND_CREATE">WIND_CREATE</A><A HREF="#()">()</A>, and a title is assigned to it with <A HREF="#WIND_SET">WIND_SET</A>()<A HREF="#.">.</A>

    After opening the window with <A HREF="#WIND_OPEN">WIND_OPEN</A><A HREF="#()">()</A> the coordinates of the work area
    of the window are found with <A HREF="#WIND_GET">WIND_GET</A><A HREF="#()">()</A>, and the whole area is covered with
    a white rectangle.

    In the <A HREF="#REPEAT">REPEAT</A><A HREF="#-">-</A><A HREF="#UNTIL">UNTIL</A> loop, control of the window elements is supervised by
    <A HREF="#EVNT_MULTI">EVNT_MULTI</A><A HREF="#()">()</A><A HREF="#.">.</A> Different events (signalled by word0&, the first word in the
    message buffer) are dealt with by the associated <A HREF="#CASE">CASE</A> selection. If the
    'Close Window' symbol is clicked, the loop terminates and so does the
    program, after closing the window and deleting it from memory.

<HR SIZE=3><H2 ID="Chapter_12_-_Appendix">Chapter 12 - Appendix</H2>
<A NAME="Appendix"></A>Additional documentation:

Memory Map+
Native File Formats+
<HR SIZE=3><H2 ID="Compatibility_with_GFA-BASIC_2">Compatibility with GFA-BASIC 2</H2>
It is possible in GFA BASIC 3 to use programs from older <A HREF="#GFA-Basic">GFA-Basic</A> versions.
For this purpose, programs written in the earlier version must be stored as
<A HREF="#ASCII">ASCII</A> files, using the <A HREF="#SAVE">SAVE</A>,A command. They can then be loaded into Version 3
by means of MERGE and, there after, treated as <A HREF="#GFA-Basic">GFA-Basic</A> 3 programs being SAVEd
and LOADed in the normal way.

Version 3 contains all the commands which are in earlier versions of the
interpreter, although there are some small differences in the interpretation of
commands which may make some modification of earlier programs necessary.

<B><A HREF="#MUL">MUL</A>, <A HREF="#DIV">DIV</A></B>

The commands <A HREF="#MUL">MUL</A> and <A HREF="#DIV">DIV</A> work in <A HREF="#GFA-Basic">GFA-Basic</A> 3 with integer variables (<A HREF="#&#124;">&#124;</A>,<A HREF="#&">&</A>,<A HREF="#%">%</A>) and
integer parameters only.

In the earlier versions, the program:

    a%=10
    <A HREF="#MUL">MUL</A> a%,2.5
    <A HREF="#PRINT">PRINT</A> a%

produced the output 25.

In Version 3, however, <A HREF="#MUL">MUL</A> does not take account of the fractional parts of
inputs, treating them all as integers. Thus, the value to the right of the
decimal point is ignored, so, in the above example, the integer a% is set to
20. This incompatibility between versions is the price paid for these commands
being many times faster than their counterparts in the earlier versions of
<A HREF="#GFA-Basic">GFA-Basic</A>, the increase in speed coming from the use of true integer
arithmetic. This incompatibility does, of course, only apply to integer
variables.

<B><A HREF="#PRINT_USING">PRINT USING</A></B>

<A HREF="#PRINT_USING">PRINT USING</A> displays only the numbers that fit in the designated format.  This
can mean that it is possible that wrong values will be displayed, instead of
wrong formats as in earlier versions, if the length of the number is too great.
The actual accuracy is, of course, not affected just the display. Care must
therefore be taken when using this command.

<B><A HREF="#CLS">CLS</A>, <A HREF="#PRINT">PRINT</A>, <A HREF="#TAB">TAB</A><A HREF="#()">()</A></B>

At <A HREF="#CLS">CLS</A>, the string ESC-E-CR is now issued, so that the <A HREF="#PRINT">PRINT</A> command will be
able to treat <A HREF="#TAB">TAB</A><A HREF="#()">()</A> correctly.

<B><A HREF="#KEYPAD">KEYPAD</A></B>

A program, which queries the keys of the numeric key-pad and Alternate and/or
Control, requires that a <A HREF="#KEYPAD">KEYPAD</A> 0 be issued to switch this off now.  The same
is valid for the function keys with Alternate.

<B><A HREF="#MOUSEX">MOUSEX</A>, <A HREF="#MOUSEY">MOUSEY</A></B>

If windows are active and <A HREF="#MOUSEX">MOUSEX</A> or <A HREF="#MOUSEY">MOUSEY</A> are interrogated, then negative
coordinates arise above and to the left of the window border (e.g. <A HREF="#CLIP">CLIP</A>
<A HREF="#OFFSET">OFFSET</A>)<A HREF="#.">.</A> In Version 2.x <A HREF="#CARD">CARD</A>(<A HREF="#MOUSEX">MOUSEX</A>) or CARD(<A HREF="#MOUSEY">MOUSEY</A>) returned these values.

<B><A HREF="#OPTION">OPTION</A></B>

In version 2 the command <A HREF="#OPTION">OPTION</A> was used to control the compiler. This command
has been replaced by the <A HREF="#$">$</A> command in version 3.

<B>Licence</B>

Programs written to run in Interpreted mode can be run by means of the Run-only
Interpreter which is supplied with the <A HREF="#GFA-Basic">GFA-Basic</A> Interpreter. This contains all
the routines necessary for the running of <A HREF="#GFA-Basic">GFA-Basic</A> programs and can be
distributed by bonafide <A HREF="#GFA-Basic">GFA-Basic</A> owners along with their programs, thus
allowing all ST users to run any software written in <A HREF="#GFA-Basic">GFA-Basic</A><A HREF="#.">.</A> The Interpreter
itself is sold for use by the owner, on one machine and copies may not be
passed on to another user.

Programs written in <A HREF="#GFA-Basic">GFA-Basic</A> Version 3 will be capable of being speeded up in
operation by the use of the <A HREF="#GFA-Basic">GFA-Basic</A> 3 compiler. This is designed to produce
programs which are executable without the need for supporting code, i.e. they
are true stand-alone .PRG files which can be distributed freely by the author.
Our only request is that an acknowledgement that they were produced using GFA
BASIC be included.

<HR SIZE=3><H2 ID="GEMDOS()_Table">GEMDOS() Table</H2>
Any program that uses <A HREF="#GEMDOS">GEMDOS</A><A HREF="#()">()</A> directly will run much better on all TOS
machines.

One other thing that is worth noting. You can completely avoid GFA's built in
error handling if you access <A HREF="#GEMDOS">GEMDOS</A><A HREF="#()">()</A> directly for all your file I/O needs. I
recommend all file I/O be done through direct <A HREF="#GEMDOS">GEMDOS</A><A HREF="#()">()</A> calls.  This will also
allow you to trap any file errors yourself rather than rely on the error
handling built into <A HREF="#GFA-Basic">GFA-Basic</A><A HREF="#.">.</A>

Not all TOS machines have the same <A HREF="#GEMDOS">GEMDOS</A><A HREF="#()">()</A> version so care should be taken
when calling these functions.

<A HREF="#GEMDOS">GEMDOS</A><A HREF="#()">()</A> Function Reference+
<A HREF="#GEMDOS">GEMDOS</A><A HREF="#()">()</A> Functions by Opcode+
<A HREF="#GEMDOS">GEMDOS</A><A HREF="#()">()</A> <A HREF="#Error_Codes">Error Codes</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="BIOS()_Table">BIOS() Table</H2>
For proper use of these calls please refer to a <A HREF="#BIOS">BIOS</A><A HREF="#()">()</A> manual.

<A HREF="#BIOS">BIOS</A><A HREF="#()">()</A> Function Reference+
<A HREF="#BIOS">BIOS</A><A HREF="#()">()</A> Functions by Opcode+
<A HREF="#BIOS">BIOS</A><A HREF="#()">()</A> <A HREF="#Error_Codes">Error Codes</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="XBIOS()_Table">XBIOS() Table</H2>
Don't use the <A HREF="#XBIOS">XBIOS</A>(4) function to determine screen size and color depth,
instead check the <A HREF="#WORK_OUT">WORK_OUT</A><A HREF="#()">()</A> values provided by the <A HREF="#VDI">VDI</A><A HREF="#.">.</A>

Not all TOS machines have the same <A HREF="#XBIOS">XBIOS</A><A HREF="#()">()</A> version so care should be taken when
calling these functions. Since the <A HREF="#XBIOS">XBIOS</A><A HREF="#()">()</A> does not provide a version number
itself the cookie jar should be checked to see what hardware is available.

<A HREF="#XBIOS">XBIOS</A><A HREF="#()">()</A> Function Reference+
<A HREF="#XBIOS">XBIOS</A><A HREF="#()">()</A> Functions by Opcode+
<HR SIZE=3><H2 ID="Line-A_Variable_Table">Line-A Variable Table</H2>
The base addresses of the <A HREF="#Line-A">Line-A</A> variables are returned by means of L~A:

{<A HREF="#L~A">L~A</A>-906} Address of the current font-header
 <A HREF="#L~A">L~A</A>-856  37 words, active <A HREF="#DEFMOUSE">DEFMOUSE</A>
{<A HREF="#L~A">L~A</A>-460} Pointer to the current font-header
 <A HREF="#L~A">L~A</A>-456  Array from four pointers, of which the last must be zero

Each pointer points to a concatenated list of character sets. The fist two
pointers are valid for resident fonts. Third is for the GDOS-Fonts, of this
with each <A HREF="#VDI">VDI</A><A HREF="#-">-</A><A HREF="#CALL">CALL</A> is put back.

 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>-440} Total number of this Fonts
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>-46}  Text line height
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>-44}  Maximum splits
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>-42}  Maximum cursor line
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>-40}  Length of a text line in bytes
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>-38}  Text background color
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>-36}  Text foreground color
    {<A HREF="#L~A">L~A</A>-34}  Address of the cursor in screen memory <A HREF="#INT">INT</A>{L~A-30}
              Distance of first text line from the upper screen edge
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>-28}  <A HREF="#CRSCOL">CRSCOL</A>
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>-26}  <A HREF="#CRSLIN">CRSLIN</A>
<A HREF="#BYTE">BYTE</A>{<A HREF="#L~A">L~A</A>-24}  Cursor blink period
<A HREF="#BYTE">BYTE</A>{<A HREF="#L~A">L~A</A>-23}  Cursor blink count
    {<A HREF="#L~A">L~A</A>-22}  Address of the data for the mode
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>-18}  Last <A HREF="#ASCII">ASCII</A> character of the font
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>-16}  First <A HREF="#ASCII">ASCII</A> character of the font
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>-12}  Horizontal resolution in pixels
    {<A HREF="#L~A">L~A</A>-10}  Address of the table
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>-4}   Vertical resolution in pixels
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>-0}   Number of bit planes
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+2}   Number of bytes per screen line
    {<A HREF="#L~A">L~A</A>+4}   Pointer for the <A HREF="#CONTRL">CONTRL</A> field
    {<A HREF="#L~A">L~A</A>+8}   Pointer for the <A HREF="#INTIN">INTIN</A> field
    {<A HREF="#L~A">L~A</A>+12}  Pointer for the <A HREF="#PTSIN">PTSIN</A> field
    {<A HREF="#L~A">L~A</A>+16}  Pointer for the <A HREF="#INTOUT">INTOUT</A> field
    {<A HREF="#L~A">L~A</A>+20}  Pointer for the <A HREF="#PTSOUT">PTSOUT</A> field
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+24}  Color value for bit level 0
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+26}  Color value for bit level 1
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+28}  Color value for bit level 2
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+30}  Color value for bit level 3
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+32}  Flag, do not draw last pixel of a line
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+34}  Line pattern
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+36}  <A HREF="#GRAPHMODE">GRAPHMODE</A>
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+38}  until
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+44}  2 coordinate pairs
    {<A HREF="#L~A">L~A</A>+46}  Pointer to current fill pattern
    {<A HREF="#L~A">L~A</A>+50}  Pointer to the current fill pattern mask
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+52}  Flag for multi-colored fill pattem
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+54}  Clipping-flag
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+56}  until
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+64}  Clipping-coordinates
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+66}  Enlargement factor
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+68}  Enlargement direction
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+70}  Flag for proportional script
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+72}  x-offset for text blit
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+74}  y-offset for text blit
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+76}  x-coordinate of a character on the screen
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+78}  y-coordinate of a character on the screen
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+80}  Width of a charaeter
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+82}  Height of a character
    {<A HREF="#L~A">L~A</A>+84}  Pointer to character set image
    {<A HREF="#L~A">L~A</A>+88}  Width of character set image
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+90}  Text style
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+92}  Mask for shaded text output
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+94}  Mask for italic script
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+96}  Additional width for wide script
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+98}  Italic script offset on the right
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+100} Italic script offset on the left
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+102} Enlargenment flag
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+104} Text rotation angle
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+106} Text color
    {<A HREF="#L~A">L~A</A>+108} Pointer in buffer for text effects
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+112} Offset for a second text effects buffer
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+114} Color of the text background
 <A HREF="#INT">INT</A>{<A HREF="#L~A">L~A</A>+116} Flag for copy screen form, <A HREF="#&#60;">&#60;</A><A HREF="#&">&</A>#62;0 for transparent
    {<A HREF="#L~A">L~A</A>+118} Pointer to routine, which terminates filling procedure <A HREF="#-">-</A>
              with V 3 by means of Shift-Altenate-Control

<A HREF="#Line-A_Variable_Table">Line-A Variable Table</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="V_OPNWK()_and_V_OPNVWK()_Input_Parameter_Table">V_OPNWK() and V_OPNVWK() Input Parameter Table</H2>
In addition to the values given below, the following default values are used: x
Device identification number (standard)

 1. :Screen      11. :Plotter
21. :Printer     31. :Metafile
41. :Camera      51. :Graphics tablet

1 Line type
1 Line color
1 Mark type
1 Mark color
1 Text style
1 Text color
1 Fill type
1 Fill style
1 Fill color
2 Coordinate stytem (0: NDC, 1: reserved, 2: RC)
<HR SIZE=3><H2 ID="VDI_WORK_OUT()_Array_Table">VDI WORK_OUT() Array Table</H2>
With <A HREF="#V_OPNWK">V_OPNWK</A><A HREF="#()">()</A> and <A HREF="#V_OPNVWK">V_OPNVWK</A>() the resultant values are returned in <A HREF="#INTOUT">INTOUT</A>(0) to
<A HREF="#INTOUT">INTOUT</A>(44) and in <A HREF="#PTSOUT">PTSOUT</A>(0) to PTSOUT(11)<A HREF="#.">.</A>

<A HREF="#WORK_OUT">WORK_OUT</A>(0)  Maximum picture width in pixels minus 1
<A HREF="#WORK_OUT">WORK_OUT</A>(1)  Maximum picture height in pixels minus 1
<A HREF="#WORK_OUT">WORK_OUT</A>(2)  Device coordinate units flag:
             0: Exact scaling possible
             1: Not possible
<A HREF="#WORK_OUT">WORK_OUT</A>(3)  Width of a pixel in microns
<A HREF="#WORK_OUT">WORK_OUT</A>(4)  Height of a pixel in microns
<A HREF="#WORK_OUT">WORK_OUT</A>(5)  Number of character heights (0: Modifiable)
<A HREF="#WORK_OUT">WORK_OUT</A>(6)  Number of line types
<A HREF="#WORK_OUT">WORK_OUT</A>(7)  Number of line widths (0: Modifiable)
<A HREF="#WORK_OUT">WORK_OUT</A>(8)  Number of marker types
<A HREF="#WORK_OUT">WORK_OUT</A>(9)  Number of marker sizes (0: Modifiable)
<A HREF="#WORK_OUT">WORK_OUT</A>(10) Number of faces supported by device
<A HREF="#WORK_OUT">WORK_OUT</A>(11) Number of patterns
<A HREF="#WORK_OUT">WORK_OUT</A>(12) Number of hatching patterns
<A HREF="#WORK_OUT">WORK_OUT</A>(13) Number of pre-defined colors/pens
<A HREF="#WORK_OUT">WORK_OUT</A>(14) Number of basic graphic functions (GDP)
<A HREF="#WORK_OUT">WORK_OUT</A>(15) List of basic graphic functions (GDP)
             Ten basic functions are supported:
             1: Bar
             2: Arc
             3: Pie
             4: Circle
             5: Ellipse
             6: Elliptical arc
             7: Elliptical pie
             8: Rounded rectangle
             9: Filled rounded rectangle
             10: Justified graphic text
<A HREF="#WORK_OUT">WORK_OUT</A>(24) <A HREF="#.">.</A>..end of GDP list (the end of this list is marked with a -1)
<A HREF="#WORK_OUT">WORK_OUT</A>(25) List of attributes of basic graphic functions:
             0: Polyline
             1: Polymarker
             2: Text
             3: Filled area
             4: None
<A HREF="#WORK_OUT">WORK_OUT</A>(34) <A HREF="#.">.</A>..End of attribute list
<A HREF="#WORK_OUT">WORK_OUT</A>(35) Color capability flag:
             0: Colors are not representable
             1: Are representable
<A HREF="#WORK_OUT">WORK_OUT</A>(36) Text rotation flag:
             0: Text cannot be rotated
             1: Can be rotated
<A HREF="#WORK_OUT">WORK_OUT</A>(37) Fill area capability flag:
             0: Fill functions are not possible
             1: Fill functions are possible
<A HREF="#WORK_OUT">WORK_OUT</A>(38) Cell array capability flag:
             0: Unavailable
             1: Available
<A HREF="#WORK_OUT">WORK_OUT</A>(39) Number of representable colors:
             0: <A HREF="#&">&</A>#62;32767
             2: Monochrome
             <A HREF="#&">&</A>#62;2: Color
<A HREF="#WORK_OUT">WORK_OUT</A>(40) Number of locator devices:
             1: Keyboard only
             2: Keyboard and other
<A HREF="#WORK_OUT">WORK_OUT</A>(41) Number of valuator devices:
             1: Keyboard only
             2: Keyboard and other
<A HREF="#WORK_OUT">WORK_OUT</A>(42) Number of choice devices:
             1: Function keys
             2: Function key and keypad
<A HREF="#WORK_OUT">WORK_OUT</A>(43) Number of string devices:
             1: Keyboard
<A HREF="#WORK_OUT">WORK_OUT</A>(44) Work station type:
             0: Output only
             1: Input only
             2: In/output
             3: Metafile
<A HREF="#WORK_OUT">WORK_OUT</A>(45) Minimum character width in pixels
<A HREF="#WORK_OUT">WORK_OUT</A>(46) Minimum character height in pixels
<A HREF="#WORK_OUT">WORK_OUT</A>(47) Maximum character width in pixels
<A HREF="#WORK_OUT">WORK_OUT</A>(48) Maximum character height in pixels
<A HREF="#WORK_OUT">WORK_OUT</A>(49) Minimum line width
<A HREF="#WORK_OUT">WORK_OUT</A>(50) Reserved, always 0
<A HREF="#WORK_OUT">WORK_OUT</A>(51) Maximum line width
<A HREF="#WORK_OUT">WORK_OUT</A>(52) Reserved, always 0
<A HREF="#WORK_OUT">WORK_OUT</A>(53) Minimum marker width
<A HREF="#WORK_OUT">WORK_OUT</A>(54) Minimum marker height
<A HREF="#WORK_OUT">WORK_OUT</A>(55) Maximum marker width
<A HREF="#WORK_OUT">WORK_OUT</A>(56) Maximum marker height

<A HREF="#VDI_WORK_OUT()_Array_Table">VDI WORK_OUT() Array Table</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="VT-52_Escape_Code_Table">VT-52 Escape Code Table</H2>
<A NAME="VT-52"></A>The Atari ST contains a <A HREF="#VT-52">VT-52</A> emulator which is modeled on a widely-used
terminal and by means of this, can be used for screens that do not contain
windows. The routines of this emulator can be called by the output of the
strings given in the folowing table by means of <A HREF="#PRINT">PRINT</A> and these all start with
the ESCape code (<A HREF="#CHR$">CHR$</A>(27))<A HREF="#.">.</A>

<A HREF="#CHR$">CHR$</A>(27)<A HREF="#+">+</A>"A"<A HREF="#;">;</A>  Cursor moves up one line (stops at the upper edge of the screen)
<A HREF="#CHR$">CHR$</A>(27)<A HREF="#+">+</A>"B"<A HREF="#;">;</A>  Cursor moves down one line (stops at the lower edge of the screen)
<A HREF="#CHR$">CHR$</A>(27)<A HREF="#+">+</A>"C"<A HREF="#;">;</A>  Cursor moves to the right (stops at the right-hand side)
<A HREF="#CHR$">CHR$</A>(27)<A HREF="#+">+</A>"D"<A HREF="#;">;</A>  Cursor moves to the left (stops at the left-hand side)
<A HREF="#CHR$">CHR$</A>(27)<A HREF="#+">+</A>"E"<A HREF="#;">;</A>  Clear screen (<A HREF="#CLS">CLS</A>)
<A HREF="#CHR$">CHR$</A>(27)<A HREF="#+">+</A>"H"<A HREF="#;">;</A>  Cursor moves to Home position (<A HREF="#LOCATE">LOCATE</A> 1,1)
<A HREF="#CHR$">CHR$</A>(27)<A HREF="#+">+</A>"I"<A HREF="#;">;</A>  Cursor moves up one line and scrolls at the upper edge
<A HREF="#CHR$">CHR$</A>(27)<A HREF="#+">+</A>"J"<A HREF="#;">;</A>  Erases from cursor to the end of page
<A HREF="#CHR$">CHR$</A>(27)<A HREF="#+">+</A>"K"<A HREF="#;">;</A>  Erases from cursor to the end of line
<A HREF="#CHR$">CHR$</A>(27)<A HREF="#+">+</A>"L"<A HREF="#;">;</A>  Inserts blank line at cursor position
<A HREF="#CHR$">CHR$</A>(27)<A HREF="#+">+</A>"M"<A HREF="#;">;</A>  Deletes line at cursor position (lines below scroll up)
<A HREF="#CHR$">CHR$</A>(27)<A HREF="#+">+</A>"Y"+CHR$(y+32)+CHR$(x+32)<A HREF="#;">;</A> Move cursor to x,y (<A HREF="#LOCATE">LOCATE</A> y,x)
<A HREF="#CHR$">CHR$</A>(27)<A HREF="#+">+</A>"b"+CHR$(f)<A HREF="#;">;</A> Selects f as text color
<A HREF="#CHR$">CHR$</A>(27)<A HREF="#+">+</A>"c"+CHR$(f)<A HREF="#;">;</A> Selects f as background color
<A HREF="#CHR$">CHR$</A>(27)<A HREF="#+">+</A>"d"<A HREF="#;">;</A>  Erase from top of page to cursor
<A HREF="#CHR$">CHR$</A>(27)<A HREF="#+">+</A>"e"<A HREF="#;">;</A>  Enable cursor
<A HREF="#CHR$">CHR$</A>(27)<A HREF="#+">+</A>"f'<A HREF="#;">;</A>  Disable cursor
<A HREF="#CHR$">CHR$</A>(27)<A HREF="#+">+</A>"j"<A HREF="#;">;</A>  Store cursor position
<A HREF="#CHR$">CHR$</A>(27)<A HREF="#+">+</A>"k"<A HREF="#:">:</A>  Restore cursor to position stored with ESC j
<A HREF="#CHR$">CHR$</A>(27)<A HREF="#+">+</A>"l"<A HREF="#;">;</A>  Erase line in which the cursor lies
<A HREF="#CHR$">CHR$</A>(27)<A HREF="#+">+</A>"o"<A HREF="#;">;</A>  Erase line from beginning to cursor position
<A HREF="#CHR$">CHR$</A>(27)<A HREF="#+">+</A>"p"<A HREF="#;">;</A>  Switch on reverse video
<A HREF="#CHR$">CHR$</A>(27)<A HREF="#+">+</A>"q"<A HREF="#;">;</A>  Switch off reverse video
<A HREF="#CHR$">CHR$</A>(27)<A HREF="#+">+</A>"v"<A HREF="#;">;</A>  Switch on word wrap at line end
<A HREF="#CHR$">CHR$</A>(27)<A HREF="#+">+</A>"w"<A HREF="#;">;</A>  Switch off word wrap at line end

<A HREF="#VT-52_Escape_Code_Table">VT-52 Escape Code Table</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="Scan_Code_Table">Scan Code Table</H2>
<A NAME="Scan"></A><B>Code  Description  Info</B>
$49   Page Up      Milan
$4F   End          Milan
$50   Page Down    Milan
<A HREF="#?">?</A>     F11          Milan
<A HREF="#?">?</A>     F12          Milan

<A HREF="#Scan_Code_Table">Scan Code Table</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="ASCII_Table">ASCII Table</H2>
<A NAME="ASCII"></A>
<A HREF="#ASCII">ASCII</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="Special_ASCII_Characters">Special ASCII Characters</H2>
  0 NUL     1 SOH     2 STX     5 ETX
  4 EOT     5 ENQ     6 ACK     7 BEL
  8 BS      9 HT     10 LF     11 VT
 12 FF     13 CR     14 SO     15 SI
 16 DLE    17 DC1    18 DC2    19 DC3
 20 DC4    21 NAK    22 SYN    23 ETB
 24 CAN    25 EM     26 <A HREF="#SUB">SUB</A>    27 ESC
 28 FS     29 GS     30 RS     31 US
127 DEL

 <A HREF="#&">&</A>#228;    &#196;    &#225;    &#224;    &#226;    &#192;
132  142  160  133  131  182

 <A HREF="#&">&</A>#235;         &#233;    &#232;    &#234;    &#201;
137       130  138  136  144

 <A HREF="#&">&</A>#239;         &#237;    &#236;    &#238;
139       161  141  140

 <A HREF="#&">&</A>#246;    &#246;    &#243;    &#242;    &#244;
148  153  162  149  147

 <A HREF="#&">&</A>#252;    &#252;    &#250;    &#249;    &#251;
129  154  163  151  150
<HR SIZE=3><H2 ID="Fill_Pattern_Table">Fill Pattern Table</H2>

Semi-official fill names taken from Atari's <A HREF="#VDI">VDI</A> source code (styles.h)<A HREF="#:">:</A>

 0,n  Hollow

 1,n  Solid

 2,1  Intensity level 2
 2,2  Intensity level 4
 2,3  Intensity level 6
 2,4  Intensity level 8
 2,5  Intensity level 10
 2,6  Intensity level 12
 2,7  Intensity level 14
 2,8  Intensity level 16
 2,9  Brick
2,10  Diagonal Bricks
2,11  Grass
2,12  Trees
2,13  Dashed x's
2,14  Cobble Stones
2,15  Sand
2,16  Rough Weave
2,17  Quilt
2,18  Patterned Cross
2,19  Balls
2,20  Verticle Scales
2,21  Diagonal scales
2,22  Checker Board
2,23  Filled Diamond
2,24  Herringbone

 3,1  Narrow spaced <A HREF="#+">+</A> 45
 3,2  Medium spaced thick 45 deg
 3,3  Medium <A HREF="#+">+</A>-45 deg
 3,4  Medium spaced vertical
 3,5  Medium spaced horizontal
 3,6  Medium spaced cross
 3,7  Wide +45 deg
 3,8  Widely spaced thick 45 deg
 3,9  Widely <A HREF="#+">+</A><A HREF="#-">-</A> 45 deg
3,10  Widely spaced vertical
3,11  Widely spaced horizontal
3,12  Widely spaced horizontal/vert cross

 4,1  Fuji

vsf_interior()<A HREF="#+">+</A>, vsf_style()+, vsf_udpat()+
<HR SIZE=3><H2 ID="Line_Style_Table">Line Style Table</H2>

vsl_type()<A HREF="#+">+</A>, vsl_ends()+
<HR SIZE=3><H2 ID="Error_Codes">Error Codes</H2>
<A HREF="#Editor_Error_Messages">Editor Error Messages</A>   (Test option only)
<A HREF="#Interpreter_Error_Codes">Interpreter Error Codes</A>
<A HREF="#BIOS_Error_Codes">BIOS Error Codes</A>
<A HREF="#GEMDOS_Error_Codes">GEMDOS Error Codes</A>
<A HREF="#Bomb_Error_Codes">Bomb Error Codes</A>

Note: All -negative values are considered system error codes.
      GFA adds the prefix <A HREF="#'">'</A><A HREF="#*">*</A> ' to all system error codes.
        Example: <A HREF="#'">'</A><A HREF="#*">*</A> Access denied' (<A HREF="##">#</A>-36)

<B>Memo:</B> Error codes as defined by MiNT <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> <A HREF="#ERRNO.H">ERRNO.H</A>

<A HREF="#Bomb_Error_Codes">Bomb Error Codes</A><A HREF="#+">+</A>
<A HREF="#BIOS">BIOS</A><A HREF="#()">()</A> <A HREF="#Error_Codes">Error Codes</A><A HREF="#+">+</A>
<A HREF="#GEMDOS">GEMDOS</A><A HREF="#()">()</A> <A HREF="#Error_Codes">Error Codes</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="Editor_Error_Messages">Editor Error Messages</H2>
   missing Select
   missing Endselect
<A HREF="#-">-</A>  M&#252;ll - Editor Fehler
   missing Wend
   missing Until
   missing Loop
   missing Next
   missing While
<A HREF="#-">-</A>  missing Repeat
   missing Do
   missing For
   missing Endif
   missing If
   Exit without loop
   missing Return
   Procedure in loop
   Procedure redefined
   missing Endfunc
   Function in loop
   Function redefined
   missing Procedure
   Label redefined
   Local without Procedure/Function
   Local in loop
<A HREF="#*">*</A>  Function redefined
   Goto into/outof For-Next, Procedure or Function
   Resume in For-Next
<A HREF="#+">+</A>  Resume without Procedure
   Resume in Function
   missing Function
   Syntax Error
   Line too long

<B>Memo:</B> Error message key:
      <A HREF="#-">-</A> Never used by the editor
      <A HREF="#*">*</A> Never used by the editor, duplicate error message
      <A HREF="#+">+</A> Incorrect error message, should be 'Resume without Procedure'
<HR SIZE=3><H2 ID="Interpreter_Error_Codes">Interpreter Error Codes</H2>
  0  <A HREF="#Division">Division</A> by zero
  1  Overflow
  2  Not Integer -2147483648 <A HREF="#.">.</A>. 2147483647
  3  Not Byte 0 <A HREF="#.">.</A>. 255
  4  Not Word -32768 <A HREF="#.">.</A>. 32767
  5  Square root only for positive numbers
  6  Logarithm only for numbers greater than zero
  7
  8  Out of memory
  9  Function or command not yet implemented
 10  String too long max. 32767 characters
 11  Not GFA-BASIC 3.5 program
 12  Program too long memory full <A HREF="#NEW">NEW</A>
 13  Not GFA-BASIC program file too short <A HREF="#NEW">NEW</A>
 14  Array dimensioned twice
 15  Array not dimensioned
 16  Array <A HREF="#index">index</A> too large
 17  Dim <A HREF="#index">index</A> too large
 18  Wrong number of indices
 19  Procedure not found
 20  Label not found
 21  On Open only "I"nput "O"utput "R"andom "A"ppend "U"pdate allowed
 22  File already open
 23  File <A HREF="##">#</A> wrong
 24  File not open
 25  Input wrong not numeric
 26  End of file reached
 27  Too many points for Polyline/Polyfill/Polymark max. 128
 28  Array must have one dimension
 29  Number of points too large for array
 30  Merge <A HREF="#-">-</A> Not an <A HREF="#ASCII">ASCII</A> file
 31  Merge <A HREF="#-">-</A> Line too long aborted
 32  <A HREF="#==&#62;">==&#62;</A> Syntax error program aborted
 33  Undefined label
 34  Out of data
 35  Data not numeric
 36
 37  Disk full
 38  Command not allowed in direct mode
 39  Program error Gosub not possible
 40  Clear not allowed in For-Next loops or Procedures
 41  Cont not possible
 42  Parameter missing
 43  Expression too complex
 44  Undefined function
 45  Too many parameters
 46  Parameter wrong must be a number
 47  Parameter wrong must be a string
 48  Open "R" Record length wrong
 49  Too many "R"-files (max 31)
 50  Not an "R"-File
 51
 52  Fields larger than record length
 53
 54  GET/PUT Field string length changed
 55  GET/PUT Record number wrong
 56
 57
 58
 59
 60  Sprite String length wrong
 61  Error while <A HREF="#RESERVE">RESERVE</A>
 62  <A HREF="#MENU">MENU</A> error
 63  <A HREF="#RESERVE">RESERVE</A> error
 64  Pointer (*x) error
 65  Array too small (<A HREF="#&">&</A>#60;256)
 66  No <A HREF="#VAR">VAR</A>-Array
 67  ASIN/ACOS error
 68  <A HREF="#VAR">VAR</A>-Type mismatch
 69  <A HREF="#ENDFUNC">ENDFUNC</A> without <A HREF="#RETURN">RETURN</A>
 70
 71  Index too large
 72
 73
 74
 75
 76
 77
 78
 79
 80  Matrix operations for one and two dimensional arrays only
 81  Matrices are of different order
 82  Vector product not defined
 83  Matrix product not defined
 84  Scalar product not defined
 85  Transposition for two dimensional arrays only
 86  Non square matrix
 87  Transposition not defined
 88  FACT/COMBIN/VARIAT not defined
 89
 90  <A HREF="#LOCAL">LOCAL</A> error
 91  <A HREF="#FOR">FOR</A> error
 92  Resume (next) not possible Fatal, For or Local
 93  Stack error
 94
 95
 96
 97
 98  Command only available on STE
 99
100  GFA BASIC Version 3.6 TT E <A HREF="#&">&</A>#169; Copyright 1986-1991 GFA Systemtechnik GmbH

<B>Memo:</B> Blank entries produce 'Undefined error XXX'

      Missing from the actual source code:
        #72 <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> <A HREF="#_DATA">_DATA</A>=x -<A HREF="#&">&</A>#62; Invalid <A HREF="#DATA">DATA</A> pointer

      Never actually used: #9 #25 #40 #44 #63 #91

      Duplicate: #20 <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> #33

      Retired from version 1 <A HREF="#&">&</A> 2: #36 #51 #53 #55

      <A HREF="#RUN">RUN</A>!Lib adds error message #99:
        'Redimensionierung nur mit gleicher Anzahl von Dimensionen'
        Translates to: 'Resizing with the same number of dimensions'
<HR SIZE=3><H2 ID="BIOS_Error_Codes">BIOS Error Codes</H2>
 -1  General error
 -2  Drive not ready
 -3  Unknown command
 -4  CRC error disk checksum wrong
 -5  Bad request
 -6  Seek error track not found
 -7  Unknown media boot sector wrong
 -8  Sector not found
 -9  Out of paper
-10  Write fault
-11  Read fault
-12  General error 12
-13  Write protected
-14  Media change detected
-15  Unknown device
-16  Bad sector (verify)
-17  Insert other disk (request)
-18
-19
-20
-21
-22
-23
-24
-25
-26
-27
-28
-29
-30
-31

<B>Memo:</B> Blank entries produce 'Undefined error -XXX'

<A HREF="#BIOS">BIOS</A><A HREF="#()">()</A> <A HREF="#Error_Codes">Error Codes</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="GEMDOS_Error_Codes">GEMDOS Error Codes</H2>
 -32  Invalid function number
 -33  File not found
 -34  Path not found
 -35  Too many open files
 -36  Access denied
 -37  Invalid handle
 -38
 -39  Out of memory
 -40  Invalid memory block address
 -41
 -42
 -43
 -44
 -45
 -46  Invalid drive specification
 -47
 -48
 -49  No more files
 -50
 -51
 -52
 -53
 -54
 -55
 -56
 -57
 -58
 -59
 -60
 -61
 -62
 -63
 -64  <A HREF="#GEMDOS">GEMDOS</A> range error seek wrong
 -65  <A HREF="#GEMDOS">GEMDOS</A> internal error
 -66  Invalid executable file format
 -67  Memory block growth failure
 -68
 -69
 -70
 -71
 -72
 -73
 -74
 -75
 -76
 -77
 -78
 -79
 -80
 -81
 -82
 -83
 -84
 -85
 -86
 -87
 -88
 -89
 -90
 -91
 -92
 -93
 -94
 -95
 -96
 -97
 -98
 -99
-100
-101
-102
-103
-104
-105
-106
-107
-108
-109
-110
-111
-112
-113
-114
-115
-116
-117
-118
-119
-120
-121
-122
-123
-124
-125
-126
-127
-128  Program stopped by the break key (compiled only)

<B>Memo:</B> Blank entries produce 'Undefined error -XXX'

<A HREF="#GEMDOS">GEMDOS</A><A HREF="#()">()</A> <A HREF="#Error_Codes">Error Codes</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="Bomb_Error_Codes">Bomb Error Codes</H2>
101
102  2 bombs <A HREF="#-">-</A> bus error Peek or Poke possibly wrong
103  3 bombs <A HREF="#-">-</A> address error Odd word address! Possibly at Dpoke, Dpeek, Lpoke or Lpeek
104  4 bombs <A HREF="#-">-</A> illegal instruction executed in machine code
105  5 bombs <A HREF="#-">-</A> divide by zero in 68000 Machine Code
106  6 bombs <A HREF="#-">-</A> CHK exception 68000 interrupted by CHK
107  7 bombs <A HREF="#-">-</A> TRAPV exception 68000 interrupted by TRAPV
108  8 bombs <A HREF="#-">-</A> privilege violation by 68000 Machine Code
109  9 bombs <A HREF="#-">-</A> trace exception
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127

<B>Memo:</B> Blank entries produce 'Undefined error XXX'

<A HREF="#Bomb_Error_Codes">Bomb Error Codes</A><A HREF="#+">+</A>
<HR SIZE=3><H2 ID="GFA-Basic_Compiler/Linker_Manual">GFA-Basic Compiler/Linker Manual</H2>
Contents
<HR>

<B><A HREF="#Introduction">Introduction</A></B>
  <A HREF="#Getting_Started">Getting Started</A>
<A HREF="#The_Function_of_the_Compiler">The Function of the Compiler</A>
<A HREF="#Commands_Not_Accepted_by_the_Compiler">Commands Not Accepted by the Compiler</A>
<A HREF="#Interpreter_-_Compiler_Differences">Interpreter - Compiler Differences</A>
<A HREF="#Using_the_Menu_Shell_Program">Using the Menu Shell Program</A>
<A HREF="#The_File_Menu">The File Menu</A>
<A HREF="#The_Options_Menu">The Options Menu</A>
<A HREF="#The_Sets_Menu">The Sets Menu</A>
<A HREF="#The_Shell-Listing">The Shell-Listing</A>
<A HREF="#Using_with_DOS_Shells">Using with DOS Shells</A>
<A HREF="#Program_Return_Value">Program Return Value</A>

<B><A HREF="#The_Compiler">The Compiler</A></B>
  <A HREF="#Array_Index_Checking">Array Index Checking</A>
<A HREF="#Integer_Overflow">Integer Overflow</A>
<A HREF="#The_Compiler_Options">The Compiler Options</A>
<A HREF="#Overview_of_Compiler_Options">Overview of Compiler Options</A>
<A HREF="#Integer_Division">Integer Division</A>
<A HREF="#Integer_Multiplication">Integer Multiplication</A>
<A HREF="#Reserving_Memory_Space">Reserving Memory Space</A>
<A HREF="#Return_Value_of_a_Function">Return Value of a Function</A>
<A HREF="#RC_INTERSECT()_Parameters">RC_INTERSECT() Parameters</A>
<A HREF="#Externally_Linked_Routines">Externally Linked Routines</A>
<A HREF="#Checking_the_BREAK_keys,_EVERY_and_AFTER">Checking the BREAK keys, EVERY and AFTER</A>
<A HREF="#Interrupt_Routines">Interrupt Routines</A>
<A HREF="#SELECT-CASE_Parameter">SELECT-CASE Parameter</A>
<A HREF="#SELECT-CASE_Optimisation">SELECT-CASE Optimisation</A>
<A HREF="#Error_Messages">Error Messages</A>
<A HREF="#Error_Numbers_Instead_of_Bombs">Error Numbers Instead of Bombs</A>
<A HREF="#Subroutines">Subroutines</A>
<A HREF="#ENDFUNC_Generation">ENDFUNC Generation</A>
<A HREF="#Register_Saving">Register Saving</A>
<A HREF="#FOR-NEXT_Loop_Checking">FOR-NEXT Loop Checking</A>
<A HREF="#Integer_Rounding">Integer Rounding</A>

<B><A HREF="#The_Linker">The Linker</A></B>
  <A HREF="#The_Linker_Options">The Linker Options</A>
  <A HREF="#Overview_of_Linker_Options">Overview of Linker Options</A>
<A HREF="#Symbol_Table">Symbol Table</A>
<A HREF="#Library_Selection">Library Selection</A>
<A HREF="#Linking_Object_Files">Linking Object Files</A>
<A HREF="#Do_not_Link_TEST.O">Do not Link TEST.O</A>
<A HREF="#Run_in_TT_Ram">Run in TT Ram</A>
<A HREF="#Including_C_Functions">Including C Functions</A>
<A HREF="#Linking_C_Functions_without_C_Libraries">Linking C Functions without C Libraries</A>
<A HREF="#Linking_with_C_Libraries">Linking with C Libraries</A>
<A HREF="#Some_Peculiarities">Some Peculiarities</A>
<A HREF="#Linker_Error_Messages">Linker Error Messages</A>

<B><A HREF="#Programming_Accessories">Programming Accessories</A></B>
  <A HREF="#The_Structure_of_Accessories">The Structure of Accessories</A>
<A HREF="#Programming_Example">Programming Example</A>
<A HREF="#Longer_Programming_Examples">Longer Programming Examples</A>

<B><A HREF="#Program_Optimization">Program Optimization</A></B>
  <A HREF="#Additional_Information">Additional Information</A>
<A HREF="#Simple_Additions">Simple Additions</A>
<A HREF="#Multiplication">Multiplication</A>
<A HREF="#Division">Division</A>
<A HREF="#More_Complicated_Calculations">More Complicated Calculations</A>
<A HREF="#Loop_Commands">Loop Commands</A>
<A HREF="#Character_Strings">Character Strings</A>
<A HREF="#Local_and_Global_Variables">Local and Global Variables</A>

<B><A HREF="#Technical_Support">Technical Support</A></B>
<A HREF="#Author/Publisher">Author/Publisher</A>

This manual is suitable for <A HREF="#GFA-Basic">GFA-Basic</A> Compiler versions 3.0 upwards. All
references to <A HREF="#GFA-Basic">GFA-Basic</A> 3.0 refer to all releases of version 3. References to
<A HREF="#GFA-Basic">GFA-Basic</A> 3.6, ie version 3, release 6, are specific to 3.6 and upwards. This
was last updated to include the new features of <A HREF="#GFA-Basic">GFA-Basic</A> Compiler 3.6. See the
README file on disk for any additional information.

<HR SIZE=3><H2 ID="Author/Publisher">Author/Publisher</H2>
<A NAME="EULA"></A><A NAME="End-user_License_Agreement"></A>
ATARI ST

<B>GFA</B>
<B>BASIC</B>
Version 3

Compiler/Linker

<A HREF="#/">/</A>-------------------\
<A HREF="#&#124;">&#124;</A>               GFA <A HREF="#&">&</A>#124;
<A HREF="#&#124;">&#124;</A><A HREF="#-">-</A>------------------<A HREF="#&">&</A>#124;
<A HREF="#&#124;">&#124;</A>          SOFTWARE <A HREF="#&">&</A>#124;
<A HREF="#&#124;">&#124;</A> TECHNOLOGIES <A HREF="#INC">INC</A><A HREF="#.">.</A> <A HREF="#&">&</A>#124;
\<A HREF="#-">-</A>------------------<A HREF="#/">/</A>

<HR>

No part of this publication may be copied, transmitted or stored in a retrieval
system or reproduced in any way including but not limited to photography,
photocopy, magnetic or other recording means, without prior permission from the
publishers, with the exception of material entered and executed on a computer
for the readers own use.

Every care has been taken in the writing and presentation of this book but no
responsibility is assumed by the author or publishers for any errrs or
omissions contained herein.


<B>ISBN 1 85552 002 8</B>

First Printed July 1989, reprints: May 1991


<B>COPYRIGHT <A HREF="#&">&</A>#169;    <A HREF="#GFA_Software_Technologies,_Inc.">GFA Software Technologies, Inc.</A>
               27 Congress St.
               Salem, MA 01970</B>


Program author         Frank Ostrowski
Manual author          Gottfried P. Engels
English translation    Gunter Minnerup
Typeset/layout         Melanie Player


<B>License</B>

Compiled GFA BASIC programs may be distributed without license payments to GFA,
as long as it is mentioned in the program, on the disk or in the manual that
the software was written in <A HREF="#GFA-Basic">GFA-Basic</A> 3.6.


This book was edited, compiled and typset on an Atari ST and an Atari SLM804
laser printer.
<HR SIZE=3><H2 ID="Introduction">Introduction</H2>
<A NAME="Getting_Started"></A><B><A HREF="#Getting_Started">Getting Started</A></B>

This section describes how to convert a <A HREF="#GFA-Basic">GFA-Basic</A> 3.0 source listing into an
executable program, and is intended for those readers who want to try out the
compiler quickly.

Before you continue you should take a backup copy of your original disk.

To generate a program you need the following files:

    GFA_BCOM.PRG  <A HREF="#GFA-Basic">GFA-Basic</A> 3.0 Compiler
    GL.PRG        <A HREF="#GFA-Basic">GFA-Basic</A> 3.0 Linker
    GFA3BLIB      Linker library
    GFA3BLIB.NDX  Linker library <A HREF="#index">index</A> file
    <A HREF="#MENU">MENU</A>.PRG      Menu program for the GFA system
    <A HREF="#*">*</A>.GFA         <A HREF="#GFA-Basic">GFA-Basic</A> 3.0 source files
    GFABASIC.PRG  <A HREF="#GFA-Basic">GFA-Basic</A> 3.0 Interpreter
    RCS2.PRG      Resource Construction Set required if your program will
                  support RCS files

To quickly compile one of the <A HREF="#GFA-Basic">GFA-Basic</A> source files (<A HREF="#*">*</A>.GFA) into a program
which can run without the Interpreter, do the following:

1) Start the <A HREF="#MENU">MENU</A>.PRG program.

2) In the File menu choose the entry entitled Select.

3) In the File Select box specify the GFA file to be compiled.

4) Press the F10 key. The source program will then be compiled and linked.

5) The compiled and linked code is now in the file called TEST.PRG on the
   diskette. You can execute it either by using the TEST entry in the File
   menu, or by exiting the menu program and running TEST.PRG

<HR SIZE=3><H2 ID="The_Function_of_the_Compiler">The Function of the Compiler</H2>
The Computer cannot understand BASIC commands directly. A BASIC program,
therefore needs to be translated into a language the computer understands. The
Interpreter reads the program line by line, translates each line into machine
code and then executes the machine code.

This method has advantages and disadvantages. The two most important
disadvantages are:

1) The program needs the Interpreter to run.

2) Since each BASIC command must be first translated before it can be executed,
   running programs can be relatively slow.

<A HREF="#The_Compiler">The Compiler</A> is a program which converts all the BASIC source code into machine
code without executing the resulting code. The compiled program can then be
saved.

<A HREF="#The_Compiler">The Compiler</A>, therefore, assembles an executable program from the individual
BASIC commands. This program then runs independently of the Interpreter and
Compiler. Program execution is fast because the commands are already in
translated format, ie machine code.

The <A HREF="#GFA-Basic">GFA-Basic</A> Compiler described in this book can only compile programs written
in <A HREF="#GFA-Basic">GFA-Basic</A> version 3.x. These programs must be stored using the <A HREF="#SAVE">SAVE</A> command
in the <A HREF="#GFA-Basic">GFA-Basic</A> 3.0 Interpreter. <A HREF="#The_Compiler">The Compiler</A> will not work with any program
stored using the <A HREF="#SAVE">SAVE</A>,A command, nor will it compile <A HREF="#GFA-Basic">GFA-Basic</A> version 2.0
programs, or any other versions of BASIC.

Earlier versions of the <A HREF="#GFA-Basic">GFA-Basic</A> interpreter may be incompatible with later
versions of the <A HREF="#GFA-Basic">GFA-Basic</A> compiler. If in doubt, use the latest versions.

<HR SIZE=3><H2 ID="Commands_Not_Accepted_by_the_Compiler">Commands Not Accepted by the Compiler</H2>
There are some commands which the Compiler will not accept; for example, the
commands such as <A HREF="#TRON">TRON</A>, <A HREF="#TROFF">TROFF</A>, and <A HREF="#TRACE$">TRACE$</A>, commands which affect the output
listing.

The <A HREF="#DEFLIST">DEFLIST</A> command is ignored by the Compiler, and the <A HREF="#DUMP">DUMP</A> command will not
be accepted, since the compiled program does not recognize variables by name.

As you cannot load, save, or list a compiled program, the <A HREF="#LOAD">LOAD</A>, <A HREF="#SAVE">SAVE</A>, <A HREF="#PSAVE">PSAVE</A>,
<A HREF="#LIST">LIST</A>, and <A HREF="#LLIST">LLIST</A> commands cannot be executed from a compiled program.

<B>Memo:</B> The command <A HREF="#'">'</A><A HREF="#==&#62;">==&#62;</A>' is also not accepted by the compiler.

<HR SIZE=3><H2 ID="Interpreter_-_Compiler_Differences">Interpreter - Compiler Differences</H2>
The <A HREF="#CHAIN">CHAIN</A> command works differently depending on whether it is interpreted or
compiled. In a compiled program the specified name is given to the <A HREF="#AES">AES</A> function
<A HREF="#SHEL_WRITE">SHEL_WRITE</A><A HREF="#()">()</A>, and the program which is running is terminated with a <A HREF="#QUIT">QUIT</A>
command. The program called by the <A HREF="#CHAIN">CHAIN</A> command is then started.

The called program does not therefore take up any more space.

A command line up to 128 bytes can be passed to the chained program. The
command line should be placed at <A HREF="#BASEPAGE">BASEPAGE</A>+128.

At least 32500 bytes must be free for a compiled program before calling the
<A HREF="#FILESELECT">FILESELECT</A> command.

<B>Memo:</B> <A HREF="#STOP">STOP</A> returns error code -128.

      The editor always intializes the <A HREF="#AES">AES</A> and the <A HREF="#VDI">VDI</A>, however the compiler
      will only do this if some <A HREF="#AES">AES</A> or <A HREF="#VDI">VDI</A> call is made. It's possible the
      ID returned from <A HREF="#APPL_INIT">APPL_INIT</A><A HREF="#()">()</A> is invalid, or the handle from <A HREF="#V~H">V~H</A> is
      invalid. Simply making an <A HREF="#AES">AES</A> or <A HREF="#VDI">VDI</A> call will force the compiler to
      link the initialization code.

      Also <A HREF="#~">~</A><A HREF="#INP">INP</A>(2) will appear to fail under MiNT if the <A HREF="#AES">AES</A> is not
      initialized.

<HR SIZE=3><H2 ID="Using_the_Menu_Shell_Program">Using the Menu Shell Program</H2>
The menu program enables programs to be called up easily, and parameters to be
passed to these programs. When a program executed from the menu program has
finished, the user is returned to the menu program.

The menu shell program for the <A HREF="#GFA-Basic">GFA-Basic</A> 3.0 Compiler resides on the
distribution disk, and enables you to call the Interpreter, Compiler, Linker,
and Resource Construction Set, implement Compiler and Linker options.

<HR SIZE=3><H2 ID="The_File_Menu">The File Menu</H2>
The first entry in the drop down File menu is Select. When this entry is
chosen, a File Select box appears for you to enter the GFA file on which you
want to work. As with all the other commands, you can also make this selection
using keys; the <B>Select</B> menu entry can also be activated up using
<B>Control and S</B><A HREF="#.">.</A>

<A HREF="#The_Compiler">The Compiler</A> menu entry sends the file selected to the Compiler, which will
create an object file called TEST.O. The <B>Compiler</B> can also be activated
using <B>Control and C</B><A HREF="#.">.</A>

The next menu entry can be used to call the Interpreter. The file assigned is
the one given in the Select entry. The <B>Interpreter</B> function can also be
activated using <B>Control and I</B><A HREF="#.">.</A>

The <B>Linker</B> entry can be selected using <B>Control and L</B>, to create
an executable program called TEST.PRG from the file TEST.O created by the
Compiler.

The <B>RCS</B> entry will call the RCS2.PRG. An alternative program name can
be placed in the variable <B>gfarcs$</B><A HREF="#.">.</A> The RCS function can also be
activated by <B>Control and R</B><A HREF="#.">.</A>

Selecting the <B>Test</B> entry, or <B>Control and T</B>, will initiate the
execution of the program TEST.PRG.

The <B>Execute</B> entry. The Execute function can also be activated by
<B>Control and X</B><A HREF="#.">.</A> An external program can be run from this command. The
file selection will appear, requesting you to enter the program to be executed.

The F10 key, calls the Compiler and then the Linker, and is thus a short cut
for <B>Control and C</B> and then <B>Control and L</B><A HREF="#.">.</A>

<HR SIZE=3><H2 ID="The_Options_Menu">The Options Menu</H2>
The next drop down menu gives the Compiler and Linker options. These are
described fully in sections 2.0 and 3.0.

The options are listed in the following table, with their respective menu entry
and key combination used to control the option:

    <B>Entry       Keys to activate  Option</B>
    Interrupts  Alternate+I       I+
    Select      Alternate+S       S& or S&#60; or both
    Functions   Alternate+F       F&#60;
    Procedures  Alternate+P       P&#62;
    IntDiv      Alternate+<A HREF="#/">/</A>       %3
    IntMul      Alternate+<A HREF="#*">*</A>       *<A HREF="#&">&</A>
    Error       Alternate+E       E$
    Memory      Alternate+M       mxxxx
    DebugSym    Alternate+D       <A HREF="#-s">-s</A>
    TT          Alternate+T       T

You can activate or suspend the options by using the keys or by selecting the
menu entry. With the Memory option you are asked for the amount of storage
space required by the program.

All these options, with the exception of DebugSym, are concerned with the
Compiler. The table entry for Select shows several possibilities of two
options. Selecting the menu entry once specifies the first option, selecting
the entry a second time specifies the second option, selecting the entry a
third time specifies both options.

The selected options are displayed on the top left of the screen. While the
Compiler is active the Basic line number being compiled is displayed in the
drop down menu list.

<HR SIZE=3><H2 ID="The_Sets_Menu">The Sets Menu</H2>
<A NAME="G3LIB"></A><A NAME="G3OBJ"></A><A NAME="G3PRG"></A><A NAME="G3MOVE"></A><A NAME="G3WAIT"></A>In the last menu, entitled Sets, certain parameters can be set. These
parameters are described below.

The <B><A HREF="#G3WAIT">G3WAIT</A></B> parameter determines whether or not, during compilation and
linking, a key is to be pressed before a file is opened. Such files could be
for example, the program being compiled, the object file, GFA3BLIB.NDX,
GFA3BLIB and the PRG file.

The purpose of this option is to allow you to change the disk before pressing
the key to continue. This is essential if you have only one disk drive, and the
necessary files reside on more than one disk.

After selecting this option, all the parameters in the Sets menu are displayed
on the screen. From this display you can see whether <A HREF="#G3WAIT">G3WAIT</A> has been turned on
or off.

You can also see from this display whether the next parameter on the menu,
<B><A HREF="#G3MOVE">G3MOVE</A></B>, is on or off. If G3MOVE is on, G3MOVE=ON is displayed on the
screen.

Enabling <A HREF="#G3MOVE">G3MOVE</A> directs the Compiler to manage the available storage space
economically during compilation. To begin the task the source code is loaded,
and compilation started. The compiled code is also held in store until it is
moved out.

In the case where you have a very large program and only a small amount of free
space, the source code and object program together may be too large to fit
completely in memory.

By activating <A HREF="#G3MOVE">G3MOVE</A>, as each procedure is compiled the source code is moved
out of memory. Naturally, this packing of memory during compilation is time
consuming, so <A HREF="#G3MOVE">G3MOVE</A> should only be enabled when necessary.

If you only select the entry <B><A HREF="#G3OBJ">G3OBJ</A></B>, you can change the default name of
the object file (normally TEST.O). Similarly, using <B><A HREF="#G3PRG">G3PRG</A></B> you can
change the default name of the compiled and linked object program (normally
TEST.PRG).

<B><A HREF="#G3LIB">G3LIB</A></B> enables you to change the name of the library normally called
GFA3BLIB. These options can, of course, be used not only for naming the
individual files, but also for establishing the path to the files.

The parameters can also be called by typing the letter following G3.

<B>PRG=GFA</B>, also selected with <B>F2</B> key. In this mode the file name
given to the compiled code is derived from the .GFA file (rather than be called
TEST.PRG). By selecting F2 (or by setting auto& in the <A HREF="#MENU">MENU</A>.PRG to 1), a GFA
file can be quickly selected and compiled with the sequence:

    <B>F2</B>
    <B>CTRL S</B> (entering name in File Select box)
    <B>F10</B>

<B>C Object</B>, also selected with <B>C</B> key. With this option you can
enter the names of the object files to be linked to the compiled code (Turbo C,
<A HREF="#DR">DR</A> C, or assembler)<A HREF="#.">.</A>

Therefore:

    W or w  for  <A HREF="#G3WAIT">G3WAIT</A>
    M or m  for  <A HREF="#G3MOVE">G3MOVE</A>
    O or o  for  <A HREF="#G3OBJ">G3OBJ</A>
    P or p  for  <A HREF="#G3PRG">G3PRG</A>
    L or l  for  <A HREF="#G3LIB">G3LIB</A>
    F2      for  PRG=GFA
    C       for  C Object

Pressing the <B><A HREF="#Help">Help</A></B> key clears the screen and displays the current state
of the Sets menu parameter entries.

Pressing the <B>Undo</B> key clears the screen but does not display the
parameter values.

<HR SIZE=3><H2 ID="The_Shell-Listing">The Shell-Listing</H2>
You can find a listing of the shell on your disk. In the listing you can set
the parameters described in the previous section. You will find the following
lines in the first part of the listing:

    gfaints$<A HREF="#=">=</A>"GFABASIC.PRG"
    gfacom$<A HREF="#=">=</A>"GFA_BCOM.PRG"
    gfalnk$<A HREF="#=">=</A>"GL.PRG"

These define the names of the interpreter, compiler, and linker and can, of
course, be altered.

The parameters <A HREF="#G3OBJ">G3OBJ</A>, <A HREF="#G3PRG">G3PRG</A>, and <A HREF="#G3LIB">G3LIB</A> take their default values from the
following lines:

    tobj$<A HREF="#=">=</A>"<A HREF="#G3OBJ">G3OBJ</A>=TEST.O"
    tprg$<A HREF="#=">=</A>"<A HREF="#G3PRG">G3PRG</A>=TEST.PRG"
    tlib$<A HREF="#=">=</A>"<A HREF="#G3LIB">G3LIB</A>=GFA3BLIB"

The parameters <A HREF="#G3WAIT">G3WAIT</A> and <A HREF="#G3MOVE">G3MOVE</A> get their values from these lines in the shell
listing:

    t_wait$<A HREF="#=">=</A>"<A HREF="#G3WAIT">G3WAIT</A>=ON"
    t_move$<A HREF="#=">=</A>"<A HREF="#G3MOVE">G3MOVE</A>=ON"

You can enable these options by deleting the underscore character in the
variable name.

The lines:

    coi&=0   <A HREF="#!">!</A> No I
    cos&=3   <A HREF="#!">!</A> S& and S&#60;
    cof&=0   <A HREF="#!">!</A> F&#60;
    cod&=0   <A HREF="#!">!</A> No %3
    com&=0   <A HREF="#!">!</A> No <A HREF="#*">*</A>&
    coe&=0   <A HREF="#!">!</A> No E
    cop&=0   <A HREF="#!">!</A> No P&#62;
    dbsym&=0 <A HREF="#!">!</A> No <A HREF="#-s">-s</A>
    auto&=0  <A HREF="#!">!</A> not xxx.prg from xxx.gfa

define the the default compiler and linker options.

The line <A HREF="#INLINE">INLINE</A> irq%,&HD6 contains an interrupt routine which during
compilation displays the number of the currently compiled line. Should you wish
to save the shell as a LST file, the <A HREF="#INLINE">INLINE</A> section needs to be saved
separately (go to <A HREF="#INLINE">INLINE</A> line, press <A HREF="#Help">Help</A> and save.  See a full explanation of
<A HREF="#INLINE">INLINE</A> in the Basic Interpreter manual)<A HREF="#.">.</A>

The following line:

    {irq%+2}=V:a&

declares a 16-bit variable to be displayed in the interrupt.

The lines:

    <A HREF="#BYTE">BYTE</A>{irq%+6}=32+35
    <A HREF="#BYTE">BYTE</A>{irq%+7}=32+10

define column 35 as the X position for the text output of the interrupt routine
and column 10 as the Y position.

When examining the shell program on the disk, you may notice that no redraw
routine has been implemented. This makes the program shorter and saves memory
space (shells ought to be small)<A HREF="#.">.</A> The primary reason for this, however, is to
keep visible the screen contents left behind by a program which has just been
run by the menu item "Test"<A HREF="#.">.</A>

<HR SIZE=3><H2 ID="Using_with_DOS_Shells">Using with DOS Shells</H2>
The compiler and linker may be controlled not only by the Shell, but also by a
DOS shell (command line interpreter)<A HREF="#.">.</A> This section describes the use of a DOS
shell or similar interface.

The compiler parameters can be passed in the same form as they appear in the
shells screen display, i.e.

    gfa_bcom name S& %3

Much the same applies to the linker parameters. Linking with generation of a
symbol table is achieved by

    gl <A HREF="#-s">-s</A>

To include a file named c_tst,

    gl c_tst

may be entered.

In this example, test.o, c_tst.o and gfa3blib are linked. The <A HREF="##">#</A> character in
the parameter list prevents the file test.o being linked.

The line

    gl <A HREF="##">#</A> c c_tst

would link the files c.o, c_tst.o and gfa3blib, but not test.o. In order to use
a library other than gfa3blib, you can enter its name prefixed with a plus
sign. Thus

    gl +new_lib

ensures that test.o and new_lib are linked. The linker considers all parameters
which are not prefixed by a plus sign and are not <A HREF="#-s">-s</A> or <A HREF="##">#</A> as the names of
object files to be linked.

<B>Memo:</B> These do not work quite right from the command line:
      <A HREF="#$I+">$I+</A>  !only works if it is the very first command
      <A HREF="#$B+">$B+</A>  !always fails

      Input parameters are as follows:
        Compiler:
          via command line: <A HREF="#*">*</A>.GFA source, $commands
          via environment variables: <A HREF="#G3OBJ">G3OBJ</A><A HREF="#=">=</A>, <A HREF="#G3WAIT">G3WAIT</A>=, <A HREF="#G3MOVE">G3MOVE</A>=

        Linker:
          via command line: <A HREF="##">#</A>, <A HREF="#*">*</A>.o, +library, <A HREF="#-s">-s</A>, <A HREF="#-t">-t</A>
          via environment variables: <A HREF="#G3OBJ">G3OBJ</A><A HREF="#=">=</A>, <A HREF="#G3PRG">G3PRG</A>=, <A HREF="#G3LIB">G3LIB</A>=, <A HREF="#G3WAIT">G3WAIT</A>=

<HR SIZE=3><H2 ID="Program_Return_Value">Program Return Value</H2>
After every program call, the return value is ouput on the screen. A 0 return
is OK, a negative number denotes an error (eg File not found), and a positive
number indicates other error conditions. Thus for example, the compiler could
return the number of uncompiled instructions and the linker the number of
undefined symbols.

<B>Memo:</B> Error codes are as follows:

      Compiler values:
      <A HREF="#&">&</A>#60;0 <A HREF="#=">=</A> Gemdos error code unless otherwise noted
             -1 <A HREF="#=">=</A> Disk full/Structure errors detected
             -8 <A HREF="#=">=</A> Out of memory
           -100 <A HREF="#=">=</A> Bad verion or file ID
       0 <A HREF="#=">=</A> Ok
      <A HREF="#&">&</A>#62;0 <A HREF="#=">=</A> Total number of errors detected

      Linker values:
      <A HREF="#&">&</A>#60;0 <A HREF="#=">=</A> Gemdos error code
           -1 <A HREF="#=">=</A> Disk full
       0 <A HREF="#=">=</A> Ok
      <A HREF="#&">&</A>#62;0 <A HREF="#=">=</A> Total number of symbol errors detected

Note: The return value appears to be a signed byte under some versions of MiNT.
      This is a bug in MiNT. For example: A missing file returns 223, thus 223
      <A HREF="#-">-</A> 256 <A HREF="#=">=</A> -33 See <A HREF="#'">'</A><A HREF="#Linker_Error_Messages">Linker Error Messages</A>' for more information.

<HR SIZE=3><H2 ID="The_Compiler">The Compiler</H2>
<A NAME="Array_Index_Checking"></A><B><A HREF="#Array_Index_Checking">Array Index Checking</A></B>

If you wish to use arrays in your program, these have to be dimensioned with
<A HREF="#DIM">DIM</A><A HREF="#.">.</A> This involves specifying the size of the largest array <A HREF="#index">index</A>. During
execution of the program, the GFA-BASIC Interpreter will check your array <A HREF="#index">index</A>
value for legality. If found too high, error 16 (Array <A HREF="#index">index</A> too large) is
reported. This also applies to the compiler for <A HREF="#GFA-Basic">GFA-Basic</A> 2.0.

There is no such array <A HREF="#index">index</A> checking in programs generated with the <A HREF="#GFA-Basic">GFA-Basic</A>
3.0 compiler. If an illegal large value appears for the array <A HREF="#index">index</A>, there is
no error message. The absence of this check makes programs shorter and quicker.

The following example shows the effect of there being no array <A HREF="#index">index</A> checking.
The program writes the numbers 0 to 5 to the screen. The interpreter generates
the error message "Array <A HREF="#index">index</A> too large"<A HREF="#.">.</A> The error message is triggered
because the dimensioning has limited the maximum <A HREF="#index">index</A> size to 5, yet the <A HREF="#FOR">FOR</A>
loop attempts to address an array element x(6)<A HREF="#.">.</A>

    <A HREF="#DIM">DIM</A> x(5)
    <A HREF="#FOR">FOR</A> i=0 TO 6
      x(i)=i
      <A HREF="#PRINT">PRINT</A> x(i)
    <A HREF="#NEXT">NEXT</A> i

When you compile and run this program, it writes the numbers from 0 to 6 to the
screen and no error message appears. The program acts as if the array x() in
the first line had been dimensioned to a sufficient size. You cannot tell from
the behaviour of the compiled program that it contains a serious mistake.

The example raises the question of what the compiled program would do if the
array <A HREF="#index">index</A> were too large. The <A HREF="#DIM">DIM</A> command reserves memory space for the
specified number of array elements. Without the programmer noticing this, the
array <A HREF="#index">index</A> is used in order to calculate the addresses of the array elements.

Compiled programs will do this even where the array <A HREF="#index">index</A> is too large. The
address calculated is outside the memory area reserved for the array. If the
array <A HREF="#index">index</A> is too large therefore, data outside the area reserved for the
array will be overwritten.

Normally the RAM space thus overwritten will contain data which is essential
for the error-free execution of the remaining program. If this data is
overwritten, the program can generate errors or even crash.

So far we have described the disadvantages of the absence of array <A HREF="#index">index</A>
checking. An excessively large <A HREF="#index">index</A>, however, will not figure in a finished
program since the programmer will have hopefully eliminated such mistakes. The
interpreter used for program development has supported him in this by its array
<A HREF="#index">index</A> checking.

Index checking is therefore unnecessary in the compiled program. It requires
time and space. The <A HREF="#GFA-Basic">GFA-Basic</A> 3.0 compiler is about four to five times as fast
as the Basic 2.0 compiler in simple operations with array elements (allocation,
addition of two array elements etc) and ten to twelve times as fast as the
Basic 3.0 interpreter.

<HR SIZE=3><H2 ID="Integer_Overflow">Integer Overflow</H2>
When changing integer variables, the GFA BASIC interpreter checks that the
value of the variable lies within the range for this variable type. The legal
ranges for the three types of integer variables are:

    <B>Type  Postfix  Minimum      Maximum</B>
    Byte  <A HREF="#&#124;">&#124;</A>        0            255
    Word  <A HREF="#&">&</A>        -32768       32767
    Long  <A HREF="#%">%</A>        -2147483648  2147483647

When the legal range is exceeded, error numbers (depending on the type of
variable affected) 2, 3 or 4 are triggered (Number not integer, byte, or word)<A HREF="#.">.</A>
Such an error is known as integer overflow.

A program generated with the <A HREF="#GFA-Basic">GFA-Basic</A> 3.0 compiler will not always be checked
for integer overflow. Such a check is superfluous in an error-free program and
only requires time and space. It is only sensible during program development
with the interpreter.

The program:

    x&=10000
    y&=4*x&
    <A HREF="#PRINT">PRINT</A> y&

generates the error message "Number not word" in the interpreter, whereas the
compiled program writes -25536 to the screen with no error message.

From the first two lines of the program, the compiler will generate the
following code (without the comments, of course)<A HREF="#:">:</A>

    move.w  <A HREF="##">#</A>$2710,<A HREF="#-">-</A>$8000(a5)  <A HREF="#;">;</A>$2710 is 10000 decimal
                               <A HREF="#;">;</A>$8000(a5) is the address of x&,
                               ;the instruction therefore equals
                               ;the line x&=10000.
    move.w  <A HREF="#-">-</A>$8000(a5),d0      ;x& is written into data
                               ;register 0.
    asl.w   <A HREF="##">#</A>$2,d0             ;The multiplication with a power
                               ;of 2 (4 in this case) is
                               ;executed with a fast bit shifting
                               ;command.
    move.w  d0,<A HREF="#-">-</A>$7ffe(a5)      <A HREF="#;">;</A>-$7ffe(a5) is the address of
                               ;y&<A HREF="#.">.</A> Thus result of the
                               ;multiplication is assigned to
                               ;y&<A HREF="#.">.</A>

The advantage of the non-existing integer overflow check results in the high
speed of the code. A program with a <A HREF="#FOR">FOR</A> loop and simple additions and
subtractions of integer variables is faster than in the interpreter by a factor
of 26.

<HR SIZE=3><H2 ID="The_Compiler_Options">The Compiler Options</H2>
<A NAME="Overview_of_Compiler_Options"></A><B><A HREF="#Overview_of_Compiler_Options">Overview of Compiler Options</A></B>

This section will first briefly describe which compiler options are available
and how you can set them. After that, each option is described in a section of
its own.


<A HREF="#$B+">$B+</A>     <A HREF="#ERROR">ERROR</A> messages instead of bombs.
<A HREF="#$C+">$C+</A>     <A HREF="#C:">C:</A>()/CALL should save/restore registers A3 to A6 on the stack.
<A HREF="#$C-">$C-</A>     <A HREF="#C:">C:</A>()/CALL shouldn't save/restore registers A3 to A6 on the stack.
<A HREF="#$E$">$E$</A>     <A HREF="#ERROR">ERROR</A> messages displayed as text.
<A HREF="#$E#">$E#</A>     <A HREF="#ERROR">ERROR</A> messages displayed as numbers.
<A HREF="#$F%">$F%</A>     <A HREF="#RETURN">RETURN</A> value of a <A HREF="#FUNCTION">FUNCTION</A> will be any integer type.
<A HREF="#$F&#62;">$F&#62;</A>     Enable <A HREF="#ENDFUNC">ENDFUNC</A> checking.
<A HREF="#$F&#60;">$F&#60;</A>     Disable <A HREF="#ENDFUNC">ENDFUNC</A> checking.
<A HREF="#$I+">$I+</A>     Enable interrupt routines.
<A HREF="#$I-">$I-</A>     Disable interrupt routines.
<A HREF="#$M">$M</A> xxxx The program should only use xxxx bytes of ram.
<A HREF="#$N+">$N+</A>     Enable <A HREF="#FOR">FOR</A><A HREF="#-">-</A><A HREF="#NEXT">NEXT</A> range checking.
<A HREF="#$N-">$N-</A>     Disable <A HREF="#FOR">FOR</A><A HREF="#-">-</A><A HREF="#NEXT">NEXT</A> range checking.
<A HREF="#$P&#62;">$P&#62;</A>     Do not optimize subroutines that have no parameters/LOCALs.
<A HREF="#$P&#60;">$P&#60;</A>     Optimize subroutines that have no parameters/LOCALs.
<A HREF="#$RC&">$RC&</A>    <A HREF="#RC_INTERSECT">RC_INTERSECT</A><A HREF="#()">()</A> parameters treated as 2 byte values.
<A HREF="#$RC%">$RC%</A>    <A HREF="#RC_INTERSECT">RC_INTERSECT</A><A HREF="#()">()</A> parameters treated as 4 byte values.
<A HREF="#$S&#62;">$S&#62;</A>     Optimise <A HREF="#SELECT">SELECT</A><A HREF="#-">-</A><A HREF="#CASE">CASE</A> for execution time.
<A HREF="#$S&#60;">$S&#60;</A>     Optimise <A HREF="#SELECT">SELECT</A><A HREF="#-">-</A><A HREF="#CASE">CASE</A> for program length.
<A HREF="#$S&#124;">$S&#124;</A>     Treat <A HREF="#SELECT">SELECT</A><A HREF="#-">-</A><A HREF="#CASE">CASE</A> parameters as 1 byte values.
<A HREF="#$S&">$S&</A>     Treat <A HREF="#SELECT">SELECT</A><A HREF="#-">-</A><A HREF="#CASE">CASE</A> parameters as 2 byte values.
<A HREF="#$S%">$S%</A>     Treat <A HREF="#SELECT">SELECT</A><A HREF="#-">-</A><A HREF="#CASE">CASE</A> parameters as 4 byte values.
<A HREF="#$U">$U</A>      Check EVERY/AFTER and <A HREF="#Break_Keys">Break Keys</A> once.
<A HREF="#$U+">$U+</A>     Enable EVERY/AFTER and <A HREF="#Break_Keys">Break Keys</A> after each instruction.
<A HREF="#$U-">$U-</A>     Disable EVERY/AFTER and <A HREF="#Break_Keys">Break Keys</A> checking.
<A HREF="#$X">$X</A> name The routine name to be taken from a linked file.
<A HREF="#$*&">$*&</A>     Longword multiplication with muls.
<A HREF="#$*%">$*%</A>     Longword multiplication without muls.
<A HREF="#$%0">$%0</A>     Variables are converted to floating point and then divided.
<A HREF="#$%3">$%3</A>     Always execute integer division as an integer division.
<A HREF="#$%6">$%6</A>     Round integers up.

<B>Memo:</B> These commands must be placed in the source code itself and do
      not always work as expected via the command line:
      <A HREF="#$B+">$B+</A>  !always fails
      <A HREF="#$F%">$F%</A>  !not supported
      <A HREF="#$I+">$I+</A>  !only works if its the very first command
      <A HREF="#$Ux">$Ux</A>  !locks up the compiler!
      <A HREF="#$X">$X</A>   !not supported

<HR SIZE=3><H2 ID="Integer_Division">Integer Division</H2>
<A NAME="$%0"></A><A NAME="$%3"></A>The compiler options <A HREF="#$%0">$%0</A> and <A HREF="#$%3">$%3</A> influence the division of integer variables
(longwords)<A HREF="#.">.</A> If the <A HREF="#$%0">$%0</A> option is active, the variables to be divided are made
into floating point variables and then divided. The result of such a division
is a floating point variable.

If the <A HREF="#$%3">$%3</A> option is enabled, the two integer variables are not made into
floating point variables. The result of the integer division will then be
interpreted as an integer value.

Example: Once compiled, the program

    <A HREF="#$%0">$%0</A>
    x%=5
    y%=2
    <A HREF="#PRINT">PRINT</A> x%/y%

produces the output 2.5. The fact that the digit behind the decimal point was
output indicates that x% and y% have been converted into floating point numbers
before the division took place. Compiler option <A HREF="#$%3">$%3</A> will produce 2 as a result,
since x% and y% are interpreted as integers without decimal points and
therefore only an integer division is carried out. This option has no effect in
the interpreter, of course, where you will get 2.5 in both cases.

The code generated by the two options will illustrate the difference once
again.

The lines

    <A HREF="#$%0">$%0</A>
    a%=x%/y%/z%

will generate the code:

    move.l  <A HREF="#-">-</A>$7ffc(a5),d0
    bsr     FITOF
    move.l  d0,<A HREF="#-">-</A>(a7)
    move.w  d2,<A HREF="#-">-</A>(a7)
    move.w  d1,<A HREF="#-">-</A>(a7)
    move.l  <A HREF="#-">-</A>$7ff8(a5),d0
    bsr     FITOF
    move.w  (a7)<A HREF="#+">+</A>,d4
    move.w  (a7)<A HREF="#+">+</A>,d5
    move.l  (a7)<A HREF="#+">+</A>,d3
    bsr     FXDIV
    move.l  d0,<A HREF="#-">-</A>(a7)
    move.w  d2,<A HREF="#-">-</A>(a7)
    move.w  d1,<A HREF="#-">-</A>(a7)
    move.l  <A HREF="#-">-</A>$7ff4(a5),d0
    bsr     FITOF
    move.w  (a7)<A HREF="#+">+</A>,d4
    move.w  (a7)<A HREF="#+">+</A>,d5
    move.l  (a7)<A HREF="#+">+</A>,d3
    bsr     FXDIV
    bsr     FFTOI
    move.l  d0,<A HREF="#-">-</A>$8000(a5)

In this listing, you will notice that the subroutine FLTOF (integer to float),
which converts the integers into floating point numbers, is called three times.
Since the result is returned to an integer variable, the routine FFTOI (float
to integer) is also required. The division is carried out with (FXDIV), a
division routine producing floating point results.

By contrast, the program

    <A HREF="#$%3">$%3</A>
    a%=x%/y%/z%

generates the assembler listing

    move.l  <A HREF="#-">-</A>$7ffc(a5),d0
    move.l  <A HREF="#-">-</A>$7ff8(a5),d1
    bsr     LDIV
    move.l  <A HREF="#-">-</A>$7ff4(a5),d0
    bsr     LDIV
    move.l  d0,<A HREF="#-">-</A>$8000

This short listing simply calls a fairly straight forward subroutine to divide
two longwords (LDIV) and can therefore be processed much faster than under the
<A HREF="#$%0">$%0</A> option. The difference in speed is of a factor around 10 to 11.

If two integer variables are divided and the result is returned to an integer
variable without any further processing, the compiler option %0 is of no
consequence. In that case, only pure integer arithmetic is being used.

In the event of two-byte variables being defined, the Motorola 68000
processor's div command is used instead of the LDIV routine (see the section on
division in the Program Optimisation chapter)<A HREF="#.">.</A>

<B>Memo:</B> <A HREF="#$%0">$%0</A> is the default.
<HR SIZE=3><H2 ID="Integer_Multiplication">Integer Multiplication</H2>
<A NAME="$*&"></A><A NAME="$*%"></A>The <A HREF="#$*&">$*&</A> option influences the multiplication of two integer variables, of which
at least one is a four-byte variable. Normally in such cases a subroutine to
multiply two four-byte variables is called. If the <A HREF="#$*&">$*&</A> option is enabled,
however, the Motorola 68000 processor's muls instruction is used instead.

This has two consequences:

1. Program execution is speeded up.

2. The muls instruction multiplies two two-byte values and produces a four-byte
   value as the result. Therefore, if the four-byte variables to be multiplied
   contain values in excess of the range of a two-byte variable, the use of
   only two bytes will generate a different result from when option <A HREF="#$*&">$*&</A> is not
   enabled.

Example: The lines

    <A HREF="#$*&">$*&</A>
    b%=40000
    c%=10
    a%=b%*c%
    <A HREF="#PRINT">PRINT</A> a%

will produce the expected result of 400000 in the interpreter. The compiled
program, however, outputs -255360 because only two bytes of b% have been used,
and these two bytes cannot represent as large a value as 40000.

The difference is once again illustrated by the code generated from the line
a%=b%*c% with and without option <A HREF="#$">$</A>*&<A HREF="#:">:</A>

    <B>with <A HREF="#$*&">$*&</A>                 with <A HREF="#$*%">$*%</A>, without <A HREF="#$">$</A><A HREF="#*">*</A><A HREF="#&">&</A></B>
    move.l  <A HREF="#-">-</A>$7ff8(a5),d0    move.l  -$7ff8(a5),d0
    move.l  <A HREF="#-">-</A>$7ffc(a5),d1    move.l  -$7ffc(a5),d1
    muls    d1,d0            bsr     LMUL
    move.l  d0,<A HREF="#-">-</A>$8000(a5)    move.l  d0,-$8000(a5)

The default setting is option <A HREF="#*">*</A><A HREF="#%">%</A> which leads to LMUL being used.

<B>Memo:</B> <A HREF="#$*%">$*%</A> is the default.
<HR SIZE=3><H2 ID="Reserving_Memory_Space">Reserving Memory Space</H2>
<A NAME="$M"></A>The compiler option $Mx is used to generate a program which will simply reserve
x bytes for itself. Normally a program generated with the <A HREF="#GFA-Basic">GFA-Basic</A> 3.0
compiler claims all available memory space (minus 16 kb) for itself.

The instruction <A HREF="#RESERVE">RESERVE</A> can be used to force a program to claim only part of
the free memory, but this has an effect different from the $mx option. A
program beginning with <A HREF="#RESERVE">RESERVE</A> 25600, for example, will first claim all free
memory when run. The GFA BASIC instruction <A HREF="#RESERVE">RESERVE</A> will only then be executed
and release some of the reserved space again.

By contrast, the compiler option $m25600 will ensure that not all free memory,
but only 25600 bytes (if available) will be used by the program. This compiler
option must be used in <A HREF="#accessories">accessories</A> which may only use part of the free memory.
You can find an example in the chapter on <A HREF="#accessories">accessories</A><A HREF="#.">.</A>

<B>Memo:</B> The space between the option and the number is optional.
      Example: $m 2048
      The compiler does not actually accept values in the range of 0 to 999.
      Any value in this range is automatically replaced with 1000.
      Odd values are rounded down (made even)<A HREF="#:">:</A> $M65535 <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> allocates 65534 kb

      Important: If the exact value cannot be allocated (ram to low) it
      gives the application all the available ram minus 16384 bytes. This
      could cause a program to behave strangely or crash, since the program
      doesn't know it was given a smaller amount than requested.
      This situation can be detected with the following code:
      <A HREF="#IF">IF</A> <A HREF="#MALLOC">MALLOC</A>(<A HREF="#TRUE">TRUE</A>)<A HREF="#&#60;">&#60;</A>=16384
        <A HREF="#PRINT">PRINT</A> "<A HREF="#$M">$M</A> failed, program terminated!"
        <A HREF="#EDIT">EDIT</A>
      <A HREF="#ENDIF">ENDIF</A>

      Under MiNT memory is rounded to an 8kb boundary, so you might as well
      request a size pre-rounded up, this way your program can use the ram
      that would normally be wasted.

      What exactly is contained in this block of memory:
      Dimensioned arrays (all types)<A HREF="#:">:</A> <A HREF="#DIM">DIM</A> tmp$(10),buf&#124;(32),ptr%(12)
        This also includes all data stored in the array and its <A HREF="#descriptor">descriptor</A><A HREF="#.">.</A>
      All assigned strings: t$<A HREF="#=">=</A>"test"
        This also includes the string <A HREF="#descriptor">descriptor</A><A HREF="#.">.</A>

      This can be a very tricky value to compute! It may requires some trial
      and error.

      What is not in this block of memory?
      All assigned numerical variables (all types)<A HREF="#:">:</A> a#=3.16 or size%=2048
        These are stored in the BSS section of the binary.
<HR SIZE=3><H2 ID="Return_Value_of_a_Function">Return Value of a Function</H2>
<A NAME="$F%"></A>The <A HREF="#$F%">$F%</A> option must be entered as the first line of a function to have an
effect. It instructs the compiler to output the return value of the function
as an integer. The default output is a floating point value.

This default behavior is probably some throw back to the classic days of BASIC
where everything was floating point. Unless you care about it yourself at each
and every function, you will always get the slower floating point.

<A HREF="#$F%">$F%</A> does not specifically imply long% type only. The compiler actually checks
the variable at <A HREF="#'">'</A><A HREF="#RETURN_x">RETURN x</A>' and adjusts the code automatically based on the
variable type. In other words the compiler will auto cast it to the correct
integer type. String functions are handled automatically and <A HREF="#$F%">$F%</A> is ignored.

To be more precise, the <A HREF="#'">'</A><A HREF="#%">%</A>' (percent sign) means return any integer type, it
does not mean return only long type. The compiler does not report syntax
errors within compiler commands, it simply ignores them.

Not only does this speed up your functions but it reduces the code size of
each function. Option <A HREF="#$F%">$F%</A> eliminates two library calls, BSR FITOF (integer to
float) and BSR FFTOI (float to integer)<A HREF="#.">.</A> Both of these add several lines of
needless assembler overhead to each function call made!  Quite literally if
<A HREF="#$F%">$F%</A> is missing the function converts the output to floating point and then the
assignment to some variable converts it back. The effect of this at each call
of a function is, integer <A HREF="#-">-</A><A HREF="#&#62;">&#62;</A> float -<A HREF="#&">&</A>#62; integer, which is for sure not very
optimal.

<B>Memo:</B> The compiler requires this command to be on the very 1st line of the
      funcition or it has no effect at all. Example:

      a%<A HREF="#=">=</A>@test             !BSR FFTOI (flt to int)
      <A HREF="#PRINT">PRINT</A> a%
      <A HREF="#EDIT">EDIT</A>
      <A HREF="#FUNCTION">FUNCTION</A> test
        <A HREF="#$F%">$F%</A>                !absolutely has to be the very 1st line!
        <A HREF="#RETURN">RETURN</A> 1.23456789  !BSR FITOF (int to flt)
      <A HREF="#ENDFUNC">ENDFUNC</A>

      A space between <A HREF="#'">'</A><A HREF="#$">$</A>' and 'F%' will cause it to fail. Example:
      <A HREF="#$">$</A> F%  !compiler fails to see the option

      According to some French manuals $F&#124; and $F& are valid options.
      These do not work, in fact it will result in a float being returned!
      I've also seen $F$ and $F! in other peoples source listings and they
      do not work.

      To be precise, no where in the compiler source code is a check for
      $F!, $F!, $F&, or $F$<A HREF="#.">.</A> All of these produce slower floating point
      output. The compiler has exactly one check for <A HREF="#'">'</A><A HREF="#$F%">$F%</A>' only. Any books
      or manuals that state otherwise are incorrect.

      <A HREF="#DEFFN">DEFFN</A> functions always return floating point values.
      They must be recoded into multi-line functions to speed them up.
<HR SIZE=3><H2 ID="RC_INTERSECT()_Parameters">RC_INTERSECT() Parameters</H2>
<A NAME="$RC&"></A><A NAME="$RC%"></A>The compiler options <A HREF="#$RC&">$RC&</A> and <A HREF="#$RC%">$RC%</A> are used to control the interpretation of
the <A HREF="#RC_INTERSECT">RC_INTERSECT</A><A HREF="#()">()</A> parameters. By default, these parameters are converted by
the compiler into four-byte parameters.

In many cases, however, the range of two-byte integer variables is quite
sufficient for these parameters. Using option <A HREF="#$RC&">$RC&</A>, you can make the compiler
interpret the <A HREF="#RC_INTERSECT">RC_INTERSECT</A><A HREF="#()">()</A> parameters as two-byte parameters.

This option is important only exceptionally and in special cases. The
<A HREF="#RC_INTERSECT">RC_INTERSECT</A><A HREF="#()">()</A> function is principally intended for calculating the size of
overlapping rectangles within a redraw.

For a redraw, only two-byte parameters are required since coordinates can only
be two bytes large under GEM. But the speed gain through using the <A HREF="#$RC&">$RC&</A> option
can be neglected here because, on the one hand, other instructions (such as the
screen section renewal) within a redraw take more time than the window overlap
calculation, and on the other, the <A HREF="#RC_INTERSECT">RC_INTERSECT</A><A HREF="#()">()</A> function will only be called
a few times in such a case.

However, the <A HREF="#$RC&">$RC&</A> option does save some memory space when using 16 bit
variables. Another application can be found in the context of hidden line
calculations.

<B>Memo:</B> <A HREF="#$RC%">$RC%</A> is the default.

<HR SIZE=3><H2 ID="Externally_Linked_Routines">Externally Linked Routines</H2>
<A NAME="$X"></A>The <A HREF="#$X">$X</A> name must be the first line in a procedure or function. In this event,
the contents of the procedure or function is not compiled, but a message is
left for the linker to instruct it to take the routine "name" from an object
file to be linked in.

The use of this option is explained in the section
"<A HREF="#Linking_C_Functions_without_C_Libraries">Linking C Functions without C Libraries</A>"<A HREF="#.">.</A>

<A HREF="#*">*</A>* The manual ends here, the following is what I found to be true. **

Parameters are always passed on the stack.
Only words and longs will be passed.
Floats are a special case and passed as two longs.
In order to use floats in assembler one would need to know GFA's internal
float format.
Bytes and boolean values are cast into words.
Strings and <A HREF="#VAR">VAR</A> parameters are cast as long pointers.
In the case of strings or arrays, the address of the <A HREF="#descriptor">descriptor</A> is passed.
The assembler routine receives the parameters in the reverse order starting at
offset 4(sp)<A HREF="#.">.</A>

Example call:
  @test(long1%,long2%,long3%)

In assembler:
  move.l   4(sp),d3  ;long3%
  move.l   8(sp),d2  ;long2%
  move.l  12(sp),d1  ;long1%

Your routines should always end with an RTS instruction.

The assembler routine should not alter the stack, because GFA itself removes
the parameters from the stack after the call for you. If you do need to alter
the stack, be sure to save and restore it.

Also registers a3 to a6 should not be altered. However you can use these so
long as you save and restore them.

When coding functions, d0 is always used to return a long value.
<A HREF="#$F%">$F%</A> is automatically implied.

<B>Memo:</B> The space between the option and the name can be left out.
      Example: $Xname
      A space between <A HREF="#'">'</A><A HREF="#$">$</A>' and 'X' will cause it to fail.
      Example: <A HREF="#$">$</A> Xname !compiler fails to see the option
      <A HREF="#$X">$X</A> contains a serious bug: It does not fix the stack correctly after
                                 the call in all cases.
      It only works correctly for PROCEDURES that do not use <A HREF="#VAR">VAR</A><A HREF="#.">.</A>
      With <A HREF="#VAR">VAR</A> it calculates too small of a stack correction.
      With <A HREF="#FUNCTION">FUNCTION</A> it does no stack correction at all!
      The problem is the parameters are actually left on the stack.
      Thus each call eats stack space, until eventually the stack collides with
      GFA's internal structures.

      Devpac v3.1 can be used to build DRI format object files.
      Registers a3 to a7 must remain unchanged.
<HR SIZE=3><H2 ID="Checking_the_BREAK_keys,_EVERY_and_AFTER">Checking the BREAK keys, EVERY and AFTER</H2>
<A NAME="$U"></A><A NAME="$U+"></A><A NAME="$U-"></A><A NAME="$Ux"></A>During program execution the <A HREF="#GFA-Basic">GFA-Basic</A> interpreter normally offers the ability
to abort the program by simultaneously pressing the Control, Left Shift, and
Alternate keys.

This ability does not exist as default in a compiled program. However, using
the <A HREF="#$Ux">$Ux</A> compiler option you can enable it. To enable any scanning of the stop
keys at all, the I+ option must be active.

The scanning of the break keys is linked to a test for the <A HREF="#EVERY">EVERY</A> and <A HREF="#AFTER">AFTER</A>
conditions. Also, a RESUME/NEXT is prepared.  Therefore all instructions which
could generate errors should be enclosed by $u (or, to put it more accurately,
$u safeguards the program counter PC, the stack pointer SP and the BASIC stack
pointer A3. Hence no DIMs, ERASEs or GOSUBs, FNs must be executed between the
$u and the error)<A HREF="#.">.</A>

The x parameter can have the following values, with the possibilities indicated
here:

    <A HREF="#$U">$U</A>   inserts a check
    <A HREF="#$U+">$U+</A>  inserts a check at each instruction generating code
    <A HREF="#$U-">$U-</A>  disables the checking.

The following program cannot be interrupted by pressing the three stop keys in
its first loop, but these keys are enabled (after pressing the right mouse
button) in the second loop.

    <A HREF="#$U-">$U-</A>
    <A HREF="#REPEAT">REPEAT</A>
    UNTlL <A HREF="#MOUSEK">MOUSEK</A>
    <A HREF="#DO">DO</A>
      <A HREF="#$U">$U</A>
    <A HREF="#LOOP">LOOP</A>

The <A HREF="#DO">DO</A> <A HREF="#LOOP">LOOP</A> cannot be aborted if the listing is changed to

    <A HREF="#$U+">$U+</A>
    <A HREF="#DO">DO</A>
    <A HREF="#LOOP">LOOP</A>

because the checking only takes place after <A HREF="#LOOP">LOOP</A> and not after <A HREF="#DO">DO</A>, as DO is not
a code-generating instruction.

If you wish to use the <A HREF="#RESUME">RESUME</A> command you must have U+ switched on.

<B>Memo:</B> <A HREF="#$U-">$U-</A> is the default.
<HR SIZE=3><H2 ID="Interrupt_Routines">Interrupt Routines</H2>
<A NAME="$I+"></A><A NAME="$I-"></A>The <A HREF="#$I+">$I+</A> and <A HREF="#$I-">$I-</A> compiler options can be used to enable or disable the interrupt
routines for:

    <A HREF="#-">-</A> <A HREF="#EVERY">EVERY</A> and <A HREF="#AFTER">AFTER</A>
    <A HREF="#-">-</A> the stop/break keys (Control-Shift-Alternate)
    <A HREF="#-">-</A> the <A HREF="#ASCII">ASCII</A> code entry via Alternate-number
    <A HREF="#-">-</A> the function key configuration (<A HREF="#KEYPAD">KEYPAD</A> and <A HREF="#KEYDEF">KEYDEF</A>)
    <A HREF="#-">-</A> the enabling of the mouse pointer in the event of disk errors
      (eg. Please insert Disk B in Drive A)
    <A HREF="#-">-</A> Error messages instead of bombs

Using these options lengthens the compiled code.

<B>Memo:</B> <A HREF="#$I-">$I-</A> is the default.
      <A HREF="#$B+">$B+</A> is also linked to <A HREF="#$I+">$I+</A> (missing from the original manual)
<HR SIZE=3><H2 ID="SELECT-CASE_Parameter">SELECT-CASE Parameter</H2>
<A NAME="$S&#124;"></A><A NAME="$S&"></A><A NAME="$S%"></A>Using the <A HREF="#$S&">$S&</A> option, you can make the <A HREF="#SELECT">SELECT</A><A HREF="#-">-</A><A HREF="#CASE">CASE</A> instruction treat all
following expressions as two-byte parameters. The default <A HREF="#$S%">$S%</A> option makes
<A HREF="#SELECT">SELECT</A> and <A HREF="#CASE">CASE</A> treat all values as four-byte parameters.

A look at the resulting code illustrates the differences. The listing

    <A HREF="#SELECT">SELECT</A> a%
    <A HREF="#CASE">CASE</A> 1
      case_1:
      <A HREF="#INC">INC</A> a%
    <A HREF="#CASE">CASE</A> 2
      case_2:
      <A HREF="#INC">INC</A> a%
    <A HREF="#DEFAULT">DEFAULT</A>
      default:
      <A HREF="#INC">INC</A> a%
    <A HREF="#ENDSELECT">ENDSELECT</A>
    endsel:
    <A HREF="#INC">INC</A> a%

contains markers to make the symbolically disassembled code more transparent.
Each marker is followed by an instruction (<A HREF="#INC">INC</A> a%) as a placemarker for the
individual instruction blocks.

Use of the <A HREF="#$S&">$S&</A> option results in the following code:

              move.l  <A HREF="#-">-</A>$8000(a5),d0
              bra.s   L1
    _CASE_1:  addq.l  <A HREF="##">#</A>$1,<A HREF="#-">-</A>$8000(a5)
              bra.s   _ENDSEL
    _CASE_2:  addq.l  <A HREF="##">#</A>$1,<A HREF="#-">-</A>$8000(a5)
              bra.s   _ENDSEL
    _DEFAULT: addq.l  <A HREF="##">#</A>$1,<A HREF="#-">-</A>$8000(a5)
              bra.s   _ENDSEL
    L1:       cmpi.w  <A HREF="##">#</A>$2,d0  <A HREF="#;">;</A><A HREF="#CASE">CASE</A> evaluation
              beq.s   _CASE_1
              cmpi.w  <A HREF="##">#</A>$2,d0
              beq.s   _CASE_2
              bra.s   _DEFAULT
    _ENDSEL   addq.l  <A HREF="##">#</A>$1,<A HREF="#-">-</A>$8000(a5)

The L1 label is not generated here.

The listing first places the four-byte value a% into d0. Then the routine to
branch to the individual <A HREF="#CASE">CASE</A> instruction blocks is called. This is marked in
the listing by the comment "<A HREF="#CASE">CASE</A> evaluation"<A HREF="#.">.</A> There cmpi.w (compare integer
words) is used to compare, for wordlength only, the values after <A HREF="#CASE">CASE</A> with the
contents of d0.

If these values are found to be identical, beq.s (branch equal) jumps to the
block after the appropriate <A HREF="#CASE">CASE</A><A HREF="#.">.</A> This block ends with the jump to the line
behind the <A HREF="#SELECT">SELECT</A><A HREF="#-">-</A><A HREF="#ENDSELECT">ENDSELECT</A> block. Here the jump is made using bra.s _ENDSEL.
If none of the values after <A HREF="#CASE">CASE</A> fits, the <A HREF="#DEFAULT">DEFAULT</A> block is called. Without the
S& option the comparisons made here would be for longword length.

<B>Memo:</B> <A HREF="#$S%">$S%</A> is the default.
      Whilst viewing a diss-assembly of the GFA Compiler I discovered a check
      for the <A HREF="#$S&#124;">$S&#124;</A> command.  However, my tests seem to indicate that it's
      identical to the <A HREF="#$S&">$S&</A> command. The reason is simple, there is no size or
      speed advantage to byte comparisons on the 68000. The <A HREF="#$S&#124;">$S&#124;</A> command seems
      to have been added just for completeness.
<HR SIZE=3><H2 ID="SELECT-CASE_Optimisation">SELECT-CASE Optimisation</H2>
<A NAME="$S&#62;"></A><A NAME="$S&#60;"></A>The <A HREF="#$S&#62;">$S&#62;</A> and <A HREF="#$S&#60;">$S&#60;</A> options determine the optimising criterion for the <A HREF="#SELECT">SELECT</A><A HREF="#-">-</A><A HREF="#CASE">CASE</A>
instructions. <A HREF="#$S&#62;">$S&#62;</A> leads to optimisation by execution time, <A HREF="#$S&#60;">$S&#60;</A> according to
program length.

You have seen in the last section how, at the end of the program blocks after
the <A HREF="#CASE">CASE</A> and the <A HREF="#DEFAULT">DEFAULT</A> instructions, bra.s branches into the line following
<A HREF="#ENDSELECT">ENDSELECT</A><A HREF="#.">.</A> However, if the program blocks are longer than in the last section,
where they only contained an addq, bra must be used instead of bra.s.

The space required for the specification of the jump distance is larger with
bra than with bra.s. The <A HREF="#$S&#60;">$S&#60;</A> option can be used to save this space. It results
in the bra instruction at the end of a <A HREF="#CASE">CASE</A> block to be directed to the bra
instruction of the next block (after the next <A HREF="#CASE">CASE</A> or <A HREF="#DEFAULT">DEFAULT</A>), as long as the
jump distance is small enough.

This could result in a chain of short branch jumps which finally ends behind
<A HREF="#ENDSELECT">ENDSELECT</A><A HREF="#.">.</A> This chain of jumps from bra.s to bra.s may again be altered by the
compiler at a later stage of optimisation.

This not altogether straight forward problem is clarified by the following
listing:

              move.l  <A HREF="#-">-</A>$8000(a5),d0
              bra     L1
    _CASE_1:  addq.l  <A HREF="##">#</A>$1,<A HREF="#-">-</A>$8000(a5)
              bra.s   L0
    _CASE_2:  addq.l  <A HREF="##">#</A>$1,<A HREF="#-">-</A>$8000(a5)
    L0:       bra     L2
    _DEFAULT: addq.l  <A HREF="##">#</A>$1,<A HREF="#-">-</A>$8000(a5)
              <A HREF="#.">.</A>..
              Many instructions
              <A HREF="#.">.</A>..
    L2:       bra.s   _ENDSEL
    L1:       cmpi.w  <A HREF="##">#</A>$1,d0 <A HREF="#;">;</A><A HREF="#CASE">CASE</A> evaluation
              beq     _CASE_1
              cmpi.w  <A HREF="##">#</A>$2,d0
              beq     _CASE_2
              bra     _DEFAULT
    _ENDSEL   addq.l  <A HREF="##">#</A>$1,<A HREF="#-">-</A>$8000(a5)

The crucial point here is the line bra.s L0. This branch should really go to
behind <A HREF="#ENDSELECT">ENDSELECT</A><A HREF="#.">.</A> But the distance would be too far for a bra.s because of the
many instructions in the <A HREF="#DEFAULT">DEFAULT</A> block. Hence the branch is to the bra command
in the next <A HREF="#CASE">CASE</A> program block.

While this method is executed more slowly, it requires less space than the code
generated with <A HREF="#$S&#62;">$S&#62;</A>, which does without such jumps.

<B>Memo:</B> <A HREF="#$S&#62;">$S&#62;</A> is the default.
<HR SIZE=3><H2 ID="Error_Messages">Error Messages</H2>
<A NAME="$E$"></A><A NAME="$E#"></A>Should an error appear in a compiled program, an error message describing the
nature of the error is displayed. You can use options <A HREF="#$E$">$E$</A> and <A HREF="#$E#">$E#</A> to choose
between numbers and text for these error messages.

The <A HREF="#$E$">$E$</A> option displays error messages as text. Since the message texts must be
part of the compiled code, this increases its length slightly.

The selected option always applies to the whole program. Unlike other options,
it cannot be altered for different parts of the program.

<B>Memo:</B> <A HREF="#$E#">$E#</A> is the default.
<HR SIZE=3><H2 ID="Error_Numbers_Instead_of_Bombs">Error Numbers Instead of Bombs</H2>
<A NAME="$B+"></A>The <A HREF="#$B+">$B+</A> option makes error numbers appear instead of "bombs"<A HREF="#.">.</A> This option must
not be used in <A HREF="#accessories">accessories</A><A HREF="#.">.</A> The <A HREF="#$B+">$B+</A> option can only be enabled, and will be
disabled again once the program has been executed.

Never use <A HREF="#$B+">$B+</A> in an <A HREF="#accessory">accessory</A>, otherwise you might trap bombs generated by the
application.

<B>Memo:</B> This option should not be used under MiNT. All bomb errors
      generated by any running programs will be sent to your application!
      The same problem occurs as with an <A HREF="#accessory">accessory</A><A HREF="#.">.</A>
      Requires <A HREF="#$I+">$I+</A> be enabled or the following problems occur:
        Bomb handler will not be unhooked
        Supervisor stack is not correctly saved/restored
<HR SIZE=3><H2 ID="Subroutines">Subroutines</H2>
<A NAME="$P&#62;"></A><A NAME="$P&#60;"></A>Procedures and functions will be compiled as GFA BASIC subroutines if the <A HREF="#$P&#62;">$P&#62;</A>
option is enabled, thus allowing the passing of parameters and problem-free
recursive calls.

The <A HREF="#$P&#60;">$P&#60;</A> option leads to procedures and function without parameters or local
variables to be compiled as simple 68000 subroutines. This can produce problems
in recursive calls with stack overflows. On the other hand, they are executed
more quickly. Also, no <A HREF="#RESUME">RESUME</A> or <A HREF="#RESUME_NEXT">RESUME NEXT</A> is possible with <A HREF="#$P&#60;">$P&#60;</A>.

<B>Memo:</B> <A HREF="#$P&#60;">$P&#60;</A> is the default.
<HR SIZE=3><H2 ID="ENDFUNC_Generation">ENDFUNC Generation</H2>
<A NAME="$F&#62;"></A><A NAME="$F&#60;"></A>In a <A HREF="#GFA-Basic">GFA-Basic</A> listing, a function always ends with <A HREF="#ENDFUNC">ENDFUNC</A><A HREF="#.">.</A> When this line is
reached, error message 69 appears (<A HREF="#ENDFUNC">ENDFUNC</A> without <A HREF="#RETURN">RETURN</A>) because a function
must always encounter <A HREF="#RETURN">RETURN</A> before it reaches <A HREF="#ENDFUNC">ENDFUNC</A><A HREF="#.">.</A>

If the <A HREF="#$F&#62;">$F&#62;</A> function is used, this also applies to the compiled program. The <A HREF="#$F&#60;">$F&#60;</A>
option prevents the error message from being displayed. The code will then
simply continue to be executed after the function, with unpredictable results.

As a rule, compiled programs have been thoroughly tested. If this is the case,
error 69 should not appear. Using <A HREF="#$F&#60;">$F&#60;</A> will then produce slightly shorter
program code.

<B>Memo:</B> <A HREF="#$F&#62;">$F&#62;</A> is the default.
      <A HREF="#$F&#60;">$F&#60;</A> will save about 4 bytes per <A HREF="#FUNCTION">FUNCTION</A><A HREF="#.">.</A>
<HR SIZE=3><H2 ID="Register_Saving">Register Saving</H2>
<A NAME="$C+"></A><A NAME="$C-"></A>The <A HREF="#GFA-Basic">GFA-Basic</A> manual indicates that the <A HREF="#C:">C:</A> and <A HREF="#CALL">CALL</A> routines must not, as in
common to C routines on 68000 computers, change the registers A3 to A6 and A7,
even though this has normally no consequences in the interpreter. Also with <A HREF="#C:">C:</A>
there is hardly ever a parameter in D0, which is a coincidental feature of the
interpreter.

<B>Memo:</B> <A HREF="#$C-">$C-</A> is the default.
<HR SIZE=3><H2 ID="FOR-NEXT_Loop_Checking">FOR-NEXT Loop Checking</H2>
<A NAME="$N+"></A><A NAME="$N-"></A>If a <A HREF="#FOR">FOR</A><A HREF="#-">-</A><A HREF="#NEXT">NEXT</A> loop spans the entire range of a variable type, it will become
endless and loop. For example:

    <A HREF="#FOR">FOR</A> i&#124;=0 TO 255
      <A HREF="#.">.</A>..
    <A HREF="#NEXT">NEXT</A> i&#124;

This will loop as i&#124; will never reach 256 and end the loop. (A byte variable
will only hold 0 to 255)<A HREF="#.">.</A> <A HREF="#$N+">$N+</A> will ensure the loop terminates correctly.

<B>Memo:</B> <A HREF="#$N-">$N-</A> is the default.
<HR SIZE=3><H2 ID="Integer_Rounding">Integer Rounding</H2>
<A NAME="$%6"></A>With this option, the compiler is forced to round up integers. For example:

    x%<A HREF="#=">=</A><A HREF="#RND">RND</A>*640

will generate numbers from 0 to 639
<HR SIZE=3><H2 ID="The_Linker">The Linker</H2>
<A NAME="The_Linker_Options"></A><A NAME="Overview_of_Linker_Options"></A><B><A HREF="#The_Linker_Options">The Linker Options</A></B>

<B><A HREF="#Overview_of_Linker_Options">Overview of Linker Options</A></B>

In this section all the linker options will be briefly introduced and their
settings described. In subsequent sections, each option will be described in
detail.

    <B><A HREF="#-s">-s</A></B>     Append symbol table.
    <B><A HREF="#+">+</A><A HREF="#NAME">NAME</A></B>  Use library NAME instead of GFA3BLIB.
    <B><A HREF="#NAME">NAME</A></B>   Include object file NAME.O.
    <B><A HREF="##">#</A></B>      Do not include TEST.O.
    <B>-T</B>     Produce code to run in TT ram

The settings in <A HREF="#G3OBJ">G3OBJ</A>, <A HREF="#G3PRG">G3PRG</A>, <A HREF="#G3LIB">G3LIB</A> and <A HREF="#G3WAIT">G3WAIT</A> are passed to the linker by the
shell.

<HR SIZE=3><H2 ID="Symbol_Table">Symbol Table</H2>
<A NAME="-s"></A>The <A HREF="#-s">-s</A> option tells the linker to append a symbol table so that the program can
be disassembled and debugged using symbols. The names of the procedures and
functions as well as label names are taken from the <A HREF="#GFA-Basic">GFA-Basic</A> listing and
written as symbols.

Only the first seven characters of a procedure, function or label name are used
in this process, and are prefixed with an underscore character.

<HR SIZE=3><H2 ID="Library_Selection">Library Selection</H2>
The +lib option selects the library lib_name to be used by the linker. If this
option is not enabled, the linker will look for a library under the name
GFA3BLIB.

The section headed "<A HREF="#Linking_with_C_Libraries">Linking with C Libraries</A>" describes in more detail how a
library is created or how GFA3BLIB can be extended. In that section you are
shown how to include the Turbo C libraries.

<HR SIZE=3><H2 ID="Linking_Object_Files">Linking Object Files</H2>
To link an object file, which must be <A HREF="#DR">DR</A> format, you can pass the file name
without the .O extender to the linker.

The section "<A HREF="#Linking_C_Functions_without_C_Libraries">Linking C Functions without C Libraries</A>" will describe in more
detail how you can use the routines contained in the object files in your
<A HREF="#GFA-Basic">GFA-Basic</A> programs.

<HR SIZE=3><H2 ID="Do_not_Link_TEST.O">Do not Link TEST.O</H2>
Using the <A HREF="##">#</A> parameter, the linker can be made not to link the TEST.O file. By
default, the linker looks for a file of that name, since the compiler gives
this name to all object files created by it.

<HR SIZE=3><H2 ID="Run_in_TT_Ram">Run in TT Ram</H2>
<A NAME="-t"></A>With the -T flag set, code will be generated that will load into the Atari TT
ram area. The default (not set) will assume that the code is to run in ST ram
area.

<B>Memo:</B> Default program flags are as follows:
      Private
      Fastload

      With option -T on:
      Private
      Fastload
      Load Alt
      Malloc Alt

<HR SIZE=3><H2 ID="Including_C_Functions">Including C Functions</H2>
<A NAME="cdecl"></A>This section deals with the question of how routines written in the C
programming language can be included in compiled <A HREF="#GFA-Basic">GFA-Basic</A> 3.0 programs. The
method described here requires the C compiler to be able to generate object
files in the <A HREF="#DR">DR</A> format, as can DR C and Turbo C.

<HR SIZE=3><H2 ID="Linking_C_Functions_without_C_Libraries">Linking C Functions without C Libraries</H2>
The basic method will now be demonstrated with the aid of an example. The
routine to be included is to fill the elements of a two-byte array with numbers
from 0 to n, passing the address and the size of the array. The parameter
passed for the array size will only be a two-byte variable so that the size of
the array is limited to 32267 elements. The function carrying out this task
will work without the use of library functions.

The <A HREF="#GFA-Basic">GFA-Basic</A> program is to be written in such a way that it can also be run by
the interpreter. In the interpreter, of course, the C routine cannot be
included through the linker. Therefore it is made executable within the
interpreter by a <A HREF="#GFA-Basic">GFA-Basic</A> routine taking over the task of the C routine to be
linked.

The <A HREF="#GFA-Basic">GFA-Basic</A> program looks like this:

    DlM x&(32000),y&(32000)
    <A HREF="#'">'</A>
    t1%<A HREF="#=">=</A><A HREF="#TIMER">TIMER</A>
    f_gfa(32000)
    t2%<A HREF="#=">=</A><A HREF="#TIMER">TIMER</A>
    <A HREF="#PRINT">PRINT</A> "In GFA-Basic:"<A HREF="#'">'</A>(t2%-t1%)/200
    <A HREF="#FOR">FOR</A> i&=0 TO 39
      <A HREF="#PRINT">PRINT</A> x&(i&),
    <A HREF="#NEXT">NEXT</A> i&
    <A HREF="#'">'</A>
    t1%<A HREF="#=">=</A><A HREF="#TIMER">TIMER</A>
    f_c(V:y&(0),32000)
    t2%<A HREF="#=">=</A><A HREF="#TIMER">TIMER</A>
    <A HREF="#PRINT">PRINT</A> "In Turbo <A HREF="#C:">C:</A>"<A HREF="#'">'</A>(t2%-t1%)/200
    <A HREF="#FOR">FOR</A> i&=0 TO 39
      <A HREF="#PRINT">PRINT</A> y&(i&),
    <A HREF="#NEXT">NEXT</A> i&
    <A HREF="#'">'</A>
    <A HREF="#PROCEDURE">PROCEDURE</A> f_gfa(n&)
      <A HREF="#FOR">FOR</A> i&=0 TO n&
        x&(i&)=i&
      <A HREF="#NEXT">NEXT</A> i&
    <A HREF="#RETURN">RETURN</A>
    <A HREF="#'">'</A>
    <A HREF="#PROCEDURE">PROCEDURE</A> f_c(adr%,n&)
      <A HREF="#$X">$X</A> fill
      i&=0
      a%=adr%
      <A HREF="#WHILE">WHILE</A> i&<A HREF="#&#60;">&#60;</A>=n&
        <A HREF="#WORD">WORD</A>{a%}=i&
        <A HREF="#INC">INC</A> i&
        <A HREF="#ADD">ADD</A> a%,2
      <A HREF="#WEND">WEND</A>
    <A HREF="#RETURN">RETURN</A>

First, two arrays are dimensioned. Then two timings are taken: the first calls
the f_gfa routine which assigns values of 0 to 32000 to the elements of the
array x&<A HREF="#()">()</A><A HREF="#.">.</A> For display purposes, the first 40 elements of the array are then
displayed on screen.

The second of the timings calls the routine f_c. This routine, too, is to
assign values of 0 to 32000 to an array, but this task is to be performed in
the compiled and linked program by a C routine. Therefore this routine is
supplied with the field address and the number of values to be written.

In the first line of the procedure f_c you will find an instruction which tells
the linker to include the C function "fill"<A HREF="#.">.</A> The name of the function can be
found after the <A HREF="#$X">$X</A> option. This line must always be the first line of the
procedure.

The linker replaces the contents of the procedure with the C routine named
after <A HREF="#$X">$X</A><A HREF="#.">.</A> In the interpreter, this line is ignored and the command lines
following <A HREF="#$X">$X</A> c_routine are executed. There are three of these in the given
example, which perform the same function as the C routine and also work in the
same way as the C routine by carrying out value assignments through a pointer.

Now to the structure of the C program carrying out the assignment. It was
written in Turbo C and reads:

    void <A HREF="#cdecl">cdecl</A> fill(n,adr)
    int n;
    int *adr;
    {
      int i; int *a;
      a <A HREF="#=">=</A> adr;
      for( i=0 <A HREF="#;">;</A> i&#60;=n ; *a++ = i++ );
    }

The first line contains the name of the function which appears after <A HREF="#$X">$X</A> in the
GFA-Baisc listing. This function has no return value and has therefore been
declared as void.

Before the function name there is the instruction <A HREF="#cdecl">cdecl</A><A HREF="#.">.</A> It tells Turbo C to
receive the parameters via the stack. Some other C compilers, such as <A HREF="#DR">DR</A> C, do
this automatically. In the GFA BASIC listing the parameters are passed in the
order adr%, n&<A HREF="#.">.</A>

C takes the parameters from the stack in the reverse order, i.e. first the
two-byte value n and then the address of a four-byte variable adr. The
following lines then carry out the assignment of values to the field elements.

This completes the description of the structure of the <A HREF="#GFA-Basic">GFA-Basic</A> and the C
listings. It only remains to explain how you can get the linker to insert the C
function in the position of <A HREF="#$X">$X</A> fill. To do this, you only need to specify the
name of the object file generated by the C compiler.

This file name can simply be entered in the command line if a DOS shell is
used. In the shell supplied the variable <A HREF="#G3OBJ">G3OBJ</A> can be amended.

The execution time of the <A HREF="#GFA-Basic">GFA-Basic</A> loop is around 0.51 seconds, while the
Turbo C loop only requires about 0.115 seconds. This shows how assignments
using pointer operations can be effectively optimised in Turbo C.

Thus the following steps have to be followed:

1. You write a procedure in the GFA BASlC program, the first line of which
   contains the <A HREF="#$X">$X</A> option followed by a C function name.

2. You write a C program containing this function. This must take the
   parameters and place them on the stack. There the parameters are placed in
   the reverse of the order that they have when passed by the <A HREF="#GFA-Basic">GFA-Basic</A>
   program.

3. When linking, the object file of the C listing with the routine to be linked
   must be specified.

If the <A HREF="#DR">DR</A> C compiler is used, one point to be noted is that this compiler
prefixes C function names with the underscore character. Hence, instead of <A HREF="#$X">$X</A>
fill, <A HREF="#$X">$X</A> _fill would have to be entered.

In our example, the C function had no return value and was therefore declared
as void. However, a C function can be employed not only in place of a <A HREF="#GFA-Basic">GFA-Basic</A>
procedure, but also in place of a <A HREF="#GFA-Basic">GFA-Basic</A> function.

The appropriate <A HREF="#GFA-Basic">GFA-Basic</A> listing could be, for example:

    value%=100
    <A HREF="#PRINT">PRINT</A> @doub(value%)
    <A HREF="#'">'</A>
    <A HREF="#FUNCTION">FUNCTION</A> doub(a%)
      <A HREF="#$X">$X</A> double
      <A HREF="#ALERT">ALERT</A> 1,"Place marker for&#124;a C function.",1,"Return",a&
      <A HREF="#RETURN">RETURN</A> 0
    <A HREF="#ENDFUNC">ENDFUNC</A>

In this example, the <A HREF="#GFA-Basic">GFA-Basic</A> function does not perform the task of the C
routine to be linked in. The simple C programs follows:

    long <A HREF="#cdecl">cdecl</A> double(x)
    long x;
    {
      return x+x;
    }

The return value of such an external function is always an integer value.

You can, of course, also link assembler routines. These must take their
parameters from the stack and must not change the stack pointer SP or the
registers A3, A4, A5 and A6.

<HR SIZE=3><H2 ID="Linking_with_C_Libraries">Linking with C Libraries</H2>
In the C routines used so far only C keywords have been used, but no library
routines. If, for example, you wanted to use a printf in one of the C routines,
you would have to link the appropriate routine from the libraries.

This can be done by extending the <A HREF="#GFA-Basic">GFA-Basic</A> compiler's library. The following
small program enables you to integrate the Turbo C libraries into the <A HREF="#GFA-Basic">GFA-Basic</A>
compiler's library. Your C routines can then contain all the C instructions
from the libraries. The program reads likes this:

    <A HREF="#OPEN">OPEN</A> "O",#2,"NEW_LIB"
    <A HREF="#OPEN">OPEN</A> "I",#1,"GFA3BLIB"
    l%<A HREF="#=">=</A><A HREF="#LOF">LOF</A>(#1)
    <A HREF="#WHILE">WHILE</A> l%<A HREF="#&">&</A>#62;32000
      <A HREF="#PRINT">PRINT</A> #2,<A HREF="#INPUT$">INPUT$</A>(32000,#1)<A HREF="#;">;</A>
      <A HREF="#SUB">SUB</A> l%,32000
    <A HREF="#WEND">WEND</A>
    <A HREF="#PRINT">PRINT</A> #2,<A HREF="#INPUT$">INPUT$</A>(l%,#1)<A HREF="#;">;</A>
    <A HREF="#CLOSE">CLOSE</A> #1
    @append("TCSTDLIB.LIB")
    @append("TCEXTLIB.LIB")
    @append("TCGEMLIB.LIB")
    @append("TCTOSLIB.LIB")
    @append("TCFLTLIB.LIB")
    <A HREF="#CLOSE">CLOSE</A> #2
    <A HREF="#'">'</A>
    <A HREF="#PROCEDURE">PROCEDURE</A> append(lib$)
      <A HREF="#RELSEEK">RELSEEK</A> #2,-2
      <A HREF="#OPEN">OPEN</A> "I",#1,lib$
      l%<A HREF="#=">=</A><A HREF="#LOF">LOF</A>(#1)-2
      <A HREF="#SEEK">SEEK</A> #1,2
      <A HREF="#WHILE">WHILE</A> l%<A HREF="#&">&</A>#62;32000
        <A HREF="#PRINT">PRINT</A> #2,<A HREF="#INPUT$">INPUT$</A>(32000,#1)<A HREF="#;">;</A>
        <A HREF="#SUB">SUB</A> l%,32000
      <A HREF="#WEND">WEND</A>
      <A HREF="#PRINT">PRINT</A> #2,<A HREF="#INPUT$">INPUT$</A>(l%,#1)<A HREF="#;">;</A>
      <A HREF="#CLOSE">CLOSE</A> #1
    <A HREF="#RETURN">RETURN</A>

To use this program, you may have to change the path name of the files. To use
the new library, you will require the appropriate <A HREF="#index">index</A> files (NDX files),
which can be generated with the library manager of the GFA-Assembler, for
instance, or similar programs (DOINDEX)<A HREF="#.">.</A>

As soon as both files are created, you can use all instructions from the Turbo
C libraries in the C routines to be linked. You simply need to tell the GFA
BASIC linker that you wish to use the new library and not GFA3BLIB. This is
done with the +lib_name linker option if you are using a DOS shell (in our
example, +NEW_LIB)<A HREF="#.">.</A>

The linker may, under certain circumstances, report back that it does not
recognise the variable errno. C compilers do not take this from the libraries
as it is part of the startup code.

One precondition for the trouble-free use of the new library is that the Turbo
C and the GFA3BLIB libraries do not contain any functions which exist under the
same name in both libraries. We do not know of any such function in the present
version of Turbo C.

<HR SIZE=3><H2 ID="Some_Peculiarities">Some Peculiarities</H2>
In larger programs it is generally necessary to avoid using PC-related calls.
In Turbo C, this can be avoided with the -P compiler option.

The C routines must not alter the registers A3 to A6, or expect particular
values from them. Turbo C and <A HREF="#DR">DR</A> C conform with this requirement, but Megamax
C, for example, does not. C programs have about 4 kb available for the stack.

<B>Memo:</B> The following was taken from the amiga version of the manual:

You may require an assembler interface like:

name:    movem.l a3-a6,regsave
         jsr     c_name
         movem.l regsave,a3-a6
         rts

regsave: ds.l    4

You may then need to employ an extra dummy parameter in your C routine, to
mask the return address of 'jsr c_name'<A HREF="#.">.</A> For example:

name (long x, long y)
c_name(long dummy, long x, long y)

<HR SIZE=3><H2 ID="Linker_Error_Messages">Linker Error Messages</H2>
The GL linker outputs some brief error messages:

    ?xxxxxxxx  means unknown symbol xxxxxxxx
    +xxxxxxxx  means symbol redefinition
    <A HREF="#&">&</A>#62;xxxxxxxx  means 16 bit offset too large

<B>Memo:</B> The linker will only report a bad symbol if the procedure or
      function is actually called.
<HR SIZE=3><H2 ID="Programming_Accessories">Programming Accessories</H2>
<A NAME="The_Structure_of_Accessories"></A><A NAME="accessory"></A><A NAME="accessories"></A><B>The structure of <A HREF="#accessories">accessories</A></B>

An <A HREF="#accessory">accessory</A> is a program which is installed in RAM after power-on or a reset.
There it waits until it receives an instruction to become active. This
instruction is sent when the user has selected it, usually from the GEM Desktop
menu.

From this simple description you can figure out the rough structure of an
<A HREF="#accessory">accessory</A><A HREF="#.">.</A> First we said that an accessory had to be installed. To this end,
the programmer must declare the <A HREF="#accessory">accessory</A> as a GEM application and pass its
name to GEM so that it can be entered as an item in the first of the dropdown
menus.

Declaration as a GEM application is performed with the <A HREF="#APPL_INIT">APPL_INIT</A><A HREF="#()">()</A> function,
the return value of which is known as the applications ID.

The value returned by <A HREF="#APPL_INIT">APPL_INIT</A><A HREF="#()">()</A> can also be used to determine whether a
program was started as an <A HREF="#accessory">accessory</A> or as a normal program. If the return value
is 0, the program was not started as an <A HREF="#accessory">accessory</A>, but as a normal program. You
can thus write programs in <A HREF="#GFA-Basic">GFA-Basic</A> 3.0 which are executable both as normal
programs and as <A HREF="#accessories">accessories</A><A HREF="#.">.</A>

The applications ID number is also required for passing the <A HREF="#accessory">accessory</A> name.
This is done with <A HREF="#MENU_REGISTER">MENU_REGISTER</A>(ap_id,text$)<A HREF="#.">.</A>

<A HREF="#MENU_REGISTER">MENU_REGISTER</A><A HREF="#()">()</A> returns the <A HREF="#accessory">accessory</A> number of the current program (0 to 5)<A HREF="#.">.</A>
This value is called the menu identification number. A return value of -1 means
that 6 <A HREF="#accessories">accessories</A> have already been installed, the maximum for GEM, and
therefore there is no room for another one. The two parameters are the
application ID and the <A HREF="#accessory">accessory</A> name.

Now the <A HREF="#accessory">accessory</A> has been installed, the next step consists of waiting for it
to be called. An <A HREF="#accessory">accessory</A> must be programmed as an endless loop within which
the message buffer is scanned.

This scanning can be done, for instance, with the <A HREF="#EVNT_MESAG">EVNT_MESAG</A><A HREF="#()">()</A> function. If a 0
is passed to this function, it will write messages coming from GEM into
<A HREF="#GFA-Basic">GFA-Basic</A>'s own message buffer which can then be read using <A HREF="#MENU">MENU</A>(1) to MENU(8)<A HREF="#.">.</A>

The most important message type for an <A HREF="#accessory">accessory</A> is <A HREF="#MENU">MENU</A>(1)=40 (AC_OPEN)<A HREF="#.">.</A> This
message means that the user has selected an <A HREF="#accessory">accessory</A><A HREF="#.">.</A> If, however, the
<A HREF="#accessory">accessory</A> runs in a window, the other messages relating to the selection of
other elements and to the redraw are also of interest.

An <A HREF="#accessory">accessory</A> normally offers the user the option to remove it again from the
screen. In terms of the program's internal structure this means that the
<A HREF="#accessory">accessory</A> must return to the endless loop by means of the <A HREF="#EVNT_MESAG">EVNT_MESAG</A>(10)
instruction. There must be no <A HREF="#END">END</A> or a similar command in an <A HREF="#accessory">accessory</A> because
that would make the computer "hang"<A HREF="#.">.</A>

This description needs one further point to be added. <A HREF="#GFA-Basic">GFA-Basic</A> programs
attempt to claim all free memory space for themselves after they have been
started. You can, of course, release space again with <A HREF="#RESERVE">RESERVE</A>, but before the
<A HREF="#RESERVE">RESERVE</A> command is executed the initialisation routine of a compiled program
will already have performed the reservation of memory space.

To prevent this, a <A HREF="#GFA-Basic">GFA-Basic</A> <A HREF="#accessory">accessory</A> must include a line which tells the
compiler that the program to be generated must not claim all the free memory.
This is what the compiler option $mx does, with x being the number of bytes to
be claimed by the compiled program.

The screen area occupied by an <A HREF="#accessory">accessory</A> must be restored. This is called
redraw. If, for example, you are using dialog boxes, this redraw can be
performed from within your <A HREF="#accessory">accessory</A>, using <A HREF="#GET">GET</A> and <A HREF="#PUT">PUT</A> to read in the screen
area and then writing it back again.

<HR SIZE=3><H2 ID="Programming_Example">Programming Example</H2>
After this dry run we will now look at an example of an <A HREF="#accessory">accessory</A> program. A
particularly brief example:

    $m1000
    ap_id&<A HREF="#=">=</A><A HREF="#APPL_INIT">APPL_INIT</A><A HREF="#()">()</A>
    <A HREF="#IF">IF</A> ap_id&=0
      <A HREF="#ALERT">ALERT</A> 1,"I am not&#124;an <A HREF="#accessory">accessory</A> now.",1,"Return",a&
      <A HREF="#END">END</A>
    <A HREF="#ENDIF">ENDIF</A>
    me_id&<A HREF="#=">=</A><A HREF="#MENU_REGISTER">MENU_REGISTER</A>(ap_id&,"  Colour switch ")
    <A HREF="#DO">DO</A>
      <A HREF="#~">~</A><A HREF="#EVNT_MESAG">EVNT_MESAG</A>(0)
      <A HREF="#IF">IF</A> <A HREF="#MENU">MENU</A>(1)=40
        <A HREF="#ALERT">ALERT</A> 1,"Color switch",1,"bw&#124;wb",a&
        <A HREF="#SETCOLOR">SETCOLOR</A> 0,a&
      <A HREF="#ENDIF">ENDIF</A>
    <A HREF="#LOOP">LOOP</A>

In the first line, the program reserves for itself 1000 bytes of storage space.
Then it announces itself as a GEM application and obtains an application ID
which it puts into the variable ap_id&<A HREF="#.">.</A> If ap_id& equals 0, the program was not
started as an <A HREF="#accessory">accessory</A><A HREF="#.">.</A> It displays a message to this effect and terminates
itself.

The line with <A HREF="#MENU_REGISTER">MENU_REGISTER</A><A HREF="#()">()</A> passes the <A HREF="#accessory">accessory</A>'s name to GEM and obtains a
menu ID number me_id&<A HREF="#.">.</A> Then follows an endless loop scanning the message buffer
with <A HREF="#EVNT_MESAG">EVNT_MESAG</A><A HREF="#()">()</A><A HREF="#.">.</A>

When the <A HREF="#accessory">accessory</A> receives the message that it has been called (<A HREF="#MENU">MENU</A>(1)=40),
it activates itself. In this example, however, the action is rather minimal.
The <A HREF="#accessory">accessory</A> lets you invert the screen with <A HREF="#SETCOLOR">SETCOLOR</A> and then returns to its
endless Loop.

If more than one <A HREF="#accessory">accessory</A> exists, it will be necessary to determine which has
been selected. <A HREF="#MENU">MENU</A>(5) holds the ID of the selected <A HREF="#accessory">accessory</A>.

<HR SIZE=3><H2 ID="Longer_Programming_Examples">Longer Programming Examples</H2>
This section will introduce two examples of <A HREF="#accessory">accessory</A> programming. They do not
perform any meaningful activity but serve illustration purposes only. The first
example program generates a window with a randomly selected fill pattern as its
contents. It runs both as an <A HREF="#accessory">accessory</A> and as a program. The other example
appears as a dialog box with radio buttons, an edit field and buttons.

First to the window program: it first reserves 5120 bytes for itself and then
obtains its application ID. Then it checks if its ID is 0. A value of 0 would
mean that it had be started as a program and not as an <A HREF="#accessory">accessory</A><A HREF="#.">.</A>

If started as an <A HREF="#accessory">accessory</A>, it now enters its name into the menu. Then it
branches to an endless loop consisting of only two instructions. The first
being <A HREF="#EVNT_MESAG">EVNT_MESAG</A><A HREF="#()">()</A>, which waits for events. The 0 parameter ensures that
messages can be evaluated with the aid of <A HREF="#MENU">MENU</A>(1) to MENU(8)<A HREF="#.">.</A> The second
instruction calls the sub-procedure message which reacts to any messages
received.

If not started as an <A HREF="#accessory">accessory</A>, the program opens a window and defines a
routine for message evaluation. This routine is identical to the one performing
the task of message evaluation in the <A HREF="#accessory">accessory</A> version. The <A HREF="#REPEAT">REPEAT</A><A HREF="#-">-</A><A HREF="#UNTIL">UNTIL</A> loop
will now wait for events until the procedure message sets the variable exit! to
<A HREF="#TRUE">TRUE</A><A HREF="#.">.</A>

The procedure message is almost identical in structure to a normal window
management routine in a normal program. It first reads the coordinates of the
current window into the variables x&, y&, b&, and h&<A HREF="#.">.</A>

The <A HREF="#SELECT">SELECT</A><A HREF="#-">-</A><A HREF="#CASE">CASE</A> instruction branches according to the different possible
messages received by <A HREF="#MENU">MENU</A>(1)<A HREF="#.">.</A> The first such message is also the most
important: the redraw message.

As soon as this message is received, the <A HREF="#AES">AES</A> is informed about the imminent
screen redraw with <A HREF="#WIND_UPDATE">WIND_UPDATE</A>(1)<A HREF="#.">.</A> We now go through the rectangles list of the
window in which the redraws take place.

Each rectangle is drawn in a random fill pattern. Unless two adjacent
rectangles happen to be drawn in identical fill patterns by chance, you can
examine the way GEM manages the rectangles list. For redrawing the rectangles
it would, strictly speaking, be sufficient to draw the rectangle only in the
area affected by a clipping.

But the method followed is the same as in a conventional window program. The
clipping is imposed on the rectangle to be drawn and the entire working area of
the window is redrawn. In your own program, you would have to replace the <A HREF="#PBOX">PBOX</A>
command with a routine to draw the window contents.

The remaining messages can be dealt with by only a few instructions. In the
example, commands specific to GFA BASIC, such as <A HREF="#TOPW">TOPW</A>, <A HREF="#FULLW">FULLW</A> etc., are
generally used. At the WM_CLOSED message, in addition to <A HREF="#CLOSEW">CLOSEW</A>, the variable
exit! is set to <A HREF="#TRUE">TRUE</A><A HREF="#.">.</A> This is to cover the possibility of the program not
running as an <A HREF="#accessory">accessory</A><A HREF="#.">.</A>

This routine differs from a normal window management routine by its ability to
react to the message AC_OPEN. This message reports that the user has selected
the <A HREF="#accessory">accessory</A><A HREF="#.">.</A> As a result, the window is opened.

The areas over written by the <A HREF="#accessory">accessory</A> must be redrawn by the program from
which the <A HREF="#accessory">accessory</A> was called. The task of sending an appropriate redraw
message to that program is performed by GEM and need not be considered in this
listing.

$m5120
ap_id&<A HREF="#=">=</A><A HREF="#APPL_INIT">APPL_INIT</A><A HREF="#()">()</A>
<A HREF="#'">'</A>
<A HREF="#IF">IF</A> ap_id&<A HREF="#&#60;">&#60;</A>&#62;0
  me_id&<A HREF="#=">=</A><A HREF="#MENU_REGISTER">MENU_REGISTER</A>(ap_id&,"  Window-ACC ")
  <A HREF="#DO">DO</A>
    <A HREF="#~">~</A><A HREF="#EVNT_MESAG">EVNT_MESAG</A>(0)
    message
  <A HREF="#LOOP">LOOP</A>
<A HREF="#ELSE">ELSE</A>
  <A HREF="#TITLEW">TITLEW</A> #1,"Window-Program"
  <A HREF="#INFOW">INFOW</A> #1," in GFA-BASIC 3.0"
  <A HREF="#OPENW">OPENW</A> #1,50,50,200,100,&X111111
  handle&<A HREF="#=">=</A><A HREF="#W_HAND">W_HAND</A>(#1)
  <A HREF="#ON_MENU_MESSAGE">ON MENU MESSAGE</A> <A HREF="#GOSUB">GOSUB</A> message
  exit!<A HREF="#=">=</A><A HREF="#FALSE">FALSE</A>
  <A HREF="#REPEAT">REPEAT</A>
    <A HREF="#ON_MENU">ON MENU</A>
  <A HREF="#UNTIL">UNTIL</A> exit!
<A HREF="#ENDIF">ENDIF</A>
<A HREF="#'">'</A>
<A HREF="#PROCEDURE">PROCEDURE</A> message
  x&<A HREF="#=">=</A><A HREF="#MENU">MENU</A>(5)
  y&<A HREF="#=">=</A><A HREF="#MENU">MENU</A>(6)
  b&<A HREF="#=">=</A><A HREF="#MENU">MENU</A>(7)
  h&<A HREF="#=">=</A><A HREF="#MENU">MENU</A>(8)
  <A HREF="#'">'</A>
  <A HREF="#SELECT">SELECT</A> <A HREF="#MENU">MENU</A>(1)
  <A HREF="#CASE">CASE</A> 20 <A HREF="#!">!</A> <A HREF="#/*">/*</A><A HREF="#*">*</A>* WM_REDRAW ***<A HREF="#/">/</A>
    <A HREF="#~">~</A><A HREF="#WIND_UPDATE">WIND_UPDATE</A>(1)
    <A HREF="#~">~</A><A HREF="#WIND_GET">WIND_GET</A>(handle&,11,rx&,ry&,rb&,rh&) !First rectangle in the list
    <A HREF="#~">~</A><A HREF="#WIND_GET">WIND_GET</A>(handle&,4,ax&,ay&,ab&,ah&) !Working area in window
    <A HREF="#REPEAT">REPEAT</A>
      <A HREF="#IF">IF</A> <A HREF="#RC_INTERSECT">RC_INTERSECT</A>(ax&,ay&,ab&,ah&,rx&,ry&,rb&,rh&)
        <A HREF="#CLIP">CLIP</A> rx&,ry&,rb&,rh& <A HREF="#OFFSET">OFFSET</A> ax&,ay&
        <A HREF="#DEFFILL">DEFFILL</A> 1,2,<A HREF="#RAND">RAND</A>(25)
        <A HREF="#PBOX">PBOX</A> 0,0,<A HREF="#PRED">PRED</A>(ab&),PRED(ah&)
        <A HREF="#CLIP">CLIP</A> 0,0,<A HREF="#WORK_OUT">WORK_OUT</A>(0),WORK_OUT(1)
      <A HREF="#ENDIF">ENDIF</A>
      <A HREF="#~">~</A><A HREF="#WIND_GET">WIND_GET</A>(handle&,12,rx&,ry&,rb&,rh&) !Next rectangle in list
    <A HREF="#UNTIL">UNTIL</A> rb&=0 <A HREF="#AND">AND</A> rh&=0 !No more in list
    <A HREF="#~">~</A><A HREF="#WIND_UPDATE">WIND_UPDATE</A>(0)
  <A HREF="#CASE">CASE</A> 21 <A HREF="#!">!</A> <A HREF="#/*">/*</A><A HREF="#*">*</A>* WM_TOPPED ***<A HREF="#/">/</A>
    <A HREF="#TOPW">TOPW</A> #1
  <A HREF="#CASE">CASE</A> 22,41 <A HREF="#!">!</A> <A HREF="#/*">/*</A><A HREF="#*">*</A>* WM_CLOSED and AC_CLOSE ***<A HREF="#/">/</A>
    <A HREF="#CLOSEW">CLOSEW</A> #1
    exit!<A HREF="#=">=</A><A HREF="#TRUE">TRUE</A>
  <A HREF="#CASE">CASE</A> 23 <A HREF="#!">!</A> <A HREF="#/*">/*</A><A HREF="#*">*</A>* WM_FULLED ***<A HREF="#/">/</A>
    <A HREF="#FULLW">FULLW</A> #1
  <A HREF="#CASE">CASE</A> 27 <A HREF="#!">!</A> <A HREF="#/*">/*</A><A HREF="#*">*</A>* WM SIZED ***<A HREF="#/">/</A>
    <A HREF="#~">~</A><A HREF="#WIND_SET">WIND_SET</A>(handle&,5,x&,y&,<A HREF="#MAX">MAX</A>(180,b&),MAX(80,h&))
  <A HREF="#CASE">CASE</A> 28 <A HREF="#!">!</A> <A HREF="#/*">/*</A><A HREF="#*">*</A>* WM_MOVED ***<A HREF="#/">/</A>
    <A HREF="#~">~</A><A HREF="#WIND_SET">WIND_SET</A>(handle&,5,x&,y&,b&,h&)
  <A HREF="#CASE">CASE</A> 40 <A HREF="#!">!</A> <A HREF="#/*">/*</A><A HREF="#*">*</A>* AC_OPEN ***<A HREF="#/">/</A>
    <A HREF="#TITLEW">TITLEW</A> #1,"Window-Accessory"
    <A HREF="#INFOW">INFOW</A> #1," in GFA-BASlC 3.0"
    <A HREF="#OPENW">OPENW</A> #1,50,50,200,100,&X111111
    handle&<A HREF="#=">=</A><A HREF="#W_HAND">W_HAND</A>(#1)
  <A HREF="#ENDSELECT">ENDSELECT</A>
<A HREF="#RETURN">RETURN</A>

Now to the next sample program in which a dialog box is used. This program
reserves quite a lot of memory space for itself to begin with, almost 13kb.
This space is required primarily to save, with <A HREF="#GET">GET</A>, the screen area covered by
the dialog box.

In the window program, GEM sent out a redraw message when the <A HREF="#accessory">accessory</A> window
was closed. If the dialog boxes of an <A HREF="#accessory">accessory</A> are to disappear from the
screen and the old contents of the area restored, another method has to be
chosen.

One possibility is to trigger the redraw message for the screen area affected.
For this purpose, there exists the <A HREF="#FORM_DIAL">FORM_DIAL</A>(3,<A HREF="#.">.</A>..) routine. Another
possibility is illustrated by the program following. It is possible to read in
the screen area covered by the dialog box with <A HREF="#GET">GET</A>, and then to restore it
later with <A HREF="#PUT">PUT</A><A HREF="#.">.</A>

Using <A HREF="#FORM_DIAL">FORM_DIAL</A><A HREF="#()">()</A> requires less memory space. However, the program that is to
perform the redraw may need some time for this task. Using <A HREF="#GET">GET</A> and <A HREF="#PUT">PUT</A> is
considerably faster.

This program, by the way, also calls an alert box. The screen area covered is
automatically redrawn by GEM. GEM uses a similar method for this as the one
chosen in our program with <A HREF="#GET">GET</A> and <A HREF="#PUT">PUT</A><A HREF="#.">.</A> The area covered by the alert box,
therefore, does not have to be redrawn by the BASIC program since GEM will be
doing it.

After determining the application ID the program checks if it has been started
as an <A HREF="#accessory">accessory</A><A HREF="#.">.</A> If not, it wiil terminate itself. In contrast to the
previously discussed window demo, this demo will therefore run as an <A HREF="#accessory">accessory</A>
oniy.

Next the <A HREF="#accessory">accessory</A> attempts to load in its resource file. If it cannot find
this, it must not be terminated like a normal program because it wouid then get
into an endless loop with an EVNT instruction.

If the resource file has been found, the program assigns object numbers to the
dialog box variables. This part of the program consists of the LST file written
by the Resource Construction Set. Once this is done, the address of the dialog
box tree is obtained and a default text assigned to the editable field.

Only now is the <A HREF="#accessory">accessory</A> entered into the menu. In the following loop, it
waits to be called via (<A HREF="#MENU">MENU</A>(1)=40)<A HREF="#.">.</A> As soon as this call arrives, the
dimensions of the dialog box are calculated and the corresponding screen area,
with a additional safety margin, is saved. The dialog box can now be drawn and
managed with <A HREF="#FORM_DO">FORM_DO</A><A HREF="#()">()</A><A HREF="#.">.</A>

On quitting the dialog box, the exit object is reset to its previous state and
the screen area overwritten by the box restored with <A HREF="#PUT">PUT</A><A HREF="#.">.</A>

In the following lines, the information entered into the dialog box by the
user, is read and displayed in an alert box. Then the <A HREF="#accessory">accessory</A> returns to the
endless loop, where it awaits its next call.

$m12800
ap_id&<A HREF="#=">=</A><A HREF="#APPL_INIT">APPL_INIT</A><A HREF="#()">()</A>
<A HREF="#IF">IF</A> ap_id&=0
  <A HREF="#ALERT">ALERT</A> 1,"Program runs only&#124;as an <A HREF="#accessory">accessory</A>",1," Return ",a&#124;
  <A HREF="#END">END</A>
<A HREF="#ENDIF">ENDIF</A>
<A HREF="#'">'</A>
<A HREF="#IF">IF</A> <A HREF="#RSRC_LOAD">RSRC_LOAD</A>("dial_acc.rsc")=0
  <A HREF="#DO">DO</A> !If the RSC file cannot be found, then
    <A HREF="#~">~</A><A HREF="#EVNT_TIMER">EVNT_TIMER</A>(-1) !simply wait for as long as it takes
  <A HREF="#LOOP">LOOP</A> !because there is nothing to do
<A HREF="#ENDIF">ENDIF</A>
<A HREF="#'">'</A>
<A HREF="#'">'</A> Object numbers from the construction set
<A HREF="#LET">LET</A> dialog&=0 !RSC_TREE
<A HREF="#LET">LET</A> text&=8 !Obj in #0
<A HREF="#LET">LET</A> abbruch&=2 !Obj in #0
<A HREF="#LET">LET</A> return&=3 !Obj in #0
<A HREF="#LET">LET</A> radio1&=5 !Obj in #0
<A HREF="#LET">LET</A> radio2&=6 !Obj in #0
<A HREF="#LET">LET</A> radio3&=7 !Obj in #0
<A HREF="#'">'</A>
<A HREF="#~">~</A><A HREF="#RSRC_GADDR">RSRC_GADDR</A>(0,dialog&,dialog_adr%)
<A HREF="#CHAR">CHAR</A>{{OB-SPEC(dialog_adr%,text&)}}<A HREF="#=">=</A>"Testtext"
me_id&<A HREF="#=">=</A><A HREF="#MENU_REGISTER">MENU_REGISTER</A>(ap_id&,"  Dialog-ACC ")
<A HREF="#'">'</A>
<A HREF="#DO">DO</A>
  <A HREF="#~">~</A><A HREF="#EVNT_MESAG">EVNT_MESAG</A>(0)
  <A HREF="#IF">IF</A> <A HREF="#MENU">MENU</A>(1)=40
    <A HREF="#~">~</A><A HREF="#FORM_CENTER">FORM_CENTER</A>(dialog_adr%,x&,y&,b&,h&)
    <A HREF="#~">~</A><A HREF="#WIND_UPDATE">WIND_UPDATE</A>(1)
    <A HREF="#GET">GET</A> x&-4,y&-4,x&+b&+4,y&+b&+4,rette$ !For Redraw.
    <A HREF="#~">~</A><A HREF="#OBJC_DRAW">OBJC_DRAW</A>(dialog_adr%,0,3,x&,y&,b&,h&)
    ex&<A HREF="#=">=</A><A HREF="#FORM_DO">FORM_DO</A>(dialog_adr%,0)
    <A HREF="#~">~</A><A HREF="#OBJC_CHANGE">OBJC_CHANGE</A>(dialog_adr%,ex&,0,x&,y&,b&,h&,0,0)
    <A HREF="#PUT">PUT</A> x&-4,y&-4,rette$ !Redraw.
    <A HREF="#~">~</A><A HREF="#WIND_UPDATE">WIND_UPDATE</A>(0)
    t$<A HREF="#=">=</A><A HREF="#CHAR">CHAR</A>{{<A HREF="#OB_SPEC">OB_SPEC</A>(dialog_adr%,text&)}}
    <A HREF="#IF">IF</A> <A HREF="#BTST">BTST</A>(<A HREF="#OB_STATE">OB_STATE</A>(dialog_adr%,radio1&),0)
      r$<A HREF="#=">=</A>"1"
    <A HREF="#ELSE_IF">ELSE IF</A> <A HREF="#BTST">BTST</A>(<A HREF="#OB_STATE">OB_STATE</A>(dialog_adr%,radio2&),0)
      r$<A HREF="#=">=</A>"2"
    <A HREF="#ELSE_IF">ELSE IF</A> <A HREF="#BTST">BTST</A>(<A HREF="#OB_STATE">OB_STATE</A>(dialog_adr%,radio3&),0)
      r$<A HREF="#=">=</A>"3"
    <A HREF="#ENDIF">ENDIF</A>
    a$<A HREF="#=">=</A>"Text: "+t$+"<A HREF="#&">&</A>#124;Radio_Button: "+r$+"&#124;Exit-Button: "+<A HREF="#STR$">STR$</A>(ex&)
    <A HREF="#ALERT">ALERT</A> 1,a$,1," Ok ",a&#124;
  <A HREF="#ENDIF">ENDIF</A>
<A HREF="#LOOP">LOOP</A>
<HR SIZE=3><H2 ID="Program_Optimization">Program Optimization</H2>
The <A HREF="#GFA-Basic">GFA-Basic</A> 3.0 compiler generates assembler code. You can support it in this
task by appropriate programming. In this chapter we shall consider, the
question of what a GFA BASIC program should look like in order to make the
resulting compiled program as fast and short as possible. To achieve this, you
have to know how the compiler goes about its optimization.

This chapter contains some assembler listings representing compiler generated
code. If you wish to disassemble programs generated by the compiler yourself,
you should let the linker append the symbol table to the code. The compiled
program always begins with the lines:

STARTADR:  lea.l  STARTADR-256(pc),a0
           lea.l  $100(a0),a7
           jsr    INIT

These three lines are followed by the code in the first lines of your BASIC
program. The end of this code is marked by the label BaseA4. When linking with
the symbol table enabled, the names of procedures and functions are inserted as
symbols (underline character plus name)<A HREF="#.">.</A>

You will be able to benefit from this chapter even if you have no knowledge of
assembler, by taking note of the advice derived from the listings <A HREF="#-">-</A> although
you may not, in this case, understand why a certain program formulation is more
efficient than another one.

The knowledge of assembler required to understand the disassembled listings has
been kept to a minimum. This chapter is aimed at <A HREF="#GFA-Basic">GFA-Basic</A> programmers wishing
to familiarise themselves with assembler in order to, for example, write
speed-critical subroutines in that language.

We cannot, of course, discuss all the instructions understood by the compiler,
but can only pick out a few examples of particular importance from the point of
view of optimization.

<HR SIZE=3><H2 ID="Simple_Additions">Simple Additions</H2>
The Atari ST's processor, the Motorola 68000, has instructions to process
integer numbers. BASIC lines which simply carry out arithmetic operations on
integer variables can be translated into a few assembler instructions as long
as these lines are not too complex.

Operations on floating point variables require far more assembler instructions,
and this is reflected in the processing time taken. Adding two integer values
to each other is about five to six times faster than the addition of two
floating point values.

The first question to be discussed here is: When does the compiler use the
faster integer arithmetic and when does use floating point arithmetic?

The statements a%=b%+c% and a%=<A HREF="#ADD">ADD</A>(b%,c%) are processed by the interpreter at
different speeds. The compiler, however, simply generates the same code from
both:

    move.l  <A HREF="#-">-</A>$7ff8(a5),d0
    add.l   <A HREF="#-">-</A>$7ffc(a5),d0
    move.l  d0,<A HREF="#-">-</A>$8000(a5)

The addresses <A HREF="#-">-</A>$xxxx(a5) depend on which variables are used in the program.
The variables can be found from <A HREF="#-">-</A>$8000(a5) onwards.

If you have used two-byte variables, for instance a&=b&+c&, the compiler will
generate the following instructions:

    move.w  <A HREF="#-">-</A>$7ffc(a5),d0
    add.w   <A HREF="#-">-</A>$7ffe(a5),d0
    move.w  d0,<A HREF="#-">-</A>$8000(a5)

With one-byte variables (a&#124;=b&#124;+x&#124;) you get:

    moveq.l <A HREF="##">#</A>$0,d0
    move.b  <A HREF="#-">-</A>$7ffe(a5),d0
    move.b  <A HREF="#-">-</A>$7fff(a5),d1
    add.l   d1,d0
    move.b  d0,<A HREF="#-">-</A>$8000(a5)

However, a program line such as a=b+c uses floating-point variables. To perform
a floating point addition, the compiler program will contain an appropriate
subroutine. In the disassembled listing of a program with a symbol table you
find:

    lea.l   <A HREF="#-">-</A>$7ff0(a5),a0
    lea.l   <A HREF="#-">-</A>$7ff8(a5),a1
    bsr     VVFADD
    lea.l   <A HREF="#-">-</A>$8000(a5),a0
    move.l  d0,(a0)<A HREF="#+">+</A>
    move.w  d1,(a0)<A HREF="#+">+</A>
    move.w  d2,(a0)<A HREF="#+">+</A>

This listing contains the line bsr VVFADD. This line branches to the floating
point addition routine, which is processed far more slowly than the
instructions generated by, for example, a%=b%+c%<A HREF="#.">.</A>

The code produced by two-byte additions can be processed most quickly by the
computer. The next fastest is the one-byte addition code, then the four-byte
addition and finally, a long way behind, the floating point addition code.

The following table gives some examples for the different timings for the
different variable types in a simple addition in both the interpreter and the
compiler. A loop with 5000 runs was used, with the time taken by the loop
commands eliminated.

    <B>Type   Interpreter  Compiler  Statement</B>
    Byte   11.715       0.31      a&#124;=b&#124;+c&#124;
    Word   11.715       0.255     a&=b&+c&
    Long   11.355       0.335     a%=b%+c%
    Float  6.23         1.925     a=b+c

Similar timings apply to subtraction.

<HR SIZE=3><H2 ID="Multiplication">Multiplication</H2>
The optimization used by the compiler with multiplication contains a special
feature. The Atari ST's processor does have multiplication instructions, but it
requires a large number of tact cycles for their execution and only knows these
instructions for two-byte values. Therefore the <A HREF="#GFA-Basic">GFA-Basic</A> 3.0 compiler has to
coordinate the multiplication of a constant with a four-byte variable while
avoiding the use of the assembler instructions mulu and muls.

The line

    x%=y%*4

for example, can be simply translated into the code:

    move.l  <A HREF="#-">-</A>$8000(a5),d0
    lsl.l   <A HREF="##">#</A>$2,d0
    move.l  d0,<A HREF="#-">-</A>$7ffc(a5)

since 4 is the square of 2. Coding the statement:

    x%=y%*21

is somewhat more involved, since 21 equals binary 10101. To be able to better
understand the code generated by the compiler, let us assume in the comments
that y%=100. The code generated is:

    move.l  <A HREF="#-">-</A>$8000(a5),d0  ;y%, that is 100, into register d0
    move.l  d0,d2          ;copy of y% into register d2
    lsl.l   <A HREF="##">#</A>$2,d0         ;d0 times 4, d0 contains 400, d2=100
    add.l   d0,d2          ;add 400 to 100, therefore d0=400,
                           ;d2=500
    lsl.l   <A HREF="##">#</A>$2,d0         ;d0 times 4, therefore d0=1600,
                           ;d2=500
    add.l   d2,d0          ;add d2 to d0: d0=2100, d2=500
    move.l  d0,<A HREF="#-">-</A>$7ffc(a5)  ;writes result 2100 to x%

This code uses an extra 6 bytes of memory compared to a muls <A HREF="##">#</A>$15,d0 (which,
however, does not exist for four-byte values), but is faster with 52 tact
cycles execution time (without the first and the last move instruction)<A HREF="#.">.</A>

By contrast, the statement

    x&=y&*21

was coded using muls. In the case of 100,000 multiplications with 21,
therefore, the four-byte variables statement is a little faster:

    <B>Statement  Time</B>
    x%=y%*21   0.975
    x&=y&*21   1.08

However, if the multiplication is not with 21 but with values whose translation
into the assembler statements add, sub, lsl and asl requires relatively lengthy
code, the four-bytes variant not only generates considerably more code, but
also executes more slowly than the two-bytes statement working with muls. For
example, multiplying with 21845 (binary 101010101010101) instead of 21, the
execution times for 100,000 repeats are:

    <B>Statement    Time</B>
    x%=y%*21845  2.26
    x&=y&*21845  1.34

So far we have only looked at multiplications of one variable with one
constant. When multiplying two integer variables, however, the fact that the
mul statement only processes two-bytes values is also of great importance.

The following list shows the code generated by different integer
multiplications and their execution times for 25000 multiplications.

    move.l  <A HREF="#-">-</A>$7ff4(a5),d0  ;x%=y%*z%, 7.685
    move.l  <A HREF="#-">-</A>$7ff8(a5),d1
    bsr     LMUL
    move.l  d0,<A HREF="#-">-</A>$7ffc(a5)
    move.w  <A HREF="#-">-</A>$7ff0(a5),d0  ;x%=y%*z&, 6.165
    ext.l   d0
    move.l  <A HREF="#-">-</A>$7ff8(a5),d1
    bsr     LMUL
    move.l  d0,<A HREF="#-">-</A>$7ffc(a5)
    move.w  <A HREF="#-">-</A>$7ff0(a5),d0  ;x%=y&*z&, 2.44
    muls    <A HREF="#-">-</A>$7fee(a5),d0
    move.l  d0,<A HREF="#-">-</A>$7ffc(a5)
    move.w  <A HREF="#-">-</A>$7ff0(a5),d0  ;x&=y&*z&, 2.315
    muls    <A HREF="#-">-</A>$7fee(a5),d0
    move.w  d0,<A HREF="#-">-</A>$7fec(a5)

The great speed differences between the first and the last two stems from the
fact that in the last two examples, muls could be used instead of the LMUL
routine. The absolute timings also depend on the values found in y%, z%, y&,
and z&<A HREF="#.">.</A> The relative speeds between the different statements, however, remain
broadly the same.

In these two cases, where a four-bytes variable is involved, the <A HREF="#$*&">$*&</A> compiler
option can also force a use of muls. It has to be remembered, however, that
only two bytes of the four-byte values processed enter into the calculation. A
more detailed description can be found in the chapter on compiler options
(integer multiplication)<A HREF="#.">.</A>

The small differences between the two LMUL and the two muls examples stem from
the move.w versus move.l and the ext.l instructions only. When multiplying
integer variables, it is therefore worthwhile using two-byte instead of
four-byte variables.

<HR SIZE=3><H2 ID="Division">Division</H2>
Divisions of integer variables can produce decimal points, for instance x%=5,
y%=2, x%/y%=2.5. In contrast to multiplication, the compiler would therefore
have to perform division generally as floating point division. This is indeed
what it does, as long as the programmer does not expressly tell it to perform
the division of two integer variables as an integer division with an integer
result.

You can do this by using the compiler option <A HREF="#$%3">$%3</A>, (the complement <A HREF="#$%0">$%0</A> option),
which causes every division to be performed as a floating point division, is
the default. You can see the difference by analysing the code produced by the
line

    x=y%/z%

Using the default <A HREF="#$%0">$%0</A> option, this produces:

    move.l  <A HREF="#-">-</A>$7ff8(a5),d0
    bsr     FITOF
    move.l  d0,<A HREF="#-">-</A>(a7)
    move.w  d2,<A HREF="#-">-</A>(a7)
    move.w  d1,<A HREF="#-">-</A>(a7)
    move.l  <A HREF="#-">-</A>$7ff4(a5),d0
    bsr     FITOF
    move.w  (a7)<A HREF="#+">+</A>,d4
    move.w  (a7)<A HREF="#+">+</A>,d5
    move.l  (a7)<A HREF="#+">+</A>,d3
    bsr     FXDIV
    lea.l   <A HREF="#-">-</A>$8000(a5),a0
    move.l  d0,(a0)<A HREF="#+">+</A>
    move.w  d1,(a0)<A HREF="#+">+</A>
    move.w  d2,(a0)<A HREF="#+">+</A>

You can see that the two variables to be divided are transformed into floating
point variables using the FITOF (integer to float) routine. The routine for the
division of two floating point values is called (FXDIV) and the result assigned
to the variable x from <A HREF="#-">-</A>$8000(a5)<A HREF="#.">.</A>

If the same line is compiled using the <A HREF="#$%3">$%3</A> option, the following code results:

    move.l  <A HREF="#-">-</A>$7ffc(a5),d0
    move.l  <A HREF="#-">-</A>$7ff8(a5),d1
    bsr     LDIV
    lea.l   <A HREF="#-">-</A>$8000(a5),a0
    bsr     ISTOF

The ISTOF routine performs the assignment to x. Here the LDIV routine for the
division of two long-integer variables is called. If the two values are such
that decimal places are the result of the division, LDIV will not, of course,
return these.

If the line were to read x%=y%/z% instead of, as is the case here, x=y%/z%,
this would be of no consequence as the result would be returned to an integer
variable. In such a case, the GFA BASIC compiler automatically uses LDIV for
the division, even with <A HREF="#$%0">$%0</A> enabled.

If two two-byte variables are to be divided, the Motorola 68000 processor's div
instruction can be used, which is of course faster than the LDIV routine. The
code, in this case, is particularly simple and fast.

The line

    x&=y&/z&

produces:

    move.w  <A HREF="#-">-</A>$7ffe(a5),d0
    ext.l   d0
    divs    <A HREF="#-">-</A>$7ffc(a5),d0
    move.w  d0,<A HREF="#-">-</A>$8000(a5)

The conclusion: If at all possible, use two-byte variables for a division and
enable the <A HREF="#$%3">$%3</A> option if you are sure that no integer variables which would
produce significant decimal places are being processed.

When dividing by constants, the optimization carried out are similar to those
with multiplications. For example, the division by a value to the power of two
is converted into bit-shift instructions.

<HR SIZE=3><H2 ID="More_Complicated_Calculations">More Complicated Calculations</H2>
So far we have only considered arithmetic operations on two variables. Now we
must look at operations involving more than two variables. The compiler can
only translate such operations into code which does not contain branches to
subroutines up to a certain level of complexity. The following example will
illustrate this.

To execute the program line

    x&=x&<A HREF="#+">+</A>(y&*y&-y&)/y&+z&

fifty thousand times, a compiled program (without the loop commands) requires
about 2.56 seconds. But this line can also be broken up into

    x&=x&<A HREF="#+">+</A>(y&*y&-y&)/y&
    x&=x&+z&

These two lines perform the same task, from the point of view of the result, as
the first statement. However, the compiled program requires only about 1.875
seconds for the execution of these lines. The rule that can be derived from
this is: Break up lines containing more complicated integer calculations into
several lines.

To understand why the two-line variant executes faster than its one-line
equivalent, we must analyze the corresponding section from the (symbolically)
disassembled program.

The line

    x&=x&<A HREF="#+">+</A>(y&*y&-y&)/y&+z&

is translated into

    move.w   <A HREF="#-">-</A>$7ffe(a5),d0
    muls     <A HREF="#-">-</A>$7ffe(a5),d0  ;y&*y&
    movea.w  <A HREF="#-">-</A>$7ffe(a5),a0
    sub.l    a0,d0          <A HREF="#;">;</A>-y&
    move.w   <A HREF="#-">-</A>$7ffe(a5),d1
    ext.l    d1
    bsr      LDIV           ;/y&
    movea.w  <A HREF="#-">-</A>$8000(a5),a0
    add.l    a0,d0          <A HREF="#;">;</A>+x&
    add.w    <A HREF="#-">-</A>$7ffc(a5),d0  <A HREF="#;">;</A>+z&
    move.w   d0,<A HREF="#-">-</A>$8000(a5)

The addresses of the variables once again depend on the order of their
introduction into the program. Here, for example, the variable x& was
introduced first, y& second, and z& third. Thus their addresses are

    x&  <A HREF="#-">-</A>$8000(a5)
    y&  <A HREF="#-">-</A>$7ffe(a5)
    z&  <A HREF="#-">-</A>$7ffc(a5)

In the listing you will find the line bsr LDIV, calling a subroutine for the
division of two integer values. If you now compare this listing with the
two-line version, you will find that the latter contains no subroutine call.
The statements

    x&=x&<A HREF="#+">+</A>(y&*y&-y&)/y&
    x&=x&+z&

produces the code:

    move.w   <A HREF="#-">-</A>$7ffe(a5),d0
    muls     <A HREF="#-">-</A>$7ffe(a5),d0  ;y&*y&
    movea.w  <A HREF="#-">-</A>$7ffe(a5),a0
    sub.l    a0,d0          <A HREF="#;">;</A>-y&
    move.w   <A HREF="#-">-</A>$7ffe(a5),d1
    divs     d1,d0          ;/y&
    add.w    d0,<A HREF="#-">-</A>$8000(a5)  ;End of first line
    move.w   <A HREF="#-">-</A>$7ffc(a5),d0
    add.w    d0,<A HREF="#-">-</A>$8000(a5)  <A HREF="#;">;</A>+z&

As you can see, this listing is a few instructions shorter than the previous
one and contains no subroutine calls using bsr (branch subroutine)<A HREF="#.">.</A> The code
will become even more efficient, by the way, if you use reverse Polish notation
with <A HREF="#ADD">ADD</A> x&,<A HREF="#.">.</A>.. instead of x&=x&<A HREF="#+">+</A>...  In the interpreter, the one-line variant
is faster than the two lines. But if you wish to tailor your programs to the
compiler, you should present it with relatively short integer arithmetic
statements only, which it will best be able to code into assembler
instructions.

Brackets are often inserted into calculations for reasons of clarity, although
strictly speaking they are superfluous. Thus instead of

    x&=x&<A HREF="#+">+</A>(y&*y&-y&)/y&

you could use the line

    x&=x&<A HREF="#+">+</A>((y&*y&)-y&)/y&

We are not concerned here with the clarity of the example. You will find that
in the interpreter, the version with the additionai pair of brackets is slower.
In the compiled program, however, both versions are equally fast since the same
code is generated from them.

So if you want to insert brackets to improve intelligibility, you can do this
without a speed penalty in the compiled program as long as the brackets have no
influence on the result of the calculation.

<HR SIZE=3><H2 ID="Loop_Commands">Loop Commands</H2>
The best-known program optimization in <A HREF="#GFA-Basic">GFA-Basic</A> 2.0 was that the <A HREF="#FOR">FOR</A>-<A HREF="#NEXT">NEXT</A> loop
in the 2.0 interpreter and the <A HREF="#REPEAT">REPEAT</A><A HREF="#-">-</A><A HREF="#UNTIL">UNTIL</A> loop in the 2.0 compiler were the
fastest. It is different with the compiler for <A HREF="#GFA-Basic">GFA-Basic</A> 3.0.

If an empty loop is run 5000 times through the three loop types <A HREF="#FOR">FOR</A><A HREF="#-">-</A><A HREF="#NEXT">NEXT</A>,
<A HREF="#REPEAT">REPEAT</A><A HREF="#-">-</A><A HREF="#UNTIL">UNTIL</A> and <A HREF="#WHILE">WHILE</A>-<A HREF="#WEND">WEND</A>, the following timings are obtained with a
four-byte variable:

                  <B><A HREF="#FOR">FOR</A><A HREF="#-">-</A><A HREF="#NEXT">NEXT</A>  <A HREF="#REPEAT">REPEAT</A>-<A HREF="#UNTIL">UNTIL</A>  <A HREF="#WHILE">WHILE</A>-<A HREF="#WEND">WEND</A></B>
    <B>Interpreter</B>   3.76      14.765        16.42
    <B>Compiler</B>      0.77      0.77          0.77

The <A HREF="#DO">DO</A><A HREF="#-">-</A><A HREF="#LOOP">LOOP</A> loop with EXlT <A HREF="#IF">IF</A> and the derivatives of DO-LOOP, such as DO-LOOP
<A HREF="#UNTIL">UNTIL</A>, will not be considered here, other than observing that the <A HREF="#DO">DO</A><A HREF="#-">-</A><A HREF="#LOOP">LOOP</A> loop
with EXlT <A HREF="#IF">IF</A> is slower in the compiler (0.875).

As can be seen from the table, the three loop types are all equally fast in the
compiled program. Thus it is no longer sensible to "adapt" a program to the
compiler by altering all loops to <A HREF="#REPEAT">REPEAT</A><A HREF="#-">-</A><A HREF="#UNTIL">UNTIL</A> loops.

The equal execution times may suggest that the code generated by the three
loops must be very similar. This is correct, as the disassembled listings of
the three loop types will now show. We have inserted the statement b%=10 into
each loop in order to make the position of the loop contents recognisable in
the code.

The <A HREF="#FOR">FOR</A><A HREF="#-">-</A><A HREF="#NEXT">NEXT</A> loop

    <A HREF="#FOR">FOR</A> i%=1 TO 10000
      b%=10
    <A HREF="#NEXT">NEXT</A> i%

generates the following listing (the jump addresses and the variable addresses
are again only examples)<A HREF="#:">:</A>

    moveq.l  <A HREF="##">#</A>$1,d0             ;Loop starts at 1
    move.l   d0,<A HREF="#-">-</A>$7ff8(a5)      ;Assign start value to i%
L1: moveq.l  <A HREF="##">#</A>$a,d0             ;Assign the value of 10
    move.l   d0,<A HREF="#-">-</A>$8000(a5)      ;to the variable b%
    addq.l   <A HREF="##">#</A>$1,<A HREF="#-">-</A>$7ff8(a5)     ;Increment i% by 1
    cmpi.l   <A HREF="##">#</A>$2710,<A HREF="#-">-</A>$7ff8(a5)  ;End of loop reached?
    ble.s    L1                 ;If not, go back

The first two instructions define the loop start value i%<A HREF="#.">.</A> Then follows the
loop contents, here from label L1 in which the value of 10 is assigned to the
variable b% using two instructions.

After that, the variable i% is incremented by 1 and this is followed by
checking whether the loop end value has been reached. The end value was 10000,
that is hex $2710. If the loop counter variable is still smaller than or equal
to this value, the loop must be executed again.

If the end value of a loop is defined not by a constant but by, for instance, a
variable, it will of course have a different structure, as will a loop using
<A HREF="#STEP">STEP</A><A HREF="#.">.</A>

Since the addq follows after the loop contents and the exit condition is tested
only after that, i% will equal 10001 on completion of the loop. It is a
convention in the BASlC language that the counter variable of a <A HREF="#FOR">FOR</A><A HREF="#-">-</A><A HREF="#NEXT">NEXT</A> loop
is greater than the loop's end value on exit from the loop. This is because the
exit condition of the loop has been met if the counter is greater than the end
value.

However, when translating your programs into other BASIC dialects or other
languages, you should not rely on this BASIC convention being adhered to.

Now to the <A HREF="#REPEAT">REPEAT</A><A HREF="#-">-</A><A HREF="#UNTIL">UNTIL</A> loop. The BASIC lines

    i%=0
    <A HREF="#REPEAT">REPEAT</A>
      <A HREF="#INC">INC</A> i%
      b%=10
    <A HREF="#UNTIL">UNTIL</A> i%=10000

translate into the following assembler instructions:

    clr.l    <A HREF="#-">-</A>$7ff8(a5)         ;i%=0.
L1: addq.l   <A HREF="##">#</A>$1,<A HREF="#-">-</A>$7ff8(a5)     ;Increment i% by 1
    moveq.l  <A HREF="##">#</A>$a,d0             ;Set b% to the
    move.l   d0,<A HREF="#-">-</A>$8000(a5)      ;value of 10
    cmpi.l   <A HREF="##">#</A>$2710,<A HREF="#-">-</A>$7ff8(a5)  ;Compare 10000 with i%
    bne.s    L1                 ;If i% not equal 10000

In this listing, the instruction clr.l is only executed once, all other
instructions several times. In the listing of the <A HREF="#FOR">FOR</A><A HREF="#-">-</A><A HREF="#NEXT">NEXT</A> loop, the same
instructions are executed several times as in the <A HREF="#REPEAT">REPEAT</A><A HREF="#-">-</A><A HREF="#UNTIL">UNTIL</A> loop: an addq,
a moveq, a cmpi and a branch instruction with a logical condition.

The same execution times for the <A HREF="#FOR">FOR</A><A HREF="#-">-</A><A HREF="#NEXT">NEXT</A> and the <A HREF="#REPEAT">REPEAT</A>-<A HREF="#UNTIL">UNTIL</A> loops thus
become understandable. In the <A HREF="#WHILE">WHILE</A><A HREF="#-">-</A><A HREF="#WEND">WEND</A> loop it is also the same instructions
which are executed several times. The lines

    i%=0
    <A HREF="#WHILE">WHILE</A> i%<A HREF="#&">&</A>#60;10000
      <A HREF="#INC">INC</A> i%
      b%=10
    <A HREF="#WEND">WEND</A>

compile into the assembler code:

    clr.l    <A HREF="#-">-</A>$7ff8(a5)         ;i%=0
    bra.s    L2                 ;Jump to cmpi
L1: addq.l   <A HREF="##">#</A>$1,<A HREF="#-">-</A>$7ff8(a5)     <A HREF="#;">;</A><A HREF="#INC">INC</A> i%
    moveq.l  <A HREF="##">#</A>$a,d0             ;set b% to the
    move.l   d0,<A HREF="#-">-</A>$8000(a5)      ;value of 10
L2: cmpi.l   <A HREF="##">#</A>$2710,<A HREF="#-">-</A>$7ff8(a5)  ;Compare 10000 with i%
    blt.s    L1                 ;If i% smaller, go back

The compilation of the <A HREF="#WHILE">WHILE</A><A HREF="#-">-</A><A HREF="#WEND">WEND</A> loop into assembler differs from the
<A HREF="#REPEAT">REPEAT</A><A HREF="#-">-</A><A HREF="#UNTIL">UNTIL</A> loop in two respects.

1. The logical condition has been formulated differently, in the <A HREF="#REPEAT">REPEAT</A><A HREF="#-">-</A><A HREF="#UNTIL">UNTIL</A>
   loop it is an exit condition and in the <A HREF="#WHILE">WHILE</A><A HREF="#-">-</A><A HREF="#WEND">WEND</A> loop it is a
   "continuation condition"<A HREF="#.">.</A>

2. The <A HREF="#WHILE">WHILE</A><A HREF="#-">-</A><A HREF="#WEND">WEND</A> loop is a descending loop. Its condition is therefore tested
   before the first execution of the loop interior. For this reason, the
   assembler program first jumps to the loop condition test with a bra
   instruction.

In all other respects the implementation of the two loop types is identical.
The identical timings for all loop types enable you as the <A HREF="#GFA-Basic">GFA-Basic</A> programmer
to choose your loop types exclusively from the point of view of program
structure rather than having to choose a less well suited loop for reasons of
execution speed.

<HR SIZE=3><H2 ID="Character_Strings">Character Strings</H2>
In this section we are not discussing speed optimization but the shortening of
the program. If, in a <A HREF="#GFA-Basic">GFA-Basic</A> program, a string variable is assigned a
character string, as for instance a$<A HREF="#=">=</A>"Test", the compiler places this character
string into the <A HREF="#DATA">DATA</A> segment of the program generated.

The compiler attempts to keep the initialised strings section short. When a
character string is assigned to a string variable, the compiler will first
search the already existing character string section to see if the new string
is already present there. If this is the case, it will remember the string's
address.

Example: Suppose you want to translate a program into several languages and you
therefore place all text output into a procedure in the BASIC program in order
to simplify the translation. There you will now find the lines

    a$<A HREF="#=">=</A>"escape key"
    b$<A HREF="#=">=</A>"terminate the program"
    x$<A HREF="#=">=</A>"the escape key will terminate the program"

During symbolic linking, the DATASTAR symbol will be inserted into the DATA
segment of the program to mark the beginning of the string section. There our
three character strings can be found one immediately after the other.

You can change the order of the three lines to

    x$<A HREF="#=">=</A>"the escape key will terminate the program"
    a$<A HREF="#=">=</A>"escape key"
    b$<A HREF="#=">=</A>"terminate the program"

Now you will only find the string "the escape key will terminate the program"
after DATASTAR. The reason is this: First the compiler puts the long text line
into the <A HREF="#DATA">DATA</A> segment. Then it is asked to initialize a string containing the
text "escape key"<A HREF="#.">.</A>

To this end, it searched the <A HREF="#DATA">DATA</A> segment and found the text "escape key" as a
component of the long text line, noting its position in the <A HREF="#DATA">DATA</A> segment
without storing it again. The same happened with the text "terminate the
program"<A HREF="#.">.</A>

If the long line is listed as the last one of the three, as in the first
version, the compiler will only find fragments of this line in the <A HREF="#DATA">DATA</A> segment
when initialising the long line. In that event, it will store the complete
string.

With a character string which is also contained in another one, the longer
string must first be assigned to a variable to enable the compiler to optimize
the use of memory space.

Strings in <A HREF="#DATA">DATA</A> lines are, incidentally, placed after DATASTAR before all
strings assigned to a variable. The <A HREF="#DATA">DATA</A> segment itself begins with a table of
local variables (VARTAB)<A HREF="#.">.</A> Then follows the 48-bytes long TYPETAB, if TYPE or an
assignment using a pointer (e.g. *x=3 or <A HREF="#SWAP">SWAP</A> *x,x%<A HREF="#()">()</A>) have been used.

After VARTAB, or TYPETAB if required, there are the <A HREF="#INLINE">INLINE</A> areas. Only then
follows the DATASTAR symbol, behind which the contents of DATA lines and the
initialised strings can be found.

<HR SIZE=3><H2 ID="Local_and_Global_Variables">Local and Global Variables</H2>
In the 3.0 interpreter, operations involving local and global variables are
executed at the same speed. This is different with compiled programs. An empty
<A HREF="#FOR">FOR</A><A HREF="#-">-</A><A HREF="#NEXT">NEXT</A> loop with 50000 repeats and a four-byte counter variable requires
about 1.315 seconds in the compiler. This is irrespective of whether the
counter variable is a local or a global variable.

Once compiled, the loop with the local variable takes about 0.595 seconds,
while the loop with the global variable needs only about 0.385 seconds.

This speed ratio between local and global variables is different with some
other languages. In C for instance, as a general rule, routines with local
variables are faster than the same routines with global variables.

<HR SIZE=3><H2 ID="Technical_Support">Technical Support</H2>
Technical support is available to registered users of GFA products. Please
ensure that you complete the registration form and return it to GFA. We will
only provide support to registered users.

Due to the nature of problems associated with programming, it is requested that
all problems are notified in writing, rather than phone. A source code listing
should be provided to support the problem. If such a source code listing is
greater than 20 lines then please supply the source code on a disk (which will
be returned)<A HREF="#.">.</A>

GFA is always improving its products and is aiways interested in suggested
improvements. As a result updates will be available to registered users.


<A HREF="#Help">Help</A> and advice is also available from the independent <B>GFA USER
Magazine</B><A HREF="#.">.</A> The magazine is compiled by GFA users for GFA users. GFA USER
Magazine is available from:

    GFA User Magazine
    186 Holland Street
    Crewe
    Cheshire
    CW1 3SJ
    UK
<HR SIZE=3><H2 ID="Additional_Information">Additional Information</H2>
In some cases the compiler will optimize simple math.

In these examples the math/function becomes a single instruction:

GFA code     Assembler output
<A HREF="#-">-</A>---------   ---------------------
a&=32+1      move.w #33,-32768(a5)
a&=32-1      move.w #31,-32768(a5)
a&=32*2      move.w #64,-32768(a5)
a&=32/2      move.w #16,-32768(a5)
a&<A HREF="#=">=</A>(2*5)+1   move.w #11,-32768(a5)
a&<A HREF="#=">=</A><A HREF="#SUCC">SUCC</A>(32)  move.w #33,-32768(a5)
a&<A HREF="#=">=</A><A HREF="#PRED">PRED</A>(32)  move.w #31,-32768(a5)

The requirement seems to be that all operands must be numerical constants.
If you mix any variables into the equations it will not be able to optimize
it and it will break it down into multiple assembler instructions.

a&=32    !even though its some fixed value
b&=a&+1  !the compiler will not optimize this
<HR SIZE=3><H2 ID="_Index_">Index</H2>
<A NAME="index"></A>

<B>A</B>
<A HREF="#About_This_Manual">About This Manual</A>
<A HREF="#ABS">ABS</A>
<A HREF="#ABSOLUTE">ABSOLUTE</A>
<A HREF="#accessories">accessories</A>
<A HREF="#accessory">accessory</A>
<A HREF="#ACHAR">ACHAR</A>
<A HREF="#ACLIP">ACLIP</A>
<A HREF="#ACOS">ACOS</A>
<A HREF="#ADD">ADD</A>
<A HREF="#ADD()">ADD()</A>
<A HREF="#Additional_Information">Additional Information</A>
<A HREF="#ADDRIN">ADDRIN</A>
<A HREF="#ADDROUT">ADDROUT</A>
<A HREF="#AES">AES</A>
<A HREF="#AES_Library">AES Library</A>
<A HREF="#aexp">aexp</A>
<A HREF="#AFTER">AFTER</A>
<A HREF="#AFTER_CONT">AFTER CONT</A>
<A HREF="#AFTER_GOSUB">AFTER GOSUB</A>
<A HREF="#AFTER_STOP">AFTER STOP</A>
<A HREF="#ALERT">ALERT</A>
<A HREF="#ALINE">ALINE</A>
<A HREF="#AND">AND</A>
<A HREF="#AND()">AND()</A>
<A HREF="#Antic_Software">Antic Software</A>
<A HREF="#APOLY">APOLY</A>
<A HREF="#Appendix">Appendix</A>
<A HREF="#APPLBLK">APPLBLK</A>
<A HREF="#Application_Block_Structure_(APPLBLK)">Application Block Structure (APPLBLK)</A>
<A HREF="#Application_Services_Library">Application Services Library</A>
<A HREF="#appl_control">appl_control</A>
<A HREF="#APPL_EXIT">APPL_EXIT</A>
<A HREF="#APPL_FIND">APPL_FIND</A>
<A HREF="#appl_getinfo">appl_getinfo</A>
<A HREF="#APPL_INIT">APPL_INIT</A>
<A HREF="#APPL_READ">APPL_READ</A>
<A HREF="#appl_search">appl_search</A>
<A HREF="#APPL_TPLAY">APPL_TPLAY</A>
<A HREF="#APPL_TRECORD">APPL_TRECORD</A>
<A HREF="#APPL_WRITE">APPL_WRITE</A>
<A HREF="#appl_yield">appl_yield</A>
<A HREF="#ARECT">ARECT</A>
<A HREF="#Arithmetic_Operators">Arithmetic Operators</A>
<A HREF="#Array_Index_Checking">Array Index Checking</A>
<A HREF="#ARRAYFILL">ARRAYFILL</A>
<A HREF="#Arrays">Arrays</A>
<A HREF="#ARRPTR">ARRPTR</A>
<A HREF="#ASC">ASC</A>
<A HREF="#ASCII">ASCII</A>
<A HREF="#ASCII_Table">ASCII Table</A>
<A HREF="#ASIN">ASIN</A>
<A HREF="#Assembler_Notes">Assembler Notes</A>
<A HREF="#Assignment_Operator">Assignment Operator</A>
<A HREF="#ATEXT">ATEXT</A>
<A HREF="#ATN">ATN</A>
<A HREF="#ATTRDEF.H">ATTRDEF.H</A>
<A HREF="#Author/Publisher">Author/Publisher</A>
<A HREF="#AUX:">AUX:</A>
<A HREF="#avar">avar</A>

<B>B</B>
<A HREF="#BASEPAGE">BASEPAGE</A>
<A HREF="#BASEPAGE.H">BASEPAGE.H</A>
<A HREF="#BCHG">BCHG</A>
<A HREF="#BCLR">BCLR</A>
<A HREF="#bexp">bexp</A>
<A HREF="#BGET">BGET</A>
<A HREF="#BIN$">BIN$</A>
<A HREF="#BIOS">BIOS</A>
<A HREF="#BIOS_Error_Codes">BIOS Error Codes</A>
<A HREF="#BIOS()_Table">BIOS() Table</A>
<A HREF="#BIOS,_XBIOS,_and_GEMDOS">BIOS, XBIOS, and GEMDOS</A>
<A HREF="#Bit_Image_Block_Structure_(BITBLK)">Bit Image Block Structure (BITBLK)</A>
<A HREF="#Bit_Operations">Bit Operations</A>
<A HREF="#BITBLK">BITBLK</A>
<A HREF="#BITBLT">BITBLT</A>
<A HREF="#BITBLT_adr%">BITBLT adr%</A>
<A HREF="#BITBLT_x%()">BITBLT x%()</A>
<A HREF="#BLOAD">BLOAD</A>
<A HREF="#BMOVE">BMOVE</A>
<A HREF="#Bomb_Error_Codes">Bomb Error Codes</A>
<A HREF="#BOUNDARY">BOUNDARY</A>
<A HREF="#BOX">BOX</A>
<A HREF="#BPUT">BPUT</A>
<A HREF="#Break_Keys">Break Keys</A>
<A HREF="#BSAVE">BSAVE</A>
<A HREF="#BSET">BSET</A>
<A HREF="#BTST">BTST</A>
<A HREF="#BYTE">BYTE</A>
<A HREF="#Byte_by_Byte_Input_and_Output">Byte by Byte Input and Output</A>
<A HREF="#BYTE()">BYTE()</A>

<B>C</B>
<A HREF="#C_to_GFABASIC">C to GFABASIC</A>
<A HREF="#C:">C:</A>
<A HREF="#CALL">CALL</A>
<A HREF="#CARD">CARD</A>
<A HREF="#CARD()">CARD()</A>
<A HREF="#CASE">CASE</A>
<A HREF="#cdecl">cdecl</A>
<A HREF="#CFLOAT">CFLOAT</A>
<A HREF="#CHAIN">CHAIN</A>
<A HREF="#Chapter__1_-_Introduction">Chapter  1 - Introduction</A>
<A HREF="#Chapter__2_-_Variables_and_Memory_Management">Chapter  2 - Variables and Memory Management</A>
<A HREF="#Chapter__3_-_Operators">Chapter  3 - Operators</A>
<A HREF="#Chapter__4_-_Numerical_Functions">Chapter  4 - Numerical Functions</A>
<A HREF="#Chapter__5_-_String_Manipulation">Chapter  5 - String Manipulation</A>
<A HREF="#Chapter__6_-_Input_and_Output">Chapter  6 - Input and Output</A>
<A HREF="#Chapter__7_-_Program_Structure">Chapter  7 - Program Structure</A>
<A HREF="#Chapter__8_-_Graphics">Chapter  8 - Graphics</A>
<A HREF="#Chapter__9_-_Event,_Menu,_and_Window_Management">Chapter  9 - Event, Menu, and Window Management</A>
<A HREF="#Chapter_10_-_System_Routines">Chapter 10 - System Routines</A>
<A HREF="#Chapter_11_-_AES_Libraries">Chapter 11 - AES Libraries</A>
<A HREF="#Chapter_12_-_Appendix">Chapter 12 - Appendix</A>
<A HREF="#CHAR">CHAR</A>
<A HREF="#Character_Strings">Character Strings</A>
<A HREF="#CHDIR">CHDIR</A>
<A HREF="#CHDRIVE">CHDRIVE</A>
<A HREF="#Checking_the_BREAK_keys,_EVERY_and_AFTER">Checking the BREAK keys, EVERY and AFTER</A>
<A HREF="#CHR$">CHR$</A>
<A HREF="#CICON">CICON</A>
<A HREF="#CICONBLK">CICONBLK</A>
<A HREF="#CINT">CINT</A>
<A HREF="#CIRCLE">CIRCLE</A>
<A HREF="#CLEAR">CLEAR</A>
<A HREF="#CLEARW">CLEARW</A>
<A HREF="#CLIP">CLIP</A>
<A HREF="#CLIP_OFF">CLIP OFF</A>
<A HREF="#CLIP_OFFSET">CLIP OFFSET</A>
<A HREF="#CLOSE">CLOSE</A>
<A HREF="#CLOSEW">CLOSEW</A>
<A HREF="#CLR">CLR</A>
<A HREF="#CLS">CLS</A>
<A HREF="#COLOR">COLOR</A>
<A HREF="#Color_Icon_Data_Structure_(CICONBLK)">Color Icon Data Structure (CICONBLK)</A>
<A HREF="#Color_Icon_Structure_(CICON)">Color Icon Structure (CICON)</A>
<A HREF="#COM:">COM:</A>
<A HREF="#COMBIN">COMBIN</A>
<A HREF="#Command_line_options">Command line options</A>
<A HREF="#Commands_and_Functions">Commands and Functions</A>
<A HREF="#Commands_Not_Accepted_by_the_Compiler">Commands Not Accepted by the Compiler</A>
<A HREF="#Communicating_with_Peripherals">Communicating with Peripherals</A>
<A HREF="#Comparison_Operators">Comparison Operators</A>
<A HREF="#Compatibility_with_GFA-BASIC_2">Compatibility with GFA-BASIC 2</A>
<A HREF="#Compatibility_with_GFA-BASIC_3.5">Compatibility with GFA-BASIC 3.5</A>
<A HREF="#CON:">CON:</A>
<A HREF="#Concatenation_Operator">Concatenation Operator</A>
<A HREF="#CONT">CONT</A>
<A HREF="#CONTRL">CONTRL</A>
<A HREF="#Cookie_Jar">Cookie Jar</A>
<A HREF="#COS">COS</A>
<A HREF="#COSQ">COSQ</A>
<A HREF="#CRSCOL">CRSCOL</A>
<A HREF="#CRSLIN">CRSLIN</A>
<A HREF="#CURVE">CURVE</A>
<A HREF="#CVD">CVD</A>
<A HREF="#CVF">CVF</A>
<A HREF="#CVI">CVI</A>
<A HREF="#CVL">CVL</A>
<A HREF="#CVS">CVS</A>

<B>D</B>
<A HREF="#DATA">DATA</A>
<A HREF="#Data_Commands">Data Commands</A>
<A HREF="#Data_Input_and_Output">Data Input and Output</A>
<A HREF="#DATE$">DATE$</A>
<A HREF="#DATE$=">DATE$=</A>
<A HREF="#Debugging_with_GFA-Basic_and_MiNT">Debugging with GFA-Basic and MiNT</A>
<A HREF="#DEC">DEC</A>
<A HREF="#Decision_Commands">Decision Commands</A>
<A HREF="#DEFAULT">DEFAULT</A>
<A HREF="#DEFBIT">DEFBIT</A>
<A HREF="#DEFBYT">DEFBYT</A>
<A HREF="#DEFDBL">DEFDBL</A>
<A HREF="#DEFFILL">DEFFILL</A>
<A HREF="#DEFFLT">DEFFLT</A>
<A HREF="#DEFFN">DEFFN</A>
<A HREF="#DEFINT">DEFINT</A>
<A HREF="#DEFLINE">DEFLINE</A>
<A HREF="#DEFLIST">DEFLIST</A>
<A HREF="#DEFMARK">DEFMARK</A>
<A HREF="#DEFMOUSE">DEFMOUSE</A>
<A HREF="#DEFNUM">DEFNUM</A>
<A HREF="#DEFSNG">DEFSNG</A>
<A HREF="#DEFSTR">DEFSTR</A>
<A HREF="#DEFTEXT">DEFTEXT</A>
<A HREF="#DEFWRD">DEFWRD</A>
<A HREF="#DEG">DEG</A>
<A HREF="#DELAY">DELAY</A>
<A HREF="#DELETE">DELETE</A>
<A HREF="#Deleting_and_Exchanging">Deleting and Exchanging</A>
<A HREF="#Descriptor">Descriptor</A>
<A HREF="#descriptor">descriptor</A>
<A HREF="#DFREE">DFREE</A>
<A HREF="#DIAL_SMP.GFA">DIAL_SMP.GFA</A>
<A HREF="#DIM">DIM</A>
<A HREF="#DIM?">DIM?</A>
<A HREF="#DIR">DIR</A>
<A HREF="#DIR$">DIR$</A>
<A HREF="#Directory_Handling">Directory Handling</A>
<A HREF="#DIV">DIV</A>
<A HREF="#DIV()">DIV()</A>
<A HREF="#Division">Division</A>
<A HREF="#DMACONTROL">DMACONTROL</A>
<A HREF="#DMASOUND">DMASOUND</A>
<A HREF="#DO">DO</A>
<A HREF="#Do_not_Link_TEST.O">Do not Link TEST.O</A>
<A HREF="#DO_UNTIL">DO UNTIL</A>
<A HREF="#DO_WHILE">DO WHILE</A>
<A HREF="#Document_not_found">Document not found</A>
<A HREF="#DOUBLE">DOUBLE</A>
<A HREF="#DOWNTO">DOWNTO</A>
<A HREF="#DPEEK">DPEEK</A>
<A HREF="#DPOKE">DPOKE</A>
<A HREF="#DR">DR</A>
<A HREF="#DRAW">DRAW</A>
<A HREF="#DRAW_TO">DRAW TO</A>
<A HREF="#DRAW()">DRAW()</A>
<A HREF="#DTA">DTA</A>
<A HREF="#DUMP">DUMP</A>

<B>E</B>
<A HREF="#EDIT">EDIT</A>
<A HREF="#Editor_Error_Messages">Editor Error Messages</A>
<A HREF="#ELLIPSE">ELLIPSE</A>
<A HREF="#ELSE">ELSE</A>
<A HREF="#ELSE_IF">ELSE IF</A>
<A HREF="#ENCOM">ENCOM</A>
<A HREF="#END">END</A>
<A HREF="#End-user_License_Agreement">End-user License Agreement</A>
<A HREF="#ENDDO">ENDDO</A>
<A HREF="#ENDFOR">ENDFOR</A>
<A HREF="#ENDFUNC">ENDFUNC</A>
<A HREF="#ENDFUNC_Generation">ENDFUNC Generation</A>
<A HREF="#ENDIF">ENDIF</A>
<A HREF="#ENDPROC">ENDPROC</A>
<A HREF="#ENDREPEAT">ENDREPEAT</A>
<A HREF="#ENDSELECT">ENDSELECT</A>
<A HREF="#ENDSUB">ENDSUB</A>
<A HREF="#ENDSWITCH">ENDSWITCH</A>
<A HREF="#ENDWHILE">ENDWHILE</A>
<A HREF="#EOF">EOF</A>
<A HREF="#EQV">EQV</A>
<A HREF="#EQV()">EQV()</A>
<A HREF="#ERASE">ERASE</A>
<A HREF="#ERR">ERR</A>
<A HREF="#ERR$">ERR$</A>
<A HREF="#ERRNO.H">ERRNO.H</A>
<A HREF="#ERROR">ERROR</A>
<A HREF="#Error_Codes">Error Codes</A>
<A HREF="#Error_Handling">Error Handling</A>
<A HREF="#Error_Messages">Error Messages</A>
<A HREF="#Error_Numbers_Instead_of_Bombs">Error Numbers Instead of Bombs</A>
<A HREF="#EULA">EULA</A>
<A HREF="#EVEN">EVEN</A>
<A HREF="#Event_Library">Event Library</A>
<A HREF="#Event_Management">Event Management</A>
<A HREF="#EVERY">EVERY</A>
<A HREF="#EVERY_CONT">EVERY CONT</A>
<A HREF="#EVERY_GOSUB">EVERY GOSUB</A>
<A HREF="#EVERY_STOP">EVERY STOP</A>
<A HREF="#EVNT_BUTTON">EVNT_BUTTON</A>
<A HREF="#EVNT_DCLICK">EVNT_DCLICK</A>
<A HREF="#EVNT_KEYBD">EVNT_KEYBD</A>
<A HREF="#EVNT_MESAG">EVNT_MESAG</A>
<A HREF="#EVNT_MOUSE">EVNT_MOUSE</A>
<A HREF="#EVNT_MULTI">EVNT_MULTI</A>
<A HREF="#EVNT_TIMER">EVNT_TIMER</A>
<A HREF="#EXEC">EXEC</A>
<A HREF="#EXEC()">EXEC()</A>
<A HREF="#EXIST">EXIST</A>
<A HREF="#EXIT_IF">EXIT IF</A>
<A HREF="#EXP">EXP</A>
<A HREF="#Externally_Linked_Routines">Externally Linked Routines</A>

<B>F</B>
<A HREF="#FACT">FACT</A>
<A HREF="#FALSE">FALSE</A>
<A HREF="#fastload">fastload</A>
<A HREF="#Fastload_on_TOS_1.00/1.02">Fastload on TOS 1.00/1.02</A>
<A HREF="#FATAL">FATAL</A>
<A HREF="#FGETDTA">FGETDTA</A>
<A HREF="#FIELD">FIELD</A>
<A HREF="#FIELD_#">FIELD #</A>
<A HREF="#File_Management">File Management</A>
<A HREF="#File_Selector_Library">File Selector Library</A>
<A HREF="#FILES">FILES</A>
<A HREF="#Files">Files</A>
<A HREF="#FILESELECT">FILESELECT</A>
<A HREF="#FILL">FILL</A>
<A HREF="#Fill_Pattern_Table">Fill Pattern Table</A>
<A HREF="#FIX">FIX</A>
<A HREF="#FLOAT">FLOAT</A>
<A HREF="#FN">FN</A>
<A HREF="#FOR">FOR</A>
<A HREF="#FOR-NEXT_Loop_Checking">FOR-NEXT Loop Checking</A>
<A HREF="#FORM_INPUT">FORM INPUT</A>
<A HREF="#FORM_INPUT_AS">FORM INPUT AS</A>
<A HREF="#Form_Library">Form Library</A>
<A HREF="#FORM_ALERT">FORM_ALERT</A>
<A HREF="#FORM_BUTTON">FORM_BUTTON</A>
<A HREF="#FORM_CENTER">FORM_CENTER</A>
<A HREF="#FORM_DIAL">FORM_DIAL</A>
<A HREF="#FORM_DO">FORM_DO</A>
<A HREF="#FORM_ERROR">FORM_ERROR</A>
<A HREF="#FORM_KEYBD">FORM_KEYBD</A>
<A HREF="#form_popup">form_popup</A>
<A HREF="#FRAC">FRAC</A>
<A HREF="#FRE">FRE</A>
<A HREF="#fsel_exinput">fsel_exinput</A>
<A HREF="#FSEL_INPUT">FSEL_INPUT</A>
<A HREF="#FSETDTA">FSETDTA</A>
<A HREF="#FSFIRST">FSFIRST</A>
<A HREF="#FSNEXT">FSNEXT</A>
<A HREF="#FULLW">FULLW</A>
<A HREF="#FUNCTION">FUNCTION</A>
<A HREF="#Fundamentals">Fundamentals</A>
<A HREF="#Further_Control_Commands">Further Control Commands</A>
<A HREF="#Further_Editing_Commands">Further Editing Commands</A>

<B>G</B>
<A HREF="#G3LIB">G3LIB</A>
<A HREF="#G3MOVE">G3MOVE</A>
<A HREF="#G3OBJ">G3OBJ</A>
<A HREF="#G3PRG">G3PRG</A>
<A HREF="#G3WAIT">G3WAIT</A>
<A HREF="#GB">GB</A>
<A HREF="#GCONTRL">GCONTRL</A>
<A HREF="#GDOS?">GDOS?</A>
<A HREF="#GEMDOS">GEMDOS</A>
<A HREF="#GEMDOS_Error_Codes">GEMDOS Error Codes</A>
<A HREF="#GEMDOS()_Table">GEMDOS() Table</A>
<A HREF="#GEMSYS">GEMSYS</A>
<A HREF="#General_Graphics_Commands">General Graphics Commands</A>
<A HREF="#General_Information">General Information</A>
<A HREF="#GET">GET</A>
<A HREF="#GET_#">GET #</A>
<A HREF="#GETSIZE">GETSIZE</A>
<A HREF="#Getting_Started">Getting Started</A>
<A HREF="#GFA_Software_Technologies,_Inc.">GFA Software Technologies, Inc.</A>
<A HREF="#GFA-Basic">GFA-Basic</A>
<A HREF="#GFA-Basic_Addendum">GFA-Basic Addendum</A>
<A HREF="#GFA-Basic_Compiler/Linker_Manual">GFA-Basic Compiler/Linker Manual</A>
<A HREF="#GFA-Basic_Editor/Interpreter_Manual">GFA-Basic Editor/Interpreter Manual</A>
<A HREF="#GFA-Basic_History">GFA-Basic History</A>
<A HREF="#GFA-Basic_v3_float_format">GFA-Basic v3 float format</A>
<A HREF="#GFA_PTCH.TXT">GFA_PTCH.TXT</A>
<A HREF="#GINTIN">GINTIN</A>
<A HREF="#GINTOUT">GINTOUT</A>
<A HREF="#GOSUB">GOSUB</A>
<A HREF="#GOTO">GOTO</A>
<A HREF="#Grabbing_Sections_of_the_Screen">Grabbing Sections of the Screen</A>
<A HREF="#GRAF_DRAGBOX">GRAF_DRAGBOX</A>
<A HREF="#GRAF_GROWBOX">GRAF_GROWBOX</A>
<A HREF="#GRAF_HANDLE">GRAF_HANDLE</A>
<A HREF="#GRAF_MKSTATE">GRAF_MKSTATE</A>
<A HREF="#GRAF_MOUSE">GRAF_MOUSE</A>
<A HREF="#GRAF_MOVEBOX">GRAF_MOVEBOX</A>
<A HREF="#graf_multirubber">graf_multirubber</A>
<A HREF="#GRAF_RUBBERBOX">GRAF_RUBBERBOX</A>
<A HREF="#GRAF_SHRINKBOX">GRAF_SHRINKBOX</A>
<A HREF="#GRAF_SLIDEBOX">GRAF_SLIDEBOX</A>
<A HREF="#GRAF_SMP.GFA">GRAF_SMP.GFA</A>
<A HREF="#GRAF_WATCHBOX">GRAF_WATCHBOX</A>
<A HREF="#Graphics_Definition_Commands">Graphics Definition Commands</A>
<A HREF="#Graphics_Library">Graphics Library</A>
<A HREF="#GRAPHMODE">GRAPHMODE</A>

<B>H</B>
<A HREF="#HARDCOPY">HARDCOPY</A>
<A HREF="#Help">Help</A>
<A HREF="#HEX$">HEX$</A>
<A HREF="#HIDEM">HIDEM</A>
<A HREF="#HIMEM">HIMEM</A>
<A HREF="#HLINE">HLINE</A>
<A HREF="#HTAB">HTAB</A>
<A HREF="#HYPertext_Version">HYPertext Version</A>

<B>I</B>
<A HREF="#Icon_Data_Structure_(ICONBLK)">Icon Data Structure (ICONBLK)</A>
<A HREF="#ICONBLK">ICONBLK</A>
<A HREF="#iexp">iexp</A>
<A HREF="#IF">IF</A>
<A HREF="#IF-ENDIF">IF-ENDIF</A>
<A HREF="#IKB:">IKB:</A>
<A HREF="#IMP">IMP</A>
<A HREF="#IMP()">IMP()</A>
<A HREF="#INC">INC</A>
<A HREF="#Including_C_Functions">Including C Functions</A>
<A HREF="#index">index</A>
<A HREF="#INFOW">INFOW</A>
<A HREF="#INKEY$">INKEY$</A>
<A HREF="#INLINE">INLINE</A>
<A HREF="#INP">INP</A>
<A HREF="#INP%">INP%</A>
<A HREF="#INP%()">INP%()</A>
<A HREF="#INP&">INP&</A>
<A HREF="#INP&()">INP&()</A>
<A HREF="#INP()">INP()</A>
<A HREF="#INP?">INP?</A>
<A HREF="#INPAUX$">INPAUX$</A>
<A HREF="#INPMID$">INPMID$</A>
<A HREF="#INPUT">INPUT</A>
<A HREF="#INPUT_#">INPUT #</A>
<A HREF="#INPUT$">INPUT$</A>
<A HREF="#INSERT">INSERT</A>
<A HREF="#INSTR">INSTR</A>
<A HREF="#INT">INT</A>
<A HREF="#INT()">INT()</A>
<A HREF="#Integer_Arithmetic">Integer Arithmetic</A>
<A HREF="#Integer_Division">Integer Division</A>
<A HREF="#Integer_Multiplication">Integer Multiplication</A>
<A HREF="#Integer_Overflow">Integer Overflow</A>
<A HREF="#Integer_Rounding">Integer Rounding</A>
<A HREF="#Interpreter_-_Compiler_Differences">Interpreter - Compiler Differences</A>
<A HREF="#Interpreter_Error_Codes">Interpreter Error Codes</A>
<A HREF="#Interrupt_Programming">Interrupt Programming</A>
<A HREF="#Interrupt_Routines">Interrupt Routines</A>
<A HREF="#INTIN">INTIN</A>
<A HREF="#INTOUT">INTOUT</A>
<A HREF="#Introduction">Introduction</A>
<A HREF="#ivar">ivar</A>

<B>K</B>
<A HREF="#Keyboard_and_Screen_Handling">Keyboard and Screen Handling</A>
<A HREF="#KEYDEF">KEYDEF</A>
<A HREF="#KEYGET">KEYGET</A>
<A HREF="#KEYLOOK">KEYLOOK</A>
<A HREF="#KEYPAD">KEYPAD</A>
<A HREF="#KEYPRESS">KEYPRESS</A>
<A HREF="#KEYTEST">KEYTEST</A>
<A HREF="#KEYxxx_Commands">KEYxxx Commands</A>
<A HREF="#KILL">KILL</A>
<A HREF="#Known_problems_with_GFA-Basic">Known problems with GFA-Basic</A>

<B>L</B>
<A HREF="#L:">L:</A>
<A HREF="#label:">label:</A>
<A HREF="#LEFT$">LEFT$</A>
<A HREF="#LEN">LEN</A>
<A HREF="#LET">LET</A>
<A HREF="#LIBPATCH.TXT">LIBPATCH.TXT</A>
<A HREF="#Library_Selection">Library Selection</A>
<A HREF="#LINE">LINE</A>
<A HREF="#LINE_INPUT">LINE INPUT</A>
<A HREF="#LINE_INPUT_#">LINE INPUT #</A>
<A HREF="#Line_Style_Table">Line Style Table</A>
<A HREF="#Line-A">Line-A</A>
<A HREF="#LINE-A">LINE-A</A>
<A HREF="#Line-A_calls">Line-A calls</A>
<A HREF="#Line-A_Calls">Line-A Calls</A>
<A HREF="#Line-A_Variable_Table">Line-A Variable Table</A>
<A HREF="#LINEAEQU.S">LINEAEQU.S</A>
<A HREF="#LINEAVAR.H">LINEAVAR.H</A>
<A HREF="#Linker_Error_Messages">Linker Error Messages</A>
<A HREF="#Linking_C_Functions_without_C_Libraries">Linking C Functions without C Libraries</A>
<A HREF="#Linking_Object_Files">Linking Object Files</A>
<A HREF="#Linking_with_C_Libraries">Linking with C Libraries</A>
<A HREF="#LIST">LIST</A>
<A HREF="#LLIST">LLIST</A>
<A HREF="#LOAD">LOAD</A>
<A HREF="#LOC">LOC</A>
<A HREF="#LOCAL">LOCAL</A>
<A HREF="#Local_and_Global_Variables">Local and Global Variables</A>
<A HREF="#LOCATE">LOCATE</A>
<A HREF="#LOF">LOF</A>
<A HREF="#LOG">LOG</A>
<A HREF="#LOG10">LOG10</A>
<A HREF="#Logical_Operators">Logical Operators</A>
<A HREF="#LONG">LONG</A>
<A HREF="#Longer_Programming_Examples">Longer Programming Examples</A>
<A HREF="#Lonny_Pursell">Lonny Pursell</A>
<A HREF="#LOOP">LOOP</A>
<A HREF="#Loop_Commands">Loop Commands</A>
<A HREF="#LOOP_UNTIL">LOOP UNTIL</A>
<A HREF="#LOOP_WHILE">LOOP WHILE</A>
<A HREF="#Loops">Loops</A>
<A HREF="#LPEEK">LPEEK</A>
<A HREF="#LPENx">LPENx</A>
<A HREF="#LPENX">LPENX</A>
<A HREF="#LPENY">LPENY</A>
<A HREF="#LPOKE">LPOKE</A>
<A HREF="#LPOS">LPOS</A>
<A HREF="#LPRINT">LPRINT</A>
<A HREF="#LPT:">LPT:</A>
<A HREF="#LSET">LSET</A>
<A HREF="#LST:">LST:</A>
<A HREF="#L~A">L~A</A>

<B>M</B>
<A HREF="#Main">Main</A>
<A HREF="#MALLOC">MALLOC</A>
<A HREF="#MAT">MAT</A>
<A HREF="#MAT_?">MAT ?</A>
<A HREF="#MAT_ABS">MAT ABS</A>
<A HREF="#MAT_ADD">MAT ADD</A>
<A HREF="#MAT_BASE">MAT BASE</A>
<A HREF="#MAT_CLR">MAT CLR</A>
<A HREF="#MAT_CPY">MAT CPY</A>
<A HREF="#MAT_DET">MAT DET</A>
<A HREF="#MAT_INPUT">MAT INPUT</A>
<A HREF="#MAT_INV">MAT INV</A>
<A HREF="#MAT_MUL">MAT MUL</A>
<A HREF="#MAT_NEG">MAT NEG</A>
<A HREF="#MAT_NORM">MAT NORM</A>
<A HREF="#MAT_ONE">MAT ONE</A>
<A HREF="#MAT_PRINT">MAT PRINT</A>
<A HREF="#MAT_QDET">MAT QDET</A>
<A HREF="#MAT_RANG">MAT RANG</A>
<A HREF="#MAT_READ">MAT READ</A>
<A HREF="#MAT_SET">MAT SET</A>
<A HREF="#MAT_SUB">MAT SUB</A>
<A HREF="#MAT_TRANS">MAT TRANS</A>
<A HREF="#MAT_XCPY">MAT XCPY</A>
<A HREF="#Mathematical_Functions">Mathematical Functions</A>
<A HREF="#Matrix_Commands">Matrix Commands</A>
<A HREF="#MAX">MAX</A>
<A HREF="#Memory_Management">Memory Management</A>
<A HREF="#MENU">MENU</A>
<A HREF="#MENU_KILL">MENU KILL</A>
<A HREF="#Menu_Library">Menu Library</A>
<A HREF="#MENU_OFF">MENU OFF</A>
<A HREF="#MENU()">MENU()</A>
<A HREF="#menu_attach">menu_attach</A>
<A HREF="#MENU_BAR">MENU_BAR</A>
<A HREF="#MENU_ICHECK">MENU_ICHECK</A>
<A HREF="#MENU_IENABLE">MENU_IENABLE</A>
<A HREF="#menu_istart">menu_istart</A>
<A HREF="#menu_popup">menu_popup</A>
<A HREF="#MENU_REGISTER">MENU_REGISTER</A>
<A HREF="#menu_settings">menu_settings</A>
<A HREF="#MENU_SMP.GFA">MENU_SMP.GFA</A>
<A HREF="#MENU_TEXT">MENU_TEXT</A>
<A HREF="#MENU_TNORMAL">MENU_TNORMAL</A>
<A HREF="#MFREE">MFREE</A>
<A HREF="#MichTron,_Inc.">MichTron, Inc.</A>
<A HREF="#MID$">MID$</A>
<A HREF="#MID$()">MID$()</A>
<A HREF="#MID:">MID:</A>
<A HREF="#MIN">MIN</A>
<A HREF="#Misc_Images">Misc Images</A>
<A HREF="#MKD$">MKD$</A>
<A HREF="#MKDIR">MKDIR</A>
<A HREF="#MKF$">MKF$</A>
<A HREF="#MKI$">MKI$</A>
<A HREF="#MKL$">MKL$</A>
<A HREF="#MKS$">MKS$</A>
<A HREF="#MOD">MOD</A>
<A HREF="#MOD()">MOD()</A>
<A HREF="#MODE">MODE</A>
<A HREF="#MONITOR">MONITOR</A>
<A HREF="#More_Complicated_Calculations">More Complicated Calculations</A>
<A HREF="#MOUSE">MOUSE</A>
<A HREF="#Mouse_and_Joysticks">Mouse and Joysticks</A>
<A HREF="#MOUSEK">MOUSEK</A>
<A HREF="#MOUSEX">MOUSEX</A>
<A HREF="#MOUSEY">MOUSEY</A>
<A HREF="#MSHRINK">MSHRINK</A>
<A HREF="#MUL">MUL</A>
<A HREF="#MUL()">MUL()</A>
<A HREF="#Multiple_Branching">Multiple Branching</A>
<A HREF="#Multiplication">Multiplication</A>
<A HREF="#MW_OUT">MW_OUT</A>

<B>N</B>
<A HREF="#N.AES">N.AES</A>
<A HREF="#N.AES_Functions_and_Objects">N.AES Functions and Objects</A>
<A HREF="#NAME">NAME</A>
<A HREF="#NEW">NEW</A>
<A HREF="#NEXT">NEXT</A>
<A HREF="#Non-BASIC_Routine_Calls">Non-BASIC Routine Calls</A>
<A HREF="#NOT">NOT</A>
<A HREF="#Number_Table">Number Table</A>

<B>O</B>
<A HREF="#OBJC_ADD">OBJC_ADD</A>
<A HREF="#OBJC_CHANGE">OBJC_CHANGE</A>
<A HREF="#OBJC_DELETE">OBJC_DELETE</A>
<A HREF="#OBJC_DRAW">OBJC_DRAW</A>
<A HREF="#OBJC_EDIT">OBJC_EDIT</A>
<A HREF="#OBJC_FIND">OBJC_FIND</A>
<A HREF="#OBJC_OFFSET">OBJC_OFFSET</A>
<A HREF="#OBJC_ORDER">OBJC_ORDER</A>
<A HREF="#objc_sysvar">objc_sysvar</A>
<A HREF="#objc_xfind">objc_xfind</A>
<A HREF="#OBJECT">OBJECT</A>
<A HREF="#Object_Library">Object Library</A>
<A HREF="#Object_Structure">Object Structure</A>
<A HREF="#OB_ADR">OB_ADR</A>
<A HREF="#OB_FLAGS">OB_FLAGS</A>
<A HREF="#OB_H">OB_H</A>
<A HREF="#OB_HEAD">OB_HEAD</A>
<A HREF="#OB_NEXT">OB_NEXT</A>
<A HREF="#OB_SPEC">OB_SPEC</A>
<A HREF="#OB_STATE">OB_STATE</A>
<A HREF="#OB_TAIL">OB_TAIL</A>
<A HREF="#OB_TYPE">OB_TYPE</A>
<A HREF="#OB_W">OB_W</A>
<A HREF="#OB_X">OB_X</A>
<A HREF="#OB_Y">OB_Y</A>
<A HREF="#OCT$">OCT$</A>
<A HREF="#ODD">ODD</A>
<A HREF="#OFFSET">OFFSET</A>
<A HREF="#ON_BREAK">ON BREAK</A>
<A HREF="#ON_BREAK_CONT">ON BREAK CONT</A>
<A HREF="#ON_BREAK_GOSUB">ON BREAK GOSUB</A>
<A HREF="#ON_ERROR">ON ERROR</A>
<A HREF="#ON_ERROR_GOSUB">ON ERROR GOSUB</A>
<A HREF="#ON_GOSUB">ON GOSUB</A>
<A HREF="#ON_MENU">ON MENU</A>
<A HREF="#ON_MENU_BUTTON">ON MENU BUTTON</A>
<A HREF="#ON_MENU_GOSUB">ON MENU GOSUB</A>
<A HREF="#ON_MENU_IBOX">ON MENU IBOX</A>
<A HREF="#ON_MENU_KEY">ON MENU KEY</A>
<A HREF="#ON_MENU_MESSAGE">ON MENU MESSAGE</A>
<A HREF="#ON_MENU_OBOX">ON MENU OBOX</A>
<A HREF="#OPEN">OPEN</A>
<A HREF="#OPENW">OPENW</A>
<A HREF="#Operator_Hierarchy">Operator Hierarchy</A>
<A HREF="#Optimizations_not_covered_in_the_Compiler_manual">Optimizations not covered in the Compiler manual</A>
<A HREF="#OPTION">OPTION</A>
<A HREF="#OPTION_BASE">OPTION BASE</A>
<A HREF="#OR">OR</A>
<A HREF="#OR()">OR()</A>
<A HREF="#Other_Commands">Other Commands</A>
<A HREF="#Other_System-related_Commands">Other System-related Commands</A>
<A HREF="#Other_Window-related_Commands">Other Window-related Commands</A>
<A HREF="#OTHERWISE">OTHERWISE</A>
<A HREF="#OUT">OUT</A>
<A HREF="#OUT_#">OUT #</A>
<A HREF="#OUT%">OUT%</A>
<A HREF="#OUT%_#">OUT% #</A>
<A HREF="#OUT&">OUT&</A>
<A HREF="#OUT&_#">OUT& #</A>
<A HREF="#OUT?">OUT?</A>
<A HREF="#Overview_of_Compiler_Options">Overview of Compiler Options</A>
<A HREF="#Overview_of_Linker_Options">Overview of Linker Options</A>

<B>P</B>
<A HREF="#PADT">PADT</A>
<A HREF="#PADX">PADX</A>
<A HREF="#PADx">PADx</A>
<A HREF="#PADY">PADY</A>
<A HREF="#Parameter_Block_Structure_(PARMBLK)">Parameter Block Structure (PARMBLK)</A>
<A HREF="#PARMBLK">PARMBLK</A>
<A HREF="#Patches_for_GFA-Basic">Patches for GFA-Basic</A>
<A HREF="#PAUSE">PAUSE</A>
<A HREF="#PBOX">PBOX</A>
<A HREF="#PCIRCLE">PCIRCLE</A>
<A HREF="#PEEK">PEEK</A>
<A HREF="#PELLIPSE">PELLIPSE</A>
<A HREF="#PI">PI</A>
<A HREF="#PLOT">PLOT</A>
<A HREF="#POINT">POINT</A>
<A HREF="#Pointer_Operations">Pointer Operations</A>
<A HREF="#POKE">POKE</A>
<A HREF="#POLYFILL">POLYFILL</A>
<A HREF="#POLYLINE">POLYLINE</A>
<A HREF="#POLYMARK">POLYMARK</A>
<A HREF="#POS">POS</A>
<A HREF="#PRBOX">PRBOX</A>
<A HREF="#PRED">PRED</A>
<A HREF="#PRED()">PRED()</A>
<A HREF="#PRINT">PRINT</A>
<A HREF="#PRINT_#">PRINT #</A>
<A HREF="#PRINT_#_USING">PRINT # USING</A>
<A HREF="#PRINT_AT">PRINT AT</A>
<A HREF="#PRINT_USING">PRINT USING</A>
<A HREF="#Printing">Printing</A>
<A HREF="#PRN:">PRN:</A>
<A HREF="#proc">proc</A>
<A HREF="#PROCEDURE">PROCEDURE</A>
<A HREF="#Procedures_and_Functions">Procedures and Functions</A>
<A HREF="#Program_Optimization">Program Optimization</A>
<A HREF="#Program_Return_Value">Program Return Value</A>
<A HREF="#Program_Tracing">Program Tracing</A>
<A HREF="#Programming_Accessories">Programming Accessories</A>
<A HREF="#Programming_Example">Programming Example</A>
<A HREF="#PSAVE">PSAVE</A>
<A HREF="#PSET">PSET</A>
<A HREF="#PTSIN">PTSIN</A>
<A HREF="#PTSOUT">PTSOUT</A>
<A HREF="#PTST">PTST</A>
<A HREF="#Publisher">Publisher</A>
<A HREF="#Pull-down_Menus">Pull-down Menus</A>
<A HREF="#PUT">PUT</A>
<A HREF="#PUT_#">PUT #</A>

<B>Q</B>
<A HREF="#QSORT">QSORT</A>
<A HREF="#QUIT">QUIT</A>

<B>R</B>
<A HREF="#RAD">RAD</A>
<A HREF="#RAND">RAND</A>
<A HREF="#RANDOM">RANDOM</A>
<A HREF="#Random_Access">Random Access</A>
<A HREF="#Random_Number_Generator">Random Number Generator</A>
<A HREF="#RANDOMIZE">RANDOMIZE</A>
<A HREF="#RBOX">RBOX</A>
<A HREF="#RCALL">RCALL</A>
<A HREF="#RC_COPY">RC_COPY</A>
<A HREF="#RC_INTERSECT">RC_INTERSECT</A>
<A HREF="#RC_INTERSECT()_Parameters">RC_INTERSECT() Parameters</A>
<A HREF="#READ">READ</A>
<A HREF="#RECALL">RECALL</A>
<A HREF="#RECORD">RECORD</A>
<A HREF="#RECORD_#">RECORD #</A>
<A HREF="#Register_Saving">Register Saving</A>
<A HREF="#RELSEEK">RELSEEK</A>
<A HREF="#REM">REM</A>
<A HREF="#RENAME">RENAME</A>
<A HREF="#REPEAT">REPEAT</A>
<A HREF="#RESERVE">RESERVE</A>
<A HREF="#Reserved_Variables">Reserved Variables</A>
<A HREF="#Reserving_Memory_Space">Reserving Memory Space</A>
<A HREF="#Resource_Library">Resource Library</A>
<A HREF="#RESTORE">RESTORE</A>
<A HREF="#RESUME">RESUME</A>
<A HREF="#RESUME_label">RESUME label</A>
<A HREF="#RESUME_NEXT">RESUME NEXT</A>
<A HREF="#RETURN">RETURN</A>
<A HREF="#Return_Value_of_a_Function">Return Value of a Function</A>
<A HREF="#RETURN_x">RETURN x</A>
<A HREF="#RIGHT$">RIGHT$</A>
<A HREF="#RINSTR">RINSTR</A>
<A HREF="#RMDIR">RMDIR</A>
<A HREF="#RND">RND</A>
<A HREF="#ROL">ROL</A>
<A HREF="#ROL&">ROL&</A>
<A HREF="#ROL&#124;">ROL&#124;</A>
<A HREF="#ROR">ROR</A>
<A HREF="#ROR&">ROR&</A>
<A HREF="#ROR&#124;">ROR&#124;</A>
<A HREF="#ROUND">ROUND</A>
<A HREF="#RSET">RSET</A>
<A HREF="#RSRC_FREE">RSRC_FREE</A>
<A HREF="#RSRC_GADDR">RSRC_GADDR</A>
<A HREF="#RSRC_LOAD">RSRC_LOAD</A>
<A HREF="#RSRC_OBFIX">RSRC_OBFIX</A>
<A HREF="#rsrc_rcfix">rsrc_rcfix</A>
<A HREF="#RSRC_SADDR">RSRC_SADDR</A>
<A HREF="#RUN">RUN</A>
<A HREF="#Run_in_TT_Ram">Run in TT Ram</A>

<B>S</B>
<A HREF="#Sample_Programs">Sample Programs</A>
<A HREF="#SAVE">SAVE</A>
<A HREF="#SCALE">SCALE</A>
<A HREF="#Scan">Scan</A>
<A HREF="#Scan_Code_Table">Scan Code Table</A>
<A HREF="#Scrap_Library">Scrap Library</A>
<A HREF="#SCRP_READ">SCRP_READ</A>
<A HREF="#SCRP_WRITE">SCRP_WRITE</A>
<A HREF="#SDPOKE">SDPOKE</A>
<A HREF="#SEEK">SEEK</A>
<A HREF="#SELECT">SELECT</A>
<A HREF="#SELECT-CASE_Optimisation">SELECT-CASE Optimisation</A>
<A HREF="#SELECT-CASE_Parameter">SELECT-CASE Parameter</A>
<A HREF="#Sequential_Access">Sequential Access</A>
<A HREF="#Serial_(RS232)_and_MIDI_Interfaces">Serial (RS232) and MIDI Interfaces</A>
<A HREF="#SETCOLOR">SETCOLOR</A>
<A HREF="#SETDRAW">SETDRAW</A>
<A HREF="#SETMOUSE">SETMOUSE</A>
<A HREF="#SETTIME">SETTIME</A>
<A HREF="#sexp">sexp</A>
<A HREF="#SGET">SGET</A>
<A HREF="#SGN">SGN</A>
<A HREF="#Shell_Library">Shell Library</A>
<A HREF="#SHEL_ENVRN">SHEL_ENVRN</A>
<A HREF="#SHEL_FIND">SHEL_FIND</A>
<A HREF="#SHEL_GET">SHEL_GET</A>
<A HREF="#shel_help">shel_help</A>
<A HREF="#SHEL_PUT">SHEL_PUT</A>
<A HREF="#shel_rdef">shel_rdef</A>
<A HREF="#SHEL_READ">SHEL_READ</A>
<A HREF="#shel_wdef">shel_wdef</A>
<A HREF="#SHEL_WRITE">SHEL_WRITE</A>
<A HREF="#Shift_Table">Shift Table</A>
<A HREF="#SHL">SHL</A>
<A HREF="#SHL&">SHL&</A>
<A HREF="#SHL&#124;">SHL&#124;</A>
<A HREF="#SHOWM">SHOWM</A>
<A HREF="#SHR">SHR</A>
<A HREF="#SHR&">SHR&</A>
<A HREF="#SHR&#124;">SHR&#124;</A>
<A HREF="#Simple_Additions">Simple Additions</A>
<A HREF="#SIN">SIN</A>
<A HREF="#SINGLE">SINGLE</A>
<A HREF="#SINQ">SINQ</A>
<A HREF="#SLPOKE">SLPOKE</A>
<A HREF="#Some_Peculiarities">Some Peculiarities</A>
<A HREF="#SOUND">SOUND</A>
<A HREF="#Sound_Generation">Sound Generation</A>
<A HREF="#SPACE$">SPACE$</A>
<A HREF="#SPC">SPC</A>
<A HREF="#Special">Special</A>
<A HREF="#Special_ASCII_Characters">Special ASCII Characters</A>
<A HREF="#Special_Commands">Special Commands</A>
<A HREF="#Special_VDI_Routines_and_GDOS">Special VDI Routines and GDOS</A>
<A HREF="#SPOKE">SPOKE</A>
<A HREF="#SPRITE">SPRITE</A>
<A HREF="#SPUT">SPUT</A>
<A HREF="#SQR">SQR</A>
<A HREF="#SSORT">SSORT</A>
<A HREF="#ST-Basic_float_format">ST-Basic float format</A>
<A HREF="#Start-up/Shut-down_modules">Start-up/Shut-down modules</A>
<A HREF="#STD:">STD:</A>
<A HREF="#STE?">STE?</A>
<A HREF="#STEP">STEP</A>
<A HREF="#STICK">STICK</A>
<A HREF="#STOP">STOP</A>
<A HREF="#STORE">STORE</A>
<A HREF="#STR$">STR$</A>
<A HREF="#STRIG">STRIG</A>
<A HREF="#String_Manipulation">String Manipulation</A>
<A HREF="#STRING$">STRING$</A>
<A HREF="#SUB">SUB</A>
<A HREF="#SUB()">SUB()</A>
<A HREF="#Subroutines">Subroutines</A>
<A HREF="#SUCC">SUCC</A>
<A HREF="#SUCC()">SUCC()</A>
<A HREF="#svar">svar</A>
<A HREF="#SWAP">SWAP</A>
<A HREF="#SWAP()">SWAP()</A>
<A HREF="#SWITCH">SWITCH</A>
<A HREF="#Symbol_Table">Symbol Table</A>
<A HREF="#SYSTEM">SYSTEM</A>
<A HREF="#System_Routines">System Routines</A>

<B>T</B>
<A HREF="#TAB">TAB</A>
<A HREF="#TAN">TAN</A>
<A HREF="#Technical_Support">Technical Support</A>
<A HREF="#TEDINFO">TEDINFO</A>
<A HREF="#TEXT">TEXT</A>
<A HREF="#Text_Data_Structure_(TEDINFO)">Text Data Structure (TEDINFO)</A>
<A HREF="#The_Compiler">The Compiler</A>
<A HREF="#The_Compiler_Options">The Compiler Options</A>
<A HREF="#The_Cursor_Keypad">The Cursor Keypad</A>
<A HREF="#The_Editor">The Editor</A>
<A HREF="#The_File_Menu">The File Menu</A>
<A HREF="#The_Function_of_the_Compiler">The Function of the Compiler</A>
<A HREF="#The_Linker">The Linker</A>
<A HREF="#The_Linker_Options">The Linker Options</A>
<A HREF="#The_local=FN_bug">The local=FN bug</A>
<A HREF="#The_Menu_Bar_and_Function_Keys">The Menu Bar and Function Keys</A>
<A HREF="#The_Modifier_Keys">The Modifier Keys</A>
<A HREF="#The_Numeric_Keypad">The Numeric Keypad</A>
<A HREF="#The_Options_Menu">The Options Menu</A>
<A HREF="#The_Origins_of_GFA-Basic">The Origins of GFA-Basic</A>
<A HREF="#The_Sets_Menu">The Sets Menu</A>
<A HREF="#The_Shell-Listing">The Shell-Listing</A>
<A HREF="#The_Structure_of_Accessories">The Structure of Accessories</A>
<A HREF="#THEN">THEN</A>
<A HREF="#TIME$">TIME$</A>
<A HREF="#TIME$=">TIME$=</A>
<A HREF="#TIMER">TIMER</A>
<A HREF="#TITLEW">TITLEW</A>
<A HREF="#TOPW">TOPW</A>
<A HREF="#TOUCH">TOUCH</A>
<A HREF="#TRACE$">TRACE$</A>
<A HREF="#TRIM$">TRIM$</A>
<A HREF="#TROFF">TROFF</A>
<A HREF="#TRON">TRON</A>
<A HREF="#TRON_#">TRON #</A>
<A HREF="#TRON_proc">TRON proc</A>
<A HREF="#TRUE">TRUE</A>
<A HREF="#TRUNC">TRUNC</A>
<A HREF="#TT?">TT?</A>
<A HREF="#TYPE">TYPE</A>
<A HREF="#Type_Transformation">Type Transformation</A>

<B>U</B>
<A HREF="#Understanding_GFA's_VDI_scheme">Understanding GFA's VDI scheme</A>
<A HREF="#UNTIL">UNTIL</A>
<A HREF="#UPPER$">UPPER$</A>
<A HREF="#Using_GFA-Basic_3_For_The_First_Time">Using GFA-Basic 3 For The First Time</A>
<A HREF="#Using_the_Menu_Shell_Program">Using the Menu Shell Program</A>
<A HREF="#Using_with_DOS_Shells">Using with DOS Shells</A>

<B>V</B>
<A HREF="#V:">V:</A>
<A HREF="#VAL">VAL</A>
<A HREF="#VAL?">VAL?</A>
<A HREF="#VAR">VAR</A>
<A HREF="#Variable_Types">Variable Types</A>
<A HREF="#VARIAT">VARIAT</A>
<A HREF="#VARPTR">VARPTR</A>
<A HREF="#VDI">VDI</A>
<A HREF="#VDI_functions">VDI functions</A>
<A HREF="#VDI_Routines">VDI Routines</A>
<A HREF="#VDI_WORK_OUT()_Array_Table">VDI WORK_OUT() Array Table</A>
<A HREF="#VDIBASE">VDIBASE</A>
<A HREF="#VDIBASE.TXT">VDIBASE.TXT</A>
<A HREF="#VDISYS">VDISYS</A>
<A HREF="#VID:">VID:</A>
<A HREF="#VOID">VOID</A>
<A HREF="#VQT_EXTENT">VQT_EXTENT</A>
<A HREF="#VQT_NAME">VQT_NAME</A>
<A HREF="#VSETCOLOR">VSETCOLOR</A>
<A HREF="#VST_LOAD_FONTS">VST_LOAD_FONTS</A>
<A HREF="#VST_UNLOAD_FONTS">VST_UNLOAD_FONTS</A>
<A HREF="#VSYNC">VSYNC</A>
<A HREF="#VT-52">VT-52</A>
<A HREF="#VT-52_Escape_Code_Table">VT-52 Escape Code Table</A>
<A HREF="#VTAB">VTAB</A>
<A HREF="#V_CLRWK">V_CLRWK</A>
<A HREF="#V_CLSVWK">V_CLSVWK</A>
<A HREF="#V_CLSWK">V_CLSWK</A>
<A HREF="#V_OPNVWK">V_OPNVWK</A>
<A HREF="#V_OPNWK">V_OPNWK</A>
<A HREF="#V_OPNWK()_and_V_OPNVWK()_Input_Parameter_Table">V_OPNWK() and V_OPNVWK() Input Parameter Table</A>
<A HREF="#V_UPDWK">V_UPDWK</A>
<A HREF="#V~H">V~H</A>

<B>W</B>
<A HREF="#W:">W:</A>
<A HREF="#WAVE">WAVE</A>
<A HREF="#WEND">WEND</A>
<A HREF="#WHILE">WHILE</A>
<A HREF="#Window_Commands">Window Commands</A>
<A HREF="#Window_Library">Window Library</A>
<A HREF="#WINDTAB">WINDTAB</A>
<A HREF="#WIND_CALC">WIND_CALC</A>
<A HREF="#WIND_CLOSE">WIND_CLOSE</A>
<A HREF="#WIND_CREATE">WIND_CREATE</A>
<A HREF="#WIND_DELETE">WIND_DELETE</A>
<A HREF="#wind_draw">wind_draw</A>
<A HREF="#WIND_FIND">WIND_FIND</A>
<A HREF="#WIND_GET">WIND_GET</A>
<A HREF="#wind_new">wind_new</A>
<A HREF="#WIND_OPEN">WIND_OPEN</A>
<A HREF="#WIND_SET">WIND_SET</A>
<A HREF="#wind_sget">wind_sget</A>
<A HREF="#WIND_SMP.GFA">WIND_SMP.GFA</A>
<A HREF="#WIND_UPDATE">WIND_UPDATE</A>
<A HREF="#WORD">WORD</A>
<A HREF="#WORD()">WORD()</A>
<A HREF="#WORK_OUT">WORK_OUT</A>
<A HREF="#WRITE">WRITE</A>
<A HREF="#WRITE_#">WRITE #</A>
<A HREF="#W_HAND">W_HAND</A>
<A HREF="#W_INDEX">W_INDEX</A>

<B>X</B>
<A HREF="#XBIOS">XBIOS</A>
<A HREF="#XBIOS()_Table">XBIOS() Table</A>
<A HREF="#XOR">XOR</A>
<A HREF="#XOR()">XOR()</A>
<A HREF="#xSORT">xSORT</A>

<B>*</B>
<A HREF="#!">!</A>
<A HREF="##">#</A>
<A HREF="#$">$</A>
<A HREF="#$%0">$%0</A>
<A HREF="#$%3">$%3</A>
<A HREF="#$%6">$%6</A>
<A HREF="#$*%">$*%</A>
<A HREF="#$*&">$*&</A>
<A HREF="#$B+">$B+</A>
<A HREF="#$C+">$C+</A>
<A HREF="#$C-">$C-</A>
<A HREF="#$compiler_option">$compiler option</A>
<A HREF="#$E#">$E#</A>
<A HREF="#$E$">$E$</A>
<A HREF="#$F%">$F%</A>
<A HREF="#$F&#60;">$F&#60;</A>
<A HREF="#$F&#62;">$F&#62;</A>
<A HREF="#$I+">$I+</A>
<A HREF="#$I-">$I-</A>
<A HREF="#$M">$M</A>
<A HREF="#$N+">$N+</A>
<A HREF="#$N-">$N-</A>
<A HREF="#$P&#60;">$P&#60;</A>
<A HREF="#$P&#62;">$P&#62;</A>
<A HREF="#$RC%">$RC%</A>
<A HREF="#$RC&">$RC&</A>
<A HREF="#$S%">$S%</A>
<A HREF="#$S&">$S&</A>
<A HREF="#$S&#124;">$S&#124;</A>
<A HREF="#$S&#60;">$S&#60;</A>
<A HREF="#$S&#62;">$S&#62;</A>
<A HREF="#$U">$U</A>
<A HREF="#$U+">$U+</A>
<A HREF="#$U-">$U-</A>
<A HREF="#$Ux">$Ux</A>
<A HREF="#$X">$X</A>
<A HREF="#%">%</A>
<A HREF="#&">&</A>
<A HREF="#&#124;">&#124;</A>
<A HREF="#&#60;">&#60;</A>
<A HREF="#&#60;&#62;">&#60;&#62;</A>
<A HREF="#&#60;=">&#60;=</A>
<A HREF="#&#62;">&#62;</A>
<A HREF="#&#62;&#60;">&#62;&#60;</A>
<A HREF="#&#62;=">&#62;=</A>
<A HREF="#&H">&H</A>
<A HREF="#&O">&O</A>
<A HREF="#&X">&X</A>
<A HREF="#'">'</A>
<A HREF="#()">()</A>
<A HREF="#*">*</A>
<A HREF="#*var=">*var=</A>
<A HREF="#*variable_pointer">*variable pointer</A>
<A HREF="#+">+</A>
<A HREF="#-">-</A>
<A HREF="#-s">-s</A>
<A HREF="#-t">-t</A>
<A HREF="#.">.</A>
<A HREF="#.dot_commands">.dot commands</A>
<A HREF="#.FF">.FF</A>
<A HREF="#.FO">.FO</A>
<A HREF="#.HE">.HE</A>
<A HREF="#.IN">.IN</A>
<A HREF="#.L+">.L+</A>
<A HREF="#.L-">.L-</A>
<A HREF="#.LL">.LL</A>
<A HREF="#.LR">.LR</A>
<A HREF="#.N0">.N0</A>
<A HREF="#.Nx">.Nx</A>
<A HREF="#.P+">.P+</A>
<A HREF="#.P-">.P-</A>
<A HREF="#.PA">.PA</A>
<A HREF="#.PL">.PL</A>
<A HREF="#/">/</A>
<A HREF="#/*">/*</A>
<A HREF="#//">//</A>
<A HREF="#256_color_VDI/Hardware_table">256 color VDI/Hardware table</A>
<A HREF="#:">:</A>
<A HREF="#;">;</A>
<A HREF="#=">=</A>
<A HREF="#=&#60;">=&#60;</A>
<A HREF="#=&#62;">=&#62;</A>
<A HREF="#==">==</A>
<A HREF="#==&#62;">==&#62;</A>
<A HREF="#?">?</A>
<A HREF="#@">@</A>
<A HREF="#@func">@func</A>
<A HREF="#\\">\\</A>
<A HREF="#^">^</A>
<A HREF="#_appl_yield">_appl_yield</A>
<A HREF="#_C">_C</A>
<A HREF="#_DATA">_DATA</A>
<A HREF="#_DATA=">_DATA=</A>
<A HREF="#_X">_X</A>
<A HREF="#_Y">_Y</A>
<A HREF="#{}">{}</A>
<A HREF="#~">~</A>
<HR>
eof
</PRE>
</BODY>
</HTML>
