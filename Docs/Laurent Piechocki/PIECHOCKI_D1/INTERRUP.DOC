
                         ππππππππππππππππππππππππ
                         Les INTERRUPTIONS et les

                            VARIABLES  SYSTEME

                         ππππππππππππππππππππππππ


 Avant de commencer Ö vous parler des programmes sous interruption, nous
 allons Çtudier:

                        *** LES VARIABLES SYSTEME ***
                        πππππππππππππππππππππππππππππ

- Les VARIABLES SYSTEME sont diverses informations qui nous sont dispo-
  nibles en lecture et en Çcriture et qui se situent au dÇbut du second
  KO de la RAM de notre ST. (L'emplacement en RAM varie si vous possädez
  un MEGA ST au un ST dont le systäme d'exploitation (le TOS) n'est pas
  en ROM, mais il ne varie pas entre les diffÇrentes versions de ROM)
  
- Pour atteindre ces variables, il faudra d'abord se positonner en MODE
  SUPERVISEUR, sinon attention au plantage...(Erreur de BUS:2 bombes !)
  Les variables systämes sont soit des OCTETS soit des MOTS soit des L-M.

- Nous allons nous servir de certaines de ces VARIABLES SYSTEME, elles
  influences grandement le fonctionnement du ST:

  VoilÖ les adresses ou se situent ces diffÇrentes variables ainsi que
  leurs noms , leurs tailles et leurs utilitÇ:

  Les noms ci-dessous sont les noms standard donnÇs par ATARI Ö ces
  variables ,les adresses qui leur sont attribuÇes sont uniquement
  valables pour les ST avec le TOS en RAM.


  
  ADRESSE |  NOM    + TAILLE  |  UTILITê      

  . $400   evt_timer    (.L)  : C'est un vecteur qui pointe sur l'adresse
                                $FCA648 ( Je donne les adresses valables 
                                pour les ST avec TOS en ROM ) et qui per-
                                met l'exÇcution des fonctions pÇriodiques
                                du GEM.    

  . $404   evt_critic   (.W)  : C'est un vecteur qui pointe sur l'adresse
                                $2A156 et qui est utilisÇ quand le systäme
                                d'exploitation doit traiter une erreur pro
                                venant du lecteur de disquette. ( Lecteur
                                ne rÇpond pas... )   

  . $408   evt_term     (.L)  : C'est un vecteur qui est utilisÇ par les
                                fonctions de type _TERM du Gemdos qui ser-
                                vent Ö finir l'exÇcution d'un programme.

  . $40C   evt_xtra   5*(.L)  : 5 L-M y sont rÇservÇs pour des 
                                applications futures...

  . $420   memvalid     (.L)  : SÇmaphore pour une configuration de
                                controleur de mÇmoire valide.

  . $424   memctrl      (.B)  : Si memctrl=4 l'ordi est un 520  ST
                                Si memctrl=5 l'ordi est un 1040 ST   
                                Si memctrl=10 c'est un MEGA ST
                                Si memctrl=0 c'est un 128 ST

  . $426   resvalid     (.L)  : Si il vaut $31415926 (soit PI sans la vir-
                                gule) l'adresse pointÇe par resvector sera
                                utilisÇe comme vecteur lors d'un RESET.

  . $42A   resvector    (.L)  : Le vecteur utilisÇ par resvalid lors d'un
                                RESET.

  . $42E   phystop      (.L)  : Adresse de la fin de la mÇmoire vidÇo 
                                physique.

  . $432   _membot      (.L)  : Adresse du dÇbut de la zone de la mÇmoire
                                rÇservÇe pour le programmeur.(voir organi-
                                sation de la mÇmoire plus loin)

  . $436   _memtop      (.L)  : Adresse de la fin de cette zone ( $78000
                                pour un 520 ST ou $F8000 pour un 1040 ST)

  . $43A   memval2      (.L)  : Si memval2=$237698AA, le L-M confirme
                                memvalid

  . $43E   flock        (.L)  : Si flock est diffÇrent de 0, la VBL est
                                arràtÇe (Voir plus loin pour VBL)

  . $440   seekrate     (.W)  : Permet de selectionner la vitesse de dÇ-
                                placement de la tàte de lecture du lecteur
                                de disquette d'une piste :
                                0=6 ms,1=12 ms,2=2 ms,3=3 ms

  . $442  _timer_ms     (.W)  : Temps ÇcoulÇ entre 2 appels du timer, soit
                                la vitesse des battements de l'horloge in-
                                terne. (en millisecondes)
                                Vous y trouverez toujours 20 ms soit 50 Hz
                                (Voir plus loin pour les TIMERS)

  . $444  _fverify      (.W)  : Si _fverify est diffÇrent de 0, il y a un
                                test d'Çcriture qui est effectuÇ par le 
                                lecteur de disquette:A chaque Çcriture, il
                                relit l'octet Çcris et le compare a l'oc-
                                tet Ö Çcrire.
                                En cas d'erreur, on obtient un code 
                                d'erreur  
  
  . $446  _bootdev      (.W)  : Contient le numÇro du lecteur de disquette
                                qui a chargÇ le systäme d'Çxploitation.

  . $448  palmode       (.W)  : Drapeau qui indique soit que le systäme se
                                trouve en mode vidÇo 50 Hz (PAL) si palmo-
                                de est diffÇrent de 0 soit qu'on est en 
                                mode vidÇo 60 Hz (Standard NTSC) 
  
  . $44A  defshiftmd    (.W)  : Contient la rÇsolution de l'Çcran dans la-
                                quelle on se trouve si on passe d'un Çcran
                                Haute rÇsolution Ö un Çcran Couleur.
                                (0=basse,1=moyenne)
  
  . $44C  sshiftmd      (.W)  : Contient la rÇsolution de l'Çcran dans la-
                                quelle on se trouve:0=BASSE,1=MOYENNE,
                                2=HAUTE
 
  . $44E  _v_bas_ad     (.L)  : Contient l'adresse du dÇbut de la mÇmoire
                                vidÇo logique.C'est obligatoirement un
                                multiple de 256

  . $452  vblsem        (.W)  : Si cette valeur est nulle, la VBL n'est
                                plus exÇcutÇe:Voir plus loin pour la VBL

  . $454  nvbls         (.W)  : Contient le nombre de routines exÇcutÇes
                                lors du VBL (Logiquement 8)

  . $456  _vblqueue     (.L)  : Vecteur qui pointe sur les adresses des
                                routines exÇcutÇes lors du VBL

  . $45A  colorptr      (.L)  : Si ce L-M est diffÇrent de 0,il est inter-
                                prÇtÇ comme l'adresse d'une nouvelle 
                                palette de couleurs.

  . $45E  screenpt      (.L)  : Si ce L-M n'est pas nul, il sera interprÇ-
                                tÇ comme l'adresse de la nouvelle mÇmoire 
                                vidÇo physique.

  . $462  _vbclock      (.L)  : C'est le compteur d'interruptions de la
                                VBL (Voir le chapitre suivant)

  . $466  _frclock      (.L)  : Contient le nombre de routines VBL qui ne 
                                sont pas bloquÇes par vblsem.
                                Ce nombre sert aussi Ö la fonction RANDOM
                                de l'XBIOS pour obtenir un nombre alÇatoi-
                                re.

  . $46A  hdv_init      (.L)  : Vecteur qui pointe sur la routine d'ini-
                                tialisation du disque dur en $FC0D60

  . $46E  swv_vec       (.L)  : Vecteur qui pointe sur la routine exÇcutÇe
                                lorsqu'on dÇconnecte ou connecte un moni-
                                teur monochrome (en $FC0020).
   
  . $472  hdv_bpb       (.L)  : Voir la fonction de code $7 du BIOS
                                (Getbpb)

  . $476  hdv_rw        (.L)  : Vecteur qui pointe sur les routines d'Çcr-
                                iture et de lecture de donnÇes sur disque
                                dur.

  . $47A  hdv_boot      (.L)  : Vecteur qui pointe sur la routine de
                                lancement (BOOT) du disque dur

  . $47E  hdv_mediach   (.L)  : Vecteur pour la routine MEDIACH du disque
                                dur (Pour tester si on change le disque :
                                voir MEDIACH de code $4 dans le BIOS)
  
  . $482  _cmdload      (.W)  : Si cette variable est diffÇrente de 0, le
                                programme nommÇ 'COMMAND.PRG' sera chargÇ 
                                däs que le systäme d'exploitation est mis
                                en place.Cette variable devra ätre modifi-
                                Çe sur le BOOT SECTOR.
  
  . $484  conterm        (.B) : C'est un vecteur bit dont les 4 premiers
                                bits sont utilisÇs.Si un de ces bits est
                                actif,la fonction est utilsÇe, sinon elle
                                est dÇconnectÇe.
                                Bit nr¯ 0 :BIP Ö chaque touche enfoncÇe
                                Bit nr¯ 1 :RÇpÇtition au clavier
                                Bit nr¯ 2 :Control+G donne un BIP
                                Bit nr¯ 3 :Permet de rägler la fonction
                                           BCONIN du BIOS.
   
  . $492  themd2         (.L) : Adresse du dÇbut de la mÇmoire disponible
     
  . $496  themd3         (.L) : Adresse de la fin de la mÇmoire disponible   
 
  . $4A2  savptr         (.L) : Adresse ($90C) qui pointe une zone de la
                                mÇmoire utilisÇe pour la sauvegarde des
                                registres par le PROCESSEUR apräs un appel
                                Ö une fonction BIOS ou XBIOS

  . $4A6  _nflops        (.W) : Contient le nombre de lecteurs de 
                                disquette connectÇs.

  . $4A8  con_state      (.L) : Vecteur pointant sur les routines de code
                                ('ESC' + 'valeur') pour les effets des 
                                Çditions graphiques de texte.

  . $4AC  save_row       (.W) : MÇmoire temporaire de la position du cur-
                                seur du texte pour la fonction ESC+'Y'

  . $4AE  sav_context    (.L) : Adresse pointant sur une mÇmoire tempo-
                                raire utilisÇe en cas de traitement d'une
                                procÇdure d'exeption. 
  
  . $4BA  _hz_200        (.L) : Le timer du systäme qui est incrÇmentÇ
                                200 fois par seconde.

  . $4BC  _the_env       (.L) : La chaine de caractäre prise par dÇfaut ,
                                positionnÇe sur 4 octets nuls...
   
  . $4C2  _drvbits       (.L) : Vecteur bit reprÇsentant suivant le nr¯ du
                                bits actif le ou les drives connectÇs.
  
  . $4C6  _dskbufp       (.L) : Tampon de 1 KO utilisÇ par les opÇrations
                                de disk.
  
  . $4CE  _vbl_list    8*(.L) : Vecteur qui pointe sur les adresses des 8
                                routines qui sont exÇcutÇes dans la VBL.

  . $4EE  _dumpflg     8*(.L) : SÇmaphore utilisÇe par la fonction de
                                Hardcopy activÇe par l'appui de Alternate
                                et Help.

  . $4F2  _sysbase       (.L) : Adresse du dÇbut du systäme d'exploitation
                                ($FC0000 sur les ST avec TOS en ROM)

  . $4FA  _end_tos       (.L) : Adresse de la fin du systäme d'exploita-
                                tion ($A100 sur les ST avec TOS en ROM)   

  . $4FE  exec_os        (.L) : Adresse du dÇbut de l'AES ($FD91D0)

  . $502  dump_vec       (.L) : Vecteur qui pointe sur la routine de
                                hardcopy de la fonction 20 du XBIOS.

  . $506  prt_stat       (.L) : SÇmaphore pour l'Çtat de l'imprimante

  . $50A  prt_vec        (.L) : Vecteur pour les fonctions d'Çdition sur
                                imprimante
  
  . $50E  aux_sta        (.L) : Vecteur de recherche d'Çtat utilisÇ par
                                une fonction de Hardcopy

  . $512  aux_vec        (.L) : Vecteur de sortie utilisÇ par une fonction
                                de Hardcopy
  

  VoilÖ la liste de ces variables systämes, pour les modifier, il suffira
  donc de se mettre en MODE SUPERVISEUR et d'y dÇposer la valeur que vous
  voulez...(Vous pouvez bien sur aussi vous contenter de lire les donnÇes
  qui y sont dÇposÇes...) 


  Ainsi, si vous voulez connaitre la rÇsolution:
  Vous Çcrirez:

 *  ;LECTURE d'une VARIABLE SYSTEME:
 
       SUPER               ;MACRO de passage en MODE SUPERVISEUR
       move.w   $44C,d0    ;$44C=sshiftmd

  et Vous obtenez la rÇsolution de l'Çcran dans d0.W !!!


  Si vous voulez changer la palette des couleurs, vous Çcrirez:   

 *  ;ECRITURE sur une VARIABLE SYSTEME:

       SUPER                ;MACRO de passage en MODE SUPERVISEUR
       move.l  #PAL,$45A    ;adresse de 'PAL' en $45A=colorptr

       DATA

  PAL  DC.W    $777,$007,$700,$070,$777,$777,$777,$777  ;les 16 couleurs
       DC.W    $777,$777,$777,$000,$000,$123,$456,$789    

   et Vous changez la palette des couleurs !!!

  
  Cette mÇthode s'applique Ö toutes les variables systäme...

  Ces variables prÇsentent un träs grand intÇràt pour nous car grÉce
  Ö elles, il n'est plus utile d'appeller certaines fonctions du BIOS, 
  de l'XBIOS ou du GEMDOS pour obtenir des effets graphiques de base 
  comme le changement de la palette,obtenir la rÇsolution... :
  VoilÖ qui nous sera vraiment träs utile car ces variables systämes se
  laissent träs facilement modifier ou lire.Mais le plus grand intÇràt
  qu'on peut en tirer,c'est que modifer une variable systäme ne nÇcessi-
  te pas l'utilisation de registres (SP ou des valeurs en RETOUR) ,con-
  trairement aux fonction de BIOS,XBIOS ou GEMDOS...
  Cela nous sera vraiment träs utile quand nous ferons nos premiers 
  programmes sous interruption...




                *** LES PROGRAMMES SOUS-INTERRUPTION ***
                ππππππππππππππππππππππππππππππππππππππππ

- Un programme sous interruption est un programme qui doit ätre exÇcutÇ
  pÇriodiquement, Ö intervals rÇguliers.
  Un tel programme sera source d'un TRAITEMENT D'EXCEPTION:
  Il sera exÇcutÇ si une certaine condition est vÇrifiÇe ( En pratique:
  apräs l'Çcoulement d'un certain temps de latence ) et sera interrompu 
  ( Däs la rencontre d'instructions prÇvues Ö cet effet ) pour n'àtre Ö
  nouveau appelÇ que lorsque la condition se retrouvera rÇalisÇe.

  Un programme sous-interruption n'arräte aucune fonction de l'ordi.:
  Il est entiärement gärÇ Ö part.
  Il est tout Ö fait possible que votre programme principal effectue 
  une boucle et qu'EN MEME TEMPS, un programme sous interruption s'e-
  xÇcute sans interrompre le programme principal !!
  C'est d'ailleurs cette propriÇtÇ qui rend les programmes sous inter-
  ruption si utiles...
  (Pour ne pas dire indispensable, car il existe toujours des routines
  sous interruption qui sont activÇes en permanence pour des raisons
  vitales ...) 
  Nous Çtudierons tout cela en dÇtail träs bientot, pas de panique !
  

- Il existe des ROUTINES D'EXCEPTION qui sont exÇcutÇes par le systäme
  d'exploitation si une certaine condition (spÇcifique) est vÇrifiÇe.
  Ce sont des programmes exÇcutÇs exeptionnelement (d'oó leur nom !),
  c.Ö.d. si la condition qui les actives se trouve rÇalisÇe.

  Ces programmes d'exception sont pointÇs par une suite de VECTEURS qui
  se situent dans le premier KO de la mÇmoire et qui pointent l'adresse
  de la ROUTINE D'EXCEPTION conscernÇe.
  Ils sont responsables d'un certain nombre de fonctions vitales de  
  notre MICROPROCESSEUR.

  On peut considärer que les programmes sous interruption sont des
  programmes d'exception.

  En pratique:

  Vous avez surement dÇjÖ vu un certain nombre de BOMBES s'afficher Ö
  l'Çcran quand vous avez crÇÇ un programme qui ne marchait pas corr-
  ectement.Ces bombes servent Ö identifier la source de l'erreur pour
  le programmeur (ou l'utilisateur) et proviennent d'un traitement
  d'exception.
  Il existe 255 VECTEURS D'EXCEPTION et le  nombre de bombes qui 
  s'affichent vous renseigne sur le nr¯ de l'exception qui a ÇtÇ 
  solicitÇ.

   
  VoilÖ les diffÇrents VECTEURS D'EXECPTION ainsi que leurs emplacements
  en mÇmoire.
  Ce sont des L-M car ce sont des ADRESSES qui pointent sur des routines
  spÇcifiques au VECTEUR conscernÇ.


  NR¯ DU VECTEUR  :  ADRESSE  DU  :  ROUTINE et UTILISATION
                       VECTEUR

     0            :     $000      :SP apräs un RESET (.L)
     1            :     $004      :PC apräs un RESET (.L)
     2            :     $008      :ERREUR de BUS (2 BOMBES)
     3            :     $00C      :ERREUR d'ADRESSE (3 BOMBES)
     4            :     $010      :INTRUCTION ILLêGALE (4 BOMBES)
     5            :     $014      :ERREUR car une DIVISION par ZêRO a ÇtÇ
                                   dÇtectÇe. 
                                   (La routine n'est en fait qu'un RTE !)  
     6            :     $018      :UtilisÇ par CHK
     7            :     $01C      :UtilisÇ par TRAPV
     8            :     $020      :VIOLATION DE PRIVILEGE:On a essayÇ de
                                   toucher Ö des donnÇes uniquement acc-
                                   Çsibles en MODE SUPERVISEUR
     9            :     $024      :Adresse de la routine exÇcutÇe apräs
                                   chaque instruction en mode TRACE
    10            :     $028      :ERREUR d'Çmulation de LINEA
    11            :     $02C      :ERREUR d'Çmulation de LINEF
    12 Ö 14       :     $030      :RÇservÇ pour des applications futures
    15            :     $03C      :INTERRUPTION NON INITIALISêE
    16 Ö 23       :     $040      :RÇservÇ pour des applications futures
    24            :     $060      :INTERRUPTION secondaire
    25            :     $064      :IPL 1
    26            :     $068      :IPL 2
    27            :     $06C      :IPL 3
    28            :     $070      :IPL 4
    29            :     $074      :IPL 5
    30            :     $078      :IPL 6
    31            :     $07C      :IPL 7
    32            :     $080      :UtilisÇ par TRAP #0
    33            :     $084      :UtilisÇ par TRAP #1 (GEMDOS)
    34            :     $088      :UtilisÇ par TRAP #2 (AES/VDI) 
    35            :     $08C      :UtilisÇ par TRAP #3
    36            :     $090      :UtilisÇ par TRAP #4
    37            :     $094      :UtilisÇ par TRAP #5
    38            :     $098      :UtilisÇ par TRAP #6
    39            :     $09C      :UtilisÇ par TRAP #7
    40            :     $0A0      :UtilisÇ par TRAP #8
    41            :     $0A4      :UtilisÇ par TRAP #9
    42            :     $0A8      :UtilisÇ par TRAP #10
    43            :     $0AC      :UtilisÇ par TRAP #11
    44            :     $0B0      :UtilisÇ par TRAP #12
    45            :     $0B4      :UtilisÇ par TRAP #13 (BIOS)
    46            :     $0B8      :UtilisÇ par TRAP #14 (XBIOS)
    47            :     $0BC      :UtilisÇ par TRAP #15
    48 Ö 63       :     $0C0      :RÇservÇ
    64 Ö 255      :     $100      :disponibles Ö l'utilisateur, on y
                                   trouve notament:
    68            :     $110      :Interruption du TIMER D
    69            :     $114      :Interruption du TIMER C
    72            :     $120      :Interruption du TIMER B
    77            :     $134      :Interruption du TIMER A
      
   
  Le dÇtail viendra plus loin.
  En pratique, si votre programme affiche 3 BOMBES avant de rendre l'Éme,
  c'est qu'une erreur d'adresse a ÇtÇ dÇtectÇe, si il en affiche 4,c'est
  qu'une instruction illÇgale a ÇtÇ dÇtectÇe...


  VoilÖ maintenant comment l'ordi. s'y prend pour exÇcuter une ROUTINE
  d'EXEPTION:
  
  .Sauvegarde de SR dans un registre interne.
  .Passage en mode SUPERVISEUR par activation du bit S de SR.
  .Anulation du mode TRACE par extinction du bit T du SR (Explications
   sur le Mode TRACE plus loin).
  .Recherche du vecteur d'exeption Ö utiliser.
  .Empilement du PC et du SR dans la pile systäme.
  .Chargement dans le PC de l'adresse que contient le VECTEUR d'EXCEPTION
   choisi :Saut Ö la routine correspondante...
  .ExÇcution du programme d'exCeption et retour däs la rencontre d'un
   RTE (Return From Exception)
  .Restauration des registres SR et PC.   

   Il est tout Ö fait possible de modifier ces vecteurs, il suffit de
   dÇpose l'adresse (L-M) de la nouvelle routine Ö exÇcuter Ö l'adresse
   du vecteur Ö modifer. (MOVE.L  #NEW,$vecteur)
   Ceci aurra pour effet de dÇtourner l'exÇcution de la ROUTINE D'EXCEP-
   TION vers votre propre routine...
   Nous verrons cela en dÇtail quand je parlerais du mode TRACE.


  Mais revenons Ö nos programmes sous interruption.

  Pour pouvoir gärer plusieurs programmes sous interruption en màme temps
  ,il faudra attribuer un NIVEAU DE PRIORITê Ö notre programme sous inter-
  ruption.
  Plus ce NIVEAU DE PRIORITê sera ÇlevÇ, et plus grande sera l'importance
  accordÇe Ö notre programme dans la hiÇrarchie.

  Le NIVEAU DE PRIORITê de notre programme sera dÇfinit par l'Çtat des
  BITS I1,I2,I3 du REGISTRE D'ETAT 'SR' (Disponible UNIQUEMENT en MODE
  SUPERVISEUR !!)

  Ces 3 BITS permettent de dÇfinir 8 niveaux de prioritÇ.

  BITS    I1   I2   I0  =  % NIVEAU  (ou Interrupt Priority Level)

   %      1    1    1         7  
   %      1    1    0         6
   %      1    0    1         5
   %      1    0    0         4
   %      0    1    1         3
   %      0    1    0         2
   %      0    0    1         1
   %      0    0    0         0

   
   Un programme de NIVEAU D'INTERRUPTION (ou d'Interrupt Priority Level
   :'IPL') 0 sera donc interrompu par tout autre programme d'IPL Ú 1,un
   programme d'IPL 1 ne sera interrompu que par un programme d'IPL Ú 2
   mais restera indiffÇrent Ö un programme sous interruption d'IPL 0,et
   celui-ci ne sera donc pas exÇcutÇ car son IPL est < 1 etc...

   Le NIVEAU 0 est thÇoriquement celui de votre programme.
   (Niveau le plus bas)
   Le NIVEAU 7 est thÇoriquement le niveau d'IPL qui permettra au prg
   sous interruption qui en est affectÇ qu'aucun autre programme sous
   interruption ne puisse l'interrompre.
   (Il pourrait par exemple s'agir du RESET,qui a une prioritÇ ABSOLUE)
   
   . En pratique, seuls les niveaux 2,4 et 6 sont utilisÇs.

          l'IPL 2 est utilisÇ par le HBL
          l'IPL 4 est utilisÇ par les routines du VBL
          l'IPL 6 est utilisÇ par les interruptions du MFP 68901
      
  
   le HBL: Horizontal BLank
   πππππππ
   Il s'agit en rÇalitÇ d'une routine exÇcutÇe apräs que le SHIFTER 
   affiche 1 ligne horizontale sur l'Çcran.
   Suivant le type de moniteur connectÇ, la routine est appellÇe toutes
   les 50 microsecondes (50Hz) ou toutes le 64 microsecondes (64 Hz) 
   Un moniteur couleur possäde 200 lignes horizontales, l'Çcran est 'ra-
   fraichit' 50 fois par secondes (50 Hz), la routine de l'HBL est donc
   appelÇ 10000 fois par seconde dans certaines conditions !
   Cette routine ralentirait ÇnormÇment l'ordi. ,c'est pourquoi la routine
   de l'HBL n'est pas exÇcutÇe. (heuresement pour nous !)
   En effet, däs son premier appel,la routine positionnera automatiquement
   l'IPL de notre programme sur un niveau d'IPL 3: la routine ne sera donc
   plus appellÇe car elle a un niveau d'IPL 2...

   NB: Il est possible de dÇtourner cette routine:
   ππ
       Il suffit de dÇposer l'adresse de votre routine dans le 26¯äme 
       VECTEUR d'EXCEPTION qui pointe sur la routine de l'HBL (.L) et
       de remettre l'IPL du programme Ö un niveau < 2 ( En modifiant  
       les bits I1,I2,I3 du registre d'Çtat )
       Votre routine devra aussi se terminer par l'instruction RTE 
       (Return From Exception), mais nous en reparlerons bientot...
       (Le tout en mode SUPERVISEUR, ne l'oubliez pas !)


  les routines du VBL :Vertical BLank
  πππππππππππππππππππ
  Elles ont un niveau d'interruption 4, elles sont donc prioritaires
  vis-Ö-vis de l'interrution de l'HBL.
  Ces routines sont exÇcutÇes apräs qu'un Çcran graphique ( 200 ou 400 
  lignes horizontales suivant la rÇsolution) ait ÇtÇ ÇditÇ en entier sur
  le moniteur.
  Elles s'exÇcutent donc 50 fois par seconde (50 Hz).
   
  Les routines de la VBL s'occuppent du changement de la palette des
  couleurs ( Uniquement apräs qu'une image a ÇtÇ dessinÇe en entier 
  pour Çviter de perturber l'image ),elles testent le changement de 
  disquette ...
  Il y a en tout 8 routines, le nombre de routines disponibles est
  contenu dans la variable systäme NVBLS et il existe un vecteur 
  qui pointe sur les 8 adresses de ces routines, en VBLQUEUE.
  En rÇalitÇ, seule 1 routine est exÇcutÇe : Les 7 autres nous sont
  donc disponibles... 
  
    
  Les interruptions du MFP 68901 (Multi Fonction Peripheral)
  ππππππππππππππππππππππππππππππ
  Le MFP 68901 gÇre 16 interruptions,elles ont un niveau de prioritÇ 6,
  elles sont donc prioritaires vis-Ö-vis des interruptions VBL et HBL.
  Les 16 interruptions du MFP 68901 ont aussi des niveaux de prioritÇ
  diffÇrent entre elles !
  Ainsi, une interruption du MFP de niveau 6 ne pourra que ätre inter-
  rompue par une autre interruption de niveau > 6      etc...  

  VoilÖ les diffÇrentes interruptions du MFP 68901 , classÇes par
  niveau de prioritÇ (notÇ x sur l'ILP 6 du MFP ).


  NIVEAU (x/6) : L'interruption
               
     15/6      : DÇtecteur de branchement ou de dÇbranchement du moniteur
                 haute rÇsolution
     14/6      : Ring indicator de l'interface RS232
     13/6      : TIMER A de l'horloge interne
     12/6      : Tampon de rÇception d'1 caractäre Ö parir de la RS232
                 destinÇ Ö l'utilisateur
     11/6      : Erreur de rÇception d'1 caractäre provenant de 
                 l'interface RS232
     10/6      : Tampon temporaire d'Çmission d'1 caractäre Ö destination
                 de la RS232
      9/6      : Erreur d'Çmission d'1 caractäre provenant de la RS232
      8/6      : TIMER B et Compteur de retour Ö la ligne
      7/6      : Routine de controle des lecteurs de disquette et du DMA
      6/6      : Routines de controle du clavier (ACIAs) et de la prise
                 MIDI (En entrÇe et sortie)
      5/6      : TIMER C utilisÇ par le YM-2149 (Son) ,le clavier et le
                 compteur de synchronisation du systäme (Ö 200 Hz)
      4/6      : TIMER D utilisÇ pour les opÇrations d'Çmission et de
                 rÇception de la RS232
      3/6      : InutilisÇ
      2/6      : Routine de controle du CTS de la RS232
      1/6      : Routine de controle du DCD de la RS232
      0/6      : UtilisÇ par le BUSY de l'interface CENTRONICS pour crÇer
                 un spooler d'imprimante.


  Les termes ci dessus ne seront pas expliquÇs, vous n'aurez pas Ö vous
  en servir de toute maniäre, alors pourquoi compliquer ce qui n'est pas
  dÇjÖ si simple ?

  Nous allons tout de mäme dÇtailler et expliquer les modes de fonction-
  nement des TIMERS, car c'est leur programmation qui va nous permettre
  de rÇaliser nos programmes sous interruption.

  Les TIMERS:

  Comme vous avez pu le constater, il existe 4 TIMERS:

  Le TIMER A, le TIMER B, le TIMER C, le TIMER D.

  . Le TIMER A est entiäremet disponible au programmeur et a un niveau
    de prioritÇ 13 au sein du MFP (ÇlevÇ!)
  . Le TIMER B est utilisÇ comme compteur de retour Ö la ligne mais vous  
    pourrez träs facilement le dÇtourner.Il a un niveau de prioritÇ 8 au
    sein du MFP ( IPL < Ö l'IPL du TIMER A)
  . Les TIMERs C et D sont responsables d'un certain nombre de fonctions 
    importantes (gestion du son,du clavier ...), les dÇtourner peut donc
    poser beaucoup de problämes...
    De plus, ils ont un niveau de prioritÇ BAS au sein du MFP, c'est 
    pourquoi nous ne les utiliseront pas pour installer nos program-
    mes sous interrupton.
 
    La programmation des TIMERS se fait d'une maniäre träs particu-
    liäre:
    Il faudra programmer directement les registres du CO-PROCESSEUR MFP
    68901 !!

    Les REGISTRES DU MFP 68901:
    πππππππππππππππππππππππππππ
    On trouve 24 registres d'une taille d'1 OCTET chacun :
    Ces registres se situent en mÇmoire Ö partir de l'adresse $FFFA01
    sur des adresses IMPAIRES.
    
    Ces registres font partie intÇgrante de la mÇmoire de notre ST.
    On peut atteindre tous ces registres en MODE SUPERVISEUR, il
    suffira de dÇposer la nouvelle valeur du registre Ö l'adresse
    correspondante.(Comme avec les variables systäme) 

    Nous n'utiliserons qu'une petite partie de ces registres, les
    voici:


  NR¯) NOM :Indications (ADRESSE)
  πππππππππππππππππππππππππππππππ
    1) GPIP:Drapeau de lecture ou d'Çcriture par le port paralläle
            ($FFFA01)

    2) AER :Donne des information sur le mode de fonctionnement de
            l'interruption 
            ($FFFA03)

    3) DDR :Affecte un sens de transmission (entrÇe ou sortie) aux bits
            du GPIP
            ($FFFA05)     

    4) IERA:Vecteur bit dÇfinissant le niveau d'IPL du MFP Ö bloquer:
            IPLs de 15 Ö 8, Voir les interruptions du MFP plus haut
            ($FFFA07)
   
            Bit 7: niveau 15
            Bit 6: niveau 14
            Bit 5: niveau 13
            Bit 4: niveau 12
            Bit 3: niveau 11
            Bit 2: niveau 10
            Bit 1: niveau  9
            Bit 0: niveau  8

     5) IERB:Vecteur bit dÇfinissant le niveau d'IPL du MFP Ö bloquer:
             IPLs de 8 Ö 0, Voir les interruptions du MFP plus haut
             ($FFFA09)
   
            Bit 7: niveau 7
            Bit 6: niveau 6
            Bit 5: niveau 5
            Bit 4: niveau 4
            Bit 3: niveau 3
            Bit 2: niveau 2
            Bit 1: niveau 1
            Bit 0: niveau 0
            
     6) IPRA:Vecteur bit enclenchÇ automatiquement qui marque l'IPL au
             sein du MFP (bit Ö 1 = IPL actif) qui est activÇ,Voir les
             interruptions du MFP pour les dÇtails sur les IPLs.
             ($FFFA0B)
  
            Bit 7: niveau 15
            Bit 6: niveau 14
            Bit 5: niveau 13
            Bit 4: niveau 12
            Bit 3: niveau 11
            Bit 2: niveau 10
            Bit 1: niveau  9
            Bit 0: niveau  8
  
          
     7) IPRB:Vecteur bit enclenchÇ automatiquement qui marque l'IPL au
             sein du MFP (bit Ö 1 = IPL actif) qui est activÇ,Voir les
             interruptions du MFP pour les dÇtails sur les IPLs.
             ($FFFA0D)
     
            Bit 7: niveau 7
            Bit 6: niveau 6
            Bit 5: niveau 5
            Bit 4: niveau 4
            Bit 3: niveau 3
            Bit 2: niveau 2
            Bit 1: niveau 1
            Bit 0: niveau 0
  
     8) ISRA:Vecteur bit qui donne les interruptions actives.
             Voir les interruptions du MFP plus haut pour les equiva-
             lences des niveaux d'IPLs.
             ($FFFA0F)               

            Bit 7: niveau 15
            Bit 6: niveau 14
            Bit 5: niveau 13
            Bit 4: niveau 12
            Bit 3: niveau 11
            Bit 2: niveau 10
            Bit 1: niveau  9
            Bit 0: niveau  8
                                 
  
     9) ISRB:Vecteur bit qui donne les interruptions actives.
             Voir les interruptions du MFP...
             ($FFFA11)               
     
            Bit 7: niveau 7
            Bit 6: niveau 6
            Bit 5: niveau 5
            Bit 4: niveau 4
            Bit 3: niveau 3
            Bit 2: niveau 2
            Bit 1: niveau 1
            Bit 0: niveau 0

    10) IMRA:Vecteur bit dans lequel on doit indiquer (par un 1),le niveau
             d'IPL qu'on utilise.( bit nr¯ 5=IPL 13 si on utilise le TIMER
             A etc...)  
             ($FFFA13)  

            Bit 7: niveau 15
            Bit 6: niveau 14
            Bit 5: niveau 13
            Bit 4: niveau 12
            Bit 3: niveau 11
            Bit 2: niveau 10
            Bit 1: niveau  9
            Bit 0: niveau  8
 

    11) IMRB:Vecteur bit dans lequel on doit indiquer (par un 1),le niveau
             d'IPL qu'on utilise.( bit nr¯ 5=IPL 5 si on utilise le TIMER
             C etc...)  
             ($FFFA15)
  
            Bit 7: niveau 7
            Bit 6: niveau 6
            Bit 5: niveau 5
            Bit 4: niveau 4
            Bit 3: niveau 3
            Bit 2: niveau 2
            Bit 1: niveau 1
            Bit 0: niveau 0

    12) VR  :Vecteur bit: 

            . Bit nr¯3 permet d'obtenir le mode AUTOMATIC END OF INTERRUPT
              ,dans ce cas (bit nr¯3 Ö 1), il ne sera plus utile de modi-
              fier les registres IPR,ISR,IMR ( Voir la programmation des
              TIMERs plus loin, pas de panique !)
            . Bits nr¯4 Ö 7, permet de modifier le nr¯ du VECTEUR qui sera
              exÇcutÇ    

              ($FFFA17)

     13) TACR:Vecteur bit qui controle le TIMER A:
              ATTENTION, seuls les bits 0 Ö 3 du Registre TACR sont
              utilisÇs !!!
              ($FFFA19) 
               

              .Nr¯ des bits 
               du  registre    ACTION sur le TIMER A et PRêDIVISEUR
              
                |76543210|                                         |
                +--------+-----------------------------------------+

                 ****0000     STOPPE le TIMER A               
                 ****0001     DELAY MODE, /4
                 ****0010     DELAY MODE, /10
                 ****0011     DELAY MODE, /16
                 ****0100     DELAY MODE, /50
                 ****0101     DELAY MODE, /64
                 ****0110     DELAY MODE, /100
                 ****0111     DELAY MODE, /200
                 ****1000     EVENT COUNT MODE
                 ****1001     MODE MESURE D'IMPULSIONS, /4
                 ****1010     MODE MESURE D'IMPULSIONS, /10
                 ****1011     MODE MESURE D'IMPULSIONS, /16
                 ****1100     MODE MESURE D'IMPULSIONS, /50
                 ****1101     MODE MESURE D'IMPULSIONS, /64
                 ****1110     MODE MESURE D'IMPULSIONS, /100
                 ****1111     MODE MESURE D'IMPULSIONS, /200

    C'est le registre TACR qui permet de coder la FRêQUENCE D'APPEL du
    TIMER A.

    EXPLICATIONS:
    πππππππππππππ      

 -  Le MFP 68901 travaille avec une horloge interne de 24,576 Mhz

 -  Le TIMER A est essentiellement composÇ d'un REGISTRE DE CONTROLE et
    d'un REGISTRE DE DONNêE.                    ππππππππππππππππππππ
         ππππππππππππππππππ 
    Le REGISTRE DE CONTROLE indique le mode de fonctionnement du TIMER,
    il s'agit du registre dÇcrit ci-dessus, le registre TACR.
    C'est en positionnant le registre TACR sur les diffÇrentes valeurs 
    acceptÇes (Voir le tableau), qu'on obtient les diffÇrents modes de
    fonctionnement du TIMER:
   
      les diffÇrents MODES DE FONCTIONNEMENT DU TIMER A sont:
      πππππππππππππππππππππππππππππππππππππππππππππππππππππππ
   . Le DELAY MODE:
     ππππππππππππππ
     Le REGISTRE DE DONNêE du TIMER est dÇcrÇmentÇ Ö intervals rÇguliers
     (Ö chaque battement de l'horloge interne contenue dans le diviseur)
     seur)et quand ce registre vaudra 1 ,une interruption sera gÇnÇrÇe.

     NB:  Le registre de DONNêE devra ätre une valeur comprise entre 1 
     πππ  et 255


     Exemple:TACR=%0011 
     πππππππ
     On est en MODE DELAY (voir Tableau)
     Le registre de controle TACR vaut %11 et le prÇdiviseur vaut 16 
     (Regardez le Tableau)   πππππππππππππ       πππππππππππππππππππ 
     Si on positionne le registre de donnÇe sur 200 par exemple, notre
     programme sous interruption sera appelÇ:   πππππππππππππππ

     245760/16/200=76,8 fois par secondes ...
     πππππππππππππ
           +-----------------------------------+    
     Soit: |FREQUENCE DU MFP/PRêDIVISEUR/DONNêE|
           +-----------------------------------+

     Autre Exemple:TACR=%0010 (voir Tableau)
     Le registre de control TACR vaut %10 et le prÇdiviseur vaut 10
     (Regardez le Tableau)  πππππππππππππ       πππππππππππππππππππ       
     Si on positionne le registre de donnÇe sur 32 par exemple, notre
     programme sous interruption sera appelÇ:   ππππππππππππππ

     245760/10/32=768 fois par secondes ...
     ππππππππππππ
           +-----------------------------------+    
     Soit: |FREQUENCE DU MFP/PRêDIVISEUR/DONNêE|
           +-----------------------------------+
 
     J'y reviendrai quand nous Çcrirons nos premiers programmes...
        

    . EVENT COUNT MODE:
      πππππππππππππππππ    
      C'est pareil, sauf qu'ici Le MFP ne tient plus compte 
      du PRêDIVISEUR...

    . Le MODE MESURE DE LARGEUR D'IMPULSION:
      ππππππππππππππππππππππππππππππππππππππ
      Identique au DELAY MODE, mais il peut àtre annulÇ par une actvitÇ
      des broches d'entrÇe ou sortie du MFP.


    
    Nous utiliseront surtout le DELAY MODE ...

    Relisez attentivement ce qui a ÇtÇ dit ici, car c'est vraiment träs
    important...




                              πππππππππππππππππ


   PIECHOCKI   Laurent
   8, Impasse Bellevue              Suite dans le fichier: INTER_2.DOC
   57980  TENTELING                                        πππππππππππ 
   
       

                   
