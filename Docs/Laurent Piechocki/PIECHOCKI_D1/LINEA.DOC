
                           ππππππππππππππππππππ
                              CHAPITRE NR¯8:

                               LES  LINEAS

                           ππππππππππππππππππππ

                    
                           *** INTRODUCTION ***
                           ππππππππππππππππππππ

 - Les lineAs sont des fonctions graphiques, elles sont träs simples  
   mais ont l'aventage d'ätres vraiment träs rapides.
   (Bien plus que le VDI...)
  
   Les LineAs sont des commandes du 'BLITTER', c.Ö.d. que c'est le HARD
   (Certaines composantes PHYSIQUES de l'ordinateur et les routines qui
   sont exÇcutÇes par le PROCESSEUR en personne.) qui exÇcute ces fonc-
   tions et non pas le SOFT (La partie LOGICIELLE de votre ordinateur :
   ROM,programmes...). 
   Si votre ST est equipÇ du BLITTER bien-entendu...(Les MEGA 2ST et les
   MEGA 4ST en sont ÇquippÇs.)    
 
   NB: Il existe un BLITTER LOGICIEL qui est disponible dans le domaine
   πππ public sous la forme d'un accessoir de bureau...
    
   Ces fonctions sont träs rapides puisque ne provenant pas du SOFT, les
   routines n'ont pas besoin d'ätres interprÇtÇes par le PROCESSEUR.

 - Pour appeller les fonctions des LINEAS, il faudra fournir les para-
   mätres appropriÇs dans le TABLEAU du VDI et aussi dans un TABLEAU
   INTERNE propre aux lineAs.
   Certains registres seront aussi utilisÇs.

   En effet, les LineAs utilisent les tableaux CONTROL,PTSIN,PTSOUT,
   INTIN et INTOUT du VDI.
   On se servira aussi des registres d0,d1,d2,a0,a1,a2 , il faudra donc
   faire attention Ö ne pas perdre leur contenu...
   Certains paramätres sont aussi fournis par les LineAs en retour dans
   d0,a0 ou INTOUT (lÖ aussi,attention Ö ne pas perdre d0!)

   Nous avons vu que les LineAs utilisent un TABLEAU INTERNE:

   C'est dans ce tableau que les fonctions recherchent les paramätres
   que nous avons dÇposÇ,le seul probläme est que l'emplacement de ce
   tableau interne varie (d'oó son nom).

   Pour trouver l'emplacement de ce tableau interne, il suffit 
   d'appeller la fonction $A000 avec:

   DC.W  $A000

   Quelle syntaxe Çtrange n'est ce pas ??

   L'explication est träs simple:Lors de l'Çtape d'ASSEMBLAGE de votre
   listing, les codes ASCII reprÇsentant les instructions et leurs opÇ-
   randes, vont àtre traduites en BINAIRE car le 68000 ne reconnait que
   les informations codÇes en binaire:
   Ainsi un NOP sera traduit par %100111001110001, un RTS par %0100111
   001110101 etc... ainsi pour toutes les instructions.
   Si on traduit ces codes du binaire Ö l'HEXADêCIMAL, on obtient des
   instructions codÇs en HEXA:
   Ainsi NOP s'Çcrira:$4E71
   et    RTS s'Çcrira:$4E75  
   etc...   

   Or,
   ππ
   On peut REMPLACER, dans un programme en ASSEMBLEUR, une instruction
   par son Çquivalent en CODE HEXA si on le dÇclare en tant que tel dans
   le segment TEXT, il suffirait donc d'Çcrire:
 
   DC.W  $4E71 Ö la place d'un NOP  (ou DC.B  $4E,$71)
   ou
   DC.W  $4E75 Ö la place d'un RTS ... (ou DC.B  $4E,$75)   

   Ceci reste valable pour toutes les instructions du 68000 (Màme pour 
   les labels).

   Mais,
   ππππ 
   Aucune instruction du 68000 ne sera codÇe en HEXA par un MOT du type:

   $A...  (ou $F...)
 
   On a donc comblÇ se manque (on en a plutot profitÇ oui!) en codant
   les fonctions LineAs en $A...

   NB:Il existe aussi des routines $F... mais nous ne les utiliseront 
   ππ pas parce qu'elles ne sont pas compatibles entre les versions
      ANCIENNE ROM et NOUVELLE ROM du ST.

   Il suffira donc d'Çcrire  DC.W  $A...  pour que le 68000 dÇcode cette
   instruction par l'intruction lineA de code $A...

   Il existe en tout 16 commandes qui sont installÇes et qui peuvent 
   ätres traduites ainsi, ce sont les 16 routines LineAs:

   Pour les appeller il suffit donc de les DêCLARER dans le segment 
   TEXT:

   Les LineAs:
   πππππππππππ
   $A000:Installe le tableau interne
   $A001:Place 1 point sur l'Çcran
   $A002:Donne la couleur d'un point de l'Çcran
   $A003:Trace une ligne quelconque
   $A004:Trace une ligne horizontale
   $A005:Dessine un rectangle plein
   $A006:Dessine un polygone plein
   $A007:?
   $A008:Permet le transfert d'un bloc de texte
   $A009:Active le curseur de la SOURIS
   $A00A:DÇsactive le curseur de la SOURIS
   $A00B:Modifie la forme du curseur de la SOURIS
   $A00C:Efface un sprite
   $A00D:Dessine un sprite
   $A00E:Copie un bloc de points
   $A00F:Identique Ö la fonction CONTOUR FILL du VDI (opcode=103)
     


   Mais revenons maintenat Ö notre fonction $A000:

   Nous avons vu prÇcÇdement qu'elle permet d'initialiser le TABLEAU
   INTERNE dans lequel on dÇposera des paramätres:
   Ce TABLEAU comporte 50 variables qui ont soit la taille d'un MOT
   soit la taille d'un L-M.
   Pour obtenir l'adresse ou commence le tableau, on se sert de la
   fonction $A000:

   DC.W  $A000

   La fonction nous fournit dans A0 l'adresse Ö laquelle se trouve le
   tableau:

   On peut donc maintenant atteindre toutes les variables de ce tableau
   avec un mode d'adressage du type INDIRECT:
   Mais les variables n'ont pas toutes la mäme taille (Mot ou L-M), les
   modes d'adressage (a0)+ et (a0) ne seront donc pas utilisÇs...

   Nous utiliserons le mode d'adressage d(a0) pour atteindre les
   diffÇrents paramätres du tableau:
  
   Ainsi MOVE.W 0(a0) posera le MOT=0 dans le 1¯ paramätre du tableau
         MOVE.W 2(a0) posera le MOT=0 dans le paramätre placÇ Ö a0+2
         etc...

   Il faudrait donc connaitre toutes les valeurs des emplacements rela-
   tifs des variables dans le tableau:Comme la syntaxe d(a0) n'est pas
   träs parlante, nous allons dÇfinir (avec EQU) les emplacemants rela-
   tifs de toutes ces variables:

   Les voici:
   
   
         
; DÇfinition des EQUIVALANCES du TABLEAU INTERNE des LineAs

; NOM de la valiable  =   DÇplacement relatif

v_planes        EQU       0                ;nombre de plans
v_lin_wr        EQU       2                ;octet par ligne d'Çcriture
ticontrol       EQU       4                ;adresse du T.I de CONTROL
tiintin         EQU       8                ;adresse du T.I de INTIN
tiptsin         EQU       12               ;adresse du T.I de PTSIN
tiintout        EQU       16               ;adreses du T.I de INTOUT
tiptsout        EQU       20               ;adresse du T.T de PTSOUT
_fg_bp_1        EQU       24               ;bit 0 de la couleur
_fg_bp_2        EQU       26               ;bit 1 de la couleur
_fg_bp_3        EQU       28               ;bit 2 de la couleur
_fg_bp_4        EQU       30               ;bit 3 de la couleur
_lstlin         EQU       32               ;toujours =-1
_ln_mask        EQU       34               ;forme de la ligne pour $A003
_wrt_mode       EQU       36               ;WRITE MODE
_x1             EQU       38               ;CoordonnÇe X du premier point
_y1             EQU       40               ;CoordonnÇe Y du premier point
_x2             EQU       42               ;CoordonnÇe X du second point
_y2             EQU       44               ;CoordonnÇe Y du second point
_patptr         EQU       46               ;adresse du remplissage
_patmsk         EQU       50               ;nombre de remplissage
_multifill      EQU       52               ;dÇtails plus loin
_clip           EQU       54               ;drapeau de clipping
_xmn_clip       EQU       56               ;X le + Ö gauche pour le clip
_ymn_clip       EQU       58               ;Y le + haut pour le clip
_xmx_clip       EQU       60               ;X le + Ö droite pour le clip
_ymx_clip       EQU       62               ;Y le + bas pour le clip
_xacc_dda       EQU       64               ;pointe sur $8000 pour TXTBLT  
_dda_inc        EQU       66               ;facteur d'agrandissement=$FFFF
_t_sclsts       EQU       68               ;=0                   
_mono_status    EQU       70               ;type de TEXT EFFECTS
_sourcex        EQU       72               ;Nr du caractäre dans le JEU  
_sourcey        EQU       74               ;=0  
_destx          EQU       76               ;CoordonnÇe X du TEXT
_desty          EQU       78               ;CoordonnÇe Y du TEXT  
_delx           EQU       80               ;Largeur du caractäre  
_dely           EQU       82               ;Hauteur du caractäre
_fbase          EQU       84               ;Adresse du JEU  
_fwidth         EQU       88               ;X du JEU
_style          EQU       90               ;FLAG pour TEXT EFFECTS  
_litemark       EQU       92               ;Masque des ombrages  
_skewmask       EQU       94               ;Masque de l'inclinaison TEXT
_weight         EQU       96               ;NB de bits d'Çlargissement  
_r_off          EQU       98               ;DÇcalage pour TEXT italique 
_l_off          EQU       100              ;idem cotÇ gauche (Left)  
_scale          EQU       102              ;Flag agrandissement (1/0)       
_chup           EQU       104              ;Angle de rotation du TEXT  
_txt_fg         EQU       106              ;Couleur du 1¯ plan du TEXT  
_scrtchp        EQU       108              ;Adresse d'1 tampon pour effets  
_scrpt2         EQU       112              ;DÇcalage pour l'agrandissement  
_text_bg        EQU       114              ;Couleur de Back Ground du TEXT  
_copytran       EQU       116              ;FLAG pour le mode d'Çcriture  


   On devine ici träs clairement la structure et la composition du 
   TABLEAU INTERNE:

   Les noms utilisÇs ici sont des noms souvent pris par dÇfaut dans
   de nombreux ouvrages.
   Nous n'utiliseront qu'une petite partie des variables du tableau
   interne...

   Les dÇfinissions des Çquivalences pour le TABLEAU INTERNE se trouvent 
   dans le fichier:LINEQU.L et vous devrez l'inclure dans votre listing 
   au dÇbut du segment TEXT.

   L'utilisation des variables dÇpendra des fonctions, les dÇtails
   viendront donc avec les explications...

   En pratique:

   Pour changer la variable '_patptr' du Tableau Interne, il suffira
   d'Çcrire:

   MOVE  source,_patptr(a0)

   Pour changer la variale '_clip' du Tableau Interne, il suffira
   d'Çcrire:

   MOVE  source,_clip(a0) 

   etc...

   C'est bien plus lisible que d'Çcrire:
   MOVE  source,46(a0)  ou   MOVE  source,54(a0)  ...

   
  Maintenant que notre tableau interne est mis en place avec DC.W $A000,
  il faut encore fournir les adresses des TABLEAUX  CONTROL,INTIN,PTSIN,
  INTOUT et PTSOUT car eux aussi sont utilisÇs !

  Cela se fait tout simplement en dÇposant ces adresses dans les varia-
  bles tiintin,tiptsin,tiintout,tiptsout du TABLEAU INTERNE:

  Il suffit donc d'Çcrire:

     MOVE.L    #CONTROL,ticontrol(a0)
     MOVE.L    #INTIN,tiintin(a0)
     MOVE.L    #PTSIN,tiptsin(a0)
     MOVE.L    #INTOUT,tiintout(a0)
     MOVE.L    #PTSOUT,tiptsout(a0)

  Pour transfärer les adresses dans le TABLEAU INTERNE.


  Cette initialisation Çtant faite, vous pouvez enfin vous servir des 
  routines LineAs.
  
  Tous les programmes que vous Çcrirez devront donc ressembler Ö cela
  si vous utilisez les LINEAS:

     TEXT

     INCLUDE   "INIT_TOS.L"
     INCLUDE   "LINEQU.L"     ;les Çquivalences pour les LineAs

     SETBLOCK                 ;initialise le GEM

     DC.W      $A000          ;on initialise le T.I. ( adresse dans a0)

; On pose les adresses des TABLEAUX du VDI dans le T.I.

     MOVE.L    #CONTROL,ticontrol(a0)
     MOVE.L    #INTIN,tiintin(a0)
     MOVE.L    #PTSIN,tiptsin(a0)
     MOVE.L    #INTOUT,tiintout(a0)
     MOVE.L    #PTSOUT,tiptsout(a0)


     .                        ;ICI, votre programme
     .
     .

     DATA

     .                        ;ICI les donnÇes
     .
     .  

     BSS
     .
     .

     INCLUDE   "TABLEAU.L"    ;le Tableau du VDI

     END




          *** Explication des termes utilisÇs plus loin ***
          πππππππππππππππππππππππππππππππππππππππππππππππππ

- Les CoordonnÇes graphiques:

  Celles-ci permettent de dÇfinir les positions des Çditions graphiques
  Ö partir de leurs coordonnÇes sur l'axe X et l'axe Y.
  
 .L'origine du repäre orthogonal ( O,x,y ) est situÇe au point le plus
  haut et le plus Ö gauche de votre Çcran:il a pour coordonnÇes (0,0).

 .L'axe X va de l'origine O au point opposÇ Ö droite le plus en 
  haut de l'Çcran.

 .L'axe Y descend de l'origine O au point Ö droite le plus bas de votre 
  Çcran.
  
 .Le nombre de points disponibles selon l'axe X et l'axe Y dÇpend de la
  rÇsolution:

  En BASSE rÇsolution  :(OX)=320 pixels (points) de 0 Ö 329
     ππππππππππππππππ   ππππππππ                    πππππππ
                       :(OY)=200 pixels (points) de 0 Ö 199
                        ππππππππ                    πππππππ   
  En MOYENNE rÇsolution:(OX)=640 pixels (points) de 0 Ö 639
     ππππππππππππππππππ ππππππππ                    πππππππ
                       :(OY)=200 pixels (points) de 0 Ö 199
                        ππππππππ                    πππππππ
  En HAUTE rÇsoltuion  :(OX)=640 pixels (points) de 0 Ö 639
     ππππππππππππππππ   ππππππππ                    πππππππ
                       :(OY)=400 pixels (points) de 0 Ö 399
                        ππππππππ                    πππππππ 
  ATTENTION Ö toujours respecter les contraintes graphiques si vous ne
  voulez pas avoir de problämes...


- Le Mode d'Çcriture:dÇfini par la variable _wrt_mode du tableau interne:

  4 modes d'Çcriture sont disponibles:

 .SI _wrt_mode=0:Mode AND,
     πππππππππππ
  Exemple:FOND  =%111011101110110100
  πππππππ:DESSIN=%100011011010100011
    --->RESULTAT=%100011011010100011 (On masque le fond)      

  On obtient:FOND AND DESSIN
   
 .Si _wrt_mode=1:Mode OR,
     πππππππππππ
  Exemple:FOND  =%101100011101010011
  πππππππ:DESSIN=%011011101110001010
    --->RESULTAT=%111111111111011011 

  On obtient FOND OR DESSIN

 .Si _wrt_mode=2:Mode (COULEUR and DESSIN) OR (FOND not DESSIN)
     πππππππππππ
  (C'est le mode graphique TRANSPARENT):

  Les points sont placÇs lÖ oó il n'y en a par encore et si le point Ö
  placer est sans couleur, on efface le point.

 
 .Si _wrt_mode=3:Mode XOR
     πππππππππππ
  Exemple:FOND  =%1101100111000101
  πππππππ:DESSIN=%0110011101011010
    --->RESULTAT=%0110011101111010

  Les pixels du FOND sont inversÇs puis on rÇalise un OR avec le DESSIN:

  On obtient FOND XOR DESSIN      
 

  NB:Le mode graphique utilisÇ par dÇfaut est le mode 0
  ππ 

- Les 4 _fg_bp_B sont au nombre de 4 et servent Ö indiquer la couleur 
  selon le mode suivant:

  _fg_bp_1=le 1¯er bit de la couleur

  _fg_bp_2=le 2¯äme bit de la couleur

  _fg_bp_3=le 3¯äme bit de la couleur

  _fg_bp_4=le 4¯äme bit de la couleur

  Chaque variable ne peut que prendre 1 ou 0 comme valeur.

  
  Ainsi, si on a par exemple:


  _fg_bp_1=0
  _fg_bp_2=1
  _fg_bp_3=1
  _fg_bp_4=0

  La couleur utilisÇe sera la couleur nr¯ %0110=6

  ATTENTION, n'oubliez pas que vous ne disposez pas du màme nombre de
  couleurs dans les diffÇrentes rÇsolution graphiques.

  Ainsi,En BASSE RêSOLUTION: 
        ππππππππππππππππππππ 
  Vous pouvez disposer de toutes les variables _fg_bp_B

        En MOYENNE RêSOLUTION:
        ππππππππππππππππππππππ
  Vous ne pouvez disposer que des variables _fg_bp_1 et _fg_bp_2. 
  _fg_bp_3 ainsi que  _fg_bp_4 devront ätres Çgales Ö 0 car vous ne
  diposez que de 4 couleurs.

        En HAUTE RêSOLUTION:
        ππππππππππππππππππππ
  Vous ne pouvez disposer que de la variable _fg_bp_1 car seules 2
  couleurs sont diponibles en màme temps dans cette rÇsolution.

 
- Le CLIPPING permet de dÇfinir les limites dans lesquelles vos graphi-
  ques pourront àtre dessinÇs Ö l'Çcran. 

  Il faut pour cela modifier les variables _xmn_clip,_ymn_clip et les
  variables _xmx_clip,_ymx_clip du tableau interne:

  _xmn_clip et _ymn_clip dÇfinisent les coordonnÇes X et Y du coin haut
  gauche du CADRE DU CLIPPING.

  _xmx_clip et _ymx_clip dÇfinissent les coordonnÇes X et Y du coin bas
  droit du CADRE DU CLIPPING.

  On utilise aussi un DRAPEAU (ou FLAG en Anglais), c.Ö.d. une variable
  qui sera testÇe pour savoir si le CLIPPING est activÇ ou non ( comme
  avec un SEMAPHORE... )
  
. Si on N'UTILISE PAS le CLIPPING, la variable _clip doit ätre Çgale Ö 0
        πππππππππππππππππππππππππ              πππππ                   π
. Sinon, on positionne le MOT en _clip(a0) dans le tableau interne Ö une
  valeur quelconque.
     

  Exemple:
  ππππππππ
  _clip=1   (diffÇrent de 0, donc le clipping est activÇ)
   
  _xmn_clip=0 , _ymn_clip=0   et
  
  _xmx_clip=50, _ymx_clip=50

  Si on trace un rectangle de coordonnÇes de dÇpart 10,10 et de
  coordonnÇes d'arrivÇe 75,75:
  Seule la partie du rectangle de coordonnÇes de dÇpart 10,10 et de 
  coordonnÇes d'arrivÇe 50,50 serra dessinÇe car le reste du rectangle
  ne rentre pas dans le CADRE du CLIPPING...
 
  Le CLIPPING permet donc de modifier le 'rayon d'action' des fonctions
  graphiques...

  NB:DÇpasser le CADRE DU CLIPPING n'entraine pas d'erreur, mais les
  ππ graphiques reprÇsentÇs hors du cadre ne seront pas affichÇs.


- La variable _multifill du tableau interne permet de crÇer des trames
  de remplissage en plusieurs couleurs.(Pour les options de remplissage)

  Mous mettrons toujours cette variable Ö 0 (remplissage monochrome)

  Cette variable du tableau interne est utilisÇe avec les fonctions qui
  permettent de remplir des surfaces...


- Le PAT (PATERN) sert aux fonctions $A004,$A005,$A006 et permet de
  dÇfinir le type de ligne et le type de remplissage utilisÇ.
  Le type normalment utilisÇ par ces fonctions est '%1111111111111111'
  (MOTIF PLEIN), modifier le PAT permet de modifier le type de lignes
  utilisÇes ainsi que les motifs de remplissages des fonctions $A004,
  $A005 et $A006.
 
  Ainsi, si le PAT vaut %1010101010101010 (MOT) et si on utilise la 
  fonction $A004 par exemple, on traáera une ligne en pointillÇs,si
  le PAT vaut %1111000011110000 (MOT), on obtiendra des pointillÇs
  plus larges et plus espacÇs...
  
  le PAT est dÇfinit par 2 variables du tableau interne:
     πππ     πππππππππππππππππππππππ
 . _patptr (L-M), c'est l'adresse Ö laquelle se trouve un Çchantillon
   de remplissage dÇfinit par un nombre PAIRE de MOTS (voir plus loin)
   
 . _patmsk (MOT), contient le nombre de donnÇes (MOTS) Ö lire -1:
   C'est un nombre toujours IMPAIRE (paire-1).  
     
  
 Ainsi, si _patptr pointe sur 'TABLE', en qu'Ö cette adresse on trouve
 les mots:

 TABLE    DC.W      %1111000011110000    ;adresse 'TABLE':le MOTIF
          DC.W      %0000111100001111
          DC.W      %1010101010101010
          DC.W      %0101010101010101    ;nombre PAIRE de MOTS

 _patmsk sera Çgal Ö 4-1=3

Le MOTIF de remplissage qui sera utilisÇ sera donc un MOTIF d'une largeur
de 16 pixels (les 16 Bits des diffÇrents MOTS,1=bit actif, 0=bit etteind)
et d'une hauteur de 4 lignes (4 MOTS)

 NB: La reprÇsentation en BINAIRE des donnÇes est la ici plus parlante.
 ππ

 Exemples d'utilisation:
 ππππππππ
 On veut dÇfinir des lignes avec de larges pointillÇs:
 On modifie le PAT

      DC.W     $A000               ;a0 pointe sur le T.I.
      
      move.l   #TABLE,_patptr(a0)  ;pose l'adresse du MOTIF dans _patptr
      move     #0,_patmsk(a0)      ;1-1=0 dans _patmsk

      DATA
 
TABLE DC.W     %1111000011110000   ;le MOTIF


  On veut obtenir un remplissage avec des petits carrÇs avec la fonction
  $A005 (filled rectangle):
  On modifie le PAT:

      DC.W     $A000               ;a0 pointe sur le T.I.

      move.l   #TABLE,_patptr(a0)  ;pose l'adresse du MOTIF dans _patptr
      move     #5,_patmsk(a0)      ;8-1=7 dans _patmsk
      
      DATA

TABLE DC.W     %1111111111111111 ;le MOTIF (8 MOTS)
      DC.W     %1100000000000011 
      DC.W     %1101111111111011 ;0=pixel etteind
      DC.W     %1101111111111011
      DC.W     %1101111111111011 ;1=pixel actif
      DC.W     %1101111111111011
      DC.W     %1100000000000011
      DC.W     %1111111111111111


  

                    *** LES ROUTINES LINEAS ***
                    πππππππππππππππππππππππππππ

 Je vais maitenant dÇcrire les routines LINEAS interessantes, je vous
 donnerais les exemples apräs ces explications dans le prochain fichier.
 Les exercices viendront ensuite...
 
 
- $A000
  πππππ
  Fournit dans a0 et d0 l'adresse du tableau interne.
  
  La fonction donne aussi en a1 l'adresse d'un autre tableau qui pointe
  sur les 3 jeux de caractäres utilisÇs par la routine $A008

  On l'appelle par:

  DC.W   $A000     ;Dans le segment TEXT 
                   ;(on peut aussi Çcrire DC.B $A0,$00)
                   ;retour des valeurs dans a0,a1,d0 (attention Ö ne pas
                   ;perdre ces valeurs, sauvez les au besoin!) 


  NB:par la suite, avant d'utiliser les autre fonctions, penssez Ö ini-
  ππ tialiser les variables ticontrol,tiintin,tiptsin,tiintout,tiptsout
     du tableau interne...



- $A001 (PUT PIXEL)
  πππππ
  Permet de placer un point de coordonnÇes (X,Y) sur l'Çcran.

  Les paramätres Ö passer sont:
 
  . X dans ptsin   
  . Y dans ptsin+2
  . La couleur du point (0 Ö 15) dans intin (MOT)

  On l'appelle ensuite par:

  DC.W   $A001     ;Dans le segment TEXT


- $A002 (GET PIXEL)
  πππππ
  Cette fonction permet d'obtenir la couleur d'un point de coordonnÇes
  (X,Y) de l'Çcran.

  Les paramätres Ö passer sont:

  . X dans ptsin
  . Y dans ptsin+2
  
  La couleur (MOT de 0 Ö 15) retourne en INTOUT

  On appelle la fonction par:

  DC.W  $A002  ;Dans le segment TEXT


- $A003 (LINE)
  πππππ
  Permet de tracer une ligne quelconque de coordonnÇes de dÇpart (A,B)
  et de coordonnÇes d'arrivÇe (C,D) sur l'Çcran.
  On peut aussi modifier la couleur de la ligne avec les _fg_bp_B, le 
  type de ligne avec _ln_mask et le mode d'Çcriture avec _wrt_mode.


  Les paramätres Ö passer sont:

  . A dans _x1
  . B dans _y1
  . C dans _x2
  . D dans _y2

  On peut choisir la couleur de la ligne, celle-ci est passÇe dans
  les variables:     πππππππππππππππππππ   

  . _fg_bp_B (Bits B utilisÇs suivant la rÇsolution)

  On peut aussi modifier le type de ligne utilisÇe avec la variable:
                         πππππππππππππππππππππππππ  
  . _ln_mask (MOT)

  Ainsi,si _ln_mask vaut %111111111111111, la ligne sera pleine, si la
  variable vaut %0000111100001111 on obtient des gros pointillÇs etc...
  
  On choisit aussi le MODE d'êCRITURE grÖce Ö la variable:

  . _wrt_mode (MOT =0 Ö 3)


  Ensuite, on appelle la fonction par:

  DC.W    $A003   ;Dans le segment TEXT




- $A004 (H-LINE)
  πππππ
  Permet de tracer une ligne horizontale.(Uniquement HORIZONTALE...)
  Les coordonnÇes de dÇpart sont (A,B) et les coordonnÇes d'arrivÇe
  sont (C,D) telles que B=D (ligne horizontale)
  On peut , tout comme avec $A003, modifier la couleur de la ligne,le
  mode d'Çcriture, et le PAT (avec _patptr et _patmsk)

  H-LINE est une fonction de base et est utilisÇe par les fonctions
  $A003,$A005,$A006:
  Une ligne courbe (routine $A003) n'est en effet rien d'autre qu'une
  succession de portions de lignes horizontales:
  Ceci explique pourquoi H-LINE est plus rapide que LINE.


  Les paramätres Ö passer sont:

  . A dans _x1
  . B dans _y1
  . C dans _x2
  . D dans _y2      ;    _y1 = _y2 (ligne horizontale)

  On peut choisir la couleur de la ligne, celle-ci est passÇe dans
  les variables:     πππππππππππππππππππ   

  . _fg_bp_B (Bits B utilisÇs suivant la rÇsolution)

  On peut aussi modifier le type de ligne utilisÇe avec les variables:
                         πππππππππππππππππππππππππ  
  . _patptr (L-M):l'adresse du MOTIF
  . _patmsk (MOT):le nombre de donnÇes -1

  On choisit aussi le MODE d'êCRITURE grÖce Ö la variable:

  . _wrt_mode (MOT =0 Ö 3)


  On appelle la fonction par:

  DC.W    $A004   ;Dans le segment TEXT



- $A005 (FILLED RECTANGLE)
  πππππ
  Permet de remplir un rectangle de coordonnÇes (A,B) pour le coin haut
  gauche et (C,D) pour le coin bas droit.
  On peut modifier la couleur du rectangle, le type de remplissage et
  le mode d'Çcriture.
  La fonction utilise aussi le CLIPPING si vous le dÇsirez.
 
  En fait, la fonction $A005 utilise la fonction $A004 pour dessiner
  le rectangle...


  Les paramätres Ö passer sont:

  . A dans _x1
  . B dans _y1
  . C dans _x2
  . D dans _y2     

  On peut choisir la couleur du rectangle, celle-ci est passÇe dans
  les variables:     ππππππππππππππππππππ   

  . _fg_bp_B (Bits B utilisÇs suivant la rÇsolution)

  On peut aussi modifier le type de PAT utilisÇ avec les variables:
                         ππππππππππππππππππππππ  
  . _patptr (L-M):l'adresse du MOTIF
  . _patmsk (MOT):le nombre de donnÇes -1

  On choisit aussi le MODE d'êCRITURE grÖce Ö la variable:

  . _wrt_mode (MOT =0 Ö 3)

  Ainsi que le CADRE du CLIPPING avec les coordonnÇes

  . _xmn_clip   ;X haut gauche
  . _ymn_clip   ;Y haut gauche
  . _xmx_clip   ;X bas droit
  . _ymn_clip   ;Y bas droit

  et 
 
  . _clip       ;0 si inutilisÇ
  
  On appelle la fonction par:

  DC.W    $A005   ;Dans le segment TEXT
  
  

- $A006 (FILLED POLYGONE)
  πππππ
  Permet de dessiner un POLYGONE (Une figure gÇomÇtrique Ö N cotÇs).
  $A006 utilise la fonction de base $A004 (H-LINE).
  On peut modifier la couleur du polygone, le type de remplissage et
  le mode d'Çcriture.
  La fonction utilise aussi le CLIPPING si vous le dÇsirez.
  
  Les paramätres Ö fournir sont:

  . sptsin contient le nombre de sommets de votre polygone.
    ππππππ             πππππππππππππππππ                   

  Dans le tableau ptsin , on place les coordonnÇes des N sommets du
  polygone (des MOTS),il faudra obligatoirement ternimer votre tab-
  leau par les coordonnÇes du 1¯ sommet pour boucler la figure.

 
  . Dans ptsin, la coordonnÇe X du 1¯ sommet    
         πππππ                π    πππππππππ
  . Dans ptsin+2, la coordonnÇe Y du 1¯ sommet
         πππππππ                π    πππππππππ   
  .
  .
  .

  . Dans ptsin+Z, la coordonnÇe X du N¯ sommet
         πππππππ                π    πππππππππ
  . Dans ptsin+(Z+2), la coordonnÇe Y du N¯ sommet
         πππππππππππ                π    πππππππππ
  . Dans ptsin+(Z+4), la coordonnÇe X du 1¯ sommet
         πππππππππππ                π    πππππππππ
  . Dans ptsin+(Z+6), la coordonnÇe Y du 1 ¯ sommet
         πππππππππππ                π    ππππππππππ

  On peut choisir la couleur du polygone, celle-ci est passÇe dans
  les variables:     πππππππππππππππππππ   

  . _fg_bp_B (Bits B utilisÇs suivant la rÇsolution)

  On peut aussi modifier le type de PAT utilisÇ avec les variables:
                         ππππππππππππππππππππππ  
  . _patptr (L-M):l'adresse du MOTIF
  . _patmsk (MOT):le nombre de donnÇes -1

  On choisit aussi le MODE d'êCRITURE grÖce Ö la variable:

  . _wrt_mode (MOT =0 Ö 3)

  Ainsi que le CADRE du CLIPPING avec les coordonnÇes

  . _xmn_clip   ;X haut gauche
  . _ymn_clip   ;Y haut gauche
  . _xmx_clip   ;X bas droit
  . _ymn_clip   ;Y bas droit

  et

  . _clip       ;0 si inutitilisÇ


  On appelle la fonction d'une maniäre träs particuliäre:
  ππππππππππππππππππππππππππππππππππππππππππππππππππππππ
  En effet, apräs avoir introduit tous les paramätres dont vous avez
  besoin, il faudra utiliser la routine $A006 POUR CHAQUE LIGNE de
  votre polygone.

  C.Ö.d. qu'il faudra utiliser $A006 plusieurs fois, pour qu'Ö chaque 
  ligne HORIZONTALE qui compose votre polygone les droites comprises
  dans l'espace dÇfinissant le polygone soient affichÇes.
  En effet, $A006 utilise la routine H-LINE mais ne trace que les lignes
  (dont vous fournissez l'ordonnÇe en paramätre) qui rentrent dans le po-
  lygone dÇfinit prÇcÇdement.

  L'ordonnÇe de la ligne du polygone Ö tracer doit ätre passÇe dans _Y1.
    ππππππππ πππππππππππ                                            ππππ  
  En utilisant $A006 dans une boucle qui fait varier _y1 , on oppärera
  un balayage de l'Çcran et les diffÇrentes lignes qui composent le po-
  lygone s'afficheront Ö chaque appel de la fonction.

  On appelle la fonction par:

  DC.W   $A006   ;Dans le segment TEXT:

  Dans une boucle oó l'on fait varier _y1 (0 Ö 199 pour BASSE et MOYENNE
  rÇsolution, 0 Ö 399 pour le HAUTE rÇsolution)
 
  Il n'est bien entendu pas utile de balayer tout l'Çcran avec $A006 pour
  afficher le polygone dÇfinit, seules les lignes qui contiennent effecti-
  vement le polygone doivent àtre tracÇes...  

  Exemple d'utilisation:
  πππππππππππππππππππππ
  Vous voulez tracer un CARRê de coordonnÇes de dÇpart (0,0) et d'une
  largeur de 20 pixels (Donc aussi d'une hauteur de 20 pixels puisque
  c'est un carrÇ...)
  
  On met:

  . 4 dans sptsin :Les 4 sommets du carrÇ

  Les coordonnÇes des sommets dans PTSIN:

  . 0 dans ptsin         (0,0)  : 1¯ sommet 
  . 0 dans ptsin+2
  
  . 19 dans ptsin+4      (19,0) : 2¯ sommet
  . 0  dans ptsin+6
         
  . 19 dans ptsin+8      (19,19): 3¯ sommet
  . 19 dans ptsin+10

  . 0  dans ptsin+12     (0,19) : 4¯ sommet
  . 19 dans ptsin+14
 
  . 0 dans ptsin+16      (0,0)  : pour boucler la figure
  . 0 dans ptsin+18

  On appelle la routine $A006 Ö chaque ligne horizontale du polygone
  pour afficher la portion de droite qui rentre dans le carrÇ:
  Notre carrÇ a une hauteur de 20 lignes (de 0 Ö 19)

  On fait varier _y1 pour ces 20 lignes et on appelle $A006 pour
  chacunes d'elles.


        move      #0,d0       ;0 dans d0

BOUCLE  move      d0,_y1(a0)  ;OrdonnÇes des 20 lignes du carrÇ de d0
                              ;dans _y1
        DC.W      $A006       ;On trace la portion de H-LINE qui rentre
                              ;dans le carrÇ prÇdÇfinit
        add       #1,d0       ;On ajoute 1 Ö d0
        cmpi      #20,d0      ;A-t-on d0 = 19+1=20 ?
        bne       BOUCLE      ;Non ? Alors on recommence avec d0=d0+1  
        


- $A009 (SHOW MOUSE)
  πππππ
  Permet de rÇafficher le curseur de la souris apräs avoir utilisÇ la
  fonction $A00A (HIDE MOUSE).
  En rÇalitÇ, l'appel de cette fonction incrÇmente un compteur interne
  et si celui est vaut 0, le curseur de la souris rÇapparait.
  Comme la fonction $A00A (HIDE MOUSE) dÇcrÇmente le compteur Ö chaque
  appel, il faudra utiliser la fonction $A009 N fois si on a utilisÇ 
  la fonction HIDE MOUSE N fois prÇcÇdement... 

  Les paramätres Ö passer sont:

  0 dans sptsin
  1 dans sintin
   
  On appelle la fonction par:

  DC.W   $A009   ;Dans le segment TEXT


  NB:Il existe une maniäre träs simple d'Çviter de s'embrouiller avec 
  ππ le compteur de HIDE et SHOW MOUSE, si on place 0 dans INTIN avant
     d'utiliser $A009, le compteur sera mis Ö 0 et le curseur de la
     souris rÇapparaitra toujours. 


- $A00A (HIDE MOUSE)
  πππππ
  C'est la fonction complÇmentaire de la fonction $A009 et elle permet
  de faire dispparaitre le curseur de la souris de l'Çcran.

  $A00A dÇcrÇmente le compteur vu prÇcÇdement d'1 unitÇ Ö chaque appel...


  Mais ATTENTION Ö l'utilisation de cette fonction:
 
 En effet, HIDE MOUSE indique Ö l'ordi. qu'au prochain raffraichissement
 de l'Çcran, le curseur de la souris doit dispparaitre et ENSUITE que ce
 qui est sous la position actuelle du curseur doit àtre rÇaffichÇ.
 (Voir le chapitre sur le VBL plus loin)
 Seulement, pendant le temps d'exÇcution de la fonction, l'utilisateur
 peut bouger la souris et ceci provoquerai l'apparition d'un TROU rec-
 tangulaire Ö la place de la partie de l'Çcran qui devait ätre restaurÇe.
 
 Il faudra donc utiliser HIDE MOUSE avant d'Çffacer votre Çcran, mais 
 jamais lorsque la souris peut se trouver sous des graphimes.

 $A00A n'admet pas de paramätres, pour l'appeller , on Çcrit:

 DC.W   $A00A  ;Dans le segment TEXT



- $A00C  (UNDRAW SPRITE)
  πππππ
  Permet d'Çffacer un SPRITE dÇfinit par la routine complÇmentaire $A00D.
  
  Les SPRITES que nous allons pouvoir dessiner sont pudiquement appellÇs
  SPRITES ATARI:Ce sont des dessins d'une hauteur et d'une largeur de 16
  pixels et ils sont monochromes ( Couleur du FOND et couleur du DESSIN
  uniquement ).:Comme le curseur de la souris par exemple...
  Le SPRITE pourra ensuite ätre affichÇ sur l'Çcran aux coordonnÇes que
  vous indiquerez sans avoir Ö le redÇfinir.

  Mais il faudra d'abord dÇfinir le SPRITE lui mäme, il se dÇfinit par:

 . Un premier plan:C.Ö.d. le dessin du SPRITE (la fläche de la souris...)
  
 . Un Masque:Ou encore un arriäre plan qui permet d'entourer le dessin 
             d'une couleur de telle faáon qu'il reste toujours visible,
             mäme sur une dessin de màme couleur que le premier plan.

 . 2 couleurs diffÇrentes:Pour le premier plan et le masque

 . Un point chaud:C'est Ö partir de ce point qu'on dÇfinit les coordonÇes
                  du SPRITE.
                  Le point chaud de la fläche de la souris se trouve par
                  exemple sur la pointe de la fläche:C'est le point d'ac-
                  tion du curseur et il ne peut pas sortir de l'Çcran.
 
 . Un format:VDI (mode graphique AND) ou XOR (mode XOR) 


 Toutes ces donnÇes devront àtre dÇfinies avec $A00D (DRAW SPRITE), pour
 effacer un SPRITE dejÖ dÇfinit, on passe le paramätre suivant Ö $A00C :


 Paramätre de UNDRAW SPRITE:

 . Adresse du tampon de sauvegarde du SPRITE dans a2


 et on appelle la fonction par:

 DC.W   $A00C    ;Dans le segment TEXT


- $A00D  (DRAW SPRITE)
  πππππ
  Permet de dÇfinir et d'afficher un SPRITE.

  Les paramätres Ö passer Ö $A00D sont:

  . CoordonnÇe X du SPRITE dans d0

  . CoordonnÇe Y du SPRITE dans d1

  . Adresse du bloc de dÇfinition du SPRITE dans a0

  Ce bloc a une taille de 74 Octets et doit ätre organisÇ comme il suit:

  Adresse:          valeur (MOTs)

  a0                CoordonnÇe relative X pour le point chaud
  a0+2              CoordonnÇe relative Y pour le point chaud      
  a0+4              Le format (0 pour VDI,1 pour XOR)
  a0+6              La couleur du masque
  a0+8              La couleur du premier plan
  a0+10             16 bits qui dÇfinissent la 1¯ ligne du masque
  a0+12             16 bits qui dÇfinissent la 1¯ ligne du premier plan
  a0+14             idem pour la 2¯ ligne du masque     
  a0+16             idem pour la 2¯ ligne du premier plan
  .
  .
  .
  a0+70             idem pour la 16¯ ligne du masque
  a0+72             idem pour la 16¯ ligne du premier plan                 


  Ainsi, si on veut dessiner un SPRITE qui reprÇsente un 1, les donnÇes
  qui dÇfinissent le dessin du sprite seront par exemple:

     DC.W     %0000000000000000    ;0 = pas de point
     DC.W     %0000000000000000    ;1 = pixel actif
     DC.W     %0000000010000000
     DC.W     %0000000110000000
     DC.W     %0000011110000000
     DC.W     %0000111110000000
     DC.W     %0000000110000000
     DC.W     %0000000110000000
     DC.W     %0000000110000000
     DC.W     %0000000110000000
     DC.W     %0000000110000000
     DC.W     %0000000110000000
     DC.W     %0001111111110000
     DC.W     %0000000000000000
     DC.W     %0000000000000000
     DC.W     %0000000000000000
   
   Le SPRITE a une taille de 16 pixels (16 colonnes ) et de 16 lignes.
   On utilise ici la notation en BINAIRE car c'est la plus lisible.


     Les donnÇes du masque seront:
     
     DC.W     %*000000000000000    ;0 = pas de point
     DC.W     %0000000010000000    ;1 = pixel actif
     DC.W     %0000000111000000    ;* = point chaud (ATTENTION:=0)
     DC.W     %0000001111000000
     DC.W     %0000111111000000
     DC.W     %0001111111000000
     DC.W     %0000001111000000
     DC.W     %0000001111000000
     DC.W     %0000001111000000
     DC.W     %0000001111000000
     DC.W     %0000001111000000
     DC.W     %0011111111111000
     DC.W     %0011111111111000
     DC.W     %0011111111111000
     DC.W     %0000000000000000
     DC.W     %0000000000000000
 
  On choisit aussi le point chaud, je l'ai notÇ * dans les donnÇes du
  masque, ATTENTION, le * n'est lÖ que pour vous indiquer clairement 
  oó j'ai placÇ le point chaud, il occupe la place d'un BIT nul et le
  * n'a en rÇalitÇ rien Ö faire dans ces donnÇes... 

  Dans mon exemple: le point chaud notÇ * a les coordonnÇes:(0,0)
  
  Notre bloc de dÇfinition pour $A00D peut donc ätre reprÇsentÇ ainsi
  suivant cet exemple:
  
  Si a0 pointe le bloc de dÇfinition et si le SPRITE est au format VDI
  ,que le premier plan Ö la couleur 0 et le masque la couleur 1:

  En                On doit avoir:
  ππ                ππππππππππππππ
  a0                0:CoordonnÇe relative X pour le point chaud
  a0+2              0:CoordonnÇe relative Y pour le point chaud      
  a0+4              0:Le format (0 pour VDI,1 pour XOR)
  a0+6              1:La couleur du masque
  a0+8              0:La couleur du premier plan
  a0+10             %0000000000000000 :MOT du masque pour ligne 1
  a0+12             %0000000000000000 :MOT du premier plan pour ligne 1
  a0+14             %0000000010000000 :MOT du masque pour ligne 2
  a0+16             %0000000000000000 :MOT du premier plan pour ligne 2
  a0+18             %0000000111000000 etc...
  a0+20             %0000000010000000
  a0+22             %0000001111000000
  a0+24             %0000000110000000
  a0+26             %0000111111000000
  a0+28             %0000011110000000
  a0+30             %0001111111000000
  a0+32             %0000111110000000
  a0+34             %0000001111000000
  a0+36             %0000000110000000
  a0+38             %0000001111000000
  a0+40             %0000000110000000
  a0+42             %0000001111000000
  a0+44             %0000000110000000
  a0+46             %0000001111000000
  a0+48             %0000000110000000
  a0+50             %0000001111000000
  a0+52             %0000000110000000
  a0+54             %0011111111111000   
  a0+56             %0000000110000000
  a0+58             %0011111111111000
  a0+60             %0001111111110000
  a0+62             %0011111111111000
  a0+64             %0000000000000000
  a0+66             %0000000000000000
  a0+68             %0000000000000000
  a0+70             %0000000000000000 :MOT du masque de la 16¯ ligne
  a0+72             %0000000000000000 :MOT du premier plan de la 16¯ ligne
 

  Mais revenons Ö notre fonction $A00D (DRAW SPRITE):

  Il reste encore 1 paramätre Ö fournir:

  . L'adresse d'un tampon de sauvegarde pour le SPRITE dans a2
  
  Ce tampon doit avoir une taille de :
  
  . 266 octets pour la basse rÇsolution
  . 138 octets pour la moyenne rÇsolution
  . 74  octets pour la haute rÇsolution

  (La taille augmente avec le nombre de couleurs disponibles)


  Par la suite, il suffira d'apeller la fonction avec:

  DC.W    $A00D  ;Dans le segment TEXT


- $A00B (TRANSFORM MOUSE)
  πππππ
  Permet de transformer la forme du curseur de la souris.

  J'ai gardÇ cette routine pour la fin parce que vous la comprendrez
  plus facilement apräs avoir vu DRAW SPRITE.

  Les paramätres qui dÇfinissent le nouveau curseur de la souris devront
  ätres transfÇrÇes dans INTIN.
  On devra y dÇposer 34 MOTS:

     Dans           On devra trouver:

     INTIN+6        :La couleur du masque (MOT)
     INTIN+8        :La couleur du premier plan (MOT)

de   INTIN+10       :Les donnÇes dÇfinissant 
Ö    INTIN+40       :le MASQUE (16 MOTS)

de   INTIN+42       :Les donnÇes dÇfinissant
Ö    INTIN+64       :le PREMIER PLAN (16 MOTS)

   La manipulation de $A00B est donc beaucoup plus aisÇe que celle de
   DRAW SPRITE car ici les donnÇes dÇfinissant le MASQUE et le PREMIER
   PLAN n'ont pas besoin d'ätres alternÇes...

   On dÇfinit les donnÇes du MASQUE et du PREMIER PLAN identiquement
   Ö celles de la fonction DRAW SPRITE.

   Vu l'organisation des variables dans le tableau INTIN: 
   On pourra dÇposer les donnÇes du masque PUIS les donnÇes du premier
   plan avec un mode d'adressage adÇquate ( (an)+ ...) dans le tableau
   INTIN... (ouf!!)


   On appelle la fonction par:

   DC.W   $A00B   ;Dans le segment TEXT
 
     

                           πππππππππππππππππ   
  
  VoilÖ pour la thÇorie, relisez träs attentivement tout ce qui a ÇtÇ 
  dit ici, notez le sur une fiche si besoin est...

  Dans le chapitre suivant, vous allez utiliser les LineAs dans de
  nombreux exercices oó toutes les routines importantes seront 
  utilisÇes et mises en valeur.


  
  PIECHOCKI   Laurent
  8, impasse Bellevue             SUITE dans le fichier:EXOS_3.DOC
  57980   TENTELING                                     ππππππππππ
  





 
