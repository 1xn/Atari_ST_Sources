<HTML>

<HEAD>

<TITLE>GEMDOS Master Document</TITLE>


</HEAD>

<BODY BACKGROUND BGCOLOR=#FFFFFF>

<a name=gemdos><H2>GEMDOS Function Reference</H2>

<HR>

<a name=cauxin><H3>Cauxin()</H3>

<P>
<B>WORD Cauxin( VOID )</B>
<TABLE>

<TR><TH></TH><TD><B>Cauxin()</B> waits for the next available data byte from <B>GEMDOS</B> handle 2 (normally device 'aux:') and when available, returns it in the low byte of the returned <B>WORD</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>3 (0x03)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w  #$3,-(sp)
trap  #1
addq.l  #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD>The <B>WORD</B> <a name=interprocesscommunication>value contains the retrieved byte in the lower eight bits. The contents of the upper 8 bits are currently undefined.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>This function can cause flow control problems.When using this function while its handle is redirected, an end-of-file condition will hang the system. <B>GEMDOS</B> version 0.30 and all <B>MiNT</B> versions correct this bug. <B>MiNT</B> returns <B>MINT_EOF</B> (0xFF1A) when the end-of-file is reached.In addition, if this handle is redirected to something other than 'aux:', an end-of-file will hang the system. Besides these known bugs, this function is used by many 'C' compilers to redirect standard error messages. It is therefore advisable to use <B>Bconin()</B> instead.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Cauxis()</B>, <B>Cauxout()</B>, <B>Bconin()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=cauxis><H3>Cauxis()</H3>

<P>
<B>WORD Cauxis( VOID )</B>
<TABLE>

<TR><TH></TH><TD><B>Cauxis()</B> indicates whether <B>GEMDOS</B> handle 2 (normally device 'aux:') has at least one character waiting.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>18 (0x12)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$12,-(sp)
trap   #1
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD>The return value will be <B>DEV_READY</B> (-1) if at least one character is available for reading or <B>DEV_BUSY</B> (0) if not.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>When using this function while its handle is redirected, an end-of-file condition will hang the system. <B>GEMDOS</B> version 0.30 and all <B>MiNT</B> versions correct this bug. <B>MiNT</B> returns <B>MINT_EOF</B> (0xFF1A) when the end-of-file is reached.In addition, some 'C' compilers use this handle as a standard error device. It is therefore advisable to use <B>Bconstat()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Cauxin()</B>, <B>Cauxout()</B>, <B>Cauxos()</B>, <B>Bconstat()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=cauxos><H3>Cauxos()</H3>

<P>
<B>WORD Cauxos( VOID )</B>
<TABLE>

<TR><TH></TH><TD><B>Cauxos()</B> indicated whether <B>GEMDOS</B> handle 2 (normally device 'aux:') is ready to receive characters.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>19 (0x13) </TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>GEMDOS</B>  versions
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$13,-(sp)
trap   #1
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD>A value of <B>DEV_READY</B> (-1) is returned if the output device is ready to receive characters or <B>DEV_BUSY</B> (0) if it is not.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>This function actually returns the status of whatever device <B>GEMDOS</B> handle 2 is redirected to. In addition, some 'C' compilers use this handle as a standard error device. It is therefore recommended that <B>Bcostat()</B> be used instead.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Cauxin()</B>, <B>Cauxis()</B>, <B>Cauxout()</B>, <B>Bcostat()</B>.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=cauxout><H3>Cauxout()</H3>

<P>
<B>VOID Cauxout( <I>ch</I> )</B>
<P>
<B>WORD <I>ch</I>;</B>
<TABLE>

<TR><TH></TH><TD><B>Cauxout()</B> outputs a character to <B>GEMDOS</B> handle 2, normally the 'aux:' device.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>4  (0x04)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>ch</I> is a <B>WORD</B> value, however, only the lower eight bits are sent. The upper eight bits must be 0.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #ch,-(sp)
move.w   #4,-(sp)
trap   #1
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>This function can cause flow control to fail when <B>GEMDOS</B> handle 2 is directed to 'aux:'.In addition, some 'C' compilers use this function as a standard error device. It is therefore recommended that <B>Bconout()</B> be used in place of this function.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Cauxin()</B>, <B>Cauxis()</B>, <B>Cauxos()</B>, <B>Bconout()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=cconin><H3>Cconin()</H3>

<P>
<B>LONG Cconin( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=6><B>Cconin()</B> reads a character (waiting until one is available) from <B>GEMDOS</B> handle 0 (normally 'con:').
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=6>1 (0x01)</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=6>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=6>
<PRE>
move.w   #1,-(sp)
trap   #1
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=6>The <B>LONG</B> value returned is a bit array arranged as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TD COLSPAN=2></TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bits 31-24</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bits 23-16</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bits 15-8</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bits 7-0</FONT></B>
</CENTER>

</TD></TR>

<TR><TD COLSPAN=2></TD><TD>
<CENTER>
<FONT SIZE=2>Shift key status</FONT>(see below)
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>Keyboard scancode</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>Unused</FONT>
</CENTER>

<P>

<CENTER>
<FONT SIZE=2>(0)</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>ASCII code of character</FONT>
</CENTER>

</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH></TH><TD COLSPAN=6>The ASCII code of the character will be 0 if a non-ascii keyboard key is struck.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=6>When using this function while its handle is redirected, an end-of-file condition will hang the system. <B>GEMDOS</B> version 0.30 and all <B>MiNT</B> versions correct this bug. <B>MiNT</B> returns <B>MINT_EOF</B> (0xFF1A) when the end-of-file is reached.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=6>The shift key status will only be returned when bit 3 of the system variable <I>conterm</I> (char *(0x484)) is set. This is normally not enabled.If the handle has been redirected, the inputted character will appear in the lower 8 bits of the return value.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=6><B>Cconis()</B>, <B>Cconout()</B>, <B>Cconrs()</B>, <B>Cnecin()</B>,<B> Crawin(), Bconin()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=cconis><H3>Cconis()</H3>

<P>
<B>WORD Cconis( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Cconis()</B> verifies that a character is waiting to be read from <B>GEMDOS</B> handle 0 (normally 'con:').
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>11 (0xB)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$0B,-(sp)
trap   #1
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Cconis()</B> returns a <B>DEV_READY</B> (-1) if a character is available or <B>DEV_BUSY</B> (0) if not.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Cconin()</B>, <B>Bconstat()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=cconos><H3>Cconos()</H3>

<P>
<B>WORD Cconos( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Cconos()</B> checks to see whether a character may be output to <B>GEMDOS</B> handle 1 (normally 'con:').
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>16 (0x10)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$10,-(sp)
trap   #1
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD>This function returns <B>DEV_READY</B> (-1) if at least one character may be sent or <B>DEV_BUSY</B> (0) if not.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Cconout(), Bcostat()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<a name=cconout><H3>Cconout()</H3>

<P>
<B>VOID Cconout( <I>ch</I> )</B>
<P>
<B>WORD <I>ch</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Cconout()</B> outputs one character via <B>GEMDOS</B> handle 1 (normally 'con:').
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>2 (0x02)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>ch</I> is a <B>WORD</B> value, however, only the lower eight bits are sent through the output stream. The upper eight bits must be 0.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   ch,-(sp)
move.w   #2,-(sp)
trap   #1
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>With <B>GEMDOS </B>versions below 0.15, this handle should not be redirected to a write-only device as the call attempts to read from the output stream to process special keys.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>No line feed translation is done at the time of output. To start a new line, ASCII 13 and ASCII 10 must both be sent.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Cconin()</B>, <B>Bconout()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=cconrs><H3>Cconrs()</H3>

<P>
<B>VOID Cconrs( <I>str</I> )</B>
<P>
<B>char *<I>str</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=4><B>Cconrs()</B> reads a string from the standard input stream (<B>GEMDOS</B> handle 0) and echoes it to the standard output stream (<B>GEMDOS</B> handle 1).
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=4>10 (0x0A)</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=4>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=4><I>str </I>should be a character pointer large enough to hold the inputted string. On function entry, <I>str[0]</I> should be equal to the maximum number of characters to read. 
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=4>
<PRE>
pea   str
move.w   #$0A,-(sp)
trap   #1
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=4>On return, the string buffer passed as a parameter will be filled in with the inputted characters. <I>str[1]</I> will contain the actual number of characters in the buffer. (char&nbsp;*)&nbsp;&amp;<I>str[2]</I> is the pointer to the start of the actual string in memory.<B>Cconrs()</B> will not terminate unless ctrl-c is pressed, the buffer is full or either return or ctrl-j is pressed.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=4><B>GEMDOS </B>versions below 0.15 echoes the input to the console even if output has been redirected elsewhere.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=4>The string <B>Cconrs()</B> creates is not null-terminated. The following keys <I>are</I> processed by the function:
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B><FONT SIZE=1 >Key</FONT></B>
</TD><TD><B><FONT SIZE=2 >Translation</FONT></B>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>return</TD><TD><FONT SIZE=2>End of input. Do not place RETURN in in buffer.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>ctrl-j</TD><TD><FONT SIZE=2>End of line. Do not place CTRL-J in buffer.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>ctrl-h</TD><TD><FONT SIZE=2>Kill last character.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>delete</TD><TD><FONT SIZE=2>Kill last character.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>ctrl-u</TD><TD><FONT SIZE=2>Echo input line and start over.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>ctrl-x</TD><TD><FONT SIZE=2>Kill input line and start over.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>ctrl-r</TD><TD><FONT SIZE=2>Echo input line and continue.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>ctrl-c</TD><TD><FONT SIZE=2>Exit program.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH></TH><TD COLSPAN=4>When the input stream is redirected, <B>Cconrs()</B> returns 0 in <I>str[1]</I> when the end-of-file marker is reached. 
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=4><B>Cconin()</B>, <B>Cconws()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=cconws><H3>Cconws()</H3>

<P>
<B>WORD Cconws( <I>str</I> )</B>
<P>
<B>char *<I>str</I>;</B>
Cconws() returns a WORD conatining the number of characters output or 0 if an error occurred.
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Cconws()</B> writes a string to <B>GEMDOS</B> handle 1 (normally 'con:').
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>9 (0x09)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>str</I> is a pointer to a null-terminated character string to be written to the output stream.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   str
move.w   #$09,-(sp)
trap   #1
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>With <B>GEMDOS </B>versions below 0.15, this handle should not be redirected to a write-only device as the call attempts to read from the output stream to process special keys.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>No line feed translation is performed on outputted characters so both an ASCII 13 and ASCII 10 must be sent to force a new line. In addition, the system checks for special keys so a ctrl-c embedded in the string will terminate the process.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Cconout()</B>, <B>Cconrs()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=cnecin><H3>Cnecin()</H3>

<P>
<B>LONG Cnecin( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=6><B>Cnecin()</B> is exactly the same as <B>Cconin()</B> except that the character fetched from the input stream is not echoed.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=6>8 (0x08)</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=6>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=6>None.</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=6>
<PRE>
move.w   #8,-(sp)
trap   #1
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=6>The <B>LONG</B> value returned is a bit array arranged as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TD COLSPAN=2></TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bits 31-24</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bits 23-16</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bits 15-8</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bits 7-0</FONT></B>
</CENTER>

</TD></TR>

<TR><TD COLSPAN=2></TD><TD>
<CENTER>
<FONT SIZE=2>Shift key status</FONT>(see below)
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>Keyboard scancode</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>Unused</FONT>
</CENTER>

<P>

<CENTER>
<FONT SIZE=2>(0)</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>ASCII code of character</FONT>
</CENTER>

</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH></TH><TD COLSPAN=6>The ASCII code of the character will be 0 if a non-ascii keyboard key is struck.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=6>When using this function while its handle is redirected, an end-of-file condition will hang the system. <B>GEMDOS</B> version 0.30 and all <B>MiNT</B> versions correct this bug. <B>MiNT</B> returns <B>MINT_EOF</B> (0xFF1A) when the end-of-file is reached.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=6>The shift key status will only be returned when bit 3 of the system variable <I>conterm</I> (char *(0x484)) is set. This is normally not enabled.If the handle has been redirected, the inputted character will appear in the lower 8 bits of the return value.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=6><B>Cconin()</B>, <B>Bconin()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=cprnos><H3>Cprnos()</H3>

<P>
<B>WORD Cprnos( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Cprnos()</B> returns the status of<B> GEMDOS</B> handle 3 (normally 'prn:').
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>17 (0x11)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD>None.</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$11,-(sp)
trap   #1
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Cprnos()</B> returns a <B>DEV_READY</B> (-1) if the output stream is ready to receive a character or <B>DEV_BUSY</B> (0) if not.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Cprnout()</B>, <B>Bcostat()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=cprnout><H3>Cprnout()</H3>

<P>
<B>WORD Cprnout( <I>ch</I> )</B>
<P>
<B>WORD <I>ch</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Cprnout()</B> sends one character to<B> GEMDOS</B> handle 3 (normally 'prn:').
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5 (0x05)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>ch</I> is a <B>WORD</B> value, however, only the lower 8 bits are sent to the output stream. The upper eight bits should be 0.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   ch,-(sp)
move.w   #$5,-(sp)
trap   #1
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Cprnout()</B> returns a non-zero value if the function successfully wrote the character to the printer or 0 otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>No input translation is performed with this call. Therefore, you must send an ASCII 13 and ASCII 10 to force a new line.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Bconout()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=crawcin><H3>Crawcin()</H3>

<P>
<B>LONG Crawcin( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=6><B>Crawcin()</B> is similar to <B>Cconout()</B>, however it does not process any special keys and does not echo the inputted character.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=6>7 (0x07)</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=6>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=6>
<PRE>
move.w   #$07,-(sp)
trap   #1
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=6>The <B>LONG</B> value returned is a bit array arranged as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TD COLSPAN=2></TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bits 31-24</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bits 23-16</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bits 15-8</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bits 7-0</FONT></B>
</CENTER>

</TD></TR>

<TR><TD COLSPAN=2></TD><TD>
<CENTER>
<FONT SIZE=2>Shift key status</FONT>(see below)
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>Keyboard scancode</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>Unused</FONT>
</CENTER>

<P>

<CENTER>
<FONT SIZE=2>(0)</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>ASCII code of character</FONT>
</CENTER>

</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH></TH><TD COLSPAN=6>The ASCII code of the character will be 0 if a non-ascii keyboard key is struck.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=6>When using this function while its handle is redirected, an end-of-file condition will hang the system. <B>GEMDOS</B> version 0.30 and all <B>MiNT</B> versions correct this bug. <B>MiNT</B> returns <B>MINT_EOF</B> (0xFF1A) when the end-of-file is reached.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=6>The shift key status will only be returned when bit 3 of the system variable <I>conterm</I> (char *(0x484)) is set. This is normally not enabled.If the handle has been redirected, the inputted character will appear in the lower 8 bits of the return value.Under normal circumstances, when <B>GEMDOS</B> handle 0 is being read from, no special system keys, including ctrl-c, are checked.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=6><B>Cconin()</B>, <B>Crawio()</B>,<B> Bconin()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=crawcio><H3>Crawio()</H3>

<P>
<B>LONG Crawio( <I>ch</I> )</B>
<P>
<B>WORD <I>ch</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=6><B>Crawio()</B> combines console input and output in one function.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=6>6 (0x06)</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=6>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=6><I>ch</I> is a <B>WORD</B> value, however, only the lower eight bits are meaningful and the upper eight bits should be set to 0. If <I>ch</I> is 0x00FF on input, <B>Crawio()</B> returns the character read from <B>GEMDOS</B> handle 0 (normally 'con:').
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=6>
<PRE>
move.w   ch,-(sp)
move.w   #6,-(sp)
trap   #1
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=6>If <I>ch</I> is 0x00FF upon entry, <B>Crawio()</B> returns a bit array arranged as follows:
</TD></TR>

<TR><TH COLSPAN=2></TH><TD></TD><TD></TD><TD></TD><TD></TD></TR>

<TR><TD COLSPAN=2></TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bits 31-24</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bits 23-16</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bits 15-8</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bits 7-0</FONT></B>
</CENTER>

</TD></TR>

<TR><TD COLSPAN=2></TD><TD>
<CENTER>
<FONT SIZE=2>Shift key status</FONT>(see below)
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>Keyboard scancode</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>Unused</FONT>
</CENTER>

<P>

<CENTER>
<FONT SIZE=2>(0)</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2><a name=charfunctions>ASCII code of character</FONT>
</CENTER>

</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH></TH><TD COLSPAN=6>The ASCII code of the character will be 0 if a non-ascii keyboard key is struck.
<P>
If no character was waiting in the input stream, <B>Crawio()</B> returns a 0.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=6>When using this function while its handle is redirected, an end-of-file condition will hang the system. <B>GEMDOS</B> version 0.30 and all <B>MiNT</B> versions correct this bug. <B>MiNT</B> returns <B>MINT_EOF</B> (0xFF1A) when the end-of-file is reached.Due to the definition of this call it is impossible to write 0x00FF to the output stream or read a zero from this call.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=6>The shift key status will only be returned when bit 3 of the system variable <I>conterm</I> (char *(0x484)) is set. This is normally not enabled.If the handle has been redirected, the inputted character will appear in the lower 8 bits of the return value.Under normal circumstances, when <B>GEMDOS</B> handle 0 is being read from, no special system keys, including ctrl-c, are checked.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=6><B>Cconout()</B>, <B>Cconin()</B>, <B>Bconout()</B>, <B>Bconin()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Dclosedir()</H3>

<P>
<B>LONG Dclosedir( <I>dirhandle</I> )</B>
<P>
<B>LONG <I>dirhandle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dclosedir()</B> closes the specified directory.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>299 (0x12B)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available when a '<B>MiNT</B>' cookie with a version of at least 0.90 exists.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>dirhandle</I> is a valid directory handle which specifies the directory to close.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.l   dirhandle,-(sp)
move.w   #$12B,-(sp)
trap   #1
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Dclosedir()</B> returns <B>E_OK</B> (0) if successful or <B>EIHNDL</B> (37) if the directory handle was invalid.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Dopendir(), Dreaddir(), Drewinddir()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=dcntl2><H3>Dcntl()</H3>

<P>
<B>LONG Dcntl( <I>cmd</I>, <I>name</I>, <I>arg </I>)</B>
<P>
<B>WORD <I>cmd</I>;</B>
<P>
<B>char *<I>name</I>;</B>
<P>
<B>LONG <I>arg</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=2><B>Dcntl()</B> performs file system specific operations on directories or files.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=2>304 (0x130)</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=2>Available when a '<B>MiNT</B>' cookie with a version of at least 0.90 exists.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=2>The only two built-in file systems that support <B>Dcntl()</B> calls are 'U:\' and 'U:\DEV.'<I> cmd</I> specifies what operation to perform and affects the meaning of <I>name</I> and <I>arg</I>. Valid <I>cmd</I> arguments for 'U:\' are
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH></TH><TD>
<CENTER>
<I><B><FONT SIZE=1 >cmd</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD>
<CENTER>
<B>FS_INSTALL</B>
</CENTER>

<P>

<CENTER>
(0xF001)
</CENTER>

</TD><TD><FONT SIZE=2>This mode installs a new file system. <I>name</I> must be 'U:\' and <I>arg</I> should point to a <I>fs_descr</I> structure as follows:</FONT>
<PRE>
struct fs_descr
{
 FILESYS  *file_system;
 WORD   dev_no;
 LONG   flags;
 LONG   reserved[4];
};
If this call is successful, a pointer to a <B>kerinfo</B> structure is returned, otherwise the return value is <B>NULL</B>. The file system itself is not accessible until this call is made and it is mounted with <B>FS_MOUNT</B>.
</PRE>

</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>FS_MOUNT</B>
</CENTER>

<P>

<CENTER>
(0xF002)
</CENTER>

</TD><TD><FONT SIZE=2>This mode mounts an instance of an installed file system. <I>name</I> should be in the format 'U:\???' where '???' is the name which the file system will be accessed by. <I>arg</I> should point to the <I>fs_descr</I> structure as above. If the file system is mounted correctly, the <I>dev_no</I> field will be updated to reflect the instance number of the mount (file systems may be mounted multiple times).</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>FS_UNMOUNT</B>
</CENTER>

<P>

<CENTER>
(0xF003)
</CENTER>

</TD><TD><FONT SIZE=2>This mode unmounts an instance of a file system. <I>name</I> is the name of the file system in the form 'U:\???' where '???' is the name of the file system instance. <I>arg</I> should point to the file system <I>fs_descr</I> structure.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>FS_UNINSTALL</B>
</CENTER>

<P>

<CENTER>
(0xF004)
</CENTER>

</TD><TD><FONT SIZE=2>This mode uninstalls a file system identified by the <I>fs_descr</I> structure passed in <I>arg</I>. A file system can only be sucessfully uninstalled after all instances of it have been unmounted. <I>name</I> should be 'U:\'.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH></TH><TD COLSPAN=2>Valid <I>cmd</I> arguments for 'U:\DEV' are:
</TD></TR>

<TR><TH></TH><TD></TD><TD></TD></TR>

<TR><TH></TH><TD>
<CENTER>
<I><B><FONT SIZE=1 >cmd</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD>
<CENTER>
<B>DEV_INSTALL </B>(0xDE02)
</CENTER>

</TD><TD><FONT SIZE=2>This command attempts to install a device driver. <I>name </I>should be in the format 'U:\DEV\???' where '???' is the name of the device to install. <I>arg</I> is a pointer to a <I>dev_descr</I> structure as follows:
</FONT>
<PRE>
<FONT SIZE=2>struct dev_descr
{
</FONT> /* Pointer to a device driver structure */
<FONT SIZE=2> DEVDRV *driver;
</FONT> /* Placed in aux field of file cookies */
<FONT SIZE=2> WORD dinfo;
</FONT> /* 0 or O_TTY (0x2000) for TTY */
<FONT SIZE=2> WORD flags;
</FONT> /* If O_TTY is set, points to tty struct */
<FONT SIZE=2> struct tty *tty;
</FONT> /* Reserved for future expansion */
<FONT SIZE=2> LONG reserved[4];
</FONT>}<FONT SIZE=2>If the device is successfully installed, <B>Dcntl()</B> will return a pointer to a <B>kerinfo</B> structure which contains information about the kernel. On failure, <B>Dcntl()</B> will return <B>NULL</B>. See the section on loadable file systems earlier in this chapter for more information.</FONT>
</PRE>

</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>DEV_NEWTTY</B> (0xDE00)
</CENTER>

</TD><TD><FONT SIZE=2>This command identifies a <B>BIOS</B> terminal device whose name is <I>name</I> (in the form 'U:\DEV\DEVNAME' and whose device number is <I>arg</I>. This call simply makes the <B>MiNT</B> kernel aware of the device. It should have been previously installed by<B> Bconmap()</B>. Any attempt to access the device prior to installing it with the <B>BIOS</B> will result in an <B>EUNDEV</B> (-15) unknown device error. If the device is installed, <B>Dcntl()</B> returns a 0 or positive value. A negative return code signifies failure.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>DEV_NEWBIOS </B>(0xDE01)
</CENTER>

</TD><TD><FONT SIZE=2>This command is the same as <B>DEV_NEWTTY</B> except that it is designed for devices which must have their data transmitted raw (SCSI devices, for example).</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=2>
<PRE>
move.l   arg,-(sp)
pea   name
move.w   cmd,-(sp)
move.w   #$130,-(sp)
trap   #1
lea   12(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Version Notes</B></TH><TD COLSPAN=2>The <B>FS_</B> group of <I>cmd</I> arguments are only available as of <B>MiNT</B> version 1.08.Due to a bug in <B>MiNT</B> versions 1.08 and below, calling this function with a parameter of <B>DEV_NEWBIOS</B> will not have any effect.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=2>See above.</TD>
</TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=2><B>Bconmap(), Fcntl()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Dcreate()</H3>

<P>
<B>LONG Dcreate( <I>path</I> )</B>
<P>
<B>char *<I>path</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>Dcreate()</B> creates a <B>GEMDOS</B> directory on the specified drive.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>57 (0x39)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>path</I> is a pointer to a string containing the directory specification of the directory to create. <I>path</I> should <I>not</I> contain a trailing backslash. Below are some examples and their results.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><I><B><FONT SIZE=1 >path</FONT></B></I>
</TD><TD><B><FONT SIZE=2 >Result</FONT></B></TD>
</TR>

<TR><TH></TH><TD>C:\ONE\ATARI</TD><TD><FONT SIZE=2>Creates a folder named "ATARI" as a subdirectory of "ONE" on drive 'C:'.</FONT>
</TD></TR>

<TR><TH></TH><TD>\ONE\ATARI</TD><TD><FONT SIZE=2>Creates a folder named "ATARI" as a subdirectory of "ONE" on the current <B>GEMDOS</B> drive.</FONT>
</TD></TR>

<TR><TH></TH><TD>ATARI</TD><TD><FONT SIZE=2>Creates a folder named "ATARI" as a subdirectory of the current <B>GEMDOS</B> path on the current <B>GEMDOS</B> drive.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
pea   path
move.w   #$39,-(sp)
trap   #1
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3>Upon return one of three codes may result:
<P>
  <B>E_OK</B> (0) :  Operation successful
<P>
  <B>EPTHNF</B> (-34): Path not found
<P>
  <B>EACCDN</B> (-36):  Access denied
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=3>Prior to <B>GEMDOS</B> version 0.15 <B>GEMDOS</B> did not detect if the creation of a subdirectory failed and could therefore leave partially created directories on disk.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>Ddelete()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3>Ddelete()</H3>

<P>
<B>LONG Ddelete( <I>path</I> )</B>
<P>
<B>char *<I>path</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Ddelete()</B> removes a directory on the specified drive.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>58 (0x3A)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>path</I> contains the directory specification of the directory you wish to remove. <I>path</I> should <I>not</I> contain a trailing backslash. For valid examples of <I>path</I>, see the entry for <B>Dcreate()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   path
move.w   #$3A,-(sp)
trap   #1
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD>Upon return one of four codes may result:
<P>
  <B>E_OK</B> (0) :  Operation successful
<P>
  <B>EPTHNF</B> (-34): Path not found
<P>
  <B>EACCDN</B> (-36):  Access denied
<P>
  <B>EINTRN</B> (-65):  Internal error
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>Prior to <B>GEMDOS</B> version 0.15 a <B>Ddelete()</B> on a directory recently created will fail but a second attempt will not.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The directory being deleted must be empty or the call will fail.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Dcreate()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=dfree2><H3>Dfree()</H3>

<P>
<B>LONG Dfree( <I>buf</I>, <I>drive</I> )</B>
<P>
<B>DISKINFO *<I>buf</I>;</B>
<P>
<B>WORD <I>drive</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dfree()</B> returns information regarding the storage capacity/current usage of the specified drive.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>54 (0x36)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>buf</I> is a <B>DISKINFO</B> pointer which will be filled in on function exit. <B>DISKINFO</B> is defined as:
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH></TH><TD>
<PRE>
typedef struct
{
 /* No. of Free Clusters */
 ULONG b_free;

 /* Clusters per Drive */
 ULONG b_total;

 /* Bytes per Sector */
 ULONG b_secsize;

 /* Sectors per Cluster */
 ULONG b_clsize;
} DISKINFO;
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH></TH><TD><I>drive</I> is a <B>WORD</B> which indicates the drive to perform the operation on. A value of <B>DEFAULT_DRIVE</B> (0) indicates the current <B>GEMDOS </B>drive. A value of 1 indicates drive 'A:', a 2 indicates 'B:', etc...
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   drive,-(sp)
pea   buf
move.w   #$36,-(sp)
trap   #1
addq.l   #8,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD>Upon return, a value of 0 indicates success. Otherwise, a negative <B>GEMDOS</B> error code is returned.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>Prior to <B>GEMDOS</B> version 0.15 this function is very slow when used on a hard disk.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>To obtain the free number of bytes on a disk, use the formula (<I>info.b_free</I> *<I> info.b_secsize</I> * <I>info.b_clsize</I>). To obtain the total number of bytes available on a disk, use the formula (<I>info.b_total</I> * <I>info.b_secsize</I> * <I>info.b_clsize</I>).
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Dgetcwd()</H3>

<P>
<B>LONG Dgetcwd( <I>size</I>, <I>drv</I>, <I>path</I> )</B>
<P>
<B>char *<I>path</I>;</B>
<P>
<B>WORD <I>drv</I>, <I>size</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dgetcwd()</B> returns the processes' current working directory for the specified drive.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>315 (0x13B)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available when a '<B>MiNT</B>' cookie with a version of at least 0.96 exists.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>path</I> is a pointer to a buffer with room for at least <I>size</I> characters into which will be copied the complete working path of drive <I>drv</I>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   path
move.w   size,-(sp)
move.w   drv,-(sp)
move.w   #$13B,-(sp)
trap   #1
lea   10(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Dgetcwd()</B> returns 0 if successful or a <B>GEMDOS</B> error code otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Dgetpath(), Dgetdrv()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3>Dgetdrv()</H3>

<P>
<B>WORD Dgetdrv( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dgetdrv()</B> returns the current <B>GEMDOS</B> drive code.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>25 (0x19)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$19,-(sp)
trap   #1
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Dgetdrv()</B> returns the current <B>GEMDOS</B> drive code. Drive 'A:' is represented by a return value of 0, 'B:' by a return value of 1, and so on.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Dsetdrv()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>Dgetpath()</H3>

<P>
<B>LONG Dgetpath( <I>buf</I>, <I>drive</I> )</B>
<P>
<B>char *<I>buf</I>;</B>
<P>
<B>WORD <I>drive</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dgetpath()</B> returns the current <B>GEMDOS</B> path specification.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>71 (0x47)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>buf</I> is a pointer to a character buffer which will contain the current <B>GEMDOS</B> path specification on function exit. <I>drive</I> is the number of the drive whose path you want returned. <I>drive</I> should be <B>DEFAULT_DRIVE</B> (0) for the current <B>GEMDOS</B> drive, 1 for drive 'A:', 2 for drive 'B:', and so on.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   drive,-(sp)
pea   buf
move.w   #47,-(sp)
trap   #1
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Dgetpath()</B> will return one of two errors on function exit:
<P>
 <B>E_OK</B> (0):  Operation successful
<P>
 <B>EDRIVE</B> (-49):  Invalid drive specification
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>As there is no way to specify the buffer size to this function you should allow at least 128 bytes of buffer space. This will allow for up to 8 folders deep. Newer file systems (CD-ROM drives) may demand up to 200 bytes.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Dsetpath()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>Dlock()</H3>

<P>
<B>LONG Dlock( <I>mode</I>, <I>drv</I> )</B>
<P>
<B>WORD <I>mode</I>, <I>drv</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dlock()</B> locks a <B>BIOS</B> disk device against <B>GEMDOS</B> usage.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>309 (0x135)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available when a '<B>MiNT</B>' cookie with a version of at least 0.93 exists.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD>Setting <I>mode</I> to <B>DRV_LOCK</B> (1) places a lock on <B>BIOS</B> device <I>drv</I> whereas a <I>mode</I> setting of <B>DRV_UNLOCK</B> (0) unlocks <I>drv</I>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   drv,-(sp)
move.w   mode,-(sp)
move.w   #$135,-(sp)
trap   #1
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Dlock()</B> returns 0 if successful or a negative <B>GEMDOS</B> error code otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Locking a device provides a method for device formatters to prevent other processes from simultaneously attempting to access a drive. If a process which locked a device terminates, that device is automatically unlocked.<B>BIOS</B> device numbers and <B>GEMDOS</B> drive letters do not necessarily have a one to one correspondence. To lock a <B>GEMDOS</B> drive use <B>Fxattr()</B> to determine the device number of the drive you wish to lock.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Fxattr()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>Dopendir()</H3>

<P>
<B>LONG Dopendir( <I>name</I>, <I>flag </I>)</B>
<P>
<B>char *<I>name</I>;</B>
<P>
<B>WORD <I>flag</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dopendir()</B> opens the specified directory for reading.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>296 (0x128)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available when a '<B>MiNT</B>' cookie with a version of at least 0.90 exists.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>name</I> is a pointer to a null-terminated directory specification of the directory to open. <I>name</I> should not be contain a trailing backslash.<I>flag</I> determines whether to open the file in normal or compatibility mode. A value of <B>MODE_NORMAL</B> (0) for <I>flag</I> signifies normal mode whereas a value of <B>MODE_COMPAT</B> (1) signifies compatibility mode.Compatibility mode forces directory searches to be performed much like <B>Fsfirst()</B> and <B>Fsnext()</B> (restricting filenames to the <B>DOS</B> 8 + 3 standard in uppercase). In normal mode, filenames returned by <B>Dreaddir()</B> will be in the format native to the file system and a <B>UNIX</B> style file index will be returned.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   flag,-(sp)
pea   name
move.w   #$128,-(sp)
trap   #1
addq.l   #8,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Dopendir()</B> returns a <B>LONG</B> directory handle (which may be positive or negative) if successful. A negative <B>GEMDOS</B> error code will be returned if the call fails.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>Failure to properly close directory handles may cause the system to eventually run out of handles which will cause the <B>OS</B> to fail.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Negative directory handles and negative <B>GEMDOS</B> error codes may be differentiated by checking for 0xFF in the high byte. Returned values with 0xFF in the high byte are errors.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Dclosedir(), Dreaddir(), Drewinddir()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=dpathconf2><H3>Dpathconf()</H3>

<P>
<B>LONG Dpathconf( <I>name</I>, <I>mode </I>)</B>
<P>
<B>char *<I>name</I>;</B>
<P>
<B>WORD <I>mode</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>Dpathconf()</B> returns information regarding limits and capabilities of an installed file system.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>292 (0x124)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>This function is available under all <B>MiNT</B> versions integrated with <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>name</I> specifies the file system you wish information about. <I>mode</I> dictates the return value as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >mode</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Return Value</FONT></B>
</TD></TR>

<TR><TH></TH><TD><B>DP_INQUIRE</B></TD><TD>
<CENTER>
<FONT SIZE=2>-1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Returns the maximum legal value for the mode parameter in <B>Dpathconf()</B>.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>DP_IOPEN</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Retuns the possible maximum number of open files at one time. If <B>UNLIMITED</B> (0x7FFFFFFF) is returned, then the number of open files is limited only by available memory.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>DP_MAXLINKS</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Returns the maximum number of links to a file. If <B>UNLIMITED</B> (0x7FFFFFFF) is returned, then the number of links to a file is limited only by available memory.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>DP_PATHMAX</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Returns the maximum length of a full path name in bytes. If <B>UNLIMITED</B> (0x7FFFFFFF) is returned, then the maximum size of a pathname is unlimited.  </FONT>
</TD></TR>

<TR><TH></TH><TD><B>DP_NAMEMAX</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Returns the maximum length of a file name in bytes. If <B>UNLIMITED</B> (0x7FFFFFFF) is returned, then the maximum length of a filename is unlimited.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>DP_ATOMIC</B></TD><TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Returns the number of bytes that can be written per write operation. If <B>UNLIMITED</B> (0x7FFFFFFF) is returned, then the number of bytes that can be written at once is limited only by available memory.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>DP_TRUNC</B></TD><TD>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Returns a code indicating the type of filename truncation as follows:</FONT><U><B>DP_NOTRUNC (0)</B></U><FONT SIZE=2>File names are not truncated. If a file name in any system call exceeds the filename size limit then an <B>ERANGE</B> (-64) range error is returned.</FONT><U><B>DP_AUTOTRUNC (1)</B></U><FONT SIZE=2>File names are truncated automatically to the maximum allowable length.</FONT><U><B>DP_DOSTRUNC (2)</B></U><FONT SIZE=2>File names are truncated to the <B>DOS</B> standard (maximum 8 character node with 3 character extension).</FONT>
</TD></TR>

<TR><TH></TH><TD><B>DP_CASE</B></TD><TD>
<CENTER>
<FONT SIZE=2>6</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Returns a code which indicates case sensitivity as follows:</FONT><U><B>DP_SENSITIVE (0)</B></U><FONT SIZE=2>File system is case-sensitive.</FONT>
<P>
<U><B><FONT SIZE=2>DP_NOSENSITIVE (1)</FONT></B></U>File system is not case-sensitive (file and path names are always converted to upper-case).<U><B><FONT SIZE=2>DP_SAVEONLY (2)</FONT></B></U>File system is not case-sensitive, however, file and path names are saved in their original case. Ex: A file called 'Compendi.um' will appear as 'Compendi.um' but may be referenced as 'compendi.um' or 'COMPENDI.UM'.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
move.w   mode,-(sp)
pea   name
move.w   #$124,-(sp)
trap   #1
addq.l   #8,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3>See above.</TD>
</TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>Sysconf()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3>Dreaddir()</H3>

<P>
<B>LONG Dreaddir( <I>len</I>, <I>dirhandle</I>, <I>buf </I>)</B>
<P>
<B>WORD <I>len</I>;</B>
<P>
<B>LONG <I>dirhandle</I>;</B>
<P>
<B>char *<I>buf</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dreaddir()</B> enumerates the contents of the specified directory.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>297 (0x129)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available when a '<B>MiNT</B>' cookie with a version of at least 0.90 exists.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><B>Dreaddir()</B> fetches information about the next file contained in the directory specified by <I>dirhandle</I>. <I>len</I> specifies the length of the buffer pointed to by <I>buf</I> which should be enough to hold the size of the filename, <B>NULL</B> byte, and index (if in normal mode).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   buf
move.l   dirhandle
move.w   len
move.w   #$129,-(sp)
trap   #1
lea   12(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Dreaddir()</B> returns a 0 if the operation was successful, <B>ERANGE</B> (-64) if the buffer was not large enough to hold the index and name, or <B>ENMFIL</B> (-47) if there were no more files to read.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>In normal mode, <B>Dreaddir()</B> returns a 4-byte file index in the first four bytes of <I>buf</I>. The filename then follows starting at the fifth byte of <I>buf</I>. The file index is present to prevent confusion under some file systems when two files of the same name exist. In some file systems this is legal, however, in all file systems, the 4-byte index will be unique.When in compatibility mode, the filename begins at &amp;<I>buf[0]</I>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Dopendir(), Dclosedir(), Drewinddir()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Drewinddir()</H3>

<P>
<B>LONG Drewinddir( <I>handle</I> )</B>
<P>
<B>LONG <I>handle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Drewinddir()</B> rewinds the specified directory pointer to its first file.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>298 (0x12A)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available when a '<B>MiNT</B>' cookie with a version of at least 0.90 exists.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies the directory handle of the directory to rewind.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.l   handle,-(sp)
move.w   #$12A,-(sp)
trap   #1
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Drewinddir()</B> returns a 0 if successful or a negative <B>GEMDOS</B> error code otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Dopendir(), Dreaddir(), Drewinddir()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Dsetdrv()</H3>

<P>
<B>LONG Dsetdrv( <I>drive</I> )</B>
<P>
<B>WORD<I> drive</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dsetdrv()</B> sets the current <B>GEMDOS</B> drive and returns a bitmap of mounted drives.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>14 (0x0E)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>drive</I> is the code of the drive to set as the default <B>GEMDOS</B> disk drive. Calling the function as:
<PRE>
 bmap = Dsetdrv(Dgetdrv());will return the bitmap of mounted drives without changing the current <B>GEMDOS</B> drive.
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   drive,-(sp)
move.w   #$0E,-(sp)
trap   #1
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Dsetdrv()</B> returns a <B>LONG</B> bit array that indicates which drives are mounted on the system. Bit 0 indicates drive 'A:', bit 1 drive 'B:', etc.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Dgetdrv()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>Dsetpath()</H3>

<P>
<B>LONG Dsetpath( <I>path</I> )</B>
<P>
<B>char *<I>path</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dsetpath() </B>sets the path of the current <B>GEMDOS</B> drive.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>59 (0x3B)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>path</I> is a pointer to a character buffer containing the new path specification for the current <B>GEMDOS</B> drive.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   path
move.w   #$3B,-(sp)
trap   #1
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Dsetpath()</B> returns one of two return codes on function exit:
<P>
 <B>E_OK</B> (0):  Operation successful
<P>
 <B>EPTHNF</B> (-34): Path not found
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>You may specify a drive letter and colon in the input path specification to set the path of a particular drive but this feature is unstable in all versions of <B>GEMDOS</B> and may confuse drive assignments. It is therefore advised that this feature be avoided.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Dgetpath()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=fattrib><H3>Fattrib()</H3>

<P>
<B>LONG Fattrib( <I>fname</I>, <I>flag</I>, <I>attr</I> )</B>
<P>
<B>char *<I>fname</I>;</B>
<P>
<B>WORD <I>flag</I>, <I>attr</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>Fattrib()</B> reads or modifies the attribute bits of a<B> GEMDOS </B>file.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>67 (0x43)</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=5><I>fname</I> is a pointer to a null-terminated string which contains the <B>GEMDOS</B> filename of the file to manipulate. <I>flag</I> should be set to <B>FA_INQUIRE</B> (0) to read the file's attributes and <B>FA_SET</B> (1) to set them. If you are setting attributes, <I>attr</I> contains the file's new attributes.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
move.w   attr,-(sp)
move.w   flag,-(sp)
pea   fname
move.w   #$43,-(sp)
trap   #1
lea   10(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=5>If reading the attributes, <B>Fattrib()</B> returns a bit array of attributes as defined below. If setting the attributes, <B>Fattrib()</B> returns the file's old attributes. In any case, a negative return code indicates that a <B>GEMDOS</B> error occurred.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
<B><FONT SIZE=1 >Name</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bit</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD><B>FA_READONLY</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Read-only flag</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>FA_HIDDEN</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Hidden file flag</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>FA_SYSTEM</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>System file flag</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>FA_VOLUME</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Volume label flag</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>FA_DIR</B></TD><TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Subdirectory</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>FA_ARCHIVE</B></TD><TD>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Archive flag</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
-
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>6...</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Currently reserved</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=5><B>GEMDOS</B> versions below 0.15 did not set the archive bit correctly. The archive bit is now correctly set by <B>TOS</B> when a file is created or written to.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=fchmod2><H3>Fchmod()</H3>

<P>
<B>LONG Fchmod( <I>name</I>, <I>mode </I>)</B>
<P>
<B>char *<I>name</I>;</B>
<P>
<B>WORD <I>mode</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>Fchmod()</B> alters file access permissions of the named file.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>306 (0x132)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>Available when a '<B>MiNT</B>' cookie with a version of at least 0.90 exists.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>name</I> specifies a valid <B>GEMDOS</B> file specification of the file whose access permissions you wish to modify. <I>mode</I> is a bit mask composed by OR'ing together values defined as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B><FONT SIZE=1 >Name</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Mask</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD>
<CENTER>
<B>S_IRUSR</B>
</CENTER>
</TD>
<TD>
<CENTER>
<FONT SIZE=2>0x100</FONT>
</CENTER>
</TD><TD><FONT SIZE=2>Read permission for the owner of the file.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>S_IWUSR</B>
</CENTER>
</TD>
<TD>
<CENTER>
<FONT SIZE=2>0x80</FONT>
</CENTER>
</TD><TD><FONT SIZE=2>Write permission for the owner of the file.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>S_IXUSR</B>
</CENTER>
</TD>
<TD>
<CENTER>
<FONT SIZE=2>0x40</FONT>
</CENTER>
</TD><TD><FONT SIZE=2>Execute permission for the owner of the file.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>S_IRGRP</B>
</CENTER>
</TD>
<TD>
<CENTER>
<FONT SIZE=2>0x20</FONT>
</CENTER>
</TD><TD><FONT SIZE=2>Read permission for members of the same group the file belongs to.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>S_IWGRP</B>
</CENTER>
</TD>
<TD>
<CENTER>
<FONT SIZE=2>0x10</FONT>
</CENTER>
</TD><TD><FONT SIZE=2>Write permission for members of the same group the file belongs to.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>S_IXGRP</B>
</CENTER>
</TD>
<TD>
<CENTER>
<FONT SIZE=2>0x08</FONT>
</CENTER>
</TD><TD><FONT SIZE=2>Execute permission for members of the same group the file belongs to.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>S_IROTH</B>
</CENTER>
</TD>
<TD>
<CENTER>
<FONT SIZE=2>0x04</FONT>
</CENTER>
</TD><TD><FONT SIZE=2>Read permission for all others.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>S_IWOTH</B>
</CENTER>
</TD>
<TD>
<CENTER>
<FONT SIZE=2>0x02</FONT>
</CENTER>
</TD><TD><FONT SIZE=2>Write permission for all others.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>S_IXOTH</B>
</CENTER>
</TD>
<TD>
<CENTER>
<FONT SIZE=2>0x01</FONT>
</CENTER>
</TD><TD><FONT SIZE=2>Execute permission for all others.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
move.w   mode,-(sp)
pea   name
move.w   #$132,-(sp)
trap   #1
addq.l   #8,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3><B>Fchmod()</B> returns <B>E_OK</B> (0) if successful or a negative <B>GEMDOS</B> error code otherwise.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=3>Not all file systems support all bits. Unrecognized bits will be ignored.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=3>Only the owner of a file may change a file's permission status.'Execute' status refers to the permission to search the named directory for a file name or component.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>Fattrib(), Fxattr()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Fchown()</H3>

<P>
<B>LONG Fchown( <I>name</I>, <I>uid</I>, <I>gid </I>)</B>
<P>
<B>char *<I>name</I>;</B>
<P>
<B>WORD <I>uid</I>, <I>gid</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Fchown()</B> changes a file's ownership.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>305 (0x131)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available when a '<B>MiNT</B>' cookie with a version of at least 0.90 exists.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>name</I> specifies the file whose ownership status you wish to change. <I>uid</I> sets the new owner and <I>gid</I> sets the new group.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   gid,-(sp)
move.w   uid,-(sp)
pea   name
move.w   #$131,-(sp)
trap   #1
lea   10(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Fchown()</B> returns 0 if the operation was successful or a negative <B>GEMDOS</B> error code otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>Most file systems don't understand the concept of file ownership (including <B>TOS</B>).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD><I>uid</I> may only be modifies if the caller's uid is 0. <I>gid</I> may only be changed to the group id of a group the caller belongs to.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Fchmod(), Fxattr()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<a name=fclose><H3>Fclose()</H3>

<P>
<B>LONG Fclose( <I>handle</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Fclose()</B> closes the file specified.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>62 (0x3E)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> is a valid <B>WORD</B> file handle which will be closed as a result of this call.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   handle,-(sp)
move.w   #$3E,-(sp)
trap   #1
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Fclose()</B> returns <B>E_OK</B> (0) if the file was closed successfully or <B>EIHNDL</B> (-37) if the handle given was invalid.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>Calling this function with an invalid file handle will crash the system on <B>GEMDOS</B> versions below 0.15. In addition, <B>GEMDOS</B> versions below 0.15 will become confused if you close a standard <B>GEMDOS</B> handle (0-5).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>As of <B>GEMDOS</B> version 0.15, closing a standard <B>GEMDOS</B> handle (0-5) will simply reset it to its default <B>BIOS</B> state.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Fcreate()</B>, <B>Fopen()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=fcnt2><H3>Fcntl()</H3>

<P>
<B>LONG Fcntl( <I>handle</I>, <I>arg</I>, <I>cmd </I>)</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>LONG <I>arg</I>;</B>
<P>
<B>WORD <I>cmd</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=2><B>Fcntl()</B> performs a command on the specified file.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=2>260 (0x104)</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=2>This function is available under all <B>MiNT</B> versions integrated with <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=2><I>handle</I> specifies the <B>GEMDOS</B> file handle of the file on which the operation specified by <I>cmd</I> will affect. <I>arg</I> varies with each command. Valid commands are:
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH></TH><TD>
<CENTER>
<I><B><FONT SIZE=1 >cmd</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD>
<CENTER>
<B>F_DUPFD</B>
</CENTER>

<P>

<CENTER>
(0x0000)
</CENTER>

</TD><TD><FONT SIZE=2>Duplicate the given file handle. <B>Fcntl()</B> will return a file handle in the range <I>arg </I>- 32. If no file handles exist within that range, an error will be returned.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>F_GETFD</B>
</CENTER>

<P>

<CENTER>
(0x0001)
</CENTER>

</TD><TD><FONT SIZE=2>Return the inheritance flag for the specified file. A value of 1 indicates that child processes started with <B>Pexec()</B> will inherit this file handle, otherwise a value of 0 is returned. <I>arg</I> is ignored.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>F_SETFD</B>
</CENTER>

<P>

<CENTER>
(0x0002)
</CENTER>

</TD><TD><FONT SIZE=2>Set the inheritance flag for the named file. <I>arg</I> specifies if child processes started with <B>Pexec()</B> will inherit the file handle. A value of 0 indicates that they will not. A value of 1 indicates that they will. <B>GEMDOS</B> handles 0-5 default to a value of 1whereas other handles default to a value of 0.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>F_GETFL</B>
</CENTER>

<P>

<CENTER>
(0x0003)
</CENTER>

</TD><TD><FONT SIZE=2>Return the file descriptor flags for the specified file. These are the same flags passed to <B>Fopen()</B>. <I>arg</I> is ignored.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>F_SETFL</B>
</CENTER>

<P>

<CENTER>
(0x0004)
</CENTER>

</TD><TD><FONT SIZE=2>Set the file decriptor flags for the specified file to <I>arg</I>. Only user-modifyable bits are considered. All others should be 0. It is not possible to change a file's read/write mode or sharing modes with this call. Attempts to do this will fail without returning an error code.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>F_GETLK</B>
</CENTER>

<P>

<CENTER>
(0x0004)
</CENTER>

</TD><TD><FONT SIZE=2>Test for the presence of a lock on the specified file. arg is a pointer to a <B>FLOCK</B> structure defined as follows:</FONT>
<PRE>
typedef struct flock
{
 /* Type of lock
    0 = Read-only lock
    1 = Write-only lock
    2 = Read/Write lock */
 WORD l_type;
 /* 0 = offset from beginning of file
    1 = offset from current position
    2 = offset from end of file */
 WORD l_whence;
 /* Offset to start of lock */
 LONG l_start;
 /* Length of lock (0 for rest of file) */
 LONG l_len;
 /* Process ID maybe filled in by call */
 WORD l_pid;
} FLOCK;<FONT SIZE=2>If a prior lock exists which would prevent the specified lock from being applied, the interfering lock is copied into the structure with the process ID of the locking process. Otherwise, <B>Fcntl()</B> returns <B>F_UNLCK</B> (3).</FONT>
</PRE>

</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>F_SETLK</B>
</CENTER>

<P>

<CENTER>
(0x0005)
</CENTER>

</TD><TD><FONT SIZE=2>Set or remove an advisory lock on the specified file. <I>arg</I> points to a <B>FLOCK</B> structure as defined above.</FONT>Setting <I>l_type</I> to <B>F_RDLOCK</B> or <B>F_WRLCK</B> will cause a lock to be set. Setting <I>l_type</I> to <B>F_UNLCK</B> wil attempt to remove the specified lock.<FONT SIZE=2>When locking and unlocking FIFO's,<I> l_whence</I>, <I>l_start</I>, and<I> l_len</I> should be 0.</FONT>The command returns 0 if successful or a negative <B>GEMDOS</B> error code otherwise.
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>F_SETLKW</B>
</CENTER>

<P>

<CENTER>
(0x0007)
</CENTER>

</TD><TD><FONT SIZE=2><a name=calling>The calling procedure is the same as above, however, if other processes already have a conflicting lock set, it will suspend the calling process until the lock is freed.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>FSTAT</B>
</CENTER>

<P>

<CENTER>
(0x4600)
</CENTER>

</TD><TD><FONT SIZE=2>Get the extended attributes for a file. <I>arg</I> points to a <B>XATTR</B> structure which is filled in with the file's extended attributes. If successful, the function returns 0, otherwise a negative <B>GEMDOS</B> error code is returned. See <B>Fxattr()</B> for an explanation of the <B>XATTR</B> structure.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>FIONREAD</B>
</CENTER>

<P>

<CENTER>
(0x4601)
</CENTER>

</TD><TD><FONT SIZE=2>Return an estimate of the number of bytes available for reading from the specified file without causing the process to block (wait for more input) in the <B>LONG</B> pointed to by <I>arg</I>.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>FIONWRITE</B>
</CENTER>

<P>

<CENTER>
(0x4602)
</CENTER>

</TD><TD><FONT SIZE=2>Return an estimate of the number of bytes that may be written from the specified file without causing the process to block in the <B>LONG</B> pointed to by <I>arg</I>.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>SHMGETBLK</B>
</CENTER>

<P>

<CENTER>
(0x4D00)
</CENTER>

</TD><TD><FONT SIZE=2>Returns the address of a memory block associated with the file. arg should be <B>NULL</B> for future compatibility.</FONT>Note: Different processes may receive different addresses for a shared block.
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>SHMSETBLK</B>
</CENTER>

<P>

<CENTER>
(0x4D01)
</CENTER>

</TD><TD><I><FONT SIZE=2>arg</FONT></I> points to a block of memory (previously allocated) which is to be associated with the file. The file must have been created at 'U:\SHM\' or the call will fail.
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>PPROCADDR</B>
</CENTER>

<P>

<CENTER>
(0x5001)
</CENTER>

</TD><TD><FONT SIZE=2>Return the address of the specified processes' control structure (opened as a file) in <I>arg</I>. See the discussion of <B>MiNT</B> processes for information about this structure.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>PBASEADDR</B>
</CENTER>

<P>

<CENTER>
(0x5002)
</CENTER>

</TD><TD><FONT SIZE=2>Return the address of the specified processes' <B>GEMDOS</B> basepage (opened as a file) in <I>arg</I>,</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>PCTXTSIZE</B>
</CENTER>

<P>

<CENTER>
(0x5003)
</CENTER>

</TD><TD><FONT SIZE=2>Return the length of the specified processes' context structure (opened as a file) in <I>arg</I>. Seeking to the offset returned by <B>PPROCADDR</B> minus this number and reading this many bytes will yield the current user context of the process. Seeking back this many bytes more and reading will yield the last system context of the process. This structure is volatile and is likely to change from one <B>MiNT</B> version to the next.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>PSETFLAGS</B>
</CENTER>

<P>

<CENTER>
(0x5004)
</CENTER>

</TD><TD><I><FONT SIZE=2>arg</FONT></I> is a pointer to a <B>LONG</B> from which the processes' memory allocation flags (<I><B>PRGFLAGS</B></I>) will be set.
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>PGETFLAGS</B>
</CENTER>

<P>

<CENTER>
(0x5005)
</CENTER>

</TD><TD><I><FONT SIZE=2>arg</FONT></I> is a pointer to a <B>LONG</B> into which the processes' memory allocation flags (<I><B>PRGFLAGS</B></I>) will be placed.
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>PTRACEGFLAGS</B>
</CENTER>

<P>

<CENTER>
(0x5006)
</CENTER>

</TD><TD><I><FONT SIZE=2>arg</FONT></I> points to a <B>WORD</B> which will be filled in with the trace flags of a process. <FONT SIZE=2>Setting bit #0 of <I>arg</I> causes the parent process to receive signals destined for the child. See the discussion on program debugging for more information. </FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>PTRACESFLAGS</B>
</CENTER>

<P>

<CENTER>
(0x5007)
</CENTER>

</TD><TD><I><FONT SIZE=2>arg</FONT></I> points to a <B>WORD</B> which will be used to set the trace flags of a process.<FONT SIZE=2>See the discussion on program <a name=debugging><a name=debuggingkeys>debugging for more information.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>PTRACEGO</B>
</CENTER>

<P>

<CENTER>
(0x5008)
</CENTER>

</TD><TD><FONT SIZE=2>This call restarts a process which was stopped because of a signal. <I>arg</I> points to a <B>WORD</B> which contains 0 to clear all of the child processes' pending signals or the signal value to send to the process.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>PTRACEFLOW</B>
</CENTER>

<P>

<CENTER>
(0x5009)
</CENTER>

</TD><TD><FONT SIZE=2>This call restarts a process in a special tracing mode in which the process is stopped and a <B>SIGTRACE</B> signal is generated whenever program flow changes (ex: JSR/BSR/JMP/BEQ). <I>arg</I> should be set to 0 to clear all of the pending signals of the process being traced or a signal value which is to be sent to the child.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>PTRACESTEP</B>
</CENTER>

<P>

<CENTER>
(0x500A)
</CENTER>

</TD><TD><FONT SIZE=2>This call restarts a process and allows it to execute one instruction before a <B>SIGTRAP</B> instruction is generated.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>PLOADINFO</B>
</CENTER>

<P>

<CENTER>
(0x500C)
</CENTER>

</TD><TD><I><FONT SIZE=2>arg</FONT></I> points to a structure as follows:
<PRE>
struct ploadinfo
<FONT SIZE=2>{
WORD  fnamelen;
</FONT> char * cmdlin;
<FONT SIZE=2> char * fname;
</FONT>};
<I>cmdlin</I> should point to a 128 byte character buffer into which the processes' command line will be copied.<I><FONT SIZE=2>fname</FONT></I> should point to a buffer <I>fnamelen</I> bytes long into which the complete path and filename of the process' parent will be copied. If the buffer is too short the call will return <B>ENAMETOOLONG</B>.
</PRE>

</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>TIOCGETP</B>
</CENTER>

<P>

<CENTER>
(0x5400)
</CENTER>

</TD><TD><FONT SIZE=2>Get terminal parameters from the TTY device with the specified file handle. <I>arg</I> is a pointer to an <B>sgttyb</B> structure which is filled in by this command.</FONT>
<PRE>
struct sgttyb
{
 /* Reserved */
 char sg_ispeed;
 /* Reserved */
 char sg_ospeed;
 /* Erase character */
 char sg_erase;
 /* Line kill character */
 char sg_kill;
 /* Terminal control flags */
 WORD sg_flags;
};
</PRE>

</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>TIOCSETP</B>
</CENTER>

<P>

<CENTER>
(0x5401)
</CENTER>

</TD><TD><FONT SIZE=2>Set the terminal parameters of the TTY device specified. <I>arg</I> is a pointer to an <B>sgyttb</B> structure as defined above. You should first get the terminal control parameters, modify what you wish to change, and then set them with this call. </FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>TIOCGETC</B>
</CENTER>

<P>

<CENTER>
(0x5402)
</CENTER>

</TD><TD><FONT SIZE=2>Get the terminal control characters of the TTY device specified. <I>arg</I> is a pointer to a <B>tchars</B> structure filled in by this call which is defined as follows:</FONT>
<PRE>
struct tchars
{
 /* Raises SIGINT */
 char t_intrc;
 /* Raises SIGKILL */
 char t_quitc;
 /* Starts terminal output */
 char t_startc;
 /* Stops terminal output */
 char t_stopc;
 /* Marks end of file */
 char t_eofc;
 /* Marks end of line */
 char t_brkc;
};
</PRE>

</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>TIOCSETC</B>
</CENTER>

<P>

<CENTER>
(0x5403)
</CENTER>

</TD><TD><FONT SIZE=2>Set the terminal control characters of the TTY device specified. <I>arg</I> is a pointer to a <B>tchars</B> structure as defined above. Setting any structure element to 0 disables that feature.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>TIOCGLTC</B>
</CENTER>

<P>

<CENTER>
 (0x5404)
</CENTER>

</TD><TD><FONT SIZE=2>Get the extended terminal control characters from the TTY device specified. <I>arg</I> is a pointer to a <B>ltchars</B> structure which is filled in by this call defined as follows:</FONT>
<PRE>
struct ltchars
{
 /* Raise SIGTSTP now */
 char t_suspc;
 /* Raise SIGTSTP when read */
 char t_dsuspc;
 /* Redraws the input line */
 char t_rprntc;
 /* Flushes output */
 char t_flushc;
 /* Erases a word */
 char t_werasc;
 /* Quotes a character */
 char t_lnextc;
};
</PRE>

</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>TIOCSLTC</B>
</CENTER>

<P>

<CENTER>
(0x5405)
</CENTER>

</TD><TD><FONT SIZE=2>Set the extended terminal control characters for the TTY device specified from the <B>ltchars</B> structure pointed to by <I>arg</I>.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>TIOCGPGRP</B>
</CENTER>

<P>

<CENTER>
(0x5406)
</CENTER>

</TD><TD><FONT SIZE=2>Return the process group ID for the TTY specified in the <B>LONG</B> pointed to by <I>arg</I>.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>TIOCSPGRP</B>
</CENTER>

<P>

<CENTER>
(0x5407)
</CENTER>

</TD><TD><FONT SIZE=2>Set the process group ID of the TTY specified in the <B>LONG</B> pointed to by <I>arg</I>.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>TIOCSTOP</B>
</CENTER>

<P>

<CENTER>
(0x5409)
</CENTER>

</TD><TD><FONT SIZE=2>Stop terminal output (as if the user had pressed ctrl-s). <I>arg</I> is ignored.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>TIOCSTART</B>
</CENTER>

<P>

<CENTER>
(0x540A)
</CENTER>

</TD><TD><FONT SIZE=2>Restart output to the terminal (as if the user had pressed ctrl-q) if it had been previously stopped with ctrl-s or a <B>TIOCSTOP</B> command. <I>arg</I> is ignored.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>TIOCGWINSZ</B>
</CENTER>

<P>

<CENTER>
(0x540B)
</CENTER>

</TD><TD><FONT SIZE=2>Get information regarding the window for this terminal. <I>arg</I> points to a <B>winsize</B> structure which is filled in by this command.</FONT>
<PRE>
struct winsize
{
 /* # of Text Rows */
 WORD ws_row;
 /* # of Text Columns */
 WORD ws_column;
 /* Width of window in pixels */
 WORD ws_xpixel;
 /* Height of window in pixels */
 WORD ws_ypixel;
}
</PRE>

</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>TIOCSWINSZ</B>
</CENTER>

<P>

<CENTER>
(0x540C)
</CENTER>

</TD><TD><FONT SIZE=2>Change the extents of the terminal window for the specified TTY. <I>arg</I> points to a <B>winsize</B> structure which contains the new window information. It is up to the window manager to modify the window extents and raise the <B>SIGWINCH</B> signal if necessary.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>TIOCGXKEY</B>
</CENTER>

<P>

<CENTER>
(0x540D)
</CENTER>

</TD><TD><FONT SIZE=2>Return the current definition of a system key. <I>arg</I> points to a structure <I>xkey</I> as follows:</FONT>
<PRE>
struct xkey
{
 WORD xk_num;
 char xk_def[8];
};<I><FONT SIZE=2>xk_def</FONT></I> will be filled in with the <B>NULL</B> terminated name associated with the key specified in <I>xk_num</I> as follows:<FONT SIZE=2> <U><I><B>xk_num</B></I><B> Key</B></U></FONT>
</PRE>

<P>
<FONT SIZE=2> 0-9 F1-F10</FONT>
<P>
<FONT SIZE=2> 10-19 F11-F20</FONT>
<P>
<FONT SIZE=2> 20 Cursor up</FONT>
<P>
<FONT SIZE=2> 21 Cursor down</FONT>
<P>
<FONT SIZE=2> 22 Cursor right</FONT>
<P>
<FONT SIZE=2> 23 Cursor left</FONT>
<P>
<FONT SIZE=2> 24 Help</FONT>
<P>
<FONT SIZE=2> 25 Undo</FONT>
<P>
<FONT SIZE=2> 26 Insert</FONT>
<P>
<FONT SIZE=2> 27 Clr/Home</FONT>
<P>
<FONT SIZE=2> 28 Shift+Cursor up</FONT>
<P>
<FONT SIZE=2> 29 Shift+Cursor down</FONT>
<P>
<FONT SIZE=2> 30 Shift+Cursor right</FONT>
<P>
<FONT SIZE=2> 31 Shift+Cursor left</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>TIOCSXKEY</B>
</CENTER>

<P>

<CENTER>
(0x540E)
</CENTER>

</TD><TD><FONT SIZE=2>Set the current definition of a system key. <I>arg</I>  must point to an <I>xkey</I> structure (as defined above). <I>xk_num</I> and <I>xk_def</I> are used to set the text associated with a system key.</FONT>If a terminal recognizes special keys (by having its <B>XKEY</B> bit set in the <I>sg_flags</I> field of its <I>sgttyb</I> structure) then setting a system key will cause the text specified by <I>xk_def</I> to be sent to a process whenever the key is struck. Note: this works only if the terminal is reading characters using <B>Fread()</B>.
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>TIOCIBAUD</B>
</CENTER>

<P>

<CENTER>
(0x5412)
</CENTER>

</TD><TD><FONT SIZE=2>Read/Write the input baud rate for the specified terminal device. If <I>arg</I> points to a <B>LONG</B> then the input baud rate will be set to that value. If <I>arg</I> is 0, the DTR on the terminal will be dropped (if this feature is supported). If <I>arg</I> is negative, the baud rate will not be changed. The old baud rate is returned in the value pointed to by <I>arg</I>.</FONT>If the terminal does not support separate input and output baud rates then this call will set both rates.
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>TIOCOBAUD</B>
</CENTER>

<P>

<CENTER>
(0x5413)
</CENTER>

</TD><TD><FONT SIZE=2>Read/Write the output baud rate for the specified terminal device. If <I>arg</I> points to a <B>LONG</B> then the output baud rate will be set to that value. If <I>arg</I> is 0, the DTR on the terminal will be dropped (if this feature is supported). If <I>arg</I> is negative, the baud rate will not be changed. The old baud rate is returned in the value pointed to by <I>arg</I>.</FONT>If the terminal does not support separate input and output baud rates then this call will set both rates.
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>TIOCCBRK</B>
</CENTER>

<P>

<CENTER>
(0x5414)
</CENTER>

</TD><TD><FONT SIZE=2>Clear the break condition on the specified device. <I>arg</I> is ignored.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>TIOCSBRK</B>
</CENTER>

<P>

<CENTER>
(0x5415)
</CENTER>

</TD><TD><FONT SIZE=2>Set the break condition on the specified device. <I>arg</I> is ignored.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>TIOCGFLAGS</B>
</CENTER>

<P>

<CENTER>
(0x5416)
</CENTER>

</TD><TD><FONT SIZE=2>Return the current stop bit/data bit configuration for the terminal device in the lower 16 bits of the <B>LONG</B> pointed to by <I>arg</I>. See the entry for <B>TIOCSFLAGS</B> for the flags required to parse <I>arg</I>.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>TIOCSFLAGS</B>
</CENTER>

<P>

<CENTER>
(0x5417)
</CENTER>

</TD><TD><FONT SIZE=2>Set the current stop bit/data bit configuration for the terminal device. The new configuration is contained in <I>arg</I>. Valid mask values for <I>arg</I> are as follows:</FONT> <U><B>Name Mask Meaning</B></U>
<P>
<FONT SIZE=2> <B>TF_1STOP</B> 0x0001 1 stop bit</FONT>
<P>
<FONT SIZE=2> <B>TF_15STOP</B> 0x0002 1.5 stop bits</FONT>
<P>
<FONT SIZE=2> <B>TF_2STOP</B> 0x0003 2 stop bits</FONT>
<P>
<FONT SIZE=2> <B>TF_8BIT</B> 0x0000 8 data bits</FONT>
<P>
<FONT SIZE=2> <B>TF_7BIT</B> 0x0004 7 data bits</FONT>
<P>
<FONT SIZE=2> <B>TF_6BIT</B> 0x0008 6 data bits</FONT>
<P>
<FONT SIZE=2> <B>TF_5BIT</B> 0x000C 5 data bits</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>TCURSOFF</B>
</CENTER>

<P>

<CENTER>
(0x6300)
</CENTER>

</TD><TD><FONT SIZE=2>Hide the cursor on the selected terminal device. <I>arg</I> is ignored.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>TCURSON</B>
</CENTER>

<P>

<CENTER>
(0x6301)
</CENTER>

</TD><TD><FONT SIZE=2>Show the cursor on the selected terminal device. <I>arg</I> is ignored.</FONT>
</TD></TR>

<TR><TD></TD><TD>
<CENTER>
<B><FONT SIZE=2>TCURSBLINK</FONT></B>
</CENTER>

<P>

<CENTER>
<FONT SIZE=2>(0x6302)</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Enable cursor blinking on the selected terminal device. <I>arg</I> is ignored.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>TCURSSTEADY</B>
</CENTER>

<P>

<CENTER>
(0x6303)
</CENTER>

</TD><TD><FONT SIZE=2>Disable cursor blinking on the selected terminal device. <I>arg</I> is ignored.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>TCURSSRATE</B>
</CENTER>

<P>

<CENTER>
(0x6304)
</CENTER>

</TD><TD><FONT SIZE=2>Set the cursor blink rate to the <B>WORD</B> pointed to by <I>arg</I>.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>TCURSGRATE</B>
</CENTER>

<P>

<CENTER>
(0x6305)
</CENTER>

</TD><TD><FONT SIZE=2>Return the current cursor blink rate in the <B>WORD</B> pointed to by <I>arg</I>.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=2>
<PRE>
move.w   cmd,-(sp)
move.l   arg,-(sp)
move.w   handle,-(sp)
move.w   #$260,-(sp)
trap   #1
lea   10(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=2>Unless otherwise noted, <B>Fcntl()</B> returns a 0 if the operation was successful or a negative <B>GEMDOS</B> error code otherwise.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=2><B>Flock(), Fopen(), Fxattr(), Pgetpgrp(), Psetpgrp()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=fcreate2><H3>Fcreate()</H3>

<P>
<B>LONG Fcreate( <I>fname</I>, <I>attr</I> )</B>
<P>
<B>char *<I>fname</I>;</B>
<P>
<B>WORD <I>attr</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=7><B>Fcreate()</B> creates a new file (or truncates an existing one) with the specified name and attributes.
</TD></TR>

<TR><TH></TH><TD COLSPAN=7></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=7>60 (0x3C)</TD></TR>

<TR><TH></TH><TD COLSPAN=7></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=7>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=7></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=7><I>fname</I> is a character pointer to the <B>GEMDOS</B> file specification of the file to create or truncate. <I>attr</I> is a bit array which specifies the attributes of the new file. Valid mask values are given below: 
</TD></TR>

<TR><TH></TH><TD COLSPAN=7></TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bit</FONT></B>
</CENTER>

</TD><TD COLSPAN=2><B><FONT SIZE=2 >Meaning</FONT></B>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2><B>FA_READONLY</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Read-only file</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2><B>FA_HIDDEN</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Hidden file</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2><B>FA_SYSTEM</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>System file</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2><B>FA_VOLUME</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Volume label</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2>-</TD><TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Reserved</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2><B>FA_ARCHIVE</B></TD><TD>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Archive bit</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=7>
<PRE>
move.w   attr,-(sp)
pea   fname,-(sp)
move.w   #$3C,-(sp)
trap   #1
addq.l   #8,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=7></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=7><B>Fcreate()</B> returns a <B>LONG</B> value. If the <B>LONG</B> is negative, it should be interpreted as a <B>GEMDOS</B> error.  Possible errors are <B>EPTHNF</B> (-34), <B>ENHNDL</B> (-35) , or <B>EACCDN</B> (36).If positive, the <B>WORD</B> portion of the returned <B>LONG</B> should be regarded as the file handle.
</TD></TR>

<TR><TH></TH><TD COLSPAN=7></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=7>With<B> GEMDOS</B> version 0.13, creating a read-only file returns a read-only file handle which is of little use. <B>GEMDOS </B>versions below 0.15 incorrectly allow more than one volume label per disk.
</TD></TR>

<TR><TH></TH><TD COLSPAN=7></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=7><B>GEMDOS </B>versions 0.15 and above automatically set the archive bit. You may set it yourself on versions below 0.15.
</TD></TR>

<TR><TH></TH><TD COLSPAN=7></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=7><B>Fopen()</B>,<B> Fclose()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=fdatime><H3>Fdatime()</H3>

<P>
<B>LONG Fdatime( <I>timeptr</I>, <I>handle</I>, <I>flag</I> )</B>
<P>
<B>DATETIME *<I>timeptr</I>;</B>
<P>
<B>WORD <I>handle</I>, <I>flag</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Fdatime()</B> reads or modifies a file's time and date stamp.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>87 (0x57)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>timeptr</I> is a pointer to a <a name=date_functions><B>DATETIME</B> structure which is represented below. <I>handle</I> is a valid <B>GEMDOS</B> file handle to the file to modify. <I>flag</I> is <B>FD_INQUIRE</B> (0) to fill <I>timeptr</I> with the file's date/timestamp and <B>FD_SET</B> (1) to change the file's date/timestamp to the contents of <I>timeptr</I>. 
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH></TH><TD>
<PRE>
typedef struct
{
 unsigned hour:5;
 unsigned minute:6;
 unsigned second:5;
 unsigned year:7;
 unsigned month:4;
 unsigned day:5;
} DATETIME;
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   flag,-(sp)
move.w   handle,-(sp)
pea   timeptr
move.w   #$57,-(sp)
trap   #1
lea   10(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Fdatime()</B> returns a 0 if the <a name=time_functions>date/time was successfully read/modified. Otherwise, it returns a negative <B>GEMDOS</B> error code.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD><B>GEMDOS</B> versions below 0.15 yielded very unpredictable results with this call and should therefore be avoided.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD><I>timeptr.second</I> should be multiplied times two to obtain the actual value. <I>timeptr.year</I> is expressed as an offset from 1980.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=fdelete><H3>Fdelete()</H3>

<P>
<B>LONG Fdelete( <I>fname</I> )</B>
<P>
<B>char *<I>fname</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Fdelete()</B> deletes the specified file.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>65 (0x41)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>fname</I> is the <B>GEMDOS</B> file specification of the file to be deleted.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   fname
move.w   #$41,-(sp)
trap   #1
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Fdelete()</B> returns <B>E_OK</B> (0) if the operation was successful or a negative <B>GEMDOS</B> error code if it fails.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>Do not attempt to delete a file that is currently open or unpredictable results will occur.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD><B>Ddelete()</B> must be used to delete subdirectories.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Ddelete()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=fdup><H3>Fdup()</H3>

<P>
<B>LONG Fdup( <I>shandle</I> )</B>
<P>
<B>WORD <I>shandle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Fdup()</B> duplicates a standard file handle (0-5) and assigns it a new handle (&gt;6).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>69 (0x45)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>shandle</I> is the standard <B>GEMDOS</B> handle to be duplicated.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   shandle,-(sp)
move.w   #$45,-(sp)
trap   #1
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Fdup()</B> returns a normal <B>GEMDOS</B> file handle in the lower <B>WORD</B> of the returned <B>LONG</B>. If the <B>LONG</B> return value is negative then it should be treated as a <B>GEMDOS</B> error code.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This function is generally used to save a standard file handle so that an <B>Fforce()</B> operation may be undone.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Fforce()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=fforce><H3>Fforce()</H3>

<P>
<B>LONG Fforce( <I>shandle</I>, <I>nhandle</I> )</B>
<P>
<B>WORD <I>shandle</I>, <I>nhandle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=4><B>Fforce()</B> is used to redirect the standard input or output from a <B>GEMDOS</B> standard handle to a specific handle created by the application.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=4>70 (0x46)</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=4>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=4><I>shandle</I> is a standard <B>GEMDOS</B> handle to be redirected. <I>nhandle</I> is the new handle you wish to direct it to. Valid values for <I>shandle</I> and <I>nhandle</I> are as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Handle</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >GEMDOS Filename</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>GSH_CONIN</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>con:</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2>Standard input (defaults to whichever <B>BIOS</B> device is mapped to <B>GEMDOS</B> handle -1)</FONT>
</TD></TR>

<TR><TH></TH><TD><B>GSH_CONOUT</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>con:</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2>Standard output (defaults to whichever <B>BIOS</B> device is mapped to <B>GEMDOS</B> handle -1)</FONT>
</TD></TR>

<TR><TH></TH><TD><B>GSH_AUX</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>aux:</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2>Currently mapped serial device (defaults to whichever <B>BIOS</B> device is mapped to <B>GEMDOS</B> handle -2)</FONT>
</TD></TR>

<TR><TH></TH><TD><B>GSH_PRN</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>prn:</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2>Printer port (defaults to whichever <B>BIOS</B> device is currently mapped to <B>GEMDOS</B> handle -3).</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
-
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>None</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2>Reserved</FONT></TD></TR>

<TR><TH></TH><TD>
<CENTER>
-
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>None</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2>Reserved</FONT></TD></TR>

<TR><TH></TH><TD><B>GSH_BIOSCON</B></TD><TD>
<CENTER>
<FONT SIZE=2>-1</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>None</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2>Refers to <B>BIOS</B> handle 2. This handle may only be redirected under the presence of <B>MiNT</B>. Doing so redirects output of the <B>BIOS</B>.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>GSH_BIOSAUX</B></TD><TD>
<CENTER>
<FONT SIZE=2>-2</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>None</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2>Refers to <B>BIOS</B> handle 1. This handle may only be redirected under the presence of <B>MiNT</B>. Doing so redirects output of the <B>BIOS</B>.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>GSH_BIOSPRN</B></TD><TD>
<CENTER>
<FONT SIZE=2>-3</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>None</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2>Refers to <B>BIOS</B> handle 0. This handle may only be redirected under the presence of <B>MiNT</B>. Doing so redirects output of the <B>BIOS</B>.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>GSH_MIDIIN</B>
<P>
<B>GSH_MIDIOUT</B></TD>
<TD>
<CENTER>
<FONT SIZE=2>-4</FONT>
</CENTER>

<P>

<CENTER>
<FONT SIZE=2>-5</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>None</FONT>
</CENTER>
</TD>
<TD><B><FONT SIZE=2>GEMDOS</FONT></B> handles -4 and 5 refer to <B>MIDI</B> input and output respectively. Redirecting these handles will affect <B>BIOS</B> handle 3. These special handles exist only with the presence of <B>MiNT</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=4>
<PRE>
move.w   nhandle,-(sp)
move.w   shandle,-(sp)
move.w   #$46,-(sp)
trap   #1
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=4><B>Fforce()</B> returns <B>E_OK</B> (0) if no error occurred or <B>EIHNDL</B> (-37) if a bad handle is given.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=4>Prior to <B>GEMDOS</B> versions 0.15, handles forced to the printer would not work properly.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=4>This function is often used to redirect the input or output of a child process. It should be used in conjunction with <B>Fdup()</B> to restore the standard handle before process termination. In addition, you should be aware that any file handle redirected to a standard handle ('con:' for example) will be closed when the child exits and should not be closed by the parent.Standard <B>GEMDOS</B> file handles which have been redirected will revert to their original mapping upon <B>Fclose()</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=4><B>Fdup()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>Fgetchar()</H3>

<P>
<B>LONG Fgetchar( <I>handle</I>, <I>mode </I>)</B>
<P>
<B>WORD <I>handle</I>, <I>mode</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>Fgetchar()</B> reads a character from the specified handle.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>263 (0x107)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>This function is available under all <B>MiNT</B> versions integrated with <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>handle</I> is a valid <B>GEMDOS</B> handle to read from. If <I>handle</I> is a TTY then <I>mode</I> (a bit mask) has meaning as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >mode</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>TTY_COOKED</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x01</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Cooked mode. Special control characters such as ctrl-c and ctrl-z are checked and acted upon. In addition, flow control with ctrl-s and ctrl-q is activated.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>TTY_ECHO</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x02</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Echo mode. Characters read are echoed back to the TTY.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
move.w   mode,-(sp)
move.w   handle,-(sp)
move.w   #$107,-(sp)
trap   #1
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3><B>Fgetchar()</B> returns the character read in the low byte of the returned <B>LONG</B>. If the device is a terminal where scan codes are available, the <B>LONG</B> will be mapped in the same manner as <B>Bconin()</B>. If an end-of-file is reached, the value 0xFF1A will be returned.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>Bconin(), Fputchar(), Fread()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Fgetdta()</H3>

<P>
<B>DTA *Fgetdta( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Fgetdta()</B> returns current <B>DTA</B> (Disk Transfer Address)
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>47 (0x2F)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD>None.</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$2F,-(sp)
trap   #1
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Fgetdta()</B> returns a pointer to the current Disk Transfer Address. The structure <B>DTA</B> is defined as:
<PRE>
typedef struct
{
 BYTE   d_reserved[21];
 BYTE   d_attrib;
 UWORD  d_time;
 UWORD  d_date;
 LONG   d_length;
 char   d_fname[14];
} DTA;
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>When an application starts, its <B>DTA</B> overlaps the command line string in the processes' basepage. Any use of the <B>Fsfirst()</B> or <B>Fsnext()</B> call without first reallocating a new <B>DTA</B> will cause the processes' command line to be corrupted.To prevent this, you should use <B>Fsetdta()</B> to define a new <B>DTA</B> structure for your process prior to using <B>Fsfirst()</B> or<B> Fsnext()</B>. Be careful to avoid assigning your <B>DTA</B> to a local or automatic variable without setting it to its original value before the variable goes out of scope.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Fsetdta(), Fsfirst(), Fsnext()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Finstat()</H3>

<P>
<B>LONG Finstat( <I>handle</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Finstat()</B> determines the input status of a file.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>261 (0x105)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This function is available under all <B>MiNT</B> versions integrated with <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies the <B>GEMDOS</B> file handle of the file to return information about.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   handle,-(sp)
move.w   #$105,-(sp)
trap   #1
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Finstat()</B> returns 0 or a positive number of characters waiting to be read if successful. A negative <B>GEMDOS</B> error code is returned otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>Currently <B>Finstat()</B> always returns 0 for disk files.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Cauxis(), Cconis(), Fcntl(), Foutstat()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Flink()</H3>

<P>
<B>LONG Flink( <I>oldname</I>, <I>newname </I>)</B>
<P>
<B>char *<I>oldname</I>, *<I>newname</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Flink()</B> creates a new name for the specified file. After the call the file may be referred to by either name. An <B>Fdelete()</B> call on one filename will not affect the other.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>301 (0x12D)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available when a '<B>MiNT</B>' cookie with a version of at least 0.90 exists.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>oldname</I> points to the <B>GEMDOS</B> path specification of the currently existing file and <I>newname</I> specifies the name of the alias to create.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   newname
pea   oldname
move.w   #$12D,-(sp)
trap   #1
lea   10(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Flink()</B> returns a 0 if successful or a negative <B>GEMDOS</B> error code otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>Not all file systems support 'hard links'. 
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The filenames given must reside on the same physical device.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Frename(), Fsymlink()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<a name=flock2><H3>Flock()</H3>

<P>
<B>LONG Flock( <I>handle</I>, <I>mode</I>, <I>start</I>, <I>length</I>
)</B>
<P>
<B>WORD <I>handle</I>,<I>mode</I>;</B>
<P>
<B>LONG <I>start</I>,<I>length</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Flock()</B> sets or removes a lock on a portion of a file which prevents other processes from accessing it.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>92 ($5C)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Only present when '<a name=flk2><B>_FLK</B>' cookie exists.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies the <B>GEMDOS</B> handle of the file. <I>mode</I> is <B>FLK_LOCK</B> (0) to create a lock and <B>FLK_UNLOCK</B> (1) to remove it. <I>start</I> specifies the byte offset from the beginning of the file which indicates where the lock starts. <I>length</I> specifies the length of the lock in bytes.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.l   length,-(sp)
move.l   start,-(sp)
move.w   mode,-(sp)
move.w   handle,-(sp)
trap   #1
lea   12(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Flock()</B> returns <B>E_OK</B> (0) if the call was successful, <B>ELOCKED </B>(-58) if an overlapping section of the file was already locked, <B>ENSLOCK</B> (-59) if a matching lock was not found for removal, or another <B>GEMDOS</B> error code as appropriate. 
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>To remove a lock, you must specify identical <I>start</I> and <I>length</I> parameters as you originally set.<B>MiNT</B> allows locks to be set on devices by locking their entry in 'U:\DEV\' as shown in the example below:
<PRE>
 handle = Fopen( "U:\DEV\MODEM1", 3 );
 if( handle &lt; 0)
   return ERR_CODE;  /* Unable to open. */

 retcode = Flock( (WORD)handle, 0, 0, 0 );  /* Lock */
 if( retcode != E_OK )
   return FILE_IN_USE; /* File is already locked */
 
 /*
  * Now do device input/output.
  */

 Flock( (WORD)handle, 1, 0, 0 );  /* Unlock */
 Fclose( (WORD)handle );
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Fopen(), Fwrite(), Fread()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=fmidipipe2><H3>Fmidipipe()</H3>

<P>
<B>LONG Fmidipipe( <I>pid</I>, <I>in</I>, <I>out </I>)</B>
<P>
<B>WORD <I>pid</I>, <I>in</I>, <I>out</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Fmidipipe()</B> is used to change the file handles used for MIDI input and output.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>294 (0x126)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available when a '<B>MiNT</B>' cookie with a version of at least 0.90 exists.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>pid</I> is the process id of the process whose MIDI devices you wish to alter. If <I>pid</I> is 0, then the current process will be modified. <I>in</I> specifies the <B>GEMDOS</B> file handle of the device to handle MIDI input. <I>out</I> specifies the <B>GEMDOS</B> file handle of the device to handle MIDI output.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   out,-(sp)
move.w   in,-(sp)
move.w   pid,-(sp)
move.w   #$126,-(sp)
trap   #1
addq.l   #8,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Fmidipipe()</B> returns a 0 if successful or a negative <B>GEMDOS</B> error code otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>An <B>Fmidipipe(</B> 0, <I>in</I>, <I>out </I><B>)</B> call is essentially the same as:
<PRE>
Fforce( -4, <I>in</I>);
Fforce( -5, <I>out</I>);After this call, any <B>Bconin()</B> calls to MIDI device 5 will translate to a one character read from handle <I>in</I>. Likewise any <B>Bconout()</B> calls to MIDI device 5 will translate to a one character write to handle <I>out</I>.
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Fdup(), Fforce()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=fopen><H3>Fopen()</H3>

<P>
<B>LONG Fopen( <I>fname</I>, <I>mode</I> )</B>
<P>
<B>char *<I>fname</I>;</B>
<P>
<B>WORD <I>mode</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=9><B>Fopen()</B> opens the <B>GEMDOS</B> file specified.
</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=9>61 ($3D)</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=9>All <B>GEMDOS</B> versions. <I>mode</I> bits pertaining to file sharing/record locking are only valid when the '<B>_FLK</B>' cookie is present.
</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=9><I>fname</I> is the <B>GEMDOS</B> file specification of the file to be opened. <I>mode</I> specifies the mode the file is to be placed into once opened. <I>mode</I> is a bit array which may be formed by using the bit masks given as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=3>
<CENTER>
<B><FONT SIZE=1 >Bit 7</FONT></B>
</CENTER>

</TD><TD COLSPAN=2>
<CENTER>
<B><FONT SIZE=2 >Bits 6-4</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bit 3</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bits 2-0</FONT></B>
</CENTER>

</TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=3>
<CENTER>
Inheritance flag
</CENTER>

</TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>Sharing mode</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>Reserved</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>Access code</FONT>
</CENTER>

</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH></TH><TD COLSPAN=9>Bits 0-2 specify the file access code as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
<B><FONT SIZE=1 >Bit 2</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=1 >Bit 1</FONT></B>
</CENTER>

</TD><TD COLSPAN=2>
<CENTER>
<B><FONT SIZE=1 >Bit 0</FONT></B>
</CENTER>

</TD><TD COLSPAN=3><B><FONT SIZE=2 >File Access Codes</FONT></B>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0
</CENTER>
</TD><TD>
<CENTER>
0
</CENTER>

</TD><TD COLSPAN=2>
<CENTER>
0
</CENTER>
</TD><TD COLSPAN=3><FONT SIZE=2>Read only access (<B>S_READ</B>)</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0
</CENTER>
</TD><TD>
<CENTER>
0
</CENTER>

</TD><TD COLSPAN=2>
<CENTER>
1
</CENTER>
</TD><TD COLSPAN=3><FONT SIZE=2>Write only access (<B>S_WRITE</B>)</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0
</CENTER>
</TD><TD>
<CENTER>
1
</CENTER>

</TD><TD COLSPAN=2>
<CENTER>
0
</CENTER>
</TD><TD COLSPAN=3><FONT SIZE=2>Read/Write access (<B>S_READWRITE</B>)</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH></TH><TD COLSPAN=9>Bit 3 is reserved and should always be 0. Bits 4-6 specify the file sharing mode of the file to be opened as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
<B><FONT SIZE=1 >Bit 6</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=1 >Bit 5</FONT></B>
</CENTER>

</TD><TD COLSPAN=2>
<CENTER>
<B><FONT SIZE=1 >Bit 4</FONT></B>
</CENTER>

</TD><TD COLSPAN=3><B><FONT SIZE=2 >File Sharing Codes</FONT></B>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0
</CENTER>
</TD><TD>
<CENTER>
0
</CENTER>

</TD><TD COLSPAN=2>
<CENTER>
0
</CENTER>
</TD><TD COLSPAN=3><FONT SIZE=2>Compatibility Mode (<B>S_COMPAT</B>). </FONT>If the file's read-only bit is set, then this is the same as Deny Writes, otherwise it is the same as Deny Read/Writes.
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0
</CENTER>
</TD><TD>
<CENTER>
0
</CENTER>

</TD><TD COLSPAN=2>
<CENTER>
1
</CENTER>
</TD><TD COLSPAN=3><FONT SIZE=2>Deny Read/Writes (<B>S_DENYREADWRITE</B>)</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0
</CENTER>
</TD><TD>
<CENTER>
1
</CENTER>

</TD><TD COLSPAN=2>
<CENTER>
0
</CENTER>
</TD><TD COLSPAN=3><FONT SIZE=2>Deny Writes (<B>S_DENYWRITE</B>)</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0
</CENTER>
</TD><TD>
<CENTER>
1
</CENTER>

</TD><TD COLSPAN=2>
<CENTER>
1
</CENTER>
</TD><TD COLSPAN=3><FONT SIZE=2>Deny Reads (<B>S_DENYREAD</B>)</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
1
</CENTER>
</TD><TD>
<CENTER>
0
</CENTER>

</TD><TD COLSPAN=2>
<CENTER>
0
</CENTER>
</TD><TD COLSPAN=3><FONT SIZE=2>Deny None (<B>S_DENYNONE</B>)</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH></TH><TD COLSPAN=9>Bit 7 (<B>S_INHERIT</B>) is the file's inheritance flag. If this flag is not set, a child process will inherit any open file handles and has the same access as the parent. If this flag is set, a child must re-open any files it wishes to use and must face the same sharing restrictions other processes must share.
</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=9>
<PRE>
move.w   mode,-(sp)
pea   fname
move.w   #$3D,-(sp)
trap   #1
addq.l   #8,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=9>Upon return, if the longword is positive, the lower <B>WORD</B> contains the new handle of the open file, otherwise the negative <B>LONG</B> should be regarded as a <B>GEMDOS</B> error code.
</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=9>Bits 7-3 of <I>mode</I> should be set to 0 unless the '<B>_FLK</B>' cookie is present indicating the presence of the file sharing/record locking extensions to <B>GEMDOS</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=9><B>Fclose(), Fcreate()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Foutstat()</H3>

<P>
<B>LONG Foutstat( <I>handle</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Foutstat()</B> determines the output status of a file.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>262 (0x106)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This function is available under all <B>MiNT</B> versions integrated with <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies the <B>GEMDOS</B> file handle of the file to return information about.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   handle,-(sp)
move.w   #$106,-(sp)
trap   #1
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Foutstat()</B> returns a 0 or positive number indicating the number of characters which may be written to the specified file without blocking. If an error occurred, <B>Foutstat()</B> returns a negative <B>GEMDOS</B> error code.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>Currently this function always returns 1 for disk files.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Cconos(), Cauxos(), Cprnos(), Fcntl(), Finstat()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Fpipe()</H3>

<P>
<B>LONG Fpipe( <I>fhandle</I> )</B>
<P>
<B>WORD <I>fhandle[2]</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Fpipe()</B> creates a pipe named 'SYS$PIPE.xxx' (where 'xxx' is a three digit integer) on 'U:\PIPE\' and returns two file handles to it, one for reading and one for writing.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>256 (0x100)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available when a '<B>MiNT</B>' cookie with a version of at least 0.90 exists.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>fhandle</I> is a pointer to an array of two <B>WORD</B>s. If the functions is successful, <I>fhandle[0]</I> will contain an open <B>GEMDOS</B> file handle to the pipe which may be used for reading only. <I>fhandle[1]</I> will contain an open <B>GEMDOS</B> file handle to the pipe which may be used for writing only.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   fhandle
move.w   #$100,-(sp)
trap   #1
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Fpipe()</B> returns <B>E_OK</B> (0) if successful or a negative <B>GEMDOS</B> error code otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>No more than 999 pipes created with <B>Fpipe()</B> may be in use at once.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This function is normally used by shells who wish to redirect the input and output of their child processes. Prior to lauching a child process, the shell redirects its input and output (as necessary) to the read and write ends of the newly created pipe.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=fputchar><H3>Fputchar()</H3>

<P>
<B>LONG Fputchar( <I>handle</I>, <I>lchar</I>, <I>mode </I>)</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>LONG <I>lchar</I>;</B>
<P>
<B>WORD <I>mode</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Fputchar()</B> writes a character to the specified file.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>264 (0x108)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This function is available under all <B>MiNT</B> versions integrated with <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies the handle of the file to write a character to. If the file specified by <I>handle</I> is a pseudo-terminal then all four bytes of <I>lchar</I> are written (it should be formatted as a character read from <B>Bconin()</B> ), otherwise only the low byte of <I>lchar</I> is transmitted. <I>mode</I> is only valid if <I>handle</I> refers to a terminal device. If <I>mode</I> is <B>TTY_COOKED</B> (0x0001) then control characters (which could cause <B>SIGINT</B> or <B>SIGTSTP</B> signals to be raised) passed through this function will be interpreted and acted upon. Setting <I>mode</I> to 0 will cause control characters to have no special effect.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   mode,-(sp)
move.l   lchar,-(sp)
move.w   handle,-(sp)
move.w   #$108,-(sp)
trap   #1
lea   10(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Fputchar()</B> returns 4L if the character was output to a terminal, 1L if the character was output to a non-terminal, 0L if the character could not be written (possibly because of flow control), <B>EIHNDL</B> (-37) if the handle was invalid, or a negative <B>BIOS</B> error code if an error occurred during I/O.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Cconout(), Cauxout(), Crawio(), Cprnout(), Bconout(), Fgetchar(), Fwrite()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=fread2><H3>Fread()</H3>

<P>
<B>LONG Fread( <I>handle</I>, <I>length</I>, <I>buf</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>LONG <I>length</I>;</B>
<P>
<B>VOIDP <I>buf</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Fread()</B> reads binary data from a specified file from the current file pointer.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>63 (0x3F)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> is the <B>GEMDOS</B> file handle of the file to read from<I>.</I> <I>length</I> specifies the number of bytes of data to read. <I>buf</I> is a pointer to a buffer (at least <I>length</I> bytes long) where the read data will be stored.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   buf
move.l   length,-(sp)
move.w   handle,-(sp)
move.w   #$3F,-(sp)
trap   #1
lea   12(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Fread()</B> returns either a positive amount indicating the number of bytes actually read (this number may be smaller than length if an <a name=eof><B>EOF</B> is hit) or a negative <B>GEMDOS</B> error code.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD><B>Fread()</B> will crash the system if given a parameter of 0 for <I>length</I> on <B>GEMDOS</B> versions lower than 0.15.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Fwrite(), Fopen(), Fclose()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Freadlink()</H3>

<P>
<B>LONG Freadlink( <I>bufsiz</I>, <I>buf</I>, <I>name </I>)</B>
<P>
<B>WORD <I>bufsiz</I>;</B>
<P>
<B>char *<I>buf</I>, *<I>name</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Freadlink()</B> determines what file the specified symbolic link refers to.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>303 (0x12F)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available when a '<B>MiNT</B>' cookie with a version of at least 0.90 exists.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>bufsiz</I> specifies the length of buffer <I>buf</I> into which the original file pointed to by the symbolic link <I>name</I> is written.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   name
pea   buf
move.w   bufsiz,-(sp)
move.w   #$12F,-(sp)
trap   #1
lea   12(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Freadlink()</B> returns 0 if successful or a negative <B>GEMDOS</B> error code otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Fsymlink()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=frename2><H3>Frename()</H3>

<P>
<B>LONG Frename( <I>reserved</I>, <I>oldname</I>, <I>newname</I>
)</B>
<P>
<B>WORD <I>reserved</I>;</B>
<P>
<B>char *<I>oldname</I>,*<I>newname</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Frename()</B> renames a standard <B>GEMDOS</B> file. It may also be used to move a file in the tree structure of a physical drive.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>86 (0x56)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>reserved </I>is not currently used and should be 0. <I>oldname</I> is the <B>GEMDOS</B> file specification of the file's current name/location. <I>newname</I> is the <B>GEMDOS</B> file specification of the new name/location of the file.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   newname
pea   oldname
move.w   #0,-(sp)
trap   #1
move.w  #$56,-(sp)
lea   12(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Frename()</B> returns <B>E_OK</B> (0) if the operation was successful or a negative <B>GEMDOS</B> error code if not.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>Prior to <B>GEMDOS</B> version 0.15, this command may not be used to rename folders. Also, do not attempt to rename a file that is currently open under any version of <B>GEMDOS</B>.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=fseek2><H3>Fseek()</H3>

<P>
<B>LONG Fseek( <I>offset</I>, <I>handle</I>, <I>mode</I> )</B>
<P>
<B>LONG <I>offset</I>;</B>
<P>
<B>WORD <I>handle</I>,<I>mode</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>Fseek()</B> moves the file position pointer within a <B>GEMDOS</B> file.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>66 (0x42)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>handle</I> specifies the <B>GEMDOS</B> file handle of the file pointer to modify. The meaning of <I>offset</I> varies with <I>mode</I> as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >mode</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>SEEK_SET</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>offset</FONT></I> specifies the positive number of bytes from the beginning of the file.
</TD></TR>

<TR><TH></TH><TD><B>SEEK_CUR</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>offset</FONT></I> specifies the negative or positive number of bytes from the current file position.
</TD></TR>

<TR><TH></TH><TD><B>SEEK_END</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>offset</FONT></I> specifies the positive number of bytes from the end of the file.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
move.w   mode,-(sp)
move.w   handle,-(sp)
move.l   offset,-(sp)
move.w   #$42,-(sp)
trap   #1
lea   10(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3><B>Fseek()</B> returns a positive value representing the new absolute location of the file pointer from the beginning of the file or a negative <B>GEMDOS</B> error code. 
</TD></TR>

</TABLE>

<P>

<HR>

<a name=fselect2><H3>Fselect()</H3>

<P>
<B>WORD Fselect( <I>timeout</I>, <I>rfds</I>, <I>wfds</I>, <I>reserved
</I>)</B>
<P>
<B>WORD <I>timeout</I>;</B>
<P>
<B>LONG *<I>rfds</I>, *<I>wfds</I>;</B>
<P>
<B>LONG <I>reserved</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Fselect()</B> enumerates file descriptors which are ready for reading and/or writing.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>285 (0x11D)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This function is available under all <B>MiNT</B> versions integrated with <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>timeout</I> specifies the maximum amount of time (in milliseconds) to wait for at least one of the specified file descriptors to become unblocked. If <I>timeout</I> is 0 then the process will wait indefinitely. <I>rfds</I> and <I>wfds</I> each point to a <B>LONG</B> bitmap describing the read and write file descriptors to wait for. Setting bit #10 of the <B>LONG</B> pointed to by <I>rfds</I>, for example, will cause <B>Fselect()</B> to return when <B>GEMDOS</B> handle 10 is available for reading. As many read or write file descriptors can be specified per call as desired. Specifying <B>NULL</B> for either <I>rfds</I> or <I>wfds</I> is the same as passing a pointer to a <B>LONG</B> with no bits set.Upon return the <B>LONG</B>s pointed to by <I>rfds</I> and <I>wfds</I> will be filled in with a similar bitmap indicating which handles are ready to be read/written. <I>reserved</I> should always be set to 0L.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.l   reserved,-(sp)
pea   wfds
pea   rfds
move.w   timeout,-(sp)
move.w   #$11D,-(sp)
trap   #1
lea   16(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Fselect()</B> returns the sum of bits set in both <I>rfds</I> and <I>wfds</I>. A return value of 0 indicates that the function timed out before any of the specified file handles became available. A negative <B>GEMDOS</B> error code is returned if the function failed.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD><B>Fselect()</B> does not currently work on any <B>BIOS</B> device except the keyboard.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD><B>Fselect( </B>0L, 0L, 0L, 0L<B>)</B> will block the calling process forever.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Finstat(), Foutstat()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<a name=fsetdta2><H3>Fsetdta()</H3>

<P>
<B>VOID Fsetdta( <I>ndta</I> )</B>
<P>
<B>DTA *<I>ndta</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Fsetdta()</B> sets the location of a new <B>DTA</B> (Disk Transfer Address) in memory.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>26 (0x1A)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>ndta</I> is a pointer to a valid memory area which will be used as the new <B>DTA</B>. The <B>DTA</B> structure is defined under the entry for <B>Fgetdta()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   ndta
move.w   #$1A,-(sp)
trap   #1
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>When an application starts, its <B>DTA</B> overlaps the command line string in the processes' basepage. Any use of the <B>Fsfirst()</B> or <B>Fsnext()</B> call without first reallocating a new <B>DTA</B> will cause the processes' command line to be corrupted.To prevent this, you should use <B>Fsetdta()</B> to define a new <B>DTA</B> structure for your process prior to using <B>Fsfirst()</B> or<B> Fsnext()</B>. Be careful to avoid assigning your <B>DTA</B> to a local or automatic variable without setting it to its original value before the variable goes out of scope.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Fgetdta(), Fsfirst(), Fsnext()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=fsfirst2><H3>Fsfirst()</H3>

<P>
<B>WORD Fsfirst( <I>fspec</I>, <I>attribs</I> )</B>
<P>
<B>char *<I>fspec</I>;</B>
<P>
<B>WORD <I>attribs</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>Fsfirst()</B> searches the file/pathspec given for the first occurrence of a file or subdirectory with named attributes and if found, fill in the current <B>DTA</B> with that file's information.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>78 (0x4E)</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=5><I>fspec</I> is the <B>GEMDOS</B> file specification of the file or subdirectory to search for. This specification may use wildcard characters (? or *) within the filename, however they may not be used within the pathname. This function is the only <B>GEMDOS</B> function which accepts wildcard characters in the path specification.<I>attribs</I> is a bit mask which can combine several file characteristics that further narrows the search as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bit Mask</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD><B>FA_READONLY</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x01</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Include files which are read-only.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>FA_HIDDEN</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x02</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Include hidden files.</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>FA_SYSTEM</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x04</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Include system files.</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>FA_VOLUME</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x08</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Include volume labels.</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>FA_DIR</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x10</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Include subdirectories.</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>FA_ARCHIVE</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x20</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Include files with archive bit set.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
move.w   attribs,-(sp)
pea   fspec
move.w   #$4E,-(sp)
trap   #1
addq.l   #8,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=5><B>Fsfirst()</B> returns <B>E_OK</B> (0) if a file was found and the <B>DTA</B> was successfully filled in with the file information. Otherwise, it returns a negative <B>GEMDOS</B> error code.The <B>DTA</B> structure is defined as:
<PRE>
typedef struct
{
  BYTE  d_reserved[21];
  BYTE  d_attrib;
  UWORD d_time;
  UWORD d_date;
  LONG  d_length;
  char  d_fname[14];
} DTA;
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=5>This function uses the application's <B>DTA</B> which is initially located in the same memory location as the processes' command line. Using this function without first assigning a new <B>DTA</B> will corrupt the command line.When running in the <B>MiNT</B> domain (see <B>Pdomain()</B>), <B>Fsfirst()</B> and <B>Fsnext()</B> will fill in the <B>DTA</B> with lowercase filenames rather than the standard <B>TOS</B> uppercase.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=5><B>Fsnext(), Fgetdta(), Fsetdta()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=fsnext2><H3>Fsnext()</H3>

<P>
<B>WORD Fsnext( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Fsnext()</B> should be called as many times as necessary after a corresponding <B>Fsfirst()</B> call to reveal all files which match the search criteria.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>79 (0x4F)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$4F,-(sp)
trap   #1
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Fsnext()</B> returns <B>E_OK</B> (0) if another file matching the search criteria given in <B>Fsfirst()</B> is found and the <B>DTA</B> has been properly filled in with the file's information. Otherwise, a negative <B>GEMDOS</B> error code is returned.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This function uses the application's <B>DTA</B> which is initially located in the same memory location as the processes' command line. Using this function without first assigning a new <B>DTA</B> will corrupt the command line.This call should only be used after <B>Fsfirst()</B> and the contents of the <B>DTA</B> should not be modifed between the calls.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Fsfirst()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=fsymlink2><H3>Fsymlink()</H3>

<P>
<B>LONG Fsymlink( <I>oldname</I>, <I>newname </I>)</B>
<P>
<B>char *<I>oldname</I>, *<I>newname</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Fsymlink()</B> creates a symbolic link to a file.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>302 (0x12E)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available when a '<B>MiNT</B>' cookie with a version of at least 0.90 exists.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>oldname</I> points to the file specification of the file to create a link to. <I>newname</I> points to the file specification of the link to create.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   newname
pea   oldname
move.w   #$12E,-(sp)
trap   #1
lea   10(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Fsymlink()</B> returns 0 if successful or a negative <B>GEMDOS</B> error code otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD><B>Fsymlink()</B>, unlike <B>Flink()</B>, creates symbolic links, which, unlike hard links, can be setup between physical devices and file systems.An <B>Fdelete()</B> call to a symbolic link will delete the link, not the file. A call to <B>Fdelete()</B> on the original file will cause future references to the created symbolic link to fail.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Flink(), Freadlink()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<a name=fwrite2><H3>Fwrite()</H3>

<P>
<B>LONG Fwrite( <I>handle</I>, <I>count</I>, <I>buf</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>LONG <I>count</I>;</B>
<P>
<B>VOIDP <I>buf</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Fwrite()</B> writes the contents of a buffer to the specified <B>GEMDOS</B> file.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>64 (0x40)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> is the handle of the file to write to. <I>count</I> specifies the number of bytes to write. <I>buf</I> indicates the starting address of the data to write.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   buf
move.l   count,-(sp)
move.w   handle,-(sp)
move.w   #$40,-(sp)
trap   #1
lea   12(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Fwrite()</B> returns the positive number of bytes actually written or a negative <B>GEMDOS</B> error code if the operation failed.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>Prior to <B>GEMDOS</B> version 0.15, calling <B>Fwrite()</B> with a <I>count</I> parameter of 0 will hang the system.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Fread()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=fxattr2><H3>Fxattr()</H3>

<P>
<B>LONG Fxattr( <I>flag</I>, <I>name</I>, <I>xattr </I>)</B>
<P>
<B>WORD <I>flag</I>;</B>
<P>
<B>char *<I>name</I>;</B>
<P>
<B>XATTR *<I>xattr</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=2><B>Fxattr()</B> returns extended information about the specified file.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=2>300 (0x12C)</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=2>Available when a '<B>MiNT</B>' cookie with a version of at least 0.90 exists.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=2><I>flag</I> specifies whether attributes returned by this call on symbolic links should be those of the file to which the link points or the link itself. A value of <B>FX_FILE</B> (0) causes the attributes to be those of the actual file whereas a value of <B>FX_LINK</B> (1) returns the attributes of the link itself.<I>name</I> specifies the name of the file from which attributes are to be read and placed in the <B>XATTR</B> structure pointed to by <I>xattr</I>. <B>XATTR</B> is defined as follows:
<PRE>
typedef struct
{
 UWORD mode;
 LONG index;
 UWORD dev;
 UWORD reserved1;
 UWORD nlink;
 UWORD uid;
 UWORD gid;
 LONG size;
 LONG blksize;
 LONG nblocks;
 WORD mtime;
 WORD mdate;
 WORD atime;
 WORD adate;
 WORD ctime;
 WORD cdate;
 WORD attr;
 WORD reserved2;
 LONG reserved3;
 LONG reserved4;
} XATTR;<B>XATTR</B>'s members have the following meaning:
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B><FONT SIZE=1 >XATTR</FONT></B>
</CENTER>

<P>

<CENTER>
<B><FONT SIZE=1 >Element</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD>
<CENTER>
<I>mode</I>
</CENTER>
</TD><TD><FONT SIZE=2>Masking <I>mode</I> with 0xF000 reveals the file type as one of the following:</FONT>
<P>
<FONT SIZE=2>   <B>S_IFCHR</B> (0x2000)</FONT>
<P>
<FONT SIZE=2>   <B>S_IFDIR</B> (0x4000)</FONT>
<P>
<FONT SIZE=2>   <B>S_IFREG</B> (0x8000)</FONT>
<P>
<FONT SIZE=2>   <B>S_IFIFO</B> (0xA000)</FONT>
<P>
<FONT SIZE=2>   <B>S_IMEM</B> (0xC000)</FONT>
<P>
<FONT SIZE=2>   <B>S_IFLNK</B> (0xE000)</FONT>The lower three nibbles of <I>mode</I> is a bit mask which specifies the legal file access mode(s) as defined in<B> Fchmod()</B>. 
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<I>index</I>
</CENTER>
</TD><TD><FONT SIZE=2>This member combined with the <I>dev</I> field are designed to provide a unique identifier for a file under file systems which allow multiple files with the same filename.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<I>dev</I>
</CENTER>
</TD><TD><FONT SIZE=2>This value represents either a <B>BIOS</B> device number or an identifier created by the file system to represent a remote device.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<I>reserved1</I>
</CENTER>
</TD>
<TD><FONT SIZE=2>This structure element is currently reserved for future implementations of <B>MiNT</B>.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<I>nlink</I>
</CENTER>
</TD><TD><FONT SIZE=2>This value specifies the current number of hard links attached to the file. On a file system that does not support hard links and for most regular files, <I>nlink</I> is 1.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<I>uid</I>
</CENTER>
</TD><TD><I><FONT SIZE=2>uid</FONT></I> is the user ID of the owner of the file.
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<I>gid</I>
</CENTER>
</TD><TD><I><FONT SIZE=2>gid</FONT></I> is the group ID of the owner of the file.
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<I>size</I>
</CENTER>
</TD><TD><I><FONT SIZE=2>size</FONT></I> is the length of the file in bytes.
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<I>blksize</I>
</CENTER>
</TD>
<TD><I><FONT SIZE=2>blksize</FONT></I> specifies the size of blocks (in bytes) in this file system.
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<I>nblocks</I>
</CENTER>
</TD>
<TD><I><FONT SIZE=2>nblocks</FONT></I> is the actual number of blocks the file is using on the device. This number may include data storage elements other used to keep track of the file (aside from the actual data).
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<I>mtime, mdate</I>
</CENTER>

</TD><TD><FONT SIZE=2>Time and date of the last file modification in <B>GEMDOS</B> format.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<I>atime, adate</I>
</CENTER>

</TD><TD><FONT SIZE=2>Time and date of the last file access in <B>GEMDOS</B> format.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<I>ctime, cdate</I>
</CENTER>

</TD><TD><FONT SIZE=2>Time and date of the file's creation in <B>GEMDOS</B> format.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<I>attr</I>
</CENTER>
</TD><TD><FONT SIZE=2>Standard file attributes (same as read by <B>Fattrib()</B> ).</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<I>reserved2</I>
</CENTER>
</TD>
<TD><FONT SIZE=2>This structure element is currently reserved for future implementations of <B>MiNT</B>.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<I>reserved3</I>
</CENTER>
</TD>
<TD><FONT SIZE=2>This structure element is currently reserved for future implementations of <B>MiNT</B>.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<I>reserved4</I>
</CENTER>
</TD>
<TD><FONT SIZE=2>This structure element is currently reserved for future implementations of <B>MiNT</B>.</FONT>
</TD></TR>

<TR><TH></TH><TD></TD><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=2>
<PRE>
pea   xattr
pea   name
move.w   flag,-(sp)
move.w   #$12C,-(sp)
trap   #1
lea   12(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=2><B>Fxattr()</B> returns 0 if successful or a negative <B>GEMDOS</B> error code otherwise.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=2><B>Fattrib()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3>Maddalt()</H3>

<P>
<B>LONG Maddalt( <I>start</I>, <I>size</I> )</B>
<P>
<B>VOIDP <I>start</I>;</B>
<P>
<B>LONG <I>size</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Maddalt()</B> informs <B>GEMDOS</B> of the existence of additional 'alternative' RAM that would not normally have been identified by the system.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>20 (0x14)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available as of <B>GEMDOS</B> version 0.19 only.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>start</I> indicates the starting address for the block of memory to be added to the <B>GEMDOS</B> free list. <I>size</I> indicates the length of this block in bytes.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.l   size,-(sp)
pea   start
move.w   #$14,-(sp)
trap   #1
lea   10(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Maddalt()</B> returns <B>E_OK</B> (0) if the call succeeds or a negative <B>GEMDOS</B> error code otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call should only be used to identify RAM not normally identified by the <B>BIOS</B> at startup (added through a VME-card or hardware modification). Once this RAM has been identified to the system it may not be removed and should only be allocated and used via the standard system calls. In addition, programs wishing to use this RAM must have their alternative RAM load bit set or use <B>Mxalloc()</B> to specifically request alternative RAM.See the discussion earlier in this chapter for more information about the types of available RAM.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Mxalloc()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=malloc2><H3>Malloc()</H3>

<P>
<B>VOIDP Malloc( <I>amount</I> )</B>
<P>
<B>LONG <I>amount</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Malloc()</B> requests a block of memory for use by an application.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>72 (0x48)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>amount</I> specifies the amount of memory (in bytes) you wish to allocate. You may pass a value of -1L in which case the function will return the size of the largest free block of memory.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.l   amount,-(sp)
move.w   #$48,-(sp)
trap   #1
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Malloc()</B> returns <B>NULL</B> if there is no block large enough to fill the request or a pointer to the block if the request was satisfied. The memory allocated will be chosen based on the status of the processes' load flags. To specify the memory requirements in more detail, use<B> Mxalloc()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>Prior to <B>GEMDOS</B> version 0.15, <B>Malloc( </B>0L<B> )</B> will return a pointer to invalid memory as opposed to failing as it should.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Because <B>GEMDOS</B> can only allocate a limited amount of blocks per process (as few as 20 depending on the version of <B>GEMDOS</B>), applications should limit their usage of this call by allocating a few large blocks instead of many small blocks or use a 'C' memory manager (like <B>malloc()</B> ) if possible.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Mxalloc()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=mfree><H3>Mfree()</H3>

<P>
<B>WORD Mfree( <I>startadr</I> )</B>
<P>
<B>VOIDP <I>startadr</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Mfree()</B> releases a block of memory previously reserved with <B>Malloc()</B> or <B>Mxalloc()</B> back into the <B>GEMDOS</B> free list.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>73 (0x49)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>startadr</I> is the starting address of the block to be freed. This address must be the same as that returned by the corresponding <B>Malloc()</B> or <B>Mxalloc()</B> call.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   startadr
move.w   #$49,-(sp)
trap   #1
addq.   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Mfree()</B> returns <B>E_OK</B> (0) if the block was freed successfully or a negative <B>GEMDOS</B> error code otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Malloc(), Mxalloc()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3>Mshrink()</H3>

<P>
<B>WORD Mshrink( <I>startadr</I>, <I>newsize</I> )</B>
<P>
<B>VOIDP <I>startadr</I>;</B>
<P>
<B>LONG <I>newsize</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Mshrink()</B> releases a portion of a block's memory to the <B>GEMDOS</B> free list.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>74 (0x4A)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>startadr</I> is the address of the block whose size you wish to decrease. <I>newsize</I> is the length you now desire for the block. 
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.l   newsize,-(sp)
pea   startadr
clr.w   -(sp)  // Required/Reserved Value
move.w   #$4A,-(sp)
trap   #1
lea   12(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Mshrink()</B> returns <B>E_OK</B> (0) if the operation was successful or a negative <B>GEMDOS</B> error code otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>This call should be used only to 'shrink' a memory block, not to enlarge it.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Malloc(), Mxalloc(), Mfree()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Mxalloc()</H3>

<P>
<B>VOIDP Mxalloc( <I>amount</I>, <I>mode</I> )</B>
<P>
<B>LONG <I>amount</I>;</B>
<P>
<B>WORD <I>mode</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=2><B>Mxalloc()</B> allocates a block of memory according to specified preferences.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=2>68 (0x44)</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=2>Available from <B>GEMDOS</B> version 0.19.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=2><I>amount</I> specifies the length (in bytes) of the block requested. As with <B>Malloc()</B>, specifying -1L for <I>amount</I> will return the size of the largest block of memory available. With modes 0 or 1, the size of the largest block of available RAM from the specified type of RAM is returned. Modes 2 and 3 return the size of the largest available block or whichever type of  RAM had the largest block. <I>mode</I> is a <B>WORD</B> bit array which specifies the type of memory requested as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B><FONT SIZE=1 >Bit</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD>
<CENTER>
0-1
</CENTER>
</TD><TD><FONT SIZE=2>Bits 0-1 represent a possible value of 0-3 representing the type of RAM to allocate as follows:</FONT> <U><B>Name Value Meaning</B></U>
<P>
<FONT SIZE=2> <B>MX_STRAM</B> 0 Allocate only ST-RAM</FONT>
<P>
<FONT SIZE=2> <B>MX_TTRAM</B> 1 Allocate only TT-RAM</FONT>
<P>
<FONT SIZE=2> <B>MX_PREFSTRAM</B> 2 Allocate either, preferring ST-RAM</FONT>
<P>
<FONT SIZE=2> <B>MX_PREFTTRAM</B> 3 Allocate either, preferring TT-RAM</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
2
</CENTER>
</TD><TD><FONT SIZE=2>Not used (should be set to 0).</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
3
</CENTER>
</TD><TD><FONT SIZE=2>If set, refer to bits 4-7 for memory protection advice, otherwise default to protection specified in program header. This bit is only valid in the presence of <B>MiNT</B>.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
4-7
</CENTER>
</TD><TD><FONT SIZE=2>Bits 4-7 represent a possible value of 0-7 representing the memory protection mode to place on the allocated block of memory. Currently valid values are:</FONT> <U><B>Name Value Meaning</B></U><FONT SIZE=2> <B>MX_HEADER</B> 0 Refer to Program Header</FONT>
<P>
<FONT SIZE=2> <B>MX_PRIVATE</B> 1 Private</FONT>
<P>
<FONT SIZE=2> <B>MX_GLOBAL</B> 2 Global</FONT>
<P>
<FONT SIZE=2> <B>MX_SUPERVISOR</B> 3 <a name=supervisormode>Supervisor Mode Only Access</FONT>
<P>
<FONT SIZE=2> <B>MX_READABLE</B> 4 Read Only Access</FONT>These bits are only consulted if bit 3 is set and <B>MiNT</B> is present.
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
8-15
</CENTER>
</TD><TD><FONT SIZE=2>Not used (should be set to 0).</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=2>
<PRE>
move.w   mode,-(sp)
move.l   amount,-(sp)
move.w   #$44,-(sp)
trap   #1
addq.l   #8,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=2><B>Mxalloc()</B> returns <B>NULL</B> if the request could not be granted or a valid pointer to the start of the block allocated otherwise.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=2><B>Mxalloc()</B> should be used instead of <B>Malloc()</B> whenever it is available.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=2><B>Malloc(), Mfree()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Pause()</H3>

<P>
<B>VOID Pause( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Pause()</B> suspends the process until a signal is received.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>289 (0x121)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This function is available under all <B>MiNT</B> versions integrated with <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$121,-(sp)
trap   #1
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>If the signal handler does a 'C' <B>longjmp()</B> to a different point in the process or if the handler's purpose is to exit the process, this call will never return.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Psigblock(), Psignal(), Psigsetmask()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Pdomain()</H3>

<P>
<B>WORD Pdomain( <I>domain</I> )</B>
<P>
<B>WORD <I>domain</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Pdomain()</B> determines/modifies the calling processes' execution domain.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>281 (0x119)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This function is available under all <B>MiNT</B> versions integrated with <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>domain</I> contains the domain code of the new process domain. Currently the only valid values are <B>DOMAIN_TOS</B> (0) for the <B>TOS</B> compatibility domain and <B>DOMAIN_MINT</B> (1) for the <B>MiNT</B> domain. Passing a negative value for <I>domain</I> will not change domains but it will return the current domain.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   domain,-(sp)
move.w   #$119,-(sp)
trap   #1
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Pdomain()</B> returns the domain in effect prior to the call.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Process domain affects system calls like<B> Fread()</B>, <B>Fwrite()</B>, <B>Fsfirst()</B>, and <B>Fsnext()</B>. Processes behave as expected when under the <B>TOS</B> domain.When processes run under the <B>MiNT</B> domain, however, the behavior of <B>Fread</B>() and <B>Fwrite()</B> calls when dealing with terminals can be modified by <B>Fcntl()</B>. Also, <B>Fsfirst()</B> and <B>Fsnext()</B> may not necessarily return the standard <B>DOS</B> 8 + 3 file name format. <B>MiNT</B> domain processes must understand filenames formatted for different file systems.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Fcntl()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=pexec2><H3>Pexec()</H3>

<P>
<B>LONG Pexec( <I>mode</I>, <I>fname</I>, <I>cmdline</I>, <I>envstr</I>
)</B>
<P>
<B>WORD <I>mode</I>;</B>
<P>
<B>char *<I>fname</I>,*<I>cmdline</I>,*<I>envstr</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>Pexec()</B> has many functions designed to spawn child processes depending on the selected mode.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>75 (0x4B)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3><B>Pexec()</B> modes 0, 3, 4, and 5, are available in all <B>GEMDOS</B> versions. Mode 6 is available as of <B>GEMDOS</B> version 0.15. Mode 6 is available as of <B>GEMDOS</B> version 0.19. Modes 100, 104, 106, and 200 are only available in the presence of <B>MiNT</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>mode</I> defines the function of <B>Pexec()</B> and the meaning of its parameters and return value as defined below. For modes which load a program, <I>fname</I> specifies the <B>GEMDOS</B> file specification of the file to load. <I>cmdline</I> is pointer to a string containg the command line which will be passed to the calling program. The first byte of the string should indicate the length of the command line (maximum of 125 bytes). The actual command line starts at byte 2. <I>envstr</I> is a pointer to an environment which is copied and assigned to the child process. If <I>envstr</I> is <B>NULL</B>, the child inherits a copy of the parent's environment.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >mode</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>PE_LOADGO</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2>'LOAD AND GO'</FONT></B> - Load and execute named program file and return a <B>WORD</B> exit code when the child terminates.
</TD></TR>

<TR><TH></TH><TD><B>PE_LOAD</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2>'LOAD, DON'T GO'</FONT></B> - Load named program. If successful, the <B>LONG</B> return value is the starting address of the child processes' basepage. The parent owns the memory of the child's environment and basepage and must therefore free them when completed with the child.
</TD></TR>

<TR><TH></TH><TD><B>PE_GO</B></TD><TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2>'JUST GO'</FONT></B> - Execute process with basepage at specified address. With this mode, <I>fname</I> and <I>envstr</I> are <B>NULL</B>. The starting address of the basepage of the process to execute is given in the <I>cmdline</I> parameter.
</TD></TR>

<TR><TH></TH><TD><B>PE_BASEPAGE</B></TD><TD>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2>'CREATE BASEPAGE'</FONT></B> - This mode allocates the largest block of free memory and creates a basepage in the first 256 bytes of it. <I>fname</I> should be set to <B>NULL</B>. It is the responsibility of the parent to load or define the child's code, shrink the memory block as necessary, and initialize the basepage pointers to the TEXT, DATA, and BSS segments of the program.<FONT SIZE=2>With <B>MiNT</B>, use of this mode in conjunction with mode <B>PE_CGO</B> can be used to emulate the <B>Pvfork()</B> call without blocking the parent.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>PE_GOTHENFREE</B></TD><TD>
<CENTER>
<FONT SIZE=2>6</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2>'JUST GO, THEN FREE'</FONT></B> - This mode is identical to mode <B>PE_GO</B> except that memory ownership of the child's environment and basepage belong to the child rather than the parent so that when the child <B>Pterm()</B>'s, that memory is automatically freed.
</TD></TR>

<TR><TH></TH><TD><B>PE_CLOADGO</B></TD><TD>
<CENTER>
<FONT SIZE=2>100</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2>'LOAD, GO, DON'T WAIT'</FONT></B> - This mode is identical to mode <B>PE_LOADGO</B> except that the parent process is returned to immediately while the child continues to execute. The positive process ID of the child is returned. Environment and basepage memory blocks are freed automatically when the child <B>Pterm()</B>'s
</TD></TR>

<TR><TH></TH><TD><B>PE_CGO</B></TD><TD>
<CENTER>
<FONT SIZE=2>104</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2>'JUST GO, DON'T WAIT'</FONT></B> - This mode is similar to mode <B>PE_GO</B> except that the parent process is returned to immediately while the child continues to execute concurrently. The positive process ID of the child is returned. Memory ownership of the environment and basepage are shared by the parent and child (this sharing extends to all memory owned by the parent). <I><FONT SIZE=2>fname</FONT></I> may be used to supply a name for the child, otherwise, if <B>NULL</B> is used, the name of the parent will be used. <I>cmdline</I> should point to the process basepage. <I>envstr</I> should be <B>NULL</B>.
</TD></TR>

<TR><TH></TH><TD><B>PE_NOSHARE</B></TD><TD>
<CENTER>
<FONT SIZE=2>106</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2>'JUST GO, DON'T WAIT, NO SHARING'</FONT></B> - This mode is exactly the same as mode <B>PE_CGO</B> except that the child process owns its own environment and basepage sharing no memory with the parent.
</TD></TR>

<TR><TH></TH><TD><B>PE_REPLACE</B></TD><TD>
<CENTER>
<FONT SIZE=2>200</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2>'REPLACE PROGRAM AND GO'</FONT></B> - This mode works like mode <B>PE_CLOADGO</B> except that the parent process is terminated immediately and the child process completely replaces the parent in memory retaining the same process ID. <I>fname</I>, <I>cmdline</I>, and <I>envstr</I>, are all normally passed and valid.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
pea   envstr
pea   cmdline
pea   fname
move.w   mode,-(sp)
move.w   #$4B,-(sp)
trap   #1
lea   16(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3>The value returned by <B>Pexec()</B> is dependent on the <I>mode</I> value and is therefore explained above. All <B>Pexec()</B> modes return a <B>LONG</B> negative <B>GEMDOS</B> error code when the call fails. A <B>WORD</B> negative value indicates the child was successfully run but it terminated returning a negative error code. In all cases, a process returning after having been interrupted with ctrl-c returns 0x0000FFE0 (-32).
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=3>Command lines longer than 126 bytes may be passed to processes aware of the <B>Atari Extended Command Line Specification</B> (see discussion earlier in this chapter).
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>shel_write()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=pfork2><H3>Pfork()</H3>

<P>
<B>WORD Pfork( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Pfork()</B> creates a copy of the current process.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>283 (0x11B)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This function is available under all <B>MiNT</B> versions integrated with <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$11B,-(sp)
trap   #1
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Pfork()</B> returns the new process ID in the parent and a 0 in the child.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>If the parent is in supervisor mode when this call is made, the child is started in user mode anyway.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>After a <B>Pfork()</B> call, two instances of one process will exist in memory. Program execution in both processes continue at the same point in the TEXT segment following this call. The parent's DATA and BSS segments are physically copied so that any variables that change in the child will not affect the parent and vice versa.New processes started with this call should not call <B>Mshrink()</B> but are required to do any <B>GEM</B> initialization such as <B>appl_init()</B> and <B>v_opnvwk()</B> again (if <B>GEM</B> usage is needed). Both the parent and child use <B>Pterm()</B> or <B>Pterm0()</B> to terminate themselves.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Pexec(), Pvfork()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3>Pgetegid()</H3>

<P>
<B>WORD Pgetegid( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Pgetegid()</B> returns the effective group ID of the process.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>313 (0x139)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available when a '<B>MiNT</B>' cookie with a version of at least 0.95 exists.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$139,-(sp)
trap   #1
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The effective group ID of a process will be different than its actual group ID if its set gid bit is set. This mechanism allows users to grant file access to other users.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Pgetgid(), Pgeteuid()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3>Pgeteuid()</H3>

<P>
<B>WORD Pgeteuid( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Pgeteuid()</B> returns the effective user ID of the process.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>312 (0x138)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available when a '<B>MiNT</B>' cookie with a version of at least 0.95 exists.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$138,-(sp)
trap   #1
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The effective group ID of a process will be different than its actual group ID if its set gid bit is set. This mechanism allows users to grant file access to other users.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Pgetuid(), Pgetegid()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3>Pgetgid()</H3>

<P>
<B>WORD Pgetgid( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Pgetgid()</B> returns the group ID (0-255) of the calling process.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>271 (0x10F)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This function is available under all <B>MiNT</B> versions integrated with <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$10F,-(sp)
trap   #1
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Psetgid()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>Pgetpgrp()</H3>

<P>
<B>WORD Pgetpgrp( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Pgetpgrp()</B> returns the process group ID code for the calling process.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>269 (0x10D)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This function is available under all <B>MiNT</B> versions integrated with <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$10D,-(sp)
trap   #1
addq.l   #2
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Process groups are closely related processes which are used for job control and signaling purposes. Process groups usually terminate together rather than one at a time.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Psetpgrp(), Pkill()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<a name=pgetpid2><H3>Pgetpid()</H3>

<P>
<B>WORD Pgetpid( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Pgetpid()</B> returns the positive <B>WORD</B> process ID code for the calling process. This identifer uniquely identifies the process within the system.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>267 (0x10B)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This function is available under all <B>MiNT</B> versions integrated with <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$10B,-(sp)
trap   #1
addq.l   #2,sp
</PRE>

</TD></TR>

</TABLE>

<P>

<HR>

<H3>Pgetppid()</H3>

<P>
<B>WORD Pgetppid( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Pgetppid()</B> returns the process ID for the calling processes' parent.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>268 (0x10C)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This function is available under all <B>MiNT</B> versions integrated with <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$10C,-(sp)
trap   #1
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Pgetppid()</B> returns the process ID code for the parent of the calling process or 0 if it was started by the kernel (not a child process).
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Pgetuid()</H3>

<P>
<B>WORD Pgetuid( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Pgetuid()</B> returns the user ID code (0-255) of the calling process which determines access permissions and can be used in a multi-user system to differentiate users.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>271 (0x10F)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This function is available under all <B>MiNT</B> versions integrated with <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$10F,-(sp)
trap   #1
addq.l   #2
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Psetuid()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=pkill><H3>Pkill()</H3>

<P>
<B>WORD Pkill( <I>pid</I>, <I>sig </I>)</B>
<P>
<B>WORD <I>pid</I>, <I>sig</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Pkill()</B> sends a signal to one or more processes.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>273 (0x111)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This function is available under all <B>MiNT</B> versions integrated with <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><B>Pkill()</B> sends signal <I>sig</I> to certain processes based on the value of <I>pid</I>. If <I>pid</I> is positive, the signal is sent the the process with process identifier pid. If <I>pid</I> is 0, the signal is sent to all processes who belong to the same process group as the caller as well as the caller itself. If <I>pid</I> is negative, the signal is sent to all processes with process group number -<I>pid</I>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   sig,-(sp)
move.w   pid,-(sp)
move.w   #$111,-(sp)
trap   #1
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Pkill()</B> returns 0 if successful or a negative <B>GEMDOS</B> error code otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>If the caller is also a recipient of a signal and that signal causes program termination this call will never return.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Psignal()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>Pmsg()</H3>

<P>
<B>WORD Pmsg( <I>mode</I>, <I>mboxid</I>, <I>msgptr </I>)</B>
<P>
<B>WORD <I>mode</I>;</B>
<P>
<B>LONG <I>mboxid</I>;</B>
<P>
<B>PMSG *<I>msgptr</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=4><B>Pmsg()</B> sends/receives a message to/from a 'message box'.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=4>293 (0x125)</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=4>Available when a '<B>MiNT</B>' cookie with a version of at least 0.90 exists.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=4><I>mode</I> specifies the action to take as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >mode</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Operation</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>MSG_READ</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Block the process and don't return until a message is read from the specified mailbox ID <I>mboxid</I> and placed in the structure pointed to by <I>msgptr</I>. </FONT>
</TD></TR>

<TR><TH></TH><TD><B>MSG_WRITE</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Block the process and don't return until a process waiting for a message with mailbox ID <I>mboxid</I> has received the message contained in the structure pointed to by <I>msgptr</I>.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>MSG_READWRITE</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Block the process until a process waiting for a message with mailbox ID <I>mboxid</I> has received the message contained in the structure pointed to by <I>msgptr</I> and a return message is received with mailbox ID 0xFFFFxxxx where 'xxxx' is the process ID of the current process.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH></TH><TD COLSPAN=4><B>PMSG</B> is defined as:
<PRE>
typedef struct
{
 LONG userlong1;
 LONG userlong2;
 WORD pid;
} PMSG;On return from writes, <I>pmsg.pid</I> contains the process ID of the process who read your message, on return from reads, its the process ID of the writer. The contents of <I>userlong1</I> and <I>userlong2</I> is completely up to the sender.By OR'ing mode with <B>MSG_NOWAIT</B> (0x8000), you can prevent the call from blocking the process and simply return -1 if another process wasn't waiting to read or send your process a message.
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=4>
<PRE>
pea   msgptr
move.l   mboxid,-(sp)
move.w   mode,-(sp)
move.w   #$125,-(sp)
trap   #1
lea   12(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=4><B>Pmsg()</B> returns 0 if successful, -1 if bit 0x8000 is set and no process was ready to receive/send the desired message, or a negative <B>GEMDOS</B> error code.
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Pnice()</H3>

<P>
<B>WORD Pnice( <I>delta</I> )</B>
<P>
<B>WORD <I>delta</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Pnice()</B> alters the process priority of the calling process.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>266 (0x10A)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This function is available under all <B>MiNT</B> versions integrated with <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>delta</I> is a signed number which is added to the current process priority value. Positive values decrease process priority while negative values increase it.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   delta,-(sp)
move.w   #$10A,-(sp)
trap   #1
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Pnice()</B> returns the prior process priority.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The process priority value has no fixed formula so it is hard to be able to predict the results of this call with any accuracy. This call is the same as <B>Prenice(</B>&nbsp;<B>Pgetpid()</B>,&nbsp;<I>delta</I>&nbsp;<B>)</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Prenice()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>Prenice()</H3>

<P>
<B>LONG Prenice( <I>pid</I>, <I>delta </I>)</B>
<P>
<B>WORD <I>pid</I>, <I>delta</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Prenice()</B> adjusts the process priority of the specified process.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>295 (0x127)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available when a '<B>MiNT</B>' cookie with a version of at least 0.90 exists.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD>The process priority for the process with process ID <I>pid</I> is adjusted by signed value <I>delta</I>. Positive values for <I>delta</I> decrease process priority while negative values increase it. 
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   delta,-(sp)
move.w   pid,-(sp)
move.w   #$127,-(sp)
trap   #1
addq.l   #6
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Prenice()</B> returns a 32-bit negative <B>GEMDOS</B> error code if unsuccessful. Otherwise, the lower 16-bit signed value can be interpreted as the previous process priority code.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The exact effect adjusting process priorites will have is difficult to determine.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Pnice()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>Prusage()</H3>

<P>
<B>VOID Prusage( <I>rusg</I> )</B>
<P>
<B>LONG *<I>rusg</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>Prusage()</B> returns resource information about the current process.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>286 (0x11E)</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>This function is available under all <B>MiNT</B> versions integrated with <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=5><I>rusg</I> is a pointer to an array of 8 <B>LONG</B>s as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >rusg[x]</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD><B>PRU_KERNELTIME</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Time spent by process in <B>MiNT</B> kernel.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>PRU_PROCESSTIME</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Time spent by process in its own code.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>PRU_CHILDKERNALTIME</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Total <B>MiNT</B> kernel time spent by children of this process.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>PRU_CHILDPROCESSTIME</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Total user code time spent by children of this process.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>PRU_MEMORY</B></TD><TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Total memory allocated by process (in bytes).</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
-
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>5-7</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Reserved for future use.</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
pea   rusg
move.w   #$11E,-(sp)
trap   #1
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=5>All times given are in milliseconds.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=5><B>Psetlimit()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3>Psemaphore()</H3>

<P>
<B>LONG Psemaphore( <I>mode</I>, <I>id</I>, <I>timeout </I>)</B>
<P>
<B>WORD <I>mode</I>;</B>
<P>
<B>LONG <I>id</I>;</B>
<P>
<B>LONG <I>timeout</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>Psemaphore()</B> creates a semaphore which may only be accessed by one process at a time.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>308 (0x134)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>Available when a '<B>MiNT</B>' cookie with a version of at least 0.92 exists.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>mode</I> specifies the mode of the operation which affects the other two parameters as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >mode</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>SEM_CREATE</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Create a semaphore with called <I>id</I> and grant ownership to the calling process. <I>timeout</I> is ignored.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>SEM_DESTROY</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Destroy the semaphore called <I>id</I>. This only succeeds if the semaphore is owned by the caller. <I>timeout</I> is ignored.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>SEM_LOCK</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Request ownership of semaphore <I>id</I>. The process will wait for the semaphore to become available for <I>timeout</I> milliseconds and then return. If <I>timeout</I> value of 0 will force the call to return immediately whether or not the semaphore is available. A <I>timeout</I> value of -1 will cause the call to wait indefinitely.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>SEM_UNLOCK</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Release ownership of semaphore <I>id</I>. The caller must be the current owner of the semaphore to release control. <I>timeout</I> is ignore.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
move.l   timeout,-(sp)
move.l   id,-(sp)
move.w   mode,-(sp)
move.w   #$134,-(sp)
trap   #1
lea   12(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3><B>Psemaphore()</B> returns a 0 if successful, <B>ERROR</B> (-1) if the process requested a semaphore it already owned, or a negative <B>GEMDOS</B> error code.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<a name=semaphores><TR><TH><B>Comments</B></TH><TD COLSPAN=3>If your process is waiting for ownership of a semaphore and it is destroyed by another process, an <B>ERANGE</B> (-64) error will result. Any semaphores owned by a process when it terminates are released but not deleted.
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Psetgid()</H3>

<P>
<B>WORD Psetgid( <I>gid</I> )</B>
<P>
<B>WORD <I>gid</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Psetgid()</B> sets the group ID of the calling process.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>277 (0x115)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This function is available under all <B>MiNT</B> versions integrated with <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>gid</I> is the group ID code to assign the calling process (0-255).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   gid,-(sp)
move.w   #$115,-(sp)
trap   #1
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Psetgid()</B> returns gid if successful or <B>EACCDN</B> (-36) if the process did not have the authority to change the group ID.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The group ID of a process may only be changed when it is currently 0. Therefore, once the group ID has been set, it is fixed and unchangeable. Further attempts to modify it will result in an <B>EACCDN</B> error.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Pgetgid()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>Psetlimit()</H3>

<P>
<B>LONG Psetlimit( <I>limit</I>, <I>value </I>)</B>
<P>
<B>WORD <I>limit</I>;</B>
<P>
<B>LONG <I>value</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>Psetlimit()</B> reads/modifies resource allocation limits for the calling process and all of its children.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>287 (0x11F)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>This function is available under all <B>MiNT</B> versions integrated with <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>limit</I> defines the resource to read or modify as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >limit</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>LIM_MAXTIME</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Maximum CPU time in milliseconds. If <I>value</I> is positive, <I>value</I> determines the new maximum. If <I>value</I> is 0, then the limit is set at 'unlimited'. If <I>value</I> is negative, the current value is returned but not modified. </FONT>
</TD></TR>

<TR><TH></TH><TD><B>LIM_MAXMEM</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Maximum total memory allowed for process. If <I>value</I> is positive, <I>value</I> determines the new maximum. If <I>value</I> is 0, then the limit is set at 'unlimited'. If <I>value</I> is negative, the current value is returned but not modified. </FONT>
</TD></TR>

<TR><TH></TH><TD><B>LIM_MAXMALLOC</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Maximum total size of each Malloc (Mxalloc). If <I>value</I> is positive, <I>value</I> determines the new maximum. If <I>value</I> is 0, then the limit is set at 'unlimited'. If <I>value</I> is negative, the current value is returned but not modified. </FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
move.l   value,-(sp)
move.w   limit,-(sp)
move.w   #$11F,-(sp)
trap   #1
addq.l   #8,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3><B>Psetlimit()</B> returns the previous value or <B>ERANGE</B> (-64) if the value for <I>limit</I> was out of range.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=3>The limits imposed by <B>Psetlimit()</B> are inherited from the parent by child processes.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>Prusage()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3>Psetpgrp()</H3>

<P>
<B>LONG Psetpgrp( <I>pid</I>, <I>newgrp </I>)</B>
<P>
<B>WORD <I>pid</I>, <I>newgrp</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Psetpgrp()</B> sets the process group ID of the specified process. 
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>270 (0x10E)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This function is available under all <B>MiNT</B> versions integrated with <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD>The process group ID of the process with process ID <I>pid</I> will have its process group ID changed to <I>newgrp </I>if the calling process has the same user ID or is the parent of the specified process. If <I>pid</I> is 0, the process group ID of the current process is sent. If <I>newgrp</I> is 0, the process group ID is set to equal the processes' (not the callers' unless <I>pid</I> is also set to 0) process ID.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   newgrp,-(sp)
move.w   pid,-(sp)
move.w   #$10E,-(sp)
trap   #1
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Psetpgrp()</B> returns <I>newgrp</I> if successful or a negative <B>GEMDOS</B> error code otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Pgetpgrp()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>Psetuid()</H3>

<P>
<B>WORD Psetuid( <I>uid</I> )</B>
<P>
<B>WORD <I>uid</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Psetuid()</B> sets the user ID of the calling process.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>272 (0x110)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This function is available under all <B>MiNT</B> versions integrated with <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>uid</I> is the user ID to assign to the calling process.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   uid,-(sp)
move.w   #$110,-(sp)
trap   #1
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Psetuid()</B> returns <I>uid</I> if successful or a negative <B>GEMDOS</B> error code otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>As with the process group ID, the user ID of a process may only be set if it is currently 0. This means that once the user ID is set, it may not be changed.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Pgetuid()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>Psigaction()</H3>

<P>
<B>LONG Psigaction( <I>sig</I>, <I>act</I>, <I>oact</I> )</B>
<P>
<B>WORD <I>sig</I>;</B>
<P>
<B>SIGACTION *<I>act</I>, *<I>oact</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Psigaction()</B> specifies a default action for the specified signal.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>311 (0x137)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available when a '<B>MiNT</B>' cookie with a version of at least 0.95 exists.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>sig</I> specifies the signal whose action you wish to change. <I>act</I> points to a <B>SIGACTION</B> structure (as defined below) which defines the handling of future signals of type <I>sig</I>. <I>oact</I> points to a <B>SIGACTION</B> structure which defines the handling of pending signals of type <I>sig</I>.
<PRE>
typedef struct
{
 LONG sa_handler;
 WORD sa_mask;
 WORD sa_flags;
} SIGACTION;Setting <I>sa_hander</I> to <B>SIG_DFL</B> (0) wll cause the default action to take place for the signal. A value of <B>SIG_IGN</B> (1) will cause the signal to be ignored. Any other value specifies the address of a signal handler.The signal handler should expect one <B>LONG</B> argument on its stack which contains the signal number being delivered. During execution of the handler, all signals specified in <I>sa_mask</I> are blocked.<I>sa_flags</I> is a signal-specific flag. When <I>sig</I> is <B>SIGCHLD</B>, setting Bit #0 (<B>SA_NOCLDSTOP</B>) will cause the <B>SIGCHLD</B> signal to be delivered only when the child process terminated (not when stopped).
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   sig,-(sp)
pea   act
pea   oact
move.w   #$137,-(sp)
trap   #1
add.l   #12,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Psigaction()</B> returns 0 if successful or a negative <B>GEMDOS</B> error code otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Calling <B>Psigaction()</B> automatically unmasks the specified signal for delivery.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Psignal</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>Psigblock()</H3>

<P>
<B>LONG Psigblock( <I>mask</I> )</B>
<P>
<B>LONG <I>mask</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Psigblock()</B> blocks selected signals from delivery.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>278 (0x116)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This function is available under all <B>MiNT</B> versions integrated with <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>mask</I> is a bit mask of signals block. For each bit <I>n</I> set, signal <I>n</I> is added to the 'blocked' list.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.l   mask,-(sp)
move.w   #$116,-(sp)
trap   #1
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Psigblock()</B> returns the original set of blocked signals in effect prior to the call.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Blocked signals are preserved with <B>Pfork()</B> and <B>Pvfork()</B> calls, however, children started with <B>Pexec()</B> start with an empty list of blocked signals.<B>SIGKILL</B> may not be blocked and will be reset by the system.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Pkill(), Psignal(), Psigpending()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Psignal()</H3>

<P>
<B>LONG Psignal( <I>sig</I>, <I>handler </I>)</B>
<P>
<B>WORD <I>sig</I>;</B>
<P>
<B>VOID (*<I>handler</I>)( LONG );</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Psignal()</B> determines the action taken when a signal is received by the process.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>274 (0x112)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This function is available under all <B>MiNT</B> versions integrated with <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>sig</I> specifies the signal whose response you wish to modify. If <I>handler</I> is cast to<B> SIG_DFL</B> (0) then the default action for the signal will occur when received. If <I>handler</I> is cast to <B>SIG_IGN</B> (1) then the signal will be ignored by the process. Otherwise, <I>handler</I> points to a user function which is designed to take action on a signal. This function is called when a signal is received with a <B>LONG</B> signal number on the stack.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   handler
move.w   sig,-(sp)
move.w   #$112,-(sp)
trap   #1
addq.l   #8,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Psignal()</B> returns the old value of the signal handler if successful or a negative <B>GEMDOS</B> error code otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Signal handler functions may make any <B>GEMDOS</B>, <B>BIOS</B>, or <B>XBIOS</B> calls desired but must not make any <B>AES</B> or <B>VDI</B> calls. Signal handlers must either return with a 680x0 <B>RTS</B> instruction to resume program execution or call <B>Psigreturn()</B> to clean the stack if it intends to do a 'C' <B>longjmp()</B>.Signal handling is preserved across <B>Pfork()</B> and <B>Pvfork()</B> calls. Child processes started with <B>Pexec()</B> ignore and follow the default action the same as their parents. Signals which have user functions assigned to them are reset to the default action for child processes.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Psigreturn(), Psigblock(), Pkill()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Psigpause()</H3>

<P>
<B>LONG Psigpause( <I>mask</I> )</B>
<P>
<B>LONG <I>mask</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Psigpause()</B> sets a new signal mask and then suspends the process until a signal is received.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>310 (0x136)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available when a '<B>MiNT</B>' cookie with a version of at least 0.95 exists.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>mask</I> specifies the signal mask to wait for.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.l   mask,-(sp)
move.w   #$136,-(sp)
trap   #1
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Psigpause()</B> returns 0 if successful or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Depending on the state of the signal handler, this call may never return.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Psigaction(), Pause()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3>Psigpending()</H3>

<P>
<B>LONG Psigpending( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Psigpending()</B> indicates which signals have been sent but not yet delivered to the calling process.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>291 (0x123)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This function is available under all <B>MiNT</B> versions integrated with <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #123,-(sp)
trap   #1
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Psigpending()</B> returns a bit mask of which signals have been sent but not yet delivered to the calling process because they are being blocked. For each bit <I>n</I> set in the returned <B>LONG</B>, signal <I>n</I> is waiting for reception.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Psigblock(), Psignal(), Psigsetmask()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Psigreturn()</H3>

<P>
<B>VOID Psigreturn( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Psigreturn()</B> prepares exit from a signal handler not planning to return via a 680x0 RTS.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>282 (0x11A)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This function is available under all <B>MiNT</B> versions integrated with <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$11A,-(sp)
trap   #1
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>Calling this function and then calling the 680x0 RTS opcode to return will produce undesired results.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD><B>Psigreturn()</B> is only needed by 'C' programs which intend to exit the signal handler by doing a 'C' <B>longjmp()</B> rather than simply using the 680x0 RTS.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Psignal()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>Psigsetmask()</H3>

<P>
<B>LONG Psigsetmask( <I>mask</I> )</B>
<P>
<B>LONG <I>mask</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Psigsetmask()</B> defines which signals are to be blocked before being delivered to the calling application.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>279 (0x117)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This function is available under all <B>MiNT</B> versions integrated with <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>mask</I> is a <B>LONG</B> bit mask which defines which signals to block and which signals to allow. For each bit <I>n</I> set, signal <I>n</I> will be blocked. For each bit <I>n</I> clear, signal <I>n</I> will be delivered.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.l   mask,-(sp)
move.w   #$117,-(sp)
trap   #1
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Psigsetmask()</B> returns the original mask of blocked/unblocked signals prior to the call or a negative <B>GEMDOS</B> error code.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Unlike <B>Psigblock()</B>, <I>mask</I> completely replaces the old mask rather than simply OR'ing it.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Pkill(), Psignal(), Psigpending()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Pterm()</H3>

<P>
<B>VOID Pterm( <I>retcode</I> )</B>
<P>
<B>WORD <I>retcode</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>Pterm()</B> terminates an application returning the specified error code.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>76 (0x4C)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>retcode</I> indicates the error status upon termination. Some recommended return values are:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >retcode</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>TERM_OK</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Program completion without errors</FONT>
</TD></TR>

<TR><TH></TH><TD><B>TERM_ERROR</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Generic Error</FONT></TD></TR>

<TR><TH></TH><TD><B>TERM_BADPARAMS</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Bad parameters</FONT></TD></TR>

<TR><TH></TH><TD><B>TERM_CRASH</B></TD><TD>
<CENTER>
<FONT SIZE=2>-1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Process crashed (returned by <B>GEMDOS</B> versions from 0.15.)</FONT>
</TD></TR>

<TR><TH></TH><TD><B>TERM_CTRLC</B></TD><TD>
<CENTER>
<FONT SIZE=2>-32</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Process terminated by ctrl-c</FONT></TD>
</TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
move.w   retcode,-(sp)
move.w   #$4C,-(sp)
trap   #1
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3><B>Pterm()</B> never returns.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=3><B>GEMDOS</B> jumps through the <I>etv_term</I> (0x102) vector when this call is made prior to process termination to allow the process one last chance to clean up. In addition, all files opened by the process are closed and all memory blocks allocated by the process are freed.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>Pexec(), Pterm0()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Pterm&Oslash;()</H3>

<P>
<B>VOID Pterm&Oslash;( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Pterm&Oslash;()</B> terminates the application returning an exit code of 0 indicating no errors.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>0 (0x00)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
clr.w   -(sp)
trap   #1
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Pterm&Oslash;()</B> never returns.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Same as <B>Pterm( </B>0 <B>)</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Pterm()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=ptermres><H3>Ptermres()</H3>

<P>
<B>VOID Ptermres( <I>keep</I>, <I>retcode</I> )</B>
<P>
<B>LONG <I>keep</I>;</B>
<P>
<B>WORD <I>retcode</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Ptermres()</B> terminates a process leaving a portion of the program's TPA intact and removing the memory left from <B>GEMDOS</B>'s memory list.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>49 (0x31)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>keep</I> is the length (in bytes) of the processes' TPA to retain in memory after exit. <I>retcode</I> is the code returned on exit.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   retcode,-(sp)
move.l   keep,-(sp)
move.w   #$31,-(sp)
trap   #1
addq.l   #8,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Ptermres()</B> never returns.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This function is normally used by TSR's to stay resident in memory. Any files opened by the process are closed. Any memory allocated is, however, retained. The value for <I>keep</I> is usually the sum of the length of the basepage (0x100), the length of the text, data, and bss segments of the application, and the length of the stack. It is important to note that the memory retained by this call may not be freed at a later point as it is removed from the <B>GEMDOS</B> memory list altogether.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Pterm0(), Pterm()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3>Pumask()</H3>

<P>
<B>WORD Pumask( <I>mode</I> )</B>
<P>
<B>WORD <I>mode</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Pumask()</B> defines an inital file and directory creation mask.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>307 (0x133)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available when a '<B>MiNT</B>' cookie with a version of at least 0.92 exists.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>mode</I> specifies the new file access permission mask to apply to all future files created with <B>Fcreate() </B>and <B>Dcreate()</B>. <I>mode</I> is a <B>WORD</B> bit mask of various access permission flags as defined in <B>Fchmod()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   mode,-(sp)
move.w   #$133,-(sp)
trap   #1
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Pumask()</B> returns the original mask in effect prior to the call.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Dcreate(), Fcreate(), Fchmod()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Pusrval()</H3>

<P>
<B>LONG Pursval( <I>val</I> )</B>
<P>
<B>LONG <I>val</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Pusrval()</B> reads/modifies a user defined value associated with a process.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>280 (0x118)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This function is available under all <B>MiNT</B> versions integrated with <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>val</I> specifies the new value of the <B>LONG</B> associated with this process. If <I>val</I> is -1 then this value is not changed but still returned.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.1   val,-(sp)
move.w   #$118,-(sp)
trap   #1
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Pusrval()</B> returns the original value of the user <B>LONG</B> prior to the call.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The user-defined longword set by this call is inherited by child processes and may be utilized as desired.
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Pvfork()</H3>

<P>
<B>WORD Pvfork( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Pvfork()</B> creates a duplicate of the current process which shares address and data space with the parent.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>275 (0x113)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This function is available under all <B>MiNT</B> versions integrated with <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$113,-(sp)
trap   #1
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Pvfork()</B> returns the new process ID to the parent and 0 to the child. If an error occurs the parent receives a negative <B>GEMDOS</B> error code.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>If the parent is in supervisor mode when this call is made the child is placed in user mode anyway.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The child process spawned by this function shares all address and data space with the parent. In other words, any variables altered by the parent will also be altered by the child and vice versa. The child process should not call <B>Mshrink()</B> as its TPA is already correctly sized.The two processes do not execute concurrently. The parent is blocked until either the child terminates or calls <B>Pexec()</B>'s mode 200.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Pexec(), Pfork()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>Pwait()</H3>

<P>
<B>LONG Pwait( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Pwait()</B> attempts to determine the exit code of a stopped or terminated child process.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>265 (0x109)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This function is available under all <B>MiNT</B> versions integrated with <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$109,-(sp)
trap   #1
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Pwait()</B> returns 0 if no child processes have terminated or a 32-bit return code for a child process which has been terminated or stopped.The process ID of the child process is placed in the upper 16 bits. A process which returned an exit status (via <B>Pterm()</B>, <B>Ptermres()</B>, or <B>Pterm0()</B> ) returns the exit code in the lower 16 bits.A process which was stopped as the result of a signal returns 0x<I>nn</I>7F where <I>nn</I> is the signal number which stopped it. A process which was terminated as the result of a signal returns 0x<I>nn</I>00 where <I>nn</I> is the signal number which killed the process.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD><B>Pwait()</B> will block the calling process until at least one child has been stopped or terminated. Once the exit code of a process has been returned with this call it will be not be returned again with this call (unless it had been stopped and is restarted and stopped again). This call is identical to <B>Pwait3(</B> 2, <B>NULL </B>); 
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Pexec(), Pterm(), Ptermres(), Pterm0()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Pwait3()</H3>

<P>
<B>LONG Pwait3( <I>flag</I>, <I>rusage </I>)</B>
<P>
<B>WORD <I>flag</I>;</B>
<P>
<B>LONG *<I>rusage</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>Pwait3()</B> determines the exit code of any children of the calling process which were stopped and/or terminated.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>284 (0x11C)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>This function is available under all <B>MiNT</B> versions integrated with <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>flag</I> is a bit mask which specifies the specifics of this call as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Mask</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>PW_NOBLOCK</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x01</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>If set, the function will not block the calling process if no child has been stopped or terminated, rather it will simply return 0. If clear, the process will be blocked until a child of the process has terminated or is stopped.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>PW_STOPPED</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x02</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>If set, return exit codes for processes which have been terminated as well as stopped. If clear, only return exit codes for processes which have actually terminated.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD COLSPAN=3><I>rusage</I> points to an array of two <B>LONG</B>s which are filled in with resource usage information of the stopped or terminated process. The first <B>LONG</B> contains the number of milliseconds used by the child in user code. The second <B>LONG</B> indicates the number of milliseconds spent by the process in the kernel. <I>rusage</I> may be set to <B>NULL</B> if this information is undesired.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
pea   rusage
move.w   flag,-(sp)
move.w #11C,-(sp)
trap   #1
addq.l   #8,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3><B>Pwait3()</B> returns 0 if no child processes have been stopped and/or terminated (depending on <I>flag</I>) or a 32-bit return code for a child process which has been terminated or stopped.The process ID of the child process is placed in the upper 16 bits. A process which returned an exit status (via <B>Pterm()</B>, <B>Ptermres()</B>, or <B>Pterm0()</B> ) returns the exit code in the lower 16 bits.A process which was stopped as the result of a signal returns 0x<I>nn</I>7F where <I>nn</I> is the signal number which stopped it. A process which was terminated as the result of a signal returns 0x<I>nn</I>00 where <I>nn</I> is the signal number which killed the process.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>Pwait(), Pexec(), Pterm(), Pterm0(), Ptermres(), Prusage()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Pwaitpid()</H3>

<P>
<B>LONG Pwaitpid( <I>pid</I>, <I>flag</I>, <I>rusage</I> )</B>
<P>
<B>WORD <I>pid</I>, <I>flag</I>;</B>
<P>
<B>LONG *<I>rusage</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Pwaitpid()</B> returns exit code information about one or more child processes.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>314 (0x13A)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available when a '<B>MiNT</B>' cookie with a version of at least 0.96 exists.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>pid</I> specifies the children whose exit codes are of interest as follows.A <I>pid</I> of <B>PWP_ALL</B> (-1) indicates that all children are of interest. A <I>pid</I> of less than -1 indicates that any child whose process group is -<I>pid</I> is of interest. A <I>pid</I> of <B>PWP_GROUP</B> (0) indicates that any child with the same process group ID of the parent is of interest. A <I>pid</I> greater than 0 indicates that the child with the given process ID is of interest.For the usage of <I>flag</I> and <I>rusage</I> see <B>Pwait3()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   rusage
move.w   flag,-(sp)
move.w   pid,-(sp)
trap   #1
lea 10(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD>See <B>Pwait3()</B>.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Pwait(), Pwait3()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3>Salert()</H3>

<P>
<B>VOID Salert( <I>str</I> )</B>
<P>
<B>char *<I>str</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Salert()</B> sends an alert string to the alert pipe 'U:\PIPE\ALERT\'.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>316 (0x13C)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available when a '<B>MiNT</B>' cookie with a version of at least 0.98 exists.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>str</I> should point to a <B>NULL</B> terminated character string containing the alert message to display. The message should not contain any carriage returns or escape characters. The string should <I>not</I> be formatted as in <B>form_alert()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   str
move.w   #$13C,-(sp)
trap   #1
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>Messages sent by <B>Salert()</B> are only delivered if a separate application is present which was designed to listen to the alert pipe and post its contents.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>form_alert()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=super><H3>Super()</H3>

<P>
<B>VOIDP Super( <I>stack</I> )</B>
<P>
<B>VOIDP <I>stack</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>Super()</B> allows you to interrogate or alter the state of the 680x0.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>32 (0x20)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>stack</I> defines the meaning of the call as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >stack</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>SUP_SET</B></TD><TD>
<CENTER>
<FONT SIZE=2>(<B>VOIDP</B>)0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>The processor is placed in supervisor mode and the old supervisor stack is returned.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>SUP_INQUIRE</B></TD><TD>
<CENTER>
<FONT SIZE=2>(<B>VOIDP</B>)1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This interrogates the current mode of the processor. If the processor is in user mode a <B>SUP_USER</B> (0) is returned, otherwise a <B>SUP_SUPER</B> (1) is returned.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
-
</CENTER>
</TD><TD>
<CENTER>
&gt;1
</CENTER>

</TD><TD><FONT SIZE=2>The processor is placed in user mode and the supervisor stack is reset to <I>stack</I>.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
pea   stack
move.w   #$20,-(sp)
trap   #1
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3><B>Super()</B> returns a different value based on the <I>stack</I> parameter. The various return values are explained above.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=3>You should never call the <B>AES</B> in supervisor mode. In addition, supervisor mode should be entered and left in the same stack context (same 'C' function) or stack corruption can result.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=3>To execute portion of a program in supervisor mode you normally call <B>Super()</B> with a parameter of 0 and save the return value. When ready to return to user mode you call <B>Super()</B> again with the saved return value as a parameter. Supervisor mode should be used sparingly under <B>MiNT</B> as no task switching can occur.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>Supexec()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3>Sversion()</H3>

<P>
<B>UWORD Sversion( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=2><B>Sversion()</B> returns the current <B>GEMDOS</B> version number.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=2>48 (0x30)</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=2>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=2>
<PRE>
move.w   #$30,-(sp)
trap   #1
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=2><B>Sversion()</B> returns a <B>UWORD</B> containing the <B>GEMDOS</B> minor version number in the upper word and the major version number in the lower word. Current values returned by Atari <B>TOS</B>'s are:
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B><FONT SIZE=1 >Return Value</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >TOS versions (normally) found in:</FONT></B>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
0x1300 (0.13)
</CENTER>
</TD><TD><B><FONT SIZE=2>TOS</FONT></B> 1.0, <B>TOS</B> 1.02
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
0x1500 (0.15)
</CENTER>
</TD><TD><B><FONT SIZE=2>TOS</FONT></B> 1.04, <B>TOS</B> 1.06
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
0x1700 (0.17)
</CENTER>
</TD><TD><B><FONT SIZE=2>TOS</FONT></B> 1.62
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
0x1900 (0.19)
</CENTER>
</TD><TD><B><FONT SIZE=2>TOS</FONT></B> 2.01, <B>TOS</B> 2.05, <B>TOS</B> 2.06, <B>TOS</B>&nbsp;3.01, <B>TOS</B> 3.05, <B>TOS</B> 3.06
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
0x3000 (0.30)
</CENTER>
</TD><TD><B><FONT SIZE=2>TOS</FONT></B> 4.00, <B>TOS</B> 4.01, <B>TOS</B> 4.02, <B>TOS</B> 4.03, <B>TOS</B> 4.04,
<P>
<B><FONT SIZE=2>MultiTOS</FONT></B> 1.00, <B>MultiTOS</B> 1.08
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=2>The <B>GEMDOS</B> number is not associated with the <B>TOS </B>or <B>AES</B> version number. You should check for <B>GEMDOS</B> or <B>MiNT</B> version numbers when trying to determine the presence or properties of a <B>GEMDOS</B> function.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=syield><H3>Syield()</H3>

<P>
<B>VOID Syield( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Syield()</B> surrenders the remainder of the callers' current process timeslice.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>255 (0xFF)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This function is available under all <B>MiNT</B> versions integrated with <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$FF,-(sp)
trap   #1
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Pause(), Fselect()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<a name=sysconf><H3>Sysconf()</H3>

<P>
<B>LONG Sysconf( <I>inq</I> )</B>
<P>
<B>WORD <I>inq</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>Sysconf()</B> returns information about the limits or capabilities of the currently running version of <B>MiNT</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>290 (0x122)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>This function is available under all <B>MiNT</B> versions integrated with <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>inq</I> determines the return value as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<B><FONT SIZE=2 >inq</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Return Value</FONT></B>
</TD></TR>

<TR><TH></TH><TD><B>SYS_MAXINQ</B></TD><TD>
<CENTER>
<FONT SIZE=2>-1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Maximum legal value for <I>inq</I>.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>SYS_MAXREGIONS</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Maximum memory regions per process.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>SYS_MAXCOMMAND</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Maximum length of <B>Pexec()</B> command string.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>SYS_MAXFILES</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Maximum number of open files per process.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>SYS_MAXGROUPS</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Maximum number of supplementary group ID's.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>SYS_MAXPROCS</B></TD><TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Maximum number of processes per user.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
move.w   inq,-(sp)
move.w   #$122,-(sp)
trap   #1
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3>See above.</TD>
</TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=3>If the requested item returns <B>UNLIMITED</B> (0x7FFFFFFF) then that item is unlimited.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>Dpathconf()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<a name=talarm><H3>Talarm()</H3>

<P>
<B>LONG Talarm( <I>time</I> )</B>
<P>
<B>LONG <I>time</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Talarm()</B> reads/sets a process alarm for the current process.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>288 (0x120)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This function is available under all <B>MiNT</B> versions integrated with <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>time</I> specifies the length of time (in milliseconds) to wait before a <B>SIGALRM</B> signal is delivered. If time is 0 then any previously set alarm is cancelled. If <I>time</I> is negative the function does not modify any alarm currently set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.l   time,-(sp)
move.w   #$120,-(sp)
trap   #1
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Talarm()</B> returns 0 i f no alarm was scheduled prior to this call or the amount of time remaining (in milliseconds) before the alarm is triggered.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>An alarm with less than 1000 remaining milliseconds will return a value of 0.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>If no <B>SIGALRM</B> signal handler has been set up when the alarm is triggered, the process will be killed.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Pause(), Psignal()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3>Tgetdate()</H3>

<P>
<B>UWORD Tgetdate( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>Tgetdate()</B> returns the current <B>GEMDOS</B> date.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>42 (0x2A)</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
move.w   #$2A,-(sp)
trap   #1
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=5><B>Tgetdate()</B> returns a bit array <B>UWORD</B> arranged as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
<B><FONT SIZE=1 >Bits 15-9</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=1 >Bits 8-5</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=1 >Bits 4-0</FONT></B>
</CENTER>

</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
Years since 1980
</CENTER>

</TD><TD>
<CENTER>
Month (1-12)
</CENTER>
</TD><TD>
<CENTER>
Date (0-31)
</CENTER>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=5><B>Tgettime(), Tsetdate(), Gettime()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Tgettime()</H3>

<P>
<B>UWORD Tgettime( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>Tgettime()</B> returns the <B>GEMDOS</B> system time.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>44 (0x2C)</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
move.w   #$2C,-(sp)
trap   #1
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=5><B>Tgettime()</B> returns a bit array arranged as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
<B><FONT SIZE=1 >Bits 15-11</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=1 >Bits 10-5</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=1 >Bits 4-0</FONT></B>
</CENTER>

</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
Hour (0-23)
</CENTER>

</TD><TD>
<CENTER>
Minute (0 to 59)
</CENTER>
</TD><TD>
<CENTER>
Secs/2 (0 to 29)
</CENTER>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=5><B>Tgetdate(), Tsettime(), Gettime()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Tsetdate()</H3>

<P>
<B>WORD Tsetdate( <I>date</I> )</B>
<P>
<B>UWORD <I>date</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Tsetdate()</B> sets the current <B>GEMDOS</B> date.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>43 (0x2B)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>date</I> is a bit array arranged as illustrated under <B>Tgetdate()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   date,-(sp)
move.w   #$2B,-(sp)
trap   #1
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Tsetdate()</B> returns 0 if the operation was successful or non-zero if a bad date is given.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD><B>GEMDOS</B> version 0.13 did not inform the <B>BIOS</B> of the date change and hence would not change the <B>IKBD</B> date or the date of a battery backed-up clock,
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Tgetdate(), Tsettime(), Settime()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Tsettime()</H3>

<P>
<B>WORD Tsettime( <I>time</I> )</B>
<P>
<B>UWORD <I>time</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Tsettime()</B> sets the current <B>GEMDOS</B> time.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>45 (0x2D)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>GEMDOS</B> versions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>time</I> is a bit array arranged as illustrated under <B>Tgettime()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   time,-(sp)
move.w   #$2D,-(sp)
trap   #1
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Tsettime()</B> returns 0 if the time was set or non-zero if the time given was invalid.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD><B>GEMDOS</B> version 0.13 did not inform the <B>BIOS</B> of the date change and hence would not change the <B>IKBD</B> date or the date of a battery backed-up clock.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Tgettime(), Tsetdate(), Settime()</B>
</TD></TR>

</TABLE>

<P>
<B></B>
<p>
<hr><center><a href="toc.htm"> Table of Contents | </a><a href="index.htm"> Index </a></center>
</BODY>

</HTML>
