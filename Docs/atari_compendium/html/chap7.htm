<HTML>

<HEAD>

<TITLE>VDI Overview</TITLE>


</HEAD>

<BODY BACKGROUND BGCOLOR=#FFFFFF>

<P>
<a name=chap7><B><FONT SIZE=2>- CHAPTER 7 -</FONT></B>
<H1>VDI</H1>

<HR>

<a name=overview><H4><FONT SIZE=4 >Overview</FONT></H4>

<HR>

<P>
The Virtual Device Interface (<B>VDI</B>) is a collection of drivers
designed to provide applications with a device-independent method
of accessing graphically based devices such as monitors, printers,
and plotters. Applications which are written to use the <B>VDI</B>
rather than directly accessing hardware will be compatible with
all currently available devices including those which have not
yet been developed.
<P>
All Atari systems with <B>TOS</B> in ROM include a <B>VDI</B>
screen driver adaptable to each display resolution the system
can support. Soft-loaded screen drivers and drivers for other
devices are loaded through a <B>VDI</B> sub-system called the
Graphics Device Operating System (<B>GDOS</B>).
<P>
The <B>GDOS</B> system is disk-loaded as a TSR utility at bootup.
It loads device drivers based upon the contents of its configuration
file(s).
<P>
Applications wishing to use the <B>GDOS</B> extensions must verify
its presence using the method described later in this chapter.
If an application's output will be limited to the screen and no
font other than the system font is needed, then the presence of
<B>GDOS</B> is not mandatory.
<HR>

<a name=workstation><a name=workstations><H4><FONT SIZE=4 >VDI Workstations</FONT></H4>

<HR>

<P>
Every system call made to the <B>VDI</B> must include a workstation
handle. This handle is a unique integer which identifies the device
and current attribute array. <a name=workstationhandles>Workstation handles are returned
by the <B>VDI</B> calls <B>v_opnwk()</B> or <B>v_opnvwk()</B>.
<P>
Workstations provide a lookup array of attributes such as line
width, text color, clipping state, etc. that are unique to it.
<a name=physicalworkstations><H5>Physical Workstations</H5>

<P>
Each device must be initialized by opening its physical workstation.
Opening a physical workstation causes all drawing and clipping
attributes to be reset and the current page (display) to be reset
to the default background color. Only one physical workstation
may be opened to a single device at any given time.
<P>
The screen device's physical workstation is automatically initialized
by the <B>AES</B> upon bootup. Its physical workstation handle
may be obtained from the <B>AES</B> call <a name=graf_handle><B>graf_handle()</B>.
<P>
Devices such as printers and plotters must have their physical
workstation opened by the application wishing to utilize them.
When opening a physical workstation the application must specify
a device ID which identifies the device to open. Device identification
codes are assigned as follows:
<TABLE BORDER=1>

<TR><TH COLSPAN=2>
<CENTER>
<B><FONT SIZE=1 >VDI Device Identification Numbers</FONT></B>
</CENTER>

</TH></TR>

<TR><TD>Screen</TD><TD>
<CENTER>
<FONT SIZE=2>1-10</FONT>
</CENTER>

</TD></TR>

<TR><TD>Plotters</TD><TD>
<CENTER>
<FONT SIZE=2>11-20</FONT>
</CENTER>

</TD></TR>

<TR><TD>Printers</TD><TD>
<CENTER>
<FONT SIZE=2>21-30</FONT>
</CENTER>

</TD></TR>

<a name=metafiles><TR><TD>Metafiles</TD><TD>
<CENTER>
<FONT SIZE=2>31-40</FONT>
</CENTER>

</TD></TR>

<TR><TD>Cameras</TD><TD>
<CENTER>
<FONT SIZE=2>41-50</FONT>
</CENTER>

</TD></TR>

<TR><TD>Tablets</TD><TD>
<CENTER>
<FONT SIZE=2>51-60</FONT>
</CENTER>

</TD></TR>

<TR><TD>Memory</TD><TD>
<CENTER>
<FONT SIZE=2>61-70</FONT>
</CENTER>

</TD></TR>

<TR><TD>Other</TD><TD>
<CENTER>
<FONT SIZE=2>71-</FONT>
</CENTER>

</TD></TR>

</TABLE>

<P>

<P>
These values correspond to the value listed in the leftmost column
of the user's 'ASSIGN.SYS' file. The following code segment demonstrates
opening a physical workstation to the printer device with ID #21.
It is important to note that the function assumes that the presence
of <B>GDOS</B> has been tested for and was verified. 
<P>
<I>work_in[0]</I> is set to the desired device ID and <I>work_in[1-9]</I>
are filled in with common defaults for workstation attributes.
<I>work_in[10]</I> is set to 2 to indicate raster coordinates
as explained later in this chapter. The function returns a non-zero
value if an error occurred.
<PRE>
WORD work_in[11],work_out[57];
<FONT SIZE=2>WORD handle;

</FONT>WORD
<FONT SIZE=2>printer_open( VOID )
</FONT>{
<FONT SIZE=2>	WORD i;

</FONT>	work_in[0] = 21;
<FONT SIZE=2>	for(i = 1;i &lt; 10; work_in[i++] = 1);
</FONT>	work_in[10] = 2;

<FONT SIZE=2>	v_opnwk(work_in,&amp;handle,work_out);

</FONT>	return (handle == 0);
<FONT SIZE=2>}
</FONT>
</PRE>

<a name=virtualworkstations><H5>Virtual Workstations</H5>

<P>
Each physical workstation may have multiple virtual workstations
opened which allow individual applications to maintain separate
workstation attributes. In fact, a single application may open
multiple virtual workstations to the same device to manage workstation
attributes more efficiently. Opening a virtual workstation does
not affect the current contents of the display.
<P>
Most <B>GEM</B> applications will open a virtual workstation to
the current screen device upon initialization. The following code
segment illustrates opening a virtual workstation to the display
device.
<P>
The device identification code for the display device must be
specified as <B>Getrez()</B> + 2 for all <B>VDI</B> features to
work correctly. All other parameters are passed the same as the
example for opening a physical workstation except that <I>handle</I>
must contain the physical workstation handle of the device for
which you wish to obtain a virtual workstation handle.
<P>
A more programmer-friendly method of opening workstations involves
the use of the <a name=vdiworkstation><B>VDI_Workstation</B> structure which is discussed
in the reference entry for <B>V_Opnvwk()</B>
<PRE>
WORD work_in[11],work_out[57];
<FONT SIZE=2>WORD handle;
</FONT>WORD wcell, hcell, wbox, hbox;

<FONT SIZE=2>WORD
</FONT>screen_open( VOID )
<FONT SIZE=2>{
</FONT>	WORD i;

<FONT SIZE=2>	handle = graf_handle( &amp;wcell, &amp;hcell, &amp;wbox, &amp;hbox);

</FONT>	work_in[0] = Getrez() + 2;
<FONT SIZE=2>	for(i = 1;i &lt; 10;work_in[i++] = 1);
</FONT>	work_in[10] = 2;

<FONT SIZE=2>	v_opnvwk(work_in, &amp;handle, work_out);

</FONT>	return (handle == 0);
<FONT SIZE=2>}
</FONT>
</PRE>

<HR>

<a name=specifics><H4><FONT SIZE=4 >Workstation Specifics</FONT></H4>

<HR>

<H5>Coordinate Systems</H5>

<P>
The <B>VDI</B> defaults to the usage of Raster Coordinates (RC)
which places the origin at the upper-left of the page or display.
As an example, the coordinate range for the 1040ST's monochrome
graphics mode is shown here:
<P>
RC coordinate ranges vary with the device. It is up to the application
to interpret and scale the size and position of its output appropriately.
<P>
With the addition of <B>GDOS</B>, the <B>VDI</B> gains the ability
to utilize Normalized Device Coordinates (NDC). When using NDC,
<B>GDOS</B> translates and scales all coordinates to the device
as appropriate. All devices using NDC will have their origin at
the lower-left hand corner of the display or page as follows:
<P>
Using NDC provides an excellent manner of reducing the overhead
of having to internally scale every coordinate, however, applications
which depend on the proper aspect ratio for their output should
consider managing coordinates internally.
<a name=renderinggraphics><H5>Rendering Graphics</H5>

<P>
Each <B>VDI</B> output function uses attributes set by other related
<B>VDI</B> functions to determine characteristics such as line
width, text face, and color. The following table lists <B>VDI</B>
attribute calls and the functions they affect.
<P>
To output a <B>VDI</B> object, set each attribute as desired and
then make the appropriate call. For example, to output a line
of text in the System font at 9 point colored red, make the following
sequence of calls.
<PRE>
vst_font( handle, 1 );				/* Select the System Font */
<FONT SIZE=2>vst_point( handle, 9 );
</FONT>vst_color( handle, 2 );
<FONT SIZE=2>v_ftext( handle, 10, 10, "The Atari Compendium" );</FONT>
</PRE>

<H5>Generalized Device Primitives</H5>

<P>
<a name=gdps>GDP's (Generalized Device Primitives) are basic drawing components
available through the <B>VDI</B>. All current device drivers support
all GDP's though specialized drivers may not be able to. <I>intout[14-24]</I>
may be used to determine the presence of GDP's. Currently there
are 10 supported GDP's as follows:
<TABLE BORDER=1>

<TR><TH>
<CENTER>
<B><FONT SIZE=1 >#</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >GDP</FONT></B></TH></TR>

<TR><TD>
<CENTER>
1
</CENTER>
</TD><TD><FONT SIZE=2><a name=vbar>Bar (Rectangle)</FONT>
</TD></TR>

<TR><TD>
<CENTER>
2
</CENTER>
</TD><a name=varc><TD><FONT SIZE=2>Arc</FONT>
</TD></TR>

<TR><TD>
<CENTER>
3
</CENTER>
</TD><TD><FONT SIZE=2>Pie Slice</FONT>
</TD></TR>

<TR><TD>
<CENTER>
4
</CENTER>
</TD><TD><FONT SIZE=2>Circle</FONT>
</TD></TR>

<TR><TD>
<CENTER>
5
</CENTER>
</TD><TD><FONT SIZE=2>Ellipse</FONT>
</TD></TR>

<TR><TD>
<CENTER>
6
</CENTER>
</TD><TD><FONT SIZE=2>Elliptical Arc</FONT>
</TD></TR>

<TR><TD>
<CENTER>
7
</CENTER>
</TD><TD><FONT SIZE=2>Elliptical Pie</FONT>
</TD></TR>

<TR><TD>
<CENTER>
8
</CENTER>
</TD><TD><FONT SIZE=2>Rounded Rectangle</FONT>
</TD></TR>

<TR><TD>
<CENTER>
9
</CENTER>
</TD><TD><FONT SIZE=2>Filled Rounded Rectangle</FONT>
</TD></TR>

<TR><TD>
<CENTER>
10
</CENTER>
</TD><TD><FONT SIZE=2>Justified Graphics Text</FONT>
</TD></TR>

</TABLE>

<P>
 
<H5><FONT SIZE=2><a name=rectangles>VDI Rectangles</FONT></H5>

<P>
Several <B>VDI</B> functions require that a rectangle in <B>VDI</B>
format be passed to them. <B>VDI</B> rectangles are different
from <B>AES</B> rectangles in the manner in which they are specified.

<P>
To correctly define a <B>VDI</B> rectangle you must specify two
coordinate pairs one representing the upper-left point of the
rectangle and the other specifying the lower-right as follows:
<P>
The following two functions provide simple conversion between
<B>AES</B> <a name=grect><B>GRECT</B>s and <B>VDI</B> rectangles in an array.
<PRE>
VOID
<FONT SIZE=2>Grect2xy( GRECT *g, short *pxy)
</FONT>{
<FONT SIZE=2>	pxy[0] = g.g_x;
</FONT>	pxy[1] = g.g_y;
<FONT SIZE=2>	pxy[2] = g.g_x + g.g_w - 1;
</FONT>	pxy[3] = g.g_y + g.g_h - 1;
<FONT SIZE=2>}

</FONT>VOID
<FONT SIZE=2>Xy2Grect( short *pxy, GRECT *g )
</FONT>{
<FONT SIZE=2>	g.g_x = pxy[0];
</FONT>	g.g_y = pxy[1];
<FONT SIZE=2>	g.g_w = pxy[2] - pxy[0] + 1;
</FONT>	g.g_h = pxy[3] - pxy[1] + 1;
<FONT SIZE=2>}
</FONT>
</PRE>

<H5>Device Types vs. Required Functions</H5>

<P>
Not all <B>VDI</B> functions are supported by all drivers. The
presence of GDP functions may be checked using the information
returned in the <I>intout</I> array after a <B>v_opnwk()</B> call.
Other calls may be checked for by entering a test call and comparing
returned information with what would be expected.
<P>
In addition, each type of driver has a certain number of required
functions which must be supported by the device. Each entry in
the <I><B>VDI</B> <a name=functionreference>Function Reference</I> specifies the support
required for a function.
<a name=writemodes><H5>  Write Modes</H5>

<P>
All <B>VDI</B> graphics primitives are subject to one of four
writing modes set by <B>vswr_mode()</B>, with the exception of
<B>vro_cpyfm() </B>which is passed one of sixteen writing modes.
<P>
The following logic tables illustrate the effects of each of the
four primary modes. Graphic examples can be found under the reference
entry for <B>vswr_mode()</B>.
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Mode</FONT></B></TH><TH><B><FONT SIZE=2 >Logic</FONT></B>
</TH></TR>

<TR><TD>Replace</TD><TD><FONT SIZE=2>Destination = Source</FONT>
</TD></TR>

<TR><TD>Transparent</TD><TD><FONT SIZE=2>Destination = Source <B>OR</B> Destination</FONT>
</TD></TR>

<TR><TD>XOR</TD><TD><FONT SIZE=2>Destination = Source <B>XOR</B> Destination</FONT>
</TD></TR>

<TR><TD>Reverse Transparent</TD><TD><FONT SIZE=2>Destination = (<B>NOT</B> Source) <B>AND</B> Destination</FONT>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=color><H4><FONT SIZE=4 ><a name=usingcolor>Using Color</FONT></H4>

<HR>

<P>
The color capabilities of <B>VDI</B> devices can be placed into
three categories as follows. Determining which category a device
falls into is accomplished by examining the return values from
<B>v_opnvwk()</B>, <B>v_opnwk()</B>, and <a name=vqextnd2><B>vq_extnd()</B>.
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=2 >Categories</FONT></B></TH>
<TH>
<CENTER>
<B><FONT SIZE=2 >v_opn/v/wk()</FONT><I><FONT SIZE=2 >work_out[13]</FONT></I></B>
</CENTER>

<P>

<CENTER>
<I><B><FONT SIZE=2 >{ colors }</FONT></B></I>
</CENTER>

</TH><TH>
<CENTER>
<B><FONT SIZE=2 >vq_extnd()</FONT></B>
</CENTER>

<P>

<CENTER>
<I><B><FONT SIZE=2 >work_out[5]</FONT></B></I>
</CENTER>

<P>

<CENTER>
<I><B><FONT SIZE=2 >{ lut }</FONT></B></I>
</CENTER>

</TH></TR>

<TR><TD>Monochrome Device</TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>
</TD></TR>

<TR><TD>Palette-Based Device</TD><TD>
<CENTER>
<FONT SIZE=2>&gt;= 2</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>
</TD></TR>

<TR><TD>True Color Device</TD><TD>
<CENTER>
<FONT SIZE=2>&gt; 2</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>
</TD></TR>

</TABLE>

<P>

<a name=monochromedevices><H5>Monochrome Devices</H5>

<P>
Monochrome devices are only capable of displaying one color. Often,
monochrome devices are instead represented by palette-based devices
with two fixed colors.
<H5>Palette-Based Devices</H5>

<P>
Palette-based devices have a fixed number of colors that may be
rendered on screen simultaneously. Each pixel value is used to
index into the palette to decide what color to display. For instance,
if you change <B>VDI</B> color #2 to green, draw a box with that
color index, and then change <B>VDI</B> color #2 to red, the box
will appear first in green and then turn red.
<P>
The first 16 <B>VDI</B> color registers are used by the operating
system and should be avoided. If your application must change
them, they should be restored when no longer needed.
<a name=truecolordevices><H5>True Color Devices</H5>

<P>
True-color devices allow each pixel to have a unique color value.
Rather than palette entries, <I>colors</I> (<I>work_out[13]</I>)
corresponds to the number of available virtual pens. Drawing is
accomplished by using these pens, however, unlike using a palette,
changing the color of a pen does not change any pixel's color
drawn with that pen on the screen.
<P>
Whatever color is stored in virtual pen #0 is considered the background
color for the purpose of computing <a name=writemodes2>write modes.
<P>
It is possible for external devices, printers, plotters, etc.
to behave as if they were a true-color device.
<H5>Color Mapping</H5>

<P>
Color values are defined in the <B>VDI</B> by specifying a red,
green, and blue value from 0-1000. The <B>VDI</B> will scale the
value to the closest color possible. <a name=vqcolor><B>vq_color()</B> can be
used to determine the actual color that was set.
<HR>

<a name=raster><H4><FONT SIZE=4 ><a name=rasterforms>VDI Raster Forms</FONT></H4>

<HR>

<P>
The <B>VDI</B> handles raster forms using three commands, <B>vro_cpyfm()</B>,
<B>vrt_cpyfm()</B>, and <B>vr_trnfm()</B>. <B>vro_cpyfm()</B>
and <B>vrt_cpyfm()</B>  are responsible for 'blitting' raster
images between memory and a workstation. These functions may also
be used to copy images from one location on a workstation to another.
'Blitting' is the process of copying memory from one location
to another. Atari computers use the <a name=blitterchip>BLiTTER chip (when one is
installed) or a software bit blit algorithm to quickly move memory.
While these calls are designed to transfer screen memory, if carefully
used, they may also be used to transfer other types of memory
as well.
<P>
<B>vr_trnfm()</B> is responsible for the transformation of images
between <a name=devicespecificformat>device-specific and <B>VDI</B> <a name=standardformats>standard format, the two
raster image formats recognized by the <B>VDI</B>. Device-specific
format is limited to images in the format of the source device
whereas the second is a generic format recommended for transporting
images to non-standard displays.
<H5>VDI Device-Specific Format</H5>

<P>
Device-specific format simply mimics the layout of pixels and
planes on the source device. When using <B>vro_cpyfm()</B> and
<B>vrt_cpyfm()</B> the source form will be transferred to the
destination form in device-specific format.
<P>
If you intend to save images to disk you should first utilize
<B>vr_trnfm()</B> to transform the image into a <B>VDI</B> standard
format so that the image can be successfully ported to any display.
<H5>VDI Standard Format</H5>

<P>
<B>VDI</B> standard format is designed to provide a portable method
of specifying raster images which may be displayed on any device.
Images stored in <B>VDI </B>standard format must be transformed
with <B>vr_trnfm()</B> before copying them to a workstation.
<P>
Images in <B>VDI</B> standard format appear in memory in a plane-by-plane
fashion. All of the bits for plane #0 appear first followed by
the bits for plane #1, and so on for as many planes as exist in
the image.
<P>
Images may be easily transferred to devices with a higher number
of planes by simply inserting empty bytes to account for planes
not present in the source image. This method will only work, however,
with <a name=palettebaseddevices>palette based devices.
<HR>

<a name=vector><H4><FONT SIZE=4 ><a name=vectorhandling>Vector Handling</FONT></H4>

<HR>

<P>
The <B>VDI</B> screen driver is also responsible for managing
some hardware vectors responsible for <a name=kbdtables>keyboard and mouse input.
The <a name=functionavailability>functions available for altering these vectors are <a name=vexmotv><B>vex_motv()</B>,
<a name=vextimv><B>vex_timv()</B>, <a name=vexcurv><B>vex_curv()</B>, and <a name=vexbutv><B>vex_butv()</B>. For
further explanation of these calls please see the <I><B>VDI</B></I>
<I>Function Reference</I>.
<P>
Use of these functions is not recommended with <B>MultiTOS</B>
as these vectors are global and affect all applications. In addition,
results are undefined if two or more non-resident applications
utilized these calls at once.
<P>
Existing applications which use these calls must have their program
flags set to either supervisor or global memory protection. See
the <I><B>GEMDOS</B> Overview</I> for a discussion of the program
flags.
<HR>

<a name=gdos><H4><FONT SIZE=4 >GDOS</FONT></H4>

<HR>

<P>
The Graphics Device Operating System (<B>GDOS</B>) is a disk-based
component of the operating system which allows disk-loadable device
drivers and additional fonts to be accessible through standard
<B>VDI</B> calls.
<P>
<a name=version>Several versions of Atari <B>GDOS</B> have been released in addition
to several third-party <B>GDOS</B> 'clones'.  All of these forms
have stayed backward-compatible with <B>GDOS</B> 1.0, however
it is recommended that programs be written to support newer <B>GDOS</B>
calls when it can be determined that a more recent release of
<B>GDOS</B> is present.
<P>
Each <B>VDI</B> call documented in the <I><B>VDI</B> Function
Reference </I>specifies if <B>GDOS</B> is required, and if so,
what type.
<H5>Determining the Version of GDOS Present</H5>

<P>
A non-standard <B>VDI</B> call is available to check for the presence
of <B>GDOS</B>. The following machine-code subroutine will return
a longword result in d0 which can be used to determine the variety
of <B>GDOS</B> present. Beware of older bindings which looked
only for the original <B>GDOS</B> and returned a 1 or 0 as a result.
<PRE>
			.text
<FONT SIZE=2><a name=vqgdos>_vq_gdos:
</FONT>			move.l	#-2,d0
<FONT SIZE=2>			trap		#2
</FONT>			rts

<FONT SIZE=2>			.end
</FONT>
</PRE>

<P>
The longword return value in d0 can be interpreted as follows:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Name</FONT></B></TH><TH>
<CENTER>
<B><FONT SIZE=2 >Value</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Meaning</FONT></B></TH>
</TR>

<TR><TH><B>GDOS_NONE</B></TH><TD>
<CENTER>
<FONT SIZE=2>-2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>No <B>GDOS</B> is installed.</FONT></TD>
</TR>

<TR><TD>
<CENTER>
-
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>Any other value.</FONT>
</CENTER>

</TD><TD><FONT SIZE=2><a name=original>Original <B>GDOS</B> 1.x is installed.</FONT>
</TD></TR>

<TR><TH><B>GDOS_FNT</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x5F464E54</FONT>'<B>_FNT</B>'
</CENTER>

</TD><TD><B><FONT SIZE=2>FONTGDOS</FONT></B> is installed.</TD>
</TR>

<TR><TH><B>GDOS_FSM</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x5F46534D</FONT>'<B>_FSM</B>'
</CENTER>

</TD><TD><B><FONT SIZE=2>FSM</FONT></B> <B>GDOS</B> or <B>SpeedoGDOS</B> is installed. For information on determining the specific variety of outline <B>GDOS</B> available, see the description of the 'FSMC' cookie in <I>Chapter 3:</I> <B>BIOS</B>
</TD></TR>

</TABLE>

<P>

<a name=speedo><H5>FSM GDOS vs. SpeedoGDOS</H5>

<P>
Since <B>FSMGDOS</B> <a name=qmsimagen>(a QMS/Imagen outline font-based <B>GDOS</B>)
was never officially released from Atari (though shipped in limited
quantity with third-party products), some changes have been made
to calls in <B>SpeedoGDOS</B> that were never exploited by developers.
For that reason, these calls will only be documented in the Speedo-compatible
way in the <I><B>VDI</B> Function Reference</I>. This does mean,
however, that use of these calls will cause your application to
fail under the original <B>FSMGDOS</B>.
<P>
The calls which were affected are <a name=vgetoutline><B>v_getoutline()</B>, <a name=vgetbitmap><B>v_getbitmap_info()</B>,
<a name=vkilloutline><B>v_killoutline()</B>, and <a name=vqtgettable><B>vqt_get_table()</B>. In addition,
use of the new <B>SpeedoGDOS</B> calls <a name=vstcharmap><B>vst_charmap()</B>, <a name=vqttrackkern><B>vqt_trackkern()</B>,
<a name=vqtpairkern><B>vqt_pairkern()</B>, <a name=vqtfontheader><B>vqt_fontheader()</B>, <a name=vstkern><B>vst_kern()</B>,
or any of the older calls when used with the <B>fix31</B> data
type will fail with the older <B>FSM</B>.
<P>
To determine the type of outline-font <B>GDOS</B> installed, look
for the '<B>FSMC</B>' cookie. The cookie value is a pointer to
a longword which contains the character string '<B>_FSM</B>' for
Imagen-based <B>FSMGDOS</B> or '<B>_SPD</B>' for Speedo-based
<B>FSMGDOS</B>.
<HR>

<a name=1><H4><FONT SIZE=4 >GDOS 1.x</FONT></H4>

<HR>

<P>
<B>GDOS</B> 1.0 and the other 1.x versions which followed it was
the original <B>GDOS</B> developed by Digital Research for Atari.
It handled only bitmap fonts and was slow compared to the newer
<B>FONTGDOS</B> which now replaces it.
<P>
When a <a name=vopnwk><B>v_opnwk()</B> call is made with <B>GDOS</B> installed,
a check is done to see if a driver was assigned to the device
ID specified in the 'ASSIGN.SYS' file, and if so, loaded.
<P>
All <B>VDI</B> calls which specify the returned handle will subsequently
be redirected to the driver. 
<P>
Not all <B>VDI</B> functions are available with every driver.
Check the 'Availability' heading for each specific function in
the <I><B>VDI</B> Function Reference</I> for specific availability.
<a name=fonts><H5>Bitmap Fonts</H5>

<P>
Bitmap fonts have the ability to be quickly rendered and highly
accurate. They do generally require more disk space and a font
file must be available for each point size and aspect ratio required.
<a name=font_naming>Bitmap fonts follow a special naming convention as follows:
<P>
The vendor code is a unique two-letter identifier which specifies
the creator of the font. The font code is a two-letter code which
abbreviates the font's name. The point size field specifies the
point size of the font. The device type is a two-letter abbreviation
which should match the aspect ratio of the device as follows:
<TABLE BORDER=1>

<TR><TH>
<CENTER>
<B><FONT SIZE=1 >Device Type</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Destination Ratio</FONT></B>
</TH></TR>

<TR><TD>
<CENTER>
None or HI
</CENTER>
</TD><TD><FONT SIZE=2>91x91 (Screen Devices) </FONT>
</TD></TR>

<TR><TD>
<CENTER>
CG
</CENTER>
</TD><TD><FONT SIZE=2>91x45 (Screen Devices)</FONT>
</TD></TR>

<TR><TD>
<CENTER>
LS
</CENTER>
</TD><TD><FONT SIZE=2>300x300 (Laser Printers, Inkjets)</FONT>
</TD></TR>

<TR><TD>
<CENTER>
EP
</CENTER>
</TD><TD><FONT SIZE=2>120x144 (Lo-Res Dot-Matrix Printers)</FONT>
</TD></TR>

<TR><TD>
<CENTER>
LB
</CENTER>
</TD><TD><FONT SIZE=2>160x72 (Lo-Res Dot-Matrix Printers)</FONT>
</TD></TR>

<TR><TD>
<CENTER>
SP
</CENTER>
</TD><TD><FONT SIZE=2>180x180 (Med-Res Dot-Matrix Printers)</FONT>
</TD></TR>

<TR><TD>
<CENTER>
QD
</CENTER>
</TD><TD><FONT SIZE=2>240x216 (Med-Res Dot-Matrix Printers)</FONT>
</TD></TR>

<TR><TD>
<CENTER>
NP
</CENTER>
</TD><TD><FONT SIZE=2>360x360 (High-Res Dot-Matrix Printers)</FONT>
</TD></TR>

</TABLE>

<P>

<P>
For a driver to recognize a bitmap font it must be listed in the
user's 'ASSIGN.SYS' file and be of the correct aspect ratio. No
extra fonts are made available to applications until a <B>vst_load_fonts()</B>
call is made.
<HR>

<a name=fontgdos><H4><FONT SIZE=4 >FONTGDOS</FONT></H4>

<HR>

<P>
<B>FONTGDOS</B> is the successor to <B>GDOS</B> 1.x. As with the
original <B>GDOS</B>, <B>FONTGDOS</B> supports only bitmap fonts.
Its differences are improved driver support, support for bezier
curves, improved error handling, and a much quicker response time.
<a name=bezier><H5>Bezier Curves</H5>

<P>
<B>FONTGDOS</B> conforms to the <a name=gem3><B>PC-GEM/3</B> file standard
with the inclusion of bezier curve rendering capability with the
<B><a name=vbez>v_bez()</B> and <a name=vbezfill><B>v_bez_fill() </B>calls. <a name=vbez2><a name=vbezon><B>v_bez_on()</B>
must be used to allow <B>FONTGDOS</B> to allocate the memory necessary
for bezier rendering. Likewise <B>v_bez_off()</B> should be used
before an application exits to free any memory used for bezier
calls.
<a name=error_support><H5>Error Support</H5>

<P>
When <B>GDOS</B> 1.x encountered an error condition, it simply
wrote an error message at the top of the display overwriting a
portion of the menu bar and display screen. <B>FONTGDOS</B> allows
an application to disengage this behavior and instead return error
codes in a global variable. It is then the applications responsibility
to check this variable after calls which may cause an error condition.
See the <I><B>VDI</B> Function Reference</I> call <B>vst_error()</B>
for more information. 
<HR>

<a name=fsm><a name=fsmdos><a name=fsmgdos><H4><FONT SIZE=4 >FSMGDOS</FONT></H4>

<HR>

<P>
<B>FSMGDOS</B> was developed by Atari in conjunction with QMS/Imagen
Corp. to provide Imagen outline fonts which could be displayed
at any point size, aspect ratio, or device. It provided all of
the improved features of <B>FONTGDOS</B> with outline fonts and
caching capability. This version of <B>GDOS</B> was, however,
never officially released. Third-party manufacturers did ship
many copies of this <B>GDOS</B> to the public. In addition, many
developers did update their products to utilize the special features
of <B>FSMGDOS</B>.
<P>
Most <B>VDI</B> function calls added with this version of <B>GDOS</B>
have remained compatible with <a name=speedo2><B>SpeedoGDOS</B>, however, some
calls which were never used by developers were changed. This means
that applications written to support <B>SpeedoGDOS</B> may not
be backwardly compatible. For specific compatibility information,
consult the <B>V<I>DI</I></B><I> Function Reference</I>.
<HR>

<a name=speedo><H4><FONT SIZE=4 ><a name=speedogdos>SpeedoGDOS</FONT></H4>

<HR>

<P>
<B>SpeedoGDOS</B> is a new variety of <B>FSM</B> which employs
outline font technology from Bitstream using Speedo-format outline
fonts. In addition, several new calls were added to gain access
to internal font information and provide true WYSIWYG (What-You-See-Is-What-You-Get)
output.
<a name=data_type><H5>The fix31 Data Type</H5>

<P>
<B>SpeedoGDOS</B> optionally allows the use of the <B>fix31</B>
data type in some calls for parameters and return values. Old
bindings designed for the Imagen-based <B>FSM</B> will still function
properly. Newer bindings may be written to take advantage of this
data type.
<P>
The <B>fix31</B> data type allows for the internal representation
and manipulation of floating-point values without the use of a
floating-point library. It is a 32-bit value with a 1-bit sign
and a 31-bit magnitude. Each value specifies a number in 1/65536
pixels. Examples of this data type follow:
<TABLE BORDER=1>

<TR><TH>
<CENTER>
<B><FONT SIZE=1 >fix31</FONT></B>
</CENTER>

</TH><TH>
<CENTER>
<B><FONT SIZE=2 >Floating Point</FONT></B>
</CENTER>

</TH></TR>

<TR><TD>
<CENTER>
0x00010000
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>1.0</FONT>
</CENTER>

</TD></TR>

<TR><TD>
<CENTER>
0xFFFF0000
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>-1.0</FONT>
</CENTER>

</TD></TR>

<TR><TD>
<CENTER>
0x00018000
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>1.5</FONT>
</CENTER>

</TD></TR>

</TABLE>

<P>
 
<P>
Character advances can be simply be added or subtracted to each
other using integer arithmetic. To convert a <B>fix31</B> unit
to an integer (rounding to 0) use the following code:
<PRE>

<CENTER>
x_integer = (WORD)(x_fix31 &gt;&gt; 16);

</CENTER>

</PRE>

<P>
To convert a <B>fix31</B> to an integer and round it to the closest
integer use the following code:
<PRE>

<CENTER>
x_integer = (WORD)((x_fix31 + 32768) &gt;&gt; 16);

</CENTER>

</PRE>

<P>
Use of <B>fix31</B> values provides higher character placement
accuracy and access to non-integer point sizes. For specific implementation
notes, see the <I><B>VDI</B> Function Reference </I>entries for
<B>vqt_advance32()</B>, <B>v_getbitmap_info()</B>, <B>vst_arbpt32()</B>,
and <B>vst_setsize32()</B>.
<a name=kerning><H5>Kerning</H5>

<P>
<B>SpeedoGDOS</B> outline fonts have the ability to be kerned
using two methods. Track kerning is global for an entire font
and has three settings, normal, tight, and extra tight. Pair kerning
works for individual pair groups of characters. In addition, new
pairs may be defined as necessary to produce the desired output.
<P>
Kerning is taken into account with <B>v_ftext()</B> and <B>vqt_advance()</B>
only when enabled. Use the calls <B>vst_kern()</B>, <B>vqt_pairkern()</B>,
and <B>vqt_trackkern()</B> to access kerning features.
<a name=caching><H5>Caching</H5>

<P>
All <B>SpeedoGDOS</B> extent and outline rendering calls are cached
for improved performance. Cache files may be loaded or saved to
disk as desired to preserve the current state of the cache. In
addition, an application might want to flush the cache before
doing an output job to a device such as a printer to improve performance
with new fonts. 
<P>
The call <B>vqt_cachesize()</B> can be used to estimate the ability
of the cache to store data for an unusually large character and
prevent memory overflow errors.
<a name=spec_effects><H5>Special Effects</H5>

<P>
The call <B>vst_scratch()</B> determines the method used when
calculating the size of the special effects buffer. In general
an application should not allow the user to use algorithmically
generated effects on Speedo fonts. In most cases, special effects
are available by simply choosing another font.
<P>
The problem is that Speedo fonts may be scaled to any size and
<B>SpeedoGDOS</B> has no way of predicting the upper-limit on
the size of a character to allocate special effects memory. Currently,
<B>SpeedoGDOS</B> allocates a buffer large enough to hold the
largest character possible from the point sizes in the 'ASSIGN.SYS'
file and those listed in the <a name=extendsys>'EXTEND.SYS' file. If your application
limits special effects to these sizes then no problems will occur.
<P>
If you intend to restrict users to using special effects only
with bitmap fonts you may call <B>vst_scratch()</B> with a <I>mode</I>
parameter of 1, memory allocation will be relaxed to only take
bitmap fonts into account. You may also specify a <I>mode</I>
parameter of 2 if you plan to allow no special effects at all.
The <B>vst_scratch()</B> call must be made prior to calling <B>vst_load_fonts()</B>.
<a name=sci><H5>Speedo Character Indexes</H5>

<P>
Speedo fonts contain more characters than the Atari ASCII set
can define. Fonts may be remapped with a CPX using the <B>vqt_get_table()</B>
call (this method is not recommended on an application basis as
this call affects all applications in the system).
<P>
Another method involves the use of a new call, <B>vst_charmap()</B>.
Calling this function with a <I>mode</I> parameter of 0 causes
all functions which take character indexes (like <B>v_ftext()</B>,
<B>vqt_width()</B>, etc.) to interpret characters as <B>WORD</B>s
rather than <B>BYTE</B>s and utilize Speedo International Character
Encoding rather than ASCII.
<P>
The <I><B>Function Reference</B></I> provides two alternate bindings
for <B>v_ftext()</B> and <B>v_ftext_offset()</B> called <B>v_ftext16()
</B>and <B>v_ftext_offset16() </B>which correctly output 16-bit
Speedo character text rather than 8-bit ASCII text.
<P>
A complete listing of the Bitstream International Character Set
is listed in <I>Appendix G: <B>Speedo Fonts</B></I>.
<H5>Speedo Font IDs</H5>

<P>
The function <B>vqt_name()</B> is used with all versions of <B>GDOS</B>
to return a unique integer identifier for each font. Because some
bitmap font ID's conflicted with Bitstream outline font ID's,
<B>SpeedoGDOS</B> versions 4.20 and higher add 5000 to each of
the outline font ID's to differentiate them from bitmap fonts.
<HR>

<a name=device><a name=device_drivers><H4><FONT SIZE=4 >Device Drivers</FONT></H4>

<HR>

<a name=plotter><a name=printers><H5>Printer and Plotter Drivers</H5>

<P>
Printer drivers are the most common form of <B>GDOS</B> driver
available, though some plotter drivers do exist. The <I><B>VDI</B>
Function Reference</I> can be used to determine if a particular
function call is required to be available on a particular device.
This does not, however, prohibit the addition of supplementary
functions.
<P>
Some special printer driver features are available with drivers
designed to support them as follows:
<P>
<B>Dot-Matrix Printers</B>
<P>
Dot-matrix printers with wide carriages can have their print region
expanded by passing a custom X and Y resolution for the driver
in <I>ptsin[0]</I> and <I>ptsin[1] </I>respectively prior to the
<B>v_opnwk()</B> call. In addition, <I>contrl[1]</I> should be
set to 1 to indicate the presence of the parameters.
<P>
<a name=slm804><B>SLM804</B>
<P>
After a <B>v_opnwk()</B> call to an SLM804 driver <I>contrl[0]
</I>will contain the MSB and <I>contrl[1]</I> will contain the
LSB of the allocated printer buffer address.
<P>
After a <B>v_updwk() </B>call, <I>intout[0]</I> will contain a
printer status code as follows:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Name</FONT></B></TH><TH>
<CENTER>
<B><FONT SIZE=2 >Error Code</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Meaning</FONT></B></TH>
</TR>

<TR><TH><B>SLM_OK</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x00</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>No Error</FONT></TD></TR>

<TR><TH><B>SLM_ERROR</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x02</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>General Printer Error</FONT></TD></TR>

<TR><TH><B>SLM_NOTONER</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x03</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Toner Empty</FONT></TD></TR>

<TR><TH><B>SLM_NOPAPER</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x05</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Paper Empty</FONT></TD></TR>

</TABLE>

<P>

<P>
<B>All Printer Drivers</B>
<P>
<a name=udpb>A user-defined printer buffer may be passed to the <B>v_updwk()</B>
call by specifying the address of the buffer in <I>intin[0]</I>
and <I>intin[1]</I>. In addition, <I>contrl[3]</I> must be set
to 2 to indicate the new parameters and <I>contrl[1]</I> must
be set to 1 to instruct the <B>VDI</B> to not clear the buffer
first. 
<a name=camera_drivers><a name=tablet>Camera and Tablet Drivers</H5>

<P>
As of this writing, no camera or tablet drivers existed for Atari
<B>GEM</B>. Several functions are reserved to support them which
were developed under<B> PC-GEM</B>, however, many remain undocumented.
Where documentation was available, those calls are included for
completeness in the <I><B>VDI</B> Function Reference</I>.
<H5>The Metafile Driver</H5>

<P>
'META.SYS' drivers are specially designed drivers which create
'.GEM' disk files rather than produce output on a device. When
a metafile device is opened, the file <a name=gemfile>'GEMFILE.GEM' is created
in the current <B>GEMDOS</B> path. The function <a name=vmfilename><B>vm_filename()</B>
may be used to change the filename to which the metafile is written
to, however, the file 'GEMFILE.GEM' must be deleted by the application.
<P>
When a metafile is opened, several defaults relating to the coordinate
space and pixel size are set. Each pixel is assigned a default
width and height of 85 microns (1 micron = 1/25400 inch). This
equates to a default resolution of 300dpi.
<P>
The device size is specified where Normalized Device Coordinates
(NDC) = Raster Coordinates (RC). The coordinate space of the metafile
has ( 0, 0 ) in the lower-left corner and ( 32767, 32767 ) in
the upper-right. This coordinate system may be modified with <a name=vmcoords><B>vm_coords()</B>.
The size of the actual object space being written to the metafile
should also be specified with <a name=vmpagesize><B>vm_pagesize()</B> so that an
application may correctly clip the objects when reading.
<P>
After changing coordinate space, values returned by <a name=vqextnd><B>vq_extnd()</B>
related to pixel width, height and page size will <I>not</I> change.
Also, font metrics returned by functions such as <B>vqt_fontinfo()</B>
and <B>vqt_advance()</B> will remain based on the default metafile
size information. In most cases, text metric information should
be embedded based on the workstation metrics of the destination
device (such as a screen or printer) anyway.
<P>
The metafile is closed when a <a name=vclswk><B>v_clswk()</B> call is issued.
Other applications which read metafiles will play back the file
by issuing commands in the same order as recorded by the driver.
For more information on the metafile format see <I>Appendix C:
<B>Native File Formats</B></I>.
<a name=mem_driver><H5>The Memory Driver</H5>

<P>
'MEMORY.SYS' includes all of the standard <B>VDI</B> calls yet
works only in memory and is not designed to be output to a device.
Normally, the memory driver should be assigned in the user's 'ASSIGN.SYS'
file as device number 61. Upon calling <B>v_opnwk()</B> to the
memory driver, <I>contrl[1]</I> should be set to 1 and <I>ptsin[0]</I>
and <I>ptsin[1]</I> should contain the X and Y extent of the memory
area. Upon return from the call, <I>contrl[0]</I> and <I>contrl[1]</I>
will contain the high and low <B>WORD</B> respectively of the
address of the memory device raster. <B>v_updwk()</B> clears the
raster. 
<HR>

<a name=calling><H4><FONT SIZE=4><a name=functioncallingprocedure>VDI Function Calling Procedure</FONT>
</H4>

<HR>

<P>
The <B>GEM</B> <B>VDI</B> is accessed through a 68x00 TRAP #2
statement. Prior to the TRAP, register d0 should contain the magic
number 0x73 and register d1 should contain a pointer to <B>VDI</B>
parameter block. An example binding is as follows:
<PRE>
	.text
<FONT SIZE=2>_vdi:
</FONT>	move.l		#_VDIpb,d1
<FONT SIZE=2>	move.l		#$73,d0
</FONT>	trap		#2
<FONT SIZE=2>	rts
</FONT>
</PRE>

<P>
The <B>VDI</B> <a name=parameterblock>parameter block is an array of 5 pointers which
each point to a specialized array of <B>WORD</B> values which
contain input parameters and function return values. Different
versions of the <B>VDI</B> support different size arrays. The
following code contains the 'worst case' sizes for these arrays.
Many newer versions of the <B>VDI</B> support larger array sizes.
You can inquire what the maximum array size that <B>VDI</B> supports
by examining the <I>work_out</I> array after a <B>v_opnvwk()</B>
or <B>v_opnwk()</B>. Larger array sizes allow more points to be
passed at a time for drawing functions and longer strings to be
passed for text functions. The definition of the <B>VDI</B> parameter
block follows:
<PRE>
			.data

<FONT SIZE=2>_contrl:		ds.w		12
</FONT>_intin:			ds.w		128
<FONT SIZE=2>_ptsin:			ds.w		256
</FONT>_intout:		ds.w		128
<FONT SIZE=2>_ptsout	:		ds.w		256

</FONT>_VDIpb:			dc.l		_contrl, _intin, _ptsin 
<FONT SIZE=2>			dc.l		_intout, _ptsout

</FONT>			.end

</PRE>

<P>
The <I>contrl</I> array contains the opcode and number of parameters
being passed the function as follows:
<TABLE BORDER=1>

<TR><TH>
<CENTER>
<I><B><FONT SIZE=1 >contrl[x]</FONT></B></I>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Contents</FONT></B></TH>
</TR>

<TR><TD>
<CENTER>
0
</CENTER>
</TD><TD><FONT SIZE=2>Function Opcode</FONT>
</TD></TR>

<TR><TD>
<CENTER>
1
</CENTER>
</TD><TD><FONT SIZE=2>Number of Input Vertices in <I>ptsin</I></FONT>
</TD></TR>

<TR><TD>
<CENTER>
2
</CENTER>
</TD><TD><FONT SIZE=2>Number of Output Vertices in <I>ptsout</I></FONT>
</TD></TR>

<TR><TD>
<CENTER>
3
</CENTER>
</TD><TD><FONT SIZE=2>Number of Parameters in <I>intin</I></FONT>
</TD></TR>

<TR><TD>
<CENTER>
4
</CENTER>
</TD><TD><FONT SIZE=2>Number of Output Values in <I>intout</I></FONT>
</TD></TR>

<TR><TD>
<CENTER>
5
</CENTER>
</TD><TD><FONT SIZE=2>Function Sub-Opcode</FONT>
</TD></TR>

<TR><TD>
<CENTER>
6
</CENTER>
</TD><TD><FONT SIZE=2>Workstation Handle</FONT>
</TD></TR>

<TR><TD>
<CENTER>
7-11
</CENTER>
</TD><TD><FONT SIZE=2>Function Specific</FONT>
</TD></TR>

</TABLE>

<P>

<P>
<I>contrl[0]</I>, <I>contrl[1]</I>, <I>contrl[3]</I>, <I>contrl[5]</I>
(when necessary), and <I>contrl[6]</I> must be filled in by the
application. <I>contrl[2]</I> and <I>contrl[4] </I>are filled
in by the <B>VDI</B> on exit. <I>contrl[7-11]</I> are rarely used,
however some functions do rely on them for function-specific parameters.
<P>
For specific information on bindings, see the <I><B>VDI</B> Function
Reference</I>.
<p>
<hr><center><a href="toc.htm"> Table of Contents | </a><a href="index.htm"> Index </a></center>
</BODY>

</HTML>
