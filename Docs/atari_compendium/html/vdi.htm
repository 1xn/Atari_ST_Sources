<HTML>

<HEAD>

<TITLE>VDI Function Reference, Master</TITLE>

</HEAD>

<BODY BACKGROUND BGCOLOR=#ffffff>

<H2>VDI/GDOS Function Reference</H2>

<HR>

<H3>v_alpha_text()</H3>

<P>
<B>VOID v_alpha_text( <I>handle</I>, <I>str</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>char *<I>str</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>v_alpha_text()</B> outputs a line of alpha text.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>5</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD COLSPAN=5>25</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>Supported by all printer and metafile drivers.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=5><I>handle</I> is a valid workstation handle. <I>str</I> is a pointer to a null-terminated text string which will be printed. Two special <B>BYTE</B> codes may be embedded in the text. ASCII 12 will cause a printer form-feed. ASCII 18 'DC2' will initiate an escape sequence followed by a command descriptor <B>BYTE</B> (in ASCII) indicating which action to take as follows.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
<B><FONT SIZE=1 >Command</FONT></B>
</CENTER>

<P>

<CENTER>
<B><FONT SIZE=1 >BYTE</FONT></B>
</CENTER>

</TD><TD COLSPAN=2><B><FONT SIZE=2 >Meaning</FONT></B>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
'0'
</CENTER>
</TD><TD COLSPAN=2><FONT SIZE=2>Enable bold print.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
'1'
</CENTER>
</TD><TD COLSPAN=2><FONT SIZE=2>Disable bold print.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
'2'
</CENTER>
</TD><TD COLSPAN=2><FONT SIZE=2>Enable italic print.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
'3'
</CENTER>
</TD><TD COLSPAN=2><FONT SIZE=2>Disable italic print.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
'4'
</CENTER>
</TD><TD COLSPAN=2><FONT SIZE=2>Enable underlining.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
'5'
</CENTER>
</TD><TD COLSPAN=2><FONT SIZE=2>Disable underlining.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
'6'
</CENTER>
</TD><TD COLSPAN=2><FONT SIZE=2>Enable superscript.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
'7'
</CENTER>
</TD><TD COLSPAN=2><FONT SIZE=2>Disable superscript.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
'8'
</CENTER>
</TD><TD COLSPAN=2><FONT SIZE=2>Enable subscript.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
'9'
</CENTER>
</TD><TD COLSPAN=2><FONT SIZE=2>Disable subscript.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
'A'
</CENTER>
</TD><TD COLSPAN=2><FONT SIZE=2>Enable NLQ mode.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
'B'
</CENTER>
</TD><TD COLSPAN=2><FONT SIZE=2>Disable NLQ mode.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
'C'
</CENTER>
</TD><TD COLSPAN=2><FONT SIZE=2>Enable wide printing.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
'D'
</CENTER>
</TD><TD COLSPAN=2><FONT SIZE=2>Disable wide printing.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
'E'
</CENTER>
</TD><TD COLSPAN=2><FONT SIZE=2>Enable light printing.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
'F'
</CENTER>
</TD><TD COLSPAN=2><FONT SIZE=2>Disable light printing.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
'W'
</CENTER>
</TD><TD COLSPAN=2><FONT SIZE=2>Switch to 10-cpi printing.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
'X'
</CENTER>
</TD><TD COLSPAN=2><FONT SIZE=2>Switch to 12-cpi printing.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
'Y'
</CENTER>
</TD><TD COLSPAN=2><FONT SIZE=2>Toggle compressed printing.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
'Z'
</CENTER>
</TD><TD COLSPAN=2><FONT SIZE=2>Toggle proportional printing.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
WORD i = 0;

while(intin[i++] = (WORD)*str++);

contrl[0] = 5;
contrl[1] = 0;
contrl[3] = --i;
contrl[5] = 25;
contrl[6] = handle;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=5>The line of text must not exceed the maximum allowable length of the <I>intin</I> array as returned by <B>vq_extnd()</B> or the maximum length of your compilers' array.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=5>Only commands '0', '1', '2', '3', '4', and '5' are available with most printer drivers.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=5><B>v_gtext(), v_ftext()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=varc><H3>v_arc()</H3>

<P>
<B>VOID v_arc( <I>handle</I>, <I>x</I>, <I>y</I>, <I>radius</I>,
<I>startangle</I>, <I>endangle</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>x</I>, <I>y</I>, <I>radius</I>, <I>startangle</I>,
<I>endangle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_arc()</B> outputs an arc to the specified workstation.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>11</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>2</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers.  This function composes one of the 10 <B>VDI</B> GDP's (Generalized Drawing Primitives). Although all current drivers support all GDP's, their availability is not guaranteed and may vary. To check for a particular GDP refer to the table returned by <B>v_opnvwk()</B> or <B>v_opnwk()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> is a valid workstation handle. <I>x</I> and <I>y</I> specify the center of an arc with a radius of <I>radius</I> and starting and ending angles of <I>startangle</I> and <I>endangle</I> specified in tenths of degrees as follows:
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 11;
contrl[1] = 4;
contrl[3] = contrl[5] = 2;
contrl[6] = handle;

intin[0] = startangle;
intin[1] = endangle;

ptsin[0] = x;
ptsin[1] = y;
ptsin[2] = ptsin[3] = ptsin[4] = ptsin[5] = 0;
ptsin[6] = radius;
ptsin[7] = 0;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vsl_color()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vbar><H3>v_bar()</H3>

<P>
<B>VOID v_bar( <I>handle</I>, <I>pxy</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>WORD *<I>pxy</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_bar()</B> outputs a filled rectangle to the specified workstation.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>11</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>1</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers.  This function composes one of the 10 <B>VDI</B> GDP's (Generalized Drawing Primitives). Although all current drivers support all GDP's, their availability is not guaranteed and may vary. To check for a particular GDP refer to the table returned by <B>v_opnvwk()</B> or <B>v_opnwk()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> is a valid workstation handle. <I>pxy</I> points to an array of four <B>WORD</B>s specifying a <B>VDI</B> format rectangle to output.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 11;
contrl[1] = 2;
contrl[3] = 0;
contrl[5] = 1;
contrl[6] = handle;

ptsin[0] = pxy[0];
ptsin[1] = pxy[1];
ptsin[2] = pxy[2];
ptsin[3] = pxy[3];

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This function, as opposed to <B>vr_recfl()</B>, <I>does</I> take the setting of <B>vsf_perimeter()</B> into consideration.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vsf_interior(), vsf_style(), vsf_color(), vsf_perimeter(), vsf_udpat()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>v_bez()</H3>

<P>
<B>VOID v_bez( <I>handle</I>, <I>count</I>, <I>pxy</I>, <I>bezarr</I>,
<I>extent</I>, <I>totpts</I>, <I>totmoves</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>count</I>;</B>
<P>
<B>WORD *<I>pxy</I>, *<I>extent</I>;</B>
<P>
<B>char *<I>bezarr</I>;</B>
<P>
<B>WORD *<I>totpts</I>, *<I>totmoves</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>v_bez()</B> outputs a bezier curve path.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>6</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD COLSPAN=3>13</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>Available only with <B>FONTGDOS</B>, <B>FSMGDOS </B>or <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>handle</I> is a valid workstation handle. <I>count</I> specifies the number of vertices in the path. <I>pxy</I> is a pointer to a <B>WORD</B> array (<I>count</I> * 2) <B>WORD</B>s long containing the vertices where <I>pxy[0]</I> is the X coordinate of the first point, <I>pxy[1]</I> is the Y coordinate of the first point and so on. <I>bezarr</I> is a pointer to a character array <I>count</I> <B>BYTE</B>s long where each byte is a bit mask with two flags that dictate the interpretation of each vertice as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bit</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>BEZ_BEZIER</B>
<P>
(0x01)
<P>
<B>BEZ_POLYLINE</B>
<P>
(0x00)
</TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>
</TD><TD><FONT SIZE=2>If set, begin a 4-point bezier segment (two anchor points followed by two control points), otherwise,  begin a polyline segment.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>BEZ_NODRAW</B>
<P>
(0x02)</TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>If set, jump to this point without drawing.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
-
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>2-7</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Currently unused (set to 0).</FONT></TD>
</TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD COLSPAN=3>Upon exit, a 4 <B>WORD</B> array pointed to by <I>extent</I> is filled in with a <B>VDI</B> format rectangle defining a bounding box of the path drawn. The <B>WORD</B> pointed to by <I>totpts</I> is filled in with the number of points in the resulting path whereas the total number of moves is stored in the <B>WORD</B> pointed to by <I>totmoves</I>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
WORD i;

contrl[0] = 6;
contrl[1] = count;
contrl[3] = (count + 1)/2;
contrl[5] = 13;
contrl[6] = handle;

for(i = 0;i &lt; count; i++)
{
 intin[i] = (WORD)bezarr[i];
 ptsin[ i*2 ] = pxy[ i*2 ];
 ptsin[ (i*2) + 1 ] = pxy[ (i*2) + 1];
}

vdi();

*totpts = intin[0];
*totmoves = intin[1];

for(i = 0; i &lt; 4; i++)
 extent[i] = ptsout[i];
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>v_bez_fill(), v_bez_on(), v_bez_off(), v_bez_qual(), v_set_app_buff()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vbexfill2><H3>v_bez_fill()</H3>

<P>
<B>VOID v_bez_fill( <I>handle</I>, <I>count</I>, <I>pxy</I>, <I>bezarr</I>,
<I>extent</I>, <I>totpts</I>, <I>totmoves</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>count</I>;</B>
<P>
<B>WORD *<I>pxy</I>, *<I>extent</I>;</B>
<P>
<B>char *<I>bezarr</I>;</B>
<P>
<B>WORD *<I>totpts</I>, *<I>totmoves</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_bez_fill()</B> outputs a filled bezier path.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>9</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>13</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available only with <B>FONTGDOS</B>, <B>FSMGDOS </B>or <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD>Same as <B>v_bez()</B>.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
WORD i;

contrl[0] = 9;
contrl[1] = count;
contrl[3] = (count + 1)/2;
contrl[5] = 13;
contrl[6] = handle;

for(i = 0;i &lt; count * 2; i++)
 ptsin[i] = pxy[i]; 
for(i = 0;i &lt; count; i++)
 intin[i] = (WORD)bezarr[i];

vdi();

*totpts = intin[0];
*totmoves = intin[1];

for(i = 0; i &lt; 4; i++)
 extent[i] = ptsout[i];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_bez(), v_bez_on(), v_bez_off(), v_bez_qual(), v_set_app_buff()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>v_bez_off()</H3>

<P>
<B>VOID v_bez_off( <I>handle</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_bez_off()</B> disables bezier capabilities and frees associated memory.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>11</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>13</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available only with <B>FONTGDOS, FSM, </B>or <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> is a valid workstation handle.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 11;
contrl[1] = 0;
contrl[3] = 0;
contrl[5] = 13;
contrl[6] = handle;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This function should be called to free any memory reserved by the bezier functions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_bez_on()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>v_bez_on()</H3>

<P>
<B>WORD v_bez_on( <I>handle</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_bez_on()</B> enables bezier capabilities.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>11</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>13</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available only with <B>FONTGDOS</B>, <B>FSM, </B>or <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> is a valid workstation handle.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 11;
contrl[1] = 0;
contrl[3] = 0;
contrl[5] = 13;
contrl[6] = handle;

vdi();

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>v_bez_on()</B> returns a <B>WORD</B> value indicating the number of line segments each curve is composed of (smoothness). The value returned (0-7) is a power of 2 meaning that a return value of 7 indicates 128 line segments per curve.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_bez_off()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>v_bez_qual()</H3>

<P>
<B>VOID v_bez_qual( <I>handle</I>, <I>percent</I>, <I>actual</I>
)</B>
<P>
<B>WORD <I>handle</I>, <I>percent</I>;</B>
<P>
<B>WORD *<I>actual</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_bez_qual()</B> sets the speed/quality ratio of the bezier curve rendering engine.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>99</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available only with <B>FONTGDOS</B>, <B>FSM, </B>or <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>percent</I> is a value (0-100) specifying the tradeoff between bezier quality and speed. A value of 0 renders a bezier fastest with the lowest quality while a value of 100 renders a bezier slowest with the highest possible quality. On return, the <B>WORD</B> pointed to by <I>actual</I> will contain the actual value used.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = 0;
contrl[3] = 3;
contrl[5] = 99;
contrl[6] = handle;

intin[0] = 32;
intin[1] = 1;
intin[2] = percent;

vdi();

*actual = intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD><I>actual</I> may not be an exact percentage as the rendering engine may not actually support every value possible between 1-99.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_bez(), v_bez_fill(), v_bez_on()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vbitimage><H3>v_bit_image()</H3>

<P>
<B>VOID v_bit_image( <I>handle</I>, <I>fname</I>, <I>ratio</I>,
<I>xscale</I>, <I>yscale</I>, <I>halign</I>, <I>valign</I>, <I>pxy</I>
)</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>char *<I>fname</I>;</B>
<P>
<B>WORD <I>aspect</I>, <I>xscale</I>, <I>yscale</I>, <I>halign</I>,
<I>valign</I>;</B>
<P>
<B>WORD *<I>pxy</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>v_bit_image()</B> outputs a disk-based <B>GEM</B> '.IMG' file.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>5</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD COLSPAN=5>23</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>Supported by all printer, metafile, and memory drivers.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=5><I>handle</I> is a valid workstation handle. <I>fname</I> specifies the <B>GEMDOS</B> file specification for the <B>GEM</B> bit-image file to print. <I>ratio</I> should be 0 to ignore the aspect ratio of the image and 1 to adhere to it. <I>xscale</I> and <I>yscale</I> specify the method of scaling to apply to the image. Fractional scaling is specified by a value of 0 whereas a value of 1 represents integer scaling. If fractional scaling is used, the image will be displayed at the coordinates given by the <B>VDI</B> format rectangle pointed to by <I>pxy</I>. If integer scaling is applied, the image will be displayed as large as possible within the given coordinates using <I>halign</I> and <I>valign</I> to specify the image justification as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
<B><FONT SIZE=1 >Value</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >halign </FONT></B></I>
</CENTER>

</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >valign</FONT></B></I>
</CENTER>

</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>Left</FONT>
</CENTER>

<P>

<CENTER>
<B><FONT SIZE=2>IMAGE_LEFT</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>Top</FONT>
</CENTER>

<P>

<CENTER>
<B><FONT SIZE=2>IMAGE_TOP</FONT></B>
</CENTER>

</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
1
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>Center</FONT>
</CENTER>

<P>

<CENTER>
<B><FONT SIZE=2>IMAGE_CENTER</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>Center</FONT>
</CENTER>

<P>

<CENTER>
<B><FONT SIZE=2>IMAGE_CENTER</FONT></B>
</CENTER>

</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
2
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>Right</FONT>
</CENTER>

<P>

<CENTER>
<B><FONT SIZE=2>IMAGE_RIGHT</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>Bottom</FONT>
</CENTER>

<P>

<CENTER>
<B><FONT SIZE=2>IMAGE_BOTTOM</FONT></B>
</CENTER>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
WORD tmp = 5;

intin[0] = ratio;
intin[1] = xscale;
intin[2] = yscale;
intin[3] = halign;
intin[4] = valign;
while(intin[tmp++] = (WORD)*fname++);

contrl[0] = 5;
contrl[1] = 2;
contrl[3] = --tmp;
contrl[5] = 23;
contrl[6] = handle;

ptsin[0] = pxy[0];
ptsin[1] = pxy[1];
ptsin[2] = pxy[2];
ptsin[3] = pxy[3];

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=5>A flag indicating whether the device supports scaling can be found in <B>vq_extnd()</B>. This call used with the memory driver can provide image scaling for transfer to the screen with <B>vrt_cpyfm()</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=5><B>vq_scan()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<a name=vcellarray><H3>v_cellarray()</H3>

<P>
<B>VOID v_cellarray( <I>handle</I>, <I>pxy</I>, <I>rowlen</I>,
<I>elements</I>, <I>num_rows</I>, <I>wrmode</I>, <I>colarray</I>
)</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>WORD *<I>pxy</I>;</B>
<P>
<B>WORD <I>rowlen</I>, <I>elements</I>, <I>num_rows</I>, <I>wrmode</I>;</B>
<P>
<B>WORD *<I>colarray</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_cellarray()</B> outputs an array of colored cells.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>10</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Not supported by any current drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>pxy</I> points to a <B>WORD</B> array with 4 entries specifying a <B>VDI</B> format rectangle giving the extent of the array to output. <I>rowlen</I> specifies the length of each color array row. <I>elements</I> specifies the total number of color array elements. <I>num_rows</I> specifies the number of rows in the color array. <I>wrmode</I> specifies a valid writing mode (1-4) and <I>colarray</I> points to an array of <B>WORD</B>s (<I>num_rows</I>&nbsp;*&nbsp;<I>elements</I>) long. 
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
WORD i;
intin[i] = colarray[i]
contrl[0] = 10;
contrl[1] = 2;
contrl[3] = num_rows * elements;
contrl[6] = handle;
contrl[7] = rowlen;
contrl[8] = elements;
contrl[9] = num_rows;
contrl[10] = wrt_mode;

for(i = 0;i &lt; (num_rows * elements);i++)
 intin[i] = colarray;

ptsin[0] = pxy[0];
ptsin[1] = pxy[1];
ptsin[2] = pxy[2];
ptsin[3] = pxy[3];

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>This function is not guaranteed available in any driver and should therefore be avoided unless you are sure the driver you are utilizing understands it.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vq_cellarray()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vcircle><H3>v_circle()</H3>

<P>
<B>VOID v_circle( <I>handle</I>, <I>x</I>, <I>y</I>, <I>radius</I>
)</B>
<P>
<B>WORD <I>handle</I>, <I>x</I>, <I>y</I>, <I>radius</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_circle()</B> outputs a filled circle.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>11</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>4</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers. This function composes one of the 10 <B>VDI</B> GDP's (Generalized Drawing Primitives). Although all current drivers support all GDP's, their availability is not guaranteed and may vary. To check for a particular GDP refer to the table returned by <B>v_opnvwk()</B> or <B>v_opnwk()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation. <I>x</I> and <I>y</I> specify the center of a circle with a radius of <I>radius</I>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 11;
contrl[1] = 3;
contrl[3] = 0;
contrl[5] = 4;
contrl[6] = handle;

ptsin[0] = x;
ptsin[1] = y;
ptsin[2] = ptsin[3] = 0;
ptsin[4] = radius;
ptsin[5] = 0;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vsf_color(), vsf_interior(), vsf_style(), vsf_udpat()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vcleardisplist><H3>v_clear_disp_list()</H3>

<P>
<B>VOID v_clear_disp_list( <I>handle</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_clear_disp_list()</B> clears the display list of a workstation.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>22</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by printer, plotter, metafile, and camera drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = contrl[3] = 0;
contrl[5] = 22;
contrl[6] = handle;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD><B>v_clear_disp_list()</B> is essentially the same as <B>v_clrwk()</B> except that no form feed is issued.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_clrwk()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vclrwk><H3>v_clrwk()</H3>

<P>
<B>VOID v_clrwk( <I>handle</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_clrwk()</B> clears a physical workstation.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>3</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 3;
contrl[1] = contrl[3] = 0;
contrl[6] = handle;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Physical workstations are cleared automatically when they are opened.
<P>
This call will generate a form feed on page-oriented  devices.Using this command on a virtual workstation will clear the underlying physical workstation. This is generally not recommended because it will effect all virtual workstations not simply your own.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_clear_disp_list(), v_updwk()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vclsvwk><H3>v_clsvwk()</H3>

<P>
<B>VOID v_clsvwk( <I>handle</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_clsvwk()</B> closes a virtual workstation.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>101</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid virtual workstation to close.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 101;
contrl[1] = contrl[3] = 0;
contrl[6] = handle;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_opnvwk()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vclswk><H3>v_clswk()</H3>

<P>
<B>VOID v_clswk( <I>handle</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_clswk()</B> closes a physical workstation.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>2</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available only with some form of <B>GDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid physical workstation to close.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 2;
contrl[1] = contrl[3] = 0;
contrl[6] = handle;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_opnvwk()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vcontourfill><H3>v_contourfill()</H3>

<P>
<B>VOID v_contourfill( <I>handle</I>, <I>x</I>, <I>y</I>, <I>color</I>
)</B>
<P>
<B>WORD <I>handle</I>, <I>x</I>, <I>y</I>, <I>color</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_countourfill()</B> outputs a 'seed' fill.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>103</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all <I>current</I> screen, printer and metafile drivers. The availability of this call can be checked for using <B>vq_extnd()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. x and y specify the starting point for the fill. If <I>color</I> is <B>OTHER_COLOR</B> (-1) then the fill continues in all directions until a color other than that found in <I>x</I> and <I>y</I> is found. If <I>color</I> is positive then the fill continues in all directions until color <I>color</I> is found.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 103;
contrl[1] = contrl[3] =  0;
contrl[6] = handle;

intin[0] = color;

ptsin[0] = x;
ptsin[1] = y;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>In true-color mode if a positive value for <I>color</I> is used, the fill spreads until a pixel is found with the same color as 'virtual pen' <I>color</I>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vsf_color(), vsf_interior(), vsf_style(), vsf_udpat()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vcurdown><H3>v_curdown()</H3>

<P>
<B>VOID v_curdown( <I>handle</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_curdown()</B> moves the text cursor down one line.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all screen drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = contrl[3] = 0;
contrl[5] = 5;
contrl[6] = handle;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call is equivalent to the esc-b VT-52 code.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_curup()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vcurhome><H3>v_curhome()</H3>

<P>
<B>VOID v_curdown( <I>handle</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_curhome()</B> moves the text cursor to the upper-left of the screen.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>8</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all screen drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = contrl[3] = 0;
contrl[5] = 8;
contrl[6] = handle;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call is equivalent to the esc-h VT-52 code.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vcurleft><H3>v_curleft()</H3>

<P>
<B>VOID v_curleft( <I>handle</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_curleft()</B> moves the text cursor left one character position.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>7</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all screen drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> is a valid workstation handle.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = contrl[3] = 0;
contrl[5] = 7;
contrl[6] = handle;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call is equivalent to the esc-d VT-52 code.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_curright()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vcurright><H3>v_curright()</H3>

<P>
<B>VOID v_curright( <I>handle</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_curright()</B> moves the text cursor one position to the right.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>6</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all screen drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = contrl[3] = 0;
contrl[5] = 6;
contrl[6] = handle;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call is equivalent to the esc-c VT-52 code.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_curleft()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vcurtext><H3>v_curtext()</H3>

<P>
<B>VOID v_curtext( <I>handle</I>, <I>str</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>char *<I>str</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_curtext()</B> outputs a line of text to the screen in text mode.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>12</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all screen drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> is a valid workstation handle. <I>str</I> is a character pointer to a string no more than 127 characters long.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
WORD i = 0;

while(intin[i++] = (WORD)*str++);

intin[i] = 0;
contrl[0] = 5;
contrl[1] = 0;
contrl[3] = --i;
contrl[5] = 12;
contrl[6] = handle;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The line of text must not exceed the maximum length of the intin array as returned by <B>vq_extnd()</B> or the maximum length of your compilers' array.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vs_curaddress(), v_rvon(), v_rvoff()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vcurup><H3>v_curup()</H3>

<P>
<B>VOID v_curup( <I>handle</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_curup()</B> moves the text cursor up one line.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>4</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all screen drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = contrl[3] = 0;
contrl[5] = 4;
contrl[6] = handle;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call is equivalent to the esc-a VT-52 code.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_curdown()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vdspcur><H3>v_dspcur()</H3>

<P>
<B>VOID v_dspcur( <I>handle</I>, <I>x</I>, <I>y</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>x</I>, <I>y</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_dspcur()</B> displays the mouse pointer on screen at the specified position.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>18</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all screen drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>x</I> and <I>y</I> specify the screen coordinates of where to display the mouse pointer.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = 1
contrl[3] = 0;
contrl[5] = 18;
contrl[6] = handle;

ptsin[0] = x;
ptsin[1] = y;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call will render a mouse cursor on screen regardless of its current 'show' status. Normally a function will use either <B>graf_mouse()</B> if using the <B>AES</B> or <B>v_show_c()</B> if using the <B>VDI</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_rmcur(), graf_mouse(), v_show_c()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=veeol><H3>v_eeol()</H3>

<P>
<B>VOID v_eeol( <I>handle</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_eeol()</B> erases the text line from the current cursor position rightwards.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>10</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all screen drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = contrl[3] = 0;
contrl[5] = 10;
contrl[6] = handle;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call is equivalent to the esc-k VT-52 code.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_eeos()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=veeos><H3>v_eeos()</H3>

<P>
<B>WORD v_eeos( <I>handle</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_eeos()</B> erases the current screen of text from the cursor position.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>9</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all screen drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = contrl[3] = 0;
contrl[5] = 9;
contrl[6] = handle;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call is equivalent to the esc-j VT-52 code.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_eeol()</B></TD></TR>

</TABLE>

<P>

<HR>

<HR>

<a name=vellarc><H3>v_ellarc()</H3>

<P>
<B>VOID v_ellarc( <I>handle</I>, <I>x</I>, <I>y</I>, <I>xradius</I>,
<I>yradius</I>, <I>startangle</I>, <I>endangle</I>)</B>
<P>
<B>WORD <I>handle</I>, <I>x</I>, <I>y</I>, <I>xradius</I>, <I>yradius</I>,
<I>startangle</I>, <I>endangle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_ellarc()</B> outputs an elliptical arc segment.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>11</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>6</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers. This function composes one of the 10 <B>VDI</B> GDP's (Generalized Drawing Primitives). Although all current drivers support all GDP's, their availability is not guaranteed and may vary. To check for a particular GDP refer to the table returned by <B>v_opnvwk()</B> or <B>v_opnwk()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>x</I> and <I>y</I> specify the coordinates of the center of an arc with an X radius of <I>xradius</I> and a Y radius of <I>yradius</I>. Only the portion of the arc which falls between the angles specified in <I>startangle</I> and <I>endangle</I> will be drawn. Angles are specified in tenths of degrees as follows:
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 11;
contrl[1] = contrl[3] = 2;
contrl[5] = 6;
contrl[6] = handle;

intin[0] = startangle;
intin[1] = endangle;

ptsin[0] = x;
ptsin[1] = y;
ptsin[2] = xradius;
ptsin[3] = yradius;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_ellipse(), v_ellpie(), vsl_color(), vsl_type(), vsl_width(), vsl_udsty()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vellipse><H3>v_ellipse()</H3>

<P>
<B>VOID v_ellipse( <I>handle</I>, <I>x</I>, <I>y</I>, <I>xradius</I>,
<I>yradius</I>)</B>
<P>
<B>WORD <I>handle</I>, <I>x</I>, <I>y</I>, <I>xradius</I>, <I>yradius</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_ellipse()</B> outputs a filled ellipse.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>11</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers.  This function composes one of the 10 <B>VDI</B> GDP's (Generalized Drawing Primitives). Although all current drivers support all GDP's, their availability is not guaranteed and may vary. To check for a particular GDP refer to the table returned by <B>v_opnvwk()</B> or <B>v_opnwk()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>x</I> and <I>y</I> specify the center point of an arc with an X radius of <I>xradius</I> and a Y radius of <I>yradius</I>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 11;
contrl[1] = 2;
contrl[3] = 0;
contrl[5] = 5;
contrl[6] = handle;

ptsin[0] = x;
ptsin[1] = y;
ptsin[2] = xradius;
ptsin[3] = yradius;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_ellpie(), v_ellarc(), vsf_color(), vsf_interior(), vsf_style(), vsf_udpat(), vs_perimeter()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vellpie><H3>v_ellpie()</H3>

<P>
<B>VOID v_ellpie( <I>handle</I>, <I>x</I>, <I>y</I>, <I>xradius</I>,
<I>yradius</I>, <I>startangle</I>, <I>endangle</I>)</B>
<P>
<B>WORD <I>handle</I>, <I>x</I>, <I>y</I>, <I>xradius</I>, <I>yradius</I>,
<I>startangle</I>, <I>endangle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_ellpie()</B> outputs a filled elliptical pie segment.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>11</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>7</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers.  This function composes one of the 10 <B>VDI</B> GDP's (Generalized Drawing Primitives). Although all current drivers support all GDP's, their availability is not guaranteed and may vary. To check for a particular GDP refer to the table returned by <B>v_opnvwk()</B> or <B>v_opnwk()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>x</I> and <I>y</I> specify the center coordinates of an elliptical pie segment to draw with an X radius of <I>xradius</I> and a Y radius of <I>yradius</I>. Only the portion of the arc will be drawn falling between the angles specified in <I>startangle</I> and <I>endangle </I>(as shown below). The ends of this arc is connected to the center point with lines forming the pie segment.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 11;
contrl[1] = contrl[3] = 2;
contrl[5] = 7;
contrl[6] = handle;

intin[0] = startangle;
intin[1] = endangle;

ptsin[0] = x;
ptsin[1] = y;
ptsin[2] = xradius;
ptsin[3] = yradius;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_ellarc(), v_ellipse(), vsf_color(), vsf_style(), vsf_interior(), vsf_udpat(), vs_perimeter()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=ventercur><H3>v_enter_cur()</H3>

<P>
<B>VOID v_enter_cur( <I>handle</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_enter_cur()</B> clears the screen to color 0, removes the mouse cursor and enters text mode.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>3</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all screen drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = contrl[3] = 0;
contrl[5] = 3;
contrl[6] = handle;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>You should check that the left mouse button has been released with <B>vq_mouse()</B> prior to calling this function. If the button is depressed when you call this function the <B>VDI</B> will lock waiting for it to be released after <B>v_exit_cur()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call is used by a <B>GEM</B> application to prepare for executing a <B>TOS</B> application when not running under <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_exit_cur()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vexitcur><H3>v_exit_cur()</H3>

<P>
<B>VOID v_exit_cur( <I>handle</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_exit_cur()</B> exits text mode and restores the mouse pointer.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>2</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all screen drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = contrl[3] = 0;
contrl[5] = 2;
contrl[6] = handle;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>See <B>v_enter_cur()</B>.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>To completely restore the screen you should call <B>form_dial(FMD_FINISH</B>, <I>sx</I>, <I>sy</I>, <I>sw</I>, <I>sh</I>) where <I>sx</I>, <I>sy</I>, <I>sw</I>, and <I>sh</I> are the coordinates of the screen.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_enter_cur()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vfillarea><H3>v_fillarea()</H3>

<P>
<B>VOID v_fillarea( <I>handle</I>, <I>count</I>, <I>pxy</I>)</B>
<P>
<B>WORD <I>handle</I>, <I>count</I>;</B>
<P>
<B>WORD *<I>pxy</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_fillarea()</B> outputs a filled polygon.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>9</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>count</I> specifies the number of vertices in the polygon to output. <I>pxy</I> should point to an array of coordinate pairs with the first <B>WORD</B> being the first X point, the second <B>WORD</B> being the first Y point and so on.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
WORD i;

contrl[0] = 9;
contrl[1] = count;
contrl[3] = 0;
contrl[6] = handle;

for(i = 0;i &lt; count*2;i++)
 ptsin[i] = pxy[i];

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This function will automatically connect the first point with the last point.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_pline(), v_contourfill()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vflushcache><H3>v_flushcache()</H3>

<P>
<B>VOID v_flushcache( <I>handle</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_flushcache()</B> flushes the character bitmap portion of the cache.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>251</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available only with <B>FSMGDOS </B>and <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 251;
contrl[1] = contrl[3] = 0;
contrl[6] = handle;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_loadcache(), v_savecache()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vfontinit><H3>v_fontinit()</H3>

<P>
<B>VOID v_fontinit( <I>fptr_high</I>, <I>fptr_low</I> )</B>
<P>
<B>WORD <I>fptr_high</I>, <I>fptr_low</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_fontinit()</B> allows replacement of the built-in system font.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>102</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>TOS</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>fptr_high</I> and <I>fptr_low</I> are the high and low <B>WORD</B>s of a pointer to a Line-A compatible font header structure in Motorola (Big-Endian) format which contains information about the font to be used as a replacement for the system font.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = 0;
contrl[3] = 2;
contrl[5] = 102;
contrl[6] = handle;

intin[0] = fptr_high;
intin[1] = fptr_low;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This function has never been officially documented though it exists in all current versions of <B>TOS</B>.
</TD></TR>

</TABLE>

<P>
 
<HR>

<a name=vformadv><H3>v_form_adv()</H3>

<P>
<B>VOID v_form_adv( <I>handle</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_form_adv()</B> outputs the current page without clearing the display list.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>20</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = contrl[3] = 0;
contrl[5] = 20;
contrl[6] = handle;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This function is useful if you wish to print a new page containing the same objects as on the previous page.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_updwk()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vftext><H3>v_ftext()</H3>

<P>
<B>VOID v_ftext( <I>handle</I>, <I>x</I>, <I>y</I>, <I>str</I>)</B>
<P>
<B>WORD <I>handle</I>, <I>x</I>, <I>y</I>;</B>
<P>
<B>char *<I>str</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_ftext()</B> outputs outline text taking spacing remainders into consideration.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>241</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available only with <B>FSMGDOS </B>or <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>x</I> and <I>y</I> specify the starting coordinate of the <B>NULL</B>-terminated text string (see <B>vst_alignment()</B> ) pointed to by <I>str</I> to print. 
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
WORD i = 0;

while(intin[i++] = (WORD)*str++);

contrl[0] = 241;
contrl[1] = 1;
contrl[3] = --i;
contrl[6] = handle;

ptsin[0] = x;
ptsin[1] = y;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The text contained in <I>str</I> (including its <B>NULL</B> byte) should not exceed the maximum allowable size of the <I>intin</I> array (as indicated in the <I>work_out</I> array) or the size of the <I>intin</I> array allocated by your compiler.To output 16-bit Speedo character indexes, use <B>v_ftext16()</B>.This function produces output more properly spaced than with <B>v_gtext()</B> because it takes the remainder amounts from <B>vqt_f_extent()</B> into consideration.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_ftext(), v_ftext_offset(), <a name=vftestoffset162>v_ftext_offset16(), v_gtext(), vst_alignment(), vst_color(), vst_effects(), vst_arbpt(), vst_height(), vst_font(), vqt_f_extent(), vst_point()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vftext16><H3>v_ftext16()</H3>

<P>
<B>VOID v_ftext16( <I>handle</I>, <I>x</I>, <I>y</I>, <I>wstr</I>,
<I>wstrlen</I>)</B>
<P>
<B>WORD <I>handle</I>, <I>x</I>, <I>y</I>;</B>
<P>
<B>WORD *<I>wstr</I>;</B>
<P>
<B>WORD <I>wstrlen</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_ftext16()</B> is a variant binding of <B>v_ftext()</B> that outputs 16-bit Speedo character text rather than 8-bit ASCII text.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>241</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available only with <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>x</I> and <I>y</I> specify the starting coordinate of the location to output text. <I>wstr</I> points to a <B>NULL</B>-terminated text string composed of <B>WORD</B>-sized Speedo characters. <I>wstrlen</I> specifies the length of the text string.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
WORD i;

for( i = 0; i &lt; wstrlen; i++)
 intin[i] = wstr[i];

contrl[0] = 241;
contrl[1] = 1;
contrl[3] = wstrlen;
contrl[6] = handle;

ptsin[0] = x;
ptsin[1] = y;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This function should only be used when <B>vst_charmap()</B> has been used to indicate that <B>WORD</B>-sized Speedo character indexes should be recognized rather than 8-bit ASCII.The text contained in <I>wstr</I> (including its <B>NULL</B> byte) should not exceed the maximum allowable size of the <I>intin</I> array (as indicated in the <I>work_out</I> array) or the size of the <I>intin</I> array allocated by your compiler.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>Current versions of <B>SpeedoGDOS</B> become confused when the space character (&nbsp;index 0) is encountered in the string. It is suggested that one of the three space characters (of varying widths) at indexes 560-562 be used instead.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_ftext(), v_ftext_offset(), v_ftext_offset16(), v_gtext(), vst_alignment(), vst_color(), vst_effects(), vst_arbpt(), vst_height(), vst_font(), vqt_f_extent(), vst_point()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vftextoffset><H3>v_ftext_offset()</H3>

<P>
<B>VOID v_ftext_offset( <I>handle</I>, <I>x</I>, <I>y</I>, <I>str</I>,
<I>offset</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>x</I>, <I>y</I>;</B>
<P>
<B>char *<I>str</I>;</B>
<P>
<B>WORD *<I>offset</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_ftext_offset()</B> is a variant binding of <B>v_ftext()</B> available under <B>SpeedoGDOS</B> which allows an offset vector for each character to be specified.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>241</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available only with <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>x</I> and <I>y</I> give the point where the string will be rendered. <I>offset</I> points to an array of <B>WORD</B>s which contains one x and y offset value for each character in <I>str</I>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
WORD i = 0;

while(intin[i++] = (WORD)*str++);
--i;

ptsin[0] = x;
ptsin[1] = y;

for(j = 0; j &lt; i * 2;j++)
 ptsin[j + 2] = offset[j]; 

contrl[0] = 241;
contrl[1] = i + 1;
contrl[3] = i;
contrl[6] = handle;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The text contained in <I>str</I> (including its <B>NULL</B> byte) should not exceed the maximum allowable size of the <I>intin</I> array (as indicated in the <I>work_out</I> array) or the size of the <I>intin</I> array allocated by your compiler.To output 16-bit Speedo character indexes, use <B>v_ftext_offset16()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_ftext_offset16(), v_ftext(), v_gtext()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=voffset16><H3>v_ftext_offset16()</H3>

<P>
<B>VOID v_ftext_offset( <I>handle</I>, <I>x</I>, <I>y</I>, <I>wstr</I>,
<I>wstrlen, offset</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>x</I>, <I>y</I>;</B>
<P>
<B>WORD *<I>wstr</I>;</B>
<P>
<B>WORD <I>wstrlen</I>;</B>
<P>
<B>WORD *<I>offset</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_ftext_offset16()</B> is a variant binding of <B>v_ftext_offset()</B> which allows 16-bit Speedo character strings to be output rather than 8-bit ASCII codes.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>241</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available only with <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>x</I> and <I>y</I> give the point where the string will be rendered. <I>offset</I> points to an array of <B>WORD</B>s which contains one x and y offset value for each character in <I>wstr</I>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
WORD i;

for( i = 0;i &lt; wstrlen; i++)
 intin[i] = wstr[i];

ptsin[0] = x;
ptsin[1] = y;

for(j = 0; j &lt; i * 2;j++)
 ptsin[j + 2] = offset[j]; 

contrl[0] = 241;
contrl[1] = wstrlen + 1;
contrl[3] = wstrlen;
contrl[6] = handle;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This function should only be used when <B>vst_charmap()</B> has been used to indicate that <B>WORD</B> sized Speedo character indexes should be recognized rather than 8-bit ASCII.The text contained in <I>wstr</I> (including its <B>NULL</B> byte) should not exceed the maximum allowable size of the <I>intin</I> array (as indicated in the <I>work_out</I> array) or the size of the <I>intin</I> array allocated by your compiler.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>Current versions of <B>SpeedoGDOS</B> become confused when the space character (&nbsp;index 0) is encountered in the string. It is suggested that one of the three space characters (of varying widths) at indexes 560-562 be used instead.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><a name=vftext162><B>v_ftext16(), v_ftext_offset()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>v_getbitmap_info()</H3>

<P>
<B>VOID v_getbitmap_info( <I>handle</I>, <I>ch</I>, <I>advx</I>,
<I>advy</I>, <I>xoff</I>, <I>yoff</I>, <I>width</I>, <I>height</I>,
<I>bitmap</I>)</B>
<P>
<B>WORD <I>handle</I>, <I>ch</I>;</B>
<P>
<B>fix31 *advx, *advy, *xoff, *yoff;</B>
<P>
<B>WORD *width, *height;</B>
<P>
<B>VOID *bitmap;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_getbitmap_info()</B> returns placement information for the bitmap of a character based on the current character font, size, and alignment.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>239</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available only with <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>ch</I> is the character to return information about.The <B>fix31</B> variables pointed to by <I>advx</I>, <I>advy</I>, <I>xoff</I>, and <I>yoff</I> will be filled in with the x and y advance and offset vectors respectively. The <B>WORD</B>s pointed to by <I>width</I> and <I>height</I> will be filled in with the width and height of the bitmap pointed to by the value returned in <I>bitmap</I>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 239;
contrl[1] = 0;
contrl[3] = 1;
contrl[6] = handle;

intin[0] = ch;

vdi();

*width = intout[0];
*height = intout[1];
*advx = *(fix31 *)&amp;intout[2];
*advy = *(fix31 *)&amp;intout[4];
*xoff = *(fix31 *)&amp;intout[6];
*yoff = *(fix31 *)&amp;intout[8];
*bitmap = *(void *)&amp;intout[10];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The advance vector represents the amount to add to the current point to properly place the character. The offset vector, when added to the current point, give the location of the upper-left corner of the bitmap.
</TD></TR>

</TABLE>

<P>

<HR>

<H3>v_getoutline()</H3>

<P>
<B>VOID v_getoutline( <I>handle</I>, <I>ch</I>, <I>xyarray, bezarray,
maxverts, numverts</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>ch</I>;</B>
<P>
<B>WORD *xyarray;</B>
<P>
<B>char *bezarray;</B>
<P>
<B>WORD maxverts;</B>
<P>
<B>WORD *numverts;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_getoutline()</B> returns information about an <B>SpeedoGDOS </B>character required to generate the character with bezier curves.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>243</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available only with <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>ch</I> specifies the character to return information about. The arrays pointed to by <I>xyarray</I> and <I>bezarray</I> are filled in with the bezier information for the character. The definition of <I>xyarray</I> and <I>bezarray</I> is given in the binding for <B>v_bez()</B>. <I>maxverts</I> should indicate the maximum number of vertices the buffer can hold. The <B>WORD</B> pointed to by <I>numverts</I> will be filled in with the actual number of vertices for the character.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 243;
contrl[1] = 0;
contrl[3] = 6;
contrl[6] = handle;

intin[0] = ch;
intin[1] = maxverts;
*(WORD *)&amp;intin[2] = xyarray;
*(WORD *)&amp;intin[4] = bezarray;

vdi();

*numverts = intout[0];
</PRE>

</TD></TR>

</TABLE>

<P>

<HR>

<a name=vgetpixel><H3>v_get_pixel()</H3>

<P>
<B>VOID v_get_pixel( <I>handle</I>, <I>x</I>, <I>y</I>, <I>pindex</I>,
<I>vindex</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>x</I>, <I>y</I>;</B>
<P>
<B>WORD *<I>pindex</I>, *<I>vindex</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_get_pixel()</B> returns the color value for a specified coordinate on the screen.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>105</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all screen drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>x</I> any <I>y</I> specify the coordinate to return color information for.In a palette-based mode the <B>WORD</B> pointed to by <I>pindex</I> will contain the hardware register index of the color and the <B>WORD</B> pointer to by <I>vindex</I> will contain the <B>VDI</B> index of the color.In 16-bit true-color modes, <I>pindex</I> will be 0 and <I>vindex</I> will return the 16-bit RGB pixel value in the format {RRRR RGGG GGGB BBBB}.In 32-bit color modes, the lower byte of <I>vindex</I> will contain the 8 bits of red data, the upper byte of <I>pindex</I> will contain the 8 bits of green data, and the lower byte of <I>pindex</I> will contain the 8 bits of blue data. The upper byte of <I>vindex</I> is reserved for non-color data.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 105;
contrl[1] = 1;
contrl[3] = 0;
contrl[6] = handle;

ptsin[0] = x;
ptsin[1] = y;

vdi();

*pindex = intout[0];
*vindex = intout[1];
</PRE>

</TD></TR>

</TABLE>

<P>

<HR>

<a name=vgtext><H3>v_gtext()</H3>

<P>
<B>VOID v_gtext( <I>handle</I>, <I>x</I>, <I>y</I>, <I>str</I>)</B>
<P>
<B>WORD <I>handle</I>, <I>x</I>, <I>y</I>;</B>
<P>
<B>char *<I>str</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_gtext()</B> outputs graphic text.</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>8</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>x</I> and <I>y</I> specify the starting coordinates of the text (see <B>vst_alignment()</B> ). <I>str</I> is a pointer to a <B>NULL</B>-terminated character string to print.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
WORD i = 0;

while(intin[i++] = (WORD)*str++);

contrl[0] = 8;
contrl[1] = 1;
contrl[3] = --i;
contrl[6] = handle;

ptsin[0] = x;
ptsin[1] = y;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The text contained in <I>str</I> (including its <B>NULL</B> byte) should not exceed the maximum allowable size of the <I>intin</I> array (as indicated in the <I>work_out</I> array) or the size of the <I>intin</I> array allocated by your compiler.Using this function to output outline text with <B>FSMGDOS</B> is possible to remain backward-compatible but not recommended as it will introduce small errors as spacing remainders are lost.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_ftext(), v_ftext_offset(), vst_color(), vst_effects(), vst_alignment(), vst_height(), vst_point()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vhardcopy><H3>v_hardcopy()</H3>

<P>
<B>VOID v_hardcopy( <I>handle</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_hardcopy()</B> invokes the alt-help screen dump.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>17</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by screen drivers running under ST compatible resolutions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = contrl[3] = 0;
contrl[5] = 17;
contrl[6] = handle;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>This function works in only ST compatible screen modes and should thus be avoided.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Scrdmp()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vhidec><H3>v_hide_c()</H3>

<P>
<B>VOID v_hide_c( <I>handle</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_hide_c()</B> hides the mouse cursor.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>123</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all screen drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 123;
contrl[1] = contrl[3] = 0;
contrl[6] = handle;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call is nested. For each time you call this function you must call <B>v_show_c()</B> an equal number of times to show the mouse.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_show_c(), graf_mouse()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vjustified><H3>v_justified()</H3>

<P>
<B>VOID v_justified( <I>handle</I>, <I>x</I>, <I>y</I>, <I>str</I>,
<I>length</I>, <I>wflag</I>, <I>cflag</I>)</B>
<P>
<B>WORD <I>handle</I>, <I>x</I>, <I>y</I>;</B>
<P>
<B>char *<I>str</I>;</B>
<P>
<B>WORD <I>length</I>, <I>wflag</I>, <I>cflag</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_justified()</B> outputs justified graphics text.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>11</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>10</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers. This function composes one of the 10 <B>VDI</B> GDP's (Generalized Drawing Primitives). Although all current drivers support all GDP's, their availability is not guaranteed and may vary. To check for a particular GDP refer to the table returned by <B>v_opnvwk()</B> or <B>v_opnwk()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>x</I> and <I>y</I> specify the starting coordinates at which to draw the <B>NULL</B>-terminated text string (see <B>vst_alignment()</B> ) pointed to by <I>str</I>. <I>length</I> specifies the pixel length of the area to justify on. <I>wflag</I> and <I>cflag</I> specify the type of justification to perform between words and characters respectively. A value of <B>NOJUSTIFY</B> (0) indicates no justification whereas a value of <B>JUSTIFY</B> (1) indicates to perform justification.  
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
WORD i = 0;

while(intin[i++] = (WORD)*str++);

contrl[0] = 11;
contrl[1] = 2;
contrl[3] = --i;
contrl[5] = 10;
contrl[6] = handle;

intin[0] = wflag;
intin[1] = cflag;

ptsin[0] = x;
ptsin[1] = y;
ptsin[2] = length;
ptsin[3] = 0;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call does not take into account remainder information from outline fonts.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_gtext(), v_ftext(), vst_color(), vst_font(), vst_effects(), vst_alignment(), vst_point(), vst_height()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>v_killoutline()</H3>

<P>
<B>VOID v_killoutline( <I>handle</I>, <I>outline</I>)</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>FSMOUTLINE <I>outline</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_killoutline()</B> releases an outline from memory.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>242</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available only with <B>FSMGDOS </B>or <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Under <B>FSMGDOS </B>this call was required to release memory allocated for an outline returned from <B>v_getoutline()</B>. With <B>SpeedoGDOS</B>, this call is no longer required and is thus not documented further.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_getoutline()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vloadcache><H3>v_loadcache()</H3>

<P>
<B>WORD v_loadcache( <I>handle</I>, <I>fname</I>, <I>mode</I>)</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>char *<I>fname</I>;</B>
<P>
<B>WORD <I>mode</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_loadcache()</B> loads a previously saved cache file from disk.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>250</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported only by <B>FSMGDOS </B>and <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>fname</I> specifies the <B>GEMDOS</B> file specification of the cache file to load. <I>mode</I> specifies whether current data will be flushed first. A value of 0 will append the loaded cache to the current cache whereas a value of 1 will flush the cache prior to loading.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
WORD i = 1;

intin[0] = mode;
while(intin[i++] = (WORD)*fname++);

contrl[0] = 250;
contrl[1] = 0;
contrl[3] = i;
contrl[6] = handle;

vdi();

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>v_loadcache()</B> returns 0 if successful or -1 if an error occurred.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This command only affects the cache responsible for storing bitmaps created from outline characters.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_savecache(), v_flushcache()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vmetaextents><H3>v_meta_extents()</H3>

<P>
<B>VOID v_meta_extents( <I>handle</I>, <I>xmin</I>, <I>ymin</I>,
<I>xmax</I>, <I>ymax</I>)</B>
<P>
<B>WORD <I>handle</I>, <I>xmin</I>, <I>ymin</I>, <I>xmax</I>,
<I>ymax</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_meta_extents()</B> embeds placement information for a metafile.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>98</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all metafile drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>xmin</I> and <I>ymin</I> specify the upper left corner of the bounding box of the metafile. <I>xmax</I> and <I>ymax</I> specify the lower left corner.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = 2;
contrl[3] = 0;
contrl[5] = 98;
contrl[6] = handle;

ptsin[0] = xmin;
ptsin[1] = ymin;
ptsin[2] = xmax;
ptsin[3] = ymax;

vdi();                                                        
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Parameters sent to this call should be specified in whatever coordinate system the metafile is currently using.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vm_pagesize()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vopnvwk><H3>v_opnvwk()</H3>

<P>
<B>VOID v_opnvwk( <I>work_in</I>, <I>handle</I>, <I>work_out </I>)</B>
<P>
<B>WORD *<I>work_in, *handle, *work_out</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=6><B>v_opnvwk()</B> opens a virtual <B>VDI</B> workstation.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6><B>dev()</B> a pointer to a virtual <B>VDI</B> workstation.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=6>100</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=6>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=6><I>work_in</I> is a pointer to an array of 11 <B>WORD</B>s which define the inital defaults for the workstation as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2>
<CENTER>
<I><B><FONT SIZE=1 >work_in[ x ]</FONT></B></I>
</CENTER>

</TD><TD COLSPAN=2><B><FONT SIZE=2 >Meaning</FONT></B>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2>
<CENTER>
0
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Device identification number. This indicates the physical device ID of the device (the line number of the driver in ASSIGN.SYS when using <B>GDOS</B>). For screen devices you should normally use the value <B>Getrez()</B>&nbsp;+&nbsp;2, however, a value of 1 is acceptable if not using any loaded fonts.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2>
<CENTER>
1
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Default line type (same as <B>vsl_type()</B> ).</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2>
<CENTER>
2
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Default line color (same as <B>vsl_color()</B> ).</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2>
<CENTER>
3
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Default marker type (same as <B>vsm_type()</B> ).</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2>
<CENTER>
4
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Default marker color (same as <B>vsm_color()</B> ).</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2>
<CENTER>
5
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Default font (same as <B>vst_font()</B> ).</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2>
<CENTER>
6
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Default text color (same as <B>vst_color()</B> ).</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2>
<CENTER>
7
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Default fill interior.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2>
<CENTER>
8
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Default fill style.</FONT></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2>
<CENTER>
9
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Default fill color.</FONT></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2>
<CENTER>
10
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Coordinate type flag. A value of 0 specifies NDC 'Normalized Device Coordinates' coordinates whereas a value of 2 specifies RC 'Raster Coordinates'. All other values are reserved. NDC coordinates are only available when using external drivers with <B>GDOS</B>.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH></TH><TD COLSPAN=6><I>handle</I> should be set to the current handle (not the device ID) of the physical workstation for this device. For screen devices this is the value returned by <B>graf_handle()</B>. On exit <I>handle</I> will be filled in the <B>VDI</B> workstation handle allocated, if successful, or 0 if the workstation could not be opened.<I>work_out</I> points to an array of 57 <B>WORD</B>s which on exit will be filled in by the <B>VDI</B> with information regarding the allocated workstation as follows (a structure name is listed beside its array member for those using the 'C' style <B>VDI_Workstation</B> structure instead of the array):
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
<I><B><FONT SIZE=1 >work_out[x]</FONT></B></I>
</CENTER>

</TD><TD COLSPAN=2>
<CENTER>
<B><FONT SIZE=2 >VDI Structure Member</FONT></B>
</CENTER>

</TD><TD COLSPAN=2><B><FONT SIZE=2 >Meaning</FONT></B>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
0
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>xres</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Width of device in pixels&nbsp;-&nbsp;1.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
1
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>yres</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Height of device in pixels&nbsp;-&nbsp;1.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
2
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>noscale</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Device coordinate units flag:</FONT>0 = Device capable of producing a precisely scaled image (screen, printer, etc...)
<P>
<FONT SIZE=2>1 = Device not capable of producing a precisely scaled image (film recorder, etc...)</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
3
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>wpixel</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>WIdth of pixel in microns (1/25400 inch).</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
4
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>hpixel</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Height of pixel in microns (1/25400 inch).</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
5
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>cheights</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Number of character heights (0 = continuous scaling).</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
6
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>linetypes</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Number of line types.</FONT></TD>
</TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
7
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>linewidths</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Number of line widths (0&nbsp;=&nbsp;continous scaling).</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
8
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>markertypes</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Number of marker types.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
9
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>markersizes</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Number of marker sizes (0&nbsp;=&nbsp;continuous scaling).</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
10
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>faces</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Number of faces supported by the device.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
11
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>patterns</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Number of available patterns.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
12
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>hatches</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Number of available hatches.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
13
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>colors</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Number of predefined colors/pens (ST High = 2, ST Medium = 4, TT Low = 256, True Color = 256).</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
14
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>ngdps</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Number of supported GDP's</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
15-24
</CENTER>
</TD>
<TD COLSPAN=2>
<CENTER>
<I>cangdps[10]</I>
</CENTER>
</TD>
<TD COLSPAN=2><I><FONT SIZE=2>cangdps</FONT></I>[<I> </I>0 - (<I>ngdps </I>- 1)] contains a list of the GDP's the device supports as follows:<FONT SIZE=2>1 = Bar</FONT>
<P>
<FONT SIZE=2>2 = Arc</FONT>
<P>
<FONT SIZE=2>3 = Pie Slice</FONT>
<P>
<FONT SIZE=2>4 = Circle</FONT>
<P>
<FONT SIZE=2>5 = Ellipse</FONT>
<P>
<FONT SIZE=2>6 = Elliptical Arc</FONT>
<P>
<FONT SIZE=2>7 = Elliptical Pie</FONT>
<P>
<FONT SIZE=2>8 = Rounded Rectangle</FONT>
<P>
<FONT SIZE=2>9 = Filled Rounded Rectangle</FONT>
<P>
<FONT SIZE=2>10 = Justified Graphics Text</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
25-34
</CENTER>
</TD>
<TD COLSPAN=2>
<CENTER>
<I>gdpattr[10]</I>
</CENTER>
</TD>
<TD COLSPAN=2><FONT SIZE=2>For each GDP as listed above, <I>gdpattr</I>[ 0 - (<I>ngdps</I> - 1)] indicates the attributes which are applied to that GDP as follows:</FONT>1 = Polyline (vsl_...)
<P>
<FONT SIZE=2>2 = Polymarker (vsm_...)</FONT>
<P>
<FONT SIZE=2>3 = Text (vst_...)</FONT>
<P>
<FONT SIZE=2>4 = Fill Area (vsf_...)</FONT>
<P>
<FONT SIZE=2>5 = None</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
35
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>cancolor</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Color capability flag.</FONT>0 = No
<P>
<FONT SIZE=2>1 = Yes</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
36
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>cantextrot</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Text rotation flag.</FONT>0 =  No
<P>
<FONT SIZE=2>1 = Yes</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
37
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>canfillarea</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Fill area capability flag.</FONT>0 =  No
<P>
<FONT SIZE=2>1 = Yes</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
38
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>cancellarray</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Cell array capability flag.</FONT>0 =  No
<P>
<FONT SIZE=2>1 = Yes</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
39
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>palette</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Number of available colors in palette.</FONT>0 = &gt; 32767 colors
<P>
<FONT SIZE=2>2 = Monochrome</FONT>
<P>
<FONT SIZE=2>&gt;2 = Color</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
40
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>locators</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Number of locator devices.</FONT>1 = Keyboard only.
<P>
<FONT SIZE=2>2 = Keyboard and other.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
41
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>valuators</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Number of valuator devices.</FONT>1 = Keyboard only.
<P>
<FONT SIZE=2>2 = Keyboard and other.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
42
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>choicedevs</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Number of choice devices.</FONT>1 = Function keys.
<P>
<FONT SIZE=2>2 = Function keys + keypad.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
43
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>stringdevs</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Number of string devices.</FONT>1 = Keyboard.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
44
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>wstype</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Workstation type.</FONT>0 = Output only
<P>
<FONT SIZE=2>1 = Input only</FONT>
<P>
<FONT SIZE=2>2 = Input/Output</FONT>
<P>
<FONT SIZE=2>3 = Metafile</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
45
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>minwchar</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Minimum character width in pixels.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
46
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>minhchar</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Minimum character height in pixels.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
47
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>maxwchar</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Maximum character width in pixels.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
48
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>maxhchar</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Maximum character height in pixels.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
49
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>minwline</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Minimum line width.</FONT></TD>
</TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
50
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>zero5</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Reserved (0).</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
51
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>maxwline</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Maximum line width.</FONT></TD>
</TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
52
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>zero7</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Reserved (0).</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
53
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>minwmark</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Minimum marker width.</FONT></TD>
</TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
54
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>minhmark</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Minimum marker height.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
55
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>maxwmark</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Maximum marker width.</FONT></TD>
</TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
56
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<I>maxhmark</I>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Maximum marker height.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD><TD COLSPAN=2></TD><TD COLSPAN=2>
</TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=6>
<PRE>
WORD i;

contrl[0] = 100;
contrl[1] = 0;
contrl[3] = 11;
contrl[6] = *handle;

for(i = 0;i &lt; 11;i++)
 intin[i] = work_in[i];

vdi();

*handle = contrl[6];

for(i = 0;i &lt; 45;i++)
 work_out[i] = intout[i];

for(i = 0;i &lt; 13;i++)
 work_out[45+i] = intout[i];
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=6>The<B> VDI </B>included with<B> TOS</B> versions less than 2.06 sometimes returned the same handle for consecutive calls using the same physical handle.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=6>Using multiple virtual workstations provides the benefit of being able to define multiple sets of default line types, text faces, etc... without having to constantly set them.The <B>VDI_Workstation</B> structure method is the recommended method of using this function. See the <B>VDI</B> entry for <B>V_Opnwk()</B> and <B>V_Opnvwk()</B>.Desk accessories running under <B>TOS</B> versions below 1.4 should not leave a workstation open across any call which might surrender control to <B>GEM</B> (<B>evnt_button()</B>, <B>evnt_multi()</B>, etc... ). This could give <B>GEM</B> time to change screen resolutions and <B>TOS</B> versions below 1.4 did not release memory allocated by a desk accessory (including workstations) when a resolution change occurred.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=6><B>v_opnwk(), vq_extend(), v_clsvwk(), V_Opnvwk()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vopnvwkcap><H3>V_Opnvwk()</H3>

<P>
<B>WORD V_Opnvwk( <I>dev</I> )</B>
<P>
<B>VDI_Workstation <I>dev</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>V_Opnvwk()</B> is not a component of the <B>VDI</B>, rather an interface binding designed to simplify working with virtual screen workstations. It will open a virtual screen workstation with a <B>VDI_Workstation</B> structure as a parameter rather than <I>work_in</I> and <I>work_out</I> arrays.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>N/A</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>User-defined.</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>ws</I> is a pointer to a <B>VDI_Workstation</B> structure defined as follows (for the meaning of each structure member, refer to<B> v_opnvwk()</B> ):
<PRE>
typedef struct
{
 WORD handle, dev_id;
 WORD wchar, hchar, wbox, hbox;
 WORD xres, yres;
 WORD noscale;
 WORD wpixel, hpixel;
 WORD cheights;
 WORD linetypes, linewidths;
 WORD markertypes, markersizes;
 WORD faces, patterns, hatches, colors;
 WORD ngdps;
 WORD cangdps[10];
 WORD gdpattr[10];
 WORD cancolor, cantextrot;
 WORD canfillarea, cancellarray;
 WORD palette;
 WORD locators, valuators;
 WORD choicedevs, stringdevs;
 WORD wstype;
 WORD minwchar, minhchar;
 WORD maxwchar, maxwchar;
 WORD minwline;
 WORD zero5;
 WORD maxwline;
 WORD zero7;
 WORD minwmark, minhmark;
 WORD maxwmark, maxhmark;
 WORD screentype;
 WORD bgcolors, textfx;
 WORD canscale;
 WORD planes, lut;
 WORD rops;
 WORD cancontourfill, textrot;
 WORD writemodes;
 WORD inputmodes;
 WORD textalign, inking, rubberbanding;
 WORD maxvertices, maxintin;
 WORD mousebuttons;
 WORD widestyles, widemodes;
 WORD reserved[38];
} VDI_Workstation;
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
WORD
V_Opnvwk( dev )
VDI_Workstation dev;
{
 WORD i, in[11];

 in[0] = Getrez() + 2;
 dev-&gt;dev_id = in[0];
 for(i = 1;i &lt; 10; in[i++] = 1);
 in[10] = 2;
 i = graf_handle( &amp;dev-&gt;wchar,
   &amp;dev-&gt;hchar, &amp;dev-&gt;wbox,
   &amp;dev-&gt;hbox );

<FONT SIZE=2> v_opnvwk( in, &amp;i, &amp;dev-&gt;xres );
</FONT> dev-&gt;handle = i;

<FONT SIZE=2> if(i)
</FONT>  vq_extnd( i, 1, &amp;dev-&gt;screentype );

<FONT SIZE=2> return (i);
</FONT>}
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>V_Opnvwk()</B> returns 0 if non-successful or the workstation handle otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This function definition is adapted from an article which appeared in the 'Atari .RSC' developers newsletter (Nov '90 - Jan '91).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_opnvwk(), V_Opnwk(), vq_extnd()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vopnwk><H3>v_opnwk()</H3>

<P>
<B>VOID v_opnwk( <I>work_in</I>, <I>handle</I>, <I>work_out</I>
)</B>
<P>
<B>WORD *<I>work_in</I>, *<I>handle</I>, *<I>work_out</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_opnwk()</B> opens a physical workstation.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>1</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available only with some form of <B>GDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD>All parmeters for this function are consistent with <B>v_opnvwk()</B> except as follows:On entry, <I>handle</I> does <U>not</U> need to contain any specific value. On return, however, it will contain a workstation handle if successful or 0 if the call failed.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
WORD i;

contrl[0] = 1;
contrl[1] = 0;
contrl[3] = 11;

for(i = 0;i &lt; 11;i++)
 intin[i] = work_in[i];

vdi();

*handle = contrl[6];

for(i = 0;i &lt; 45;i++)
 work_out[i] = intout[i];

for(i = 0;i &lt; 13;I++)
 work_out[45+i] = ptsout[i];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Physical workstations should be opened when needed and closed immediately afterwards. For example, a word processor should <I>not</I> open the printer workstation when the application starts and close it when it ends. If this is done, the user will be unable to change printers with the Printer Setup CPX(s).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>V_Opnwk(), v_opnvwk(), vq_extnd()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vopnwkcap><H3>V_Opnwk()</H3>

<P>
<B>WORD V_Opnwk( <I>devno</I>, <I>dev</I> )</B>
<P>
<B>WORD <I>devno</I>;<i> dev</i></B>
<P>
<B>VDI_Workstation <I>dev</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>V_Opnwk()</B> is not a component of the <B>VDI</B>, rather an interface binding designed to simplify working with <B>VDI</B> workstations. It will open a physical workstation using a <B>VDI_Workstation</B> structure rather than <I>work_in</I> and <I>work_out</I>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>N/A</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>User-defined.</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>devno</I> specifies the device ID of the device to open. Valid values for <I>devno</I> follow:   1-10   = Screen (loaded device drivers only)  11-20 = Plotters
<P>
  21-30 = Printers
<P>
  31-40 = Metafile Drivers
<P>
  41-50 = Camera Drivers
<P>
  51-60 = Tablet Drivers
<P>
  61-70 = Memory Drivers<I>ws</I> is a <B>VDI_Workstation</B> structure as defined in <B>V_Opnvwk()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
WORD
V_Opnvwk( devno, dev )
WORD devno;
VDI_Workstation dev;
{
 WORD i, in[11];

 in[0] = dev-&gt;dev_id = devno;
 for(i = 1;i &lt; 10; in[i++] = 1);
 in[10] = 2;
 i = devno;

<FONT SIZE=2> v_opnvwk( in, &amp;i, &amp;dev-&gt;xres );
</FONT> dev-&gt;handle = i;

<FONT SIZE=2> if(i)
</FONT>  vq_extnd( i, 1, &amp;dev-&gt;screentype );

<FONT SIZE=2> return (i);
</FONT>}
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>V_Opnwk()</B> returns a workstation handle if successful or 0 if the call failed.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This function definition is adapted from an article which appeared in the 'Atari .RSC' developers newsletter (Nov '90 - Jan '91).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_opnwk(), vq_extnd(), v_opnvwk(), V_Opnvwk()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=voutputwindow><H3>v_output_window()</H3>

<P>
<B>VOID v_output_window( <I>handle</I>, <I>pxy</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>WORD *<I>pxy</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_output_window()</B> outputs a specified portion of the current page.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>21</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all printer and metafile drivers under any type of <B>GDOS</B>. 
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>pxy</I> is a pointer to an array of four <B>WORD</B>s in <B>VDI</B> rectangle format which specifies the bounding extents of the current page to output.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = 2;
contrl[3] = 0;
contrl[5] = 21;
contrl[6] = handle;

ptsin[0] = pxy[0];
ptsin[1] = pxy[1];
ptsin[2] = pxy[2];
ptsin[3] = pxy[3];

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>Some printer drivers ignore the sides of the bounding box specified and print the entire width of the page.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call is similar to <B>v_updwk()</B> except that only a portion of the page is output.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_updwk()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vpgcount><H3>v_pgcount()</H3>

<P>
<B>VOID v_pgcount( <I>handle</I>, <I>numcopies</I>)</B>
<P>
<B>WORD <I>handle</I>, <I>numcopies</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_pgcount()</B> is used to cause the laser printer to output multiple copies of the current page.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>2000</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported only with some laser printer drivers (for instance the Atari laser printer driver) under some form of <B>GDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>numcopies</I> specifies the number of copies to print minus one. A value of 0 means print one copy, a value of 1, two copies, and so on.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = 0;
contrl[3] = 1;
contrl[5] = 2000;
contrl[6] = handle;

intin[0] = numcopies;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call is preferred over repeatedly calling <B>v_updwk()</B> and <B>v_form_adv()</B> as this method forces the printer data to be resent for each page.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vpieslice><H3>v_pieslice()</H3>

<P>
<B>VOID v_pieslice( <I>handle</I>, <I>x</I>, <I>y</I>, <I>radius</I>,
<I>startangle</I>, <I>endangle</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>x</I>, <I>y</I>, <I>radius</I>, <I>startangle</I>,
<I>endangle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_pieslice()</B> outputs a filled pie segment.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>11</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>3</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers. This function composes one of the 10 <B>VDI</B> GDP's (Generalized Drawing Primitives). Although all current drivers support all GDP's, their availability is not guaranteed and may vary. To check for a particular GDP refer to the table returned by <B>v_opnvwk()</B> or <B>v_opnwk()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>x</I> and <I>y</I> specify the center of a circlular segment of radius <I>radius</I> which is drawn between the angles of <I>startangle</I> and <I>endangle</I> (specified in tenths of degrees - legal values illustrated below) and connected to the center point.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 11;
contrl[1] = 4;
contrl[3] = 2;
contrl[5] = 3;
contrl[6] = handle;

ptsin[0] = x;
ptsin[1] = y;
ptsin[2] = ptsin[3] = ptsin[4] = ptsin[5] = 0
ptsin[6] = radius;

intin[0] = startangle;
intin[1] = endangle;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_ellpie(), vsf_color(), vsf_style(), vsf_interior(), vsf_udpat(), vsf_perimeter()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vpline><H3>v_pline()</H3>

<P>
<B>VOID v_pline( <I>handle</I>, <I>count</I>, <I>pxy</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>count</I>;</B>
<P>
<B>WORD *<I>pxy</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_pline()</B> outputs a polyline (group of one or more lines).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>6</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>count</I> specifies the number of vertices in the line path (2 to plot a single line). <I>pxy</I> points to a <B>WORD</B> array with <I>count</I> * 2 elements containing the vertices to plot as in (X1, Y1), (X2, Y2), etc...
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
WORD i;

contrl[0] = 6;
contrl[1] = count;
contrl[3] = 0;
contrl[6] = handle;

for(i = 0;i &lt; (count*2);i++)
 ptsin[i] = count[i];

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>To draw a single point with this function, <I>pxy[2]</I> should equal <I>pxy[0]</I>, <I>pxy[3]</I> should equal <I>pxy[1]</I>, and <I>count</I> should be 2.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_fillarea(), vsl_color(), vsl_type(), vsl_udsty(), vsl_ends()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vpmarker><H3>v_pmarker()</H3>

<P>
<B>VOID v_pmarker( <I>handle</I>, <I>count</I>, <I>pxy</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>count</I>;</B>
<P>
<B>WORD *<I>pxy</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_pmarker()</B> outputs one or several markers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>7</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation. <I>count</I> specifies the number of markers to plot. <I>pxy</I> points to a <B>WORD</B> array with (<I>count</I> * 2) elements containing the vertices of the markers to plot as in ( X1, Y1 ), ( X2, Y2 ), etc...
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
WORD i;

contrl[0] = 7;
contrl[1] = count;
contrl[3] = 0;
contrl[6] = handle;

for(i = 0;i &lt; (count * 2); i++)
 ptsin[i] = pxy[i];

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Single points may be plotted quickly with this function when the proper marker type is selected with <B>vsm_type()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vsm_type(), vsm_height(), vsm_color()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vrbox><H3>v_rbox()</H3>

<P>
<B>VOID v_rbox( <I>handle</I>, <I>pxy</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>WORD *<I>pxy</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_rbox()</B> outputs a rounded box (not filled).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>11</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>8</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers. This function composes one of the 10 <B>VDI</B> GDP's (Generalized Drawing Primitives). Although all current drivers support all GDP's, their availability is not guaranteed and may vary. To check for a particular GDP refer to the table returned by <B>v_opnvwk()</B> or <B>v_opnwk()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>pxy</I> points to an array of 4 <B>WORD</B>s containing the <B>VDI</B> format rectangle of the rounded box to output.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 11;
contrl[1] = 2;
contrl[3] = 0;
contrl[5] = 8;
contrl[6] = handle;

ptsin[0] = pxy[0];
ptsin[1] = pxy[1];
ptsin[2] = pxy[2];
ptsin[3] = pxy[3];

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>There is no way to define to size of the 'roundness' of the corners.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_rfbox(), v_bar(), vsl_type(), vsl_color(), vsl_udsty(), vsl_ends()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vrfbox><H3>v_rfbox()</H3>

<P>
<B>VOID v_rfbox( <I>handle</I>, <I>pxy</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>WORD *<I>pxy</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_rfbox()</B> outputs a filled rounded-rectangle.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>11</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>9</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers. This function composes one of the 10 <B>VDI</B> GDP's (Generalized Drawing Primitives). Although all current drivers support all GDP's, their availability is not guaranteed and may vary. To check for a particular GDP refer to the table returned by <B>v_opnvwk()</B> or <B>v_opnwk()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>pxy</I> points to an array of four <B>WORD</B>s which specify the <B>VDI</B> format rectangle of the rounded-rectangle to output.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 11;
contrl[1] = 2;
contrl[3] = 0;
contrl[5] = 9;
contrl[6] = handle;

ptsin[0] = pxy[0];
ptsin[1] = pxy[1];
ptsin[2] = pxy[2];
ptsin[3] = pxy[3];

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>There is no way to specify the 'roundness' of the rectangle.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_rbox(), v_bar(), vsf_color(), vsf_style(), vsf_interior(), vsf_udpat()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vrmcur><H3>v_rmcur()</H3>

<P>
<B>VOID v_rmcur( <I>handle</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_rmcur()</B> removes the last mouse cursor displayed.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>19</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all screen drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = contrl[3] = 0;
contrl[5] = 19;
contrl[6] = handle;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD><B>v_rmcur()</B> should only be used in conjunction with <B>v_dspcur()</B> when the mouse is moved manually. <B>graf_mouse()</B> or <B>v_hide_c()</B> should be used unless this is your intention.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_hide_c(), graf_mouse()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vrvoff><H3>v_rvoff()</H3>

<P>
<B>VOID v_rvoff( <I>handle</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_rvoff()</B> causes alpha screen text to be displayed in normal video (as opposed to inverse).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>14</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all screen drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = contrl[3] = 0;
contrl[5] = 14;
contrl[6] = handle;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call is equivalent to the esc-q VT-52 code.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_rvon(), v_curtext()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<a name=vrvon><H3>v_rvon()</H3>

<P>
<B>VOID v_rvon( <I>handle</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_rvon()</B> causes alpha screen text to be displayed in inverse mode.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>13</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all screen devices.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = contrl[3] = 0;
contrl[5] = 13;
contrl[6] = handle;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call is equivalent to the esc-p VT-52 code.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_rvoff(), v_curtext()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vsavecache><H3>v_savecache()</H3>

<P>
<B>WORD v_savecache( <I>handle</I>, <I>fname</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>char *<I>fname</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_savecache()</B> saves the current outline cache.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>249</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available only with <B>FSMGDOS </B>or <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>fname</I> specifies the <B>GEMDOS</B> file specification of the cache file to save.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
WORD i = 0;

while(intin[i++] = (WORD)*fname++);

contrl[0] = 249;
contrl[1] = 0;
contrl[3] = --i;
contrl[6] = handle;

vdi();

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>v_savecache() </B>returns 0 if successful or -1 if an error occurred.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call only saves the portion of the cache responsible for storing bitmaps created from outlines.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_loadcache(), v_flushcache()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vsetappbuff><H3>v_set_app_buff()</H3>

<P>
<B>VOID v_set_app_buff( <I>but</I>, <I>nparagraphs</I> )</B>
<P>
<B>VOID *<I>buf</I>;</B>
<P>
<B>WORD <I>nparagraphs</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_set_app_buff()</B> designates memory for use by the bezier generation routines.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>-1</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>6</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available only with <B>FONTGDOS</B>, <B>FSMGDOS </B>or <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>buf</I> specifies the address of a buffer which the bezier generator routines may safely use. <I>nparagraphs</I> specifies the size of the buffer in 'paragraphs' (16 bytes). 
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = -1;
contrl[1] = 0;
contrl[3] = 3;
contrl[5] = 6;

*(VOID *)&amp;intin[0] = buf;
intin[2] = nparagraphs;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Before the application exits, it should call <B>v_set_app_buff( NULL, 0 )</B> to 'unmark' memory. The application is then responsible for deallocating the memory.In the absence of this call the first <B>v_bez()</B> or <B>v_bezfill() </B>call will allocate its own buffer of 8K. Atari documentation recommends a size of about 9K depending on the extents of the bezier you wish to generate.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_bez()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vshowc><H3>v_show_c()</H3>

<P>
<B>VOID v_show_c( <I>handle</I>, <I>reset</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>reset</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>v_show_c()</B> 'unhides' the mouse cursor.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>122</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all screen drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. If <I>reset</I> is 0 the mouse will be displayed regardless of the number of times it was 'hidden'. Otherwise, the call will only display the cursor if the function has been called an equal number of times compared to <B>v_hide_c()</B>. 
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 122;
contrl[1] = 0;
contrl[3] = 1;
contrl[6] = handle;

intin[0] = reset;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>While it may be tempting to always use a <I>reset</I> value of 0, it is not recommended. Doing so may confuse the system so that when the critical error handler is called, the mouse is not displayed.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_hide_c(), graf_mouse()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vupdwk><H3>v_updwk()</H3>

<P>
<B>VOID v_updwk( <I>handle</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B><a name=vupdwk2>v_updwk()</B> outputs the current page to the specified device.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>4</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all printer, metafile, plotter, and camera devices when using any form of <B>GDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 4;
contrl[1] = contrl[3] = 0;
contrl[6] = handle;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call does not cause the 'page' to be ejected. You must use either <B>v_clrwk()</B> or <B>v_form_adv()</B> to accomplish that.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_clrwk(), v_form_adv()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vwritemeta><H3>v_write_meta()</H3>

<P>
<B>VOID v_write_meta( <I>handle</I>, <I>intin_len</I>, <I>intin</I>,
<I>ptsin_len</I>, <I>ptsin</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>intin_len</I>;</B>
<P>
<B>WORD *<I>intin</I>;</B>
<P>
<B>WORD <I>ptsin_len</I>;</B>
<P>
<B>WORD *<I>ptsin</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=4><B>v_write_meta()</B> writes a customized metafile sub-opcode.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=4>5</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD COLSPAN=4>99</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=4>Supported by all metafile drivers.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=4><I>handle</I> specifies a valid workstation handle. <I>intin</I> points to an array of <B>WORD</B>s with <I>intin_len</I> (0-127) elements. <I>ptsin</I> points to an array of <B>WORD</B>s with <I>ptsin_len</I> (0-127) elements. <I>ptsin</I> is not required to be of any length, however, <I>intin</I> should be at least one word long to specify the sub-opcode in <I>intin[0]</I>. Sub-opcodes 0-100 are reserved for use by Atari. Several pre-defined sub-opcodes in this range already exist as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B><FONT SIZE=1 >Sub-Opcode:</FONT></B>
<CENTER>
<B><FONT SIZE=2 >intin[0]</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
10
</CENTER>
</TD><TD><FONT SIZE=2>Start group.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
11
</CENTER>
</TD><TD><FONT SIZE=2>End group.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
49
</CENTER>
</TD><TD><FONT SIZE=2>Set no line style.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
50
</CENTER>
</TD><TD><FONT SIZE=2>Set attribute shadow on.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
51
</CENTER>
</TD><TD><FONT SIZE=2>Set attribute shadow off.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
80
</CENTER>
</TD><TD><FONT SIZE=2>Start draw area type primitive.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
81
</CENTER>
</TD><TD><FONT SIZE=2>End draw area type primitive.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=4>
<PRE>
WORD i;

contrl[0] = 5;
contrl[1] = ptsin_len;
contrl[3] = intin_len;
contrl[5] = 99;
contrl[6] = handle;

for(i = 0;i &lt; intin_len; i++)
 intin[i] = m_intin[i];
for(i = 0;i &lt; ptsin_len; i++)
 ptsin[i] = m_ptsin[i];

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=4>Metafile readers should ignore and safely skip any opcodes not understood.
</TD></TR>

</TABLE>

<P>

<HR>

<H3>vex_butv()</H3>

<P>
<B>VOID vex_butv( <I>handle</I>, <I>butv</I>, <I>old_butv</I>
)</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>WORD (*<I>butv</I>)( (WORD) <I>bstate</I> );</B>
<P>
<B>WORD (**<I>old_butv</I>)( (WORD) <I>bstate</I> );</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vex_butv()</B> installs a routine which is called by the <B>VDI</B> every time a mouse button is pressed.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>125</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all screen drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid physical workstation handle. <I>butv</I> points to a user-defined button-click handler routine. The address pointed to by <I>old_butv</I> will be filled in with the address of the old button-click handler. 
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 125;
contrl[1] = contrl[3] = 0;
contrl[6] = handle;
contrl[7] = (WORD)((LONG)butv &gt;&gt; 16);
contrl[8] = (WORD)((LONG)butv);

vdi();

<FONT SIZE=2>*(LONG *)old_butv = (LONG)(((LONG)contrl[9] &lt;&lt; 16) | (LONG)contrl[10]); </FONT>
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Upon entry to <I>butv</I>, the mouse status is contained in 68x00 register D0 (in the same format as the button return value in <B>vq_mouse()</B> ). A 'C' handler should, therefore, be sure to specify register calling parameters for this function. Any registers which will be modifed should be saved and restored upon function exit. The routine may call the <B>BIOS</B> and/or <B>XBIOS</B> sparingly but should not call the <B>AES</B>, <B>VDI</B>, or <B>GEMDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vex_curv(), vex_motv()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>vex_curv()</H3>

<P>
<B>VOID vex_curv( <I>handle</I>, <I>curv</I>, <I>old_curv</I>
)</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>WORD (*<I>curv</I>)( (WORD) <I>mx</I>, (WORD) <I>my</I> );</B>
<P>
<B>WORD (**<I>old_curv</I>)( (WORD) <I>mx</I>, (WORD) <I>my</I>
);</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vex_curv()</B> installs a routine which is called every time the mouse cursor is drawn allowing a customized mouse rendering routine to replace that of the system.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>127</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all screen devices.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid physical workstation handle. <I>curv</I> points to a user defined function which will be called every time the mouse is to be refreshed. <I>old_curv</I> is the address of a pointer to the old rendering routine which will be filled in by the function on exit.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 127;
contrl[1] = contrl[3] = 0;
contrl[6] = handle;
contrl[7] = (WORD)((LONG)curv &gt;&gt; 16);
contrl[8] = (WORD)((LONG)curv);

vdi();

<FONT SIZE=2>*(LONG *)old_curv = (LONG)(((LONG)contrl[9] &lt;&lt; 16) | (LONG)contrl[10]); </FONT>
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Upon entry to <I>curv</I>, the mouse's X and Y location on screen is contained in 68x00 registers D0 and D1 respectively. A 'C' handler should, therefore, be sure to specify register calling parameters for this function. Any registers which will be modifed should be saved and restored upon function exit. The routine may call the <B>BIOS</B> and/or <B>XBIOS</B> sparingly but should not call the <B>AES</B>, <B>VDI</B>, or <B>GEMDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vex_butv(), vex_motv()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>vex_motv()</H3>

<P>
<B>VOID vex_motv( <I>handle</I>, <I>motv</I>, <I>old_motv</I>
)</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>WORD (*<I>motv</I>)( (WORD) <I>mx</I>, (WORD) <I>my</I> );</B>
<P>
<B>WORD (**<I>old_motv</I>)( (WORD) <I>mx</I>, (WORD) <I>my</I>
);</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vex_motv()</B> installs a user routine which is called every time the mouse pointer is moved.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>126</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all screen drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid physical workstation handle. <I>motv</I> points to a user-defined routine which is called every time the mouse is moved. <I>old_motv</I> is an address to a pointer which will be filled in containing the address of the old function.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 126;
contrl[1] = contrl[3] = 0;
contrl[6] = handle;
contrl[7] = (WORD)((LONG)motv &gt;&gt; 16);
contrl[8] = (WORD)((LONG)motv);

vdi();

<FONT SIZE=2>*(LONG *)old_motv = (LONG)(((LONG)contrl[9] &lt;&lt; 16) | (LONG)contrl[10]); </FONT>
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Upon entry to <I>motv</I>, the mouse's new X and Y location is contained in 68x00 registers D0 and D1 respectively. A 'C' handler should, therefore, be sure to specify register calling parameters for this function. Any registers which will be modifed should be saved and restored upon function exit. The routine may call the <B>BIOS</B> and/or <B>XBIOS</B> sparingly but should not call the <B>AES</B>, <B>VDI</B>, or <B>GEMDOS</B>. The routine may modify the contents of D0 and D1 as necessary to affect the movement of the mouse (one way of implementing a mouse accelerator).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vex_curv(), vex_butv()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>vex_timv()</H3>

<P>
<B>VOID vex_timv( <I>handle</I>, <I>timv</I>, <I>old_timv</I>,
<I>mpt</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>VOID (*<I>timv</I>)( VOID );</B>
<P>
<B>VOID (**<I>old_timv</I>)( VOID );</B>
<P>
<B>WORD *<I>mpt</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vex_timv()</B> installs a user-defined routine that will be called at each timer tick (currently once every 50 milliseconds).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>118</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all screen drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid physical workstation handle. <I>timv</I> should point to a user-defined timer tick routine. <I>old_timv</I> is an address to a pointer which will be filled in with the old timer tick routine. <I>mpt</I> is a pointer to a <B>WORD</B> which will be filled in with the value representing the current number of milliseconds per timer tick.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 118;
contrl[1] = contrl[3] = 0;
contrl[6] = handle;
contrl[7] = (WORD)((LONG)timv &gt;&gt; 16);
contrl[8] = (WORD)((LONG)timv);

vdi();
*mpt = inout[0]

<FONT SIZE=2>*(LONG *)old_timv = (LONG)(((LONG)contrl[9] &lt;&lt; 16) | (LONG)contrl[10]); </FONT>
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Any registers which will be modifed should be saved and restored upon function exit. The routine may call the <B>BIOS</B> and/or <B>XBIOS</B> sparingly but should not call the <B>AES</B>, <B>VDI</B>, or <B>GEMDOS</B>. The routine should fall through to the old routine. As this vector is jumped through quite often, the routine should be very simple to avoid system performance slowdowns.
</TD></TR>

</TABLE>

<P>

<HR>

<H3>vm_coords()</H3>

<P>
<B>VOID vm_coords( <I>handle</I>, <I>xmin</I>, <I>ymin</I>, <I>xmax</I>,
<I>ymax</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>xmin</I>, <I>ymin</I>, <I>xmax</I>,
<I>ymax</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vm_coords()</B> allows the use of variable coordinate systems with metafiles.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcodes</B></TH><TD>99, 1</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all metafile drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>xmin</I> and <I>ymin</I> specify the coordinate pair which provides an anchor for the upper-left point of the coordinate system. <I>xmax</I> and <I>ymax</I> specify the coordinate pair which provides an anchor for the lower-right point of the coordinate system.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = 0;
contrl[3] = 5;
contrl[5] = 99;
contrl[6] = handle;

intin[0] = 1;
intin[1] = xmin;
intin[2] = ymin;
intin[3] = xmax;
intin[4] = ymax;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Use of this function allows the use of practically any coordinate system with a limit of ( -32768, -32768 ), (&nbsp;32767,&nbsp;32767&nbsp;).Metafiles default to a coordinate space of (&nbsp;0,&nbsp;32767&nbsp;), (&nbsp;32767,&nbsp;0&nbsp;).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vm_pagesize(), v_meta_extents()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>vm_filename()</H3>

<P>
<B>VOID vm_filename( <I>handle</I>, <I>fname</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>char *<I>fname</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vm_filename()</B> allows specfying a user-defined filename for metafile output.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>100</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all metafile drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifys a valid workstation handle. <I>fname</I> points to a <B>NULL</B>-terminated <B>GEMDOS</B> filename which all metafile output should be redirected to.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
WORD i = 0;

while(intin[i++] = (WORD)*fname++);

contrl[0] = 5;
contrl[1] = 0;
contrl[3] = --i;
contrl[5] = 100;
contrl[6] = handle;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>When a metafile is opened, the default file 'GEMFILE.GEM' is created in the current <B>GEMDOS</B> path on the current drive and is not deleted as a result of this call. You will need to manually delete it yourself.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call should be made immediately after a <a name=vopnwk2><B>v_opnwk()</B> to a metafile handle if you wish to use an alternate filename to prevent data from being lost.
</TD></TR>

</TABLE>

<P>

<HR>

<H3>vm_pagesize()</H3>

<P>
<B>VOID vm_pagesize( <I>handle</I>, <I>pwidth</I>, <I>pheight</I>
)</B>
<P>
<B>WORD <I>handle</I>, <I>pwidth</I>, <I>pheight</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vm_pagesize()</B> specifys a metafile's source page size.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcodes</B></TH><TD>99, 0</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all metafile drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>pwidth</I> specifies the width of the page which the metafile was originally placed on in tenths of a millimeter. <I>pheight</I> specifies the height of the page which the metafile was originally placed on in tenths of a millimeter.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = 0;
contrl[3] = 3;
contrl[5] = 99;
contrl[6] = handle;

intin[0] = 0;
intin[1] = pwidth;
intin[2] = pheight;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>A metafile originally designed on an 8.5" x 11" page would have a <I>pwidth</I> value of 2159 and a <I>pheight</I> value of 2794.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_meta_extents()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vqcellarray><H3>vq_cellarray()</H3>

<P>
<B>VOID vq_cellarray( <I>handle</I>, <I>pxy</I>, <I>rowlen</I>,
<I>num_rows</I>, <I>elements</I>, <I>rows_used</I>, <I>status</I>,
<I>colarray</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>WORD *<I>pxy</I>;</B>
<P>
<B>WORD <I>rowlen, num_rows</I>;</B>
<P>
<B>WORD *<I>elements</I>, *<I>rows_used</I>, *<I>status</I>, *<I>colarray</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vq_cellarray()</B> returns the cell array definitions of specified pixels.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>27</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Not supported by any known drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>pxy</I> points to an array of 4 <B>WORD</B>s which specify a <B>VDI</B> format rectangle. <I>row_length</I> specifies the length of each row in the color array. <I>num_rows</I> specifies the number of total rows in the color array.Upon return, the <B>WORD</B> pointed to by <I>elements</I> will indicate the number of array elements used per row. In addition, <I>rows_used</I> will be filled in with actual number of rows used by the color array and the <B>WORD</B> pointed to by <I>status</I> will be filled in with 0 if the operation was successful or 1 if at least one element could not be determined. Finally, the <B>WORD</B> array (with (<I>num_rows</I>&nbsp;*&nbsp;<I>row_length</I>) elements) pointed to by <I>colarray</I> will be filled in with the color index array stored one row at a time. On return <I>colarray</I> will actually contain (<I>elements</I>&nbsp;*&nbsp;<I>rows_used</I>) valid elements.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
WORD i;

contrl[0] = 27;
contrl[1] = 2;
contrl[3] = 0;
contrl[6] = handle;
contrl[7] = row_length;
contrl[8] = num_rows;

ptsin[0] = pxy[0];
ptsin[1] = pxy[1];
ptsin[2] = pxy[2];
ptsin[3] = pxy[3];

vdi();

*el_used = contrl[9];
*rows_used = contrl[10];
*status = contrl[11];

for(i = 0;i &lt; contrl[4];i++)
 colarray[i] = intout[i];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>No driver types are required to utilize this function. It is therefore recommended that it be avoided unless your application is aware of the capabilities of the driver.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_cellarray()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vqchcells><H3>vq_chcells()</H3>

<P>
<B>VOID vq_chcells( <I>handle</I>, <I>rows</I>, <I>columns</I>
)</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>WORD *<I>rows</I>, *<I>columns</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vq_chcells()</B> returns the current number of columns and rows on the alpha text mode of the device.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>1</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all screen and printer drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>rows</I> and <I>columns</I> each point to a <B>WORD</B> which will be filled in with the current number of rows and columns of the device (in text mode).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = contrl[3] = 0;
contrl[5] = 1;
contrl[6] = handle;

vdi();

*rows = intout[0];
*columns = intout[1];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_curtext()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>vq_color()</H3>

<P>
<B>WORD vq_color( <I>handle</I>, <I>index</I>, <I>flag</I>, <I>rgb</I>)</B>
<P>
<B>WORD <I>handle</I>, <I>index</I>, <I>flag</I>;</B>
<P>
<B>WORD *<I>rgb</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>vq_color()</B> returns RGB information for a particular <B>VDI</B> color index.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>26</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>handle</I> specifies a valid workstation handle. <I>index</I> specifies the <B>VDI</B> color index of which you wish to inquire. <I>rgb</I> points to an array of 3 <B>WORD</B>s which will be filled in with the red, green, and blue values (0-1000) of the color index. The values returned in the RGB array are affected by the value of <I>flag</I> as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >flag</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Values returned in <I><B>rgb</B></I></FONT></B>
</TD></TR>

<TR><TH></TH><TD><B>COLOR_REQUESTED</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Return the values as last requested by the user (ie: not mapped to the actual color value displayed).</FONT>
</TD></TR>

<TR><TH></TH><TD><B>COLOR_ACTUAL</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Return the values as the actual color being displayed.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
contrl[0] = 26;
contrl[1] = 0;
contrl[3] = 2;
contrl[6] = handle;

intin[0] = index;
intin[1] = flag;

vdi();

rgb[0] = intout[1];
rgb[1] = intout[2];
rgb[2] = intout[3];

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3><B>vq_color()</B> returns -1 if the specified index is out of range for the device.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=3>Some drivers for color printers do not allow you to modify the color of each register. A simple test will allow you to determine if the driver will allow you to change index colors as follows: Call <B>vq_color()</B> with a <I>flag</I> value of 0 and save the return.
<P>
 Call <B>vs_color()</B> to modify that color index by a signifigant value.
<P>
 Call <B>vq_color()</B> with a <I>flag</I> value of 0 and compare with what you set.
<P>
 Restore the old value.
<P>
 If equivalent values are returned, you may modify each color index.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>vs_color()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<a name=vqcuraddress><H3>vq_curaddress()</H3>

<P>
<B>VOID vq_curaddress( <I>handle</I>, <I>row</I>, <I>column</I>
)</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>WORD *<I>row</I>, *<I>column</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vq_curaddress()</B> returns the current position of the alpha text cursor.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>15</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all screen drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. The <B>WORD</B>s pointed to by <I>row</I> and <I>column</I> will be filled in with the current row and column respectively of the text cursor in alpha mode.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = contrl[3] = 0;
contrl[5] = 15;
contrl[6] = handle;

vdi();

*row = intout[0];
*column = intout[1];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_curtext(), vq_chcells()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vqextnd><H3>vq_extnd()</H3>

<P>
<B>VOID vq_extnd( <I>handle</I>, <I>mode</I>, <I>work_out</I>
)</B>
<P>
<B>WORD <I>handle</I>, <I>mode</I>;</B>
<P>
<B>WORD *<I>work_out</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>vq_extnd()</B> returns extra information about a particular workstation.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>102</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>handle</I> specifies a valid workstation handle. If <I>mode</I> is set to 0 then this call fills in the array pointed to by <I>work_out</I> with the same 57 <B>WORD</B>s which are returned by either <B>v_opnwk()</B> or <B>v_opnvwk()</B>. If <I>mode</I> is 1 then the 57 <B>WORD</B>s of <I>work_out</I> are filled in with other information as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD>
<CENTER>
<I><B><FONT SIZE=1 >work_out[x]</FONT></B></I>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >VDI Structure</FONT></B>
</CENTER>

<P>

<CENTER>
<B><FONT SIZE=2 >Member</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD>
<CENTER>
0
</CENTER>
</TD><TD>
<CENTER>
<I><FONT SIZE=2>screentype</FONT></I>
</CENTER>

</TD><TD><FONT SIZE=2>Type of display screen:</FONT>0 = Not screen.<FONT SIZE=2>1 = Separate alpha/ graphic controllers and displays.</FONT>
<P>
<FONT SIZE=2>2 = Separate alpha/ graphic controllers with common screen.</FONT>
<P>
<FONT SIZE=2>3 = Common alpha/ graphic controllers with separate image memory.</FONT>
<P>
<FONT SIZE=2>4 = Common alpha/ graphic controllers and image memory.</FONT>(All known devices either return 0 or 4.)
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
1
</CENTER>
</TD><TD>
<CENTER>
<I><FONT SIZE=2>bgcolors</FONT></I>
</CENTER>

</TD><TD><FONT SIZE=2>Number of background colors available.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
2
</CENTER>
</TD><TD>
<CENTER>
<I><FONT SIZE=2>textfx</FONT></I>
</CENTER>

</TD><TD><FONT SIZE=2>Text effects supported. (Same bitmask as with <B>vst_effects()</B> ).</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
3
</CENTER>
</TD><TD>
<CENTER>
<I><FONT SIZE=2>canscale</FONT></I>
</CENTER>

</TD><TD><FONT SIZE=2>Scaling of rasters:</FONT>0 = Can't scale.
<P>
<FONT SIZE=2>1 = Can scale.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
4
</CENTER>
</TD><TD>
<CENTER>
<I><FONT SIZE=2>planes</FONT></I>
</CENTER>

</TD><TD><FONT SIZE=2>Number of planes.</FONT></TD></TR>

<TR><TH></TH><TD>
<CENTER>
5
</CENTER>
</TD><TD>
<CENTER>
<I><FONT SIZE=2>lut</FONT></I>
</CENTER>

</TD><TD><FONT SIZE=2>Lookup table supported:</FONT>0 = Table not supported.
<P>
<FONT SIZE=2>1 = Table supported.</FONT>(True color modes return a value of 0 for <I>lut</I> and &gt;2 for <I>colors</I> in <B>v_opnvwk()</B>).<FONT SIZE=2>See the caveat listed below.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
6
</CENTER>
</TD><TD>
<CENTER>
<I><FONT SIZE=2>rops</FONT></I>
</CENTER>

</TD><TD><FONT SIZE=2>Performance factor. Number of 16x16 raster operations per second.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
7
</CENTER>
</TD><TD>
<CENTER>
<I><FONT SIZE=2>cancontourfill</FONT></I>
</CENTER>

</TD><TD><B><FONT SIZE=2>v_contourfill()</FONT></B> availability:<FONT SIZE=2>0 = Not available.</FONT>
<P>
<FONT SIZE=2>1 = Available.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
8
</CENTER>
</TD><TD>
<CENTER>
<I><FONT SIZE=2>textrot</FONT></I>
</CENTER>

</TD><TD><FONT SIZE=2>Character rotation capability:</FONT>0 = None.
<P>
<FONT SIZE=2>1 = 90 degree increments.</FONT>
<P>
<FONT SIZE=2>2 = Any angle of rotation.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
9
</CENTER>
</TD><TD>
<CENTER>
<I><FONT SIZE=2>writemodes</FONT></I>
</CENTER>

</TD><TD><FONT SIZE=2>Number of writing modes available.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
10
</CENTER>
</TD><TD>
<CENTER>
<I><FONT SIZE=2>inputmodes</FONT></I>
</CENTER>

</TD><TD><FONT SIZE=2>Highest level of input modes available:</FONT>0 = None.
<P>
<FONT SIZE=2>1 = Request.</FONT>
<P>
<FONT SIZE=2>2 = Sample.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
11
</CENTER>
</TD><TD>
<CENTER>
<I><FONT SIZE=2>textalign</FONT></I>
</CENTER>

</TD><TD><FONT SIZE=2>Text alignment capability flag:</FONT>0 = Not available.
<P>
<FONT SIZE=2>1 = Available.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
12
</CENTER>
</TD><TD>
<CENTER>
<I><FONT SIZE=2>inking</FONT></I>
</CENTER>

</TD><TD><FONT SIZE=2>Inking capability flag.</FONT>0 = Device can't ink.
<P>
<FONT SIZE=2>1 = Device can ink.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
13
</CENTER>
</TD><TD>
<CENTER>
<I><FONT SIZE=2>rubberbanding</FONT></I>
</CENTER>

</TD><TD><FONT SIZE=2>Rubberbanding capability flag:</FONT>0 = No rubberbanding.
<P>
<FONT SIZE=2>1 = Rubberbanded lines.</FONT>
<P>
<FONT SIZE=2>2 = Rubberbanded lines and rectangles.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
14
</CENTER>
</TD><TD>
<CENTER>
<I><FONT SIZE=2>maxvertices</FONT></I>
</CENTER>

</TD><TD><FONT SIZE=2>Maximum vertices for polyline, polymarker, or filled area (-1 = no maximum).</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
15
</CENTER>
</TD><TD>
<CENTER>
<I><FONT SIZE=2>maxintin</FONT></I>
</CENTER>

</TD><TD><FONT SIZE=2>Maximum length of intin array (1 = no maximum).</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
16
</CENTER>
</TD><TD>
<CENTER>
<I><FONT SIZE=2>mousebuttons</FONT></I>
</CENTER>

</TD><TD><FONT SIZE=2>Number of mouse buttons.</FONT></TD></TR>

<TR><TH></TH><TD>
<CENTER>
17
</CENTER>
</TD><TD>
<CENTER>
<I><FONT SIZE=2>widestyles</FONT></I>
</CENTER>

</TD><TD><FONT SIZE=2>Styles available for wide lines?</FONT>0 = No
<P>
<FONT SIZE=2>1 = Yes</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
18
</CENTER>
</TD><TD>
<CENTER>
<I><FONT SIZE=2>widemodes</FONT></I>
</CENTER>

</TD><TD><FONT SIZE=2>Writing modes available for wide lines?</FONT>0 = No
<P>
<FONT SIZE=2>1 = Yes</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
19-56
</CENTER>
</TD><TD>
<CENTER>
<I><FONT SIZE=2>reserved1</FONT></I>
</CENTER>

</TD><TD><FONT SIZE=2>Reserved for future use.</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
WORD i;

contrl[0] = 102;
contrl[1] = 0;
contrl[3] = 1;
contrl[6] = handle;

intin[0] = mode;

vdi();

for(i = 0;i &lt; 45;i++)
 work_out[i] = intout[i];

for(i = 0;i &lt; 13;i++)
 work_out[45+i] = ptsout[i]; 
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=3>See the entry for <B>V_Opnwk()</B> and <B>V_Opnvwk()</B> to see how the <B>vq_extnd()</B> information and <B>v_opn/v/wk()</B> calls are integrated into a 'C' style structure.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=3>The <I>lut</I> member of the <B>VDIWORK</B> structure was originally misdocumented by Atari with the values reversed. The Falcon030 as well as some third-party true-color boards return the correct values. Some older boards may not, however.One alternative method of determining if the current screen is not using a software color lookup table (i.e. true color) is to compare the value for 2 ^ <I>planes</I> with the number of colors in the palette found in <I>colors</I>. If this number is different, the <B>VDI</B> is not using a software color lookup table.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>v_opnwk(), v_opnvwk(), V_Opnwk(), V_Opnvwk()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vqgdos><H3>vq_gdos()</H3>

<P>
<B>ULONG vq_gdos( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>vq_gdos()</B> determines the availability and type of <B>GDOS</B> present. 
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>N/A</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>Supported in ROM by all Atari computers.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
; Correct binding for vq_gdos. Some compilers
; use the name vq_vgdos for the new version
; and vq_gdos for the old version which
; looked like:
;    move.w  #-2,d0
;    trap   #2
;    cmp.w  #-2,d0
;    sne   d0
;    ext.w  d0 

_vq_gdos:

move.w   #-2,d0
trap   #2
rts
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3>Currently one of the following values are returned:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Value</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >GDOS Type</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>GDOS_NONE</B></TD><TD>
<CENTER>
<FONT SIZE=2>-2</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2>GDOS</FONT></B> not installed.</TD></TR>

<TR><TH></TH><TD>
<CENTER>
-
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>Any other value.</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2>GDOS</FONT></B> 1.0, 1.1, or 1.2 installed.
</TD></TR>

<TR><TH></TH><TD><B>GDOS_FNT</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x5F464E54 ('<B>_FNT</B>')</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2>FONTGDOS</FONT></B> installed.</TD></TR>

<TR><TH></TH><TD><B>GDOS_FSM</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x5F46534D ('_<B>FSM</B>')</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2>FSMGDOS</FONT></B> installed.</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=3>Calling a <B>GDOS</B> function without <B>GDOS</B> loaded is fatal and will cause a system crash.To determine whether <B>FSMGDOS </B>or <B>SpeedoGDOS</B> is loaded look for the '<B>FSMC</B>' cookie in the cookie jar. The cookie value points to a longword which will contain either '<B>_FSM</B>' or '<B>_SPD</B>'.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vqkeys><H3>vq_key_s()</H3>

<P>
<B>VOID vq_key_s( <I>handle</I>, <I>status</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>WORD *<I>status</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>vq_key_s()</B> returns the current shift-key status.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>128</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>Supported by all Atari computers.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=5><I>handle</I> specifies a valid workstation handle. <I>status</I> points to a <B>WORD</B> which is filled in on function exit with a bit mask containing the current shift key status as follows: 
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bit</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD><B>K_RSHIFT</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Right shift key depressed</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>K_LSHIFT</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Left shift key depressed</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>K_CTRL</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Control key depressed</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>K_ALT</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Alternate key depressed</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
contrl[0] = 128;
contrl[1] = contrl[3] = 0;
contrl[6] = handle;

vdi();

*status = intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=5><B>graf_mkstate()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vqmouse><H3>vq_mouse()</H3>

<P>
<B>VOID vq_mouse( <I>handle</I>, <I>mb</I>, <I>mx</I>, <I>my</I>
)</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>WORD *<I>mb</I>, *<I>mx</I>, *<I>my</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=4><B>vq_mouse()</B> returns information regarding the current state of the mouse.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=4>124</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=4>Supported by all screen drivers.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=4><I>handle</I> specifies a valid workstation handle. <I>mb</I> points to a <B>WORD</B> which will be filled in upon function exit with a bit mask indicating the current status of the mouse buttons as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B><FONT SIZE=1 >Name</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Mask</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>LEFT_BUTTON</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x01</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Left mouse button</FONT></TD></TR>

<TR><TH></TH><TD><B>RIGHT_BUTTON</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x02</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Right mouse button</FONT></TD></TR>

<TR><TH></TH><TD><B>MIDDLE_BUTTON</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x04</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Middle button (this button would be the first button to the left of the rightmost button on the device).</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
-
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>0x08</FONT>
</CENTER>

<P>

<CENTER>
<FONT SIZE=2>.</FONT>
</CENTER>

<P>

<CENTER>
<FONT SIZE=2>.</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Other buttons (0x08 is the mask for the button to the immediate left of the middle button. Masks continue leftwards).</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH></TH><TD COLSPAN=4><I>mx</I> and <I>my</I> both point to <B>WORD</B>s which will be filled in upon function exit with the current position of the mouse pointer.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=4>
<PRE>
contrl[0] = 124;
contrl[1] = contrl[3] = 0;
contrl[6] = handle;

vdi();

*mb = intout[0];
*mx = ptsout[0];
*my = ptsout[1];
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=4><B>graf_mkstate(), v_key_s()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>vq_scan()</H3>

<P>
<B>VOID vq_scan( <I>handle</I>, <I>grh</I>, <I>passes</I>, <I>alh</I>,
<I>apage</I>, <I>div</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>WORD *<I>grh</I>, *<I>passes</I>, *<I>alh</I>, *apage, *<I>div</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vq_scan()</B> returns information regarding printer banding.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>24</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all printer drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>passes</I> specifies the number of graphic passes per printer page. The value obtained through the formula <I>grh</I>/<I>div</I> specifies the number of graphics scan lines per pass. The value obtained by the formula <I>alh</I>/<I>div</I> specifies the number of graphic scan lines per alpha text line. <I>apage</I> specifies the number of alpha lines per page.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = contrl[3] = 0;
contrl[5] = 24;
contrl[6] = handle;

vdi();

*grh = intout[0];
*passes = intout[1];
*alh = intout[2];
*apage = intout[3];
*div = intout[4];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call has been previously mis-documented.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vqtabstatus><H3>vq_tabstatus()</H3>

<P>
<B>WORD vq_tabstatus( <I>handle</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vq_tabstatus()</B> determines the availability of a tablet device.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>16</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all screen drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = contrl[3] = 0;
contrl[5] = 16;
contrl[6] = handle;

vdi();

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>vq_tabstatus()</B> returns 0 if no tablet is available or 1 if a tablet device is present.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vq_tdimensions(), vt_origin(), vt_axis(), vt_resolution(), vt_alignment()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vqtdimensions><H3>vq_tdimensions()</H3>

<P>
<B>VOID vq_tdimensions( <I>handle</I>, <I>xdim</I>, <I>ydim</I>
)</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>WORD *<I>xdim</I>, *<I>ydim</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vq_tdimensions()</B> returns the scanning dimensions of the attached graphics tablet.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>84</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all tablet drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>xdim</I> and <I>ydim</I> point to <B>WORD</B>s which upon function exit will contain the X and Y dimensions of the tablet scanning area specified in tenths of an inch.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = contrl[3] = 0;
contrl[5] = 84;
contrl[6] = handle;

vdi();

*xdim = intout[0];
*ydim = intout[1];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vq_tabstatus()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vqattributes><H3>vqf_attributes()</H3>

<P>
<B>VOID vqf_attributes( <I>handle</I>, <I>attr</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>WORD *<I>attr</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=4><B>vqf_attributes()</B> returns information regarding the current fill attributes.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=4>37</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=4>Supported by all devices.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=4><I>handle</I> specifies a valid workstation handle. <I>attr</I> points to an array of five <B>WORD</B>s which upon exit will be filled in as follows: 
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
<I><B><FONT SIZE=1 >attr[x]</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0
</CENTER>
</TD><TD><FONT SIZE=2>Current fill area interior type (see <B>vsf_interior()</B> ).</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
1
</CENTER>
</TD><TD><FONT SIZE=2>Current fill area color (see <B>vsf_color()</B> ).</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
2
</CENTER>
</TD><TD><FONT SIZE=2>Current fill area style (see <B>vsf_style()</B> ).</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
3
</CENTER>
</TD><TD><FONT SIZE=2>Current writing mode (see <B>vswr_mode()</B> ).</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
4
</CENTER>
</TD><TD><FONT SIZE=2>Current perimeter status (see <B>vsf_perimeter()</B> ).</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=4>
<PRE>
contrl[0] = 37;
contrl[1] = contrl[3] = 0;
contrl[6] = handle;

vdi();

attr[0] = intout[0];
attr[1] = intout[1];
attr[2] = intout[2];
attr[3] = intout[3];
attr[4] = intout[4];
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=4><B>vqt_attributes(), vql_attributes(), vqm_attributes()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vqinmode><H3>vqin_mode()</H3>

<P>
<B>VOID vqin_mode( <I>handle</I>, <I>dev</I>, <I>mode</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>dev</I>;</B>
<P>
<B>WORD *<I>mode</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>vqin_mode()</B> returns the input status of the specified <B>VDI</B> device.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>115</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>Supported by all Atari computers.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=5><I>handle</I> specifies a valid workstation handle. <I>mode</I> points to a <B>WORD</B> which upon exit will be filled in with 1 if the specified device is in request mode or 2 if in sample mode. <I>dev</I> specifies the device to inquire as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >dev</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Device</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD><B>LOCATOR</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Locator (Mouse, Mouse Buttons, and Keyboard)</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>VALUATOR</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Valuator (not currently defined)</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>CHOICE</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Choice (not currently defined)</FONT></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD><B>STRING</B></TD><TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>String (Keyboard)</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
contrl[0] = 115;
contrl[1] = 0
contrl[3] = 1;
contrl[6] = handle;

intin[0] = dev;

vdi();

*mode = intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=5><B>vsin_mode()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<a name=vqlattributes><H3>vql_attributes()</H3>

<P>
<B>VOID vql_attributes( <I>handle</I>, <I>attr</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>WORD *<I>attr</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=4><B>vql_attributes()</B> returns information regarding current settings which affects line drawing functions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=4>35</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=4>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=4><I>handle</I> specifies a valid workstation handle. <I>attr</I> is an array of 6 <B>WORD</B>s which describe the current parameters for line drawing as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
<I><B><FONT SIZE=1 >attr[x]</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0
</CENTER>
</TD><TD><FONT SIZE=2>Line type (see <B>vsl_type()</B> ).</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
1
</CENTER>
</TD><TD><FONT SIZE=2>Line color (see<B> vsl_color()</B> ).</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
2
</CENTER>
</TD><TD><FONT SIZE=2>Writing mode (see <B>vswr_mode()</B> ).</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
3
</CENTER>
</TD><TD><FONT SIZE=2>End style for start of lines (see <B>vsl_ends()</B> ).</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
4
</CENTER>
</TD><TD><FONT SIZE=2>End style for end of lines (see <B>vsl_ends()</B> ).</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
5
</CENTER>
</TD><TD><FONT SIZE=2>Current line width (see <B>vsl_width()</B> ).</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=4>
<PRE>
contrl[0] = 35;
contrl[1] = contrl[3] = 0;
contrl[6] = handle;

vdi();

attr[0] = intout[0];
attr[1] = intout[1];
attr[2] = intout[2];
attr[3] = intout[3];
attr[4] = intout[4];
attr[5] = intout[5];
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=4><B>vqm_attributes(), vqt_attributes(), vqf_attributes()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vqmattributes><H3>vqm_attributes()</H3>

<P>
<B>VOID vqm_attributes( <I>handle</I>, <I>attr</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>WORD *<I>attr</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=4><B>vqm_attributes()</B> returns information regarding current settings which apply to polymarker output.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=4>36</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=4>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=4><I>handle</I> specifies a valid workstation handle. <I>attr</I> points to an array of 5 <B>WORD</B>s which specify the current polymarker attributes as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
<I><B><FONT SIZE=1 >attr[x]</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0
</CENTER>
</TD><TD><FONT SIZE=2>Marker type (see<B> vsm_type()</B> ).</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
1
</CENTER>
</TD><TD><FONT SIZE=2>Marker color (see <B>vsm_color()</B> ).</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
2
</CENTER>
</TD><TD><FONT SIZE=2>Writing mode (see<B> vswr_mode()</B> ).</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
3
</CENTER>
</TD><TD><FONT SIZE=2>Polymarker width (see <B>vsm_height()</B> ).</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
4
</CENTER>
</TD><TD><FONT SIZE=2>Polymarker height (see <B>vsm_height()</B> ).</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=4>
<PRE>
contrl[0] = 36;
contrl[1] = contrl[3] = 0;
contrl[6] = handle;

vdi();

attr[0] = intout[0];
attr[1] = intout[1];
attr[2] = intout[2];
attr[3] = ptsout[0];
attr[4] = ptsout[1];
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=4><B>vql_attributes(), vqt_attributes(), vqf_attributes()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vqperror><H3>vqp_error()</H3>

<P>
<B>WORD vqp_error( <I>handle</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=4><B>vqp_error()</B> returns error information for the camera driver.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=4>5</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD COLSPAN=4>96</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=4>Supported by all camera drivers.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=4><I>handle</I> specifies a valid workstation handle.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=4>
<PRE>
contrl[0] = 5;
contrl[1] = contrl[3] = 0;
contrl[5] = 96;
contrl[6] = handle;

vdi();

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=4><B>vqp_error()</B> returns the current error state as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
<B><FONT SIZE=1 >Return Value</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Error State</FONT></B>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0
</CENTER>
</TD><TD><FONT SIZE=2>No error.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
1
</CENTER>
</TD><TD><FONT SIZE=2>Open dark slide for print film.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
2
</CENTER>
</TD><TD><FONT SIZE=2>No port at location specified by driver.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
3
</CENTER>
</TD><TD><FONT SIZE=2>Palette not found at specified port.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
4
</CENTER>
</TD><TD><FONT SIZE=2>Video cable disconnected.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
5
</CENTER>
</TD><TD><FONT SIZE=2>Memory allocation error.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
6
</CENTER>
</TD><TD><FONT SIZE=2>Inadequate memory for buffer.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
7
</CENTER>
</TD><TD><FONT SIZE=2>Memory not freed.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
8
</CENTER>
</TD><TD><FONT SIZE=2>Driver file not found.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
9
</CENTER>
</TD><TD><FONT SIZE=2>Driver file is not correct type.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
10
</CENTER>
</TD><TD><FONT SIZE=2>Prompt user to process print film.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=4>Use of this function does not stop the generation of on-screen messages. You must use<B> vsp_message()</B> to accomplish that.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=4><B>vsp_message()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vqpfilms><H3>vqp_films()</H3>

<P>
<B>VOID vqp_films( <I>handle</I>, <I>films</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>char *<I>films</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vqp_films()</B> returns strings which represent up to five possible film types for the camera driver to utilize.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>91</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all camera drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>films</I> is a character pointer to a buffer at least 125 characters in length. Upon return <I>films</I> will be filled in with 5 character strings. Bytes 0-24 will contain a string for the first type of film, bytes 25-49 will contain a string for the second type, and so on. These strings are <U>not</U> <B>NULL</B>-terminated but are padded with spaces.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
WORD i;

contrl[0] = 5;
contrl[1] = contrl[3] = 0;
contrl[5] = 91;
contrl[6] = handle;

vdi();

for(i = 0;i &lt; 125;i++)
 films[i] = (char)intout[i];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vqp_state()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vqpstate><H3>vqp_state()</H3>

<P>
<B>VOID vqp_state( <I>handle</I>, <I>port</I>, <I>film</I>, <I>lightness</I>,
<I>interlace</I>, <I>planes</I>, <I>indices</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>WORD *<I>port</I>, *<I>film</I>, *<I>lightness</I>, *<I>interlace</I>,
*<I>planes</I>, *<I>indices</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=2><B>vqp_state()</B> returns information regarding the current state of the palette driver.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=2>5</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD COLSPAN=2>92</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=2>Supported by all camera drivers.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=2><I>handle</I> specifies a valid workstation handle. The rest of the parameters are all <B>WORD</B>s which are filled in as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B><FONT SIZE=1 >Parameter</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD>
<CENTER>
<I>port</I>
</CENTER>
</TD><TD><FONT SIZE=2>Communication port number.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<I>film</I>
</CENTER>
</TD><TD><FONT SIZE=2>Film type (0 - 4).</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<I>lightness</I>
</CENTER>
</TD>
<TD><FONT SIZE=2>Lightness (-3 - 3). A value of 0 specifies the current f-stop setting. A value of three results in an exposure half as long as normal while a value of 3 results in an exposure twice as long as normal.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<I>interlace</I>
</CENTER>
</TD>
<TD><FONT SIZE=2>Interlace mode. A value of 0 is non-interlaced, 1 is interlaced.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<I>planes</I>
</CENTER>
</TD><TD><FONT SIZE=2>Number of planes (1 - 4)</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<I>indices</I>
</CENTER>
</TD>
<TD><FONT SIZE=2>This is actually a <B>WORD</B> array with at least 16 members. (2 ^ <I>planes</I>) members will be filled in with color codes for the driver. <I>indices[0]</I> and <I>indices[1]</I> will specify the first color, <I>indices[2]</I> and <I>indices[2]</I> the second, and so on.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=2>
<PRE>
WORD i;

contrl[0] = 5;
contrl[1] = contrl[3] = 0;
contrl[5] = 92;
contrl[6] = handle;

vdi();

*port = intout[0];
*film = intout[1];
*lightness = intout[2];
*interlace = intout[3];
*planes = intout[4];

for(i = 0;i &lt; 21;i++)
 indices[i] = intout[5 + i];
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=2><B>vsp_state()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<a name=vqtadvance><H3>vqt_advance()</H3>

<P>
<B>VOID vqt_advance( <I>handle</I>, <I>wch</I>, <I>advx</I>, <I>advy</I>,
<I>xrem</I>, <I>yrem</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>wch</I>;</B>
<P>
<B>WORD *<I>advx</I>, *<I>advy</I>, *<I>xrem</I>, *<I>yrem</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vqt_advance()</B>  returns the advance vector and remainder for a character.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>247</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available only with <B>FSMGDOS </B>or <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>wch</I> contains the character which you desire information for. Upon return the <B>WORD</B>s pointed to by <I>advx</I>, <I>advy</I>, <I>xrem</I>, and <I>yrem</I> will be filled in with the correct advance vector and remainders.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 247;
contrl[1] = 0;
contrl[3] = 1;
contrl[6] = handle;

intin[0] = wch;

vdi();

*advx = ptsout[0];
*advy = ptsout[1];
*xrem = ptsout[2];
*yrem = ptsout[3];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD><I>advx</I> and <I>advy</I>, when added to the position where the character was rendered will indicate the position to draw the next character. This advance vector works in all directions with all character rotations. <I>xrem</I> and <I>yrem</I> give the remainder value as a modulus of 16384. These remainders should be summed by an application an managed to nudge the advance vector by a pixel when necessary.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vqt_width(), vqt_extent(), vqt_f_extent()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vqtadvance32><H3>vqt_advance32()</H3>

<P>
<B>VOID vqt_advance32( <I>handle</I>, <I>wch</I>, <I>advx</I>,
<I>advy</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>wch</I>;</B>
<P>
<B>fix31 *<I>advx</I>, *<I>advy</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vqt_advance32()</B> is a variation of the binding for <B>vqt_advance()</B> which returns the advance vector and remainder for a character as two <B>fix31</B> values..
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>247</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available only with <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>wch</I> contains the character which you desire information for. Upon return the <B>fix31</B>s pointed to by <I>advx</I> and <I>advy</I> will be filled in with the correct advance vector.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 247;
contrl[1] = 0;
contrl[3] = 1;
contrl[6] = handle;

intin[0] = wch;

vdi();

*advx = (fix31)((ptsout[4] &lt;&lt; 16) | ptsout[5]);
*advy = (fix31)((ptsout[6] &lt;&lt; 16) | ptsout[7]);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD><I>advx</I> and <I>advy</I>, when added to the position where the character was rendered will indicate the position to draw the next character. This advance vector works in all directions with all character rotations.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vqt_width(), vqt_extent(), vqt_f_extent()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vqtattributes><H3>vqt_attributes()</H3>

<P>
<B>VOID vqt_attributes( <I>handle</I>, <I>attr</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>WORD *<I>attr</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=4><B>vqt_attributes()</B> returns information regarding the current attributes which affect text output.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=4>38</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=4>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=4><I>handle</I> specifies a valid workstation handle. <I>attr</I> points to an array containing 10 <B>WORD</B>s which are filled in upon function exit as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
<I><B><FONT SIZE=1 >attr[x]</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0
</CENTER>
</TD><TD><FONT SIZE=2>Text face (see <B>vst_font()</B> ).</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
1
</CENTER>
</TD><TD><FONT SIZE=2>Text color (see <B>vst_color()</B> ).</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
2
</CENTER>
</TD><TD><FONT SIZE=2>Text rotation (see <B>vst_rotation()</B> ).</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
3
</CENTER>
</TD><TD><FONT SIZE=2>Horizontal alignment (see <B>vst_alignment()</B> ).</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
4
</CENTER>
</TD><TD><FONT SIZE=2>Vertical alignment (see <B>vst_alignment()</B> ).</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
5
</CENTER>
</TD><TD><FONT SIZE=2>Writing mode (see <B>vswr_mode()</B> ).</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
6
</CENTER>
</TD><TD><FONT SIZE=2>Character width (see <B>vst_height()</B> ).</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
7
</CENTER>
</TD><TD><FONT SIZE=2>Character height (see <B>vst_height()</B> ).</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
8
</CENTER>
</TD><TD><FONT SIZE=2>Character cell width (see <B>vst_height()</B> ).</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
9
</CENTER>
</TD><TD><FONT SIZE=2>Character cell height (see <B>vst_height()</B> ).</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=4>
<PRE>
contrl[0] = 38;
contrl[1] = contrl[3] = 0;
contrl[6] = handle;

vdi();

attr[0] = intout[0];
attr[1] = intout[1];
attr[2] = intout[2];
attr[3] = intout[3];
attr[4] = intout[4];
attr[5] = intout[5];
attr[6] = intout[6];
attr[7] = intout[7];
attr[8] = intout[8];
attr[9] = intout[9];
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=4>The values pertaining to character and cell width and have limited usefulness as they are only constant with non-proportional fonts. 
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=4><B>vql_attributes(), vqm_attributes(), vqf_attributes()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vqtcachesize><H3>vqt_cachesize()</H3>

<P>
<B>VOID vqt_cachesize( <I>handle</I>, <I>which</I>, <I>size</I>
)</B>
<P>
<B>WORD <I>handle</I>, <I>which</I>;</B>
<P>
<B>LONG *<I>size</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vqt_cachesize()</B> returns the size of the largest allocatable block of memory in one of two caches.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>255</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available only with <B>FSMGDOS </B>or <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>which</I> specifies which cache. A value of <B>CACHE_CHAR</B> (0) selects the character bitmap cache. A value of <B>CACHE_MISC</B> (1) selects the miscellaneous cache. The <B>LONG</B> pointed to by <I>size</I> will be filled in upon function exit with the size of the largest allocatable block of memory in the selected cache.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 255;
contrl[1] = 0;
contrl[3] = 1;
contrl[6] = handle;

intin[0] = which;

vdi();

*size = (LONG)(((LONG)intout[0] &lt;&lt; 16) | (LONG)intout[1]); 
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>An application can estimate the amount of memory required to generate a character and print a warning message if the user attempts to exceed it. <B>FSMGDOS </B>will simply print a message on screen (you can intercept this with <B>vst_error()</B> ) and ask the user to reboot. You can estimate the amount of memory required for a particular character in the character bitmap cache with the formula:
<CENTER>
(width in pixels + 7)/8 * height in pixels
</CENTER>
Likewise, you can estimate the amount of memory needed for the miscellaneous cache as:
<CENTER>
84 * (width + height)
</CENTER>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vst_error(), v_flushcache()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vqtdevinfo><H3>vqt_devinfo()</H3>

<P>
<B>VOID vqt_devinfo( <I>handle</I>, <I>devid</I>, <I>exists</I>,
<I>devstr</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>devid</I>;</B>
<P>
<B>WORD *<I>exists</I>;</B>
<P>
<B>char *<I>devstr</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vqt_devinfo()</B> determines if a particular device ID is available, and if so, the name of the device driver.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>248</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available only with <B>FONTGDOS,</B> <B>FSM, </B>or <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>devid</I> specifies the device ID as listed in the 'ASSIGN.SYS' file. <I>exists</I> is a pointer to a <B>WORD</B> which will be filled in with <B>DEV_INSTALLED</B> (1) if a device is installed with the specified ID number or <B>DEV_MISSING</B> (0) if not. If the device does exist, the character buffer pointer to by <I>devstr</I> will be filled in with the filename of the device padded with spaces to the standard <B>GEMDOS</B> 8 + 3 format.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
WORD i;

contrl[0] = 248;
contrl[1] = 0;
contrl[3] = 1;
contrl[6] = handle;

intin[0] = devid;

vdi();

*exists = ptsout[0];

for(i = 0;i &lt; contrl[4];i++)
 devstr[i] = (char)intout[i];
</PRE>

</TD></TR>

</TABLE>

<P>

<HR>

<a name=vqtextent><H3>vqt_extent()</H3>

<P>
<B>VOID vqt_extent( <I>handle</I>, <I>str</I>, <I>pts</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>char *<I>str</I>;</B>
<P>
<B>WORD *<I>pts</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=4><B>vqt_extent()</B> returns the pixel extent of a string of text.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=4>116</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=4>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=4><I>handle</I> specifies a valid workstation handle. <I>str</I> points to a text string to return extent information for. <I>pts</I> points to an array of 8 <B>WORD</B>s which will be filled in as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
<I><B><FONT SIZE=1 >pts[x]</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0
</CENTER>
</TD><TD><FONT SIZE=2>X coordinate of point 1.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
1
</CENTER>
</TD><TD><FONT SIZE=2>Y coordinate of point 1.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
2
</CENTER>
</TD><TD><FONT SIZE=2>X coordinate of point 2.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
3
</CENTER>
</TD><TD><FONT SIZE=2>Y coordinate of point 2.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
4
</CENTER>
</TD><TD><FONT SIZE=2>X coordinate of point 3.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
5
</CENTER>
</TD><TD><FONT SIZE=2>Y coordinate of point 3.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
6
</CENTER>
</TD><TD><FONT SIZE=2>X coordinate of point 4.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
7
</CENTER>
</TD><TD><FONT SIZE=2>Y coordinate of point 4.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=4>
<PRE>
WORD i = 0;

while(intin[i++] = (WORD)*str++);

contrl[0] = 116;
contrl[1] = 0;
contrl[3] = --i;
contrl[6] = handle;

vdi();

pts[0] = ptsout[0];
pts[1] = ptsout[1];
pts[2] = ptsout[2];
pts[3] = ptsout[3];
pts[4] = ptsout[4];
pts[5] = ptsout[5];
pts[6] = ptsout[6];
pts[7] = ptsout[7];
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=4>This function will also output correct bounding information for rotated text. It is recommended that <B>vqt_f_extent()</B> be used for outline fonts as it takes special factors into consideration which makes its output more accurate.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=4><B>vqt_f_extent(), vqt_advance(), vqt_width()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vqtfextent><H3>vqt_f_extent()</H3>

<P>
<B>VOID vqt_f_extent( <I>handle</I>, <I>str</I>, <I>pts</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>char *<I>str</I>;</B>
<P>
<B>WORD *<I>pts</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vqt_f_extent()</B> returns the bounding box required to enclose the specified string of text.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>240</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available only with <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD>Same as <B>vqt_extent()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
WORD i = 0;

while(intin[i++] = (WORD)*str++);

contrl[0] = 240;
contrl[1] = 0;
contrl[3] = --i;
contrl[6] = handle;

vdi();

pts[0] = ptsout[0];
pts[1] = ptsout[1];
pts[2] = ptsout[2];
pts[3] = ptsout[3];
pts[4] = ptsout[4];
pts[5] = ptsout[5];
pts[6] = ptsout[6];
pts[7] = ptsout[7];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>As opposed to <B>vqt_extent()</B>, <B>vqt_f_extent()</B> calculates the remainders generated by outline fonts therefore providing more accurate results.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vqt_extent(), vqt_width(), vqt_advance()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vqtfextent16><H3>vqt_f_extent16()</H3>

<P>
<B>VOID vqt_f_extent( <I>handle</I>, <I>wstr</I>, <I>wstrlen,
pts</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>WORD *<I>wstr</I>;</B>
<P>
<B>WORD <I>wstrlen</I>;</B>
<P>
<B>WORD *<I>pts</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vqt_f_extent16()</B> is a variant binding of <B>vqt_f_extent()</B> that returns the bounding box required to enclose the specified string of 16-bit Speedo character indexed text.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>240</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available only with <B>FSMGDOS </B>or <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>wstr</I> points to a 16-bit text string composed of Speedo character indexes. <I>wstrlen</I> indicates the length of <I>wstr</I>. The array pointed to by <I>pts</I> is filled in with the same values as <B>vqt_extent()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
WORD i;

for( i = 0; i &lt; wstrlen; i++)
 intin[i] = wstr[i];

contrl[0] = 240;
contrl[1] = 0;
contrl[3] = wstrlen;
contrl[6] = handle;

vdi();

pts[0] = ptsout[0];
pts[1] = ptsout[1];
pts[2] = ptsout[2];
pts[3] = ptsout[3];
pts[4] = ptsout[4];
pts[5] = ptsout[5];
pts[6] = ptsout[6];
pts[7] = ptsout[7];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This variation of the <B>vqt_f_extent()</B> binding should only be used when <B>SpeedoGDOS</B> has been properly configured with <B>vst_charmap()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vqt_extent(), vqt_width(), vqt_advance()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vqtfontheader><H3>vqt_fontheader()</H3>

<P>
<B>VOID vqt_fontheader( <I>handle</I>, <I>buffer</I>, <I>pathname</I>
)</B>
<P>
<B>WORD *<I>handle</I>;</B>
<P>
<B>char *<I>buffer</I>, *<I>pathname</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vqt_fontheader()</B> returns font-specific information for the currently selected Speedo font.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>234</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available only with <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>buffer</I> should point to a buffer of at least 421 bytes into which the font header will be copied. <I>pathname</I> should point to a buffer of at least 128 bytes into which the full pathname of the font's corresponding '.TDF' file will be copied.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
WORD i;

contrl[0] = 234;
contrl[1] = 0;
contrl[3] = 2;
contrl[6] = handle;

vdi();

for(i = 0; i &lt; contrl[4]; i++)
 pathname[i] = (char)intout[i];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The font header format and '.TDF' file contents are contained in <I>Appendix G: <B>Speedo Fonts</B></I>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vqt_fontinfo()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vqtfontinfo><H3>vqt_fontinfo()</H3>

<P>
<B>VOID vqt_fontinfo( <I>handle</I>, <I>first</I>, <I>last</I>,
<I>dist</I>, <I>width</I>, <I>effects</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>WORD *<I>first</I>, *<I>last</I>, *<I>dist</I>, *<I>width</I>,
*<I>effects</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vqt_fontinfo()</B> returns information regarding the current text font.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>131</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>first</I> and <I>last</I> each point to a <B>WORD</B> which will be filled in with the first and last character in the font respectively. <I>dist</I> points to an array of 5 <B>WORD</B>s which indicate the distances between the baseline and the point indicated as follows:
<center><br><img src="../graphics/chap7110.gif"></center> 
<p>
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH></TH><TD><I>width</I> specifies the width of the largest cell in the font in pixels not including effects. <I>effects</I> points to an array of 3 <B>WORD</B>s which contain information relating to the offsets of the font when printed with the current effects.<I>effects[0]</I> specifies the number of X pixels of the left slant. <I>effects[1]</I> specifies the number of X pixels of the right slant. <I>effects[2]</I> specifies the extra number of X pixels to add to compensate for the special effects.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 131;
contrl[1] = contrl[3] = 0;
contrl[6] = handle;

vdi();

*first = intout[0];
*last = intout[1];
*width = ptsout[0];
dist[0] = ptsout[1];
dist[1] = ptsout[3];
dist[2] = ptsout[5];
dist[3] = ptsout[7];
effects[0] = ptsout[2];
effects[1] = ptsout[4];
effects[2] = ptsout[6];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD><B>SpeedoGDOS</B> is not capable of generating values for <I>dist[1]</I> or <I>dist[2]</I> so <I>dist[1]</I> is set to equal <I>dist[0]</I> and <I>dist[2]</I> is set to equal <I>dist[3]</I>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vqt_width()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vqtgettable><H3>vqt_get_table()</H3>

<P>
<B>VOID vqt_get_table( <I>handle</I>, <I>map</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>VOID **<I>map</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=4><B>vqt_get_table()</B> returns pointers to seven tables which map the Atari character set to the Bitstream character indexes. 
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=4>254</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=4>Available only with <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=4><I>handle</I> specifies a valid workstation handle. The location pointed to by map will be filled in with a pointer to seven internal tables, each 224 <B>WORD</B> size entries long mapping ASCII characters 32-255 to Bitstream character indexes.The tables are defined as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
<B><FONT SIZE=1 >Position</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Table</FONT></B></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
1st
</CENTER>
</TD><TD><FONT SIZE=2>Master mapping.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
2nd
</CENTER>
</TD><TD><FONT SIZE=2>Bitstream International Character Set</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
3rd
</CENTER>
</TD><TD><FONT SIZE=2>Bitstream International Symbol Set</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
4th
</CENTER>
</TD><TD><FONT SIZE=2>Bitstream Dingbats Set</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
5th
</CENTER>
</TD><TD><FONT SIZE=2>PostScript Text Set</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
6th
</CENTER>
</TD><TD><FONT SIZE=2>PostScript Symbol Set</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
7th
</CENTER>
</TD><TD><FONT SIZE=2>PostScript Dingbats Set </FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=4>
<PRE>
contrl[0] = 254;
contrl[1] = contrl[3] = 0;
contrl[6] = handle;

vdi();

*(VOID *)map = ((LONG)(intout[0] &lt;&lt; 16) | (LONG)intout[1]); 
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=4>Use of this call allows access to characters outside of the ASCII range but care must be taken to as this call affects all applications.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vqtname><H3>vqt_name()</H3>

<P>
<B>WORD  vqt_name( <I>handle</I>, <I>index</I>, <I>fontname</I>
)</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>WORD <I>index</I>;</B>
<P>
<B>char *<I>fontname</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vqt_name()</B> returns the name of the specified font.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>130</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>fontname</I> points to a character buffer of at least 33 characters which will be filled in with the name of font <I>index</I> and a flag which distinguishes bitmap and outline fonts. <I>fontname[0-31]</I> will contain the name of the font (not necessarily <B>NULL</B>-terminated). If <B>FSMGDOS </B>or <B>SpeedoGDOS </B>is installed, <I>fontname[32]</I> will contain a flag equalling <B>OUTLINE_FONT</B> (1) if the specified font is an outline font or <B>BITMAP_FONT</B> (0) if it is a bitmap font.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
WORD i;

contrl[0] = 130;
contrl[1] = 0;
contrl[3] = 1;
contrl[6] = handle;

intin[0] = index;

vdi();

for(i = 0;i &lt; 33;i++)
 fontname[i] = intout[i + 1];

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>vqt_name()</B> returns the unique code value which identifies this font (and is passed to <B>vst_font()</B> ).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vst_load_fonts(), vst_font()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>vqt_pairkern()</H3>

<P>
<B>VOID vqt_pairkern( <I>handle</I>, <I>char1</I>, <I>char2</I>,
<I>x</I>, <I>y</I> )</B>
<P>
<B>WORD <I>char1</I>, <I>char2</I>;</B>
<p>
<b>WORD <i>handle</i>,</b>
<P>
<B>fix31 *<I>x</I>, *<I>y</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vqt_pairkern()</B> returns adjustment vector information for the kerning of a character pair.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>235</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available only with <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>char1</I> and <I>char2</I> specify the left and right members of the character pair to inquire. <I>x</I> and <I>y</I> will be filled with the adjustment vector for the specified character pair.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 235;
contrl[1] = 0;
contrl[3] = 2;
contrl[6] = handle;

intin[0] = char1;
intin[1] = char2;

vdi();

*x = ((LONG)ptsout[0] &lt;&lt; 16 ) | ptsout[1];
*y = ((LONG)ptsout[2] &lt;&lt; 16 ) | ptsout[3];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vqt_trackkern(), vst_kern()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>vqt_trackkern()</H3>

<P>
<B>VOID vqt_trackkern( <I>handle</I>, <I>x</I>, <I>y</I> )</B>
<P>
<B>fix31 *<I>x</I>, *<I>y</I>;</B>
<p>
<b>WORD  <i>handle/i>,</b>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vqt_trackkern()</B> returns the horizontal and vertical adjustment vector for track kerning.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>234</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available only with <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>x</I> and <I>y</I> are the horizontal and vertical adjustment vectors currently used to modify character spacing in track kerning.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 234;
contrl[1] = 0;
contrl[3] = 0;
contrl[6] = handle;

vdi();

*x = ((LONG)ptsout[0] &lt;&lt; 16 ) | ptsout[1];
*y = ((LONG)ptsout[2] &lt;&lt; 16 ) | ptsout[2];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vqt_pairkern(), vst_kern()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vqtwidth><H3>vqt_width()</H3>

<P>
<B>WORD vqt_width( <I>handle</I>, <I>wch</I>, <I>cellw</I>, <I>left</I>,
<I>right</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>wch</I>;</B>
<P>
<B>WORD *<I>cellw</I>, *<I>left</I>, *<I>right</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vqt_width()</B> returns information regarding the width of a character cell.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>117</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. The lower eight bits of <I>wch</I> specify the ASCII character to return width information about. The following three values are each WORDs which are filled in by the function upon return with information about the width of the specified character in pixels as illustrated here.
<center><br><img src="../graphics/chap7115.gif"></center>
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 117;
contrl[1] = 0;
contrl[3] = 1;
contrl[6] = handle;

intin[0] = wch;

vdi();

*cellw = ptsout[0];
*left = ptsout[2];
*right = ptsout[4];

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>vqt_width()</B> returns <I>wch</I> or -1 if an error occurred.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD><B>vqt_width()</B> does not take into account remainders when dealing with outline fonts. It is therefore recommended that <B>vqt_advance()</B> be used instead when inquiring about outline fonts.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vqt_advance()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vrrecfl><H3>vr_recfl()</H3>

<P>
<B>VOID vr_recfl( <I>handle</I>, <I>pxy</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>WORD *<I>pxy</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vr_recfl()</B> outputs a filled rectangle.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>114</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>pxy</I> points to an array of 4 <B>WORD</B>s which give a <B>VDI</B> format rectangle of the object to draw.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 114;
contrl[1] = 2;
contrl[3] = 0;
contrl[6] = handle;

ptsin[0] = pxy[0];
ptsin[1] = pxy[1];
ptsin[2] = pxy[2];
ptsin[3] = pxy[3];

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD><B>vr_recfl()</B>, as opposed to <B>v_bar()</B>, never draws an outline regardless of the settings of <B>vsf_perimeter()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_bar()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vrtrnfm><H3>vr_trnfm()</H3>

<P>
<B>VOID vr_trnfm( <I>handle</I>, <I>src</I>, <I>dest</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>MFDB *<I>src</I>, *<I>dest</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=10><B>vr_trnfm()</B> transforms a memory block from device-independent to device-dependent and vice-versa.
</TD></TR>

<TR><TH></TH><TD COLSPAN=10></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=10>110</TD></TR>

<TR><TH></TH><TD COLSPAN=10></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=10>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD COLSPAN=10></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=10><I>handle</I> specifies a valid workstation handle. <I>src</I> specifies the <B>MFDB</B> (as defined in <B>vro_cpyfm()</B> ) wheras <I>dest</I> specifies the <B>MFDB</B> of the destination.
</TD></TR>

<TR><TH></TH><TD COLSPAN=10></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=10>
<PRE>
contrl[0] = 110;
contrl[1] =contrl[3] = 0;
contrl[6] = handle;
contrl[7] = (WORD)((LONG)src &gt;&gt; 16);
contrl[8] = (WORD)src;
contrl[9] = (WORD)((LONG)dest &gt;&gt; 16);
contrl[10] = (WORD)dest;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=10></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=10>While <B>vr_trnfm()</B> will work for in-place transformations, this process can be time-consuming for large forms.This call will not translate between forms with multiple planes. For instance, you can not translate a 2 plane device-independent image to an 8-plane device-specific image.
</TD></TR>

<TR><TH></TH><TD COLSPAN=10></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=10>To stay compatible with future hardware developments it is recommended that all images be initially either stored or manually translated to device-independent format and subsequently converted with this function to match the planar configuration of the device.When this call is used to transform forms with either 2 or 4 bit planes, color translation is performed on each pixel as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=10></TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=5>
<CENTER>
<I><B>Four-Plane Transformations</B></I>
</CENTER>

</TD><TD></TD><TD COLSPAN=2>
<CENTER>
<I><B><FONT SIZE=2>Two Plane</FONT></B></I>
</CENTER>

</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
<B><FONT SIZE=1 >Device</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >VDI</FONT></B>
</CENTER>

</TD><TD></TD><TD>
<CENTER>
<B><FONT SIZE=2 >Device</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >VDI</FONT></B>
</CENTER>

</TD><TD></TD><TD>
<CENTER>
<B><FONT SIZE=2 >Device</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >VDI</FONT></B>
</CENTER>

</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0000
</CENTER>
</TD>
<TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>
</TD><TD></TD>
<TD>
<CENTER>
<FONT SIZE=2>1000</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>9</FONT>
</CENTER>

</TD><TD></TD><TD>
<CENTER>
<FONT SIZE=2>00</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0001
</CENTER>
</TD>
<TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>
</TD><TD></TD>
<TD>
<CENTER>
<FONT SIZE=2>1001</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>10</FONT>
</CENTER>

</TD><TD></TD><TD>
<CENTER>
<FONT SIZE=2>01</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0010
</CENTER>
</TD>
<TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>
</TD><TD></TD>
<TD>
<CENTER>
<FONT SIZE=2>1010</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>11</FONT>
</CENTER>

</TD><TD></TD><TD>
<CENTER>
<FONT SIZE=2>10</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0011
</CENTER>
</TD>
<TD>
<CENTER>
<FONT SIZE=2>6</FONT>
</CENTER>
</TD><TD></TD>
<TD>
<CENTER>
<FONT SIZE=2>1011</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>14</FONT>
</CENTER>

</TD><TD></TD><TD>
<CENTER>
<FONT SIZE=2>11</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0100
</CENTER>
</TD>
<TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>
</TD><TD></TD>
<TD>
<CENTER>
<FONT SIZE=2>1100</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>12</FONT>
</CENTER>

</TD><TD></TD><TD></TD><TD></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0101
</CENTER>
</TD>
<TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>
</TD><TD></TD>
<TD>
<CENTER>
<FONT SIZE=2>1101</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>15</FONT>
</CENTER>

</TD><TD></TD><TD></TD><TD></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0110
</CENTER>
</TD>
<TD>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>
</TD><TD></TD>
<TD>
<CENTER>
<FONT SIZE=2>1110</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>13</FONT>
</CENTER>

</TD><TD></TD><TD></TD><TD></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0111
</CENTER>
</TD>
<TD>
<CENTER>
<FONT SIZE=2>8</FONT>
</CENTER>
</TD><TD></TD>
<TD>
<CENTER>
<FONT SIZE=2>1111</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD></TD><TD></TD><TD></TD></TR>

<TR><TH></TH><TD COLSPAN=10></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=10><B>vro_cpyfm()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vrocpyfm><H3>vro_cpyfm()</H3>

<P>
<B>VOID vro_cpyfm( <I>handle</I>, <I>mode</I>, <I>pxy</I>, <I>src</I>,
<I>dest</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>mode</I>;</B>
<P>
<B>WORD *<I>pxy</I>;</B>
<P>
<B>MFDB *<I>src</I>, *<I>dest</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>vro_cpyfm()</B> 'blits' a screen or memory block from one location to another.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>109</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>Supported by all screen drivers.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>handle</I> specifies valid workstation handle. <I>mode</I> specifies the writing mode as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Mode</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Result</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>ALL_WHITE</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>All zeros.</FONT></TD></TR>

<TR><TH></TH><TD><B>S_AND_D</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>source AND destination</FONT></TD></TR>

<TR><TH></TH><TD><B>S_AND_NOTD</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>source AND (NOT destination)</FONT></TD>
</TR>

<TR><TH></TH><TD><B>S_ONLY</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

<P>

<CENTER>
<FONT SIZE=2>(Replace mode)</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>source</FONT></TD></TR>

<TR><TH></TH><TD><B>NOTS_AND_D</B></TD><TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

<P>

<CENTER>
<FONT SIZE=2>(Erase mode)</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>(NOT source) AND destination</FONT></TD>
</TR>

<TR><TH></TH><TD><B>D_ONLY</B></TD><TD>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>destination</FONT></TD></TR>

<TR><TH></TH><TD><B>S_XOR_D</B></TD><TD>
<CENTER>
<FONT SIZE=2>6</FONT>
</CENTER>

<P>

<CENTER>
<FONT SIZE=2>(XOR Mode)</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>source XOR destination</FONT></TD></TR>

<TR><TH></TH><TD><B>S_OR_D</B></TD><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>source OR destination</FONT></TD></TR>

<TR><TH></TH><TD><B>NOT_SORD</B></TD><TD>
<CENTER>
<FONT SIZE=2>8</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>NOT (source OR destination)</FONT></TD>
</TR>

<TR><TH></TH><TD><B>NOT_SXORD</B></TD><TD>
<CENTER>
<FONT SIZE=2>9</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>NOT (source XOR destination)</FONT></TD>
</TR>

<TR><TH></TH><TD><B>NOT_D</B></TD><TD>
<CENTER>
<FONT SIZE=2>10</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>NOT destination</FONT></TD></TR>

<TR><TH></TH><TD><B>S_OR_NOTD</B></TD><TD>
<CENTER>
<FONT SIZE=2>11</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>source OR (NOT destination)</FONT></TD>
</TR>

<TR><TH></TH><TD><B>NOT_S</B></TD><TD>
<CENTER>
<FONT SIZE=2>12</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>NOT source</FONT></TD></TR>

<TR><TH></TH><TD><B>NOTS_OR_D</B></TD><TD>
<CENTER>
<FONT SIZE=2>13</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>(NOT source) OR destination</FONT></TD>
</TR>

<TR><TH></TH><TD><B>NOT_SANDD</B></TD><TD>
<CENTER>
<FONT SIZE=2>14</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>NOT (source AND destination)</FONT></TD>
</TR>

<TR><TH></TH><TD><B>ALL_BLACK</B></TD><TD>
<CENTER>
<FONT SIZE=2>15</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>All ones.</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD COLSPAN=3><I>pxy</I> points to an array of eight <B>WORD</B>s.<I> pxy[0-3]</I> contains the bounding rectangle of the source block. <I>pxy[4-7]</I> contains the bounding rectangle of the destination block. <I>src</I> and <I>dest</I> each point to an <B>MFDB</B> structure which describes the source and destination memory form. <B>MFDB</B> is defined as follows:
<PRE>
typedef struct
{
<FONT SIZE=2> /* Memory address (NULL = current screen). If you specify a value of NULL, the rest of the structure will be filled out for you. */
</FONT> VOID *fd_addr;

<FONT SIZE=2> /* Form width in pixels */
</FONT> WORD fd_width;

<FONT SIZE=2> /* Form height in pixels */
</FONT> WORD fd_height;

<FONT SIZE=2> /* Form width in WORDs (fd_width&nbsp;+&nbsp;15)/16 */
</FONT> WORD fd_wdwidth;

<FONT SIZE=2> /* Format (0 = device-specific, 1 = VDI format) */
</FONT> WORD fd_stand;

<FONT SIZE=2> /* Number of memory planes */
</FONT> WORD fd_planes;

<FONT SIZE=2> /* Reserved (set to 0) */
</FONT> WORD reserved1;
<FONT SIZE=2> WORD reserved2;
</FONT> WORD reserved3;
<FONT SIZE=2>} MFDB;</FONT>
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
contrl[0] = 109;
contrl[1] = 4;
contrl[3] = 1;
contrl[6] = handle;
contrl[7] = (WORD)((LONG)src &gt;&gt; 16);
contrl[8] = (WORD)src;
contrl[9] = (WORD)((LONG)dest &gt;&gt; 16);
contrl[10] = (WORD)dest;

intin[0] = mode;

ptsin[0] = pxy[0];
ptsin[1] = pxy[1];
ptsin[2] = pxy[2];
ptsin[3] = pxy[3];
ptsin[4] = pxy[4];
ptsin[5] = pxy[5];
ptsin[6] = pxy[6];
ptsin[7] = pxy[7];

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=3>To 'blit' a single-plane form to a multi-plane destination, use <B>vrt_cpyfm()</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>vr_trnfm(), vrt_cpyfm()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vrqchoice><H3>vrq_choice()</H3>

<P>
<B>VOID vrq_choice( <I>handle</I>, <I>start</I>, <I>final</I>
)</B>
<P>
<B>WORD <I>handle</I>, <I>start</I>;</B>
<P>
<B>WORD *<I>final</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vrq_choice()</B> accepts input from the 'choice' device in request mode.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>30</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is not guaranteed to be available with any driver and its use should therefore be restricted.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>start</I> indicates the starting value for the choice device (1-???). <I>final</I> points to a <B>WORD</B> which will be filled in upon exit with the results of the request.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 30;
contrl[1] = 0;
contrl[3] = 1;
contrl[6] = handle;

intin[0] = start;

vdi();

*final = intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Input is sampled until a key is pressed.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vsm_choice(), vsin_mode()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vrqlocator><H3>vrq_locator()</H3>

<P>
<B>VOID vrq_locator( <I>handle</I>, <I>mx</I>, <I>my</I>, <I>xout</I>,
<I>yout</I>, <I>term</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>mx</I>, <I>my</I>;</B>
<P>
<B>WORD *<I>xout</I>, *<I>yout</I>, *<I>term</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vrq_locator()</B> inputs information from the 'locator' device in request mode.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>28</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is not guaranteed to be available with any driver and its use should therefore be restricted.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. To start, the mouse cursor is displayed at the location given by <I>mx</I> and <I>my</I>. When a key or mouse button is pressed, the call returns. The final location of the mouse pointer is filled into the 2 <B>WORD</B>s pointed to by <I>xout</I> and <I>yout</I>. The <B>WORD</B> pointed to by <I>term</I> is filled in with the ASCII key of the character that terminated input, 32 (0x20) if the left mouse button was struck, or 33 (0x21) if the right mouse button was struck.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 28;
contrl[1] = 1;
contrl[3] = 0;
contrl[6] = handle;

ptsin[0] = mx;
ptsin[1] = my;

vdi();

*term = intout[0];

*xout = ptsout[0];
*yout = ptsout[1];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Using this function will confuse the <B>AES</B>'s mouse input functions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vsm_locator(), vsin_mode()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vrqstring><H3>vrq_string()</H3>

<P>
<B>VOID vrq_string( <I>handle</I>, <I>maxlen</I>, <I>echo</I>,
<I>outxy</I>, <I>str</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>maxlen</I>, <I>echo</I>;</B>
<P>
<B>WORD *<I>outxy</I>;</B>
<P>
<B>char *<I>str</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vrq_string()</B> waits for input from the 'string' device in request mode.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>31</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is not guaranteed to be available with any driver and its use should therefore be restricted.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. This call inputs characters from the keyboard into the buffer pointed to by <I>str</I> up to <I>maxlen</I> + 1 characters. If <I>echo</I> is set to 1, characters are echoed to the screen at the location given by the two <B>WORD</B>s pointed to by <I>outxy</I>. If echo is set to 0, no echoing is performed.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
WORD i;

contrl[0] = 31;
contrl[1] = 1;
contrl[3] = 2;
contrl[6] = handle;

intin[0] = maxlen;
intin[1] = echo;

ptsin[0] = outxy[0];
ptsin[1] = outxy[1];

vdi();

for(i = 0;i &lt; contrl[4];i++)
 str[i] = (char)intout[i];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>The <I>echo</I> parameter is not functional. Character output is never echoed. However, <I>outxy</I> must point to valid memory space or a crash <I>will</I> occur.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Though this binding does not allow for it, if <I>maxlen</I> is specified as negative, then as many as |<I>maxlen</I>| + 1 characters will be read as keycodes rather than ASCII codes. The values in <I>intout</I> will occupy the full <B>WORD</B> rather than just the lower eight bits. A custom binding could be used to take advantage of this. 
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vsin_mode(), vsm_string()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vrqvaluator><H3>vrq_valuator()</H3>

<P>
<B>VOID vrq_valuator( <I>handle</I>, <I>start</I>, *<I>final</I>,
*<I>term</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>start</I>;</B>
<P>
<B>WORD *<I>final</I>, *<I>term</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vrq_valuator()</B> accepts for input from the valuator device until a terminating character is entered in request mode.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>29</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is not guaranteed to be available with any driver and its use should therefore be restricted.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>start</I> specifies the initial value of the valuator device (1-100). When a terminating character has been struck, the <B>WORD</B> pointed to by <I>final</I> will be filled in with the final value of the valuator and the <B>WORD</B> pointed to by <I>term</I> will be filled in with whatever ASCII character caused termination.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 29;
contrl[1] = 0;
contrl[3] = 1;
contrl[6] = handle;

intin[0] = start;

vdi();

*final = intout[0];
*term = intout[1];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The 'valuator' is typically the up and down arrow keys. Each key increments or decrements the value by 10 unless the shift key is held in which case it is incremented or decremented by 1.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vsm_valuator(), vsin_mode()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>vrt_cpyfm()</H3>

<P>
<B>VOID vrt_cpyfm( <I>handle</I>, <I>mode</I>, <I>pxy</I>, <I>src</I>,
<I>dest</I>, <I>colors</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>mode</I>;</B>
<P>
<B>WORD *<I>pxy</I>;</B>
<P>
<B>MFDB *<I>src</I>, *<I>dest</I>;</B>
<P>
<B>WORD *<I>colors</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vrt_cpyfm()</B> 'blits' a single-plane source form to a multiple-plane destination.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>121</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all screen drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>mode</I> specifies the writing mode (1-4, see <B>vswr_mode()</B> ). <I>pxy</I>, <I>src</I>, and <I>dest</I> are defined the same as in <B>vro_cpyfm()</B>. <I>colors</I> points to a 2 <B>WORD</B> array which specifies the colors to apply to the 'blitted' image. <I>colors[0]</I> is applied to all set bits in the source image and <I>colors[1]</I> is applied to all of the cleared bits.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 121;
contrl[1] = 4;
contrl[3] = 3;
contrl[6] = handle;
contrl[7] = (WORD)((LONG)src &gt;&gt; 16);
contrl[8] = (WORD)src;
contrl[9] = (WORD)((LONG)dest &gt;&gt; 16);
contrl[10] = (WORD)dest;

intin[0] = mode;
intin[1] = colors[0];
intin[2] = colors[1];

ptsin[0] = pxy[0];
ptsin[1] = pxy[1];
ptsin[2] = pxy[2];
ptsin[3] = pxy[3];
ptsin[4] = pxy[4];
ptsin[5] = pxy[5];
ptsin[6] = pxy[6];
ptsin[7] = pxy[7];

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The source form must be a monoplane form.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vro_cpyfm()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vsclip><H3>vs_clip()</H3>

<P>
<B>VOID vs_clip( <I>handle</I>, <I>flag</I>, <I>pxy</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>flag</I>;</B>
<P>
<B>WORD *<I>pxy</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vs_clip()</B> defines the global clipping rectangle and state for the specified workstation.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>129</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>flag</I> is set to <B>CLIP_OFF</B> (0) to turn off <a name=clipping2>clipping or <B>CLIP_ON</B> (1) to enable clipping. If <I>flag</I> is <B>CLIP_ON</B> (1) then <I>pxy</I> should point to a 4 <B>WORD</B> array containing a <B>VDI</B> format rectangle which will serve as the clipping rectangle, otherwise, <I>pxy</I> can be <B>NULL</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 129;
contrl[1] = 2;
contrl[3] = 1;
contrl[6] = handle;

if(intin[0] = flag) {
 ptsin[0] = pxy[0];
 ptsin[1] = pxy[1];
 ptsin[2] = pxy[2];
 ptsin[3] = pxy[3];
}

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>All <B>VDI</B> calls are clipped to that workstations current clipping rectangle.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vscolor><H3>vs_color()</H3>

<P>
<B>VOID vs_color( <I>handle</I>, <I>color</I>, <I>rgb</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>color</I>;</B>
<P>
<B>WORD *<I>rgb</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vs_color()</B> sets the color of a palette index.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>14</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all devices.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>color</I> specifies the color register of the color to modify. <I>rgb</I> points to an array of three <B>WORD</B>s which contain the red, green, and blue values respectively (0-1000) which will be used to map the color index to the closest color value possible.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 14;
contrl[1] = 0;
contrl[3] = 4;
contrl[6] = handle;

intin[0] = color;
intin[1] = rgb[0];
intin[2] = rgb[1];
intin[3] = rgb[2];

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Esetcolor(), Setcolor()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vscuraddress><H3>vs_curaddress()</H3>

<P>
<B>VOID vs_curaddress( <I>handle</I>, <I>row</I>, <I>column</I>
)</B>
<P>
<B>WORD <I>handle</I>, <I>row</I>, <I>column</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vs_curaddress()</B> sets the position of the alpha screen text cursor.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>11</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all screen drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD>handle specifies a valid workstation handle. <I>row</I> and <I>column</I> specify the new coordinates of the text cursor.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = 0;
contrl[3] = 2;
contrl[5] = 11;
contrl[6] = handle;

intin[0] = row;
intin[1] = column;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call is equivalent to the esc-y VT-52 code.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vq_curaddress()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vspalette><H3>vs_palette()</H3>

<P>
<B>VOID vs_palette( <I>handle</I>, <I>mode</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>mode</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vs_palette()</B> selects a CGA palette.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>60</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call was originally designed for use on IBM CGAbased computers. Its usefulness and availability are not guaranteed under any driver so it should thus be avoided.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. A <I>mode</I> value of 0 selects a palette of red, green, and blue. A <I>mode</I> value of 1 selects a palette of cyan, magenta, and white.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = 0;
contrl[3] = 1;
contrl[5] = 60;
contrl[6] = handle;

intin[0] = mode;

vdi();
</PRE>

</TD></TR>

</TABLE>

<P>

<HR>

<a name=vscform><H3>vsc_form()</H3>

<P>
<B>VOID vsc_form( <I>handle</I>, <I>newform</I> )</B>
<P>
<B>MFORM *<I>newform</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vsc_form()</B> alters the appearance of the mouse pointer.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>111</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all screen drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>newform</I> points to a <B>MFORM</B> structure defined as follows:
<PRE>
typedef struct
{
 
 WORD mf_xhot;   /* X 'hot spot' */
 WORD mf_yhot;   /* Y 'hot spot' */
 WORD mf_nplanes;  /* Number of planes (must be 1) */
 WORD mf_fg;   /* Foreground color (should be 0) */
 WORD mf_bg;   /* Background color (should be 1) */
 WORD mf_mask[16]; /* 16 WORDs of mask*/
 WORD mf_data[16];  /* 16 WORDs of data */

} MFORM;
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
WORD i;

contrl[0] = 111;
contrl[1] = 0;
contrl[3] = 37;
contrl[6] = handle;

for(i = 0;i &lt; 37;i++)
 intin[i] = ((WORD *)newform)[i];

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>graf_mouse()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vsfcolor><H3>vsf_color()</H3>

<P>
<B>WORD vsf_color( <I>handle</I>, <I>color</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>color</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vsf_color()</B> changes the current fill color.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>25</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>color</I> specifies the new fill color index.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 25;
contrl[1] = 0;
contrl[3] = 1;
contrl[6] = handle;

intin[0] = color;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>vsf_color()</B> returns the actual color set (within bounds).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vst_color(), vsm_color(), vsl_color(), vsf_attributes()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vsfinterior><H3>vsf_interior()</H3>

<P>
<B>WORD vsf_interior( <I>handle</I>, <I>interior</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>interior</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=4><B>vsf_interior()</B> sets the interior type for filled objects.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=4>23</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=4>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=4><I>handle</I> specifies a valid workstation handle. <I>interior</I> specifies the interior type as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >interior</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>FIS_HOLLOW</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Hollow interior (color index 0).</FONT>
</TD></TR>

<TR><TH></TH><TD><B>FIS_SOLID</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Solid interior (as set by <B>vsf_color()</B> ).</FONT>
</TD></TR>

<TR><TH></TH><TD><B>FIS_PATTERN</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Patterned fill. (style set by <B>vsf_style()</B> ).</FONT>
</TD></TR>

<TR><TH></TH><TD><B>FIS_HATCH</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Hatched fill. (style set by <B>vsf_style()</B> ).</FONT>
</TD></TR>

<TR><TH></TH><TD><B>FIS_USER</B></TD><TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>User-defined fill (as set by <B>vsf_udpat()</B> ).</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=4>
<PRE>
contrl[0] = 23;
contrl[1] = 0;
contrl[3] = interior;
contrl[6] = handle;

intin[0] = interior;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=4>This call returns the color value actually set (within bounds).
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=4><B>vsf_style()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<a name=vsfperimeter><H3>vsf_perimeter()</H3>

<P>
<B>WORD vsf_perimeter( <I>handle</I>, <I>flag</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>flag</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vsf_perimeter()</B> sets whether a border will be drawn around most <B>VDI</B> objects.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>104</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>flag</I> is set to <B>PERIMETER_OFF</B> (0) to turn off perimeter drawing and <B>PERIMETER_ON</B> (1) to enable it.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 104;
contrl[1] = 0;
contrl[3] = 1;
contrl[6] = handle;
intin[0] = flag;

vdi();
return inout[0]
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD>This function returns the new value of the perimeter visibility flag.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vsfstyle><H3>vsf_style()</H3>

<P>
<B>WORD vsf_style( <I>handle</I>, <I>style</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>style</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vsf_style()</B> defines the style of fill pattern applied to filled objects.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>24</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>style</I> specifies the pattern or hatch index depending upon the last setting of <B>vsf_interior()</B>. Valid pattern indexes are as follows:
<CENTER>

</CENTER>
Valid hatch indexes are as follows:
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 24;
contrl[1] = 0;
contrl[3] = 1;
contrl[6] = handle;

intin[0] = style;

vdi();
return inout[0]
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD>This call returns the actual style set by the call.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The interior type should be set first with <B>vsf_interior()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vsf_interior()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>vsf_udpat()</H3>

<P>
<B>VOID vsf_udpat( <I>handle</I>, <I>pattern</I>, <I>planes</I>
)</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>WORD *<I>planes</I>;</B>
<P>
<B>WORD <I>planes</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vsf_udpat()</B> creates the user-defined fill pattern.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>112</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. In palette-based modes, <I>pattern</I> points to an array of (16 * <I>planes</I>) <B>WORD</B>s which provide the bit pattern for the fill. In true-color modes, <I>pattern</I> points to a 16x16 array of <B>LONG</B>s (256 in total) which each contain 32-bit color information. <I>planes</I> specifies the number of color planes for the fill. Use 1 for a monochrome fill on any display, a value equal to the number of planes on the current device for a palette-based color fill or 32 for a true-color display. 
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
WORD i;

contrl[0] = 112;
contrl[1] = 0;
contrl[3] = (16 * planes);
contrl[6] = handle;

for(i = 0;i &lt; (16 * planes);i++)
 intin[i] = pattern[i];

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vsf_interior()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vsinmode><H3>vsin_mode()</H3>

<P>
<B>WORD vsin_mode( <I>handle</I>, <I>device</I>, <I>mode</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>device</I>, <I>mode</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>vsin_mode()</B> chooses between request or sample mode for the specified device.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>33</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>Supported in ROM by all Atari computers.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=5><I>handle</I> specifies a valid workstation handle. A <I>mode</I> value of <B>REQUEST_MODE</B> (1) sets the device to operate in request mode whereas a value of <B>SAMPLE_MODE</B> (2) operates the device in sample mode. Valid devices are:
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >device</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Device</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD><B>LOCATOR</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Locator</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>VALUATOR</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Valuator</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>CHOICE</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Choice</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>STRING</B></TD><TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>String</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
contrl[0] = 33;
contrl[1] = 0;
contrl[3] = 2;
contrl[6] = handle;

intin[0] = device;
intin[1] = mode;

vdi();

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=5><B>vsin_mode()</B> returns <I>mode</I>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=5>Using this function will cause the <B>AES</B> to function improperly.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=5><B>vrq_valuator(), vrq_string(), vrq_choice(), vrq_locator(), vsm_valuator(), vsm_string(), vsm_choice(), vsm_locator()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vslcolor><H3>vsl_color()</H3>

<P>
<B>WORD vsl_color( <I>handle</I>, <I>color</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>color</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vsl_color()</B> sets the color for line-drawing functions and objects with perimeters.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>17</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>color</I> specifies the new color to define for line-drawing.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 17;
contrl[1] = 0;
contrl[3] = 1;
contrl[6] = handle;

intin[0] = color;

vdi();

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD>This function returns the new color set (within bounds).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vst_color(), vsm_color(), vsf_color()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vslends><H3>vsl_ends()</H3>

<P>
<B>VOID vsl_ends( <I>handle</I>, <I>start</I>, <I>end</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>start</I>, <I>end</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>vsl_ends()</B> sets the style of end point for the starting and ending points of lines drawn by the <B>VDI </B>in line-drawing functions and perimeter drawing.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>108</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=5><I>handle</I> specifies a valid workstation handle. <I>start</I> and <I>end</I> specify the type of end cap to use at the start and end of lines respectively as follows:
<center><br><img src="../graphics/chap7133.gif"></center><br>
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >start/end</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Shape</FONT></B></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>SQUARE</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>ARROWED</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>ROUND</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD></TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
contrl[0] = 108;
contrl[1] = 0;
contrl[3] = 2;
contrl[6] = handle;

intin[0] = start;
intin[1] = end;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=5><B>vsl_type()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<a name=vsltype><H3>vsl_type()</H3>

<P>
<B>WORD vsl_type( <I>handle</I>, <I>type</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>type</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>vsl_type()</B> defines the style of line used in line-drawing functions and perimeter drawing.
<center><br><img src="../graphics/chap7134.gif"></center><br>
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>15</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=5><I>handle</I> specifies a valid workstation handle. <I>type</I> defines the style of line as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >type</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Style</FONT></B></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>SOLID</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>LDASHED</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>DOTTED</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>DASHDOT</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>DASH</B></TD><TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

</TD><TD></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>DASHDOTDOT</B></TD><TD>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>

</TD><TD></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>USERLINE</B></TD><TD>
<CENTER>
<FONT SIZE=2>6</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>User-defined with <B>vsl_udsty()</B>.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
contrl[0] = 15;
contrl[1] = 0;
contrl[3] = 1;
contrl[6] = handle;

intin[0] = type;

vdi();

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=5><B>vsl_style()</B> returns the newly set line type.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=5><B>vsl_udsty()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<a name=vsludsty><H3>vsl_udsty()</H3>

<P>
<B>VOID vsl_udsty( <I>handle</I>, <I>pattern</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>pattern</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vsl_udsty()</B> sets the user-defined line type.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>113</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>pattern</I> is a <B>WORD</B> which defines the <B>USERLINE</B> style. It is essentially a bit mask which is applied to a solid line and repeated along the length of the line. A value of 0xFFFF would create a solid line. A value of 0xAAAA would produce a line where every other pixel was set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 113;
contrl[1] = 0;
contrl[3] = 1;
contrl[6] = handle;

intin[0] = pattern;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>You must call <B>vsl_style(</B> <I>handle</I>, 6 <B>)</B> to actually utilize this style.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vsl_style()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vslwidth><H3>vsl_width()</H3>

<P>
<B>WORD vsl_width( <I>handle</I>, <I>width</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>width</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vsl_width()</B> determines the width of lines drawn with line-drawing functions and as perimeters to other objects.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>16</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>width</I> specifes the width future lines drawn will be.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 16;
contrl[1] = 1;
contrl[2] = 0;
contrl[3] = 0;
contrl[6] = handle;
ptsin[0] = width;
ptsin[1] = 0;
vdi();
return ptsout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>You must call vsl_type(handle,) to actually utilize this style.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vq_extnd()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vsmchoice><H3>vsm_choice()</H3>

<P>
<B>WORD vsm_choice( <I>handle</I>, <I>xout</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>WORD *<I>xout</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vsm_choice()</B> returns the current value of the 'choice' device.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>30</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is not guaranteed to be available with any driver and its use should therefore be restricted.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>xout</I> points to a <B>WORD</B> which is filled in on function exit with the current value of the choice device.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 30;
contrl[1] = contrl[3] = 0;
contrl[6] = handle;

vdi();

*xout = intout[0];

return contrl[4];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>vsm_choice()</B> returns 1 if an input from the 'choice' device was made or 0 otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vsin_mode(), vrq_choice()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vsmcolor><H3>vsm_color()</H3>

<P>
<B>WORD vsm_color( <I>handle</I>, <I>color</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>color</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vsm_color()</B> defines the color used to render markers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>20</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>color</I> specifies the new color to define for markers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 20;
contrl[1] = 0;
contrl[3] = 1;
contrl[6] = handle;
intin = color;
vdi();

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>vsm_color()</B> returns the new marker color actually set (within bounds).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_pmarker(), vsl_color(), vst_color(), vsf_color()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vsmheight><H3>vsm_height()</H3>

<P>
<B>WORD vsm_height( <I>handle</I>, <I>size</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>size</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vsm_height()</B> sets the height of markers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>19</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>size</I> specifies the height (and width) of markers to draw in pixels.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 19;
contrl[1] = 0;
contrl[3] = 1;
contrl[6] = handle;

ptsin[0] = 0
ptsin[1] = size;
vdi();

return ptsout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>vsm_height()</B> returns the marker height actually set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The <B>DOT</B> marker is not affected by this call. It is always one pixel high and wide.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_pmarker()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vsmlocator><H3>vsm_locator()</H3>

<P>
<B>WORD vsm_locator( <I>handle</I>, <I>mx</I>, <I>my</I>, <I>xout</I>,
<I>yout</I>, <I>term</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>mx</I>, <I>my</I>;</B>
<P>
<B>WORD *<I>xout</I>, *<I>yout</I>, *<I>term</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=2><B>vsm_locator()</B> receives data from the 'locator' device in sample mode.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=2>28</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=2>This call is not guaranteed to be available with any driver and its use should therefore be restricted.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=2><I>handle</I> specifies a valid workstation handle. The mouse pointer is initially drawn at location ( <I>mx</I>, <I>my</I> ). The call returns with the final position of the mouse in the <B>WORD</B>s pointed to by <I>xout</I> and <I>yout</I>.The <B>WORD</B> pointed to by <I>term</I> will be filled in with a value which specifies the ASCII value of the key pressed. <I>term</I> will be set to 0x20 if the left mouse button was pressed or 0x21 if the right mouse button was pressed.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=2>
<PRE>
contrl[0] = 28;
contrl[1] = 1;
contrl[3] = 0;
contrl[6] = handle;

ptsin[0] = mx;
ptsin[1] = my;

vdi();

*xout = ptsout[0];
*yout = ptsout[1];

*term = intout[0];

return ((contrl[4] &lt;&lt; 1) | contrl[2]);
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=2><B>vsm_locator()</B> returns one of the following based on its result:
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B><FONT SIZE=1 >Return Value</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD>
<CENTER>
0
</CENTER>
</TD><TD><FONT SIZE=2>Mouse has not moved nor was any key pressed.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
1
</CENTER>
</TD><TD><FONT SIZE=2>Mouse has been moved (<I>xout</I> and <I>yout</I> are valid).</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
2
</CENTER>
</TD><TD><FONT SIZE=2>Key or mouse button has been struck (<I>term</I> is valid).</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
3
</CENTER>
</TD><TD><FONT SIZE=2>Mouse has moved and a key or mouse button has been struck (<I>xout</I>, <I>yout</I>, and <I>term</I> are valid).</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=2>Using this call will confuse the <B>AES</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=2><B>vrq_locator(), vsin_mode()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vsmstring><H3>vsm_string()</H3>

<P>
<B>WORD vsm_string( <I>handle</I>, <I>maxlen</I>, <I>echo</I>,
<I>echoxy</I>, <I>str</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>maxlen</I>, <I>echo</I>;</B>
<P>
<B>WORD *<I>echoxy</I>;</B>
<P>
<B>char *<I>str</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vsm_string()</B> retrieves input from the 'string' device.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>31</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is not guaranteed to be available with any driver and its use should therefore be restricted.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. This call inputs characters from the keyboard into the buffer pointed to by <I>str</I> up to (<I>maxlen</I> + 1) characters. If <I>echo</I> is set to 1, characters are echoed to the screen at the location given by the two <B>WORD</B>s pointed to by <I>outxy</I>. If echo is set to 0, no echoing is performed.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
WORD i;

contrl[0] = 31;
contrl[1] = 1;
contrl[3] = 2;
contrl[6] = handle;

intin[0] = maxlen;
intin[1] = echo;

ptsin[0] = echoxy[0];
ptsin[1] = echoxy[1];

vdi();

for(i = 0;i &lt; contrl[4];i++)
 str[i] = (char)intout[i];

return contrl[4];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>vsm_string()</B> returns the number of characters actually read.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>Using this function will confuse the <B>AES</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Though this binding does not allow for it, if <I>maxlen</I> is specified as negative, then as many as ( |<I>maxlen</I>| + 1 ) characters will be read as keycodes rather than ASCII codes. The values in <I>intout</I> will occupy the full <B>WORD</B> rather than just the lower eight bits. A custom binding could be used to take advantage of this. 
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vsin_mode()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vsmtype><H3>vsm_type()</H3>

<P>
<B>WORD vsm_type( <I>handle</I>, <I>type</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>type</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>vsm_type()</B> sets the current type of marker.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>18</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=5><I>handle</I> specifies a valid workstation handle. <I>type</I> changes the marker type as follows:
<center><br><img src="../graphics/chap7140.gif"></center><br>
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >type</FONT></B></I>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Shape</FONT></B>
</CENTER>

</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>MRKR_DOT</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>Single Pixel</FONT>
</CENTER>

</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>MRKR_PLUS</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2> </FONT>
</CENTER>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>MRKR_ASTERISK</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>MRKR_BOX</B></TD><TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

</TD><TD></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>MRKR_CROSS</B></TD><TD>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>

</TD><TD></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>MRKR_DIAMOND</B></TD><TD>
<CENTER>
<FONT SIZE=2>6</FONT>
</CENTER>

</TD><TD></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
-
</CENTER>
</TD><TD>
<CENTER>
7...
</CENTER>

</TD><TD>
<CENTER>
Device Dependent
</CENTER>
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
contrl[0] = 18;
contrl[1] = 0;
contrl[3] = 1;
contrl[6] = handle;

intin[0] = type;

vdi();
return intout[0]
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=5><B>vsm_type()</B> returns the type of marker actually set.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=5><B>v_pmarker()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<a name=vsmvaluator><H3>vsm_valuator()</H3>

<P>
<B>VOID vsm_valuator( <I>handle</I>, <I>x</I>, <I>xout</I>, <I>term</I>,
<I>status</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>x</I>;</B>
<P>
<B>WORD *<I>xout</I>, *<I>term</I>, *<I>status</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=4><B>vsm_valuator()</B> retrieves input from the 'valuator' device in sample mode.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=4>29</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=4>This call is not guaranteed to be available with any driver and its use should therefore be restricted.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=4><I>handle</I> specifies a valid workstation handle. <I>x</I> sets the intial value of the 'valuator'. The <B>WORD</B> pointed to by <I>xout</I> is filled in with the final value of the device. If a key was pressed its ASCII code is returned in the <B>WORD</B> pointed to by <I>term</I>. The <B>WORD</B> pointed to by <I>status</I> contains a value as follows: 
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
<I><B><FONT SIZE=1 >status</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0
</CENTER>
</TD><TD><FONT SIZE=2>No input was taken.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
1
</CENTER>
</TD><TD><FONT SIZE=2>Valuator changed.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
2
</CENTER>
</TD><TD><FONT SIZE=2>Key press occurred.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=4>
<PRE>
contrl[0] = 29;
contrl[1] = 0;
contrl[3] = 1;
contrl[6] = handle;

intin[0] = x;

vdi();

*xout = intout[0];
*term = intout[1];

*status = contrl[4];
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=4><B>vsin_mode(), vrq_valuator()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vspmessage><H3>vsp_message()</H3>

<P>
<B>VOID vsp_message( <I>handle</I>)</B>
<P>
<B>WORD <I>handle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vsp_message()</B> causes the suppression of palette driver messages from the screen.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>95</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all camera drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = contrl[3] = 0;
contrl[5] = 95;
contrl[6] = handle;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vqp_error()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vspsave><H3>vsp_save()</H3>

<P>
<B>VOID vsp_save( <I>handle</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vsp_save()</B> saves the current state of the driver to disk.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>94</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all camera drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = contrl[3] = 0;
contrl[5] = 94;
contrl[6] = handle;

vdi();
</PRE>

</TD></TR>

</TABLE>

<P>

<HR>

<a name=vspstate><H3>vsp_state()</H3>

<P>
<B>VOID vsp_state( <I>handle</I>, <I>port</I>, <I>film</I>, <I>lightness</I>,
<I>interlace</I>, <I>planes</I>, <I>indexes</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>port</I>, <I>film</I>, <I>lightness</I>,
<I>interlace</I>, <I>planes</I>;</B>
<P>
<B>WORD *<I>indexes</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vsp_state()</B> sets the palette driver state.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>93</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all camera drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>port</I> specifies the communication port number of the camera device. <I>film</I> specifies the index of the desired type of film (0-4). <I>lightness</I> specifies the modification to apply to the camera's default f-stop setting (-3-3). A value of 0 uses the default setting. A value of -3 results in an exposure of half of the default length whereas a value of 3 doubles the exposure time. <I>interlace</I> is set to 0 for non-interlaced or 1 for interlaced output. <I>planes</I> specifies the number of planes to output (1-4). <I>indexes</I> points to an array of 16 <B>WORD</B>s which define the color codes for the palette.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
WORD i;

contrl[0] = 5;
contrl[1] = 0;
contrl[3] = 20;
contrl[5] = 93;
contrl[6] = handle;

intin[0] = port;
intin[1] = film;
intin[2] = lightness;
intin[3] = interlace;
intin[4] = planes;
for(i = 0;i &lt; 16;i++)
 intin[i + 5] = indexes[i];

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vqp_state()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vstalignment><H3>vst_alignment()</H3>

<P>
<B>VOID vst_alignment( <I>handle</I>, <I>halign</I>, <I>valign</I>,
*<I>hout</I>, *<I>vout</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>halign</I>, <I>valign</I>;</B>
<P>
<B>WORD *<I>hout</I>, *<I>vout</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vst_alignment()</B> affects the vertical and horizontal alignment of normal and justified text.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>39</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. halign and valign affects where the coordinate specified by <B>v_gtext()</B> or <B>v_justified() </B>actually applies to as follows:On return, the <B>WORD</B>s pointed to by <I>hout</I> and <I>vout</I> are filled in with the values actually set.
<center><br><img src="../graphics/chap7144.gif"></center><br>
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 39;
contrl[1] = 0;
contrl[3] = 2;
contrl[6] = handle;

intin[0] = halign;
intin[1] = valign;

vdi();

*hout = intout[0];
*vout = intout[1];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_gtext(), v_justified()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vstarbpt><H3>vst_arbpt()</H3>

<P>
<B>WORD vst_arbpt( <I>handle</I>, <I>point</I>, <I>wchar</I>,
<I>hchar</I>, <I>wcell</I>, <I>hcell</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>WORD <I>point</I>;</B>
<P>
<B>WORD *<I>wchar</I>, *<I>hchar</I>, *<I>wcell</I>, *<I>hcell</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vst_arbpt()</B> selects any point size for an outline font.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>246</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available only with <B>FSMGDOS </B>or <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>point</I> specifies the point size at which to render outline text.Upon return, the <B>WORD</B>s pointed to by <I>wchar</I>, <I>hchar</I>, <I>wcell</I>, and <I>hcell</I> will be filled in with the width and height of the character and the width and height of the character cell respectively.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 246;
contrl[1] = 0;
contrl[3] = 1;
contrl[6] = handle;

intin[0] = point;

vdi();

*wchar = ptsout[0];
*hchar = ptsout[1];
*wcell = ptsout[2];
*hcell = ptsout[3];

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>vst_arbpt()</B> returns the point size actually selected.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call only works with outline fonts, however, it is not restricted by the point sizes listed in the 'ASSIGN.SYS' file.To specify a fractional point size, use <B>vst_arbpt32()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vst_arbpt32(), vst_point(), vst_height()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vstarbpt32><H3>vst_arbpt32()</H3>

<P>
<B>fix31 vst_arbpt( <I>handle</I>, <I>point</I>, <I>wchar</I>,
<I>hchar</I>, <I>wcell</I>, <I>hcell</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>fix31 <I>point</I>;</B>
<P>
<B>WORD *<I>wchar</I>, *<I>hchar</I>, *<I>wcell</I>, *<I>hcell</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vst_arbpt32()</B> selects a fractional point size for an outline font.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>246</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available only with <B>FSMGDOS </B>or <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>point</I> specifies the point size at which to render outline text as a <B>fix31</B> value.Upon return, the <B>WORD</B>s pointed to by <I>wchar</I>, <I>hchar</I>, <I>wcell</I>, and <I>hcell</I> will be filled in with the width and height of the character and the width and height of the character cell respectively.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 246;
contrl[1] = 0;
contrl[3] = 2;
contrl[6] = handle;

intin[0] = (WORD)(point &gt;&gt; 16);
intin[1] = (WORD)(point &amp; 0xFFFF);

vdi();

*wchar = ptsout[0];
*hchar = ptsout[1];
*wcell = ptsout[2];
*hcell = ptsout[3];

return (((fix31)intout[0] &lt;&lt; 16) | (fix31)intout[1]);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><a name=vstarbpt322><B>vst_arbpt32()</B> returns the point size actually selected.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call only works with outline fonts, however, it is not restricted by the point sizes listed in the 'ASSIGN.SYS' file.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vst_arbpt(), vst_point(), vst_height()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>vst_charmap()</H3>

<P>
<B>VOID vst_charmap( <I>handle</I>, <I>mode</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>mode</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vst_charmap()</B> chooses between the standard Atari ASCII interpretation of text strings or translation of Bitstream character indexes.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>236</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available only with <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>mode</I> should be <B>MAP_ATARI</B> (1) to specify Atari ASCII characters or <B>MAP_BITSTREAM</B> (0) for Bitstream mappings.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 236;
contrl[1] = 0;
contrl[3] = 1;
contrl[6] = handle;

intin[0] = mode;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Bitstream character indexes are <B>WORD</B> sized rather than <B>BYTE</B> sized. A list of Bitstream character mappings can be found in Appendix G.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vstcolor><H3>vst_color()</H3>

<P>
<B>WORD vst_color( <I>handle</I>, <I>color</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>color</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vst_color()</B> sets the current text color.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>22</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>color</I> specifies the new color to apply to text.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 22;
contrl[1] = 0;
contrl[3] = 1;
contrl[6] = handle;

intin[0] = color;

vdi();

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>vst_color()</B> returns the text color actually set (within bounds).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vsl_color(), vsm_color(), vsf_color()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vsteffects><H3>vst_effects()</H3>

<P>
<B>WORD vst_effects( <I>handle</I>, <I>effects</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>effects</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>vst_effects()</B> defines which special effects are to be applied to text.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>106</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=5><I>handle</I> specifies a valid workstation handle. <I>effects</I> is a bit mask which specifies one or more special effects to apply to text as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bit</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD><B>THICKENED</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Thickened</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>LIGHT</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Lightened</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>SKEWED</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Skewed</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>UNDERLINED</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Underlined</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>OUTLINED</B></TD><TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Outlined</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>SHADOWED</B></TD><TD>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Shadowed (not currently supported)</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
contrl[0] = 106;
contrl[1] = 0;
contrl[3] = 1;
contrl[6] = handle;

intin[0] = effects;

vdi();

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=5><B>vst_effects()</B> returns the actual effects set by the call.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=5>Special effects do not, in general, work well with outline text (besides underlining). To compensate, most type families have bold and italic faces in addition to the <B>vst_skew()</B> call.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=5><B>vst_skew()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<a name=vsterror><H3>vst_error()</H3>

<P>
<B>VOID vst_error( <I>handle</I>, <I>mode</I>, <I>error</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>mode</I>;</B>
<P>
<B>WORD *<I>error</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><a name=vsterror2><B>vst_error()</B> provides a method to obtain errors from <B>GDOS </B>and suppress text messages on screen.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>245</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>Available only with <B>FONTGDOS,</B> <B>FSM, </B>or <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>handle</I> specifies a valid workstation handle. <I>mode</I> specifies the error reporting mode. A value of <B>SCREEN_ERROR</B> (1) (default) causes error messages to be outputted to the screen as text.A value of <B>APP_ERROR</B> (0) suppresses these messages and instead places an error code in the <B>WORD</B> pointed to by <I>error</I> whenever an error occurs leaving it up to the application to process errors correctly. Prior to making this call and after each reported error, the application is responsible for resetting the value pointed to by <I>error</I> to 0.The following is a list of possible error codes:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >error</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>NO_ERROR</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>No error.</FONT></TD></TR>

<TR><TH></TH><TD><B>CHAR_NOT_FOUND</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Character not found in font.</FONT></TD>
</TR>

<TR><TH></TH><TD><B>FILE_READERR</B></TD><TD>
<CENTER>
<FONT SIZE=2>8</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Error reading file.</FONT></TD></TR>

<TR><TH></TH><TD><B>FILE_OPENERR</B></TD><TD>
<CENTER>
<FONT SIZE=2>9</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Error opening file.</FONT></TD></TR>

<TR><TH></TH><TD><B>BAD_FORMAT</B></TD><TD>
<CENTER>
<FONT SIZE=2>10</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Bad file format.</FONT></TD></TR>

<TR><TH></TH><TD><B>CACHE_FULL</B></TD><TD>
<CENTER>
<FONT SIZE=2>11</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Out of memory/cache full.</FONT></TD></TR>

<TR><TH></TH><TD><B>MISC_ERROR</B></TD><TD>
<CENTER>
<FONT SIZE=2>-1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Miscellaneous error.</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
contrl[0] = 245;
contrl[1] = 0;
contrl[3] = 3;
contrl[6] = handle;

intin[0] = mode;
*(LONG *)&amp;intin[1] = (LONG)error;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=3>Once setting the error mode to 0, an application should check the error variable after each of the following calls:<B>  v_gtext()   v_justified() vst_point()</B>
<P>
<B>  vst_height()  vst_font()  vst_arbpt()</B>
<P>
<B>  vqt_advance()  vst_setsize() vqt_fontinfo()</B>
<P>
<B>  vqt_name()  vqt_width() vqt_extent()</B>
<P>
<B>  v_opnwk()  v_opnvwk() vst_load_fonts()</B>
<P>
<B>  vst_unload_fonts() v_ftext()  vqt_f_extent()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vstfont><H3>vst_font()</H3>

<P>
<B>WORD vst_font( <I>handle</I>, <I>index</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>index</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vst_font()</B> sets the current text font.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>21</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>index</I> specifies the index (as returned by <B>vqt_name()</B> ) of the font to enable.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 21;
contrl[1] = 0;
contrl[3] = 1;
contrl[6] = handle;

intin[0] = index;

vdi();

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>vst_font()</B> returns the index of the font actually set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vqt_name()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vstheight><H3>vst_height()</H3>

<P>
<B>VOID vst_height( <I>handle</I>, <I>height</I>, <I>wchar</I>,
<I>hchar</I>, <I>wcell</I>, <I>hcell</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>height</I>;</B>
<P>
<B>WORD *<I>wchar</I>, *<I>hchar</I>, *<I>wcell</I>, *<I>hcell</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vst_height</B>() sets the height of the current text face (in pixels).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>12</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>height</I> specifies the height (in pixels) at which to render text. Upon return, the <B>WORD</B>s pointed to by <I>wchar</I>, <I>hchar</I>, <I>wcell</I>, and <I>hcell</I> will be filled in with the width and height of the character and the width and height of the character cell respectively.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 12;
contrl[1] = 1;
contrl[3] = 0;
contrl[6] = handle;

ptsin[0] = 0;
ptsin[1] = height; /* Passed in ptsin[1] because of VDI bug. */

vdi();

*wchar = ptsout[0];
*hchar = ptsout[1];
*wcell = ptsout[2];
*hcell = ptsout[3];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD><B>vst_height()</B> works on both bitmap and outline fonts. The font will be scaled to fit within the height given. This doesn't always give good results with bitmap text.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vst_point(), vst_arbpt()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>vst_kern()</H3>

<P>
<B>VOID vst_kern( <I>handle</I>, <I>tmode</I>, <I>pmode</I>, <I>tracks</I>,
<I>pairs</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>tmode</I>, <I>pmode</I>;</B>
<P>
<B>WORD *<I>tracks</I>, *<I>pairs</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>vst_kern()</B> sets the track and pair kerning values.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>237</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>Available only with <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=5><I>handle</I> specifies a valid workstation handle. <I>tmode</I> specifies the track kerning mode as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >tmode</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD><B>TRACK_NONE</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>No track kerning</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>TRACK_NORMAL</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Normal track kerning</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>TRACK_TIGHT</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Tight track kerning</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>TRACK_VERYTIGHT</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Very tight track kerning</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH></TH><TD COLSPAN=5>Setting <I>pmode</I> to <B>PAIR_ON</B> (1) turns pair kerning on. Setting it to <B>PAIR_OFF </B>(0) turns pair kerning off. The <B>WORD</B> pointed to by <I>tracks</I> is filled in with the track kerning mode actually set. <I>pairs</I> points to a <B>WORD</B> which is filled in with the number of defined character kerning pairs.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
contrl[0] = 237;
contrl[1] = 0;
contrl[3] = 2;
contrl[6] = handle;

intin[0] = tmode;
intin[1] = pmode;

vdi();

*tracks = intout[0];
*pairs = intout[1];
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=5><B>vqt_trackkern(), vqt_pairkern()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vstloadfonts><H3>vst_load_fonts()</H3>

<P>
<B>WORD vst_load_fonts( <I>handle, rsrvd</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>rsrvd</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vst_load_fonts()</B> loads disk-based font information into memory.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>119</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available with any form of <B>GDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>rsrvd</I> is currently unused and must be 0.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 119;
contrl[1] = 0;
contrl[3] = 1;
contrl[6] = handle;

intin[0] = rsrvd;

vdi();
return intout[0]
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>vst_load_fonts()</B> returns the number of extra fonts loaded.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Calling this function more than once before calling <B>vst_unload_fonts()</B> will return 0.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vst_unload_fonts(), vqt_name()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vstpoint><H3>vst_point()</H3>

<P>
<B>WORD vst_point( <I>handle</I>, <I>point</I>, <I>wchar</I>,
<I>hchar</I>, <I>wcell</I>, <I>hcell</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>height</I>;</B>
<P>
<B>WORD *<I>wchar</I>, *<I>hchar</I>, *<I>wcell</I>, *<I>hcell</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vst_point()</B> sets the height of the current text face in points (1/72 inch).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>107</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>point</I> specifies a valid point size to set the current text face to. This means an appropriate bitmap font or a point size enumerated in the 'EXTEND.SYS' file.Upon return, the <B>WORD</B>s pointed to by <I>wchar</I>, <I>hchar</I>, <I>wcell</I>, and <I>hcell</I> will be filled in with the width and height of the character and the width and height of the character cell respectively.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 107;
contrl[1] = 0;
contrl[3] = 1;
contrl[6] = handle;

intin[0] = point;

vdi();

*wchar = ptsout[0];
*hchar = ptsout[1];
*wcell = ptsout[2];
*hcell = ptsout[3];

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>vst_point()</B> returns the point size actually set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>If a point size which doesn't exist for the current face is selected, the next valid size down is selected.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vst_arbpt(), vst_height()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vstrotation><H3>vst_rotation()</H3>

<P>
<B>WORD vst_rotation( <I>handle</I>, <I>angle</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>angle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vst_rotation()</B> sets the angle at which graphic text is drawn.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>13</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all drivers. For specific character rotation abilities, check the values returned in <B>vq_extnd()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>angle</I> specifies the angle at which to rotate text in tenths of degrees as follows:
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 13;
contrl[1] = 0;
contrl[3] = 1;
contrl[6] = handle;

intin[0] = angle;

vdi();

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>vst_rotation()</B> returns the value of rotation actually set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Bitmap fonts may only be rotated at 0, 90, and 270 degrees. Outline fonts may be rotated at any angle with <B>FSM</B>.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vstscratch><H3>vst_scratch()</H3>

<P>
<B>VOID vst_scratch( <I>handle</I>, <I>mode</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>mode</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>vst_scratch()</B> allows <B>FSMGDOS </B>or <B>SpeedoGDOS</B> to change its method of allocating a scratch buffer for better efficiency.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>244</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>Available only with <B>FSMGDOS </B>or <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>handle</I> specifies a valid workstation handle. <I>mode</I> specifies the scratch buffer allocation mode as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >mode</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>SCRATCH_BOTH</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Scratch buffers should be allocated which are large enough for <B>FSM/Speedo</B> and bitmap fonts with any combination of special effects.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>SCRATCH_BITMAP</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Scratch buffers should be allocated which are large enough for <B>FSM/Speedo</B> fonts with no effects and bitmap fonts with effects.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>SCRATCH_NONE</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Scratch buffers should be allocated which are large enough for <B>FSM/Speedo</B> fonts and bitmap fonts with no special effects.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
contrl[0] = 244;
contrl[1] = 0;
contrl[3] = 1;
contrl[6] = handle;

intin[0] = mode;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=3>Atari recommends that at least mode 1 be set prior to a <a name=vstloadfonts2><B>vst_load_fonts()</B> call to prevent scratch buffer overruns.The size of the scratch buffer is based on the size of the largest point size specified in the 'EXTEND.SYS' file. Attempting to add effects to a character higher in point size than this will cause a buffer overrun.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vstsetsize><H3>vst_setsize()</H3>

<P>
<B>WORD vst_setsize( <I>handle</I>, <I>point</I>, <I>wchar</I>,
<I>hchar</I>, <I>wcell</I>, <I>hcell</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>WORD <I>point</I>;</B>
<P>
<B>WORD *<I>wchar</I>, *<I>hchar</I>, *<I>wcell</I>, *<I>hcell</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vst_setsize()</B> sets the width of outline characters.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>252</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available only with <B>FSMGDOS </B>or <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a vaid workstation handle.<I>point</I> specifies the width of the character in points (1/72 inch). A value for <I>point</I> equivalent to the same point size specified in <B>vst_arbpt()</B> will result in a correctly proportioned character.Upon return, the <B>WORD</B>s pointed to by <I>wchar</I>, <I>hchar</I>, <I>wcell</I>, and <I>hcell</I> will be filled in with the width and height of the character and the width and height of the character cell respectively.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 252;
contrl[1] = 0;
contrl[3] = 1;
contrl[6] = handle;

intin[0] = point;

vdi();

*wchar = ptsout[0];
*hchar = ptsout[1];
*wcell = ptsout[2];
*hcell = ptsout[3];

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>vst_setsize()</B> returns the size actually set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call only works with outline fonts. At the next <B>vst_point()</B>, <B>vst_height()</B>, or <B>vst_arbpt()</B> the size will be reset to the correct proportions (width in points = height in points).To set a fractional size, use <B>vst_setsize32()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vst_arbpt(), vst_setsize32()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vstsetsize32><H3>vst_setsize32()</H3>

<P>
<B>fix31 vst_setsize( <I>handle</I>, <I>point</I>, <I>wchar</I>,
<I>hchar</I>, <I>wcell</I>, <I>hcell</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>fix31 <I>point</I>;</B>
<P>
<B>WORD *<I>wchar</I>, *<I>hchar</I>, *<I>wcell</I>, *<I>hcell</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vst_setsize()</B> sets the width of outline characters as a <B>fix31</B> fractional value.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>252</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available only with <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a vaid workstation handle.<I>point</I> specifies the width of the character in points (1/72 inch). A value for <I>point</I> equivalent to the same point size specified in <B>vst_arbpt()</B> will result in a correctly proportioned character.Upon return, the <B>WORD</B>s pointed to by <I>wchar</I>, <I>hchar</I>, <I>wcell</I>, and <I>hcell</I> will be filled in with the width and height of the character and the width and height of the character cell respectively.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 252;
contrl[1] = 0;
contrl[3] = 2;
contrl[6] = handle;

intin[0] = (WORD)(point &gt;&gt; 8);
intin[1] = (WORD)point;

vdi();

*wchar = ptsout[0];
*hchar = ptsout[1];
*wcell = ptsout[2];
*hcell = ptsout[3];

return ((fix31)intout[0] &lt;&lt; 16) | (fix31)intout[1];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>vst_setsize32()</B> returns the size actually set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call only works with outline fonts. At the next <B>vst_point()</B>, <B>vst_height()</B>, or <B>vst_arbpt()</B> the size will be reset to the correct proportions (width in points = height in points).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vst_setsize(), vst_arbpt()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vstskew><H3>vst_skew()</H3>

<P>
<B>WORD vst_skew( <I>handle</I>, <I>skew</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>skew</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vst_skew()</B> sets the skew amount for fonts.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>253</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available only with <B>FSMGDOS </B>or <B>SpeedoGDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>skew</I> specifies the amount to skew in tenths of degrees from 900 to 900. Negative values skew to the left and positive values skew to the right. <I>skew</I> values of -900 or 900 will result in a flat line.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 253;
contrl[1] = 0;
contrl[3] = 1;
contrl[6] = handle;

intin[0] = skew;

vdi();

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>vst_skew()</B> returns the skew value actually set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call should only be used with outline fonts. Note that this call generates a true 'skew' effect independent of that generated by <B>vst_effects()</B> which is an algorithmic 'skew'. The algorithmic 'skew' may be used on bitmap fonts but is rather unpleasant applied to outline fonts.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vst_effects()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vstunloadfonts><H3>vst_unload_fonts()</H3>

<P>
<B>VOID vst_unload_fonts( <I>handle</I>, <I>select</I> )</B>
<P>
<B>WORD <I>handle</I>, select;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vst_unload_fonts()</B> frees memory associated with disk-loaded fonts.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>120</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available under any form of <B>GDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>select</I> is reserved and should be 0.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 120;
contrl[1] = 0;
contrl[3] = 1;
contrl[6] = handle;

intin[0] = select;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vst_load_fonts()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vswrmode><H3>vswr_mode()</H3>

<P>
<B>WORD vswr_mode( <I>handle</I>, <I>mode</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>mode</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>vswr_mode()</B> defines the writing mode for rendering <B>VDI</B> objects.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>32</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>Supported by all drivers.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>handle</I> specifies a valid workstation handle. <I>mode</I> specifies a writing mode as follows:
<center><br><img src="../graphics/chap7159.gif"></center><br>
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >mode</FONT></B></I>
</CENTER>

</TD><TD COLSPAN=2><B><FONT SIZE=2 >Example</FONT></B>
</TD></TR>

<TR><TH></TH><TD><B>MD_REPLACE</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD COLSPAN=2></TD></TR>

<TR><TH></TH><TD><B>MD_TRANS</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD COLSPAN=2></TD></TR>

<TR><TH></TH><TD><B>MD_XOR</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD COLSPAN=2></TD></TR>

<TR><TH></TH><TD><B>MD_ERASE</B></TD><TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

</TD><TD COLSPAN=2></TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
contrl[0] = 32;
contrl[1] = 0;
contrl[3] = 1;
contrl[6] = handle;

intin[0] = mode;

vdi();

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3><B>vswr_mode()</B> returns the writing mode set.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=3>In true-color modes, <B>MD_ERASE</B> and <B>MD_TRANS</B> work a little differently, they write (or avoid writing on) whatever color is currently held in VDI color 0 (as opposed to the actual register reference of 0).
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vtalignment><H3>vt_alignment()</H3>

<P>
<B>VOID vt_alignment( <I>handle</I>, <I>dx</I>, <I>dy</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>dx</I>, <I>dy</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vt_alignment()</B> allows an offset to be specifies that will be applied to all coordinates output from the graphics tablet.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>85</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all tablet drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>dx</I> and <I>dy</I> are the delta offsets from (&nbsp;0,&nbsp;0&nbsp;) to apply to values from the graphics tablet.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = 0;
contrl[3] = 2;
contrl[5] = 85;
contrl[6] = handle;

intin[0] = dx;
intin[1] = dy;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call is used to 'fine-tune' the true starting point of the tablet.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vt_origin()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=vtaxis><H3>vt_axis()</H3>

<P>
<B>VOID vt_axis( <I>handle</I>, <I>xres</I>, <I>yres</I>, *<I>xout</I>,
*<I>yout</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>xres</I>, <I>yres</I>;</B>
<P>
<B>WORD *<I>xout</I>, *<I>yout</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vt_axis()</B> sets the horizontal and vertical resolution for the graphics tablet (in lines).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>82</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all tablet drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>xres</I> and <I>yres</I> specify the new horizontal and vertical resoultion of the tablet respectively. Upon return, the <B>WORD</B>s pointer to by <I>xout</I> and <I>yout</I> are filled in with the resolution actually set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0]= 5;
contrl[1] = 0;
contrl[3] = 2;
contrl[5] = 82;
contrl[6] = handle;

intin[0] = xres;
intin[1] = yres;

vdi();

*xout = intout[0];
*yout = intout[1];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vt_alignment(), vt_origin()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vtorigin><H3>vt_origin()</H3>

<P>
<B>VOID vt_origin( <I>handle</I>, <I>xorigin</I>, <I>yorigin</I>
)</B>
<P>
<B>WORD <I>handle</I>, <I>xorigin</I>, <I>yorigin</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vt_origin()</B> sets the origin point for the tablets' upper-left point.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>83</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all tablet drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>xorigin</I> and <I>yorigin</I> specify the new upper-left point recognized by the tablet.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = 0;
contrl[3] = 2;
contrl[5] = 83;
contrl[6] = handle;

intin[0] = xorigin;
intin[1] = yorigin;

vdi();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vt_axis(), vt_alignment()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vtresolution><H3>vt_resolution()</H3>

<P>
<B>VOID vt_resolution( <I>handle</I>, <I>xres</I>, <I>yres</I>,
*<I>xout</I>, *<I>yout</I> )</B>
<P>
<B>WORD <I>xres</I>, <I>yres</I>;</B>
<P>
<B>WORD *<I>xout</I>, *<I>yout</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>vt_resolution()</B> sets the horizontal and vertical resolution of the graphics tablet (in lines per inch).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Sub-Opcode</B></TH><TD>81</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Supported by all tablet drivers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies a valid workstation handle. <I>xres</I> and <I>yres</I> specify the new horizontal and vertical resolution values for the tablet respectively. Upon return, the <B>WORD</B>s pointed to by <I>xout</I> and <I>yout</I> are filled in with the values actually set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
contrl[0] = 5;
contrl[1] = 0;
contrl[3] = 2;
contrl[5] = 81;
contrl[6] = handle;

intin[0] = xres;
intin[1] = yres;

vdi();

*xout = intout[0];
*yout = intout[1];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>vt_axis()</B></TD></TR>

</TABLE>

<P>
<B></B>
<hr><center><a href="toc.htm"> Table of Contents | </a><a href="index.htm"> Index </a></center>
</BODY>

</HTML>
