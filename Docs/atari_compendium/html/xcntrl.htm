<HTML>

<HEAD>

<TITLE>XCONTROL Function Reference</TITLE>


</HEAD>

<BODY BACKGROUND BGCOLOR=#FFFFFF>

<H2>XCONTROL Function Reference</H2>

<HR>

<H2>XCONTROL Callback Functions</H2>

<HR>

<P>
The <B>XCONTROL</B> callback functions are user-supplied functions
which are identified to the Control Panel in the <B>CPXINFO</B>
structure returned by the <B>cpx_init()</B> function which is
also described in this section. When creating a Form CPX, the
only callback function that is utilized is <B>cpx_call()</B>.
The remaining functions are used only when creating Event CPX's.
The <B>XCONTROL</B> callback functions are:
<P>
 cpx_button()
<P>
 cpx_call()
<P>
 cpx_close()
<P>
 cpx_draw()
<P>
 cpx_hook()
<P>
 cpx_init()
<P>
 cpx_key()
<P>
 cpx_m1()
<P>
 cpx_m2()
<P>
 cpx_timer()
<P>
 cpx_wmove()
<a name=cpxbutton><H3>cpx_button()</H3>

<P>
<B>VOID (*cpx_button)( <I>mrets</I>, <I>nclicks</I>, <I>event</I>
)</B>
<P>
<B>MRETS *<I>mrets</I>;</B>
<P>
<B>WORD <I>nclicks</I>;</B>
<P>
<B>WORD *<I>event</I>;</B>
<TABLE>

<TR><TH></TH><TD><B>cpx_button()</B> is called in an Event CPX when a <B>MU_BUTTON</B> event has occurred.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>mrets</I> points to a structure containing the mouse event which triggered the function as follows:
<PRE>
typedef struct
{
 WORD x;   /* X position of mouse */
 WORD y;   /* Y position of mouse */
 WORD buttons;  /* Mask of buttons depressed */
 WORD kstate;  /* Keyboard shift state */
} MRETS;<I>nclicks</I> specifies the number of clicks processed. If this event should terminate the CPX, the function should place a 1 in the <B>WORD</B> pointed to by <I>event</I>.
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
cpxinfo.cpx_button = cpx_button;

return ( "cpxinfo );
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This function will only be called if <B>Set_Evnt_Mask()</B> is called with <B>MU_BUTTON</B> specified as an event to wait for.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=cpxcall><H3>cpx_call()</H3>

<P>
<B>BOOLEAN (*cpx_call)( <I>work</I> )</B>
<P>
<B>GRECT *<I>work</I>;</B>
<TABLE>

<TR><TH></TH><TD><B>cpx_call()</B> is called immediately after the <B>cpx_init()</B> function when the user activates the CPX. 
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD>Upon entry, the <B>GRECT</B> structure pointed to by work contains the current rectangular extent of the control panel window work area.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
cpxinfo.cpx_call = cpx_call;

return ( &amp;cpxinfo );
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD>The <B>cpx_call()</B> function should return <B>TRUE</B> if it wants to continue processing events through the event handlers specified in the <B>CPXINFO</B> structure or <B>FALSE</B> to indicate the CPX is finished.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>When exiting the <B>cpx_call()</B> function, the CPX must deallocate any allocated memory and close any <B>VDI</B> workstations opened.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=cpxclose><H3>cpx_close()</H3>

<P>
<B>VOID (*cpx_close)( <I>flag</I> )</B>
<P>
<B>BOOLEAN <I>flag</I>;</B>
<TABLE>

<TR><TH></TH><TD><B>cpx_close()</B> is called in an Event CPX when a <B>WM_CLOSED</B> or <B>AC_CLOSE</B> message is received by the control panel.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>flag</I> contains <B>TRUE</B> if a <B>WM_CLOSED</B> message was received or <B>FALSE</B> if <B>AC_CLOSE</B> was received.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
cpxinfo.cpx_close = cpx_close;

return ( "cpxinfo );
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This function will only be called if <B>Set_Evnt_Mask()</B> is called with <B>MU_MESAG</B> specified as an event to wait for.<B>WM_CLOSED</B> messages should be treated as equivalent to 'OK' whereas <B>AC_CLOSE</B> messages should be treated as 'Cancel'.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=cpxdraw><H3>cpx_draw()</H3>

<P>
<B>VOID (*cpx_draw)( <I>clip</I> )</B>
<P>
<B>GRECT *<I>clip</I>;</B>
<TABLE>

<TR><TH></TH><TD><B>cpx_draw()</B> is called when a <B>WM_REDRAW</B> message is received by the control panel in an Event CPX.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>clip</I> points to a <B>GRECT</B> structure specifiying the dirtied area.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
cpxinfo.cpx_draw = cpx_draw;

return ( &amp;cpxinfo );
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This routine should utilize <B>GetFirstRect()</B> and <B>GetNextRect()</B> to obtain the true rectangles of the area to redraw.This function will only be called if <B>Set_Evnt_Mask()</B> is called with <B>MU_MESAG</B> specified as an event to wait for.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=cpxhook><H3>cpx_hook()</H3>

<P>
<B>BOOLEAN (*cpx_hook)( <I>event</I>, <I>msg</I>, <I>mrets</I>,
<I>key</I>, <I>nclicks</I> )</B>
<P>
<B>WORD <I>event</I>;</B>
<P>
<B>WORD *<I>msg</I>;</B>
<P>
<B>WORD *<I>mrets</I>;</B>
<P>
<B>WORD <I>key</I>, <I>nclicks</I>;</B>
<TABLE>

<TR><TH></TH><TD><B>cpx_hook()</B> is called in an Event CPX immediately after the Control Panel's <B>evnt_multi()</B> function returns before the message is processed.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD>All parameters share counterparts with the <B>evnt_multi()</B> function. For a detailed explanation of the return values please consult the documentation for that function. <I>event</I> contains the event mask of one or more events that occurred. <I>msg</I> points to an array of eight <B>WORD</B>s containing the message buffer. <I>mrets</I> and <I>nclicks</I> point to the mouse event (if any) as described in <B>cpx_button()</B>. <I>key</I> points to a <B>WORD</B> containing the keyboard scancode of the key pressed (if any).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
cpxinfo.cpx_hook = cpx_hook;

return ( &amp;cpxinfo );
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD>The function should return <B>TRUE</B> to override default event handling or <B>FALSE</B> to continue processing the message.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=cpxinit><H3>cpx_init()</H3>

<P>
<B>CPXINFO (*cpx_init)( <I>xcpb</I> )</B>
<P>
<B>XCPB *<I>xcpb</I>;</B>
<TABLE>

<TR><TH></TH><TD><B>cpx_init()</B> is called upon bootup and every subsequent time the CPX is opened by the user.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>xcpb</I> points to an XControl Parameter Block structure as described in the beginning of this chapter.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>The <B>cpx_init()</B> function is called by JSR'ing to the first location in the CPX's TEXT segment. 'C' programmers should assemble and link the following code as the first object file in the link to ensure that the correct function is properly called:
<PRE>
; Startup stub for CPX's without save area

  .xref _cpx_init

  .text

cpxstart:
  jmp  _cpx_init

  .end
If the CPX has default data which is to be saved back into the CPX with the <B>CPX_Save()</B> function, the following stub should be used (substitute the '.dc.w&nbsp;1' statement with the appropriate amount of space required to store your data):
; Startup stub for CPX's with save area

  .xref _cpx_init
  .globl _save_vars

  .text

cpxstart:
  jmp  _cpx_init

  .data

_save_vars:
  .dc.w  1

  .end
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD>The <B>cpx_init()</B> function returns a pointer to its <a name=cpxinfo><B>CPXINFO</B> structure to allow the Control Panel to access its other routines. If it is a 'Set-Only' CPX, it should return <B>NULL</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>A CPX can distunguish when a CPX is booting by checking the <I>xcpb-&gt;booting</I> structure member.It is recommended that the CPX to create a copy of <I>xcpb</I> each time <B>cpx_init()</B> is called for the other callback functions to utilize.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=cpxkey><H3>cpx_key()</H3>

<P>
<B>VOID (*cpx_key)( <I>kstate</I>, <I>key</I>, <I>event</I> )</B>
<P>
<B>WORD <I>kstate</I>;</B>
<P>
<B>WORD <I>key</I>;</B>
<P>
<B>WORD *<I>event</I>;</B>
<TABLE>

<TR><TH></TH><TD><B>cpx_key()</B> is called in an Event CPX when a <B>MU_KEYBD</B> event has occurred.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>kstate</I> specifies the state of the keyboard shift keys as in <B>evnt_keybd()</B>. key specifies the keyboard scan code of the key struck. The <B>WORD</B> pointed to by <I>event</I> should be filled in with a 1 if this event should terminate the CPX.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
cpxinfo.cpx_key = cpx_key;

return ( &amp;cpxinfo );
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This function will only be called if <B>Set_Evnt_Mask()</B> is called with <B>MU_KEYBD</B> specified as an event to wait for.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=cpxm1><H3>cpx_m1()</H3>

<P>
<B>VOID (*cpx_m1)( <I>mrets</I>, <I>event</I> )</B>
<P>
<B>MRETS *<I>mrets</I>;</B>
<P>
<B>WORD <I>event</I>;</B>
<TABLE>

<TR><TH></TH><TD><B>cpx_m1()</B> is called when a <B>MU_M1</B> event has occurred in an Event CPX.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>mrets</I> will contain a pointer to a <B>MRETS</B> structure as specified in <B>cpx_button()</B> which contains the mouse state as it satisfied the condition. The <B>WORD</B> pointed to by event should be filled in with 1 if this event should terminate the CPX.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
cpxinfo.cpx_m1 = cpx_m1;

return ( &amp;cpxinfo );
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This function will only be called if <B>Set_Evnt_Mask()</B> is called with <B>MU_M1</B> specified as an event to wait for.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>cpx_m2()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=cpxm2><H3>cpx_m2()</H3>

<P>
<B>WORD (*cpx_m2)( <I>mrets</I>, <I>event</I> )</B>
<P>
<B>MRETS *<I>mrets</I>;</B>
<P>
<B>WORD <I>event</I>;</B>
<TABLE>

<TR><TH></TH><TD><B>cpx_m2()</B> is called when a <B>MU_M2</B> event has occurred in an Event CPX.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD>See <B>cpx_m1()</B>.</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
cpxinfo.cpx_m2 = cpx_m2;

return ( &amp;cpxinfo );
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This function will only be called if <B>Set_Evnt_Mask()</B> is called with <B>MU_M2</B> specified as an event to wait for.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>cpx_m1()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=cpxtimer><H3>cpx_timer()</H3>

<P>
<B>VOID (*cpx_timer)( <I>event</I> )</B>
<P>
<B>WORD *<I>event</I>;</B>
<TABLE>

<TR><TH></TH><TD><B>cpx_timer()</B> is called when a <B>MU_TIMER</B> event has occurred in an Event CPX.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD>The <B>WORD</B> pointed to by event should be filled in with 1 if this event should terminate the CPX.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
cpxinfo.cpx_timer = cpx_timer;

return ( &amp;cpxinfo );
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This function will only be called if <B>Set_Evnt_Mask()</B> is called with <B>MU_TIMER</B> specified as an event to wait for.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=cpxwmove><H3>cpx_wmove()</H3>

<P>
<B>VOID (*cpx_wmove)( <I>work</I> )</B>
<P>
<B>GRECT *<I>work</I>;</B>
<TABLE>

<TR><TH></TH><TD><B>cpx_wmove()</B> is called when a <B>WM_MOVED</B> message is received by the Control Panel in an Event CPX.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>work</I> is a pointer to a <B>GRECT</B> containing the new coordinates of the window work area.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
cpxinfo.cpx_wmove = cpx_wmove;

return ( &amp;cpxinfo );
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This function will only be called if <B>Set_Evnt_Mask()</B> is called with <B>MU_MESAG</B> specified as an event to wait for.
</TD></TR>

</TABLE>

<H2>XCONTROL Utility Functions</H2>

<HR>

<P>
The <B>XCONTROL</B> utility functions are accessed via the <B>XCPB</B>
(XControl Parameter Block) in the following format for users of
'C':
<PRE>

<CENTER>
ret = (*xcpb-&gt;Function)( param1, param2, ... )
</CENTER>

</PRE>

<P>
These functions provide functions useful mostly to CPX's as well
as functions that closely resemble <B>AES</B> functions better
suited for CPX's. The <B>XCONTROL</B> Utility Functions are:
<P>
 (*xcpb-&gt;CPX_Save)()
<P>
 (*xcpb-&gt;Get_Buffer)()
<P>
 (*xcpb-&gt;getcookie)()
<P>
 (*xcpb-&gt;GetFirstRect)()
<P>
 (*xcpb-&gt;GetNextRect)()
<P>
 (*xcpb-&gt;MFsave)()
<P>
 (*xcpb-&gt;Popup)()
<P>
 (*xcpb-&gt;rsh_fix)()
<P>
 (*xcpb-&gt;rsh_obfix)()
<P>
 (*xcpb-&gt;Set_Evnt_Mask)()
<P>
 (*xcpb-&gt;Sl_arrow)()
<P>
 (*xcpb-&gt;Sl_dragx)()
<P>
 (*xcpb-&gt;Sl_dragy)()
<P>
 (*xcpb-&gt;Sl_size)()
<P>
 (*xcpb-&gt;Sl_x)()
<P>
 (*xcpb-&gt;Sl_y)()
<P>
 (*xcpb-&gt;)()
<P>
 (*xcpb-&gt;XGen_Alert)()
<H3>(*xcpb-&gt;CPX_Save)()</H3>

<P>
<B>BOOLEAN (*xcpb-&gt;CPX_Save)( <I>ptr</I> , <I>num</I> );</B>
<P>
<B>VOIDP <I>ptr</I>;</B>
<P>
<B>LONG <I>num</I>;</B>
<TABLE>

<TR><TH></TH><TD><B>CPX_Save()</B> writes the specified data to the CPX on disk at the beginning of the CPX's DATA segment.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>ptr</I> is a pointer to the data to save. <I>num</I> specifies the length of the data in bytes.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
(*xcpb-&gt;CPX_Save)( ptr, num );
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>CPX_Save()</B> returns <B>TRUE</B> if the operation was successful or <B>FALSE</B> if an error occurred.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD><B><a name=cpxsave>CPX_Save()</B> stores the specified data on disk in the original CPX file at the start of the DATA segment of the program. For this reason, enough space should be allocated to account for this data. See <B>cpx_init()</B> for an example method of accomplishing this.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>(*xcpb-&gt;Get_Buffer)()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>(*xcpb-&gt;Get_Buffer)()</H3>

<P>
<B>VOIDP (*xcpb-&gt;Get_Buffer)( VOID )</B>
<TABLE>

<TR><TH></TH><TD><a name=getbuffer><B>Get_Buffer()</B> returns the address of a 64-byte static storage location for the calling CPX.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
bufptr = (*xcpb-&gt;Get_Buffer)();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Get_Buffer()</B> returns a pointer to a 64-byte static storage location which can be used by the CPX to preserve data between invocations.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Data stored in this area is lost upon a reboot. Permanent data should be stored using <B>CPX_Save()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>(*xcpb-&gt;CPX_Save)()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>(*xcpb-&gt;getcookie)()</H3>

<P>
<B>WORD (*xcpb-&gt;getcookie)( <I>cookie</I>, <I>pvalue</I> )</B>
<P>
<B>LONG <I>cookie</I>;</B>
<P>
<B>LONG *<I>pvalue</I>;</B>
<TABLE>

<TR><TH></TH><TD><B>getcookie()</B> searches the 'cookie jar' for a given cookie and if found returns its stored longword. 
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>cookie</I> contains the longword cookie (usually a packed 4 character ASCII code) to search for. If found, the value of the cookie is placed in the <B>LONG</B> pointed to by <I>pvalue</I>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
err = (*xcpb-&gt;getcookie)( cookie, pvalue );
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><a name=getcookie><TD><B>getcookie()</B> returns <B>TRUE</B> if the value placed in <I>pvalue</I> is valid or <B>FALSE</B> if the cookie was not found.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This function is useful in locating TSR's or other resident processes which a CPX is designed to configure.
</TD></TR>

</TABLE>

<P>

<HR>

<H3>(*xcpb-&gt;GetFirstRect)()</H3>

<P>
<B>GRECT *(*xcpb-&gt;GetFirstRect)( <I>prect</I> )</B>
<P>
<B>GRECT *<I>prect</I>;</B>
<TABLE>

<TR><TH></TH><TD><B>GetFirstRect()</B> returns the first member of the Control Panel's rectangle list intersected by <I>prect</I>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>prect</I> points to a <B>GRECT</B> containing the extent of the dirtied area.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
rdraw = (*xcpb-&gt;GetFirstRect)( prect );
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><a name=getfirstrect><B>GetFirstRect()</B> will return a pointer to a <B>GRECT</B> containing the first intersecting rectangle to redraw or <B>NULL</B> if none of the CPX's rectangles intersect the dirtied area.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD><B>Xform_do()</B> handles resource object redraws in Form CPX's. Other objects requiring a redraw in Form CPX's and all objects in Event CPX's must be redrawn with using these functions when a redraw message is generated.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>(*xcpb-&gt;GetNextRect)()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>(*xcpb-&gt;GetNextRect)()</H3>

<P>
<B>GRECT *(*xcpb-&gt;GetNextRect)( VOID )</B>
<TABLE>

<TR><TH></TH><TD><a name=getnextrect><B>GetNextRect()</B> returns subsequent rectangles needing to be redrawn after first calling <B>GetFirstRect()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
rdraw = (*xcpb-&gt;GetNextRect)();
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>GetNextRect()</B> returns a pointer to a <B>GRECT</B> structure containing a subsequent rectangle needing to be redrawn.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>When a redraw message is received, it should be handled as illustrated below (the example given is for an Event CPX but it may be applied to the <B>WM_REDRAW</B> message handling section of a Form CPX as well):
<PRE>
VOID
cpx_draw( clip )
GRECT *clip;
{
 GRECT *rdraw;

 rdraw = (*xcpb-&gt;GetFirstRect)( clip );

 while( rdraw )
 {
  /* User redraw function */
  my_redraw( rdraw );
  rdraw = (*xcpb-&gt;GetNextRect)();
 }
}
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>(*xcpb-&gt;GetFirstRect)()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>(*xcpb-&gt;MFsave)()</H3>

<P>
<B>VOID (*xcpb-&gt;MFsave)( <I>flag</I>, <I>mf</I> )</B>
<P>
<B>BOOLEAN <I>flag</I>;</B>
<P>
<B>MFORM *<I>mf</I>;</B>
<TABLE>

<TR><TH></TH><TD><a name=mfsave><B>MFsave()</B> saves the current mouse form so that a custom application mouse form is not destroyed when the CPX calls <B>graf_mouse()</B> or <B>vsc_form()</B> to change the shape of the mouse.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>flag</I> specifies the action to take. If <I>flag</I> is <B>MFSAVE</B> (1), the current mouse form will be written into the <B>MFORM</B> structure pointed to by <I>mf</I>. If <I>flag</I> is <B>MFRESTORE</B> (0), the mouse form will be restored from the <B>MFORM</B> structure pointed to by <I>mf</I>. See <B>vsc_form()</B> for the definition of <B>MFORM</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
(*xcpb-&gt;MFsave)( flag, mf );
</PRE>

</TD></TR>

</TABLE>

<P>

<HR>

<H3>(*xcpb-&gt;Popup)()</H3>

<P>
<B>WORD (*xcpb-&gt;Popup)( <I>items</I>, <I>num_items</I>, <I>default</I>,
<I>font</I>, <I>button</I>, <I>world</I> );</B>
<P>
<B>CHAR *<I>items</I>[];</B>
<P>
<B>WORD <I>num_items</I>, <I>default, font</I>;</B>
<P>
<B>GRECT *<I>button</I>, *<I>world</I>;</B>
<TABLE>

<TR><TH></TH><TD><B>Popup()</B> displays and controls user interaction with a popup menu.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>items</I> points to an array of character pointers pointing to the text of the items. Each string must be padded in front with at least 2 spaces and should be of equal length (at least as long as the longest string). <I>num_items</I> specifies the number of items to display in the popup. If <I>num_items</I> exceeds five, the popup will only show three items with two arrows to allow scrolling.<I>default</I> indicates the default item (the default item is displayed with a checkmark) or -1 to indicate no default item.<I>font</I> specifies the font size (3 = large, 5 = small) of the items in the popup.<I>button</I> points to a <B>GRECT</B> containing the rectangular extent of the button pressed to call the popup. <I>world</I> points to a <B>GRECT</B> containing the current extent of the CPX work area.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
ret = (*xcpb-&gt;Popup)( items, num_items, default, font, button, world );
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Popup()</B> returns the item selected (0 based ) or -1 if no selection was made (the user clicked outside of the popup area).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This function is unique to CPX's and is not the same as <B>menu_popup()</B>.Button objects which are to be used as popups should be <B>TOUCHEXIT</B> objects. In addition, as a matter of style, popup buttons should be <B>SHADOWED</B>.
</TD></TR>

</TABLE>

<P>

<HR>

<H3>(*xcpb-&gt;rsh_fix)()</H3>

<P>
<B>VOID (*xcpb-&gt;rsh_fix)( <I>num_objs</I>, <I>num_frstr</I>,
<I>num_frimg</I>, <I>num_tree</I>, <I>rs_object</I>, <I>rs_tedinfo</I>,
<I>rs_strings</I>, <I>rs_iconblk</I>, <I>rs_bitblk</I>, <I>rs_frstr</I>,
<I>rs_frimg</I>, <I>rs_trindex</I>, <I>rs_imdope</I> );</B>
<P>
<B>WORD <I>num_objs</I>, <I>num_frstr</I>, <I>num_frimg</I>, <I>num_tree</I>;</B>
<P>
<B>OBJECT *<I>rs_object</I>;</B>
<P>
<B>TEDINFO *<I>rs_tedinfo</I>;</B>
<P>
<B>char *<I>rs_strings</I>[];</B>
<P>
<B>ICONBLK *<I>rs_iconblk</I>;</B>
<P>
<B>BITBLK *<I>rs_bitblk</I>;</B>
<P>
<B>LONG *<I>rs_frstr</I>, *<I>rs_frimg</I>, *<I>rs_trindex</I>;</B>
<P>
<B>struct foobar *<I>rs_imdope</I>;</B>
<TABLE>

<TR><TH></TH><TD><B>rsh_fix()</B> fixes up a resource tree in memory based on an 8x16 character font.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD>When using the Atari Resource Construction Set the parameters are generated in the .RSH file created by the compiler.When using other resource construction sets you should refer to their instructions for applying their resource structure to this function or use the CPX function <B>rsh_obfix()</B> on each <B>OBJECT</B>. 
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
(xcpb-&gt;rsh_fix)( num_objs, num_frstr, num_frimg, num_tree, rs_object, rs_tedinfo, rs_strings, rs_iconblk, rs_bitblk, rs_frstr, rs_frimg, rs_trindex, rs_imdope );
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD><B>rsrc_load()</B>, <B>rsrc_obfix()</B>, and <B>rsrc_rcfix()</B> fix up a resource file based upon the current screen character size. CPX resource data is always fixed up based upon an 8x16 character font.Resources should be designed on a screen that supports an 8x16 ratio. When using the Atari Resource Construction Set, the resouce should be designed as a 'Panel' rather than a 'Dialog'. With other resource construction applications the same effect is acheived by turning snap off.Resources should only be fixed up when the <I>xcpb&gt;SkipRshFix</I> flag is 0. This prevents resources from being fixed up more than once.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>(*xcpb-&gt;rsh_obfix)()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>(*xcpb-&gt;rsh_obfix)()</H3>

<P>
<B>VOID (*xcpb-&gt;rsh_obfix)( <I>tree</I>, <I>curob</I> )</B>
<P>
<B>OBJECT *<I>tree</I>;</B>
<P>
<B>WORD <I>curob</I>;</B>
<TABLE>

<TR><TH></TH><TD><B>rsh_obfix()</B> converts the specified object from character to pixel based coordinates based on an 8x16 character font.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>tree</I> points to the <B>OBJECT</B> tree which contains the object <I>curob</I> to fix up.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
(*xcpb-&gt;rsh_obfix)( tree, curob );
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>See <B>rsh_fix()</B>.</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>(*xcpb-&gt;rsh_fix)()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3>(*xcpb-&gt;Set_Evnt_Mask)()</H3>

<P>
<B>VOID (*xcpb-&gt;Set_Evnt_Mask)( <I>mask</I>, <I>m1</I>, <I>m2</I>,
<I>time</I> )</B>
<P>
<B>WORD <I>mask</I>;</B>
<P>
<B>MOBLK *<I>m1</I>;</B>
<P>
<B>MOBLK *<I>m2</I>;</B>
<P>
<B>LONG <I>time</I>;</B>
<TABLE>

<TR><TH></TH><TD><B>Set_Evnt_Mask()</B> defines which events an Event CPX will process with its callback functions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>mask</I> is a bit mask of events (<B>MU_MESAG</B>, <B>MU_TIMER</B>, etc... ) that the CPX wishes to process as in <B>evnt_multi()</B>. <I>m1</I> and <I>m2</I> point to <B>MOBLK</B> structures which define mouse rectangles to wait for if the CPX wishes to wait for <B>MU_M1</B> and/or <B>MU_M2</B> events as in <B>evnt_mouse()</B>. <B>MOBLK</B> is defined as follows:
<PRE>
typedef struct
{
 WORD m_out; /* 0 = enter, 1 = exit */
 WORD m_x;
 WORD m_y;
 WORD m_w;
 WORD m_h;
} MOBLK;<I>time</I> specifies the length of time to specify for the <B>MU_TIMER</B> event if appropriate.
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
(*xcpb-&gt;Set_Evnt_Mask)( mask, m1, m2, time );
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This function is only valid for Event CPX's.
</TD></TR>

</TABLE>

<P>

<HR>

<H3>(*xcpb-&gt;Sl_arrow)()</H3>

<P>
<B>VOID (*xcpb-&gt;Sl_arrow)( <I>tree</I>, <I>base</I>, <I>slider</I>,
<I>obj</I>, <I>inc</I>, <I>min</I>, <I>max</I>, <I>numvar</I>,
<I>dir</I>, <I>foo</I> )</B>
<P>
<B>OBJECT *<I>tree</I>;</B>
<P>
<B>WORD <I>base</I>, <I>slider</I>, <I>obj</I>, <I>inc</I>, <I>min</I>,
<I>max</I>;</B>
<P>
<B>WORD *<I>numvar</I>;</B>
<P>
<B>WORD <I>dir</I>;</B>
<P>
<B>VOID (*<I>foo</I>)();</B>
<TABLE>

<TR><TH></TH><TD><B>Sl_arrow()</B> is called by a CPX when the user clicks on an arrow element of an 'active' slider.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>tree</I> points to the object tree containing the slider elements. <I>base</I> is the object index of the slider 'track'. <I>slider</I> is the object index of the slider 'elevator'. <I>obj</I> is the index of the arrow element clicked on by the user.<I>inc</I> specifies the increment amount for each slider step (+/-). <I>min</I> specifies the minimum value the slider can represent. <I>max</I> specifies the maximum value the slider can represent.<I>numvar</I> points to a <B>WORD</B> containing the value which the slider represents and which is to be updated as the slider is moved. <I>dir</I> specifies the direction of the slider movement (<B>VERTICAL</B> (0) or <B>HORIZONTAL</B> (1) ).<I>foo</I> is a pointer to a user-defined callback function which is called once for each step of the slider to allow the user's action to 'actively' update the slider. <I>foo</I> may be <B>NULL</B> if no updating is desired.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
(*xcpb-&gt;Sl_arrow)( tree, base, slider, obj, inc, min, max, numvar, dir, foo );
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Slider paging can be accomplished with this function. To do so use a method similar to the following (this example is for vertical sliders):
<PRE>
graf_mkstate( &amp;mx, &amp;my, &amp;dum, &amp;dum );
objc_offset( tree, slider, &amp;ox, &amp;oy );
inc = ( ( my &lt; oy ) ? ( -1 ) : ( 1 ) );
<FONT SIZE=2>(*xcpb-&gt;Sl_arrow( tree, base, slider, base, inc, min, max, &amp;numvar, VERTICAL, foo );</FONT>
</PRE>

</TD></TR>

</TABLE>

<P>

<HR>

<H3>(*xcpb-&gt;Sl_dragx)()</H3>

<P>
<B>VOID (*xcpb-&gt;Sl_dragx)( <I>tree</I>, <I>base</I>, <I>slider</I>,
<I>min</I>, <I>max</I>, <I>numvar</I>, <I>foo</I> )</B>
<P>
<B>OBJECT *<I>tree</I>;</B>
<P>
<B>WORD <I>base</I>, <I>slider</I>, <I>min</I>, <I>max</I>;</B>
<P>
<B>WORD *<I>numvar</I>;</B>
<P>
<B>VOID (*<I>foo</I>)();</B>
<TABLE>

<TR><TH></TH><TD><B>Sl_dragx()</B> is called by a CPX when a user clicks on the horizontal slider 'elevator' of an 'active' slider.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>tree</I> points to an <B>OBJECT</B> tree containing the slider elements. <I>base</I> is the object index of the slider 'track'. <I>slider</I> is the object index of the slider 'elevator'.<I>min</I> specifies the minimum value the slider can represent. <I>max</I> specifies the maximum value the slider can represent.<I>numvar</I> points to a <B>WORD</B> containing the value which the slider represents and which is to be updated as the slider is moved.<I>foo</I> points to a user-defined routine which is called each time the slider value <I>numvar</I> is modified. <I>foo</I> may be <B>NULL</B> if no updating is desired.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
(*xcpb-&gt;Sl_dragx)( tree, base, slider, min, max, numvar, foo );
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>It is appropriate to change the shape of the mouse to <B>FLAT_HAND</B> while the user is dragging a slider.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>(*xcpb-&gt;Sl_dragy)()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>(*xcpb-&gt;Sl_dragy)()</H3>

<P>
<B>VOID (*xcpb-&gt;Sl_dragx)( <I>tree</I>, <I>base</I>, <I>slider</I>,
<I>min</I>, <I>max</I>, <I>numvar</I>, <I>foo</I> )</B>
<P>
<B>OBJECT *<I>tree</I>;</B>
<P>
<B>WORD <I>base</I>, <I>slider</I>, <I>min</I>, <I>max</I>;</B>
<P>
<B>WORD *<I>numvar</I>;</B>
<P>
<B>VOID (*<I>foo</I>)();</B>
<TABLE>

<TR><TH></TH><TD><B>Sl_dragy()</B> is called by a CPX when a user clicks on the vertical slider 'elevator' of an 'active' slider.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD>See <B>Sl_dragx()</B>.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
(*xcpb-&gt;Sl_dragy)( tree, base, slider, min, max, numvar, foo );
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>It is appropriate to change the shape of the mouse to <B>FLAT_HAND</B> while the user is dragging a slider.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>(*xcpb-&gt;Sl_dragx)()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>(*xcpb-&gt;Sl_size)()</H3>

<P>
<B>VOID (*xcpb-&gt;Sl_size)( <I>tree</I>, <I>base</I>, <I>slider</I>,
<I>num_items</I>, <I>visible</I>, <I>direction</I>, <I>min_size</I>
)</B>
<P>
<B>OBJECT *<I>tree</I>;</B>
<P>
<B>WORD <I>base</I>, <I>slider</I>, <I>num_items</I>, <I>visible</I>,
<I>direction</I>, <I>min_size</I> ;</B>
<TABLE>

<TR><TH></TH><TD><B>Sl_size()</B> adjusts the size of the slider 'track' relative to the size of the slider 'elevator'.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>tree</I> points to the <B>OBJECT</B> tree containing the slider elements. <I>base</I> is the object index of the slider 'track'. <I>slider</I> is the object index of the slider 'elevator'. <I>num_items</I> is the total number of items represented by the slider. <I>visible</I> is the number of items actually seen by the user. <I>direction</I> specifies the direction of the slider as either <B>VERTICAL</B> (0) or <B>HORIZONTAL</B> (1). <I>min_size</I> represents the minimum pixel size of the adjusted slider elevator.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
(*xcpb-&gt;Sl_size)( tree, base, slider, num_items, visible, direction, min_size );
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This function does not redraw the slider.
</TD></TR>

</TABLE>

<P>

<HR>

<H3>(*xcpb-&gt;Sl_x)()</H3>

<P>
<B>VOID (*xcpb-&gt;Sl_x)( <I>tree</I>, <I>base</I>, <I>slider</I>,
<I>value</I>, <I>min</I>, <I>max</I>, <I>foo</I> )</B>
<P>
<B>OBJECT *<I>tree</I>;</B>
<P>
<B>WORD <I>base</I>, <I>slider</I>, <I>value</I>, <I>min</I>,
<I>max</I>;</B>
<P>
<B>VOID (*<I>foo</I>)();</B>
<TABLE>

<TR><TH></TH><TD><B>Sl_x()</B> updates the position of a horizontal slider within its base.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>tree</I> points to an <B>OBJECT</B> tree containing the slider elements. <I>base</I> is the object index of the slider 'track'. <I>slider</I> is the object index of the slider 'elevator'.<I>value</I> is the value the slider should represent. <I>min</I> and <I>max</I> are the minimum and maximum values the slider can represent respectively.If <I>foo</I> is not <B>NULL</B>, it points to a user-function which is called to redraw the slider.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
(*xcpb-&gt;Sl_x)( tree, base, slider, value, min, max, foo );
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>(*xcpb-&gt;Sl_y)()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3><a name=sly>(*xcpb-&gt;Sl_y)()</H3>

<P>
<B>VOID (*xcpb-&gt;Sl_y)( <I>tree</I>, <I>base</I>, <I>slider</I>,
<I>value</I>, <I>min</I>, <I>max</I>, <I>foo</I> )</B>
<P>
<B>OBJECT *<I>tree</I>;</B>
<P>
<B>WORD <I>base</I>, <I>slider</I>, <I>value</I>, <I>min</I>,
<I>max</I>;</B>
<P>
<B>VOID (*<I>foo</I>)();</B>
<TABLE>

<TR><TH></TH><TD><B>Sl_y()</B> updates the position of a vertical slider within its base.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD>See <B>Sl_x()</B>.</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
(*xcpb-&gt;Sl_y)( tree, base, slider, value, min, max, foo );
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>(*xcpb-&gt;Sl_x)()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3>(*xcpb-&gt;Xform_do)()</H3>

<P>
<B>WORD (*xcpb-&gt;Xform_do)( <I>tree</I>, <I>editobj</I>, <I>msg</I>
)</B>
<P>
<B>OBJECT *<I>tree</I>;</B>
<P>
<B>WORD <I>editobj</I>;</B>
<P>
<B>WORD *<I>msg</I>;</B>
<TABLE>

<TR><TH></TH><TD><B>Xform_do()</B> is a specialized version of <B>form_do()</B> designed to handle a CPX object tree and window messages concurrently.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>tree</I> should point to an <B>OBJECT</B> tree containing a form with the root object being 256x176. <I>editobj</I> specifies the editable text object to initially display the text cursor at (or 0 if no editable object exists on the form).<I>msg</I> should point to an 8 <B>WORD</B> array used by the function to store special messages returned by<B> evnt_multi()</B>. 
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
ret = (*xcpb-&gt;Xform_do)( tree, editobj, msg );
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Xform_do()</B> returns the positive object number of the <B>EXIT</B> or <B>TOUCHEXIT</B> object selected. The high bit of this value indicates if the object was double-clicked and should therefore be masked off if unused. If <B>Xform_do()</B> returns a -1, then a message should be processed as contained in <I>msg</I>. The structure of messages are the same as in <B>evnt_multi()</B>. Possible messages are:<B>WM_REDRAW</B>
<P>
<B>AC_CLOSE</B>
<P>
<B>WM_CLOSED</B>
<P>
<B>CT_KEYCT_KEY</B> (53) is a special <B>XCONTROL</B> message indicating that a key was pressed. The scancode of the key pressed is contained in<I> msg[3]</I>. Only special keyboard keys such as help, f1-f10, undo, alt-x, etc... will be returned as the standard alphabetic keys are processed in editable fields.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The <a name=xformdo><B>Xform_do()</B> function automatically handles and redraws of the given <B>OBJECT</B> tree. Any other items needing to be redrawn should be handled at the appropriate window redraw message.<B>WM_CLOSED</B> messages should always be treated as 'OK' while <B>AC_CLOSE</B> messages should be treated as 'Cancel'.
</TD></TR>

</TABLE>

<P>

<HR>

<H3>(*xcpb-&gt;XGen_Alert)()</H3>

<P>
<B>BOOLEAN (*xcpb-&gt;XGen_Alert)( <I>id</I> )</B>
<P>
<B>WORD <I>id</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B><a name=xgenalert>XGen_Alert()</B> displays a specialized alert centered in the Control Panel's work area.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=5><I>id</I> specifies the alert to display as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >id</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Alert</FONT></B></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>SAVE_DEFAULTS</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Save Defaults?</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>MEM_ERR</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Memory Allocation Error</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>FILE_ERR</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>File I/O Error</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>FILE_NOT_FOUND</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>File Not Found Error</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
ret = (*xcpb-&gt;XGen_Alert)( id );
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=5><B>XGen_Alert()</B> returns <B>TRUE</B> if 'OK' was selected or <B>FALSE</B> if 'Cancel' was selected. Alerts 1-3 always returns <B>TRUE</B>.
</TD></TR>

</TABLE>

<P>
<B></B>
<hr><center><a href="toc.htm"> Table of Contents | </a><a href="index.htm"> Index </a></center>
</BODY>

</HTML>
