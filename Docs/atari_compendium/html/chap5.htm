<HTML>

<HEAD>

<TITLE>The Atari Compendium - Hardware</TITLE>


</HEAD>

<BODY BACKGROUND BGCOLOR=#FFFFFF>

<P>
<a name=chap5><B><FONT SIZE=2>- CHAPTER 5 -</FONT></B>
<H1>HARDWARE</H1>

<HR>

<a name=overview><H4><FONT SIZE=4 >Overview</FONT></H4>

<HR>

<P>
This chapter will cover those aspects of Atari software programming
that can only be accomplished by accessing hardware registers
directly. In most cases, Atari has provided OS calls to manipulate
the hardware. When an OS call exists to access hardware, it should
<I>always</I> be used to ensure upward and backward compatibility.
Keep in mind that access to hardware registers is limited to those
applications operating in supervisor mode only (except where noted
otherwise).
<P>
Besides those hardware registers discussed here, a complete list
of I/O registers, system variables, and interrupt vectors are
contained in <I>Appendix B: <B>Memory Map</B></I>.
<HR>

<a name=680><H4><FONT SIZE=4 >The 680x0 Processor</FONT></H4>

<HR>

<P>
Atari computers use the Motorola MC68000 or MC68030. Third party
devices have also been created to allow the use of a MC68010,
MC68020, or MC68040 processor. The system cookie '_CPU' should
be used to determine the currently installed processor. The following
table lists the 680x0's interrupt priority assignments:
<TABLE BORDER=1>

<TR><TH>
<CENTER>
<B><FONT SIZE=1 >Level</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Assignment</FONT></B></TH>
</TR>

<TR><TD>
<CENTER>
7
</CENTER>
</TD><TD><FONT SIZE=2>NMI</FONT>
</TD></TR>

<TR><TD>
<CENTER>
6
</CENTER>
</TD><TD><FONT SIZE=2>MK68901 MFP</FONT>
</TD></TR>

<TR><TD>
<CENTER>
5
</CENTER>
</TD><TD><FONT SIZE=2>SCC</FONT>
</TD></TR>

<TR><TD>
<CENTER>
4
</CENTER>
</TD><TD><FONT SIZE=2>VBLANK (Sync)</FONT>
</TD></TR>

<TR><TD>
<CENTER>
3
</CENTER>
</TD><TD><FONT SIZE=2>VME Interrupter</FONT>
</TD></TR>

<TR><TD>
<CENTER>
2
</CENTER>
</TD><TD><FONT SIZE=2>HBLANK (Sync)</FONT>
</TD></TR>

<TR><TD>
<CENTER>
1
</CENTER>
</TD><TD><FONT SIZE=2>Unused</FONT>
</TD></TR>

</TABLE>

<P>

<P>
Interrupts may be disabled by setting the system interrupt mask
(bits 8-10 of the SR register) to a value higher than the interrupts
you wish to disable. Setting the mask to a value of 7 will effectively
disable all interrupts (except the level 7 <a name=nonmaskableinterrupt>non-maskable interrupt).

<a name=caches>
<a name=instructcache><H5>The Data/Instruction Caches</H5>

<P>
The Atari TT030 and Falcon030 contain onboard data and instruction
caches. These caches may be controlled by writing to the <a name=cacr>CACR register (in supervisor mode). The following table lists longword
values that may be written to the CACR to enable or disable the
caches:
<TABLE BORDER=1>

<TR><TH>
<CENTER>
<B><FONT SIZE=1 >Value to Write to CACR</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Effect</FONT></B></TH>
</TR>

<TR><TD>
<CENTER>
0xA0A
</CENTER>
</TD><TD><FONT SIZE=2>Flush and disable both caches.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x101
</CENTER>
</TD><TD><FONT SIZE=2>Enable both caches.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0xA00
</CENTER>
</TD><TD><FONT SIZE=2>Flush and disable the data cache.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x100
</CENTER>
</TD><TD><FONT SIZE=2>Enable the data cache.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0xA
</CENTER>
</TD><TD><FONT SIZE=2>Flush and disable the instruction cache.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x1
</CENTER>
</TD><TD><FONT SIZE=2>Enable the instruction cache.</FONT>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=68881><H4><FONT SIZE=4 >The 68881/882 Floating Point Coprocessor</FONT>
</H4>

<HR>

<P>
A MC6888x math coprocessor may be installed in a Mega ST, Mega
STe, or a Falcon030. The TT030 has one installed in its standard
configuration. The 6888x is interfaced to the 68000 in peripheral
mode and to the 68030 in coprocessor mode. Thus, the TT030 and
Falcon030 computers access the 6888x in coprocessor mode while
the Mega ST and MegaSTe computers access the 6888x in peripheral
mode.
<H5>Coprocessor Mode</H5>

<P>
When the 6888x is interfaced in <a name=cpmode>coprocessor mode, using it is
as simple as placing floating-point instructions in the standard
instruction stream (use a coprocessor ID of 1). The 68030 will
properly dispatch the instruction and respond to <a name=exceptions>exceptions through
the following vectors:
<TABLE BORDER=1>

<TR><TH>
<CENTER>
<B><FONT SIZE=1 >Vector Address</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Assignment</FONT></B></TH>
</TR>

<TR><TD>
<CENTER>
0x0000001C
</CENTER>
</TD><TD><FONT SIZE=2>FTRAPcc Instruction</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x0000002C
</CENTER>
</TD><TD><FONT SIZE=2>F-Line Emulator</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x00000034
</CENTER>
</TD><TD><FONT SIZE=2>Co-processor Protocol Violation</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x000000C0
</CENTER>
</TD><TD><FONT SIZE=2>Branch or Set on Unordered Condition</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x000000C4
</CENTER>
</TD><TD><FONT SIZE=2>Inexact Result</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x000000C8
</CENTER>
</TD><TD><FONT SIZE=2>Floating-Point Divide by Zero</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x000000CC
</CENTER>
</TD><TD><FONT SIZE=2>Underflow</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x000000D0
</CENTER>
</TD><TD><FONT SIZE=2>Operand Error</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x000000D4
</CENTER>
</TD><TD><FONT SIZE=2>Overflow</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x000000D8
</CENTER>
</TD><TD><FONT SIZE=2>Signaling NAN</FONT>
</TD></TR>

</TABLE>

<P>

<a name=peripheralmode><H5>Peripheral Mode</H5>

<P>
Utilizing an installed math coprocessor interfaced using peripheral
mode requires the use of several hardware registers mapped to
special coprocessor registers. Unlike most hardware registers,
these do not have to be accessed in supervisor mode. Atari computers
map the 6888x registers to the following locations:
<TABLE BORDER=1>

<TR><TH>
<CENTER>
<B><FONT SIZE=1 >Address</FONT></B>
</CENTER>

</TH><TH>
<CENTER>
<B><FONT SIZE=2 >Length</FONT></B>
</CENTER>

</TH><TH>
<CENTER>
<B><FONT SIZE=2 >Register</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Description</FONT></B>
</TH></TR>

<TR><TD>
<CENTER>
0xFFFFFA40
</CENTER>
</TD><TD>
<CENTER>
<B><FONT SIZE=2>WORD</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<I><B><FONT SIZE=2>FPCIR</FONT></B></I>
</CENTER>

</TD><TD><FONT SIZE=2>Status register</FONT></TD></TR>

<TR><TD>
<CENTER>
0xFFFFFA42
</CENTER>
</TD><TD>
<CENTER>
<B><FONT SIZE=2>WORD</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<I><B><FONT SIZE=2>FPCTL</FONT></B></I>
</CENTER>

</TD><TD><FONT SIZE=2>Control Register</FONT></TD></TR>

<TR><TD>
<CENTER>
0xFFFFFA44
</CENTER>
</TD><TD>
<CENTER>
<B><FONT SIZE=2>WORD</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<I><B><FONT SIZE=2>FPSAV</FONT></B></I>
</CENTER>

</TD><TD><FONT SIZE=2>Save Register</FONT></TD></TR>

<TR><TD>
<CENTER>
0xFFFFFA46
</CENTER>
</TD><TD>
<CENTER>
<B><FONT SIZE=2>WORD</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<I><B><FONT SIZE=2>FPREST</FONT></B></I>
</CENTER>

</TD><TD><FONT SIZE=2>Restore Register</FONT></TD></TR>

<TR><TD>
<CENTER>
0xFFFFFA48
</CENTER>
</TD><TD>
<CENTER>
<B><FONT SIZE=2>WORD</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<I><B><FONT SIZE=2>FPOPR</FONT></B></I>
</CENTER>

</TD><TD><FONT SIZE=2>Operation word register</FONT></TD></TR>

<TR><TD>
<CENTER>
0xFFFFFA4A
</CENTER>
</TD><TD>
<CENTER>
<B><FONT SIZE=2>WORD</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<I><B><FONT SIZE=2>FPCMD</FONT></B></I>
</CENTER>

<a name=commands></TD><TD><FONT SIZE=2>Command register</FONT></TD></TR>

<TR><TD>
<CENTER>
0xFFFFFA4C
</CENTER>
</TD><TD>
<CENTER>
<B><FONT SIZE=2>WORD</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<I><B><FONT SIZE=2>FPRES</FONT></B></I>
</CENTER>

</TD><TD><FONT SIZE=2>Reserved</FONT></TD></TR>

<TR><TD>
<CENTER>
0xFFFFFA4E
</CENTER>
</TD><TD>
<CENTER>
<B><FONT SIZE=2>WORD</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<I><B><FONT SIZE=2>FPCCR</FONT></B></I>
</CENTER>

</TD><TD><FONT SIZE=2>Condition Code Register</FONT></TD></TR>

<TR><TD>
<CENTER>
0xFFFFFA50
</CENTER>
</TD><TD>
<CENTER>
<B><FONT SIZE=2>LONG</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<I><B><FONT SIZE=2>FPOP</FONT></B></I>
</CENTER>

</TD><TD><FONT SIZE=2>Operand Register</FONT></TD></TR>

</TABLE>

<P>

<P>
To execute a floating point instruction, use the following protocol
for communicating data with the 6888x:
<P>
1. Wait for the chip to be idle.
<P>
2. Write a valid 6888x command to <I><B>FPCMD</B></I>.
<P>
3. If necessary for the command, write an operand to <I><B>FPOP</B></I>.
<P>
4. Wait for the status port to indicate the command is complete.
<P>
5. Read any return data from <I><B>FPOP</B></I>.
<P>
Step one is achieved by waiting for a value of 0x0802 to appear
in the status register (after ANDing with 0xBFFF) as follows:
<PRE>
while( ( FPCIR &amp; 0xBFFF) != 0x0802 ) ;
</PRE>

<P>
Steps two and three involve writing the command word to <I><B>FPCMD</B></I>
and any necessary operand data to <I><B>FPOP</B></I>. A primitive
response code will be generated (and should be read) between each
write to either <I><B>FPCMD</B></I> or <I><B>FPOP</B></I>. For
a listing of primitive response codes returned by the 68881, consult
the <B>MC68881/68882<a name=float> Floating-Point Coprocessor User's Manual
(2nd edition), Motorola publication MC68881UM/AD rev. 2, ISBN
0-13-567-009-8</B>.
<P>
After the operation is complete (step 4), data may be read from
the 68881 in <I><B>FPOP</B></I> (step 5).
<P>
When sending or receiving data in <B>FPOP</B>, the following chart
details the transfer ordering and alignment:
<center><br><img src="../graphics/chap55.gif"></center>
<P>
The following code demonstrates transferring two single precision
floating-point numbers to the 68881, multiplying them, and returning
the result.
<PRE>
/* Number of iterations before an error is triggered */
#define FPCOUNT		0x80		

#define FPCIR			((WORD *)(0xFFFFFA40L))
#define FPCMD			((WORD *)(0xFFFFFA4AL))
#define FPOP			((float *)(0xFFFFFA50L))

WORD fpcount, dum;

/* fperr() is user-defined */

#define FPwait() { 	fpcount = FPCOUNT; \
					while((*FPCIR &amp; 0xBFFF) != 0x0802) \
						if(!(--fpcount)) fperr();	 }

#define FPsglset(r,v) { FPwait(); \
					  *FPCMD = (0x5400 | ((r) &lt;&lt; 7)); \
					  while((*FPCIR &amp; 0xFFF0) != 0x8C00) \
						if(!(--fpcount)) fperr();		\
					  *FPOP = (v); }

#define FPsglmul(r1,r2) { 	FPwait();	\
						*FPCMD = (0x0027 | ((r2) &lt;&lt; 10) | ((r1) &lt;&lt; 7));		\
						dum = *FPCIR + 1;	}

/* dum = FPCIR +1; forces the status register to be read
   (we assume the data's good) */

#define FPsglget(r,var) {	FPwait();	\
						*FPCMD = (0x6400 | ((r) &lt;&lt; 7));		\
						while(*FPCIR != 0xb104)		\
							if(!(--fpcount)) fperr();		\
						var = *FPOP;		}							

/*
 * void sglmul( float *f1, float *f2 );
 *
 * Multiplies f1 by f2. Returns result in f1.
 *
 */

void
sglmul( float &amp;f1, float &amp;f2 )
{
	FPsglset( 0, *f1 );
	FPsglset( 1, *f2 );
	FPsglmul( 0, 1 );
	FPsglget( 0, *f1 );
}

</PRE>

<HR>

<a name=carts><H4><FONT SIZE=4 >Cartridges</FONT></H4>

<HR>

<P>
All Atari computers support an external 128K ROM cartridge port.
Cartridges may be created to support applications or diagnostic
tools. The 128K of address space allocated to cartridges appears
from address 0xFA0000 to 0xFBFFFF. Newer Atari computers support
larger cartridges (this is because the address space would no
longer overlap the OS). All program code must be compiled to be
relative of this base address.
<P>
The <B>LONG</B> appearing at 0xFA0000 determines the type of cartridge
installed as follows:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Cartridge</FONT></B></TH>
<TH>
<CENTER>
<B><FONT SIZE=2 >LONG Value</FONT></B>
</CENTER>

</TH></TR>

<TR><TD>Application</TD><TD>
<CENTER>
<FONT SIZE=2>0xABCDEF42</FONT>
</CENTER>

</TD></TR>

<TR><TD>Diagnostic</TD><TD>
<CENTER>
<FONT SIZE=2>0xFA52255F</FONT>
</CENTER>

</TD></TR>

</TABLE>

<P>
 
<H5>Diagnostic Cartridges</H5>

<P>
Diagnostic cartridges are executed almost immediately after a
system reset. The OS uses a 680x0 JMP instruction to begin execution
at address 0xFA0004 after having set the <a name=ipl>Interrupt Priority Level
(IPL) to 7, entering supervisor mode, and executing a RESET instruction
to reset external hardware devices.
<P>
Upon execution, register A6 will contain a return address which
should be JMP'd to if you wish to continue system initialization
at any point. The stack pointers will contain garbage. In addition,
keep in mind that no hardware has been initialized, particularly
the memory controller. All system memory sizing and initialization
must be performed by the diagnostic cartridge.
<H5>Application Cartridges</H5>

<P>
Application cartridges should contain one or more application
headers beginning at location 0xFA0004 as follows (one cartridge
may contain one or many applications):
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Name</FONT></B></TH><TH>
<CENTER>
<B><FONT SIZE=2 >Offset</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Meaning</FONT></B></TH>
</TR>

<TR><TH><B>CA_NEXT</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x00</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Pointer to the next application header (or <B>NULL</B> if there are no more).</FONT>
</TD></TR>

<TR><TH><B>CA_INIT</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x04</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Pointer to the application's initialization code. The high eight bits of this pointer have a special meaning as follows:</FONT> <U><B>Bit Set Meaning</B></U>
<P>
<FONT SIZE=2> 0 Execute prior to display</FONT>
<P>
<FONT SIZE=2>  memory and interrupt</FONT>
<P>
<FONT SIZE=2>  vector initialization.</FONT>
<P>
<FONT SIZE=2> 1 Execute just before</FONT>
<P>
<FONT SIZE=2>  <B>GEMDOS</B> is initialized.</FONT>
<P>
<FONT SIZE=2> 2 (unused)</FONT>
<P>
<FONT SIZE=2> 3 Execute prior to boot</FONT>
<P>
<FONT SIZE=2>  disk.</FONT>
<P>
<FONT SIZE=2> 4 (unused)</FONT>
<P>
<FONT SIZE=2> 5 Application is a Desk</FONT>
<P>
<FONT SIZE=2>  Accessory.</FONT>
<P>
<FONT SIZE=2> 6 Application is not a <B>GEM</B>   application.</FONT>
<P>
<FONT SIZE=2> 7 Application needs</FONT>
<P>
<FONT SIZE=2>  parameters.</FONT>
</TD></TR>

<TR><TH><B>CA_RUN</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x08</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Pointer to application's main entry point.</FONT>
</TD></TR>

<TR><TH><B>CA_TIME</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x0C</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Standard <B>GEMDOS</B> time stamp.</FONT>
</TD></TR>

<TR><TH><B>CA_DATE</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x0E</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Standard <B>GEMDOS</B> date stamp.</FONT>
</TD></TR>

<TR><TH><B>CA_SIZE</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x10</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Size of application in bytes.</FONT></TD>
</TR>

<TR><TH><B>CA_NAME</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x14</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2>NULL</FONT></B> terminated ASCII filename in standard <B>GEMDOS</B> 8+3 format.
</TD></TR>

</TABLE>

<P>

<P>
When application cartridges are present, <B>GEMDOS</B> will allow
a special 'c' (lowercase) drive to be accessed. Executable files
appear on this drive as they would on any standard disk. This
'drive' may also be installed on the desktop.
<HR>

<a name=game><a name=gamecontrollers><H4><FONT SIZE=4 >Game Controllers</FONT></H4>

<HR>

<P>
The Atari 1040STe and Falcon030 support new <a name=enhjoystick>enhanced joystick
controls as well as older style <a name=cx40>CX-40 controls. For the usage and polling of the older style controls, refer to the following
section which discusses the IKBD controller. This section will
focus specifically on the newer style of controllers.
<a name=joysticks><H5>Joysticks</H5>

<P>
Enhanced joysticks are read by a two-step process. The <B>WORD</B>
at address 0xFF9202 is written to using a mask which determines
which values may subsequently be read from the <B>WORD</B>s at
address 0xFF9200 and 0xFF9202. Valid mask values and the keys
that may be read follow:
<TABLE BORDER=1>

<TR><TH COLSPAN=3>
<CENTER>
<B>Read Controller 0 at 0xFF9200</B>
</CENTER>

</TH></TR>

<TR><TH>
<CENTER>
<B><FONT SIZE=1 >Write</FONT></B>
</CENTER>

<P>

<CENTER>
<B><FONT SIZE=1 >Mask</FONT></B>
</CENTER>

</TH><TD>
<CENTER>
<B><FONT SIZE=1 >Bit 0 Clear</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=1 >Bit 1 Clear</FONT></B>
</CENTER>

</TD></TR>

<TR><TD>
<CENTER>
0xFFFE
</CENTER>
</TD><TD>
<CENTER>
Pause
</CENTER>

</TD><TD>
<CENTER>
Fire 0
</CENTER>
</TD></TR>

<TR><TD>
<CENTER>
0xFFFD
</CENTER>
</TD><TD>
<CENTER>
-
</CENTER>

</TD><TD>
<CENTER>
Fire 1
</CENTER>
</TD></TR>

<TR><TD>
<CENTER>
0xFFFB
</CENTER>
</TD><TD>
<CENTER>
-
</CENTER>

</TD><TD>
<CENTER>
Fire 2
</CENTER>
</TD></TR>

<TR><TD>
<CENTER>
0xFFF7
</CENTER>
</TD><TD>
<CENTER>
-
</CENTER>

</TD><TD>
<CENTER>
Option
</CENTER>
</TD></TR>

</TABLE>

<P>

<TABLE BORDER=1>

<TR><TH COLSPAN=3>
<CENTER>
<B>Read Controller 1 at 0xFF9200</B>
</CENTER>

</TH></TR>

<TR><TH>
<CENTER>
<B><FONT SIZE=1 >Write</FONT></B>
</CENTER>

<P>

<CENTER>
<B><FONT SIZE=1 >Mask</FONT></B>
</CENTER>

</TH><TD>
<CENTER>
<B><FONT SIZE=1 >Bit 2 Clear</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=1 >Bit 3 Clear</FONT></B>
</CENTER>

</TD></TR>

<TR><TD>
<CENTER>
0xFFEF
</CENTER>
</TD><TD>
<CENTER>
Pause
</CENTER>

</TD><TD>
<CENTER>
Fire 0
</CENTER>
</TD></TR>

<TR><TD>
<CENTER>
0xFFDF
</CENTER>
</TD><TD>
<CENTER>
-
</CENTER>

</TD><TD>
<CENTER>
Fire 1
</CENTER>
</TD></TR>

<TR><TD>
<CENTER>
0xFFBF
</CENTER>
</TD><TD>
<CENTER>
-
</CENTER>

</TD><TD>
<CENTER>
Fire 2
</CENTER>
</TD></TR>

<TR><TD>
<CENTER>
0xFF7F
</CENTER>
</TD><TD>
<CENTER>
-
</CENTER>

</TD><TD>
<CENTER>
Option
</CENTER>
</TD></TR>

</TABLE>

<P>

<TABLE BORDER=1>

<TR><TH COLSPAN=5>
<CENTER>
<B>Read Controller 0 at 0xFF9202</B>
</CENTER>

</TH></TR>

<TR><TH>
<CENTER>
<B><FONT SIZE=1 >Write</FONT></B>
</CENTER>

<P>

<CENTER>
<B><FONT SIZE=1 >Mask</FONT></B>
</CENTER>

</TH><TD>
<CENTER>
<B><FONT SIZE=1 >Bit 8 Clear</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=1 >Bit 9 Clear</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=1 >Bit 10 Clear</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=1 >Bit 11 Clear</FONT></B>
</CENTER>

</TD></TR>

<TR><TD>
<CENTER>
0xFFFE
</CENTER>
</TD><TD>
<CENTER>
Up
</CENTER>

</TD><TD>
<CENTER>
Down
</CENTER>
</TD><TD>
<CENTER>
Left
</CENTER>

</TD><TD>
<CENTER>
Right
</CENTER>
</TD></TR>

<TR><TD>
<CENTER>
0xFFFD
</CENTER>
</TD><TD>
<CENTER>
Key *
</CENTER>

</TD><TD>
<CENTER>
Key 7
</CENTER>
</TD><TD>
<CENTER>
Key 4
</CENTER>

</TD><TD>
<CENTER>
Key 1
</CENTER>
</TD></TR>

<TR><TD>
<CENTER>
0xFFFB
</CENTER>
</TD><TD>
<CENTER>
Key 0
</CENTER>

</TD><TD>
<CENTER>
Key 8
</CENTER>
</TD><TD>
<CENTER>
Key 5
</CENTER>

</TD><TD>
<CENTER>
Key 2
</CENTER>
</TD></TR>

<TR><TD>
<CENTER>
0xFFF7
</CENTER>
</TD><TD>
<CENTER>
Key #
</CENTER>

</TD><TD>
<CENTER>
Key 9
</CENTER>
</TD><TD>
<CENTER>
Key 6
</CENTER>

</TD><TD>
<CENTER>
Key 3
</CENTER>
</TD></TR>

</TABLE>

<P>

<TABLE BORDER=1>

<TR><TH COLSPAN=5>
<CENTER>
<B>Read Controller 1 at 0xFF9202</B>
</CENTER>

</TH></TR>

<TR><TH>
<CENTER>
<B><FONT SIZE=1 >Mask</FONT></B>
</CENTER>

</TH><TD>
<CENTER>
<B><FONT SIZE=1 >Bit 12 Clear</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=1 >Bit 13 Clear</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=1 >Bit 14 Clear</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=1 >Bit 15 Clear</FONT></B>
</CENTER>

</TD></TR>

<TR><TD>
<CENTER>
0xFFEF
</CENTER>
</TD><TD>
<CENTER>
Up
</CENTER>

</TD><TD>
<CENTER>
Down
</CENTER>
</TD><TD>
<CENTER>
Left
</CENTER>

</TD><TD>
<CENTER>
Right
</CENTER>
</TD></TR>

<TR><TD>
<CENTER>
0xFFDF
</CENTER>
</TD><TD>
<CENTER>
Key *
</CENTER>

</TD><TD>
<CENTER>
Key 7
</CENTER>
</TD><TD>
<CENTER>
Key 4
</CENTER>

</TD><TD>
<CENTER>
Key 1
</CENTER>
</TD></TR>

<TR><TD>
<CENTER>
0xFFBF
</CENTER>
</TD><TD>
<CENTER>
Key 0
</CENTER>

</TD><TD>
<CENTER>
Key 8
</CENTER>
</TD><TD>
<CENTER>
Key 5
</CENTER>

</TD><TD>
<CENTER>
Key 2
</CENTER>
</TD></TR>

<TR><TD>
<CENTER>
0xFF7F
</CENTER>
</TD><TD>
<CENTER>
Key #
</CENTER>

</TD><TD>
<CENTER>
Key 9
</CENTER>
</TD><TD>
<CENTER>
Key 6
</CENTER>

</TD><TD>
<CENTER>
Key 3
</CENTER>
</TD></TR>

</TABLE>

<P>

<P>
To read the joystick, write a mask value corresponding to the
row of keys/positions you wish to interrogate to 0xFF9202. Next,
read back a <B>WORD</B> from either 0xFF9200 or 0xFF9202. As indicated
in the table, cleared bits mean that a key is being pressed or
a joystick is moved in that direction.
<a name=paddles><H5>Paddles</H5>

<P>
Two paddles may be plugged into each joystick port. Each paddle
returns an 8-bit value indicating its position ( 0 = full counter-clockwise,
255 = full clockwise) at the addresses shown below. Unlike joysticks,
paddle positions are returned automatically with no need to write
to an address prior to a read. Paddle fire buttons, however, are
mapped and read in the same manner as the joysticks. See the discussion
of joysticks above for an explanation.
<TABLE BORDER=1>

<TR><TH>
<CENTER>
<B><FONT SIZE=1 >Byte Address</FONT></B>
</CENTER>

</TH><TH>
<CENTER>
<B><FONT SIZE=1 >Paddle</FONT></B>
</CENTER>

</TH></TR>

<TR><TD>
<CENTER>
0xFF9211
</CENTER>
</TD><TD>
<CENTER>
X Paddle 0
</CENTER>

</TD></TR>

<TR><TD>
<CENTER>
0xFF9213
</CENTER>
</TD><TD>
<CENTER>
Y Paddle 0
</CENTER>

</TD></TR>

<TR><TD>
<CENTER>
0xFF9215
</CENTER>
</TD><TD>
<CENTER>
X Paddle 1
</CENTER>

</TD></TR>

<TR><TD>
<CENTER>
0xFF9217
</CENTER>
</TD><TD>
<CENTER>
Y Paddle 1
</CENTER>

</TD></TR>

</TABLE>

<P>

<a name=lightgun><H5>Light Gun/Pen</H5>

<P>
Joystick port 0 supports a light gun or pen. The position that
the gun is pointing to is returned in the <B>WORD</B> registers
at 0xFF9220 (X position) and 0xFF9222 (Y position). Only the lower
10 bits are significant giving a range of values from 0-1023.
<HR>

<a name=ikbd><H4><FONT SIZE=4 >The IKBD Controller</FONT></H4>

<HR>

<P>
<a name=6850>The Atari 16/32 bit computer line uses the Intelligent Keyboard
Controller (IKBD) for keyboard, joystick (old-style CX-40), mouse,
and clock communication. The 6850 ACIA serial communications chip
is used to transfer data packets from the IKBD interface to the
host computer.
<P>
The <B>TOS</B> calls <B>Bconout(</B> 4, ??? <B>)</B>, <B>Ikbdws()</B>,
and <B>Initmous()</B> handle communication to the controller.
Return messages from the controller must be processed by placing
a specialized handler in the vector table returned by the <B>XBIOS</B>
call <B>Kbdvbase()</B>. <B>Kbdvbase()</B> returns the pointer
to a vector table as follows:
<PRE>
typedef struct
{
void (*midivec)( UBYTE data );		/* Passed in d0 */
	void (*vkbderr)( UBYTE data );		/* Passed in d0 */
	void (*vmiderr)( UBYTE data );		/* Passed in d0 */
	void (*statvec)( char *packet );		/* Passed in a0 */
	void (*mousevec)( char *packet );		/* Passed in a0 */
	void (*clockvec)( char *packet );		/* Passed in a0 */
	void (*joyvec)( char *packet );		/* Passed in a0 */
	void (*midisys)( VOID );
	void (*ikbdsys)( VOID );
	char ikbdstate;
} KBDVECS;

</PRE>

<P>
When an IKBD message is pending, the interrupt handler for the
ACIAs calls either the <a name=midi>midisys handler or the ikbdsys handler
to retrieve the data and handle any errors. The default action
for the <I>ikbdsys</I> handler is to decide whether the packet
contains error, status, joystick, clock, or mouse information
and to route it appropriately to <I>vkbderr</I>, <I>statvec</I>,
<I>joyvec</I>, <I>clockvec</I>, or <I>mousevec</I>. Keyboard packets
are handled internally by <I>ikbdsys</I>.
<P>
Your handler should be patched into the appropriate vector and,
if appropriate, expect the packet buffer to be pointed to by register
A0. Unless your handler is designed to completely replace the
functions of the default handler you should jump through the original
vector pointer upon exit, otherwise simply use the 680x0 RTS instruction.
<P>
Each byte received through the keyboard ACIA falls into one of
the following categories as follows:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Category</FONT></B></TH>
<TH><B><FONT SIZE=1 >Value(s)</FONT></B></TH><TH><B><FONT SIZE=1 >Meaning</FONT></B>
</TH></TR>

<a name=makecodes><TR><TD>Keyboard Make Code</TD><TD>0x00-0x7F</TD><TD>One of these values is generated each time a key is depressed.This value may be used with <B>Keytbl()</B> to generate an ASCII code for the scan code.
</TD></TR>

<TR><TD>Keyboard Break Code</TD><TD>0x80-0xFF</TD><TD>This code is generated when a key previously depressed has been released. It represents the make code logically OR'ed with 0x80.
</TD></TR>

<TR><TD>Status Packet Header</TD><TD>0xF6</TD><TD>This codes indicate the beginning of a multiple byte status packet.
</TD></TR>

<TR><TD>Absolute Mouse Position</TD><TD>0xF7</TD><TD>See Below
</TD></TR>

<TR><TD>Relative Mouse Position</TD><TD>0xF8-0xFB</TD><TD>See Below
</TD></TR>

<TR><TD>Time-of-Day </TD><TD>0xFC</TD><TD>See Below</TD></TR>

<TR><TD>Joystick Report</TD><TD>0xFD</TD><TD>See Below</TD></TR>

<TR><TD>Joystick 0 Event</TD><TD>0xFE</TD><TD>See Below</TD></TR>

<TR><TD>Joystick 1 Event</TD><TD>0xFF</TD><TD>See Below</TD></TR>

<TR><TD>Status Packet Data</TD><TD>Any</TD><TD>When the <I>ikbdstate</I> variable (found in the <B>KBDVECS</B> structure) is non-zero, it represents the number of remaining bytes to retrieve that are part of a status packet and should thus not be treated as any of the above codes.
</TD></TR>

</TABLE>

<P>

<a name=keyboard><H5>The Keyboard</H5>

<P>
Keyboard keys generate both a 'make' and 'break' code for each
complete press and release respectively. The 'make' code is equivalent
to the high byte of the IKBD scan code. 'make' codes are not related
in any way to ASCII codes. They represent the physical position
of the key in the keyboard matrix and may vary in keyboards designed
for other countries. The <B>XBIOS</B> function <B>Keytbl()</B>
provides lookup values which make internationalization possible.
The key 'break' code is the 'make' code logically ORed with 0x80.
<P>
It should be noted that 'key repeats' are not generated by the
ACIA but by a coordination of the <I>ikbdsys</I> and system timer
handlers.
<a name=mouse><H5>The Mouse</H5>

<P>
The mouse may be programmed to return position reports in either
absolute, relative, or keycode mode (it is by default programmed
to return relative position reports).
<P>
In relative reporting mode, the IKBD generates a mouse packet
each time a mouse button is pressed or released, and every time
the mouse is moved over a preset threshold distance (which is
configurable). A relative mouse report packet is headed by a byte
value between 0xF8 and 0xFB followed by the X and Y movement of
the mouse as signed bytes. If the movement is greater than can
be represented as signed bytes (-128 to 127), multiple packets
are sent. 
<P>
The header byte determines the state of the mouse buttons as follows:
<TABLE BORDER=1>

<TR><TH>
<CENTER>
<B><FONT SIZE=1 >Header</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Mouse Button State</FONT></B>
</TH></TR>

<TR><TD>
<CENTER>
0xF8
</CENTER>
</TD><TD><FONT SIZE=2>No buttons depressed.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0xF9
</CENTER>
</TD><TD><FONT SIZE=2>Left button depressed.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0xFA
</CENTER>
</TD><TD><FONT SIZE=2>Right button depressed.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0xFB
</CENTER>
</TD><TD><FONT SIZE=2>Both buttons depressed.</FONT>
</TD></TR>

</TABLE>

<P>

<P>
In absolute reporting mode, the IKBD only generates a mouse packet
when interrogated. Mouse packets in absolute mode are headed by
a 0xF7 byte followed by the MSB and LSB of the X value and the
MSB and LSB of the Y value respectively. The minimum and maximum
X and Y values are user-definable.
<P>
<a name=break>
Keycode reporting mode generates keyboard 'make' and 'break' codes
for mouse movements rather than sending standard mouse packets.
Mouse movement is translated into the arrow keys and the codes
0x74 and 0x75 represent the left and right mouse button respectively.
'break' codes are sent immediately after the corresponding 'make'
code is delivered.
<a name=joysticks2><H5>The Joystick</H5>

<P>
The basic CX-40 style joystick controls are still present on every
Atari computer. Atari recommends that these ports should not be
supported when STe/Falcon030 enhanced joysticks are present unless
the option for four-player play is desired. While no direct <B>TOS</B>
support is available for reading these ports, it is possible using
the IKBD controller in one of several joystick reporting modes.
<P>
Joystick event reporting mode (the default) sends a joystick packet
each time the status of one of the joysticks changes. The joystick
packet header is 0xFE if the state of joystick 0 has changed or
0xFF if the status of joystick 1 has changed. This header byte
is followed by a <B>BYTE</B> containing the new state of the joystick
as follows:
<center><br><img src="../graphics/chap511.gif"></center>
<P>
The four bits corresponding to joystick position can be interpreted
as follows:
<P>
Joysticks may be interrogated at any time by sending an interrogate
command (as described later in this chapter). The packet response
to this command is 0xFD followed by the <B>BYTE</B> report of
joystick 0 and 1 (as shown above).
<P>
The joysticks may be placed into joystick monitoring or fire button
monitoring mode. In these modes, all other IKBD communication
is stopped and all processor time is devoted to the processing
of packets. Joystick monitoring mode cause the IKBD to send a
continuous stream of two-byte packets as follows: The first byte
contains the status of joystick buttons 0 and 1 in bits 1 and
0 respectively. The second byte contains the position state of
joystick 0 in the high nibble and joystick 1 in the lower nibble
(the position state can be interpreted as shown in the diagram
above).
<P>
Fire button monitoring mode constantly scans joystick button 1
and returns the results in <B>BYTE</B>s packed with 8 reports
each (one per bit). These modes may be paused or halted using
the appropriate commands.
<P>
Joystick keycode mode is similar to mouse keycode mode. This mode
translates all joystick position information into arrow keys.
A 'make' code of 0x74 is generated when joystick button 0 is depressed
and a 'make' code of 0x75 is generated when joystick button 1
is depressed. The rate at which the IKBD controller generates
these joystick events can be controlled using commands discussed
in the following section.
<H5>Time-of-Day</H5>

<P>
The IKBD controller maintains a separate time-of day clock that
is kept synchronized with <B>GEMDOS</B> time by OS calls. A time-of-day
packet may be requested using the method shown below under IKBD
commands.
<P>
The response packet from the IKBD is seven bytes in length identified
by its header byte of 0xFC and followed by six UBYTES containing
the year (last two digits), month, day, hours (0-24), minutes,
and seconds in BCD format (ex: a month byte in December would
be 0x12).
<H5>IKBD Commands</H5>

<P>
Commands may be sent to the IKBD using any of the <B>TOS</B> function
calls described above. Some commands may generate packets while
other commands change the operating state of the IKBD controller.
Unrecognized command codes are treated as NOPs. The following
lists valid IKBD command codes:
<TABLE BORDER=1>

<TR><TH>
<CENTER>
<B><FONT SIZE=1 >Command BYTE</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Result</FONT></B></TH>
</TR>

<TR><TD>
<CENTER>
0x07
</CENTER>
</TD><TD><FONT SIZE=2>Set mouse button action. This command <B>BYTE</B> should be followed by a <B>BYTE</B> which describes how the mouse buttons should be treated as follows:</FONT> <U><B>BYTE Meaning</B></U>
<P>
<FONT SIZE=2> 0x00 Default mode.</FONT>
<P>
<FONT SIZE=2> 0x01 Mouse button press triggers an absolute</FONT>
<P>
<FONT SIZE=2>  position report.</FONT>
<P>
<FONT SIZE=2> 0x02 Mouse button release triggers an     absolute position report.</FONT>
<P>
<FONT SIZE=2> 0x03 Mouse button press and release triggers</FONT>
<P>
<FONT SIZE=2>  absolute position reports.</FONT>
<P>
<FONT SIZE=2> 0x04 Mouse buttons report key presses.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x08
</CENTER>
</TD><TD><FONT SIZE=2>Enable relative mouse position reporting (default).</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x09
</CENTER>
</TD><TD><FONT SIZE=2>Enable absolute mouse position reporting. This command is followed by the MSB and LSB of the X and Y coordinate maximum values for the mouse.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x0A
</CENTER>
</TD><TD><FONT SIZE=2>Enable mouse keycode mode. This command is followed by two <B>BYTE</B>s indicating the maximum number of mouse 'ticks' required to generate a keycode for the X and Y axis respectively.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x0B
</CENTER>
</TD><TD><FONT SIZE=2>Set mouse threshold. This command is followed by two <B>BYTE</B>s which determine the number of mouse 'ticks' required to generate a mouse position report in relative positioning mode.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x0C
</CENTER>
</TD><TD><FONT SIZE=2>Set mouse scale. This command is followed by two <B>BYTE</B>s which determine the number of mouse 'ticks' for each single coordinate on the X and Y axis respectively.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x0D
</CENTER>
</TD><TD><FONT SIZE=2>Interrogate mouse position. This command generates an absolute mouse position report.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x0E
</CENTER>
</TD><TD><FONT SIZE=2>Load mouse position. This command sets the mouse position based on the current coordinate system in absolute reporting mode. The command is followed by a filler <B>BYTE</B> of 0x00 and the MSB and LSB of the new X and Y axis for the mouse. </FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x0F
</CENTER>
</TD><TD><FONT SIZE=2>Set Y=0 to the bottom. This command changes the origin of the mouse coordinate system to the upper left of the screen.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x10
</CENTER>
</TD><TD><FONT SIZE=2>Set Y=0 to the top. This command changes the origin of the mouse coordinate system to the lower left of the screen.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x11
</CENTER>
</TD><TD><FONT SIZE=2>Resume sending data. This command (or for that matter any command) will cause the IKBD to resume sending packet data to the host.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x12
</CENTER>
</TD><TD><FONT SIZE=2>Disable all mouse packet reporting. Any valid mouse command resets this state. If the mouse buttons have been programmed to act like keyboard keys, this command will have no effect on them.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x13
</CENTER>
</TD><TD><FONT SIZE=2>Pause output. All output from the IKBD controller is halted until a 'Resume' or other command is received.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x14
</CENTER>
</TD><TD><FONT SIZE=2>Set joystick event reporting mode. This command causes a joystick report to be generated whenever the state of either joystick changes.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x15
</CENTER>
</TD><TD><FONT SIZE=2>Set joystick interrogation mode. This command causes the IKBD to generate joystick packets only when requested by the host.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x16
</CENTER>
</TD><TD><FONT SIZE=2>Joystick interrogation. This command causes a joystick packet indicating the status of both joysticks to be generated.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x17
</CENTER>
</TD><TD><FONT SIZE=2>Enables joystick monitoring mode. Besides serial communication and the maintenance of the time-of-day clock, this command causes only special joystick reports to be generated.</FONT>
<P>
<FONT SIZE=2>The command <B>BYTE</B> should be followed by a <B>BYTE</B> indicating how often the joystick should be polled in increments of 1/100ths of a second.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x18
</CENTER>
</TD><TD><FONT SIZE=2>Enables fire button monitoring mode. As above, this mode limits the IKBD to serial communication, updating the time-of-day clock, and the reporting of the state of joystick button 1.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x19
</CENTER>
</TD><TD><FONT SIZE=2>Set joystick keycode mode. This command is followed by six <B>BYTE</B>s as follows:</FONT> <U><B>BYTE Meaning</B></U>
<P>
<FONT SIZE=2> 1 The length of time (in tenths of a</FONT>
<P>
<FONT SIZE=2>  second) before the horizontal breakpoint is</FONT>
<P>
<FONT SIZE=2>   reached.</FONT>
<P>
<FONT SIZE=2> 2 Same as above for the vertical plane.</FONT>
<P>
<FONT SIZE=2> 3 The length of time (in tenths of a</FONT>
<P>
<FONT SIZE=2>  second) between key repeats before the</FONT>
<P>
<FONT SIZE=2>  velocity breakpoint is reached.</FONT>
<P>
<FONT SIZE=2> 4 Same as above for the vertical plane.</FONT>
<P>
<FONT SIZE=2> 5 The length of time (in tenths of a</FONT>
<P>
<FONT SIZE=2>  second) between key repeats after the</FONT>
<P>
<FONT SIZE=2>  velocity breakpoint is reached.</FONT>
<P>
<FONT SIZE=2> 6 Same as above for the vertical plane.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x1A
</CENTER>
</TD><TD><FONT SIZE=2>Disable joystick event reporting.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x1B
</CENTER>
</TD><TD><FONT SIZE=2>Set the time of day clock. This command is followed by six <B>BYTE</B>s used to set the IKBD clock. These <B>BYTE</B>s are in binary-coded decimal (BCD) format. Each <B>BYTE</B> contains two digits (0-9), one in each nibble. The format for these <B>BYTE</B>s is as follows:</FONT><U><B> BYTE Meaning</B></U>
<P>
<FONT SIZE=2> 1 Year (last two digits)</FONT>
<P>
<FONT SIZE=2> 2 Month</FONT>
<P>
<FONT SIZE=2> 3 Date</FONT>
<P>
<FONT SIZE=2> 4 Hours (0-23)</FONT>
<P>
<FONT SIZE=2> 5 Minutes (0-59)</FONT>
<P>
<FONT SIZE=2> 6 Seconds (0-59) </FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x1C
</CENTER>
</TD><TD><FONT SIZE=2>Interrogate the time-of-day clock. This command returns a packet headed by the value 0xFC followed by six <B>BYTE</B>s as indicated above.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x20
</CENTER>
</TD><TD><FONT SIZE=2>Load <B>BYTE</B>s into the IKBD memory. This command is followed by at least three <B>BYTE</B>s containing the MSB and LSB of the address into which to load the data, the number of <B>BYTE</B>s to load (0-127), and the data itself.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x21
</CENTER>
</TD><TD><FONT SIZE=2>Read <B>BYTE</B>s from the IKBD controller. This command is followed by two <B>BYTE</B>s containing the MSB and LSB of the address to read from. This returns a packet headed by the <B>BYTE</B> values 0xF6 and 0x20 followed by the memory data. </FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x22
</CENTER>
</TD><TD><FONT SIZE=2>Execute a subroutine on the IKBD controller. This command <B>BYTE</B> is followed by two <B>BYTE</B>s containing the MSB and LSB of the memory location of the subroutine to execute.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x80
</CENTER>
</TD><TD><FONT SIZE=2>Reset the IKBD controller. This command is actually a two-<B>BYTE</B> command. The <B>BYTE</B> 0x80 must be followed by a <B>BYTE</B> of 0x01 or the command will be ignored.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x87
</CENTER>
</TD><TD><FONT SIZE=2>Return a status message containing the current mouse action state. After receiving this command the IKBD will respond by sending a status packet (which may be intercepted at <I>statvec</I>) as follows:</FONT> <U><B>BYTE Meaning</B></U>
<P>
<FONT SIZE=2> 1 0xF6</FONT>
<P>
<FONT SIZE=2> 2 0x07</FONT>
<P>
<FONT SIZE=2> 3 Current mouse action state</FONT>
<P>
<FONT SIZE=2>  (see command 0x07)</FONT>
<P>
<FONT SIZE=2> 4-8 0</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x88
</CENTER>
</TD><TD><FONT SIZE=2>Return a status message containing the current mouse mode. After receiving this command the IKBD will respond by sending a status packet (which may be intercepted at <I>statvec</I>) as follows:</FONT> <U><B>BYTE Meaning</B></U>
<P>
<FONT SIZE=2> 1 0xF6</FONT>
<P>
<FONT SIZE=2> 2 Current mode as follows:</FONT>
<P>
<FONT SIZE=2>   0x08 = Relative mode</FONT>
<P>
<FONT SIZE=2>   0x09 = Absolute mode</FONT>
<P>
<FONT SIZE=2>   0x0A = Keycode mode</FONT>
<P>
<FONT SIZE=2> 3 <I>Absolute mode:</I> MSB of maximum X</FONT>
<P>
<FONT SIZE=2>  position (units to current scale).</FONT>
<P>
<FONT SIZE=2>  <I>Keycode mode:</I> Horizontal distance</FONT>
<P>
<FONT SIZE=2>  threshold that must be passed prior to</FONT>
<P>
<FONT SIZE=2>  sending a keycode.</FONT>
<P>
<FONT SIZE=2>  <I>Relative mode:</I> 0</FONT>
<P>
<FONT SIZE=2> 4 <I>Absolute mode:</I> LSB of maximum X</FONT>
<P>
<FONT SIZE=2>  position.</FONT>
<P>
<FONT SIZE=2>  <I>Keycode mode:</I> Vertical distance</FONT>
<P>
<FONT SIZE=2>  threshold that must be passed prior to</FONT>
<P>
<FONT SIZE=2>  sending a keycode.</FONT>
<P>
<FONT SIZE=2>  <I>Relative mode</I>: 0</FONT>
<P>
<FONT SIZE=2> 5 <I>Absolute mode:</I> MSB of maximum Y</FONT>
<P>
<FONT SIZE=2>  position (units to current scale).</FONT>
<P>
<FONT SIZE=2>  <I>Keycode mode:</I> 0</FONT>
<P>
<FONT SIZE=2>  <I>Relative mode:</I> 0</FONT>
<P>
<FONT SIZE=2> 6 <I>Absolute mode:</I> LSB of maximum Y</FONT>
<P>
<FONT SIZE=2>  position.</FONT>
<P>
<FONT SIZE=2>  <I>Keycode mode:</I> 0</FONT>
<P>
<FONT SIZE=2>  <I>Relative mode:</I> 0</FONT>
<P>
<FONT SIZE=2> 7-8 0</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0X89
</CENTER>
</TD><TD><FONT SIZE=2>Same as 0x88.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0X8A
</CENTER>
</TD><TD><FONT SIZE=2>Same as 0x88.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x8B
</CENTER>
</TD><TD><FONT SIZE=2>Return a status message containing the current mouse threshold state. After receiving this command the IKBD will respond by sending a status packet (which may be intercepted at <I>statvec</I>) as follows:</FONT> <U><B>BYTE Meaning</B></U>
<P>
<FONT SIZE=2> 1 0xF6</FONT>
<P>
<FONT SIZE=2> 2 0x0B</FONT>
<P>
<FONT SIZE=2> 3 Number of horizontal mouse 'ticks' that</FONT>
<P>
<FONT SIZE=2>  must be traveled prior to sending a mouse</FONT>
<P>
<FONT SIZE=2>  packet.</FONT>
<P>
<FONT SIZE=2> 4 Number of vertical mouse 'ticks' that</FONT>
<P>
<FONT SIZE=2>  must be traveled prior to sending a mouse</FONT>
<P>
<FONT SIZE=2>  packet.</FONT>
<P>
<FONT SIZE=2> 5-8 0</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x8C
</CENTER>
</TD><TD><FONT SIZE=2>Return a status message containing the current mouse scaling factor. After receiving this command the IKBD will respond by sending a status packet (which may be intercepted at <I>statvec</I>) as follows:</FONT> <U><B>BYTE Meaning</B></U>
<P>
<FONT SIZE=2> 1 0xF6</FONT>
<P>
<FONT SIZE=2> 2 0x0C</FONT>
<P>
<FONT SIZE=2> 3 Horizontal mouse 'ticks' between a change</FONT>
<P>
<FONT SIZE=2>  in mouse position on the X axis.</FONT>
<P>
<FONT SIZE=2> 4 Vertical mouse 'ticks' between a change</FONT>
<P>
<FONT SIZE=2>  in mouse position on the Y axis.</FONT>
<P>
<FONT SIZE=2> 5-8 0</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x8F
</CENTER>
</TD><TD><FONT SIZE=2>Return a status message containing the current origin point of the Y axis used for mouse position reporting. After receiving this command the IKBD will respond by sending a status packet (which may be intercepted at <I>statvec</I>) as follows:</FONT> <U><B>BYTE Meaning</B></U>
<P>
<FONT SIZE=2> 1 0xF6</FONT>
<P>
<FONT SIZE=2> 2 0x0F = Bottom is (Y=0)</FONT>
<P>
<FONT SIZE=2>  0x10 = Top is (Y=0)</FONT>
<P>
<FONT SIZE=2> 3-8 0</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x90
</CENTER>
</TD><TD><FONT SIZE=2>Same as 0x8F.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x92
</CENTER>
</TD><TD><FONT SIZE=2>Return a status message containing the current state of mouse reporting. After receiving this command the IKBD will respond by sending a status packet (which may be intercepted at <I>statvec</I>) as follows:</FONT> <U><B>BYTE Meaning</B></U>
<P>
<FONT SIZE=2> 1 0xF6</FONT>
<P>
<FONT SIZE=2> 2 0x00 = Mouse reporting enabled.</FONT>
<P>
<FONT SIZE=2>  0x12 = Mouse reporting disabled.</FONT>
<P>
<FONT SIZE=2> 3-8 0</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x94
</CENTER>
</TD><TD><FONT SIZE=2>Return a status message containing the current joystick mode. After receiving this command the IKBD will respond by sending a status packet (which may be intercepted at <I>statvec</I>) as follows:</FONT> <U><B>BYTE Meaning</B></U>
<P>
<FONT SIZE=2> 1 0xF6</FONT>
<P>
<FONT SIZE=2> 2 Current mode as follows:</FONT>
<P>
<FONT SIZE=2>   0x14 = Event reporting mode</FONT>
<P>
<FONT SIZE=2>   0x15 = Interrogation mode</FONT>
<P>
<FONT SIZE=2>   0x19 = Keycode mode</FONT>
<P>
<FONT SIZE=2> 3 <I>Keycode mode:</I> This value represents the</FONT>
<P>
<FONT SIZE=2>  amount of time (in tenths of a second)</FONT>
<P>
<FONT SIZE=2>  that keycodes are returned to the host</FONT>
<P>
<FONT SIZE=2>  for horizontal position events at the initial</FONT>
<P>
<FONT SIZE=2>  velocity level (after this time expires, the</FONT>
<P>
<FONT SIZE=2>  secondary velocity level is used).</FONT>
<P>
<FONT SIZE=2>  <I>Event recording mode:</I> 0</FONT>
<P>
<FONT SIZE=2>  <I>Interrogation mode:</I> 0</FONT>
<P>
<FONT SIZE=2> 4 <I>Keycode mode:</I> Same as <B>BYTE</B> 3 for</FONT>
<P>
<FONT SIZE=2>  vertical events.</FONT>
<P>
<FONT SIZE=2>  <I>Event recording mode:</I> 0</FONT>
<P>
<FONT SIZE=2>  <I>Interrogation mode:</I> 0</FONT>
<P>
<FONT SIZE=2> 5 <I>Keycode mode:</I> This value represents the </FONT>
<P>
<FONT SIZE=2>  initial horizontal velocity level (in tenths of a </FONT>
<P>
<FONT SIZE=2>  second). This is the initial rate at which </FONT>
<P>
<FONT SIZE=2>  keycodes are generated.</FONT>
<P>
<FONT SIZE=2>  <I>Event recording mode:</I> 0</FONT>
<P>
<FONT SIZE=2>  <I>Interrogation mode:</I> 0</FONT>
<P>
<FONT SIZE=2> 6 <I>Keycode mode: </I>Same as byte 5 for vertical</FONT>
<P>
<FONT SIZE=2>  events. </FONT>
<P>
<FONT SIZE=2>  <I>Event recording mode:</I> 0</FONT>
<P>
<FONT SIZE=2>  <I>Interrogation mode:</I> 0</FONT>
<P>
<FONT SIZE=2> 7 <I>Keycode mode: </I>This value represents the</FONT>
<P>
<FONT SIZE=2>  secondary horizontal velocity level (in</FONT>
<P>
<FONT SIZE=2>  tenths of a second). This is the rate used</FONT>
<P>
<FONT SIZE=2>  after the amount of time specified in bytes</FONT>
<P>
<FONT SIZE=2>  3-4 expires.</FONT>
<P>
<FONT SIZE=2>  <I>Event recording mode:</I> 0</FONT>
<P>
<FONT SIZE=2>  <I>Interrogation mode:</I> 0</FONT>
<P>
<FONT SIZE=2> 8 <I>Keycode mode: </I>Same as byte 7 for vertical</FONT>
<P>
<FONT SIZE=2>  events.</FONT>
<P>
<FONT SIZE=2>  <I>Event recording mode:</I> 0</FONT>
<P>
<FONT SIZE=2>  <I>Interrogation mode:</I> 0</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x95
</CENTER>
</TD><TD><FONT SIZE=2>Same as 0x94.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x99
</CENTER>
</TD><TD><FONT SIZE=2>Same as 0x94.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
0x9A
</CENTER>
</TD><TD><FONT SIZE=2>Return a status message containing the current status of the joystick. After receiving this command the IKBD will respond by sending a status packet (which may be intercepted at <I>statvec</I>) as follows:</FONT> <U><B>BYTE Meaning</B></U>
<P>
<FONT SIZE=2> 1 0xF6</FONT>
<P>
<FONT SIZE=2> 2 0x00 = Joystick enabled</FONT>
<P>
<FONT SIZE=2>  0x1A = Joystick disabled</FONT>
<P>
<FONT SIZE=2> 3-8 0</FONT>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=sound><a name=stettdigitalsound><H4><FONT SIZE=4 >STe/TT030 DMA Sound</FONT></H4>

<HR>

<P>
The Atari STe, Mega STe, TT030, and Falcon030 are all equipped
with the ability to playback stereo digital audio. Only the Falcon030,
however, has supporting <B>XBIOS</B> calls which eliminate the
need for the programmer to directly access the sound system hardware.
Although the Falcon030 has a more sophisticated sound system than
the earlier Atari machines, the hardware registers have been kept
compatible so older applications should function as expected.
Programmers designing Falcon030 applications which use digital
audio should use the appropriate <B>XBIOS</B> calls.
<P>
The STe, MegaSTe, and TT030 support 8-bit monophonic or stereophonic
sound samples. Samples should be signed ( -128 to 127) with alternating
left and right channels (for stereo) beginning with the left channel.
Samples may be played at 50 kHz, 25 kHz, 12.5 kHz, or 6.25&nbsp;kHz
(6.25 kHz is not supported on the Falcon030).
<H5>DMA Sound Registers</H5>

<P>
Several hardware registers control DMA sound output as follows:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Address</FONT></B></TH>
<a name=blayout><TH><B><FONT SIZE=1 >Bit Layout</FONT></B></TH><TH><B><FONT SIZE=1 >Meaning</FONT></B>
</TH></TR>

<TR><TD>0xFF8900</TD><TD>
<PRE>
---- ---- ---- --cc
</PRE>

</TD><TD>Sound DMA Control</TD></TR>

<TR><TD>0xFF8902</TD><TD>
<PRE>
---- ---- 00xx xxxx
</PRE>

</TD><TD>Frame Base Address High (bits 21-16)</TD></TR>

<TR><TD>0xFF8904</TD><TD>
<PRE>
---- ---- xxxx xxxx
</PRE>

</TD><TD>Frame Base Address Middle (bits 15-8)</TD></TR>

<TR><TD>0xFF8906</TD><TD>
<PRE>
---- ---- xxxx xxx0
</PRE>

</TD><TD>Frame Base Address Low (bits 7-1)</TD></TR>

<TR><TD>0xFF8908</TD><TD>
<PRE>
---- ---- 00xx xxxx
</PRE>

</TD><TD>Frame Address Counter (bits 21-16)</TD></TR>

<TR><TD>0xFF890A</TD><TD>
<PRE>
---- ---- xxxx xxxx
</PRE>

</TD><TD>Frame Address Counter (bits 15-8)</TD></TR>

<TR><TD>0xFF890C</TD><TD>
<PRE>
---- ---- xxxx xxx0
</PRE>

</TD><TD>Frame Address Counter (bits 7-1)</TD></TR>

<TR><TD>0xFF890E</TD><TD>
<PRE>
---- ---- 00xx xxxx
</PRE>

</TD><TD>Frame End Address High (bits 21-16)</TD></TR>

<TR><TD>0xFF8910</TD><TD>
<PRE>
---- ---- xxxx xxxx
</PRE>

</TD><TD>Frame End Address Middle (bits 15-8)</TD></TR>

<TR><TD>0xFF8912</TD><TD>
<PRE>
---- ---- xxxx xxx0
</PRE>

</TD><TD>Frame End Address Low (bits 7-1)</TD></TR>

<TR><TD>0xFF8920</TD><TD>
<PRE>
0000 0000 m000 00rr
</PRE>

</TD><TD>Sound Mode Control</TD></TR>

</TABLE>

<P>

<P>
Addresses placed in the three groups of address pointer registers
must begin on an even address. In addition, only sounds within
the first 4 megabytes of memory may be accessed (this limitation
has been lifted on the Falcon030). Sounds may not be played from
alternate RAM.
<H5>Playing a Sound</H5>

<P>
To begin sound playback, place the start address of the sound
in the Frame Base Address registers. Place the address of the
end of the sound in the Frame End Address registers. The address
of the end of the sound should actually be the first byte in memory
past the last byte of the sample.
<P>
Set the Sound Mode Control register to the proper value. Bit 7,
notated as 'm' should be set to 1 for a monophonic sample or 0
for a stereophonic sample. Bits 0 and 1, notated as 'r', control
the sample playback rate as follows:
<TABLE BORDER=1>

<TR><TH>
<CENTER>
<B><FONT SIZE=1 >'r'</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Playback Rate</FONT></B>
</TH></TR>

<TR><TD>
<CENTER>
00
</CENTER>
</TD><TD><FONT SIZE=2>6258 Hz</FONT>
</TD></TR>

<TR><TD>
<CENTER>
01
</CENTER>
</TD><TD><FONT SIZE=2>12517 Hz</FONT>
</TD></TR>

<TR><TD>
<CENTER>
10
</CENTER>
</TD><TD><FONT SIZE=2>25033 Hz</FONT>
</TD></TR>

<TR><TD>
<CENTER>
11
</CENTER>
</TD><TD><FONT SIZE=2>50066 Hz</FONT>
</TD></TR>

</TABLE>

<P>
 
<P>
To begin the sample playback, set bits 0 and 1 of the Sound DMA
Control register, notated as 'c',  as follows:
<TABLE BORDER=1>

<TR><TH>
<CENTER>
<B><FONT SIZE=1 >'c'</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Sound Control</FONT></B>
</TH></TR>

<TR><TD>
<CENTER>
00
</CENTER>
</TD><TD><FONT SIZE=2>Sound Disabled (this will stop any sound currently being played)</FONT>
</TD></TR>

<TR><TD>
<CENTER>
01
</CENTER>
</TD><TD><FONT SIZE=2>Sound Enabled (play once)</FONT>
</TD></TR>

<TR><TD>
<CENTER>
11
</CENTER>
</TD><TD><FONT SIZE=2>Sound Enabled (repeat until stopped)</FONT>
</TD></TR>

</TABLE>

<P>

<P>
Sound playback may be prematurely halted by writing a 0 to address
0x00FF8900.
<H5>Sound Interrupts using MFP Timer A</H5>

<P>
Discontinuous sample frames may be linked together using the MFP
Timer A interrupt. When a sound is played using repeat mode an
interrupt is generated at the end of every frame. By configuring
Timer A to 'event count' mode you can ensure the seamless linkage
and variable repeating of frames.
<P>
For example, suppose you have three sample frames, A, B, and C,
in memory and you want to play A five times, B five times, and
C only once. Use the following steps to properly configure Timer
A and achieve the desired result:
<P>
 Use <B>Xbtimer()</B> to set Timer A to event count mode with
a data value of 4 (the first data value should be one less than
actually desired since the sound will play once before the interrupt
occurs).
<P>
 Configure the sound registers as desired and start sound playback
in repeat mode.
<P>
 When the interrupt fires, place the address of frame B in the
sound playback registers (these values aren't actually used until
the current frame finishes).
<P>
 Reset Timer A's data register to 5 and exit your interrupt handler.
<P>
 When the second interrupt fires, place the address of frame C
in the sound playback registers.
<P>
 Reset Timer A's data register to 1 and exit your interrupt handler.
<P>
 When the final interrupt is triggered, write a 0x01 to the sound
control register to cause sound playback to end at the end of
the current frame.
<H5>Sound Interrupts using GPIP 7</H5>

<P>
Another method of generating interrupts at the end of sound frames
is by using the MFP's General Purpose Interrupt Port (GPIP) 7.
This interrupt does not support an event count mode so it will
generate an interrupt at the end of every frame. In addition,
the interrupt must be configured differently depending on the
type on monitor connected to the system (this is because GPIP
7 serves double-duty as the monochrome detect signal).
<P>
To program GPIP 7 for interrupts, disable all DMA sound by placing
a 0x00 in the sound control register. Next, check bit 7 of the
GPIP port at location 0xFFFA01. If a monochrome monitor is connected
the bit will be 0. The bit will be 1 if a color monitor is connected.
<P>
Bit 7 of the MFP's active edge register (at 0xFFFA03) should be
set to the opposite of the GPIP port's bit 7. This will cause
an interrupt to trigger at the end of every frame. Use <B>Mfpint()</B>
to set the location of your interrupt handler and <B>Jenabint()</B>
to enable interrupts. From this point, interrupts will be generated
at the end of every frame playing in 'play once' mode or repeat
mode until the interrupt is disabled.
<HR>

<a name=interface><H4><FONT SIZE=4 ><a name=microwireinterface>The MICROWIRE Interface</FONT>
</H4>

<HR>

<P>
The STe and TT030 computers use the MICROWIRE interface to control
volume, mixing of the PSG and DMA output, and tone control. The
original ST is limited to amplitude control through the use of
the appropriate PSG register. The Falcon030 supports new <B>XBIOS</B>
calls which allow volume and mixing control.
<P>
The MICROWIRE interface is a write-only device accessed using
two hardware registers 0xFFFF8924 (mask) and 0xFFFF8922 (data).
To write a command to the MICROWIRE you must first place the value
0x07FF into the mask register and then write the appropriate command
to the data register. The format for the data <B>WORD</B> is shown
below:
<center><br><img src="../graphics/chap520.gif"></center>
<P>
Bits labeled 'x' will be ignored. Bits 9 and 10 should always
be %10 to correctly specify the device address which is a constant.
Bits labeled 'c' specify the command and bits labeled 'd' contain
the appropriate data for the command. The following table explains
the valid MICROWIRE commands:
<TABLE BORDER=1>

<TR><TH>
<CENTER>
<B><FONT SIZE=1 >Command</FONT></B>
</CENTER>

</TH><TH>
<CENTER>
<B><FONT SIZE=1 >'ccc'</FONT></B>
</CENTER>

</TH><TH>
<CENTER>
<B><FONT SIZE=1 >'dddddd'</FONT></B>
</CENTER>

</TH></TR>

<TR><TD>Set Master Volume</TD><TD>
<CENTER>
<FONT SIZE=2>011</FONT>
</CENTER>

</TD><TD><FONT SIZE=2> <U><B>Example Value Result</B></U></FONT>
<P>
<FONT SIZE=2> %000000 -80dB Attenuation</FONT>
<P>
<FONT SIZE=2> %010100 -40dB Attenuation</FONT>
<P>
<FONT SIZE=2> %101000 0dB Attenuation (Maximum)</FONT>
</TD></TR>

<TR><TD>Set Left Channel Volume</TD><TD>
<CENTER>
<FONT SIZE=2>101</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2> <U><B>Example Value Result</B></U></FONT></B>
<P>
<FONT SIZE=2> %000000 -40dB Attenuation</FONT>
<P>
<FONT SIZE=2> %001010 -20dB Attenuation</FONT>
<P>
<FONT SIZE=2> %010100 0dB Attenuation (Maximum)</FONT>
</TD></TR>

<TR><TD>Set Right Channel Volume</TD><TD>
<CENTER>
<FONT SIZE=2>100</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2> <U><B>Example Value Result</B></U></FONT></B>
<P>
<FONT SIZE=2> %000000 -40dB Attenuation</FONT>
<P>
<FONT SIZE=2> %001010 -20dB Attenuation</FONT>
<P>
<FONT SIZE=2> %010100 0dB Attenuation (Maximum)</FONT>
</TD></TR>

<TR><TD>Set Treble</TD><TD>
<CENTER>
<FONT SIZE=2>010</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2> <U><B>Example Value Result</B></U></FONT></B>
<P>
<FONT SIZE=2> %000000 -12dB Attenuation</FONT>
<P>
<FONT SIZE=2> %000110 0dB Attenuation</FONT>
<P>
<FONT SIZE=2> %001100 +12dB Attenuation (Maximum)</FONT>
</TD></TR>

<TR><TD>Set Bass</TD><TD>
<CENTER>
<FONT SIZE=2>001</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2> <U><B>Example Value Result</B></U></FONT></B>
<P>
<FONT SIZE=2> %000000 -12dB Attenuation</FONT>
<P>
<FONT SIZE=2> %000110 0dB Attenuation</FONT>
<P>
<FONT SIZE=2> %001100 +12dB Attenuation (Maximum)</FONT>
</TD></TR>

<TR><TD>Set PSG/DMA Mix</TD><TD>
<CENTER>
<FONT SIZE=2>000</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2> <U><B>Example Value Result</B></U></FONT></B>
<P>
<FONT SIZE=2> %000000 -12dB Attenuation</FONT>
<P>
<FONT SIZE=2> %000001 Mix PSG sound output.</FONT>
<P>
<FONT SIZE=2> %000010 Don't Mix PSG sound output.</FONT>
</TD></TR>

</TABLE>

<P>

<P>
When configuring multiple settings at once, you should program
a delay between writes since the MICROWIRE takes at least 16sec
to completely read the data register. During a read the MICROWIRE
rotates the mask register one bit at a time. You will know a read
operation has completed when the mask register returns to 0x07FF.
The following assembly segment illustrates this by setting the
left and right channel volumes to their maximum values:
<PRE>
MWMASK			EQU		$FFFF8924
MWDATA			EQU		$FFFF8922

MASKVAL			EQU		$7FF
HIGHLVOL		EQU		$554
HIGHRVOL		EQU		$514

			.text

maxvol:
			move.w	MASKVAL,MWMASK		; First write the mask and data values
			move.w	#HIGHLVOL,MWDATA
mwwrite:
			cmp.w	MASKVAL,MWMASK
			bne.s	mwwrite				; loop until MWMASK reaches $7FF again
			move.w	#HIGHRVOL,MWDATA		; ok, safe to write second value
			rts

			.end
</PRE>

<HR>

<a name=video><H4><FONT SIZE=4 >Video Hardware</FONT></H4>

<HR>

<H5>Video Resolutions</H5>

<P>
Atari computers support a wide range of video resolutions as shown
in the following tables:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Computer System</FONT></B>
</TH><TH>
<CENTER>
<B><FONT SIZE=2 >Modes</FONT></B>
</CENTER>

<P>

<CENTER>
<B><FONT SIZE=2 >(width <B> height  colors)</B></FONT></B>
</CENTER>

</TH><TH>
<CENTER>
<B><FONT SIZE=2 >Possible</FONT></B>
</CENTER>

<P>

<CENTER>
<B><FONT SIZE=2 >Colors</FONT></B>
</CENTER>

</TH></TR>

<TR><TD>ST, Mega ST</TD><TD>
<CENTER>
<FONT SIZE=2>320x200x16</FONT>
</CENTER>

<P>

<CENTER>
<FONT SIZE=2>640x200x4</FONT>
</CENTER>

<P>

<CENTER>
<FONT SIZE=2>640x400x2</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>512</FONT>
</CENTER>
</TD>
</TR>

<TR><TD>STe, Mega STe</TD><TD>
<CENTER>
<FONT SIZE=2>320x200x16</FONT>
</CENTER>

<P>

<CENTER>
<FONT SIZE=2>640x200x4</FONT>
</CENTER>

<P>

<CENTER>
<FONT SIZE=2>640x400x2</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>4096</FONT>
</CENTER>
</TD>
</TR>

<TR><TD>STacy</TD><TD>
<CENTER>
<FONT SIZE=2>640x400x2</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>N/A</FONT>
</CENTER>
</TD>
</TR>

<TR><TD>TT030</TD><TD>
<CENTER>
<FONT SIZE=2>320x200x256</FONT>
</CENTER>

<P>

<CENTER>
<FONT SIZE=2>640x200x4</FONT>
</CENTER>

<P>

<CENTER>
<FONT SIZE=2>640x400x2</FONT>
</CENTER>

<P>

<CENTER>
<FONT SIZE=2>320x480x256</FONT>
</CENTER>

<P>

<CENTER>
<FONT SIZE=2>640x480x16</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>4096</FONT>
</CENTER>
</TD>
</TR>

<TR><TD>Falcon030</TD><TD>
<CENTER>
<FONT SIZE=2>See below.</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>262,144</FONT>
</CENTER>

</TD></TR>

</TABLE>

<P>

<H5>Falcon030 Video Modes</H5>

<P>
The Falcon030 is equipped with a much more flexible video controller
than earlier Atari computers. The display area may be output on
a standard television, an Atari color or monochrome monitor, or
a VGA monitor. Overscan is supported with all monitor configurations
with the exception of VGA. Also, hardware support for NTSC and
PAL monitors is software configurable.
<P>
The Falcon030 supports graphic modes of 40 or 80 columns (320
or 640 pixels across) containing 1, 2, 4, 8, or 16 bits per pixel
resulting in 2, 4, 16, 256, or 262,144 colors respectively. All
modes except the 16 bit per pixel mode supply the video shifter
with palette indexes. The 16 bit per pixel mode is a 'true-color'
mode where each 16 bit value determines the color rather than
being an index into a palette. Each 16 bit <B>WORD</B> value is
arranged as follows:
<P>
The 'R', 'G', and 'B', represent the red, green, and blue components
of the color. Because red and blue are each allocated five bits,
they can represent a color range of 0-31. The green component
is allocated six bits so it can represent a color range of 0-63.
<P>
The Falcon030 also supports an overlay mode (see <B>VsetMask()</B>)
where certain colors can be defined as transparent to a connected
Genlock (or similar) device. In this mode, the least signifigant
green bit (Bit #5) is treated as the transparent flag bit and
the resolution of the green color component is slightly reduced.
If the transparent flag bit of a pixel is set, that pixel will
display video from the Falcon030's video shifter, otherwise the
external video source will be responsible for its display.
<P>
Another feature of the Falcon030's video shifter is an optional
interlace/double-line mode. When operating on a VGA monitor, this
mode doubles the pixel height effectively reducing the vertical
screen <a name=resolution>resolution by half. On any other video display, this mode
engages interlacing which increases the video resolution.
<P>
The operating system calls <B>VsetMode()</B> or <B>VsetScreen()</B>
can be used to manipulate the operating mode of the Falcon030's
video shifter. These calls do not, however, do any checking to
ensure the selected video mode is actually attainable on the connected
monitor or that the mode is legal. In particular, you should not
attempt to set the video shifter to either 40 column mode with
only one bit per pixel or 80 column VGA mode with 16 bits per
pixel. 
<a name=memory><H5>Video Memory</H5>

<P>
Most of the available video modes are palette-based. The number
of bits required per pixel depends on the number of palette entries
as shown in the table below. The Falcon030 also offers a true
color video mode which requires 16 bits per pixel.
<TABLE BORDER=1>

<TR><TH>
<CENTER>
<B><FONT SIZE=1 >Palette Entries</FONT></B>
</CENTER>

</TH><TH>
<CENTER>
<B><FONT SIZE=1 >Bits per Pixel</FONT></B>
</CENTER>

</TH></TR>

<TR><TD>
<CENTER>
2
</CENTER>
</TD><TD>
<CENTER>
1
</CENTER>

</TD></TR>

<TR><TD>
<CENTER>
4
</CENTER>
</TD><TD>
<CENTER>
2
</CENTER>

</TD></TR>

<TR><TD>
<CENTER>
16
</CENTER>
</TD><TD>
<CENTER>
4
</CENTER>

</TD></TR>

<TR><TD>
<CENTER>
256
</CENTER>
</TD><TD>
<CENTER>
8
</CENTER>

</TD></TR>

</TABLE>

<P>

<P>
Directly accessing video memory is normally not recommended because
it may create compatibility problems with future machines and
wreak havoc with other system applications. The <B>VDI</B> provides
a rich set of function calls which should be used when outputting
to the screen. The function call <B>vr_trnfm()</B>, for instance,
can be useful in transforming video images into a pattern compatible
with the current video shifter. Certain software, however, does
need exclusive access to video memory.
<P>
With the exception of the 16-bit true color mode of the Falcon030,
all video images are stored in memory in <B>WORD</B> interleaved
format. The video shifter grabs one at a time from each plane
present as shown in the following diagram which represents a 16-color
(four plane) screen layout:
<center><br><img src="../graphics/chap523.gif"></center>
<P>
The Falcon030's 16-bit true color mode is pixel-packed so that
<B>WORD</B> #0 in memory is the complete color <B>WORD</B> for
the pixel at ( 0, 0 ), <B>WORD</B> #1 is the complete color <B>WORD</B>
for the pixel at ( 1, 0 ), etc.
<a name=finescroll><H5>Fine Scrolling</H5>

<P>
All Atari computers except the original ST and Mega ST support
both horizontal and vertical fine scrolling in hardware. To accomplish
this, an application must place a special handler in the vertical
blank vector (at 0x00000070) which resets the scroll registers
and video base address as needed.
<P>
The following registers are manipulated during the vertical-blank
period to shift the screen across any number of virtual 'screens':
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Register</FONT></B></TH>
<TH><B><FONT SIZE=1 >Address</FONT></B></TH><TH><B><FONT SIZE=1 >Contents</FONT></B>
</TH></TR>

<TR><TH><I><B>VBASEHI</B></I></TH><TD>0xFFFF8200</TD><TD>Low byte contains bits 23-16 of the video display base address.
</TD></TR>

<TR><TH><I><B>VBASEMID</B></I></TH><TD>0xFFFF8202</TD><TD>Low byte contains bits 15-8 of the video display base address.
</TD></TR>

<TR><TH><I><B>VBASELO</B></I></TH><TD>0xFFFF820C</TD><TD>Low byte contains bits 7-0 of the video display base address.
</TD></TR>

<TR><TH><I><B>LINEWID</B></I></TH><TD>0xFFFF820E</TD><TD>Number of extra <B>WORD</B>s per scanline (normally 0).
</TD></TR>

<TR><TH><I><B>HSCROLL</B></I></TH><TD>0xFFFF8264</TD><TD>Low four bits contain the bitwise offset (0-15) of the screen (normally 0 unless scrolling is in effect).
</TD></TR>

<TR><TH><I><B>VCOUNTHI</B></I></TH><TD>0xFFFF8204</TD><TD>Low byte contains bits 23-16 of the current video refresh address (use with care).
</TD></TR>

<TR><TH><I><B>VCOUNTMID</B></I></TH><TD>0xFFFF8206</TD><TD>Low byte contains bits 15-8 of the current video refresh address (use with care).
</TD></TR>

<TR><TH><I><B>VCOUNTLO</B></I></TH><TD><FONT SIZE=2>0xFFFF8208</FONT>
</TD><TD><FONT SIZE=2>Low byte contains bits 7-0 of the current video refresh address (use with care).</FONT>
</TD></TR>

</TABLE>

<P>

<P>
To accommodate virtual screens wider than the display can show,
set <I><B>LINEWID</B></I> to the number of extra <B>WORD</B>s
per scanline. For instance, to create a virtual display two screens
wide for a 320x200 16-color display, set <I><B>LINEWID</B></I>
to 80.
<P>
To scroll vertically, simply alter the video base address by adding
or subtracting the number of <B>WORD</B>s per scanline for each
line you wish to scroll during the vertical blank.
<P>
To scroll horizontally, alter the video base address in <B>WORD</B>
increments to move the physical screen left and right over the
virtual screen. This by itself will cause the screen to skip in
16 pixel jumps. To scroll smoothly, use the <I><B>HSCROLL</B></I>
register to shift the display accordingly. When <I><B>HSCROLL</B></I>
is non-zero, subtract one from <I><B>LINEWID</B></I> for each
plane.
<P>
To illustrate this more clearly, imagine a physical screen of
320x200 (16 colors) which is laid out over 4 virtual screens in
a 2x2 grid. The following diagram and table shows example values
to move the physical screen to the desired virtual coordinates:
<center><br><img src="../graphics/chap525.gif"></center>
<br><TABLE BORDER=1>

<TR><TH COLSPAN=4>
<CENTER>
<B>Sample Values</B>
</CENTER>

</TH></TR>

<TR><TH>
<CENTER>
<B><FONT SIZE=1 >Virtual Coordinates</FONT></B>
</CENTER>

</TH><TD>
<CENTER>
<I><B><FONT SIZE=2 >VBASE</FONT></B></I><B><FONT SIZE=2 > Address</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >LINEWID</FONT></B></I>
</CENTER>

</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >HSCROLL</FONT></B></I>
</CENTER>

</TD></TR>

<TR><TD>
<CENTER>
( 0, 0 )
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>0x80000</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>80</FONT>
</CENTER>
</TD>
<TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>
</TD></TR>

<TR><TD>
<CENTER>
( 16, 0 )
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>0x80004</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>80</FONT>
</CENTER>
</TD>
<TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>
</TD></TR>

<TR><TD>
<CENTER>
( 0, 1 )
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>0x80140</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>80</FONT>
</CENTER>
</TD>
<TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>
</TD></TR>

<TR><TD>
<CENTER>
( 1, 0 )
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>0x80000</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>76</FONT>
</CENTER>
</TD>
<TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>
</TD></TR>

<TR><TD>
<CENTER>
( 0, 10 )
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>0x80B40</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>80</FONT>
</CENTER>
</TD>
<TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>
</TD></TR>

<TR><TD>
<CENTER>
( 100, 100 )
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>0x87BE4</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>76</FONT>
</CENTER>
</TD>
<TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>
</TD></TR>

</TABLE>

<P>
<hr><center><a href="toc.htm"> Table of Contents | </a><a href="index.htm"> Index </a></center>

</BODY>

</HTML>
