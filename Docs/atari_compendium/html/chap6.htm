<HTML>

<HEAD>

<TITLE>AES Overview</TITLE>


</HEAD>

<BODY BACKGROUND BGCOLOR=#ffffff>

<P>
<a name=chap6><B><FONT SIZE=2>- CHAPTER 6 -</FONT></B>
<H2>AES</H2>

<HR>

<a name=overview><H4><FONT SIZE=4 >Overview</FONT></H4>

<HR>

<P>
<a name=aes>The Application Environment Services (<B>AES</B>) compose the
highest level of the operating system. The <B>AES</B> uses the
<B>VDI</B>, <B>GEMDOS</B>, and <B>XBIOS</B> to provide a global
utility library of calls which provide applications with the <B>GEM</B>
interface. Usage of the <B>AES</B> makes application development
simpler and makes user interfaces more consistent. The services
provided by the <B>AES</B> include:
<P>
 Application Control/Interaction
<P>
 Event Management
<P>
 Menu Services
<P>
 Object Rendering/Manipulation
<P>
 <a name=form>Form Management
<P>
 Graphic Utility Functions
<P>
 Scrap (Clipboard) Management
<P>
 Common Dialog Display
<P>
 Window Management
<P>
 Resource Management
<P>
 Shell (Desktop) Interaction
<P>
<a name=system>System-specific <B>AES</B> information and variables may be determined
through reserved fields in the application's global array (see
<B>appl_init()</B>) or by using the various modes of <B>appl_getinfo()</B>.
<HR>

<a name=process><H4><FONT SIZE=4 >Process Handling</FONT></H4>

<HR>

<P>
The <B>AES</B> manages two <a name=types>types of user programs. Normal <B>GEM</B>
applications have file extensions of '.PRG', '.APP', or '.GTP'.
<a name=desk>Desk Accessories have file extensions of '.ACC'.
<P>
Without <B>MultiTOS</B>, the <B>AES</B> can have a maximum of
one application and six desk accessories (four desk accessories
under <B>TOS</B> 1.0) executing concurrently. The currently running
application (or the Desktop if no application is running) is given
primary control over the system. Desk accessories are allocated
processor time <I>only</I> when the foreground application releases
control by calling one of the event library functions. An application
which does not have a standard <a name=eventloop>loop (as illustrated below)
will cause desk accessories to stop functioning while it is being
executed.
<P>
Under <B>MultiTOS</B>, an unlimited amount of applications and
desk accessories may be loaded concurrently. <B>MultiTOS</B> is
a pre-emptive system where all system processes are given time
regardless of other applications.
<HR>

<a name=app><a name=apps><H4><FONT SIZE=4 >Applications</FONT></H4>

<HR>

<P>
When an application is launched, <B>GEM</B> allocates <I>all</I>
remaining system memory and loads the application into this area.
It is the responsibility of the application to free whatever memory
it doesn't immediately need for its text, data, bss, and stack
area. Most high level <a name=language>languages do this for you in the startup
stub linked with every application.
<P>
<B>GEM</B> applications begin with an <a name=applinit><B>appl_init()</B> function
call. This call will return a valid application ID if the process
can be successfully registered or a -1 if it fails. If the call
fails, the application should immediately exit without making
any <B>AES</B> calls. Upon success, however, the ID should be
stored for future use within the application. Applications running
under <B>MultiTOS</B> should call<a name=menuregister> <B>menu_register()</B> to display
the program title in the application list rather than the filename.
<P>
The next steps a <B>GEM</B> application will follow are variable,
however, most <B>GEM</B> applications will initialize themselves
further by performing some or all of the following steps:
<UL>
<LI>Open a <B>VDI</B> workstation.
<LI>Verify that the computer the application is being run on has
the minimum requirements (screen resolution, OS versions, memory
needs, hardware features) necessary to continue.
<LI>Load the application '.RSC' file and fix it up as necessary.
<LI>Display the menu bar.
<LI>Change the mouse form to an arrow (the <B>AES</B> defaults
to a <B>BUSY_BEE</B> shape).
<LI>Enter the application's main event loop.
</UL>

<P>

<P>
The following represents a basic skeleton for an <B>AES</B> application:
<PRE>
#include &lt;AES.H&gt;
#include &lt;VDI.H&gt;
#include &lt;OSBIND.H&gt;
#include &lt;VDIWORK.H&gt;
#include "skel.h"

#define CNTRL_Q	0x11

int main(int, char *[]);

extern int _AESglobal[15];

short ap_id;
VDI_Workstation ws;		/* See entry for V_Opnvwk() in VDI docs */
OBJECT *mainmenu;

char RSCname[] = "skeleton.rsc";
char menu_title[] = "  Skeleton";

int
main(int argc, char *argv[])
{
<FONT SIZE=2>	char *altNoVDIWork = "[3][GEM is unable to|allocate a workstation.|The program 		must abort.][ OK ]";
</FONT>	char *altNoRSC = "[3][The program cannot locate|SKELETON.RSC. Please 				ensure|that it resides in the|same directory as|SKELETON.PRG.][ OK ]";
<FONT SIZE=2>	short ret,msg[8],kc,quit,dum;

</FONT>	ap_id = appl_init();
<FONT SIZE=2>	if(ap_id == -1)
</FONT>			return -1;

<FONT SIZE=2>	if(!OpenVwork(&amp;ws))
</FONT>	{
<FONT SIZE=2>			graf_mouse( ARROW, 0L );
</FONT>		<a name=form_alert2>	form_alert(1, altNoVDIWork );
<FONT SIZE=2>			appl_exit();
</FONT>			return -1;
<FONT SIZE=2>	}

</FONT>	if(!rsrc_load( RSCname ))
<FONT SIZE=2>	{
</FONT>			graf_mouse( ARROW, 0L );
<FONT SIZE=2>			form_alert(1, altNoRSC );
</FONT>			v_clsvwk(ws.handle);
<FONT SIZE=2>			appl_exit();
</FONT>			return -1;
<FONT SIZE=2>	}

</FONT>	if(_AESglobal[1] == -1)						/* MultiTOS present?      */
<FONT SIZE=2>			menu_register(ap_id, menu_title);		/* Yes, make name pretty. */

</FONT>	rsrc_gaddr( R_TREE, MAINMENU, &amp;mainmenu);

<FONT SIZE=2>	menu_bar(mainmenu,1);
</FONT>	graf_mouse( ARROW, 0L );

<FONT SIZE=2>	quit = FALSE;
</FONT>	while(!quit)
<FONT SIZE=2>	{
</FONT>			ret = evnt_multi(MU_MESAG|MU_KEYBD,2,1,1,0,0,0,0,0,0,0,0,0,0,msg,0,0,
<FONT SIZE=2>								&amp;dum,&amp;dum,&amp;dum,&amp;dum,&amp;kc,&amp;dum);

</FONT>			if(ret &amp; MU_MESAG)
<FONT SIZE=2>			{
</FONT>				switch(msg[0])
<FONT SIZE=2>				{
</FONT>					case MN_SELECTED:
<FONT SIZE=2>						switch(msg[3])
</FONT>						{
<FONT SIZE=2>							.		/* Other menu selections */
</FONT>							.
<FONT SIZE=2>							.

</FONT>							case mmExit:					/* Defined in SKEL.H */
<FONT SIZE=2>								quit = TRUE;
</FONT>								break;
<FONT SIZE=2>						}
</FONT>						break;
<FONT SIZE=2>					}
</FONT>				}
<FONT SIZE=2>			}

</FONT>			if(ret &amp; MU_KEYBD)
<FONT SIZE=2>			{
</FONT>				switch(kc &amp; 0xFF)
<FONT SIZE=2>				{
</FONT>					.			/* Other keyboard equivalents */
<FONT SIZE=2>					.
</FONT>					.
<FONT SIZE=2>					case CNTRL_Q:
</FONT>						quit = TRUE;
<FONT SIZE=2>						break;
</FONT>				}
<FONT SIZE=2>			}
</FONT>	}
<FONT SIZE=2>	
</FONT>	menu_bar( mainmenu, 0 );
<FONT SIZE=2>	v_clsvwk(ws.handle);
</FONT><a name=rsrcfree>	rsrc_free();
<FONT SIZE=2>	appl_exit();
</FONT>	return 0;
<FONT SIZE=2>}
</FONT>
</PRE>

<H5>The Command Line</H5>

<P>
<B>GEM</B> applications, like <B>TOS</B> applications, may be
started with a command line (for a detailed description of command
line processing, see <I>Chapter 2:</I><B> <I>GEMDOS</I></B>).
'.PRG' files and '.APP' files will have items on the command line
if a document file which was registered with the application was
<a name=evnt_dclick>double-clicked or if a valid document file was dropped over the
application's <a name=icon>icon in the Desktop. Launching a '.GTP' application
will cause the Desktop to prompt the user for a command line in
the same manner as '.TTP' programs are handled. Applications which
find one or more valid document names on their command line should
automatically load them on program start.

<HR>

<a name=desk><H4><FONT SIZE=4 >Desk Accessories</FONT></H4>

<HR>

<P>
Upon bootup, any files with the extension '.ACC' found in the
root directory of the user's boot drive will be loaded and executed
up until their first event library call. <B>MultiTOS</B> allows
desk accessories to be loaded and unloaded after bootup.
<P>
Unlike applications, desk accessories are not given all of available
system memory on startup. They are only allocated enough memory
for their text, data, and bss segments. No <a name=stackallocation>stack space is allocated
for a desk accessory either. Many high level language stubs reserve
space in the BSS or overwrite startup code to provide a stack
but keep in mind that desk accessory stacks are usually small
compared to applications.
<P>
As with applications, <B>GEM</B> desk accessories should begin
with an <B>appl_init()</B> function call. Upon success, the ID
should be stored and used within a <B>menu_register()</B> call
to place the applications' name on the menu bar.
<P>
Desk accessories, unlike applications, do not begin user interaction
immediately. Most desk accessories initialize themselves and enter
a message loop waiting for an <a name=acopen><B>AC_OPEN</B> message. Some desk
accessories wait for <a name=timerevents2>timer events or custom messages from another
application. After being triggered, they usually open a window
in which user interaction may be performed <a name=dialogs2>(dialogs and <a name=alerts>alerts
may also be presented but are not recommended because they prevent
shuffling between other system processes).
<P>
Desk accessories should not use a menu bar and should never exit
(unless <B>appl_init()</B> fails) after calling <a name=menuregister2><B>menu_register()</B>.
If an error condition occurs which would make the accessory unusable,
simply enter an indefinite message loop.
<P>
Any resources loaded by an accessory should be loaded prior to
entering the first event loop and should never be freed after
the accessory has called <B>menu_register()</B>. Resource data
for desk accessories should be embedded in the executable rather
than being soft-loaded because memory allocated to a desk accessory
is not freed during a <a name=resolutionchange>resolution change on <B>TOS</B> versions
less than 2.06. This causes resource memory allocated by <a name=rsrcload><B>rsrc_load()</B>
to be lost to the system after a resolution change and will likely
cause memory fragmentation.
<P>
An <a name=acclose><B>AC_CLOSE</B> message is sent to an accessory when it is
being closed at the request of the OS. At this point, it should
perform any cleanup necessary to release system resources and
close files opened at <a name=acopen2><B>AC_OPEN</B> (accessory windows will be
closed automatically by the <B>AES</B>). After cleanup, the event
loop should be reentered to wait for subsequent <B>AC_OPEN</B>
messages.
<P>
The following code represents a basic skeleton for an <B>AES</B>
desk accessory:
<PRE>
#include &lt;AES.H&gt;
#include &lt;VDI.H&gt;
#include &lt;OSBIND.H&gt;
#include &lt;VDIWORK.H&gt;

int main(int, char *[]);

short ap_id;
VDI_Workstation ws;		/* See entry for V_Opnvwk() in VDI docs */

char menu_title[] = "  Skeleton";

int
main(int argc, char *argv[])
{
<FONT SIZE=2>	char *altNoVDIWork = "[3][GEM is unable to|allocate a workstation.|The program 		must abort.][ OK ]";
</FONT>	short ret,msg[8],kc,dum;

<FONT SIZE=2>	ap_id = appl_init();
</FONT>	if(ap_id == -1)
<FONT SIZE=2>			return -1;

</FONT>	if(!OpenVwork(&amp;ws))
<FONT SIZE=2>	{
</FONT>		form_alert(1, altNoVDIWork);
<FONT SIZE=2>			appl_exit();
</FONT>			return -1;
<FONT SIZE=2>	}

</FONT>	menu_id = menu_register(ap_id, menu_title );		/* Place name on menu bar */

<FONT SIZE=2>	for(;;)
</FONT>	{
<FONT SIZE=2>			evnt_mesag(msg);

</FONT>			switch( msg[0] )
<FONT SIZE=2>			{
</FONT>				case AC_OPEN:
<FONT SIZE=2>					if(msg[3] == menu_id)
</FONT>						OpenAccessoryWindow();
<FONT SIZE=2>					break;
</FONT>				<a name=acclose2>case AC_CLOSE:
<FONT SIZE=2>					if(msg[3] == menu_id)
</FONT>					{
<FONT SIZE=2>						v_clsvwk(ws.handle);
</FONT>						break;
<FONT SIZE=2>					}
</FONT>			}
<FONT SIZE=2>		}
</FONT>}
</PRE>

<HR>

<a name=enviroment><a name=envirostring><H4><FONT SIZE=4 >The Environment String</FONT></H4>

<HR>

<P>
One <B>AES</B> environment string exists in the system. This environment
string is the one initially allocated for the <B>AES</B> by <B>GEMDOS</B>.
The <B>AES</B> environment string should not be confused with
<B>GEMDOS</B> environment strings. Each <B>GEMDOS</B> process
receives its own environment string when launched. This string
may have been purposely altered (or omitted) by its parent. 
<P>
The <B>AES</B> environment string is a collection of variables
which the AES (and other processes) may use as global system variables.
Environment data may be set by a CPX designed to configure the
environment, in the user's GEM.CNF file, or by an application.
<P>
In actuality, the environment string is actually one or many string
entries separated by <B>NULL</B> bytes with the full list being
terminated by a double <B>NULL</B> byte. Examples of environment
string entries include:
<PRE>
PATH=C:\;D:\;E:\BIN\
TEMP=C:\
AE_SREDRAW=0
</PRE>

<P>
 
<P>
The environment variable name is followed by an equal sign which
is followed by the variable data. Multiple arguments (such as
path names) may be separated by semicolons or commas.
<P>
The <B>AES</B> call <a name=shelenvrn><B>shel_envrn()</B> may be used to search
for an environment variable and new modes of <a name=shelwrite><B>shel_write()</B>
(after <B>AES</B> version 4.0) may be used to alter environment
variables or copy the entire environment string.
<P>
Most versions of the <B>AES</B> contain a bug which causes the
'PATH' environment variable to be set incorrectly upon bootup
to 'PATH=<I>[nul]</I>A:\<I>[nul][nul]</I>'. If an environment
string like this is found it may be safely reset or simply ignored.
<HR>

<a name=event><H4><FONT SIZE=4 >The Event Dispatcher</FONT></H4>

<HR>

<P>
<a name=applib>Most <B>GEM</B> applications and all desk accessories rely on
one of the <B>AES</B> event processing calls to direct program
flow. After program initialization, an application enters a message
loop which waits for and reacts to messages sent by the <B>AES</B>.
Five basic types of events are generated by the <B>AES</B> and
each can be read by a specialized <a name=eventlib>event library call as follows:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Event Type</FONT></B></TH>
<TH><B><FONT SIZE=2 >AES Function</FONT></B></TH>
</TR>

<TR><TD>Message</TD><TD><B><FONT SIZE=2><a name=evnt_mesag>evnt_mesag()</FONT></B>
</TD></TR>

<TR><TD>Mouse Button</TD><TD><B><FONT SIZE=2><a name=evntbutton>evnt_button()</FONT></B>
</TD></TR>

<TR><TD>Keyboard</TD><TD><B><FONT SIZE=2><a name=entkbd>evnt_keybd()</FONT></B>
</TD></TR>

<TR><TD>Timer</TD><TD><B><FONT SIZE=2><a name=evnt_timer>evnt_timer()</FONT></B>
</TD></TR>

<a name=evnt_mouse><TR><TD>Mouse Movement</TD><TD><B><FONT SIZE=2>evnt_mouse()</FONT></B>
</TD></TR>

</TABLE>

<P>

<P>
In addition to these five basic calls, the <B>AES</B> offers one
multi-purpose call which waits for any combination of the above
events called <a name=evnt_multi><B>evnt_multi()</B>. The <B>evnt_multi()</B> call
is often the most important function call in any <B>GEM</B> application.
A typical message loop follows:
<PRE>
#include &lt;AES.H&gt;

void
MessageLoop( void )
{
	short mx, my;			/* Mouse Position */
	short mb, mc;			/* Mouse button/# clicks */
	short ks, kc;			/* Key state/code */
	short quit;			/* Exit flag */
	short msg[8];			/* Message buffer */
	short events;			/* What events are valid? */

/* Mask for all events */
#define ALL_EVENTS	(MU_MESAG|MU_BUTTON|MU_KEYBD|MU_TIMER|MU_M1|MU_M2)

	quit = FALSE;
	while(!quit)
	{
			events = evnt_multi( ALL_EVENTS,
								2, 1, 1,				/* Single/double clicks */
								0, 0, 0, 128, 128,	/* M1 event */
								1, 0, 0, 128, 128,  	/* M2 event */
								msg,					/* Pointer to msg */
								1000, 0,				/* MU_TIMER every 1 sec. */
								&amp;mx, &amp;my, &amp;ks, &amp;kc,
								&amp;mc );

			if( events &amp; MU_MESAG )
			{
				switch( msg[0] )		/* msg[0] is message type */
				{
					case MN_SELECTED:
						HandleMenuClick( msg );
						break;
					case WM_CLOSED:
						CloseWindow( msg[3] );
						break;
					/*
					 * more message events...
					 */
				}
			}

			if( events &amp; MU_BUTTON )
			{
				/*
				 * <a name=mbe2>Handle mouse button event.
				 */
			}

			if( events &amp; MU_KEYBD )
			{
				/*
				 * Handle keyboard events.
				 */
			}

			if( events &amp; MU_TIMER )
			{
				/*
				 * Handle Timer events.
				 */
			}

			if( events &amp; MU_M1 )
			{
				/*
				 * Handle mouse rectangle event 1.
				 */
			}

			if( events &amp; MU_M2 )
			{
				/*
				 * Handle mouse rectangle event 2.
				 */
			}
	}

	/* Loop will terminate here when 'quit' is set to TRUE. */
}

</PRE>

<P>
When an event library function is called, the program is effectively
halted until a message which is being waited for becomes available.
Not all applications will require all events so the above code
may be considered flexible.
<a name=messageevents><H5>Message Events</H5>

<P>
Each standard <B>GEM</B> message event (<B>MU_MESAG</B>) uses
some or all of an 8 <B>WORD</B> message buffer. Each entry in
this buffer is assigned as follows:
<TABLE BORDER=1>

<TR><TH>
<CENTER>
<I><B><FONT SIZE=1 >msg[x]</FONT></B></I>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Meaning</FONT></B></TH>
</TR>

<TR><TD>
<CENTER>
0
</CENTER>
</TD><TD><FONT SIZE=2>Message type.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
1
</CENTER>
</TD><TD><FONT SIZE=2>The<a name=appidentify><a name=applicationidentifier> application identifier of the process sending the message.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
2
</CENTER>
</TD><TD><FONT SIZE=2>The length of the message <I>beyond</I> 16 bytes (in bytes). For all standard <B>GEM</B> messages, this values is 0.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
3
</CENTER>
</TD><TD><FONT SIZE=2>Depends on message.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
4
</CENTER>
</TD><TD><FONT SIZE=2>Depends on message.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
5
</CENTER>
</TD><TD><FONT SIZE=2>Depends on message.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
6
</CENTER>
</TD><TD><FONT SIZE=2>Depends on message.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
7
</CENTER>
</TD><TD><FONT SIZE=2>Depends on message.</FONT>
</TD></TR>

</TABLE>

<P>

<P>
The entry for <a name=evnt_mesag2><B>evnt_mesag()</B> later in this chapter has a
comprehensive list of all system messages and the action that
should be taken when they are received.
<a name=messageevents2><a name=udm><H5>User-Defined Message Events</H5>

<P>
Applications may write customized messages to other applications
(or themselves) using <a name=applwrite><B>appl_write()</B>. The structure of the
message buffer should remain the same as shown above. If more
than the standard eight <B>WORD</B>s of data are sent, however,
<a name=applread><B>appl_read()</B> must be used to read the additional bytes.
It is recommended that user-defined messages be set to a multiple
of 8 bytes.
<P>
You can use this method to send your own application standard
messages by filling in the message buffer appropriately and using
<B>appl_write()</B>. This method is often used to force redraw
or window events.
<a name=mbe><H5>Mouse Button Events</H5>

<P>
When a mouse button (<B>MU_BUTTON</B>) event happens, the <B><a name=evntbutton2>evnt_button()</B>
or <B>evnt_multi()</B> call is returned with the mouse coordinates,
the number of clicks that occurred, and the keyboard shift state.
<H5>Keyboard Events</H5>

<P>
Keyboard events (<B>MU_KEYBD</B>) are generated whenever a key
is struck. The IKBD scan code (see <I>Appendix F: <B>IKBD Scan
Codes</B></I>) and current key shift state are returned by either
<B><a name=entkbd2>evnt_keybd()</B> or <a name=evnt_multi2lti()</B>. If your application
is designed to run on machines in other countries, you might consider
translating the scan codes using the tables returned by the <B>XBIOS</B>
call <B>Keytbl()</B>.
<a name=timerevents><H5>Timer Events</H5>

<P>
<a name=evnt_timer2><B>evnt_timer()</B> or <B>evnt_multi( MU_TIMER</B>, ...<B> )</B>
can be used to request a timer event(s) be scheduled in a certain
number of milliseconds. The time between the actual function call
and the event may, however, be greater than the time specified.
<H5>Mouse Rectangle Events</H5>

<P>
Mouse rectangle events (<B>MU_M1</B> and/or <B>MU_M2</B>) are
generated by <a name=evnt_mouse2><B>evnt_mouse()</B> and <B>evnt_multi()</B> when
the mouse pointer enters or leaves (depending on how you program
it) a specified rectangle.
<HR>

<a name=resources><H4><FONT SIZE=4 >Resources</FONT></H4>

<HR>

<P>
<B>GEM</B> resources consist of object trees, strings, and bitmaps
used by an application. They encapsulate the user interface and
make internationalization easier by placing all program strings
in a single file. Resources are generally created using a Resource
Construction Set (RCS) and saved to a .RSC file (see <I>Appendix
C: <B>Native File Formats</B></I>) which is loaded by <B>rsrc_load()</B>
at program initialization time.
<P>
Resources may also be embedded as data structures in source code
(some utility programs convert .RSC files to source code). Desk
accessories often do this to avoid complications they have in
loading .RSC files.
<P>
Resources contain pointers and coordinates which must be fixed
up before being used. <a name=rsrcload2><B>rsrc_load()</B> does this automatically,
however if you use an embedded resource you must use <a name=rsrcrcfix><B>rsrc_rcfix()</B>
if available or <a name=rsrcobfix><B>rsrc_obfix()</B> on each object in each object
tree to convert the initial character coordinates of to screen
coordinates. This allows resources designed on screens with different
aspect ratios and <a name=systemfont2>system <a name=fonts>fonts to appear the same. In any case,
you should test your resources on several different screens, especially
screen resolutions with different aspect ratios such as ST Medium
and ST High.
<P>
Once a resource is loaded use <a name=rsrcgaddr><B>rsrc_gaddr()</B> to obtain pointers
to individual object trees which can then be manipulated directly
or with the <B>AES</B> <a name=ol>Object Library. Replacing resources after
they're loaded is accomplished with <B>rsrc_saddr()</B>.
<HR>

<a name=objects><a name=fontsaes><H4><FONT SIZE=4 >Objects</FONT></H4>

<HR>

<P>
Objects can be boxes, buttons, text, images, and more. An object
tree is an array of <B>OBJECT</B> structures linked to form a
structured relationship to each other. The <B>OBJECT</B> structure
format is as follows:
<PRE>
typedef struct object
{
	WORD		ob_next;
	WORD		ob_head;
	WORD		ob_tail;
	UWORD		ob_type;
	UWORD		ob_flags;
	UWORD		ob_state;
	VOIDP		ob_spec;
	WORD		ob_x;
	WORD		ob_y;
	WORD		ob_width;
	WORD		ob_height;
} OBJECT;	

</PRE>

<P>
Normally <B>OBJECT</B>s are loaded in an application resource
file but it is possible to create and manipulate them on-the-fly
using the <a name=objcadd><B>objc_add()</B>,<a name=objcdelete><B> objc_delete()</B>, and <a name=objcorder><B>objc_order()
</B>commands.
<P>
The first object in an <B>OBJECT</B> tree is called the <B>ROOT</B>
object (<B>OBJECT</B> #0). It's coordinates are relative to the
upper-left hand corner of the screen.
<P>
The <B>ROOT</B> object can have any number of children and each
child can have children of their own. In each case, the <B>OBJECT</B>'s
coordinates, <I>ob_x</I>, <I>ob_y</I>, <I>ob_width</I>, and <I>ob_height</I>
are relative to that of its parent. The <B>AES</B> call <a name=objcoffset><B>objc_offset()</B>
can, however, be used to determine the exact screen coordinates
of a child object. <a name=objcfind><B>objc_find()</B> is used to determine the
object at a given screen coordinate.
<P>
The <I>ob_next</I>, <I>ob_head</I>, and <I>ob_tail</I> fields
determine this relationship between parent <B>OBJECT</B>s and
child <B>OBJECT</B>s. The following alert box is an example of
an <B>OBJECT</B> tree:
<center><br><img src="../graphics/chap613.gif"></center>
<center><br><img src="../graphics/chap614.gif"></center>
<P>
The tree structure this object has can be represented as follows:
<P>
The exact usage of <I>ob_head</I>, <I>ob_next</I>, and <I>ob_tail</I>
are as follows:
<TABLE BORDER=1>

<TR><TH>
<CENTER>
<B><FONT SIZE=1 >Element</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Usage</FONT></B></TH></TR>

<TR><TH>
<CENTER>
<I>ob_head</I>
</CENTER>
</TH><TD><FONT SIZE=2>This member gives the exact index from the first object in the <B>OBJECT</B> tree to the first child of the current object. If the object has no children then this value should be -1.</FONT>
</TD></TR>

<TR><TH>
<CENTER>
<I>ob_tail</I>
</CENTER>
</TH><TD><FONT SIZE=2>This member gives the exact index from the first object in the <B>OBJECT</B> tree to the last child of the current object. If the object has no children then this value should be -1.</FONT>
</TD></TR>

<TR><TH>
<CENTER>
<I>ob_next</I>
</CENTER>
</TH><TD><FONT SIZE=2>This member gives the exact index from the first object in the <B>OBJECT</B> tree to the next child at the same level. The <B>ROOT</B> object should be set to -1. The last child at any given nesting level should be set to the index of its parent.</FONT>
</TD></TR>

</TABLE>

<P>

<P>
The low byte of the <I>ob_type</I> field specifies the object
type as follows:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Name</FONT></B></TH><TH>
<CENTER>
<I><B><FONT SIZE=2 >ob_type</FONT></B></I><B><FONT SIZE=2 > &amp; 0xFF</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Meaning</FONT></B></TH>
</TR>

<TR><TH><B>G_BOX</B></TH><TD>
<CENTER>
<FONT SIZE=2>20</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Box</FONT></TD></TR>

<TR><TH><B>G_TEXT</B></TH><TD>
<CENTER>
<FONT SIZE=2>21</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Formatted Text</FONT></TD></TR>

<TR><TH><B>G_BOXTEXT</B></TH><TD>
<CENTER>
<FONT SIZE=2>22</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Formatted Text in a Box</FONT></TD></TR>

<TR><TH><B>G_IMAGE</B></TH><TD>
<CENTER>
<FONT SIZE=2>23</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Monochrome Image</FONT></TD></TR>

<TR><TH><B>G_PROGDEF</B></TH><TD>
<CENTER>
<FONT SIZE=2>24</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Programmer-Defined Object.</FONT></TD></TR>

<TR><TH><B>G_IBOX</B></TH><TD>
<CENTER>
<FONT SIZE=2>25</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Invisible Box</FONT></TD></TR>

<TR><TH><B>G_BUTTON</B></TH><TD>
<CENTER>
<FONT SIZE=2>26</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Push Button w/String</FONT></TD></TR>

<TR><TH><B>G_BOXCHAR</B></TH><TD>
<CENTER>
<FONT SIZE=2>27</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Character in a Box</FONT></TD></TR>

<TR><TH><B>G_STRING</B></TH><TD>
<CENTER>
<FONT SIZE=2>28</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Unformatted Text</FONT></TD></TR>

<TR><TH><B>G_FTEXT</B></TH><TD>
<CENTER>
<FONT SIZE=2>29</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Editable Formatted Text</FONT></TD></TR>

<TR><TH><B>G_FBOXTEXT</B></TH><TD>
<CENTER>
<FONT SIZE=2>30</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Editable Formatted Text in a Box</FONT>
</TD></TR>

<TR><TH><B>G_ICON</B></TH><TD>
<CENTER>
<FONT SIZE=2>31</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Monochrome Icon</FONT></TD></TR>

<TR><TH><B>G_TITLE</B></TH><TD>
<CENTER>
<FONT SIZE=2>32</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Menu Title</FONT></TD></TR>

<TR><TH><B>G_CICON</B></TH><TD>
<CENTER>
<FONT SIZE=2>33</FONT>
</CENTER>

</TD><TD><FONT SIZE=2><a name=color>Color Icon (Available as of <B>AES</B> v3.3)</FONT>
</TD></TR>

</TABLE>

<P>

<a name=flags><H5>Object Flags</H5>

<P>
The <I>ob_flags</I> field of the <B>OBJECT</B> structure is a
bitmask of different flags that can be applied to any object as
follows:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Name</FONT></B></TH><TH>
<CENTER>
<B><FONT SIZE=2 >Bit(s)</FONT></B>
</CENTER>

</TH><TH>
<CENTER>
<B><FONT SIZE=2 >Mask</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Meaning</FONT></B></TH>
</TR>

<TR><TH><B>SELECTABLE</B></TH><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>0x0001</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2>Object's selected state may be toggled by clicking on it with the mouse.</FONT>
</TD></TR>

<TR><TH><B>DEFAULT</B></TH><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>0x0002</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2>An <B>EXIT</B> object with this bit set will have a thicker outline and be triggered when the user presses return.</FONT>
</TD></TR>

<TR><TH><B>EXIT</B></TH><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>0x0004</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2>Clicking on this <B>OBJECT</B> and releasing the mouse button while still over it will cause the dialog to exit.</FONT>
</TD></TR>

<TR><TH><B>EDITABLE</B></TH><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>0x0008</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2>Set for <B>FTEXT</B> and <B>FBOXTEXT</B> objects to indicate that they may receive edit focus.</FONT>
</TD></TR>

<TR><TH><B>RBUTTON</B></TH><TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>0x0010</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2>This object is one of a group of radio buttons. Clicking on it will deselect any selected objects at the same tree level that also have the <B>RBUTTON</B> flag set.</FONT>Likewise, it will be deselected automatically when any other object is selected.
</TD></TR>

<TR><TH><B>LASTOB</B></TH><TD>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>0x0020</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2>This flag signals to the <B>AES</B> that the current <B>OBJECT</B> is the last in the object tree. (Required!)</FONT>
</TD></TR>

<TR><TH><B>TOUCHEXIT</B></TH><TD>
<CENTER>
<FONT SIZE=2>6</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>0x0040</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2>Setting this flag causes the <B>OBJECT</B> to return an exit state immediately after being clicked on with the mouse.</FONT>
</TD></TR>

<TR><TH><B>HIDETREE</B></TH><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>0x0080</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2>This <B>OBJECT</B> and all of its children will not be drawn.</FONT>
</TD></TR>

<TR><TH><B>INDIRECT</B></TH><TD>
<CENTER>
<FONT SIZE=2>8</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>0x0100</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2>This flag cause the <a name=obspec><I>ob_spec</I> field to be interpreted as a pointer to the <I>ob_spec</I> value rather than the value itself.</FONT>
</TD></TR>

<TR><TH><B>FL3DIND</B></TH><TD>
<CENTER>
<FONT SIZE=2>9</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>0x0200</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2>Setting this flag causes the <B>OBJECT</B> to be drawn as a <a name=threedimensionalobjects>3D indicator. This is appropriate for radio and toggle buttons. This flag is only recognized as of <B>AES</B> version 3.4.</FONT>
</TD></TR>

<TR><TH><B>FL3DACT</B></TH><TD>
<CENTER>
<FONT SIZE=2>10</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>0x0400</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2>Setting this flag causes the <B>OBJECT</B> to be drawn as a 3D activator. This is appropriate for <B>EXIT</B> buttons. This flag is only recognized as of <B>AES</B> version 3.4.</FONT>
</TD></TR>

<TR><TH><B>FL3DBAK</B></TH><TD>
<CENTER>
<FONT SIZE=2>9 &amp; 10</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>0x0600</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2>If these bits are set, the object is treated as an <B>AES</B> background object. If it is <B>OUTLINED</B>, the outlined is drawn in a 3D manner. If its color is set to <B>WHITE</B> and its fill pattern is set to 0 then the <B>OBJECT</B> will inherit the default 3D background color. This flag is only recognized as of <B>AES</B> version 3.4.</FONT>
</TD></TR>

<TR><TH><B>SUBMENU</B></TH><TD>
<CENTER>
<FONT SIZE=2>11</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>0x0800</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2><a name=about>This bit is set on menu items which have a sub-menu attachment. This bit also indicates that the high byte of the <I>ob_type</I> field is being used by the menu system.</FONT>
</TD></TR>

</TABLE>

<P>

<a name=states><H5>Object States</H5>

<P>
The <I>ob_state</I> field determines the display state of the
<B>OBJECT</B> as follows:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Name</FONT></B></TH><TH>
<CENTER>
<B><FONT SIZE=2 >Bit</FONT></B>
</CENTER>

</TH><TH>
<CENTER>
<B><FONT SIZE=2 >Mask</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Meaning</FONT></B></TH>
</TR>

<TR><TH><B>SELECTED</B></TH><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>0x0001</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2>The object is selected. An object with this bit set will be drawn in inverse video except for <B>G_CICON</B> which will use its 'selected' image. </FONT>
</TD></TR>

<TR><TH><B>CROSSED</B></TH><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>0x0002</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2>An <B>OBJECT</B> with this bit set will be drawn over with a white cross (this state can only usually be seen over a colored or <B>SELECTED</B> object).</FONT>
</TD></TR>

<TR><TH><B>CHECKED</B></TH><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>0x0004</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2>An <B>OBJECT</B> with this bit set will be displayed with a checkmark in its upper-left corner.</FONT>
</TD></TR>

<TR><TH><B>DISABLED</B></TH><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>0x0008</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2>An <B>OBJECT</B> with this bit set will ignore user input. Text objects with this bit set will draw in a dithered pattern.</FONT>
</TD></TR>

<TR><TH><B>OUTLINED</B></TH><TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>0x0010</FONT>
</CENTER>
</TD>
<TD><B><FONT SIZE=2>G_BOX</FONT></B>, <B>G_IBOX</B>, <B>G_BOXTEXT</B>, <B>G_FBOXTEXT</B>, and <B>G_BOXCHAR</B> <B>OBJECT</B>s with this bit set will be drawn with a double border.
</TD></TR>

<TR><TH><B>SHADOWED</B></TH><TD>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>0x0020</FONT>
</CENTER>
</TD>
<TD><B><FONT SIZE=2>G_BOX</FONT></B>, <B>G_IBOX</B>, <B>G_BOXTEXT</B>, <B>G_FBOXTEXT</B>, and <B>G_BOXCHAR OBJECT</B>s will be drawn with a shadow.
</TD></TR>

</TABLE>

<P>

<P>
The <B>AES</B> supports the <a name=objcchange><B>objc_change()</B> call which can
be used to change the state of an object and (optionally) redraw
it.
<H5>The Object-Specific Field</H5>

<P>
The <I>ob_spec</I> field contains different data depending on
the object type as indicated in the table below:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Object</FONT></B></TH><TH><B><FONT SIZE=2 >Contents of <I><B>ob_spec</B></I></FONT></B>
</TH></TR>

<TR><TH><B>G_BOX</B></TH><TD><FONT SIZE=2>The low 16 bits contain a <B>WORD</B> containing color information for the <B>OBJECT</B>. Bits 23-16 contain a signed <B>BYTE</B> representing the border thickness of the box.</FONT>
</TD></TR>

<TR><TH><B>G_TEXT</B></TH><TD><FONT SIZE=2>The <I>ob_spec</I> field contains a pointer to a <a name=tedinfo><B>TEDINFO</B> structure.</FONT>
</TD></TR>

<TR><TH><B>G_BOXTEXT</B></TH><TD><FONT SIZE=2>The <I>ob_spec</I> field contains a pointer to a <B>TEDINFO</B> structure.</FONT>
</TD></TR>

<TR><TH><B>G_IMAGE</B></TH><TD><FONT SIZE=2>The <I>ob_spec</I> field points to a ><B>BITBLK</B> structure.</FONT>
</TD></TR>

<TR><TH><B>G_PROGDEF</B></TH><TD><FONT SIZE=2>The <I>ob_spec</I> field points to a <B>APPLBLK</B> structure.</FONT>
</TD></TR>

<TR><TH><B>G_IBOX</B></TH><TD><FONT SIZE=2>The low 16 bits contain a <B>WORD</B> containing color information for the <B>OBJECT</B>. Bits 23-16 contain a signed <B>BYTE</B> representing the border thickness of the box.</FONT>
</TD></TR>

<TR><TH><B>G_BUTTON</B></TH><TD><FONT SIZE=2>The <I>ob_spec</I> field contains a pointer to the text to be contained in the button.</FONT>
</TD></TR>

<TR><TH><B>G_BOXCHAR</B></TH><TD><FONT SIZE=2>The low 16 bits contain a <B>WORD</B> containing color information for the <B>OBJECT</B>. Bits 23-16 contain a signed <B>BYTE</B> representing the border thickness of the box. Bits 31-24 contain the ASCII value of the character to display.</FONT>
</TD></TR>

<TR><TH><B>G_STRING</B></TH><TD><FONT SIZE=2>The <I>ob_spec</I> field contains a pointer to the text to be displayed.</FONT>
</TD></TR>

<TR><TH><B>G_FTEXT</B></TH><TD><FONT SIZE=2>The <I>ob_spec</I> field contains a pointer to a <B>TEDINFO</B> structure.</FONT>
</TD></TR>

<TR><TH><B>G_FBOXTEXT</B></TH><TD><FONT SIZE=2>The <I>ob_spec</I> field contains a pointer to a <B>TEDINFO</B> structure.</FONT>
</TD></TR>

<TR><TH><B>G_ICON</B></TH><TD><FONT SIZE=2>The <I>ob_spec</I> field contains a pointer to an <a name=iconblk_structure><B>ICONBLK</B> structure.</FONT>
</TD></TR>

<TR><TH><B>G_TITLE</B></TH><TD><FONT SIZE=2>The <I>ob_spec</I> field contains a pointer to the text to be used for the title.</FONT>
</TD></TR>

<TR><TH><B>G_CICON</B></TH><TD><FONT SIZE=2>The <I>ob_spec</I> field contains a pointer to a <B>CICONBLK</B> structure.</FONT>
</TD></TR>

</TABLE>

<P>

<a name=structure><H5>Object-Specific Structures</H5>

<P>
Almost all objects reference a <B>WORD</B> containing the object
color as defined below (note the definition below may need to
be altered depending upon the bit ordering of your compiler).
<PRE>
typedef struct <a name=objccolorword><a name=colorword><a name=objccolorwordstructure>objc_colorword
{
	UWORD		borderc	: 4;		/* Bits 15-12 contain the border color */
	UWORD		textc	: 4;		/* Bits 11-8 contain the text color */
	UWORD		opaque	: 1;		/* Bit 7 is 1 if opaque or 0 if transparent */
	UWORD		pattern	: 3;		/* Bits 6-4 contain the fill pattern index */
	UWORD		fillc	: 4;		/* Bits 3-0 contain the fill color */
} OBJC_COLORWORD;

</PRE>

<P>
Available colors for fill patterns, text, and borders are listed
below:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Name</FONT></B></TH><TH>
<CENTER>
<B><FONT SIZE=2 >Value</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Color</FONT></B></TH></TR>

<TR><TH><B>WHITE</B></TH><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>White</FONT></TD></TR>

<TR><TH><B>BLACK</B></TH><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Black</FONT></TD></TR>

<TR><TH><B>RED</B></TH><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Red</FONT></TD></TR>

<TR><TH><B>GREEN</B></TH><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Green</FONT></TD></TR>

<TR><TH><B>BLUE</B></TH><TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Blue</FONT></TD></TR>

<TR><TH><B>CYAN</B></TH><TD>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Cyan</FONT></TD></TR>

<TR><TH><B>YELLOW</B></TH><TD>
<CENTER>
<FONT SIZE=2>6</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Yellow</FONT></TD></TR>

<TR><TH><B>MAGENTA</B></TH><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Magenta</FONT></TD></TR>

<TR><TH><B>LWHITE</B></TH><TD>
<CENTER>
<FONT SIZE=2>8</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Light Gray</FONT></TD></TR>

<TR><TH><B>LBLACK</B></TH><TD>
<CENTER>
<FONT SIZE=2>9</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Dark Gray</FONT></TD></TR>

<TR><TH><B>LRED</B></TH><TD>
<CENTER>
<FONT SIZE=2>10</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Light Red</FONT></TD></TR>

<TR><TH><B>LGREEN</B></TH><TD>
<CENTER>
<FONT SIZE=2>11</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Light Green</FONT></TD></TR>

<TR><TH><B>LBLUE</B></TH><TD>
<CENTER>
<FONT SIZE=2>12</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Light Blue</FONT></TD></TR>

<TR><TH><B>LCYAN</B></TH><TD>
<CENTER>
<FONT SIZE=2>13</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Light Cyan</FONT></TD></TR>

<TR><TH><B>LYELLOW</B></TH><TD>
<CENTER>
<FONT SIZE=2>14</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Light Yellow</FONT></TD></TR>

<TR><TH><B>LMAGENTA</B></TH><TD>
<CENTER>
<FONT SIZE=2>15</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Light Magenta</FONT></TD></TR>

</TABLE>

<P>

<H5>TEDINFO</H5>

<P>
<B>G_TEXT</B>, <B>G_BOXTEXT</B>, <B>G_FTEXT</B>, and <B>G_FBOXTEXT</B>
objects all reference a <B>TEDINFO</B> structure in their <I>ob_spec</I>
field. The <B>TEDINFO</B> structure is defined below:
<PRE>
typedef struct text_edinfo
{
	char *	te_ptext;
	char *	te_ptmplt;
	char *	te_pvalid;
	WORD		te_font;
	WORD		te_fontid;
	WORD		te_just;
	WORD		te_color;
	WORD		te_fontsize;
	WORD		te_thickness;
	WORD		te_txtlen;
	WORD		te_tmplen;
} TEDINFO;

</PRE>

<P>
The three character pointer point to text strings required for
<B>G_FTEXT</B> and <B>G_FBOXTEXT</B> objects. <I>te_ptext</I>
points to the actual text to be displayed and is the only field
used by all text objects. <I>te_ptmplt</I> points to the text
template for editable fields. For each character that the user
can enter, the text string should contain a tilde character (ASCII
126). Other characters are displayed but cannot be overwritten
by the user. <I>te_pvalid</I> contains validation characters for
each character the user may enter. The current acceptable validation
characters are:
<TABLE BORDER=1>

<TR><TH>
<CENTER>
<B><FONT SIZE=1 >Character</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Allows</FONT></B></TH>
</TR>

<TR><TD>
<CENTER>
9
</CENTER>
</TD><TD><FONT SIZE=2>Digits 0-9</FONT>
</TD></TR>

<TR><TD>
<CENTER>
A
</CENTER>
</TD><TD><FONT SIZE=2>Uppercase letters A-Z plus space</FONT>
</TD></TR>

<TR><TD>
<CENTER>
a
</CENTER>
</TD><TD><FONT SIZE=2>Upper and lowercase letters plus space</FONT>
</TD></TR>

<TR><TD>
<CENTER>
N
</CENTER>
</TD><TD><FONT SIZE=2>Digits 0-9, uppercase letters A-Z, and space</FONT>
</TD></TR>

<TR><TD>
<CENTER>
n
</CENTER>
</TD><TD><FONT SIZE=2>Digits 0-9, upper and lowercase letters A-Z, and space</FONT>
</TD></TR>

<TR><TD>
<CENTER>
F
</CENTER>
</TD><TD><FONT SIZE=2>Valid <B>GEMDOS</B> filename characters plus question mark and asterisk</FONT>
</TD></TR>

<TR><TD>
<CENTER>
P
</CENTER>
</TD><TD><FONT SIZE=2>Valid <B>GEMDOS</B> pathname characters plus backslash, colon, question mark, and asterisk</FONT>
</TD></TR>

<TR><TD>
<CENTER>
p
</CENTER>
</TD><TD><FONT SIZE=2>Valid <B>GEMDOS</B> pathname characters plus backslash and colon</FONT>
</TD></TR>

<TR><TD>
<CENTER>
X
</CENTER>
</TD><TD><FONT SIZE=2>All characters</FONT>
</TD></TR>

</TABLE>

<P>

<P>
As an example the following diagram shows the correct text, template,
and <a name=validationstring>validation strings for obtaining a <B>GEMDOS</B> filename
from the user.
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >String</FONT></B></TH><TH><B><FONT SIZE=2 >Contents</FONT></B>
</TH></TR>

<TR><TH><I>te_ptext</I></TH><TD><FONT SIZE=2>'\0' (<B>NULL</B> char)</FONT>
</TD></TR>

<TR><TH><I>te_ptmplt</I></TH><TD><FONT SIZE=2>________.___</FONT>
</TD></TR>

<TR><TH><I>te_pvalid</I></TH><TD><FONT SIZE=2>FFFFFFFFFFF</FONT>
</TD></TR>

</TABLE>

<P>

<P>
<I>te_font</I> may be set to any of the following values:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Name</FONT></B></TH><TH>
<CENTER>
<I><B><FONT SIZE=2 >te_font</FONT></B></I>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Meaning</FONT></B></TH>
</TR>

<TR><TH><B>GDOS_PROP</B></TH><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Use a <B>SpeedoGDOS</B> font (valid only with an <B>AES</B> version of at least 4.0 and <B>SpeedoGDOS</B> installed).</FONT>
</TD></TR>

<TR><TH><B>GDOS_MONO</B></TH><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Use a <B>SpeedoGDOS</B> font (valid only with an <B>AES</B> version of at least 4.1 and <B>SpeedoGDOS</B> installed) and force monospaced output.</FONT>
</TD></TR>

<TR><TH><B>GDOS_BITM</B></TH><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Use a <B>GDOS</B> bitmap font (valid only with an <B>AES</B> version of at least 4.1 and <B>SpeedoGDOS</B> installed).</FONT>
</TD></TR>

<TR><TH><B>IBM</B></TH><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Use the standard monospaced system font.</FONT>
</TD></TR>

<TR><TH><B>SMALL</B></TH><TD>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Use the small monospaced system font.</FONT>
</TD></TR>

</TABLE>

<P>

<P>
When using a value of <B>GDOS_PROP</B>, <B>GDOS_MONO</B>, or <B>GDOS_BITM</B>,
<I>te_fontsize</I> specifies the font size in points and <I>te_fontid</I>
specifies the <B>SpeedoGDOS</B> font identification number. Selecting
the <B>IBM</B> or <B>SMALL</B> font will cause <I>te_fontsize</I>
and <I>te_fontid</I> to be ignored.
<P>
<I>te_just</I> sets the justification of the text output as follows:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 FFFFF>Name</FONT></B></TH><TH>
<CENTER>
<I><B><FONT SIZE=2 >te_just</FONT></B></I>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Meaning</FONT></B></TH>
</TR>

<TR><TH><B>TE_LEFT</B></TH><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Left Justify</FONT></TD></TR>

<TR><TH><B>TE_RIGHT</B></TH><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Right Justify</FONT></TD></TR>

<TR><TH><B>TE_CNTR</B></TH><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Center</FONT></TD></TR>

</TABLE>

<P>

<P>
<I>te_thickness</I> sets the border thickness (positive and negative
values are acceptable) of the <B>G_BOXTEXT</B> or <B>G_FBOXTEXT</B>
object. <I>te_txtlen</I> and <I>te_tmplen</I> should be set to
the length of the starting text and template length respectively.
<a name=bitblk<H5>BITBLK</H5>

<P>
<B>G_IMAGE</B> objects contain a pointer to a <B>BITBLK</B> structure
in their <I>ob_spec</I> field. The <B>BITBLK</B> structure is
defined as follows:
<PRE>
typedef struct bit_block
{
	WORD			*bi_pdata;
	WORD			bi_wb;
	WORD			bi_hl;
	WORD			bi_x;
	WORD			bi_y;
	WORD			bi_color;
} BITBLK;

</PRE>

<P>
<I>bi_pdata</I> should point to a monochrome bit image. <I>bi_wb</I>
specifies the width (in bytes) of the image. All <B>BITBLK</B>
images must be a multiple of 16 pixels wide therefore this value
must be even.
<P>
<I>bi_hl</I> specifies the height of the image in scan lines (rows).
<I>bi_x</I> and <I>bi_y</I> are used as offsets into <I>bi_pdata</I>.
Any data occurring before these coordinates will be ignored. <I>bi_color</I>
is a standard color <B>WORD</B> where the fill color specifies
the color in which the image will be rendered.
<H5>ICONBLK</H5>

<P>
The <I>ob_spec</I> field of <B>G_ICON</B> objects point to an
<B>ICONBLK</B> structure as defined below:
<PRE>
typedef struct icon_block
{
	WORD *		ib_pmask;
	WORD *		ib_pdata;
	char *		ib_ptext;
	WORD		ib_char;
	WORD		ib_xchar;
	WORD		ib_ychar;
	WORD		ib_xicon;
	WORD		ib_yicon;
	WORD		ib_wicon;
	WORD		ib_hicon;
	WORD		ib_xtext;
	WORD		ib_ytext;
	WORD		ib_wtext;
	WORD		ib_htext;
} ICONBLK;

</PRE>

<P>
<I>ib_pmask</I> and <I>ib_pdata</I> are pointers to the monochrome
mask and image data respectively. <I>ib_ptext</I> is a string
pointer to the icon text. <I>ib_char</I> defines the icon character
(used for drive icons) and the icon foreground and background
color as follows:
<TABLE BORDER=1>

<TR><TH COLSPAN=3>
<CENTER>
<I><B>ib_char</B></I>
</CENTER>

</TH></TR>

<TR><TH>
<CENTER>
<B><FONT SIZE=1 >Bits 15-12</FONT></B>
</CENTER>

</TH><TD>
<CENTER>
<B><FONT SIZE=2 >Bits 11-8</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bits 7-0</FONT></B>
</CENTER>

</TD></TR>

<TR><TD>
<CENTER>
Icon Foreground Color
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>Icon Background Color</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>ASCII Character (or 0 for no character).</FONT>
</CENTER>

</TD></TR>

</TABLE>

<P>

<P>
<I>ib_xchar</I> and <I>ib_ychar</I> specify the location of the
icon character relative to <I>ib_xicon</I> and <I>ib_yicon</I>.
<I>ib_xicon</I> and <I>ib_yicon</I> specify the location of the
icon relative to the <I>ob_x</I> and <I>ob_y</I> of the object.
<I>ib_wicon</I> and <I>ib_hicon</I> specify the width and height
of the icon in pixels. As with images, icons must be a multiple
of 16 pixels in width.
<P>
<I>ib_xtext</I> and <I>ib_ytext</I> specify the location of the
text string relative to the <I>ob_x</I> and <I>ob_y</I> of the
object. <I>ib_wtext</I> and <I>ib_htext</I> specify the width
and height of the icon text area.
<a name=ciconblk><H5>CICONBLK</H5>

<P>
The <B>G_CICON</B> object (available as of <B>AES</B> version
3.3) defines its <I>ob_spec</I> field to be a pointer to a <B>CICONBLK</B>
structure as defined below:
<PRE>
typedef struct cicon_blk
{
	ICONBLK		monoblk;
	CICON *		mainlist;
} CICONBLK;

</PRE>

<P>
<I>monoblk</I> contains a monochrome icon which is rendered if
a color icon matching the display parameters cannot be found.
In addition, the icon text, character, size, and positioning data
from the monochrome icon are always used for the color one. <I>mainlist</I>
points to the first <a name=cicon><B>CICON</B> structure in a linked list of
color icons for different resolutions. <B>CICON</B> is defined
as follows:
<PRE>
typedef struct cicon_data
{
	WORD					num_planes;
	WORD *				col_data;
	WORD *				col_mask;
	WORD *				sel_data;
	WORD *				sel_mask;
	struct cicon_data *	next_res;
} CICON;

</PRE>

<P>
<I>num_planes</I> indicates the number of bit planes this color
icon contains. <I>col_data</I> and <I>col_mask</I> point to the
icon data and mask for the unselected icon respectively. Likewise,
<I>sel_data</I> and <I>sel_mask</I> point to the icon data and
mask for the selected icon. <I>next_res</I> points to the next
color icon definition or <B>NULL</B> if no more are available.
Bitmap data pointed to by these variables should be in <B>VDI</B>
device-dependent format (they are stored as device-independent
images in a .RSC file).
<P>
The <B>AES</B> searches the <B>CICONBLK</B> object for a color
icon that has the same number of planes in the display. If none
is found, the <B>AES</B> simply uses the monochrome icon.
<H5>APPLBLK</H5>

<P>
<B>G_PROGDEF</B> objects allow programmers to define custom objects
and link them transparently in the resource. The <I>ob_spec</I>
field of <B>G_PROGDEF</B> objects contains a pointer to an <B>APPLBLK</B>
as defined below:
<PRE>
typedef struct appl_blk
<FONT SIZE=2>{
WORD		(*ab_code)(PARMBLK *);
</FONT>	LONG		ab_parm;
<FONT SIZE=2>} APPLBLK;
</FONT>
</PRE>

<P>
<I>ab_code</I> is a pointer to a user-defined routine which will
draw the object. The routine will be passed a pointer to a <a name=parmblk><B>PARMBLK</B>
structure containing the information it needs to render the object.
The routine must be defined with stack checking off and expect
to be passed its parameter on the stack. <I>ab_parm</I> is a user-defined
value which is copied into the <B>PARMBLK</B> structure as defined
below:
<PRE>
typedef struct parm_blk
{
	OBJECT		*tree;
	WORD		pb_obj;
	WORD		pb_prevstate;
	WORD		pb_currstate;
	WORD		pb_x;
	WORD		pb_y;
	WORD		pb_w;
	WORD		pb_h;
	WORD		pb_xc;
	WORD		pb_yc;
	WORD		pb_wc;
	WORD		pb_hc;
	LONG		pb_parm;
} PARMBLK;

</PRE>

<P>
<I>tree</I> points to the <B>OBJECT</B> tree of the object being
drawn. The object is located at index <I>pb_obj</I>.
<P>
The routine is passed the old <I>ob_state</I> of the object in
<I>pb_prevstate</I> and the new <I>ob_state</I> of the object
in <I>pb_currstate</I>. If <I>pb_prevstate</I> and <I>pb_currstate</I>
is equal then the object should be drawn completely, otherwise
only the drawing necessary to redraw the object from <I>pb_prevstate</I>
to <I>pb_currstate</I> are necessary.
<P>
<I>pb_x</I>, <I>pb_y</I>, <I>pb_w</I>, and <I>pb_h </I>give the
screen coordinates of the object. <I>pb_xc</I>, <I>pb_yc</I>,
<I>pb_wc</I>, and <I>pb_hc</I> give the rectangle to clip to.
<I>pb_parm</I> contains a copy of the <I>ap_parm</I> value in
the <B>APPLBLK</B> structure.
<P>
The custom routine should return a <B>WORD</B> containing any
remaining <I>ob_state</I> bits you wish the <B>AES</B> to draw
over your custom object.
<P>
Because the drawing routing will be called from the context of
the <B>AES</B>, using the stack heavily or defining many local
variables is not recommended.
<HR>

<a name=dialogs><H4><FONT SIZE=4 >Dialogs</FONT></H4>

<HR>

<P>
Dialog boxes are modal forms of user input. This means that no
other interaction can occur between the user and applications
until the requirements of the dialog have been met and it is exited.
A normal dialog box consists of an <B>OBJECT</B> tree with a <B>BOX</B>
<a name=udc>as its root object and any number of other controls that accept
user input. Both alert boxes and the file selector are examples
of <B>AES</B> provided dialog boxes.
<P>
The <B>AES</B> <a name=form_do><B>form_do()</B> function is the simplest method
of using a dialog box. Simply construct an <B>OBJECT</B> tree
with at least one <B>EXIT</B> or <B>TOUCHEXIT</B> object and call
<B>form_do()</B>. All interaction with the dialog like editable
fields, radio buttons, and selectable objects will be maintained
by the <B>AES</B> until the user strikes an <B>EXIT</B> or <B>TOUCHEXIT</B>
object. The proper method for displaying a dialog box is shown
in the example below:
<PRE>
WORD
do_dialog( OBJECT *tree, WORD first_edit )
{
	GRECT g;
	WORD ret;

	/* Reserve screen/mouse button */
	wind_update( BEG_UPDATE );
	wind_update( BEG_MCTRL );

	<a name=clipping>/* Center dialog on screen and put clipping rectangle in g */
	<a name=form_center>form_center( tree, &amp;g.g_x, &amp;g.g_y, &amp;g.g_w, &amp;g.g_h );

	/* Reserve screen space and draw growing box */
	<a name=form_dial>form_dial( FMD_START, 0, 0, 0, 0, g.g_x, g.g_y, g.g_w, g.g_h );
<FONT SIZE=2>	form_dial( FMD_GROW, g.g_x + g.g_w/2, g.g_y + g.g_h/2, 0, 0, g.g_x, g.g_y, 			g.g_w, g.g_h );

</FONT>	/* Draw the dialog box */
<FONT SIZE=2>	<a name=objcdraw>objc_draw( tree, ROOT, MAX_DEPTH, g.g_x, g.g_y, g.g_w, g.g_h );

</FONT>	/* Handle dialog */
<FONT SIZE=2><a name=form_do2>	ret = form_do( tree, first_edit );	

</FONT>	/* Deselect EXIT button */
<FONT SIZE=2>	tree[ret].ob_state &amp;= ~SELECTED;	

</FONT>	/* Draw shrinking box and release screen area */
<FONT SIZE=2>	form_dial( FMD_SHRINK, g.g_x + g.g_w/2, g.g_y + g.g_h/2, 0, 0, g.g_x, g.g_y, 			g.g_w, g.g_h );
</FONT>	form_dial( FMD_FINISH, 0, 0, 0, 0, g.g_x, g.g_y, g.g_w, g.g_h );

<FONT SIZE=2>	/* Release screen/mouse control. */
</FONT>	wind_update( END_MCTRL );
<FONT SIZE=2>	wind_update( END_UPDATE );

</FONT>	/* Return the object selected */
<FONT SIZE=2>	return ret;
</FONT>}

</PRE>

<P>
You may wish to create your own specialized dialog handling routines
or place dialog boxes in windows to create modeless input. This
can be accomplished by using the <a name=form_button><B>form_button()</B>, <a name=form_keybd><B>form_keybd()</B>,
and <a name=objcedit><B>objc_edit() AES</B> calls. Specific information about these
calls may be found in the <I><B>Function Reference</B></I>.
<P>
<B>GEM</B> also provides two generic dialog boxes through the
<B><a name=form_alert>form_alert()</B> and <a name=form_error><B>form_error()</B> calls. <B>form_alert()</B>
displays an alert dialog with a choice between icons and user-defined
text and buttons. <B>form_error()</B> displays an alert based
on predefined system error codes.
<HR>

<a name=menus><H4><FONT SIZE=4 >Menus</FONT></H4>

<HR>

<P>
Most <B>GEM</B> applications use a menu bar to allow the user
to navigate through program options. In addition, newer versions
of the <B>AES</B> now allow <a name=popupmenus2><a name=popupmenus>popup menus and <a name=ddlb>drop-down list boxes
(a special form of a popup menu). Menus are simply specially designed
<B>OBJECT</B> trees activated using special <B>AES</B> calls.
<H5>The Menu Bar</H5>

<P>
The menu bar is a special <B>OBJECT</B> which is usually registered
in the beginning stages of a <B>GEM</B> program which contains
choices which the user may select to trigger a special menu event
(<B>MN_SELECTED</B>) to be sent to the application's message loop.
Normally, you will use a <a name=resourceconstructionset>resource construction set to create a
menu but if you are designing an <B>RCS</B> or must create a menu
bar by hand, the format for the <B>OBJECT</B> structure of a <B>GEM</B>
menu bar is shown below:
<center><br><img src="../graphics/chap624.gif"></center>
<P>
The <B>ROOT</B> object is a <B>G_IBOX</B> and should be set to
the same width and height of the screen. It has two children,
the <B>BAR</B> object and the <B>DROPDOWNS</B> object.
<P>
The <B>BAR</B> object is a <B>G_BOX</B> which should be the width
of the screen and the height of the <a name=systemfont>system font plus two pixels
for a border line. The <B>DROPDOWNS</B> object is a <B>G_IBOX</B>
and should be of a size large enough to encompass all of the drop-down
menu boxes.
<P>
The <B>BAR</B> object has one child, the <B>ACTIVE</B> object,
it should be the width of the screen and the height of the system
font. It has as many <B>G_TITLE</B> children as there are menu
titles.
<P>
The <B>DROPDOWNS</B> object has the same number of <B>G_BOX</B>
child objects as the <B>ACTIVE</B> object has <B>G_TITLE</B> children.
Each box must be high enough to support the number of <B>G_STRING</B>
menu items and wide enough to support the longest item. Each <B>G_BOX</B>
must be aligned so that it falls underneath its corresponding
<B>G_TITLE</B>. In addition, each <B>G_STRING</B> menu item should
be the same length as its parent <B>G_BOX</B> object.
<P>
Each <B>G_STRING</B> menu item should be preceded by two spaces.
Each <B>G_TITLE</B> should be preceded and followed by one space.
The first <B>G_BOX</B> object should appear under a <B>G_TITLE</B>
object named 'Desk' and should contain eight children. The first
child <B>G_STRING</B> is application defined (it usually leads
to the 'About...' program credits), the second item should be
a disabled separator ('-----------') line. The next six items
are dummy objects used by the <B>AES</B> to display program and
desk accessory titles. 
<H5>Utilizing a Menu Bar</H5>

<P>
<a name=menubar>Menu bars can be displayed and their handling initiated by calling
<B>menu_bar()</B>. In addition, using this command, a menu bar
may be turned off or replaced with another menu bar at any time.
<P>
<a name=menuicheck>Individual menu items may be altered with three <B>AES</B> calls.
<B>menu_icheck()</B> sets or removes a checkmark from in front
of menu items. <B>menu_ienable()</B> enables or disables a menu
item. <B>menu_itext()</B> alters the text of a menu item. After
receiving a message indicating that a menu item has been clicked,
perform the action appropriate to the menu item and then call
<a name=menutnormal><B>menu_tnormal()</B> to return the menu title text to normal
video.
<a name=hmenus><H5>Hierarchical Menus</H5>

<P>
<B>AES</B> versions 3.3 and above support hierarchical submenus.
When a submenu is attached to a regular menu item, a right arrow
is appended to the end of the menu item text and a submenu is
displayed whenever the mouse is positioned over the menu item.
The user may select submenu items which cause an extended version
of the <B>MN_SELECTED</B> message to be delivered (containing
the menu object tree).
<P>
Up to 64 submenu attachments may be in effect at any time per
process. Attaching a single submenu to more than one menu item
counts as only one attachment.
<P>
Submenus should be <B>G_BOX</B> objects with as many <B>G_STRING</B>
(or other) child objects as necessary. One or several submenus
may be contained in a single <B>OBJECT</B> tree. If the submenu's
scroll flag is set, scroll arrows will appear and the menu will
be scrollable if it contains more items than the currently set
system scroll value. Submenus containing user-defined objects
should not have their scroll flag set.
<P>
<a name=memattach>Submenus are attached and removed with the <B>menu_attach()</B>
call. A serious bug exists in <B>AES</B> versions lower than 4.0
which causes <B>menu_attach()</B> to crash the system if you use
it to remove or inquire the state of an existing submenu. This
means that submenus may only be removed in <B>AES</B> versions
4.0 and above. Submenus may be nested to up to four levels though
only one level is recommended.
<P>
Submenus may not be attached to menu items in the left-most 'Desk'
menu. Individual submenu items may be aligned with the parent
object by using <a name=menuistart><B>menu_istart()</B>. 
<a name=popupmenus><H5>Popup Menus</H5>

<P>
<B>AES</B> versions 3.3 and above support popup menus. Popup menus
share the same <B>OBJECT</B> structure as hierarchical menus but
are never attached to a parent menu item. They may be displayed
anywhere on the screen and are often called in response to selecting
a special dialog item (see <I>Chapter 11: <B>GEM User Interface
Guidelines</B></I>).  Popup menus are displayed with the <B>AES</B>
call <a name=menupopup><B>menu_popup()</B>.
<H5>Menu Settings</H5>

<P>
<a name=system2>The <B>AES</B> call <a name=menusettings><B>menu_settings()</B> may be used to adjust
certain global defaults regarding the appearance and timing delays
of submenus and popup menus. Because this call affects all system
applications it should only be utilized by a system configuration
utility and not by individual applications.
<a name=ddlb2><H5>Drop-Down List Boxes</H5>

<P>
<B>AES</B> versions 4.0 and later support a special type of popup
menu called a drop-down list box. Setting the menu scroll flag
to a value of -1 will cause a popup menu to be displayed as a
drop-down list instead.
<P>
A drop-down list reveals up to eight items from a multiple item
list to the user. A <a name=sliderbar>slider bar is displayed next to the list and
is automatically handled during the <B>menu_popup()</B> call.
Several considerations must be taken when using a drop-down list
box:
<P>
 Drop-down lists may only contain <B>G_STRING</B> objects.
<P>
 If you want to force the AES to always draw scroll bars for the
list box, the <B>OBJECT</B> tree must contain at least eight <B>G_STRING</B>
objects. If less than that number of items exist, pad the remaining
items with blanks and set the object's <B>DISABLED</B> flag.
<P>
 As long as the <B>OBJECT</B> tree has at least eight <B>G_STRING</B>
objects, it should not be padded with any additional objects since
the size of the slider is based on the number of objects.
<a name=menubuffer><H5>The Menu Buffer</H5>

<P>
A special memory area is allocated by the <B>AES</B> so that it
may reserve the screen area underneath displayed menus. A pointer
to this memory and its length may be obtained by calling <a name=windget><B>wind_get(
WF_SCREEN</B>, ... <B>)</B>. Menu buffer memory may be used as
a temporary holding arena for applications as long as the following
rules are maintained:
<P>
 The application must not use a menu bar or it must be locked
with <a name=windupdate><B>wind_update(&nbsp;BEG_UPDATE )</B>.
<P>
 Access to the <a name=menubuffer2>menu buffer in a multitasking  is not
controlled so information stored by one application may be overwritten
by another. It is therefore recommended that the menu buffer should
not be used under <B>MultiTOS</B>. 
<HR>

<a name=windows><a name=window><H4><FONT SIZE=4 >Windows</FONT></H4>

<HR>

<P>
<B>GEM</B> applications usually maintain most user-interaction
in windows. Windows are workspaces created with <a name=windcreate><B>wind_create()</B>
with any of several predefined gadgets (controls) illustrated
in the diagram and table below:
<center><br><img src="../graphics/chap627.gif"></center>
<p><TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Name</FONT></B></TH><TH><B><FONT SIZE=2 >Mask</FONT></B>
</TH><TH><B><FONT SIZE=2 >Meaning</FONT></B></TH>
</TR>

<TR><TH><B>NAME</B></TH><TD><FONT SIZE=2>0x0001</FONT></TD><TD><FONT SIZE=2>Using this mask will cause the <B>AES</B> to display the window with a title bar containing a name that the application should set with <B>wind_set( WF_NAME,</B> ... <B>)</B>.</FONT>
</TD></TR>

<TR><TH><B>CLOSER</B></TH><TD><FONT SIZE=2>0x0002</FONT></TD>
<TD><FONT SIZE=2>This mask will attach a closer box to the window which, when pressed, will send a <B>WM_CLOSED</B> message to the application.</FONT>
</TD></TR>

<TR><TH><B>FULLER</B></TH><TD><FONT SIZE=2>0x0004</FONT></TD>
<TD><FONT SIZE=2>This mask displays a fuller box with the window which, when pressed, will cause a <B>WM_FULLED</B> message to be sent to the application.</FONT>
</TD></TR>

<TR><TH><B>MOVER</B></TH><TD><FONT SIZE=2>0x0008</FONT></TD><TD><FONT SIZE=2>This mask allows the user to move the window by clicking and dragging on the window's title bar. This action will generate a <B>WM_MOVED</B> message.</FONT>
</TD></TR>

<TR><TH><B>INFO</B></TH><TD><FONT SIZE=2>0x0010</FONT></TD><TD><FONT SIZE=2>This mask creates an information line just below the title bar which can contain any user-defined information as set with <B>wind_set( WF_INFO</B>, ...<B>)</B>.</FONT>
</TD></TR>

<TR><TH><B>SIZER</B></TH><TD><FONT SIZE=2>0x0020</FONT></TD><TD><FONT SIZE=2>This mask attaches a sizer object to the window which, when clicked and dragged to a new location, will generate a <B>WM_SIZED</B> message.</FONT>
</TD></TR>

<TR><TH><B>UPARROW</B></TH><TD><FONT SIZE=2>0x0040</FONT></TD>
<TD><FONT SIZE=2>This mask attaches an up arrow object to the window which, when pressed, will generate a <B>WM_ARROWED</B> message to the application.</FONT>
</TD></TR>

<TR><TH><B>DNARROW</B></TH><TD><FONT SIZE=2>0x0080</FONT></TD>
<TD><FONT SIZE=2>This mask attaches a down arrow object to the window which, when pressed, will generate a <B>WM_ARROWED</B> message to the application.</FONT>
</TD></TR>

<TR><TH><B>VSLIDE</B></TH><TD><FONT SIZE=2>0x0100</FONT></TD>
<TD><FONT SIZE=2>This mask attaches a vertical slider object to the window which, when clicked and dragged, will generate a <B>WM_VSLID</B> message. Clicking on the exposed area of the slider will also generate this message.</FONT>
</TD></TR>

<TR><TH><B>LFARROW</B></TH><TD><FONT SIZE=2>0x0200</FONT></TD>
<TD><FONT SIZE=2>This mask attaches a left arrow object to the window which, when pressed, will generate a <B>WM_ARROWED</B> message to the application.</FONT>
</TD></TR>

<TR><TH><B>RTARROW</B></TH><TD><FONT SIZE=2>0x0400</FONT></TD>
<TD><FONT SIZE=2>This mask attaches a right arrow object to the window which, when pressed, will generate a <B>WM_ARROWED</B> message to the application.</FONT>
</TD></TR>

<TR><TH><B>HSLIDE</B></TH><TD><FONT SIZE=2>0x0800</FONT></TD>
<TD><FONT SIZE=2>This mask attaches a horizontal slider object to the window which, when clicked and dragged, will generate a <B>WM_HSLID</B> message. Clicking on the exposed area of the slider will also generate this message.</FONT>
</TD></TR>

<TR><TH><B><a name=smallergadget>SMALLER</B></TH><TD><FONT SIZE=2>0x4000</FONT></TD>
<TD><FONT SIZE=2>This mask attaches a smaller object which, when clicked, will generate a <B>WM_ICONIFIED</B> message. If the object is ctrl-clicked, a <B>WM_ALLICONIFY</B> message will be generated.</FONT>This object is only valid in <B>AES</B> v4.1 and higher.
</TD></TR>

</TABLE>

<P>

<P>
<a name=windcreate2><B>wind_create()</B> returns a window handle which should be stored
as it must be referenced on any further calls that open, alter,
close, or delete the window. <B>wind_create()</B> may fail if
too many windows are already open. Different versions of the <B>AES</B>
impose different limits on the number of concurrently open windows.
<P>
Calling <B>wind_create()</B> does not automatically display the
window. <a name=windopen><B>wind_open()</B> displays a window named by its window
handle. Any calls needed to initialize the window (such as setting
the window title, etc.) should be made between the <B>wind_create()</B>
and <B>wind_open()</B> calls.
<P>
<B>wind_set()</B> and <a name=windget2><B>wind_get()</B> can be used to set and
retrieve many various window attributes. Look for their documentation
in the function reference for further details.
<P>
<a name=windclose><B>wind_close()</B> may be used to remove a window from the screen.
The window itself and its attributes are not deleted as a result
of this call, however. A subsequent call to <B>wind_open()</B>
will restore a window to the state it was in prior to the <B>wind_close()</B>
call. The <a name=winddelete><B>wind_delete()</B> function is used to physically
delete a window and free any memory it was using.
<P>
Two other utility functions for use in dealing with windows are
provided by the <B>AES</B>. <a name=windcalc><B>wind_calc()</B> will return the
border rectangle of a window given the desired work area or the
work area of a window given the desired border area. The call
takes into account the sizes of the various window gadgets.
<P>
<a name=windfind><B>wind_find()</B> returns the handle of the window currently
under the mouse.
<a name=desktop><H5>The Desktop Window</H5>

<P>
The desktop window encompasses the entire screen. It has a constant
window handle of <B>DESK&nbsp;</B>(0) so information about it
can be inquired with <B>wind_get()</B>. Calling <B>wind_get()</B>
with a parameter of <B>WF_CURRXYWH</B> will return the size of
the screen. Calling <B>wind_get()</B> with a parameter of <B>WF_WORKXYWH</B>
will return the size of the screen minus the size of the menu
bar.
<P>
The desktop draws a custom <B>OBJECT</B> tree in its work area.
This tree results in the fill pattern and color seen on screen.
An application may create its own custom desktop object tree by
using <B>wind_set()</B> with a parameter of <B>WF_DESKTOP</B>.
The <B>OBJECT</B> tree specified should be the exact size of the
desktop work area. 
<P>
<B>MultiTOS</B> will switch between these object trees as applications
are switched. The desktop's object tree will be visible whenever
an application doesn't specify one of its own.
<a name=rect><H5>The Rectangle List</H5>

<P>
Whenever a window receives a redraw message or needs to update
its window because of its reasons, it should always constrain
output to its current rectangle list. The <B>AES</B> will calculate
the size and position of a group of rectangles that compromise
the area of your window not covered by other overlapping windows.

<P>
<B>wind_get()</B> with parameters of <B>WF_FIRSTXYWH</B> and <B>WF_NEXTXYWH</B>
is used to return the current rectangle list. Redrawing inside
a window should also only be attempted when the window semaphore
is locked with <B>wind_update( BEG_UPDATE )</B>. This prevents
the rectangle list from changing during the redraw and prevents
the user from dropping down menus which might be overwritten.
The following code sample illustrates a routine that correctly
steps through the rectangle list:
<PRE>
	.
	.
	. Application Event Loop
	.
	case WM_REDRAW:
			RedrawWindow( msg[3], (GRECT *)&amp;msg[4] );
			break;
	.
	.


VOID
RedrawWindow( WORD winhandle, GRECT *dirty )
{
	GRECT rect;

	wind_update( BEG_UPDATE );
	
	wind_get( winhandle, WF_FIRSTXYWH, &amp;rect.g_x, &amp;rect.g_y, &amp;rect.g_w, &amp;rect.g_h);
	while( rect.g_w &amp;&amp; rect.g_h )
	{
			if( rc_intersect( dirty, &amp;rect ) )
			{
				/*
				 * Do your drawing here...constrained to the rectangle in g.
				 */
			}

<FONT SIZE=2>			wind_get( winhandle, WF_NEXTXYWH, &amp;rect.g_x, &amp;rect.g_y, &amp;rect.g_w, 					&amp;rect.g_h);
</FONT>	}

<FONT SIZE=2>	wind_update( END_UPDATE );
</FONT>}

</PRE>

<a name=toolbars><H5>Window Toolbars</H5>

<P>
<B>AES</B> versions 4.0 and later support window toolbar attachments.
Toolbars are <B>OBJECT</B> trees containing a number of <B>TOUCHEXIT</B>
objects. They are attached to a window using <B>wind_set()</B>
with a parameter of <B>WF_TOOLBAR</B>. The following diagram shows
a window with a toolbar:
<center><br><img src="../graphics/chap631.gif"></center>
<P>

<CENTER>

</CENTER>

<P>
Window toolbars are automatically redrawn whenever necessary and
their <B>ROOT</B> objects are automatically repositioned and resized
with the window. If any special redrawing is necessary (ex: changing
the visual state of an object after a click), the application
may obtain a special toolbar rectangle list by using <B>wind_get()</B>
with parameters of <B>WF_FTOOLBAR</B> and <B>WF_NTOOLBAR</B>.
<P>
If toolbar objects must be modified on <B>WM_SIZED</B> events,
simply modify them prior to calling <B>wind_set(</B> handle, <B>WM_CURRXYWH</B>,
... <B>)</B>.
<P>
A special note about windows with toolbars concerns the usage
of <a name=windcalc2><B>wind_calc()</B>. <B>wind_calc()</B> doesn't understand the
concept of toolbars. The information it returns must be modified
by adjusting the height of its output rectangles according to
the current height of the toolbar object tree.
<HR>

<a name=graphics><H4><FONT SIZE=4 >The Graphics Library</FONT></H4>

<HR>

<P>
The Graphics Library contain many functions which can be used
to provide visual clues to the user. This library also contains
functions to inquire and set information about the mouse pointer.
<P>
<a name=graf_movebox><B>graf_movebox()</B>, <a name=shrinkbox><B>graf_shrinkbox()</B>, and <a name=graf_gb><a name=graf_grow><B>graf_growbox()</B>
display animations that can be used to indicate an impending change
in the screen display. <a name=graf_db><B>graf_dragbox()</B>, <a name=rubberbox><B>graf_rubberbox()</B>,
and <a name=slidebox><B>graf_slidebox()</B> display visual effects that are interactively
changed by the mouse position.
<P>
<a name=graf_mkstate><B>graf_mkstate()</B> is used to inquire the current state of
the mouse buttons and mouse position. <a name=graf_mouse><B>graf_mouse()</B> can
be used to change the shape of the system mouse. <a name=graf_handle><B>graf_handle()</B>
is used to return the physical handle of the screen (needed to
open a <a name=workstation><B>VDI</B> workstation) and the metrics of the system default
text font.
<HR>

<a name=file><a name=filesel><H4><FONT SIZE=4 >The File Selector Library</FONT>
</H4>

<HR>

<P>
Two routines are provided by the <B>AES</B> to display and handle
the common system file selector. <B>AES</B> versions less than
1.4 do not support<B> fsel_exinput()</B>. All <B>AES</B> versions
support <a name=fsel_input><B>fsel_input()</B>.
<P>
Both calls take a <B>GEMDOS</B> pathname and filename as parameters.
The pathname should include a complete path specification including
a drive letter, colon, path, and filemask. The filemask may (and
usually does include wildcard characters). The application may
also pass a default filename to the selector.
<P>
<a name=fse><B>fsel_exinput()</B> allows the application to specify a replacement
title for the file selector which reminds the user about the action
they are taking such as 'Select a .DOC file to open...'. 
<HR>

<a name=scrap><H4><FONT SIZE=4 >The Scrap Library</FONT></H4>

<HR>

<P>
The <a name=scrpread><B>scrp_read()</B> and <a name=scrpwrite><B>scrp_write()</B> calls are provided
by the <B>AES</B> to return and set the current clipboard path.
The clipboard is a global resource in which applications can share
data. Applications supporting the clipboard contain an 'Edit'
menu title which has at least the following four items, 'Cut',
'Copy', 'Paste', and 'Delete'. An appropriate action for each
is listed below:
<H5>Implementing 'Cut' and 'Copy'</H5>

<P>
When the user selects 'Cut' or 'Copy' from the 'Edit' menu and
an object is selected ('Cut' and 'Copy' should only be enabled
in the menu when an object is selected which may be transferred
to the clipboard) the following steps may be used to transfer
the data to the system clipboard:
<P>
1. Call <B>scrp_read()</B> to return the name of the current scrap
directory. If the returned string is empty, no clipboard directory
has been defined since the computer has been started. The directory
string returned may need to be reformatted. A proper directory
string ends in a backslash, however some applications incorrectly
append a filename to this string.
<P>
2. If no clipboard directory was returned or the one specified
is invalid, create a directory in the user's boot drive called
'\CLIPBRD' and write the pathname back using <B>scrp_write()</B>.
For example, if the user's boot drive was 'C:' then your parameter
to<B> scrp_write()</B> would be 'C:\CLIPBRD\'.
<P>
3. Search and delete files in the current clipboard directory
with the mask 'SCRAP.*'.
<P>
4. Now write a disk file for the selected data to a file named
SCRAP.??? where '???' is the proper file extension for an object
of its type. If the object can be represented in more than one
format by your application, write as many formats as possible
all named 'SCRAP' with the proper file extension.
<P>
5. If the menu choice was 'Cut' rather than 'Copy,' delete the
object from your data structures and update your application as
necessary.
<H5>Implementing 'Paste'</H5>

<P>
'Paste' is used to read a file and insert it appropriately into
an application that supports data of its type. To implement 'Paste'
follow the steps below:
<P>
1. Call <B>scrp_read()</B> to obtain the current system clipboard
directory. If the returned string is empty, no data is in the
clipboard.
<P>
2. Format the string returned by <B>scrp_read()</B> into a usable
pathname and search for files called 'SCRAP' in that path having
a file extension of data that your application supports. Remember,
more than one SCRAP.??? file may be present.
<P>
3. Load the data and insert it in your application as appropriate.
<H5>MultiTOS Notes</H5>

<P>
The <B>AES</B>, when running under <B>MultiTOS</B>, will create
a <B>MiNT</B> semaphore named '_SCP' which should be used to provide
negotiated access to the scrap directory. Access to this semaphore
should be obtained from MiNT prior to any clipboard operation
and must be released as soon as it is complete. Applications should
not attempt to destroy this semaphore.  
<HR>

<a name=shell><H4><FONT SIZE=4 >The Shell Library</FONT></H4>

<HR>

<P>
The Shell Library was originally intended to provide <B>AES</B>
support to the Desktop application. Many of the routines, however,
are useful to other <B>GEM</B> applications. Some functionality
of the Shell Library was discussed earlier in this chapter in
<a name=evirostring2>'The Environment String'.
<a name=shellbuffer><H5>The Shell Buffer</H5>

<P>
The Desktop application loads the DESKTOP.INF or NEWDESK.INF file
(depending on the <B>TOS</B> version) into the shell buffer. Prior
to <B>TOS</B> 2.00, the shell buffer was 1024 bytes long meaning
that was the maximum length of the DESKTOP.INF file. <B>AES</B>
versions 2.00 to 3.30 allocate a buffer 4096 bytes long. <B>AES</B>
versions 3.30 and above support variable-length buffers.
<P>
The <a name=shellbuffer2>shell buffer contains the 'working' copy of the above mentioned
system files. The information in this buffer may be copied by
using <a name=shelget><B>shel_get()</B>. Likewise, information can be written
to this buffer using <B>shel_put()</B>. Extreme care must be used
with these functions as their misuse can confuse or possibly even
crash the Desktop.
<H5>Miscellaneous Shell Library Functions</H5>

<P>
<a name=shelfind><B>shel_find()</B> is used to locate data files associated with
an application. The <B>AES</B> uses this call to locate application
resource files during <B>rsrc_load()</B>.
<P>
<a name=shelread><B>shel_read()</B> returns information about the process which
called the application (usually the Desktop).
<P>
<a name=shelwrite2><B>shel_write()</B> was originally used only to spawn new applications.
With newer <B>AES</B> versions, though, <B>shel_write()</B> has
taken on an enormous functionality and its documentation should
be consulted for more information.
<HR>

<a name=cnf><H4><FONT SIZE=4 ><a name=gemcnf>The GEM.CNF File</FONT></H4>

<HR>

<P>
When running under <B>MultiTOS</B>, the <B>AES</B> will load and
process an ASCII text file called 'GEM.CNF' which contains command
lines that set environment and <B>AES</B> system variables and
may run <B>GEM</B> programs. In addition, a replacement shell
program may be specified in this file (see <I>Chapter 9: <B>Desktop</B></I>
for more information).
<P>
<B>AES</B> environment variables may be set in the 'GEM.CNF' file
with the command 'setenv' as in the following example:
<PRE>

<CENTER>
setenv TOSRUN=c:\multitos\miniwin.app
</CENTER>

</PRE>

<P>
Several <B>AES</B> system variables may also be set in this file
as shown in the following example:
<PRE>

<CENTER>
AE_FONTID=3
</CENTER>

</PRE>

<P>
Currently recognized <B>AES</B> system variables that may be set
are shown in the following table:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Variable</FONT></B></TH>
<TH><B><FONT SIZE=2 >Meaning</FONT></B></TH></TR>

<TR><TH><B>AE_FONTID</B></TH><TD><FONT SIZE=2>This variable may be set to any valid Speedo outline font ID which will be used as the <B>AES</B> default text font.</FONT>This feature is only valid as of <B>AES</B> version 4.1.
</TD></TR>

<TR><TH><B>AE_PNTSIZE</B></TH><TD><FONT SIZE=2>This variable defines the size of the <B>AES</B> default text font in points.</FONT>This feature is only valid as of <B>AES</B> version 4.1.
</TD></TR>

<TR><TH><B>AE_SREDRAW</B></TH><TD><FONT SIZE=2>Setting this variable to 1 causes the <B>AES</B> to send a full-screen redraw message whenever an application starts. Setting it to 0 disables this feature. The default is 1.</FONT>
</TD></TR>

<TR><TH><B>AE_TREDRAW</B></TH><TD><FONT SIZE=2>Setting this variable to 1 causes the <B>AES</B> to send a full-screen redraw message whenever an application terminates. Setting it to 0 disables this feature. The default is 1.</FONT>
</TD></TR>

</TABLE>

<P>

<P>
The 'GEM.CNF' file may also be used to automatically start applications
as shown in the following example:
<PRE>

<CENTER>
run c:\multitos\tclock.prg
</CENTER>

</PRE>

<HR>

<a name=calling><H4><FONT SIZE=4 >AES Function Calling Procedure</FONT>
</H4>

<HR>

<P>
The <B>GEM</B> <B>AES</B> is accessed through a 680x0 TRAP #2
statement. Upon calling the TRAP, register d0 should contain the
magic number 0xC8 and register d1 should contain a pointer to
the <B>AES</B> parameter block. The <I>global</I> data array member
of the parameter block is filled in with information about the
<B>AES</B> after an <B>appl_init()</B> call (see <B>appl_init()</B>
for more details). The <B>AES</B> parameter block is a structure
containing pointers to several arrays defined as follows:
<PRE>
struct aespb
{
	WORD *contrl;
	WORD *global;
	WORD *intin;
	WORD *intout;
	LONG *addrin;
	LONG *addrout; 
};

</PRE>

<P>
The <I>control</I> array is filled in prior to an <B>AES</B> call
with information about the number of parameters the function is
being passed, the number of return values the function expects,
and the opcode of the function itself as follows:
<TABLE BORDER=1>

<TR><TH>
<CENTER>
<I><B><FONT SIZE=1 >contrl[x]</FONT></B></I>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Contents</FONT></B></TH>
</TR>

<TR><TD>
<CENTER>
0
</CENTER>
</TD><TD><FONT SIZE=2>Function opcode.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
1
</CENTER>
</TD><TD><FONT SIZE=2>Number of <I>intin</I> elements the function is being sent.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
2
</CENTER>
</TD><TD><FONT SIZE=2>Number of <I>intout</I> elements the function is being sent.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
3
</CENTER>
</TD><TD><FONT SIZE=2>Number of <I>addrin</I> elements the function returns.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
4
</CENTER>
</TD><TD><FONT SIZE=2>Number of <I>addrout</I> elements the function returns.</FONT>
</TD></TR>

</TABLE>

<P>

<P>
 The <I>intin</I> array and <I>addrin</I> arrays are used to pass
integer and address parameters respectively (consult each individual
binding for details).
<P>
Upon return from the call, the <I>intout</I> and <I>addrout</I>
arrays will be filled in with any appropriate output values.
<P>
To add a binding for the <B>AES</B> to your compiler you will
usually write a short procedure that provides an interface to
the <B>AES</B> arrays. The following example illustrates the binding
to <a name=graf_db><B>graf_dragbox()</B> in this manner:
<PRE>
WORD
graf_dragbox( WORD width, WORD height, WORD start_x, WORD start_y,
				WORD box_x, WORD box_y, WORD box_w, WORD box_h,
				WORD *end_x, WORD *end_y )
{
	contrl[0] = 71;
	contrl[1] = 8;
	contrl[2] = 3;
	contrl[3] = 0;
	contrl[4] = 0;

	intin[0] = width;
	intin[1] = height;
	intin[2] = start_x;
	intin[3] = start_y;
	intin[4] = box_x;
	intin[5] = box_y;
	intin[6] = box_w;
	intin[7] = box_h;

	aes();

	*end_x = intout[1];
	*end_y = intout[2];

	return intout[0];
}

</PRE>

<P>
The following code is the assembly language function <B>aes()</B>
used by the function above:
<PRE>
			.globl		_aes
		
			.text
_aes:
			lea			_aespb,a0
			move.l		a0,d1
			move.w		#$C8,d0
			trap			#2
			lea			_intout,a0
			move.w		(a0),d0
			rts

			.data

_aespb:			.dc.l		_contrl, _global, _intin, _intout, _addrin, _addrout

			.bss

_contrl:		.ds.w		5
_global:		.ds.w		15
_intin:			.ds.w		16
_intout:		.ds.w		7
_addrin:		.ds.l		2
_addrout:	.ds.l		1

			.end

</PRE>

<P>
The bindings in the <I><B>AES Function Reference </B></I>call
a specialized function called <a name=crys><B>crys_if()</B> to actually call
the <B>AES</B>. Many compilers use this method as well (Lattice
C calls the function <B>_AESif()</B> ).
<P>
<B>crys_if()</B> properly fills in the <I>contrl</I> array and
calls the <B>AES</B>. It is passed one <B>WORD</B> parameter in
d0 which contains the opcode of the function minus ten multiplied
by four (for quicker table indexing). This gives an index into
a table from which the <I>contrl</I> array data may be loaded.
The <B>crys_if()</B> function is listed below:
<PRE>
			
* Note that this binding depends on the fact that no current AES call utilizes
* the addrout array

			.globl	_crys_if
			.globl	_aespb
			.globl	_contrl
			.globl	_global
			.globl	_intin
			.globl	_addrin
			.globl	_intout
			.globl	_addrout	
		
			.text

_crys_if:
			lea		table(pc),a0		; Table below
			move.l	0(a0,d0.w),d0		; Load four packed bytes into d0
			lea		_aespb,a0		; Load address of _aespb into a0
			movea.l	(a0),a1			; Move address of contrl into a1
			movep.l	d0,1(a1)			; Move four bytes into WORDs at 1(contrl)
			move.l	a0,d1			; Move address of _aespb into d1
			move.w	#$C8,d0			; AES magic number
			trap		#2				; Call GEM
			lea		_intout,a0		; Get return value
			move.w	(a0),d0			; Put it into d0
			rts

* Table of AES opcode/control values
* Values are: opcode, intin, intout, addrin
* As stated before, addrout is left at 0 since no AES calls use it

table:
			.dc.b		10, 0, 1, 0		; appl_init
			.dc.b		11, 2, 1, 1		; appl_read
			.dc.b		12, 2, 1, 1		; appl_write
			.dc.b		13, 0, 1, 1		; appl_find
			.dc.b		14, 2, 1, 1		; appl_tplay
			.dc.b		15, 1, 1, 1		; appl_trecord
			.dc.b		16, 0, 0, 0		; 
			.dc.b		17, 0, 0, 0		; 
			.dc.b		18, 1, 1, 3		; appl_search (v4.0)
			.dc.b		19, 0, 1, 0		; appl_exit
			.dc.b		20, 0, 1, 0		; evnt_keybd
			.dc.b		21, 3, 5, 0		; evnt_button
			.dc.b		22, 5, 5, 0		; evnt_mouse
			.dc.b		23, 0, 1, 1		; evnt_mesag
			.dc.b		24, 2, 1, 0		; evnt_timer
			.dc.b		25, 16, 7, 1		; evnt_multi
			.dc.b		26, 2, 1, 0		; evnt_dclick
			.dc.b		27, 0, 0, 0		; 
			.dc.b		28, 0, 0, 0		; 
			.dc.b		29, 0, 0, 0		; 
			.dc.b		30, 1, 1, 1		; menu_bar
			.dc.b		31, 2, 1, 1		; menu_icheck
			.dc.b		32, 2, 1, 1		; menu_ienable
			.dc.b		33, 2, 1, 1		; <a name=menutnormal2>menu_tnormal
			.dc.b		34, 1, 1, 2		; <a name=menutext>menu_text
			.dc.b		35, 1, 1, 1		; menu_register
			.dc.b		36, 2, 1, 2		; <a name=menupopup2>menu_popup (v3.3)
			.dc.b		37, 2, 1, 2		; menu_attach (v3.3)
			.dc.b		38, 3, 1, 1		; <a name=menu_istart2>menu_istart (v3.3)
			.dc.b		39, 1, 1, 1		; <a name=mneusettings2>menu_settings (v3.3)
			.dc.b		40, 2, 1, 1		; <a name=objcadd2>objc_add
			.dc.b		41, 1, 1, 1		; <a name=objcdelete2>objc_delete
			.dc.b		42, 6, 1, 1		; objc_draw
			.dc.b		43, 4, 1, 1		; <a name=objcfind2>objc_find
			.dc.b		44, 1, 3, 1		; <a name=objcoffset2>objc_offset
			.dc.b		45, 2, 1, 1		; <a name=objcorder2>objc_order
			.dc.b		46, 4, 2, 1		; <a name=objcedit2>objc_edit
			.dc.b		47, 8, 1, 1		; <a name=objcchange2>objc_change
			.dc.b		48, 4, 3, 0		; <a name=objcsysvar>objc_sysvar (v3.4)
			.dc.b		49, 0, 0, 0		; 
			.dc.b		50, 1, 1, 1		; form_do
			.dc.b		51, 9, 1, 0		; form_dial
			.dc.b		52, 1, 1, 1		; form_alert
			.dc.b		53, 1, 1, 0		; <a name=form_error2>form_error
			.dc.b		54, 0, 5, 1		; form_center
			.dc.b		55, 3, 3, 1		; <a name=form_keybd2>form_keybd
			.dc.b		56, 2, 2, 1		; <a name=form_button2>form_button
			.dc.b		57, 0, 0, 0		; 
			.dc.b		58, 0, 0, 0		; 
			.dc.b		59, 0, 0, 0		; 
			.dc.b		60, 0, 0, 0		; 
			.dc.b		61, 0, 0, 0		; 
			.dc.b		62, 0, 0, 0		; 
			.dc.b		63, 0, 0, 0		; 
			.dc.b		64, 0, 0, 0		; 
			.dc.b		65, 0, 0, 0		; 
			.dc.b		66, 0, 0, 0		; 
			.dc.b		67, 0, 0, 0		; 
			.dc.b		68, 0, 0, 0		; 
			.dc.b		69, 0, 0, 0		; 
			.dc.b		70, 4, 3, 0		; <a name=rubberbox2>graf_rubberbox
			.dc.b		71, 8, 3, 0		; graf_dragbox
			.dc.b		72, 6, 1, 0		; <a name=graf_movebox2>graf_movebox
			.dc.b		73, 8, 1, 0		;<a name=graf_gb2> graf_growbox
			.dc.b		74, 8, 1, 0		; <a name=shrinkbox2>graf_shrinkbox
			.dc.b		75, 4, 1, 1		; <a name=watchbox>graf_watchbox
			.dc.b		76, 3, 1, 1		; <a name=slidebox2>graf_slidebox
			.dc.b		77, 0, 5, 0		; <a name=graf_handle2>graf_handle
			.dc.b		78, 1, 1, 1		; <a name=graf_mouse2>graf_mouse
			.dc.b		79, 0, 5, 0		; <a name=graf_mkstate2>graf_mkstate
			.dc.b		80, 0, 1, 1		; <a name=scrpread2>scrp_read
			.dc.b		81, 0, 1, 1		; <a name=scrpwrite2>scrp_write
			.dc.b		82, 0, 0, 0		; 
			.dc.b		83, 0, 0, 0		; 
			.dc.b		84, 0, 0, 0		; 
			.dc.b		85, 0, 0, 0		; 
			.dc.b		86, 0, 0, 0		; 
			.dc.b		87, 0, 0, 0		; 
			.dc.b		88, 0, 0, 0		; 
			.dc.b		89, 0, 0, 0		; 
			.dc.b		90, 0, 2, 2		; <a name=fsel_input2>fsel_input
			.dc.b		91, 0, 2, 3		; <a name=fse2>fsel_exinput
			.dc.b		92, 0, 0, 0		; 
			.dc.b		93, 0, 0, 0		; 
			.dc.b		94, 0, 0, 0		; 
			.dc.b		95, 0, 0, 0		; 
			.dc.b		96, 0, 0, 0		; 
			.dc.b		97, 0, 0, 0		; 
			.dc.b		98, 0, 0, 0		; 
			.dc.b		99, 0, 0, 0		; 
			.dc.b		100, 5, 1, 0		; wind_create
			.dc.b		101, 5, 1, 0		; <a name=windopen2>wind_open
			.dc.b		102, 1, 1, 0		; <a name=windclose2>wind_close
			.dc.b		103, 1, 1, 0		; <a name=winddelete2>wind_delete
			.dc.b		104, 2, 5, 0		; wind_get
			.dc.b		105, 6, 1, 0		; wind_set
			.dc.b		106, 2, 1, 0		; <a name=windfind2>wind_find
			.dc.b		107, 1, 1, 0		; <a name=windupdate2>wind_update
			.dc.b		108, 6, 5, 0		; wind_calc
			.dc.b		109, 0, 1, 0		; <a name=windnew>wind_new
			.dc.b		110, 0, 1, 1		; <a name=rsrcload3>rsrc_load
			.dc.b		111, 0, 1, 0		; <a name=rsrcfree2>rsrc_free
			.dc.b		112, 2, 1, 0		; <a name=rsrcgaddr2>rsrc_gaddr
			.dc.b		113, 2, 1, 1		; rsrc_saddr
			.dc.b		114, 1, 1, 1		; <a name=rsrcobfix2>rsrc_obfix
			.dc.b		115, 0, 0, 1		; <a name=rsrcrcfix2>rsrc_rcfix (v4.0)
			.dc.b		116, 0, 0, 0		; 
			.dc.b		117, 0, 0, 0		; 
			.dc.b		118, 0, 0, 0		; 
			.dc.b		119, 0, 0, 0		; 
			.dc.b		120, 0, 1, 2		; <a name=shelread2>shel_read
			.dc.b		121, 3, 1, 2		; <a name=shelwrite3>shel_write
			.dc.b		122, 1, 1, 1		; <a name=shelget2>shel_get
			.dc.b		123, 1, 1, 1		; shel_put
			.dc.b		124, 0, 1, 1		; <a name=shelfind2>shel_find
			.dc.b		125, 0, 1, 2		; <a name=shelenvrn2>shel_envrn
			.dc.b		126, 0, 0, 0		; 
			.dc.b		127, 0, 0, 0		; 
			.dc.b		128, 0, 0, 0		; 
			.dc.b		129, 0, 0, 0		; 
			.dc.b		130, 1, 5, 0		; appl_getinfo (v4.0)

			.data

_aespb:			.dc.l		_contrl, _global, _intin, _intout, _addrin, _addrout
_contrl:		.dc.l		0, 0, 0, 0, 0

			.bss

* _contrl = opcode
* _contrl+2 = num_intin
* _contrl+4 = num_addrin
* _contrl+6 = num_intout
* _contrl+8 = num_addrout 

_global			.ds.w		15
_intin			.ds.w		16
_intout			.ds.w		7
_addrin			.ds.l		2
_addrout		.ds.l		1

			.end
</PRE>
<p>
<hr><center><a href="toc.htm"> Table of Contents | </a><a href="index.htm"> Index </a></center>

</BODY>

</HTML>
