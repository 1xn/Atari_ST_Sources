<HTML>

<HEAD>

<TITLE>The Atari Compendium: Introduction to Style</TITLE>


</HEAD>

<BODY BACKGROUND BGCOLOR=#FFFFFF>

<P>
<a name=chap11><B><FONT SIZE=2>- CHAPTER 11 -</FONT></B>
<a name=interface><H2><a name=userinterface>GEM USER INTERFACE<BR>
GUIDELINES</H2>

<HR>

<a name=overview><H4><FONT SIZE=4 >Overview</FONT></H4>

<HR>

<P>
Maintaining consistent elements of style in a user-interface is
an important aspect of programming which should not be overlooked.
An extremely powerful application will have its usefulness compromised
by an interface that is unlike the majority of other <a name=apps>applications
a user will be exposed to.
<P>
In an effort to create a more standardized method of application
programming, this reference will diagram many interface elements
that every Atari programmer should use, regardless of whether
you are applying them to existing parts of <B>GEM</B> or programmer-defined
elements.
<P>
In a case where you provide an enhanced interface element that
departs from these specifications, you should at least allow the
user to disable the option in a 'Settings...' dialog. 
<HR>

<a name=basics><H4><FONT SIZE=4 >The Basics</FONT></H4>

<HR>

<P>
All <B>GEM</B> applications should contain a menu bar providing
<a name=deskmenu>access to program features. Desk accessories should appear in
a window. 
<P>
<a name=dialogware>'Dialogware' and <a name=alertware>'Alertware' applications are strongly discouraged.
Each performs user interaction exclusively in one or more dialogs
or alerts respectively. This makes it impossible for the user
to take advantage of other programs or desk accessories while
in use. 
<P>
Document-oriented applications that are launched with one or more
valid documents specified on the command line should launch those
documents into their own windows, otherwise the application should
initialize in one of two other ways:
<P>
 Open an empty document window with the default parameters labeled
"Untitled."
<P>
 Present a dialog allowing three choices. "New" opens
a blank document (as above), "Open" presents a file
selector used to select a document to open, "Cancel"
removes the dialog and leaves the user with the menu bar to make
other selections.
<HR>

<a name=windows><H4><FONT SIZE=4 >Windows</FONT></H4>

<HR>

<P>
A window is a viewport through which all or part of an application's
document may be viewed. Windows are modeless forms of input. This
means that they do not restrict the user from switching to another
window or executing a command.
<P>
Normal document windows should have a title bar and should be
moveable (these characteristics are set with the <B>wind_create()</B>
function - see <I>Chapter 6: <B>AES </B></I>). The following illustration
shows a window with all window components identified:
<center><br><img src="../graphics/chap114.gif"></center>
<P>
Here are some other basic rules to use when creating windows:
<P>
 Windows should almost always have the <B>MOVE</B> characteristic
set.
<P>
 If it is possible that the contents of the information displayed
in the window might overflow, provide sliders (horizontal and/or
vertical) as appropriate. The sliders should be updated as necessary
to ensure that they are proportional in size and position to the
amount of information viewable in the window versus the size of
the entire document.
<P>
 Generally, all document windows will include all window elements
(with the possible exception of the information line). Only exclude
an element if its use would be inappropriate in the current context.
<H5>Window Messages</H5>

<P>
An application's use of windows depends on either the <B>evnt_mesag()</B>
or <B>evnt_multi()</B> functions of the <B>AES</B>. These functions
return messages which in turn must be responded to by the application
for any changes to occur. The following list illustrates all messages
that a window may receive along with an appropriate action(s)
that should be taken.
<TABLE BORDER=1>

<TR><TH>
<CENTER>
<B><FONT SIZE=1 >Message</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Action</FONT></B></TH>
</TR>

<TR><TD><B>WM_REDRAW</B></TD><TD><FONT SIZE=2>Redraw the rectangular portion of the window which was dirtied (as specified in the message). Always use <B>wind_get()</B> with <B>WF_FIRSTXYWH</B> and <B>WF_NEXTXYWH</B> to walk the rectangle list and enable clipping to the appropriate regions.</FONT>If the window had a <B>SMALLER</B> gadget, check prior to drawing whether you are drawing the actual window contents or an iconified representation.<FONT SIZE=2>If the window has an attached toolbar that requires special redrawing, use <B>wind_get()</B> with <B>WF_FTOOLBAR</B> and <B>WF_NTOOLBAR</B> as parameters to walk the rectangle list and enable clipping to the returned regions.</FONT>In some situations you may want to redraw the entire window upon each <B>WM_REDRAW</B> call. You must still walk the rectangle list as specified above.
</TD></TR>

<TR><TD><B>WM_TOPPED</B></TD><TD><FONT SIZE=2>Call <B>wind_set()</B> with a parameter of <B>WF_TOP</B> to actually top the window. Do not redraw the window. Your application will receive <B>WM_REDRAW</B> messages for portions of the window uncovered by the call.</FONT>Also, set the mouse form as desired.
</TD></TR>

<TR><TD><B>WM_SIZED</B></TD><TD><FONT SIZE=2>Call <B>wind_set()</B> with a parameter of <B>WF_CURRXYWH</B> to actually change the current size of the window. Update slider positions as necessary to reflect the new size of the window.</FONT>Applications will automatically receive a redraw message if any portion of the window was uncovered. If you need to redraw the entire window each time the window size changes, send your own application a <B>WM_REDRAW</B> message with <B>appl_write()</B> to cause a redraw.
</TD></TR>

<TR><TD><B>WM_MOVED</B></TD><TD><FONT SIZE=2>Call <B>wind_set()</B> with a parameter of <B>WF_CURRXYWH</B> to actually change the current size of the window. This message and the message <B>WM_SIZED</B> are usually handled by common code.</FONT>
</TD></TR>

<TR><TD><B>WM_ARROWED</B></TD><TD><FONT SIZE=2>Scroll the contents of the document window as necessary and redraw the window (using the rectangle list).</FONT>When an arrow indicator is clicked, scroll the window by one 'line' (a small increment in a non-text oriented application). When the exposed area of the slider bar is clicked, scroll the contents of the document window by one 'page' (current viewable portion of the document) minus one 'line'.
</TD></TR>

<TR><TD><B>WM_VSLID</B></TD><TD><FONT SIZE=2>Scroll the contents of the document window in proportion with the new position of the slider elevator.</FONT>
</TD></TR>

<TR><TD><B>WM_HSLID</B></TD><TD><FONT SIZE=2>Scroll the contents of the document window in proportion with the new position of the slider elevator.</FONT>
</TD></TR>

<TR><TD><B>WM_FULLED</B></TD><TD><FONT SIZE=2>Restore the size of the window using <B>wind_get()</B> with a parameter of <B>WF_PREVXYWH</B>. Update slider bars as necessary.</FONT>
</TD></TR>

<TR><TD><B>WM_CLOSED</B></TD><TD><FONT SIZE=2>Close the window. If the window context required a positive or negative answer from the user ('Yes/No' or 'OK/Cancel'), assume positive. If the window contains a document which <I>has </I>been altered since the last time it was saved to disk, it is appropriate to ask the user if the document should be saved before proceeding.</FONT>
</TD></TR>

<TR><TH><B>WM_BOTTOMED</B></TH><TD><FONT SIZE=2>Call <B>wind_set()</B> with a parameter of <B>WF_BOTTOM</B> to send the window to the bottom of the window stack.</FONT>
</TD></TR>

<TR><TH><B>WM_ICONIFY</B></TH><TD><FONT SIZE=2>See below.</FONT>
</TD></TR>

<TR><TH><B>WM_UNICONIFY</B></TH><TD><FONT SIZE=2>See below.</FONT>
</TD></TR>

<TR><TH><B>WM_ALLICONIFY</B></TH><TD><FONT SIZE=2>See below.</FONT>
</TD></TR>

<TR><TH><B>WM_TOOLBAR</B></TH><TD><FONT SIZE=2>Respond as necessary to the toolbar event.</FONT>
</TD></TR>

<TR><TD><B>WM_ONTOP</B></TD><TD><FONT SIZE=2>Set the mouse form appropriately for your application.</FONT>
</TD></TR>

<TR><TD><B>WM_UNTOPPED</B></TD><TD><FONT SIZE=2>No action is mandated by this message.</FONT>
</TD></TR>

</TABLE>

<P>

<H5>Clipping Rectangles</H5>

<P>
In every instance where text or graphics are rendered in a window,
you should walk the rectangle list in order to ensure that the
screen is properly updated. This includes all instances when the
contents of the window are updated as a response to a user command
(as opposed to a <B>WM_REDRAW</B> message) or dynamic interaction
(i.e. selection or animation).
<H5>Window Titles</H5>

<P>
The title bar of a window should accurately reflect its basic
contents. If a window contains a document the title bar should
contain the filename of the document or 'Untitled' if it is a
new document that has not been saved yet. If the window does not
contain a document, the title bar should serve to clearly explain
the purpose of the menu. For example, if you were to implement
a find and replace dialog in a window, the window should be titled
"Find &amp; Replace."
<P>
In some cases you may wish to provide an option (though a menu
or keystroke) which allows the user to open a duplicate copy of
the document in another window. This allows the user to select
separate views in each open window yet changes in one window are
reflected in others.  In this case, suffix the document name with
a colon and the window number such as "FILENAME.DOC:1".
The numbering should only be present when more than one document
window actually exists.
<H5>Iconified Windows</H5>

<P>
<B>AES</B> versions 4.1 and above support the <B>SMALLER</B> gadget
for window <a name=iconif><a name=iconification>iconification. The basic rules for iconification follow:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Action</FONT></B></TH><TH>
<CENTER>
<B><FONT SIZE=2 >Is a 'program group' iconified window already open?</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Response</FONT></B></TH>
</TR>

<TR><TD>User wishes to iconify a single window.</TD><TD>
<CENTER>
<FONT SIZE=2>No</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Iconify the single window.</FONT></TD></TR>

<TR><TD>User wishes to iconify a single window.</TD><TD>
<CENTER>
<FONT SIZE=2>Yes</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Close the window the user wishes to iconify and add it to those represented by the 'program group' window.</FONT>
</TD></TR>

<TR><TD>User wishes to iconify all windows.</TD><TD>
<CENTER>
<FONT SIZE=2>No</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Create a new, iconified window as a 'program group' and close all other windows.</FONT>
</TD></TR>

<TR><TD>User wishes to iconify all windows.</TD><TD>
<CENTER>
<FONT SIZE=2>Yes</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Add all open windows to those represented by the 'program group' window and close all other windows.</FONT>
</TD></TR>

<TR><TD>User wishes to uniconify a single window.</TD><TD>
<CENTER>
<FONT SIZE=2>N/A</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Uniconify the window.</FONT></TD></TR>

<TR><TD>User wishes to uniconify a 'program group' window.</TD>
<TD>
<CENTER>
<FONT SIZE=2>Yes</FONT>
</CENTER>
</TD><TD><FONT SIZE=2>Close the iconified window and open all of the windows in the 'program group'.</FONT>
</TD></TR>

</TABLE>

<P>

<P>
Here are some other hints that are helpful when dealing with iconification:
<P>
 Due to the smaller size of the window title line, it may be desirable
to adjust the title text when a window is iconified.
<P>
 Draw an icon which represents the contents of the window when
drawing a single iconified window. When drawing a 'program group'
iconified window, draw an icon which represents the application.
<P>
 Use <B>graf_growbox()</B> and <B>graf_shrinkbox()</B> to graphically
show the user the iconification/uniconification process.
<H5>Window Information Line</H5>

<P>
When appropriate, the addition of the <B>INFO</B> component of
a window should serve to provide additional information about
the objects visible in the window. This information should change
to provide the most useful information. A vector graphics editor
might display the document size, statistics, and zoom factor normally,
but provide information on the number and extent of selected objects
when at least one object is selected. 
<H5>Window Colors</H5>

<P>
<B>AES</B> versions 3.0 and above allow the color of each window
component to be modified. An application should never modify the
global settings. Allow the user to use the Window Colors CPX to
choose global colors of his/her choice.
<P>
If your application wants to draw a visual distinction between
windows by displaying them in different colors, provide a dialog
where the user may choose color preferences or (at least) enable/disable
this option.
<HR>

<a name=dialog><H4><FONT SIZE=4 >Dialog Boxes</FONT></H4>

<HR>

<P>
A dialog box is the modal counterpart to a window. When a dialog
box is displayed, all of the user's input is exclusively directed
towards it until the user releases control by satisfying the needs
of the dialog. Here are some basic rules regarding dialog boxes:
<P>
 Prior to drawing a dialog and calling <B>form_do()</B>, call
the <B>AES</B> function <B>wind_update( BEG_UPDATE )</B>. Do not
release control with <B>END_UPDATE</B> until the dialog box is
removed and input with it is finished.
<P>
 If a dialog box controls a physical attribute (such as text face
or fill type), provide a 'Sample' area where changes are automatically
displayed prior to exiting the dialog.
<P>
 Dialogs that position themselves automatically at the center
of the active window or mouse location are convenient to some
users, annoying to others. When providing this feature, allow
it to be disabled.
<H5>Button Positioning</H5>

<P>
<a name=dialogs>Most dialogs consist of several resource objects that can be edited
or changed by the user and several exit buttons which terminate
the dialog (or cause a supplementary action). Dialogs which supply
information should have an 'OK' button and a 'Help' button if
additional information is available. Dialogs which manipulate
settings should have an 'OK' button to accept changes, a 'Cancel'
button to revert to the state prior to entering the dialog, and
an 'Help' button if help is to be provided.
<P>
Buttons should always appear in the order 'OK', 'Cancel', ...other
buttons..., 'Help' when working left to right or top to bottom.
'OK' should be in all capitals. All other buttons should be capitalized.
When other wording is appropriate (such as 'Yes/No') the positive
answer should always precede the negative answer.
<P>
All dialogs should have a default exit button which exits the
dialog. In most cases this will be the positive 'OK' or 'Yes'
response. In a case where an action is irreversible and data will
be changed (for example, formatting a disk), it is appropriate
for the negative response to be made default rather than the positive
one.
<P>
Exit buttons should be placed in a dialog so that they are either
centered at the bottom of the dialog or listed from top to bottom
starting at the upper-righthand corner of a dialog as pictured
in the following diagrams:
<center><br><img src="../graphics/chap119.gif"></center>

<P>
When using the 'top-down' style, buttons with complementary meanings
may be grouped by inserting one space between groups. The dialog
pictured above shows an example of a dialog with an 'OK', 'Cancel',
and 'Help' button correctly positioned.
<H5>Unfolding Dialogs</H5>

<P>
In some cases a dialog may contain features for both the common
and advanced user. In this case it is recommended that an 'unfolding'
dialog be presented.
<P>
An unfolding dialog contains a button such as 'Options &gt;&gt;'
or 'More &gt;&gt;' which, when pressed, expands the dialog to
reveal additional features. When this happens the 'Options &gt;&gt;'
button becomes '&lt;&lt;&nbsp;Options' (or 'More &gt;&gt;' becomes
'&lt;&lt; Less'  which, when pressed, will return the dialog box
to its original state.
<a name=udc><H5>User-Defined Controls.</H5>

<P>
When adding custom objects to dialog boxes using <B>G_PROGDEF</B>
objects or other means, it is important to keep the interface
with these objects consistent with an already existing object.
For instance, a custom text control should respond to keystrokes
in the same manner as the <B>G_FTEXT</B> object. If a custom object
departs from these standards, its implementation should be capable
of being disabled.
<HR>

<a name=alerts><H4><FONT SIZE=4 >Alerts</FONT></H4>

<HR>

<P>
Alerts are special dialog boxes which provide information and/or
a limited choice of options to the user. Alerts are often used
to present an error condition to the user or to inform them of
a choice. Some basic rules regarding alert boxes follow:
<P>
 In general apply rules regarding button text (such as capitalization,
the default object, etc.) to alerts.
<P>
 Whenever possible, provide the user with more than one option
in an alert box. Alerts with only one button are frustrating and
should only be used when only one possible course of action exists.
<P>
 Never provide an 'OK' button and a 'Cancel' button when either
button will lead to the same action/inaction.
<P>
 Avoid using the word 'error' or any other text which might blame
the user.
<P>
 If an error has occurred, suggest a remedy (possibly using a
dialog box for data reentry).
<P>
 Use 'Cannot' instead of 'Can't' or 'Can not'.
<P>
 If an error alert might occurring during multi-tasking while
another process has focus, make the first line of the alert text
the program name followed by a colon.
<P>
 A message such as "Not enough memory to load file TEST.DOC."
is much better than "Insufficient memory."
<P>
 Minor warnings to a user might become increasingly apparent by
having the response to the first incorrect action be the system
bell and the second occurrence being a dialog box politely guiding
the user along.
<P>
 Message text should be left-aligned.
<P>
 If message text is too long to fit into the 5 line/30 character
per line limit, consider downsizing the message for clarity, or
if necessary, place the alert in a form. Never use consecutive
alerts.
<P>
 Alerts should be capitalized by standard grammatical rules and
should be punctuated with a period or question mark (not an exclamation
mark).
<P>
Alerts boxes may be displayed with one of three icons (or no icon
at all). The following lists examples of when to use a specific
icon:
<center><br><img src="../graphics/chap1111.gif"></center><br>
<TABLE BORDER=1>

<TR><TH>
<CENTER>
<B><FONT SIZE=1 >Icon</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Uses</FONT></B></TH></TR>

<TR><TD>
<CENTER>
None
</CENTER>
</TD><TD><FONT SIZE=2>Program credits, reminders, general help.</FONT>
</TD></TR>

<TR><TD></TD><TD><FONT SIZE=2>Error conditions, conditions requiring immediate action.</FONT>
</TD></TR>

<TR><TD></TD><TD><FONT SIZE=2>Inquiries, most confirmations.</FONT>
</TD></TR>

<TR><TD></TD><TD><FONT SIZE=2>Potentially program-fatal errors, confirmation of an irreversible action.</FONT>
</TD></TR>

<TR><TD></TD><TD><FONT SIZE=2>Informational alerts. These usually have only an 'OK' button. Alerts with more than one choice might be better suited for the question mark icon.</FONT>
</TD></TR>

<TR><TD></TD><TD><FONT SIZE=2>General disk errors and requests.</FONT>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=file><a name=filesel><H4><FONT SIZE=4 >The File Selector</FONT></H4>

<HR>

<P>
Several important style guidelines are important to follow when
using the system calls <B>fsel_input()</B> or <B>fsel_exinput()</B>
to provide the common system file selector to the user. If your
application provides a custom file selector unique to your application,
always allow the user the choice of using the system file selector
as opposed to your own. In general, it is better to use the internal
selector rather than provide a customized one. The user may install
a third-party file selector replacement if they want the extra
features that custom file selectors usually provide. This provides
more user-interface consistency throughout the system.
<P>
If you commonly use a third-party replacement file selector on
the system you test applications on, always test your application
with the replacement file selector disabled. Several third-party
file selectors handle screen redraws and pathname parsing differently
than the internal file selector does.
<P>
When your application needs to display the file selector, always
ensure that the pathname that is going to be passed to the file
selector call is valid. If the pathname becomes invalid, revert
to a system default path such as that of your applications own.
It is also courteous to the user to store the last used path in
a global buffer so that each time the file selector is accessed
the user doesn't have to change directories again.
<P>
If your application requires that its files be loaded and saved
with a specific file extension, append that file mask to the end
of the pathname so that the user's choices are restricted. If
during a save operation the user chooses to override your default
extension, either allow it or prompt the user as to their true
intention.
<P>
When the file selector call returns, if the filename field is
blank, treat it as a 'Cancel'. If a filename was entered but it
contains no file extension, append your default file extension
(if appropriate) to it.
<HR>

<a name=progress><H4><FONT SIZE=4 ><a name=progressindicators>Progress Indicators</FONT></H4>

<HR>

<P>
When an application begins a task that may require a substantial
amount of time to complete, it is normally appropriate to change
the mouse to a <B>BUSY_BEE</B> form to indicate to the user a
long action is taking place.
<P>
If the screen display does not reflect the actual task in real
time, it is helpful to display a progress bar (sometimes referred
to as a thermometer) indicator on screen to remind the user that
an task is indeed taking place and that the computer has not entered
a locked state. In this case, you may leave the mouse form in
the <B>ARROW</B> shape so that the user may perform other functions
in a multitasking environment.
<P>
It is helpful to place a progress bar for potentially long operations
into a window so that other applications or desk accessories may
be accessed. When possible, the exact length of the operation
might be stated like "Time Left: xx:xx".
<P>
The progress bar should move as closely as possible to a true
proportional representation of time (i.e. avoid circumstances
where it might take ten seconds to move from 25% to 50% but only
a second to move from 50% to 100%).
<P>
An example progress bar showing a task in progress is shown below:
<center><br><img src="../graphics/chap1112.gif"></center><br>
<HR>

<a name=toolbox><H4><a name=tollboxes><FONT SIZE=4 >Toolboxes</FONT></H4>

<HR>

<P>
Toolboxes are groups of buttons (usually <B>G_IMAGE</B> or <B>G_ICON</B>)
which either select between editing modes (often in graphic editors
or DTP applications) or choose object properties. A toolboxes
may be contained in its own window or appear 'attached' in the
document window aligned with the upper-left corner of the work
area. A toolbox in its own window should have its 'un-toppable'
characteristic set under <B>MultiTOS</B> (see <B>wind_set()</B>)
to prevent the user from having to click twice to select a button.
<P>
Buttons on these specialized dialog/window combinations fall into
three categories, exclusive buttons (such as a pointer tool and
rectangle tool), non-exclusive buttons (such as zoom on/off),
and style buttons (such as fill style and line style).
<P>
Buttons should reflect their state by appearing either inverted
or depressed. The currently selected exclusive button as well
as any selected non-exclusive button retains this state until
a new object is chosen or it is deselected. Style buttons are
only selected until the user has completed the operation. When
available, toolbox buttons should appear in color using a <B>G_CICON</B>.
An example of a toolbox window follows:
<center><br><img src="../graphics/cha11131.gif"></center><br>

<HR>

<a name=toolbars><H4><FONT SIZE=4 >Toolbars</FONT></H4>

<HR>

<P>
Toolbars (sometimes referred to as 'Ribbons') are single-strip
toolboxes placed at the top of the document work area which contain
buttons or combo boxes which are usually used to alter properties
of the document. An example of a control bar embedded in a window
follows:
<center><br><img src="../graphics/cha11132.gif"></center>

<P>
Newer versions of the <B>AES</B> provide built-in support for
toolbars, though they can be implemented in applications running
in an OS that does not support the new calls.
<HR>

<a name=menus><H4><FONT SIZE=4 >Menus</FONT></H4>

<HR>

<H5>The Menu Bar</H5>

<P>
Each application in the system should initialize a menu bar as
soon as it is called. The menu bar consists of several titles
which when pointed to by the mouse cause a list of individual
menu items to be displayed.
<P>
The leftmost menu title (commonly referred to as the 'Desk' menu)
should be the application name. An example of the first menu title/items
are shown below:
<center><br><img src="../graphics/chap1114.gif"></center>
<P>
The first item in the menu should be "<I>PRGNAME</I>...".
<I>PRGNAME</I> should be substituted with the name of the application.
The lines below are reserved for desk accessories and applications
(when running under <B>MultiTOS</B>)..
<P>
An application should call <B>menu_register()</B> (under <B>MultiTOS</B>)
to change its entry in the menu from the filename to the program
title.
<P>
The second and third menu titles should be "File" and
"Edit" as appropriate (though the inclusion of both
of these menus is highly recommended). Application defined menus
should be placed after these. If a "Help" menu is available
it should be the rightmost title. A "Window" menu should
be placed rightmost second only to "Help" if it exists.
An example title bar follows:
<center><br><img src="../graphics/chap1114.gif"></center><p>
<P>
Menu entries should be grouped by function under appropriate titles
and subgrouped by placing separator bars between them (disabled
dashes).
<P>
Menu entries which end in an ellipsis should lead to a dialog
box. Those without ellipsis should carry out an action with no
further user interaction.
<a name=filemenu><H5>The File Menu</H5>

<P>
The "File" menu should consist of the following items
(presented in order):
<P>
 New
<P>
 Open...
<P>
 Recall (optional - has cascading menu attached with most-recently
used file list)
<P>
 Save
<P>
 Save as...
<P>
 Save all (optional)
<P>
 Any other document closing commands as required.
<P>
Separator
<P>
 Import (if applicable)
<P>
 Export (if applicable)
<P>
 Any other file operations as required.
<P>
Separator
<P>
 Page Setup... (if applicable)
<P>
 Print (if applicable)
<P>
 Any other printing commands as required.
<P>
Separator
<P>
 Quit
<P>
Following is an example "File" menu:
<center><br><img src="../graphics/chap1115.gif"></center><p>
<a name=editmenu><H5>The Edit Menu</H5>

<P>
The next menu, "Edit", usually contains the following
items:
<P>
 Undo (if supported)
<P>
 Redo (if supported)
<P>
Separator
<P>
 Cut
<P>
 Copy
<P>
 Paste
<P>
 Delete
<P>
Separator
<P>
 Select All (optional)
<P>
Separator
<P>
 Find... (optional)
<P>
 Replace... (optional)
<P>
 Find Next (optional)
<P>
Separator
<P>
 Any other editing/searching commands.
<P>
An example "Edit" menu follows:
<center><br><img src="../graphics/chap1116.gif"></center><p>
<a name=dualstate><H5>Dual-State Menu Items</H5>

<P>
Menu selections can be designed to represent toggles. There are
two methods of accomplishing this as follows:
<P>
 Apply a checkmark to the item to indicate an enabled state.
<P>
 Alter the text. For example, when "Hide Toolbar" is
clicked, change the text to "Show Toolbar".
<P>
In addition, some menu item groups may provide a choice between
more than two options.
<P>
Again, checkmarks can be used to indicate the selection.
<P>
<a name=about>Here are some other general pointers about using menus:
<P>
 Menu items such as "Preferences..." or "Save Preferences"
belong in the "Options" menu.
<P>
 Menu items for text styles (like bold, italic) can be made <B>G_USERDEF</B>
objects and made to reflect their actual state.
<P>
 If you add a "Window" menu, items such as "New
Window" which opens a new window for the current document,
"Arrange All", "Tile All", "Cascade All",
which positions windows can optionally be included. Followed by
a separator, a generic item "Window" can be attached
to a cascading menu which contains an updated list of all document
windows so that the user can use the menu bar to 'top' a window.
<P>
 If you add a "Help" menu, different options can provide
different levels of help such as "Contents" or "Index".
Don't list help items for each possible dialog box or mode, instead
provide context sensitive help that is activated through a "Help"
button or by pressing the HELP key.
<a name=popupmenus><H5>Popup Menus</H5>

<P>
Popup menus are menus which can appear anywhere on screen at the
request of the user. A common use of popup menus is for object-specific
options which are called upon when an object is right-clicked
on with the mouse.
<P>
Popup menus can also be placed in dialog boxes as shown below.
Dialog objects which lead to popup menus should be <B>TOUCHEXIT</B>
and <B>SHADOWED</B>. If text describing the popup appears at the
left of the button, it should be inverted when the popup is displayed
and until it is closed.
<P>
When a popup menu contains a list of exclusive options, the option
currently selected should be properly identified to the <B>menu_popup()</B>
command so that it is aligned with the object in addition to having
a checkmark. Popups with no selected option should always start
at the first selection.
<P>
Popup menus may contain objects other than text (like fill styles
or bitmaps) but will be unable to scroll.
<a name=ddlb><H5>Drop-Down List Boxes</H5>

<P>
Drop-down list boxes are handled in the same manner as popup menus
with the following exceptions:
<P>
An 'equivalence' character (ASCII 240) in a <B>BOXCHAR</B> object
should be displayed immediately to the right of the box leading
to the drop-down list and should also be <B>TOUCHEXIT</B> and
<B>SHADOWED</B>. A click on this object is the same as clicking
on the main object.
<P>
No checkmark should be displayed next to the current selection.
<P>
The <B>TOUCHEXIT</B> box leading to a drop-down list may be editable,
if appropriate, to allow the user to add items to those currently
in the list.
<P>
The following illustrations show examples of both a 'closed' (prior
to being selected) and 'open' (during selection) drop-down list:

<center><br><img src="../graphics/chap1118.gif"></center><p>

<a name=hm><a name=hmenus><H5>Hierarchical Menus</H5>

<P>
Hierarchical menus (or sub-menus) are menus attached to either
a main menu item or a popup menu item. These menus can be nested
several levels deep but it is recommended that this feature not
be used because your menu bar, in general, should never be this
complex. An example of a hierarchical menu follows:
<center><br><img src="../graphics/chap1119.gif"></center><p>
<HR>

<a name=keyboards><a name=kbdequiv><H4><FONT SIZE=4 >Keyboard Equivalents</FONT></H4>

<HR>

<P>
Some users prefer to do their program interaction via the mouse
while others prefer the keyboard. Those users who prefer keyboard
interaction are often frustrated by a lack of consistency among
programs concerning keyboard equivalents.
<P>
The following keyboard equivalents are universal among many platforms
(including Atari) and should be enabled in all cases where a counterpart
option exists in an application. Other keyboard equivalents may
be assigned as long as they do not conflict with one of those
already predefined. The use of the ALTERNATE key as a modifier
in a keyboard equivalent is discouraged because international
users use the ALTERNATE key to access special keyboard characters.
<H5>Menus</H5>

<P>
Menu keyboard equivalents should be notated next the menu item
and flush right (excepting one space) with the menu. The CONTROL
key should be notated by the caret, the ALTERNATE key should be
notated by the window closer character, and the SHIFT key should
be notated by the up arrow character. Function keys are notated
"Fnn" and other keys are notated as, for example, "Del",
"Bksp", "Help", etc.
<P>
Menu items with a sub-menu attachment should not have a keyboard
equivalent. An example menu with keyboard equivalents shown correctly
follows:
<center><br><img src="../graphics/chap1120.gif"></center>
<P>
Following is a list of defined keyboard equivalents:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Key Equivalent</FONT></B>
</TH><TH><B><FONT SIZE=1 >Operation</FONT></B></TH>
</TR>

<TR><TH>ctrl-n</TH><TD>New</TD></TR>

<TR><TH>ctrl-o</TH><TD>Open</TD></TR>

<TR><TH>ctrl-w</TH><TD>Close</TD></TR>

<TR><TH>ctrl-s</TH><TD>Save as...</TD></TR>

<TR><TH>ctrl-shift-s</TH><TD>Save</TD></TR>

<TR><TH>ctrl-p</TH><TD>Print</TD></TR>

<TR><TH>ctrl-shift-p</TH><TD>Page Setup</TD></TR>

<TR><TH>ctrl-q</TH><TD>Quit</TD></TR>

<TR><TH>ctrl-x</TH><TD>Cut</TD></TR>

<TR><TH>ctrl-c</TH><TD>Copy</TD></TR>

<TR><TH>ctrl-v</TH><TD>Paste</TD></TR>

<TR><TH>ctrl-a</TH><TD>Select all</TD></TR>

<TR><TH>ctrl-f</TH><TD>Find</TD></TR>

<TR><TH>ctrl-r</TH><TD>Replace</TD></TR>

<TR><TH>help</TH><TD>Access help</TD></TR>

<TR><TH>shift-help</TH><TD>Engage context sensitive help. Pointer should change to arrow/question mark and help should be provided for any object clicked on.
</TD></TR>

<TR><TH>undo</TH><TD>Undo last operation</TD></TR>

</TABLE>

<P>

<H5>Windows</H5>

<P>
When working with text-oriented applications, the following list
of keyboard equivalents apply. Keep in mind that CTRL is generally
a character-based modifier while SHIFT is line-based.
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Key Equivalent</FONT></B>
</TH><TH><B><FONT SIZE=1 >Operation</FONT></B></TH>
</TR>

<TR><TH>ctrl-b</TH><TD>Bold</TD></TR>

<TR><TH>ctrl-i</TH><TD>Italic</TD></TR>

<TR><TH>ctrl-u</TH><TD>Underline</TD></TR>

<TR><TH>ctrl-backspace</TH><TD>Delete word to left.</TD></TR>

<TR><TH>ctrl-delete</TH><TD>Delete word to right.</TD></TR>

<TR><TH>ctrl-arrow</TH><TD>Move to the left/right one word.</TD>
</TR>

<TR><TH>ctrl-clrhome</TH><TD>Move cursor to start of document.
</TD></TR>

<TR><TH>shift-left-arrow</TH><TD>Move to the beginning of current line.
</TD></TR>

<TR><TH>shift-right-arrow</TH><TD>Move to the end of current line.
</TD></TR>

<TR><TH>shift-up-arrow</TH><TD>Move up one page.</TD></TR>

<TR><TH>shift-down-arrow</TH><TD>Move down one page.</TD></TR>

<TR><TH>shift-delete</TH><TD>Delete line.</TD></TR>

<TR><TH>shift-clrhome</TH><TD>Move cursor to end of document.
</TD></TR>

<TR><TH>arrow</TH><TD>Move one character left/right.</TD></TR>

<TR><TH>clrhome</TH><TD>Move cursor to top of window.</TD></TR>

<TR><TH>backspace</TH><TD>Delete character to left of cursor.
</TD></TR>

<TR><TH>delete</TH><TD>Delete character to the right of cursor.
</TD></TR>

</TABLE>

<P>

<P>
When working with object-oriented applications, the following
keyboard equivalents are suggested:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Key Equivalent</FONT></B>
</TH><TH><B><FONT SIZE=1 >Operation</FONT></B></TH>
</TR>

<TR><TH>arrow</TH><TD>Deselect current object(s), select previous/next object.
</TD></TR>

<TR><TH>backspace</TH><TD>Delete selected object.</TD></TR>

<TR><TH>delete</TH><TD>Delete selected object.</TD></TR>

<TR><TH>tab</TH><TD>Deselect current object, select next object.
</TD></TR>

</TABLE>

<P>

<H5>Disjoint/Group Selection</H5>

<P>
When in the context of a text-editing application, SHIFT-clicking
on a point should select the text from the cursor position to
the point clicked or add that region to a current selection (if
one exists). In an object-oriented application, SHIFT-clicking
should allow the user to select and deselect multiple objects.
<HR>

<a name=device><H4><FONT SIZE=4 >Device Independence</FONT></H4>

<HR>

<P>
Programming for compatibility on the Atari is a simple task. Here
are some basic tips:
<P>
 A <B>GEM</B> program should use the <B>VDI</B> for all graphical/screen
output. Never use <B>GEMDOS</B>, <B>BIOS,</B> or <B>XBIOS</B>
functions to output to the screen or manipulate the palette.
<P>
 Don't make assumptions about the type of display based on any
call such as <B>Getrez()</B>, <B>EsetShift()</B>, or <B>Vsetmode()</B>.
Only look at the values returned by the <B>VDI</B> <B>v_opnvwk()</B>
call.
<P>
 For printing, always support <B>GDOS</B>. It is the only way
to ensure that a user has a printer driver and fonts for the attached
printer and that output is consistent among different printers.
As with the screen, never make assumptions about the printer based
on criteria like driver name, etc.
<P>
 Never write directly to hardware unless it's the documented way
to accomplish a task. This is an almost sure sign that your program
will break in future hardware releases.
<P>
 Avoid using interrupt vectors. If you must use them, use <B>Setexc()</B>.
<HR>

<a name=global><H4><FONT SIZE=4 >Globalization</FONT></H4>

<HR>

<P>
One of the most effective ways a software marketer can increase
his product's sales is by ensuring its usability in foreign countries.
Programmers can make their software more portable through the
following methods:
<UL>
<LI>Store all <a name=language>language-dependent strings in the application's
resource file. Porting to other languages may then be accomplished
by the modification of the resource file only.
<LI>When creating resource files. Allow at least 50% more space
than that is required for English text. The English language tends
to require fewer characters than most others.
<LI>Use the '_IDT' and '_AKP' cookie to globalize references to
dates, times, and currencies.  If your application does not have
a resource file, you may also use the '_AKP' cookie to select
among language specific strings embedded within your code. When
the '_AKP' cookie is not present you can check for language information
embedded in the program header.
</UL>

<P>

<HR>

<a name=colors><H4><FONT SIZE=4 >Colors</FONT></H4>

<HR>

<P>
<a name=proper>An application's proper use of color can greatly enhance its effectiveness.
Likewise, improper use of color can thoroughly confuse a user.
Below are some basic rules about the use of color:
<P>
 Never alter the first 16 colors in modes with 256 colors or more.
Only change system colors in other cases when absolutely necessary.
These are system colors which should be controlled exclusively
by the user.
<P>
 When providing a custom 3D effect to complement the OS under
<B>TOS</B> 4.0 and above, use <B>objc_sysvar()</B> to interrogate
color settings to allow your objects to match.
<P>
 Make dialogs <B>FL3DBAK</B> objects to allow the user's selected
dialog color to come through.
<P>
 Don't use colors to decorate, use them to emphasize or draw attention
to an important screen element. Use colors to display choices
relating to color or when a user expects it in the document.
<P>
 When using color as a choice indicator, use green as a positive,
red as a negative.
<HR>

<a name=sound><H4><FONT SIZE=4 >Sound</FONT></H4>

<HR>

<P>
As with color, the <a name=properuseof>proper use of sound can help or hinder an application
program. The system bell should be used as a polite reminder to
the user when an operation is being attempted that is beyond the
capabilities of the application (ex: scrolling past the last line
in a document). It is also useful to alert the user to the end
of a long operation (during which the user might have stepped
away).
<P>
In general, applications should restrict their use of sounds to
the system bell. Beyond that, applications can support sounds
through the use of the accessory "System Audio Manager"
(supplied with the Falcon030) or have their custom sounds provided
they may be enabled selectively by the user.
<HR>

<a name=app><H4><FONT SIZE=4 >Application Software</FONT></H4>

<HR>

<P>
Application software programmers writing for the Atari line of
computers should follow the following suggestions:
<P>
 Provide an installation program on the distribution floppy called
'INSTALL.PRG'. See below for details.
<P>
  Use the '_IDT' cookie to determine the proper method of displaying
dates and times. Use the '_AKP' cookie to determine the country's
currency character.
<P>
 Provide help in as many places as possible. Provide context-sensitive
help if possible.
<UL>
<LI>Your application file, its resource file(s), and any 'readme'
files should be together in one directory. Any other application
data files should be kept in a child directory of the application
directory.
</UL>

<P>

<HR>

<a name=install><H4><FONT SIZE=4 >Installation Software</FONT></H4>

<HR>

<P>
Every disk distributed for end-user use should have an installation
program called 'INSTALL.PRG' on the root directory of the floppy
or CD-ROM diskette. Even disks containing only data files should
be installable in this manner. Basic guidelines for installation
programs follow:
<UL>
<LI>The installation program should allow the user to specify
a location for the files to be installed and create a new directory
for them if necessary.
<LI>The installation program may (if desired by the user) add
icons for the application itself and data files to the DESKICON.RSC
or DESKCICN.RSC file as appropriate. If the application requires
special GDOS drivers or fonts, the installation should (if desired
by the user) modify the ASSIGN.SYS or EXTEND.SYS files appropriately.
<LI>The installation program may (if desired) modify the system
DESKTOP.INF or NEWDESK.INF, as appropriate, to create references
to added icons and to install the application to the system (creating
associated file types, startup directory, etc.). Be careful not
to override existing document associations without the user's
permission.
<LI>If your installation program modifies any system files, <I>always</I>
make a backup prior to the changes and inform the user where the
backups will be located.
<LI>The installation program should visually update the user as
to the progress of the installation procedure.
<LI>If changes to system files were made, inform the user on exit
that the system will need a reboot for these changes to become
effective.
<LI>If removing your application completely from the system involves
more than deleting a single directory's contents or if relocating
the application will cause it to no longer function properly,
provide an additional application that will remove or move your
application as desired by the user.
</UL>

<HR>

<a name=entertainment><H4><FONT SIZE=4 >Entertainment Software</FONT></H4>

<HR>

<P>
Entertainment software written for Atari computers should follow
these minimum standards.
<P>
 Allow the user to install your software on the hard drive using
an 'INSTALL.PRG'.
<P>
 Don't force the user to change resolutions prior to running your
software.
<P>
 The path to your application should not contain data files, place
those in a folder.
<P>
 Allow the user to return to the desktop in the same resolution
he left.
<P>
 If possible, allow the game to be run in a window.
<P>
 Use device-independent graphics paired with the <B>VDI</B> call
<B>vr_trnfm()</B> to translate your graphics upon loading to be
compatible with the installed video shifter.
<P>
 Support the enhanced analog joystick rather than CX-40 style
controls on machines which have the ports to support them (like
the STe and Falcon030). Use the CX-40 controls if four-player
play is desired.
<p>
<hr><center><a href="toc.htm"> Table of Contents | </a><a href="index.htm"> Index </a></center>
</BODY>

</HTML>
