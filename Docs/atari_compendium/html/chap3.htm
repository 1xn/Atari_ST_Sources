<HTML>

<HEAD>

<TITLE>BIOS</TITLE>


</HEAD>

<BODY BACKGROUND BGCOLOR=#FFFFFF>

<P>
<a name=chap3><B><FONT SIZE=2>- CHAPTER 3 -</FONT></B>
<H1>BIOS</H1>

<HR>

<a name=overview><H4><FONT SIZE=4 >Overview</FONT></H4>

<HR>

<P>
The Basic Input/Output System (<B>BIOS</B>) is responsible for
the lowest level of communications between the operating system
and hardware devices. This chapter will document the operating
system functions of the <B>BIOS</B> and other system level operations.
<HR>

<a name=startup><H4><FONT SIZE=4 >System Startup</FONT></H4>

<HR>

<P>
<a name=coldboot>Upon a cold or <a name=warmboot >warm boot, microprocessors in the 680x0 series
load the initial supervisor stack pointer from the first longword
in memory ($0) and begin execution at the PC found in the second
longword ($4). The location this points to is the base initialization
point for Atari computers.
<P>
Every Atari computer follows a predefined set of steps to accomplish
system initialization. The following illustrates these steps leaving
out some hardware initialization which is specific to the particular
computer line (ST, TT, Falcon, etc.).
<P>
 <a name=interrupt>The Interrupt Priority Level (IPL) is set to 7 and the OS switches
to supervisor mode.
<P>
 A RESET instruction is executed to reset external hardware devices.
<P>
 The presence of a diagnostic cartridge is determined. If one
is inserted, it is JMP'ed to with a return address in register
A6.
<P>
 If running on a 68030, the CACR, VBR, TC, TT0, and TT1 registers
are initialized.
<P>
 If a floating-point coprocessor is present it is initialized.
<P>
 If the <I>memvalid </I>($420), <I>memval2 </I>($43A), and <I>memval3
</I>($51A) system variables are all valid, a warm boot is assumed
and the memory controller is initialized with the value from <I>memcntrl
</I>($424).
<P>
 The initial color palette registers are loaded and the screen
base is initialized to $100000.
<P>
 Memory is sized if it wasn't from a previous reset.
<P>
 <a name=meminit>Magic numbers are stored in low memory to indicate the successful
sizing and initialization of memory.
<P>
 System variables and the cookie jar are initialized.
<P>
 The <B>BIOS</B> initialization point is executed.
<P>
 Installed cartridges of type 2 are executed.
<P>
 The screen resolution is programmed.
<P>
 Installed cartridges of type 0 are executed.
<P>
 Interrupts are enabled by lowering the IPL to 3.
<P>
 Installed cartridges of type 1 are executed.
<P>
 The <B>GEMDOS</B> initialization point is executed.
<P>
 On systems running <B>TOS</B> 2.06 or <B>TOS</B> 3.06 and above,
the Fuji logo is displayed and a  memory test and hard disk spin-up
sequence is executed.
<P>
 If at least one floppy drive is attached to the system, the first
sector of the first floppy drive is loaded, and if executable,
it is called.
<P>
 If at least one hard disk or other media is attached to the system,
the first sector of each is loaded in succession until one with
an executable sector is found or each has been tried.
<P>
 If a hard disk sector was found that was executable, it is executed.
<P>
 The text cursor is enabled.
<P>
 All "\AUTO\*.PRG" files found on the boot disk are
executed.
<P>
 If _<I>cmdload</I> ($482) is 0 then an environment string is
created and the <B>AES</B> is launched, otherwise "\COMMAND.PRG"
is loaded.
<P>
 If the <B>AES</B> ever terminates, the system is reset and system
initialization begins again.
<HR>

<a name=header><a name=osheader><H4><FONT SIZE=4 >OS Header</FONT></H4>

<HR>

<P>
The address of the start of operating system is stored in the
system variable _<a name=sysbase><I>sysbase</I> ($4F2). The beginning of the operating
system contains a table with contents as follows:
<TABLE BORDER=1>

<TR><TH>
<CENTER>
<B><FONT SIZE=1 >Offset</FONT></B>
</CENTER>

<P>

<CENTER>
<B><FONT SIZE=1 >(_<I><B>sysbase</B></I><B> + $x)</B></FONT></B>
</CENTER>

</TH><TH>
<CENTER>
<B><FONT SIZE=2 >Size</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Contents</FONT></B></TH>
</TR>

<TR><TD>
<CENTER>
$0
</CENTER>
</TD><TD>
<CENTER>
<B><FONT SIZE=2>WORD</FONT></B>
</CENTER>

</TD><TD><I><FONT SIZE=2>os_entry</FONT></I>: BRA to reset hander (shadowed at $0).
</TD></TR>

<TR><TD>
<CENTER>
$2
</CENTER>
</TD><TD>
<CENTER>
<B><FONT SIZE=2>WORD</FONT></B>
</CENTER>

</TD><TD><I><FONT SIZE=2>os_version</FONT></I>: <B>TOS</B> version number. The high byte is the major revision number, and the low byte is the minor revision number.
</TD></TR>

<TR><TD>
<CENTER>
$4
</CENTER>
</TD><TD>
<CENTER>
<B><FONT SIZE=2>LONG</FONT></B>
</CENTER>

</TD><TD><I><FONT SIZE=2>reseth</FONT></I>: Pointer to the system reset handler.
</TD></TR>

<TR><TD>
<CENTER>
$8
</CENTER>
</TD><TD>
<CENTER>
<B><FONT SIZE=2>LONG</FONT></B>
</CENTER>

</TD><TD><I><FONT SIZE=2>os_beg</FONT></I>: Base address of the OS (same as _<I>sysbase</I>).
</TD></TR>

<TR><TD>
<CENTER>
$C
</CENTER>
</TD><TD>
<CENTER>
<B><FONT SIZE=2>LONG</FONT></B>
</CENTER>

</TD><TD><I><FONT SIZE=2>os_end</FONT></I>: Address of the first byte of RAM not used by the operating system.
</TD></TR>

<TR><TD>
<CENTER>
$10
</CENTER>
</TD><TD>
<CENTER>
<B><FONT SIZE=2>LONG</FONT></B>
</CENTER>

</TD><TD><I><FONT SIZE=2>os_rsv1</FONT></I>: Reserved</TD></TR>

<TR><TD>
<CENTER>
$14
</CENTER>
</TD><TD>
<CENTER>
<B><FONT SIZE=2>LONG</FONT></B>
</CENTER>

</TD><TD><I><FONT SIZE=2>os_magic</FONT></I>: Pointer to the <B>GEM</B> <a name=memoryusageparameterblock         >Memory Usage Parameter Block (<B>MUPB</B>). See below for more information.
</TD></TR>

<TR><TD>
<CENTER>
$18
</CENTER>
</TD><TD>
<CENTER>
<B><FONT SIZE=2>LONG</FONT></B>
</CENTER>

</TD><TD><I><FONT SIZE=2>os_date</FONT></I>: Date of system build ($YYYYMMDD).
</TD></TR>

<TR><TD>
<CENTER>
$1C
</CENTER>
</TD><TD>
<CENTER>
<B><FONT SIZE=2>WORD</FONT></B>
</CENTER>

</TD><TD><I><FONT SIZE=2>os_conf</FONT></I>: OS Configuration Bits. See below for more information.
</TD></TR>

<TR><TD>
<CENTER>
$1E
</CENTER>
</TD><TD>
<CENTER>
<B><FONT SIZE=2>LONG</FONT></B>
</CENTER>

</TD><TD><I><FONT SIZE=2>os_dosdate</FONT></I>: <B>GEMDOS</B> format date of system build.
</TD></TR>

<TR><TD>
<CENTER>
$20
</CENTER>
</TD><TD>
<CENTER>
<B><FONT SIZE=2>LONG</FONT></B>
</CENTER>

</TD><TD><I><FONT SIZE=2><a name=proot>p_root</FONT></I>: Pointer to a system variable containing the address of the <B>GEMDOS</B> memory pool structure. This entry is available as of <B>TOS</B> 1.2. The location pointed to by this value should never be modified by an application.
</TD></TR>

<TR><TD>
<CENTER>
$24
</CENTER>
</TD><TD>
<CENTER>
<B><FONT SIZE=2>LONG</FONT></B>
</CENTER>

</TD><TD><I><FONT SIZE=2><a name=kbshift><a name=pkbshift>p_kbshift</FONT></I>: Pointer to a system variable which contains the address of the system keyboard shift state variable. See below for more information. This entry is available as of <B>TOS</B> 1.02. This location should never be modified by an application.
</TD></TR>

<TR><TD>
<CENTER>
$28
</CENTER>
</TD><TD>
<CENTER>
<B><FONT SIZE=2>LONG</FONT></B>
</CENTER>

</TD><TD><I><FONT SIZE=2><a name=prun>p_run</FONT></I>: Pointer to a system variable which contains the address of the currently executing <B>GEMDOS</B> process. See below for more information. This entry is available as of <B>TOS</B> 1.02. The information pointed to by this variable should never be modified by an application.
</TD></TR>

<TR><TD>
<CENTER>
$2C
</CENTER>
</TD><TD>
<CENTER>
<B><FONT SIZE=2>LONG</FONT></B>
</CENTER>

</TD><TD><I><FONT SIZE=2>p_rsv2</FONT></I>: Reserved</TD></TR>

</TABLE>

<P>

<P>
Some versions of <a name=ahdi>AHDI (the Atari Hard Disk Interface) contain
a bug which copies the system <a name=header1>header to RAM and then corrupts
some portions of it. The following 'C' structure definition defines
the <B>OSHEADER</B> structure. The function GetROMSysbase() can
be used to return an <B>OSHEADER</B> pointer to the code in ROM.
GetROMSysbase() will execute properly in either user or supervisor
mode.
<PRE>
typedef struct _osheader
{
	UWORD	 os_entry;
	UWORD	 os_version;
	VOID 	*reseth;
	struct _osheader *os_beg;
	char 	*os_end;
	char 	*os_rsv1;
	char 	*os_magic;
	LONG 	os_date;
	UWORD	os_conf;
	UWORD	os_dosdate;

	/* Available as of TOS 1.02 */
	char 	**p_root;
	char 	**p_kbshift;
	char 	**p_run;
	char 	*p_rsv2;
} OSHEADER;

#define _sysbase		((OSHEADER **)0x4F2)

OSHEADER *
GetROMSysbase( VOID )
{
	OSHEADER *osret;
	char *savesp = (Super(SUP_INQUIRE) ? NULL : Super(SUP_SET));
	
	osret = (*_sysbase)-&gt;os_beg;

	if( savesp )
		Super( savesp );

	return osret;
}

</PRE>

<H5><FONT SIZE=2>OS Configuration Bits</FONT></H5>

<P>
<I>os_conf</I> contains the <a name=cc>country code and video sync mode that
the operating system was compiled for. Bit #0 of this variable
is 0 to indicate NTSC video mode or 1 to indicate PAL.  The remaining
bits, when shifted right by one bit, yield the country code as
follows:
<TABLE BORDER=1>

<TR><TH>
<CENTER>
<I><B><FONT SIZE=1 >os_conf</FONT></B></I><B><FONT SIZE=1  FACE="Arial"> &gt;&gt; 1</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Country</FONT></B></TH>
</TR>

<TR><TD>
<CENTER>
0
</CENTER>
</TD><TD><FONT SIZE=2>USA</FONT>
</TD></TR>

<TR><TD>
<CENTER>
1
</CENTER>
</TD><TD><FONT SIZE=2>Germany</FONT>
</TD></TR>

<TR><TD>
<CENTER>
2
</CENTER>
</TD><TD><FONT SIZE=2>France</FONT>
</TD></TR>

<TR><TD>
<CENTER>
3
</CENTER>
</TD><TD><FONT SIZE=2>United Kingdom</FONT>
</TD></TR>

<TR><TD>
<CENTER>
4
</CENTER>
</TD><TD><FONT SIZE=2>Spain</FONT>
</TD></TR>

<TR><TD>
<CENTER>
5
</CENTER>
</TD><TD><FONT SIZE=2>Italy</FONT>
</TD></TR>

<TR><TD>
<CENTER>
6
</CENTER>
</TD><TD><FONT SIZE=2>Sweden</FONT>
</TD></TR>

<TR><TD>
<CENTER>
7
</CENTER>
</TD><TD><FONT SIZE=2>Switzerland (French)</FONT>
</TD></TR>

<TR><TD>
<CENTER>
8
</CENTER>
</TD><TD><FONT SIZE=2>Switzerland (German)</FONT>
</TD></TR>

<TR><TD>
<CENTER>
9
</CENTER>
</TD><TD><FONT SIZE=2>Turkey</FONT>
</TD></TR>

<TR><TD>
<CENTER>
10
</CENTER>
</TD><TD><FONT SIZE=2>Finland</FONT>
</TD></TR>

<TR><TD>
<CENTER>
11
</CENTER>
</TD><TD><FONT SIZE=2>Norway</FONT>
</TD></TR>

<TR><TD>
<CENTER>
12
</CENTER>
</TD><TD><FONT SIZE=2>Denmark</FONT>
</TD></TR>

<TR><TD>
<CENTER>
13
</CENTER>
</TD><TD><FONT SIZE=2>Saudi Arabia</FONT>
</TD></TR>

<TR><TD>
<CENTER>
14
</CENTER>
</TD><TD><FONT SIZE=2>Holland</FONT>
</TD></TR>

<TR><TD>
<CENTER>
15
</CENTER>
</TD><TD><FONT SIZE=2>Czechoslovakia</FONT>
</TD></TR>

<TR><TD>
<CENTER>
16
</CENTER>
</TD><TD><FONT SIZE=2>Hungary</FONT>
</TD></TR>

<TR><TD>
<CENTER>
127
</CENTER>
</TD><TD><FONT SIZE=2>All countries are supported. As of <B>TOS</B> 4.0 the OS is compiled with text for all languages and switches between them based on the country code stored in non-volatile RAM. </FONT>Use the '_AKP' cookie to determine the actual language in use.
</TD></TR>

</TABLE>

<P>

<a name=parameter><H5>GEM Memory Usage Parameter Block</H5>

<P>
The pointer at offset $14 in the OS header points to the <B>GEM</B>
Memory Usage Parameter Block which is defined as follows:
<PRE>
typedef struct
{
	/* $87654321 if GEM present */
	LONG gem_magic;

	/* End address of OS RAM usage */
	LONG gem_end;

	/* Execution address of GEM */
	LONG gem_entry;
} MUPB;	
</PRE>

<P>
<B>GEM</B> is only launched at system startup if <I>gem_magic</I>
is $87654321. The <B>XBIOS</B> call <a name=puntaes><B>Puntaes()</B> also uses
this information to restart the operating system after clearing
<B>GEM</B> (only if disk-based). It verifies that <I>gem_magic</I>
was valid and that <B>GEM</B> was in RAM, then it modifies <I>gem_magic</I>
and restarts the operating system.
<a name=shiftkeys><H5>Keyboard Shift State Variable</H5>

<P>
The OS header entry <I>p_kbshift</I> provides a method of reading
the state of the keyboard shift state variables more quickly than
with <a name=kbshift2><B>Kbshift()</B>. This header entry did not exist in <B>TOS</B>
1.0. The following code provides an acceptable method for accessing
this variable in all <B>TOS</B> versions:
<PRE>
#define Kbstate	*p_kbshift

char *p_kbshift;

<FONT SIZE=2>VOID
</FONT>init_kbshift( VOID )
<FONT SIZE=2>{
</FONT>	/* See above for GetROMSysbase() definition. */
<FONT SIZE=2>	OSHEADER *os = GetROMSysbase();

</FONT>	if ( os-&gt;os_version == 0x0100)
<FONT SIZE=2>		p_kbshift = (char *)0xE1BL;
</FONT>	else
<FONT SIZE=2>		p_kbshift = *(char **)os-&gt;p_kbshift;
</FONT>}

</PRE>

<H5>Currently Running Process</H5>

<P>
The OS header entry <I>_p_run</I> is used to locate the 
of the basepage of the currently running process. This entry has
only existed as of <B>TOS</B> 1.02 and should never be modified.
The following routine returns the address of the basepage of the
currently running process in all versions of <B>TOS</B>:
<PRE>
#define SPAIN		4
typedef long PID

PID *
get_run()
{
	OSHEADER *os = GetROMSysbase();

	if(os-&gt;os_version &lt; 0x0102)
	{
		if(( os-&gt;os_conf &gt;&gt; 1 ) == SPAIN)
			return (PID *)0x873C;
		else
			return (PID *)0x602C;
	}
	else
		return (PID *)(os-&gt;p_run);
}

</PRE>

<HR>

<a name=cookie><H4><FONT SIZE=4 >The Cookie Jar</FONT></H4>

<HR>

<H5>Overview</H5>

<P>
The 'Cookie Jar' is a structure in memory containing entries called
'cookies' which are placed in the 'jar' by the operating system
or Terminate and Stay Resident (TSR) applications. Applications
can test for the presence of a cookie to determine the presence
of a hardware device or system feature.
<P>
The location of the cookie jar is determined by the address contained
in the system variable _<I>p_cookies </I>($5A0). If no cookie
jar has been allocated yet, this entry will contain <B>NULL</B>
(0).
<a name=cookiestr><H5>Structure</H5>

<P>
The variable _<I>p_cookies</I> points to multiple <B>COOKIE</B>
structures as defined below:
<PRE>
	typedef struct
	{
		LONG cookie;
		LONG value;
	} COOKIE;
</PRE>

<P>
The structure member <I>cookie</I> contains a value that hopefully
uniquely identifies the cookie. <I>cookie</I> values are 4-byte
packed longword identifiers (often a 4 letter ASCII code word).
Entries with the high byte equal to $5F, the underscore character,
are reserved for use by Atari.
<P>
The structure member <I>value</I> may contain any value meaningful
to an application or no value at all. In some cases a cookie won't
have a meaningful value and its presence simply signals the existence
of another process or system feature. TSR's often use <I>value</I>
to store a pointer to an internal structure. The operating system
uses cookies to signal the availability of hardware devices or
system features.
<P>
The end of the cookie jar is signaled with a final entry with
the value for <I>cookie</I> equaling <B>NULL</B>. The <I>value</I>
entry for this final cookie contains the number of entries possible
without reallocating the jar.
<a name=searching><H5>Searching for a Cookie</H5>

<P>
The following code may be used to find a cookie in the cookie
jar. It returns 0 if an error occurred or 1 if successful. If
<I>p_value</I> is non-<B>NULL</B> on entry, the address it points
to will be filled in with the value of the cookie.
<PRE>
	WORD
	getcookie( target, p_value )
	LONG target;
	LONG *p_value;
	{
			char *oldssp;
			COOKIE *cookie_ptr;
	
			oldssp = (Super(SUP_INQUIRE) ? NULL : Super(1L));

			cookie_ptr = *(COOKIE **)0x5A0;

			if(oldssp)
				Super( oldssp );

			if(cookie_ptr != NULL)
			{
				do
				{
					if(cookie_ptr-&gt;cookie == target)
					{
						if(p_value != NULL)
							*p_value = cookie_ptr-&gt;value;

						return 1;
					}
				} while((cookie_ptr++)-&gt;cookie != 0L);
			}

			return 0;
	}

</PRE>

<a name=placing><H5><FONT SIZE=2>Placing a Cookie</FONT></H5>

<P>
Only TSR programs should place cookies in the cookie jar. The
cookie these programs place should either signal a function provided
by the TSR or the presence of an expansion device. A CPX, desk
accessory, or standard application should not place cookies in
the jar.
<P>
To place a cookie, the TSR must first locate the current location
of the cookie jar. It is possible that a cookie jar does not exist
(&nbsp;_<I>p_cookies</I>&nbsp;==&nbsp;0 ). In that case, a new
jar should be allocated. 
<P>
In most instances, the cookie jar should be allocated in increments
of 8 slots (though it is not a requirement). In addition, if the
process installs a new cookie jar in a <B>TOS</B> version lower
than 1.06 it is also the processes responsibility to remove it
upon a warm reset. Calling the following code after installing
the cookie jar for the first time will ensure that the cookie
jar pointer is properly reset on a warm boot.
<PRE>
	RESMAGIC		equ		$31415926
	_resvalid		equ		$426
	_resvector		equ		$42A
	_p_cookies		equ		$5A0

						.globl	_unjar

	_unjar:			move.l	_resvalid,valsave
						move.l	_resvector,vecsave
						move.l	#reshand,_resvector
						move.l	#RESMAGIC,_resvalid
						rts

	reshand:			clr.l	_p_cookies
						move.l	vecsave,_resvector
						move.l	valsave,_resvalid
						jmp		(a6)

						.bss

	vecsave:			.ds.l		1
	valsave			.ds.l		1

</PRE>

<P>
After determining the location of the cookie jar, the application
should search for the first empty slot in the jar by looking for
a <B>NULL</B> in the <I>cookie</I> field of a slot. Next, the
application must determine if this is the last slot in the jar
by comparing the entry in the <I>value</I> field of the current
cookie to the number of the actual slot you are comparing. For
instance, if you have found <B>NULL</B> as the value for <I>cookie</I>
in slot 16 and <I>value</I> is equal to 16, the jar is full and
must be reallocated. 
<P>
If the slot found is not the last one, the application can simply
copy the current slot to the next slot and insert its own cookie.
<P>
If the jar must be reallocated, you should allocate enough memory
to increase the size of the cookie jar, copy the old entries to
the new jar, insert your entry as the last cookie in the jar,
and finally terminate the jar with a cookie containing a <B>NULL</B>
and the new number of slots you have allocated.
<P>
Though not mentioned previously, it is also advisable to ensure
that your cookie isn't already in the jar before placing it to
avoid two cookies for multiple executions of the same application
to appear.
<a name=syscookies><a name=syscookie><H5>System Cookies</H5>

<P>
As of <B>TOS</B> 1.06, the operating system will place several
cookies in the cookie jar to inform applications of certain operating
system and hardware capabilities as follows:
<TABLE BORDER=1>

<TR><TH>
<CENTER>
<I><B><FONT SIZE=1 >cookie</FONT></B></I>
</CENTER>

</TH><TH><I><B><FONT SIZE=2 >value</FONT></B></I>
</TH></TR>

<TR><TH>
<CENTER>
<a name=cpu><B>_CPU</B>
</CENTER>
</TH><TD><FONT SIZE=2>The low <B>WORD</B> of the CPU cookie contains a number representing the processor installed in the system as follows:</FONT> <U><B>Value Processor</B></U>
<P>
<FONT SIZE=2> 0 68000</FONT>
<P>
<FONT SIZE=2> 10 68010</FONT>
<P>
<FONT SIZE=2> 20 68020</FONT>
<P>
<FONT SIZE=2> 30 68030</FONT>
</TD></TR>

<TR><TH>
<CENTER>
<a name=vdo><B>_VDO</B>
</CENTER>
</TH><TD><FONT SIZE=2>This cookie represents the revision of the video shifter present. The low <B>WORD</B> represents the minor revision number and the high <B>WORD</B> represents the major revision number. Currently valid values are:</FONT> <U><B>Major Minor Shifter</B></U>
<P>
<FONT SIZE=2> 0 0 ST</FONT>
<P>
<FONT SIZE=2> 1 0 STe</FONT>
<P>
<FONT SIZE=2> 2 0 TT030</FONT>
<P>
<FONT SIZE=2> 3 0 Falcon030</FONT>
</TD></TR>

<TR><TH>
<CENTER>
<a name=fpu><B>_FPU</B>
</CENTER>
</TH><TD><FONT SIZE=2>This cookie identifies the presence of floating-point math capabilities in the system. A non-zero low <B>WORD</B> indicates the presence of software floating point support (no specific values have yet been assigned). The high <B>WORD</B> indicates the type of coprocessor currently connected to the system as follows:</FONT> <U><B>Value Meaning</B></U>
<P>
<FONT SIZE=2> 0 No FPU is installed.</FONT>
<P>
<FONT SIZE=2> 1 SFP004</FONT>
<P>
<FONT SIZE=2> 2 68881 or 68882</FONT>
<P>
<FONT SIZE=2> 3 68881 or 68882 and SFP004</FONT>
<P>
<FONT SIZE=2> 4 68881</FONT>
<P>
<FONT SIZE=2> 5 68881 and SFP004</FONT>
<P>
<FONT SIZE=2> 6 68882</FONT>
<P>
<FONT SIZE=2> 7 68882 and SFP004</FONT>
<P>
<FONT SIZE=2> 8 68040 Internal</FONT>
<P>
<FONT SIZE=2> 9 68040 Internal and SFP004</FONT>
</TD></TR>

<TR><TH>
<CENTER>
<a name=fdc><B>_FDC</B>
</CENTER>
</TH><TD><FONT SIZE=2>This cookie indicates the capability of the currently connected floppy drive. The lowest three bytes is a code indicating the origin of the unit ('ATC' is an Atari unit). The upper byte is a value indicating the highest density floppy present as follows:</FONT><U><B> Value Density</B></U>
<P>
<FONT SIZE=2> 0 360 Kb/ 720 Kb</FONT>
<P>
<FONT SIZE=2> 1 1.44 Mb</FONT>
<P>
<FONT SIZE=2> 2 2.88 Mb</FONT>
</TD></TR>

<TR><TH>
<CENTER>
<a name=sndcookie><B>_SND</B>
</CENTER>
</TH><TD><FONT SIZE=2>This cookie contains a bitmap of sound features available to the system as follows:</FONT><U><B> Bit Feature</B></U>
<P>
<FONT SIZE=2> 0 GI Sound Chip (PSG)</FONT>
<P>
<FONT SIZE=2> 1 Stereo 8-bit Playback</FONT>
<P>
<FONT SIZE=2> 2 DMA Record (w/<B>XBIOS</B>)</FONT>
<P>
<FONT SIZE=2> 3 16-bit CODEC</FONT>
<P>
<FONT SIZE=2> 4 DSP</FONT>
</TD></TR>

<TR><TH>
<CENTER>
<a name=mch><B>_MCH</B>
</CENTER>
</TH><TD><FONT SIZE=2>This cookie indicates the machine type with the major revision number in the high <B>WORD</B> and the minor revision number in the low <B>WORD</B> as follows:</FONT> <U><B>Major Minor Shifter</B></U>
<P>
<FONT SIZE=2> 0 0 ST</FONT>
<P>
<FONT SIZE=2> 1 0 STe</FONT>
<P>
<FONT SIZE=2> 1 8 ST Book</FONT>
<P>
<FONT SIZE=2> 1 16 Mega STe</FONT>
<P>
<FONT SIZE=2> 2 0 TT030</FONT>
<P>
<FONT SIZE=2> 3 0 Falcon030</FONT>
</TD></TR>

<TR><TH>
<CENTER>
<a name=swi><B>_SWI</B>
</CENTER>
</TH><TD><FONT SIZE=2>On machines that contain internal configuration dip switches, this value specifies their positions as a bitmap. Dip switches are generally used to indicate the <a name=presence>presence of additional hardware which will be represented by other cookies.</FONT>
</TD></TR>

<TR><TH>
<CENTER>
<a name=frb><B>_FRB</B>
</CENTER>
</TH><TD><FONT SIZE=2>This cookie is present when alternative RAM is present. It points to a 64k buffer that may be used by DMA device drivers to transfer memory between alternative RAM and ST RAM for DMA operations.</FONT>
</TD></TR>

<TR><TH>
<CENTER>
<a name=flk><B>_FLK</B>
</CENTER>
</TH><TD><FONT SIZE=2>The presence of this cookie indicates that file and record locking extensions to <B>GEMDOS</B> exist. The <I>value</I> field is a version number currently undefined.</FONT>
</TD></TR>

<TR><TH>
<CENTER>
<a name=net><B>_NET</B>
</CENTER>
</TH><TD><FONT SIZE=2>This cookie indicates the presence of networking software. The cookie value points to a structure which gives manufacturer and version information as follows:</FONT>
<PRE>
struct netinfo
{
 LONG publisher;
 LONG version;
};
</PRE>

</TD></TR>

<TR><TH>
<CENTER>
<a name=idt><B>_IDT</B>
</CENTER>
</TH><TD><FONT SIZE=2>This cookie defines the currently configured date and time format, Bits #0-7 contain the ASCII code of the date separator. Bits #8-11 contain a value indicating the date display format as follows:</FONT> <U><B>Value Meaning</B></U>
<P>
<FONT SIZE=2> 0 MM-DD-YY</FONT>
<P>
<FONT SIZE=2> 1 DD-MM-YY</FONT>
<P>
<FONT SIZE=2> 2 YY-MM-DD</FONT>
<P>
<FONT SIZE=2> 3 YY-DD-MM</FONT>Bits #12-15 contain a value indicating the time format as follows:<FONT SIZE=2> <U><B>Value Meaning</B></U></FONT>
<P>
<FONT SIZE=2> 0 12 hour</FONT>
<P>
<FONT SIZE=2> 1 24 hour</FONT>Note: The value of this cookie does not affect any of the internal time functions. It is intended for informational use by applications only.
</TD></TR>

<TR><TH>
<CENTER>
<a name=akp><B>_AKP</B>
</CENTER>
</TH><TD><FONT SIZE=2>This cookie indicates the presence of an Advanced Keyboard Processor. The high word of this cookie is currently reserved. The low word indicates the language currently used by <B>TOS</B> for keyboard interpretation and alerts. See the explanation for the country code in the OS header earlier in this chapter for valid values.</FONT>If this cookie is present on TOS 5.0 and higher then the system supports soft-loaded keyboard tables.
</TD></TR>

<TR><TH>
<CENTER>
<a name=fsmc><B>FSMC</B>
</CENTER>
</TH><TD><FONT SIZE=2>This cookie indicates the presence of <B>FSM </B>or <B>SpeedoGDOS</B>. Its <I>value</I> field is a pointer to a structure as follows:<TT><FONT SIZE=2 FACE="Courier New">typedef struct</FONT></TT></FONT>
<P>
<TT><FONT SIZE=2 FACE="Courier New">{</FONT></TT>
<P>
<TT><FONT SIZE=2 FACE="Courier New"> LONG  gdos_type;</FONT></TT>
<P>
<TT><FONT SIZE=2 FACE="Courier New"> UWORD version;</FONT></TT>
<P>
<TT><FONT SIZE=2 FACE="Courier New"> WORD  quality;</FONT></TT>
<P>
<TT><FONT SIZE=2 FACE="Courier New">} GDOS_INFO;</FONT></TT>The <I>gdos_type</I> field determines the variety of <B>GDOS</B>. '<B>_FSM</B>' represents Imagen font-based <B>FSM</B> whereas '<B>_SPD</B>' represents Bitstream font-based <B>FSM</B>. <I>version</I> specifies the current GDOS version.<I><FONT SIZE=2>quality</FONT></I> determines the output quality of <B>v_updwk()</B>. The default setting is <B>QUAL_DEFAULT</B> (0xFFFF) which causes the driver to use the setting last set in the driver configuration accessory or CPX. This default setting may be overridden by placing a value of <B>QUAL_DRAFT</B> (0x0000) or <B>QUAL_FINAL</B> (0x0001) at this location. The quality setting should be restored to <B>QUAL_DEFAULT</B> at the end of each print job.
</TD></TR>

<TR><TH>
<CENTER>
<B>SAM\0</B>
</CENTER>
</TH><TD><FONT SIZE=2>This cookie indicates the presence of System Audio Manager and the <B>XBIOS</B> extensions it provides. The <I>value</I> field is currently reserved for internal use.</FONT>
</TD></TR>

<TR><TH>
<CENTER>
<B>MiNT</B>
</CENTER>
</TH><TD><FONT SIZE=2>This cookie indicates the presence of <B>MiNT</B> (<B>MultiTOS</B>) and its <I>value</I> field is the current version number (ex: <B>MiNT</B> 1.02 has a <I>value</I> field of 0x00000102).</FONT>
</TD></TR>

</TABLE>

<P>
 
<HR>

<a name=devices><a name=device><H4><FONT SIZE=4 >BIOS Devices</FONT></H4>

<HR>

<P>
The <B>BIOS</B> provides access to six default devices (numbered
0-5). In addition, <B>TOS</B> 2.00 provides the ability to add
extra devices with the <B>XBIOS</B> <a name=bconmap><B>Bconmap()</B> function
(see the <B>XBIOS</B> overview for more information). Device assignments
higher than device five are dependent upon the machine and any
third-party enhancements. The following list indicates the device
assignments which remain constant:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Name</FONT></B></TH><TH>
<CENTER>
<B><FONT SIZE=2 >Device Number</FONT></B>
</CENTER>

</TH><TH>
<CENTER>
<B><FONT SIZE=2 >GEMDOS Filename</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Meaning</FONT></B></TH>
</TR>

<TR><TH><B>DEV_PRINTER</B></TH><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>PRN:</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2>Centronics Parallel Port</FONT></TD></TR>

<TR><TH><B>DEV_AUX</B></TH><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>AUX:</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2>Default Serial Device (this device number could actually refer to any serial device connected to the system depending on which was mapped with <B>Bconmap()</B> )</FONT>
</TD></TR>

<TR><TH><B>DEV_CON</B></TH><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>CON:</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2>Console (screen device)</FONT></TD></TR>

<TR><TH><B>DEV_MIDI</B></TH><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>N/A</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2><a name=midi>MIDI Ports</FONT></TD></TR>

<TR><TH><B>DEV_IKBD</B></TH><TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>N/A</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2>Intelligent Keyboard Controller</FONT></TD></TR>

<TR><TH><B>DEV_RAW</B></TH><TD>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>N/A</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2>Console (no interpretation)</FONT></TD></TR>

</TABLE>

<P>

<a name=cdevice><H5>The Console Device</H5>

<P>
Two methods are provided for outputting characters to the screen.
Output via <B>BIOS</B> device #2 subjects character codes to interpretation.
Codes such as a carriage return (ASCII 13), line feed (ASCII 10),
TAB (ASCII 9), CTRL-G (ASCII 7), and ESCAPE (ASCII 27) are interpreted
as special cases and handled specially.
<P>
Output via <B>BIOS</B> device #5 causes all characters to be output
literally to the screen without interpretation.
<H5><a name=vt52emulator>The VT-52 Emulator</H5>

<P>
The Atari console device contains emulation code compatible with
the VT52 standard. Special escapes may be used to manipulate the
cursor and create text effects.
<P>
To send an escape sequence, one of the following codes (and possibly
additional characters) must be sent following the ESCAPE character
(ASCII 27):
<TABLE BORDER=1>

<TR><TH>
<CENTER>
<B><FONT SIZE=1 >Escape</FONT></B>
</CENTER>

</TH><TH>
<CENTER>
<B><FONT SIZE=2 >Code</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Effect</FONT></B></TH>
</TR>

<TR><TD>
<CENTER>
A
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>65</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Move the cursor up one line. If the cursor is on the top line this does nothing.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
B
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>66</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Move the cursor down one line. If the cursor is on the bottom line this does nothing.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
C
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>67</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Move the cursor right one line. If the cursor is on the far right of the screen this does nothing.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
D
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>68</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Move the cursor left one line. If the cursor is on the far left of the screen this does nothing.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
E
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>69</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Clear the screen and place the cursor at the upper-left corner.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
H
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>72</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Move the cursor to the upper-left corner of the screen.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
I
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>73</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Move the cursor up one line. If the cursor is on the top line, the screen scrolls down one line.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
J
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>74</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Erase the screen downwards from the current position of the cursor.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
K
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>75</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Clear the current line to the right from the cursor position.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
L
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>76</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Insert a line by scrolling all lines at the cursor position down one line.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
M
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>77</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Delete the current line and scroll lines below the cursor position up one line.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
Y
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>89</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Position the cursor at the coordinates given by the following two codes. The screen starts with coordinates ( 32, 32 ) at the upper-left of the screen. Coordinates should be presented in reverse order, Y and then X.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
b
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>98</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This code is followed by a character from which the lowest four bits determine a new text foreground color.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
c
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>99</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This code is followed by a character from which the lowest four bits determine a new text background color.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
d
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>100</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Erase the screen from the upper-left to the current cursor position.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
e
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>101</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Enable the cursor.</FONT></TD></TR>

<TR><TD>
<CENTER>
f
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>102</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Disable the cursor.</FONT></TD></TR>

<TR><TD>
<CENTER>
j
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>106</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Save the current cursor position. (Only implemented as of <B>TOS</B> 1.02)</FONT>
</TD></TR>

<TR><TD>
<CENTER>
k
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>107</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Restore the current cursor position. (Only implemented as of <B>TOS</B> 1.02)</FONT>
</TD></TR>

<TR><TD>
<CENTER>
l
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>108</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Erase the current line and place the cursor at the far left.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
o
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>111</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Erase the current line from the far left to the current cursor position.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
p
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>112</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Enable inverse video.</FONT></TD></TR>

<TR><TD>
<CENTER>
q
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>113</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Disable inverse video.</FONT></TD></TR>

<TR><TD>
<CENTER>
v
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>118</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Enable line wrap.</FONT></TD></TR>

<TR><TD>
<CENTER>
w
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>119</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Disable line wrap.</FONT></TD></TR>

</TABLE>

<P>

<HR>

<a name=media><a name=mediachange><H4><FONT SIZE=4 >Media Change</FONT></H4>

<HR>

<P>
The <B>BIOS</B> function <a name=mediach><B>Mediach()</B> returns the current
media-change status of the drive specified. This state is used
to determine if a disk has been changed in removable media drives
(floppies, removable hard drives, etc.
<P>
The <a name=getbpb><a name=getmpb><B>Getbpb()</B> incorrectly resets the media change state.
Failure to properly reset this state after calling <B>Getbpb()</B>
can cause data loss. The function <B>_mediach()</B>, shown below,
forces the <B>Mediach()</B> function to return a 'definitely changed'
state and should always be called after calling <B>Getbpb()</B>
on removable media drives.
<PRE>
/*
 * _mediach(): force the media 'changed' state on a removable drive.
 *
 * Usage: errcode = _mediach( devno )		- returns 1 if an error occurs
 *
 * Inputs: devno - (0 = 'A:', 1 = 'B:', etc...)
 *
 */

			.globl	_mediach

_mediach:
			move.w	4(sp),d0
			move.w	d0,mydev
			add.b	#'A',d0
			move.b	d0,fspec		; Set drive spec for search
loop:
			clr.l	-(sp)		; Get supervisor mode, leave old SSP
			move.w	#$20,-(sp)	; and "Super" function code on stack.
			trap		#1
			addq.l	#6,sp
			move.l	d0,-(sp)
			move.w	#$20,-(sp)

		<a name=getbpb2>	move.l	$472,oldgetbpb
			move.l	$47e,oldmediach
			move.l	$476,oldrwabs

			move.l	#newgetbpb,$472
			move.l	#newmediach,$47e
			move.l	#newrwabs,$476

			; Fopen a file on that drive
			move.w	#0,-(sp)
			move.l	#fspec,-(sp)
			move.w	#$3d,-(sp)
			trap		#1
			addq.l	#8,sp

			; Fclose the handle
			tst.l	d0
			bmi.s	noclose

			move.w	d0,-(sp)
			move.w	#$3e,-(sp)
			trap		#1
			addq.l	#4,sp

noclose:
			moveq	#0,d7
			cmp.l	#newgetbpb,$472		; still installed?
			bne.s	done

			move.l	oldgetbpb,$472		; Error, restore vectors.
			move.l	oldmediach,$47e
			move.l	oldrwabs,$476

			trap		#1					; go back to user mode
			addq.l	#6,sp				; restore sp
			
			moveq.l	#1,d0				; 1 = Error
			rts
done:
			trap		#1					; go back to user mode
			addq.l	#6,sp				; from stack left above

			clr.l	d0					; No Error

			rts

/*
 * New Getbpb()...if it's the target device, uninstall vectors.
 * In any case, call normal Getbpb().
 */

newgetbpb:
			move.w	mydev,d0
			cmp.w	4(sp),d0
			bne.s	dooldg

			move.l	oldgetbpb,$472	; Got target device so uninstall.
			move.l	oldmediach,$47e
			move.l	oldrwabs,$476
dooldg:			move.l	oldgetbpb,a0		; Go to real Getbpb()
			jmp		(a0)

/*
 * New Mediach()...if it's the target device, return 2. Else call old.
 */

<a name=mediach2>newmediach:
			move.w	mydev,d0
			cmp.w	4(sp),d0
			bne.s	dooldm
			moveq.l	#2,d0			; Target device, return 2

			rts

dooldm:
			move.l	oldmediach,a0		; Call old
			jmp		(a0)

/*
 * <a name=rwabs>New Rwabs()...if it's the target device, return E_CHG (-14)
 */

newrwabs:
			move.w	mydev,d0
			cmp.w	4(sp),d0
			bne.s	dooldr
			moveq.l	#-14,d0
			rts

dooldr:
			move.l	oldrwabs,a0
			jmp		(a0)

			.data

fspec:			dc.b		"X:\\X",0
mydev:			ds.w		1
oldgetbpb:	ds.l		1
oldmediach:	ds.l		1
oldrwabs:	ds.l		1
			
			.end
</PRE>

<HR>

<a name=vectors><H4><FONT SIZE=4 >BIOS Vectors</FONT></H4>

<HR>

<H5>Reset Vector</H5>

<P>
Shortly after a warm boot the OS will jump to the address contained
in the system variable <I>resvector</I> ($42A) if the value in
the system variable <I>resvalid</I> ($426) contains the magic
number $31415926. The OS will supply a return address to this
code segment in register A6 but the subroutine must not utilize
the stack as neither stack pointer will be valid.
<P>
 If your process needs to do cleanup in the event of a warm reset
(see "Placing a Cookie" earlier in this chapter) the
following code installs a user routine to accomplish this.
<PRE>
	_resvalid		equ		$426
	_resvector		equ		$42A
	RESMAGIC		equ		$31415926

					.text

	installres:
					move.l	_resvalid,oldvalid
					move.l	_resvector,oldvector
					move.l	#myresvec,_resvector
					move.l	#RESMAGIC,_resvalid
					rts
	myresvec:
					*
					* Insert user code here
					*
					move.l	oldvector,_resvector
					move.l	oldvalid,_resvalid
					jmp		(a6)

					.bss

	oldvector:		ds.l		1
	oldvalid:		ds.l		1

					.end

</PRE>

<H5><FONT SIZE=2>System Bell Vector</FONT></H5>

<P>
As of <B>TOS</B> 1.06, the OS jumps through the address contained
in the system variable <I>bell_hook</I> ($5AC) to ring the system
bell. It is possible for a custom routine to hook into this vector
to alter the bell sound. The user routine may modify registers
D0-D2/A0-A2 and may chain to the old bell handler if desired.
It is also safe to make <B>BIOS</B> and <B>XBIOS</B> calls following
the procedure for calling from an interrupt (when not running
under <B>MultiTOS</B>). The routine should either jump to the
old handler or execute an RTS statement.
<H5>System Keyclick Vector</H5>

<P>
Similar to the system bell vector, another vector is called each
time a keyclick sound is generated. This vector is stored in system
variable <I>kcl_hook</I> ($5B0) and is entered with the keycode
(not the ASCII code) of the key struck in the low byte of D0.
Registers D1-D2/A0-A2 may be modified, however, all other registers
including D0 must be maintained. The replacement handler may either
chain to a new handler or RTS.
<a name=handlers><H5>Deferred Vertical Blank Handlers</H5>

<P>
Applications may install custom routines which are called during
every vertical blank (approx. 50-72 times per second). The OS
performs several operations during the vertical blank as follows:
<P>
 The system variable _<I>frclock</I> is incremented.
<P>
 The system variable <I>vblsem</I> is tested. If 0, the vertical
blank handler exits immediately.
<P>
 All registers are saved.
<P>
 The system variable _<I>vbclock</I> is incremented.
<P>
 If the system is currently in a high resolution video mode and
a low-resolution monitor is detected, the video resolution is
adjusted and the vector found at system variable <I>swv_vec</I>
is called.
<P>
 The text cursor blink routine is called.
<P>
 If a new palette has been selected since the last vertical blank,
it is loaded.
<P>
 If a new screen base address has been selected since the last
vertical blank, it is selected.
<P>
 Each of the "deferred" vertical blank routine handlers
is called.
<P>
 If the system variable <I>prt_cnt</I> is greater than -1, the
vector at system variable <I>scr_dump</I> is called.
<P>
 Saved registers are restored and processing continues.
<P>
To install a routine to be called as a "deferred" vertical
blank handler, you must inspect the list of handler vectors at
<a name=vblqueue><I>vblqueue</I> for a <B>NULL</B> slot, replace it with your vector
and initialize the next slot to <B>NULL</B>. The system variable
<I>nvbls</I> indicates the number of slots pointed to by <I>vblqueue</I>.
If the vertical blank handler list is filled, you may allocate
a new area, copy the old list of handlers with your handler, and
update the pointer <I>vblqueue</I> and <I>nvbls</I>.  
<HR>

<a name=xbra><H4><FONT SIZE=4 >The XBRA Protocol</FONT></H4>

<HR>

<P>
Many applications that add functionality to the system do so by
'hooking' themselves into one or more interrupt or pass-through
vectors (usually with <a name=setexc><B>Setexc()</B>). Most vector handlers work
by executing the relevant code when the interrupt is called and
then calling the original vector handler. When several applications
handle one vector, a vector 'chain' is created. This chain makes
it difficult for debuggers or the process itself to 'unhook' itself
from the chain.
<P>
The XBRA protocol was designed so that processes that wish to
be able to unhook themselves may and so that debuggers can trace
the 'chain' of vector handlers. Following the protocal is simple.
Prior to the first instruction of the vector handler, insert three
longwords into the application as follows:
<UL>
<LI>The longword 'XBRA' 0x58425241.
<LI>Another longword containing the application 'cookie' ID (this
is the same as that put into the cookie jar if applicable).
<LI>A longword into which should be placed the address of the
original handler.
</UL>

<P>

<P>
The following code example shows how to correctly use the XBRA
protocol in a routine designed to supplement the 680x0 TRAP #1
vector (<B>GEMDOS</B>):
<PRE>
instl_trap1:
			move.l		#my_trap1,-(sp)
			move.w		#VEC_GEMDOS,-(sp)
			move.w		#Setexc,-(sp)
			trap			#13
			addq.l		#8,sp
			move.l		d0,old_handler
			rts

			DC.L			'XBRA'
			DC.L			'SDS1'	; Put your cookie here
old_handler	DC.L			0

my_trap1:
			movem.l		d2-d7/a2-a6,-(sp)

			;
			; Your TRAP #1 handler goes here.
			;

			movem.l		(sp)+,d2-d7/a2-a6
			move.l		old_handler,-(sp)		; Fake a return
			rts								; to old code.

</PRE>

<P>
The following 'C' function is an example of how to use the XBRA
protocol to unhook a vector handler from the XBRA chain. This
function will only work if all installed vector handlers follow
the XBRA protocol. It takes a <a name=setexc2><B>Setexc()</B> vector number and
an XBRA application id cookie as a parameter. It returns the address
of the routine that was unhooked or 0L if unsuccessful.
<PRE>
typedef struct xbra
{
	LONG	xbra_id;
	LONG	app_id;
	VOID 	(*oldvec)();
} XBRA;

LONG
unhook_xbra( WORD vecnum, LONG app_id )
{
	XBRA *rx;
	LONG vecadr, *stepadr, lret = 0L;
	char *savessp;

	vecadr = Setexc( vecnum, VEC_INQUIRE );
	rx = (XBRA *)(vecadr - sizeof( XBRA ));

	/* Set supervisor mode for search just in case. */
	savessp = Super( SUP_SET );

	/* Special Case: Vector to remove is first in chain. */
	if( rx-&gt;xbra_id == 'XBRA' &amp;&amp; rx-&gt;app_id == app_id )
	{
		Setexc( vecnum, rx-&gt;oldvec );
		return vecadr;
	}

	stepadr = (LONG *)&amp;rx-&gt;oldvec;
	rx = (XBRA *)((LONG)rx-&gt;oldvec - sizeof( XBRA ));
	while( rx-&gt;xbra_id == 'XBRA' )
	{
		if( rx-&gt;app_id == app_id )
		{
			*stepadr = lret = (LONG)rx-&gt;oldvec;
			break;
		}

		stepadr = (LONG *)&amp;rx-&gt;oldvec;
		rx = (XBRA *)((LONG)rx-&gt;oldvec - sizeof( XBRA ));
	}

	Super( savessp );
	return lret;
}
</PRE>

<HR>

<a name=calling><H4><FONT SIZE=4 >BIOS Function Calling Procedure</FONT>
</H4>

<HR>

<P>
<B>BIOS</B> system functions are called via the TRAP #13 exception.
Function arguments are pushed onto the current stack (user or
supervisor) in reverse order followed by the function opcode.
The calling application is responsible for correctly resetting
the stack pointer after the call. 
<P>
The <B>BIOS</B> may utilize registers D0-D2 and A0-A2 as scratch
registers and their contents should not be depended upon at the
completion of a call. In addition, the function opcode placed
on the stack will be modified. The BIOS places return codes in D0.
<P>
The following example for <a name=bconout><B>Bconout()</B> illustrates calling
the <B>BIOS</B> from assembly language:
<PRE>
move.w		#char,-(sp)
move.w		#dev,-(sp)
move.w		#$03,-(sp)
trap		#13
addq.l		#6,sp

</PRE>

<P>
A 'C' binding for a generic <B>BIOS</B> handler would be as follows:
<PRE>
_bios:
	; Save the return code from the stack
	move.l	(sp)+,trp13ret
	trap		#13
	move.l	trp13ret,-(sp)
	rts

	.bss
trp13ret:
	.ds.l		1		
</PRE>

<P>
With the above code, you could easily design a 'C' macro to add
<B>BIOS</B> calls to your compiler as in the following example
for <B>Bconout()</B>:
<PRE>
#define Bconout( a )	bios( 0x02, a )

</PRE>

<P>
The <B>BIOS</B> is re-entrant to three levels, however there is
no <a name=adderror>error checking performed so interrupt handlers should avoid
intense <B>BIOS</B> usage. In addition, no disk or printer usage
should be attempted from the system timer interrupt, critical
error, or process-terminate handlers. 
<a name=interupt><H5>Calling the BIOS from an Interrupt</H5>

<P>
The <B>BIOS</B> and <B>XBIOS</B> are the <I>only</I> two OS sub-systems
which can be called from an interrupt handler. Precisely <I>one</I>
interrupt handler at a time may use the <B>BIOS</B> as shown in
the following code segment:
<PRE>
savptr			equ		$4A2
savamt			equ		$23*2

myhandler:
			sub.l	#savamt,savptr

			; BIOS calls may be performed here

			add.l	#savamt,savptr

			rte		; (or rts?)

</PRE>

<P>
This method is not valid under <B>MultiTOS</B>.
<p>
<hr><center><a href="toc.htm"> Table of Contents | </a><a href="index.htm"> Index </a></center>
</BODY>

</HTML>
