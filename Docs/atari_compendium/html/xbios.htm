<HTML>

<HEAD>

<TITLE>XBIOS Reference, Master</TITLE>


</HEAD>

<BODY BACKGROUND BGCOLOR=#FFFFFF>

<H2>XBIOS Function Reference</H2>

<HR>

<H3>Bconmap() </H3>

<P>
<B>LONG Bconmap( <I>devno </I>)</B>
<P>
<B>WORD <I>devno</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>Bconmap()</B> maps a serial device to <B>BIOS</B> device #1. It is also used to add serial device drivers to the system.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>44 (0x2C)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>To reliably check that <B>Bconmap()</B> is supported, the <B>TOS</B> version must be 1.02 or higher and the following function should return a <B>TRUE</B> value.
<PRE>
#define BMAP_EXISTS 0

<FONT SIZE=2>BOOL IsBconmap( VOID )
</FONT>{
<FONT SIZE=2> return (Bconmap(0) == BMAP_EXISTS);
</FONT>}
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3>The value of <I>devno</I> has the following effect:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD>
<CENTER>
<I><B><FONT SIZE=1 >Name</FONT></B></I>
</CENTER>

</TD><TD>
<CENTER>
<I><B><FONT SIZE=1 >devno</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD>
<CENTER>
<B>BMAP_CHECK</B>
</CENTER>
</TD>
<TD>
<CENTER>
0
</CENTER>
</TD><TD><FONT SIZE=2>Verify the existence of the call (systems without <B>Bconmap()</B> will return the function opcode 44).</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
-
</CENTER>
</TD><TD>
<CENTER>
1-5
</CENTER>

</TD><TD><FONT SIZE=2>These are illegal values (will return 0).</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<I>See <B>XBIOS</B> Serial Port Mapping for constants</I>.
</CENTER>

</TD><TD>
<CENTER>
6-
</CENTER>
</TD><TD><FONT SIZE=2>Redefine <B>BIOS</B> device 1 (the <B>GEMDOS</B> 'aux:' device) to map to the named serial device. All <B>Bcon...(1,...)</B>, <B>Rsconf()</B>, and <B>Iorec()</B> calls will return information for the named device. Returns the old value.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>BMAP_INQUIRE</B>
</CENTER>

</TD><TD>
<CENTER>
-1
</CENTER>
</TD><TD><FONT SIZE=2>Don't change anything, simply return the old value.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>BMAP_MAPTAB</B>
</CENTER>
</TD>
<TD>
<CENTER>
-2
</CENTER>
</TD><TD><FONT SIZE=2>Return a pointer to the serial device vector table (see below).</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
move.w   devno,-(sp)
move.w   #$2C,-(sp)
trap   #14
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3>See above.</TD>
</TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=3>You should never install the 38th device (<B>BIOS</B> device number 44). It would be indistinguishable from the case where <B>Bconmap()</B> was unavailable. In the unlikely event that this case arises, you should install two new devices and assign your new device to the second one.
<P>
All current versions of Falcon030 <B>TOS</B> (4.00 - 4.04) contain a bug that prevents the <B>BIOS</B> from accessing the extra available devices. A patch program named FPATCH2.PRG is available from Atari Corporation to correct this bug in software.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=3>To add a serial device to the table, use <B>Bconmap(-2)</B> to return a pointer to a <B>BCONMAP</B> structure. <I>maptab</I> points to a list of <B>MAPTAB</B> structures (the first entry in <B>MAPTAB</B> is the table for device number 6). The list will contain <I>maptabsize</I> devices. Allocate a block of memory large enough to store the old table plus your new entry and copy the old table and your new device structure there making sure to increment <I>maptabsize</I>. Finally, alter <I>maptab</I> to point to your new structure.
<PRE>
typedef struct
{
WORD (*Bconstat)();
 LONG (*Bconin)();
 LONG (*Bcostat)();
 VOID (*Bconout)();
 ULONG (*Rsconf)();
 IOREC *iorec;   /* See Iorec() */
} MAPTAB;

typedef struct
{
 MAPTAB *maptab;
 WORD   maptabsize;
} BCONMAP;
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>Bconin(), Bconout(), Rsconf(), Iorec()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=bioskeys><H3>Bioskeys()</H3>

<P>
<B>VOID Bioskeys( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Bioskeys()</B> is used to reset to the power-up defaults of the keyboard configuration tables.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>24 (0x18)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>TOS</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$18,-(sp)
trap   #14
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call is only necessary to restore changes made by modifying the tables given by <B>Keytbl()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Keytbl()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>Blitmode()</H3>

<P>
<B>WORD Blitmode( <I>mode </I>)</B>
<P>
<B>WORD <I>mode</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>Blitmode()</B> detects a hardware BLiTTER chip and can alter its configuration if present.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>64 (0x40)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>This call is available as of <B>TOS</B> 1.02.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>mode</I> is used to set the BLiTTER configuration. If <I>mode</I> is <B>BLIT_INQUIRE</B> (1), the call will return the current state of the BLiTTER without modifying its state. To change the method of OS blit operations, call <B>Blitmode()</B> with one of the following values:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >mode</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>BLIT_SOFT</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>If set, use hardware BLiTTER chip, otherwise use software routines.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>BLIT_HARD</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>If set, hardware BLiTTER chip is available.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
move.w   mode,-(sp)
move.w   #$40,-(sp)
trap   #14
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3><B>Blitmode()</B> returns the old <I>mode</I> value. Bit #0 of <I>mode</I> contains the currently set blitter mode as shown above. Bit #1 is set to indicate the presence of a hardware blitter chip or clear if no blitter chip is installed.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=3>You should use this call once to verify the existence of the BLiTTER prior to attempting to change its configuration.
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Buffoper()</H3>

<P>
<B>LONG Buffoper( <I>mode </I>)</B>
<P>
<B>WORD <I>mode</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>Buffoper()</B> sets/reads the state of the hardware sound system.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>136 (0x88)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>Available if '_SND' cookie has third bit set.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>mode</I> is a bit array which may be composed of all or none of the following flags indicating the desired sound system state as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><FONT SIZE=1 >Name</FONT></TD><TD>
<CENTER>
<FONT SIZE=2 >Bit Mask</FONT>
</CENTER>

</TD><TD><FONT SIZE=2 >Meaning</FONT></TD></TR>

<TR><TH></TH><TD><B>PLAY_ENABLE</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x01</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Enable DMA Sound Playback. The sound must have been previously identified to the <B>XBIOS</B> with the <B>Buffptr()</B> function.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>PLAY_REPEAT</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x02</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Setting this flag will cause any sound currently playing or started as a result of this call to be looped indefinitely (until <B>Buffoper(</B>0<B>) </B>is used).</FONT>
</TD></TR>

<TR><TH></TH><TD><B>RECORD_ENABLE</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x04</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Enable DMA Sound Recording. The sound must have been previously identified to the <B>XBIOS</B> with the <B>Buffptr()</B> function.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>RECORD_REPEAT</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x08</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Setting this flag during a record will cause the recording to continue indefinitely within the currently set recording buffer (as set by <B>Buffptr()</B>)</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD COLSPAN=3>Alternately, calling this function with a <I>mode</I> parameter of <B>SND_INQUIRE</B> (1) will return a bit mask indicating the current sound system state as shown above.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
move.w   mode,-(sp)
move.w   #$88,-(sp)
trap   #14
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3><B>Buffoper()</B> normally returns 0 for no error or non-zero otherwise (except in inquire mode as indicated above.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=3>The sound system uses a 32 bit FIFO. The FIFO is only guaranteed to be clear when the record enable bit is clear. When transferring new data to the record buffers, the record enable bit should be cleared to flush the FIFO.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>Setbuffer()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3>Buffptr()</H3>

<P>
<B>LONG Buffptr( <I>sptr </I>)</B>
<P>
<B>SBUFPTR *<I>sptr</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Buffptr()</B> returns the current position of the playback and record pointers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>141 (0x8D)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available if '_SND' cookie has third bit set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameter</B></TH><TD><I>sptr</I> is a pointer to a <B>SBUFPTR</B> structure which is filled in with the current pointer values. <B>SBUFPTR</B> is defined as follows:
<PRE>
typedef struct
{
 VOIDP playptr;
 VOIDP recordptr;
 VOIDP reserved1;
 VOIDP reserved2;
} SBUFPTR;
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   sptr
move.w   #$8d,-(sp)
trap   #14
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Buffptr()</B> returns 0 if the operation was successful or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Setbuffer(), Buffoper()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Cursconf()</H3>

<P>
<B>WORD Cursconf( <I>mode</I>, <I>rate </I>)</B>
<P>
<B>WORD <I>mode</I>, <I>rate</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>Cursconf()</B> configures the VT-52 cursor.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>21 (0x15)</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>All <B>TOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=5><I>mode</I> defines the operation as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >mode</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD><B>CURS_HIDE</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Hide cursor.</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>CURS_SHOW</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Show cursor.</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>CURS_BLINK</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Enable cursor blink.</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>CURS_NOBLINK</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Disable cursor blink.</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>CURS_SETRATE</B></TD><TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Set blink rate to <I>rate.</I></FONT></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD><B>CURS_GETRATE</B></TD><TD>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Return current blink rate.</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
move.w   rate,-(sp)
move.w   mode,-(sp)
move.w   #$15,-(sp)
trap   #14
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=5><B>Cursconf()</B> only returns a meaningful value under <I>mode</I> 5 in which it returns the current blink rate.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=5>The blink rate is specified in number of vertical blanks per blink.
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Dbmsg()</H3>

<P>
<B>VOID Dbmsg( <I>rsrvd</I>, <I>msg_num</I>, <I>msg_arg</I> )</B>
<P>
<B>WORD <I>rsrvd</I>, <I>msg_num</I>;</B>
<P>
<B>LONG <I>msg_arg</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dbmsg()</B> allows special debugging messages to be sent to a resident debugger application.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>11 (0x0B)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>The only debugger that currently supports this call is the Atari Debugger.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>rsrvd</I> is currently reserved and should always be 5. <I>msg_num</I> is the message number which you want to send to the debugging host. Values of 0x0000 to 0xEFFF are reserved for applications to define. Values of 0xF000 to 0xFFFF are reserved for special debugging messages.If <I>msg_num</I> is in the application defined range, it and the <B>LONG</B> contained in <I>msg_arg</I> will be displayed by the debugger and the application will be halted.If <I>msg_num</I> is between 0xF001 and 0xF0FF inclusive then <I>msg_arg</I> is interpreted as a character pointer pointing to a string to be output by the debugger and debugging to halt. The string length is determined by the low byte of <I>msg_num</I>. If <I>msg_num</I> is <B>DB_NULLSTRING</B> (0xF000), the string will be output until a <B>NULL</B> is reached.If <I>msg_num</I> is <B>DB_COMMAND</B> (0xF100), <I>msg_arg</I> is interpreted as a character pointer to a string containing a debugger command. The command format is specific to the debugger which you are running.A useful example of this format when running under the Atari debugger allows a string to be output to the debugger without terminating debugging as shown in the following example:
<PRE>

<CENTER>
Dbmsg( 5, DB_COMMAND, "echo 'Debugging Message';g" );
</CENTER>

</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.l   msg_arg,-(sp)
move.w   msg_num,-(sp)
move.w   #$5,-(sp)
move.w   #$0B,-(sp)
trap   #14
lea   10(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The Atari Debugger only understands the value <B>DB_COMMAND</B> (0xF100) for <I>msg_num</I> as of version 3.Though it is normally harmless to run an application with embedded debugging messages when no debugger is present in the system, distribution versions of applications should have these instructions removed.
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Devconnect()</H3>

<P>
<B>LONG Devconnect( <I>source</I>, <I>dest</I>, <I>clk</I>, <I>prescale</I>,
<I>protocol </I>)</B>
<P>
<B>WORD <I>source</I>, <I>dest</I>, <I>clk</I>, <I>prescale</I>,
<I>protocol</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=8><B><a name=devconnect2>Devconnect()</B> attaches a source device in the sound system to one or multiple destination devices through the use of the connection matrix.
</TD></TR>

<TR><TH></TH><TD COLSPAN=8></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=8>139 (0x8B)</TD></TR>

<TR><TH></TH><TD COLSPAN=8></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=8>Available if '_SND' cookie has third bit set.
</TD></TR>

<TR><TH></TH><TD COLSPAN=8></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=8><I>source</I> indicates the source device to connect as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=8></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD COLSPAN=2>
<CENTER>
<I><B><FONT SIZE=2 >source</FONT></B></I>
</CENTER>

</TD><TD COLSPAN=3><B><FONT SIZE=2 >Meaning</FONT></B>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>DMAPLAY</B></TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD COLSPAN=3><FONT SIZE=2>DMA Playback</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>DSPXMIT</B></TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD COLSPAN=3><FONT SIZE=2>DSP Transmit</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>EXTINP</B></TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD COLSPAN=3><FONT SIZE=2>External Input</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>ADC</B></TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD COLSPAN=3><FONT SIZE=2>Microphone/Yamaha PSG</FONT></TD>
</TR>

<TR><TH></TH><TD COLSPAN=8></TD></TR>

<TR><TH></TH><TD COLSPAN=8><I>dest</I> is a bit mask which is used to choose which destination devices to connect as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=8></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD COLSPAN=3>
<CENTER>
<B><FONT SIZE=2 >Mask</FONT></B>
</CENTER>

</TD><TD COLSPAN=2><B><FONT SIZE=2 >Meaning</FONT></B>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>DMAREC</B></TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>0x01</FONT>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>DMA Record</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>DSPRECV</B></TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>0x02</FONT>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>DSP Receive</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>EXTOUT</B></TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>0x04</FONT>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>External Out</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>DAC</B></TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>0x08</FONT>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>DAC (Headphone or Internal Speaker)</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=8></TD></TR>

<TR><TH></TH><TD COLSPAN=8><I>clk</I> is the clock the source device will use as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=8></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD COLSPAN=3>
<CENTER>
<I><B><FONT SIZE=2 >clk</FONT></B></I>
</CENTER>

</TD><TD COLSPAN=2><B><FONT SIZE=2 >Meaning</FONT></B>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>CLK_25M</B></TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Internal 25.175 MHz clock</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>CLK_EXT</B></TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>External clock</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>CLK_32M</B></TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Internal 32 MHz clock</FONT></TD>
</TR>

<TR><TH></TH><TD COLSPAN=8></TD></TR>

<TR><TH></TH><TD COLSPAN=8><I>prescale</I> chooses the source clock prescaler. Sample rate is determined by the formula: Valid prescaler values for the internal CODEC using the 25.175 MHz clock are:
</TD></TR>

<TR><TH></TH><TD COLSPAN=8></TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD COLSPAN=3>
<CENTER>
<I><B><FONT SIZE=2 >prescale</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning/Sample Rate</FONT></B>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2><B>CLK_COMPAT</B></TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>TT030/STe compatiblity mode. Use prescale value set with <B>Soundcmd()</B>.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2><B>CLK_50K</B></TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>49170 Hz</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2><B>CLK_33K</B></TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>32880 Hz</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2><B>CLK_25K</B></TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>24585 Hz</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2><B>CLK_20K</B></TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>19668 Hz</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2><B>CLK_16K</B></TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>16390 Hz</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2><B>CLK_12K</B></TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>12292 Hz</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2><B>CLK_10K</B></TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>9</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>9834 Hz</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2><B>CLK_8K</B></TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>11</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>8195 Hz</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=8></TD></TR>

<TR><TH></TH><TD COLSPAN=8><I>protocol</I> sets the handshaking mode. A value of <B>HANDSHAKE</B> (0) enables handshaking, <B>NO_SHAKE</B> (1) disables it. When transferring sound or video data through the CODEC it is usually recommended that handshaking be disabled. When incoming data must be 100% error free, however, handshaking should be enabled.
</TD></TR>

<TR><TH></TH><TD COLSPAN=8></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=8>
<PRE>
move.w   protocol,-(sp)
move.w   prescale,-(sp)
move.w   clk,-(sp)
move.w   dest,-(sp)
move.w   source,-(sp)
move.w   #$8B,-(sp)
trap   #14
lea   12(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=8></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=8><B>Devconnect()</B> returns 0 if the operation was successful or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD COLSPAN=8></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=8>Setting the prescaler to an invalid value will result in a mute condition.
</TD></TR>

<TR><TH></TH><TD COLSPAN=8></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=8><B>Soundcmd()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3>DMAread()</H3>

<P>
<B>LONG DMAread( <I>sector</I>, <I>count</I>, <I>buf</I>, <I>dev
</I>)</B>
<P>
<B>LONG <I>sector</I>;</B>
<P>
<B>WORD <I>count</I>;</B>
<P>
<B>VOIDP <I>buf</I>;</B>
<P>
<B>WORD <I>dev</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=4><B>DMAread()</B> reads raw sectors from a ACSI or SCSI device.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=4>42 (0x2A)</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=4>This call is available as of <B>TOS</B> version 2.00.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=4><I>sector</I> specifies the sector number to begin reading at. <I>count</I> specifies the number of sectors to read. <I>buf</I> is a pointer to the address where incoming data will be stored. <I>dev</I> specifies the device to read from as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
<I><B><FONT SIZE=1 >dev</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0-7
</CENTER>
</TD><TD><FONT SIZE=2>ACSI devices 0-7</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
8-15
</CENTER>
</TD>
<TD><FONT SIZE=2>SCSI devices 0-7</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=4>
<PRE>
move.w   dev,-(sp)
pea   buf
move.w   count,-(sp)
move.l   sector,-(sp)
move.w   #$2A,-(sp)
trap   #14
lea   14(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=4><B>DMAread()</B> returns 0 if the operation was successful or a negative <B>BIOS</B> error code otherwise.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=4>SCSI devices will write data until the device exits its data transfer phase. Since this call is not dependent on sector size, you should ensure that the buffer is large enough to hold sectors from devices with large sectors (CD-ROM = 2K, for example).
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=4>ACSI transfers must be done to normal RAM. If you need to read sectors into alternative RAM, use the 64KB pointer found with the '_FRB' cookie as an intermediate transfer point while correctly managing the '<I>_flock</I>' system variable.SCSI transfers on the TT030 do not actually use DMA. Handshaking is used to transfer bytes individually. This means that alternative RAM may be used. The Falcon030 uses DMA for SCSI transfers making transfers to alternative RAM illegal.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=4><B>DMAwrite(), Rwabs()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>DMAwrite()</H3>

<P>
<B>LONG DMAwrite( <I>sector</I>, <I>count</I>, <I>buf</I>, <I>dev
</I>)</B>
<P>
<B>LONG <I>sector</I>;</B>
<P>
<B>WORD <I>count</I>;</B>
<P>
<B>VOIDP <I>buf</I>;</B>
<P>
<B>WORD <I>dev</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>DMAwrite()</B> writes raw sectors to ACSI or SCSI devices.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>43 (0x2B)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD><B>TOS</B> versions &gt;= 2.00
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>sector</I> is the starting sector number to write data to. <I>count</I> is the number of sectors to write. <I>buf</I> defines the starting address of the data to write. <I>dev</I> is the device number as specified in <B>DMAread()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   dev,-(sp)
pea   buf
move.w   count,-(sp)
move.l   sector,-(sp)
move.w   #$2B,-(sp)
trap   #14
lea   14(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>DMAwrite()</B> returns 0 if successful or a negative <B>BIOS</B> error code otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>ACSI transfers must be done from normal RAM. If you need to read sectors into alternative RAM, use the 64KB pointer found with the '_FRB' cookie as an intermediate transfer point while correctly managing the '<I>_flock</I>' system variable.SCSI transfers do not actually use DMA. Handshaking is used to transfer bytes individually.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>DMAread(), Rwabs()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3>Dosound()</H3>

<P>
<B>VOID Dosound( <I>cmdlist </I>)</B>
<P>
<B>char *<I>cmdlist</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=2><B>Dosound()</B> initializes and starts an interrupt driven sound playback routine using the PSG.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=2>32 (0x20)</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=2>All <B>TOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=2>If<I> cmdlist</I> is positive, it will be interpreted as a pointer to a character array containing a sequential list of commands required for the sound playback. Each command is executed in order and has a meaning as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B><FONT SIZE=1 >Command Byte</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD>
<CENTER>
0x00 - 0x0F
</CENTER>
</TD><TD><FONT SIZE=2>Select a PSG register (the register number is the command byte). The next byte in the list will be loaded into this register. See <B>Appendix I</B> for a detailed listing of registers, musical frequencies, and sound durations.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
0x80
</CENTER>
</TD><TD><FONT SIZE=2>Store the next byte in a temporary register for use by command 0x81.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
0x81
</CENTER>
</TD><TD><FONT SIZE=2>Three bytes follow this command. The first is the PSG register to load with the value in the temporary register (set with command 0x80). The second is a signed value to add to the temporary register until the value in the third byte is met.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
0x82
</CENTER>
</TD><TD><FONT SIZE=2>If a 0 follows this command, this signals the end of processing, otherwise the value indicates the number of 50Hz ticks to wait until the processing of the next command.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH></TH><TD COLSPAN=2>Passing the value <B>DS_INQUIRE</B> (1) for <I>cmdlist</I> will cause the pointer to the current sound buffer to be returned or <B>NULL</B> if no sound is currently playing.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=2>
<PRE>
pea   cmdlist
move.w   #$20,-(sp)
trap   #14
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=2></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=2>This routine is driven by interrupts. Do not use an array created on the stack to store the command list that may go out of scope before the sound is complete.This function will cause the OS to crash under <B>MultiTOS</B> versions prior to 1.08 if every running application is not set to 'Supervisor' or 'Global' memory protection.<B>Dosound(</B> <B>DS_INQUIRE</B> <B>)</B> will cause the OS to crash under <B>MultiTOS</B> versions 1.08 and below.
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Dsp_Available()</H3>

<P>
<B>VOID Dsp_Available( <I>xavail</I>, <I>yavail </I>)</B>
<P>
<B>LONG *<I>xavail</I>, *<I>yavail</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dsp_Available()</B> returns the amount of free program space in X and Y DSP memory.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>106 (0x6A)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is only available if the fifth bit of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD>Upon return, the longwords pointed to by <I>xavail</I> and <I>yavail</I> will contain the length of memory (in bytes) available for DSP programs and subroutines.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   yavail
pea   xavail
move.w   #$6A,-(sp)
trap   #14
lea   10(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Dsp_Reserve()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>Dsp_BlkBytes()</H3>

<P>
<B>VOID Dsp_BlkBytes( <I>data_in</I>, <I>size_in</I>, <I>data_out</I>,
<I>size_out </I>)</B>
<P>
<B>UBYTE *<I>data_in</I>;</B>
<P>
<B>LONG <I>size_in</I>;</B>
<P>
<B>UBYTE *<I>data_out</I>;</B>
<P>
<B>LONG <I>size_out</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dsp_BlkBytes()</B> transfers a block of unsigned character data to the DSP and returns the output from the running program or subroutine.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>124 (0x7C)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is only available if the fifth bit of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>data_in</I> is a pointer to an unsigned character array which is transferred to the DSP. <I>size_in</I> is the length (in bytes) of data to transfer.<I>data_out</I> is a pointer to the unsigned character array to be filled in from the low byte of the DSP's transfer register. <I>size_out</I> is the length (in bytes) of the output buffer array.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.l   size_out,-(sp)
pea   data_out
move.l   size_in,-(sp)
pea   data_in
move.w   #$7C,-(sp)
trap   #14
lea   18(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>No handshaking is performed with this call. Error sensitive data should be transferred with <B>Dsp_BlkHandShake()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Bytes are not sign extended before transfer. Also, due to the length of static memory in the DSP, <I>size_in</I> and <I>size_out</I> should not exceed 65536.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Dsp_BlkWords()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>Dsp_BlkHandShake</H3>

<P>
<B>VOID Dsp_BlkHandShake( <I>data_in</I>, <I>size_in</I>, <I>data_out</I>,
<I>size_out</I> )</B>
<P>
<B>char *<I>data_in</I>;</B>
<P>
<B>LONG <I>size_in</I>;</B>
<P>
<B>char *<I>data_out</I>;</B>
<P>
<B>LONG <I>size_out</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dsp_BlkHandShake()</B> handshakes a block of  bytes to the DSP and returns the output generated by the running subroutine or program.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>97 (0x61)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is only available if the fifth bit of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>data_in</I> is a pointer to data being sent to the DSP. <I>size_in</I> specifies the number of DSP words of data to be transferred. <B>Dsp_GetWordSize()</B> can be used to determine the number of bytes that occur for a DSP word.<I>data_out</I> is a pointer to the buffer to which processed data will be returned from the DSP. <I>size_out</I> indicates the number of DSP words to transfer.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.l   size_out,-(sp)
pea   data_out
move.l   size_in,-(sp)
pea   data_in
move.w   #$61,-(sp)
trap   #14
lea   18(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD><B>Dsp_BlkHandshake()</B> is identical to <B>Dsp_DoBlock()</B>, however, this function handshakes each byte to prevent errors in sensitive data.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Dsp_DoBlock()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>Dsp_BlkUnpacked()</H3>

<P>
<B>VOID Dsp_BlkUnpacked( <I>data_in</I>, <I>size_in</I>, <I>data_out</I>,
<I>size_out</I> )</B>
<P>
<B>LONG *da<I>ta_in</I>;</B>
<P>
<B>LONG <I>size_in</I>;</B>
<P>
<B>LONG *<I>data_out</I>;</B>
<P>
<B>LONG <I>size_out</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dsp_BlkUnpacked()</B> transfers data to the DSP from a longword array. Data processed by the running subroutine or program is returned.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>98 (0x62)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is only available if the fifth bit of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>data_in</I> is a pointer to an array of <B>LONG</B>s from which data is transferred to the DSP. As many bytes are transferred from each <B>LONG</B> as there are bytes in a DSP <B>WORD</B>. For example, if <B>Dsp_GetWordSize()</B> returns 3, the lower three bytes of each <B>LONG</B> are transferred into each DSP <B>WORD</B>.<I>size_in</I> represents the number of <B>LONG</B>s in the array to transfer. <I>data_out</I> is a pointer to an array of <B>LONG</B>s <I>size_out</I> in length in which data sent from the DSP is returned. 
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.l   size_out,-(sp)
pea   data_out
move.l   size_in,-(sp)
pea   data_in
move.w   #$62,-(sp)
trap   #14
lea   18(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>This function only works with DSP's which return 4 or less from<B> Dsp_GetWordSize()</B>. In addition, no handshaking is performed with this call. Data which is sensitive to errors should use <B>Dsp_BlkHandShake()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Dsp_DoBlock()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>Dsp_BlkWords()</H3>

<P>
<B>VOID Dsp_BlkWords( <I>data_in</I>, <I>size_in</I>, <I>data_out</I>,
<I>size_out</I> )</B>
<P>
<B>WORD *<I>data_in</I>;</B>
<P>
<B>LONG <I>size_in</I>;</B>
<P>
<B>WORD *<I>data_out</I>;</B>
<P>
<B>LONG <I>size_out</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dsp_BlkWords()</B> transfers an array of <B>WORD</B>s to the DSP and returns the output generated by the running subroutine or program.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>123 (0x7B)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is only available if the fifth bit of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>data_in</I> is a pointer to the <B>WORD</B> array to be transferred to the DSP. <I>size_in</I> is the length (in <B>WORD</B>s) of data to transfer.<I>data_out</I> is a pointer to the <B>WORD</B> array to be filled in during the data output phase of the DSP from the middle and low bytes of the transfer register. <I>size_out</I> is the length (in <B>WORD</B>s) of the buffer for the output array.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.l   size_out,-(sp)
pea   data_out
move.l   size_in,-(sp)
pea   data_in
move.w   #$7B,-(sp)
trap   #14
lea   18(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>No handshaking is performed with this call. Data which is sensitive to errors should use <B>Dsp_BlkHandShake()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD><B>WORD</B>s are sign extended before transfer. Also, due to the length of static memory in the DSP, <I>size_in</I> and <I>size_out</I> should not exceed 32768.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Dsp_BlkBytes()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=dsp_dob2><H3>Dsp_DoBlock()</H3>

<P>
<B>VOID Dsp_DoBlock( <I>data_in</I>, <I>size_in</I>, <I>data_out</I>,
<I>size_out</I> )</B>
<P>
<B>char *<I>data_in</I>;</B>
<P>
<B>LONG <I>size_in</I>;</B>
<P>
<B>char *<I>data_out</I>;</B>
<P>
<B>LONG <I>size_out</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dsp_DoBlock()</B> transfers bytewise packed data to the DSP and returns the data processed by the running subroutine or program.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>96 (0x60)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is only available if the fifth bit of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>data_in</I> is a character array containing data to transfer to the DSP. <I>size_in</I> specifies the number of DSP words to transfer. For example, if<B> Dsp_GetWordSize()</B> returns 3, the first 3 bytes from <I>data_in</I> are stored in the first DSP word, the next 3 bytes are stored in the next DSP word and so on. <I>data_out</I> points to a character array where the output will be stored in a similar manner. <I>size_out</I> represents the size of this array.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.l   size_out,-(sp)
pea   data_out
move.l   size_in,-(sp)
pea   data_in
move.w   #$60,-(sp)
trap   #14
lea   18(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>No handshaking is performed with this call. Data which is sensitive to errors should use <B>Dsp_BlkHandShake()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Dsp_BlkHandShake()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3>Dsp_ExecBoot()</H3>

<P>
<B>VOID Dsp_ExecBoot( <I>codeptr</I>, <I>codesize</I>, <I>ability</I>
)</B>
<P>
<B>char *<I>codeptr</I>;</B>
<P>
<B>LONG <I>codesize</I>;</B>
<P>
<B>WORD <I>ability</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dsp_ExecBoot() </B>completely resets the DSP and loads a new bootstrap program into the first 512 DSP words of memory.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>110 (0x6E)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is only available if the fifth bit of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>codeptr</I> points to the beginning of the DSP program data to be transferred. <I>codesize</I> indicates the size (in DSP words) of program data to transfer. <I>ability</I> indicates the bootstrapper's unique ability code.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   ability,-(sp)
move.l   codesize,-(sp)
pea   codeptr
move.w   #$6E,-(sp)
trap   #14
lea   12(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call is only designed for special development and testing purposes. Use of this call takes over control of the DSP system. This call is limited to transferring up to 512 DSP words of code.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Dsp_LoadProg(), Dsp_ExecProg()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Dsp_ExecProg()</H3>

<P>
<B>VOID Dsp_ExecProg( <I>codeptr</I>, <I>codesize</I>, <I>ability</I>
)</B>
<P>
<B>char *<I>codeptr</I>;</B>
<P>
<B>LONG <I>codesize</I>;</B>
<P>
<B>WORD <I>ability</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dsp_ExecProg()</B> transfers a DSP program stored in binary format in memory to the DSP and executes it.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>109 (0x6D)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is only available if the fifth bit of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>codeptr</I> points to the start of the binary program in memory. <I>codesize</I> indicates the number of DSP words to transfer. <I>ability</I> indicates the program's unique ability code.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   ability,-(sp)
move.l   codesize,-(sp)
pea   codeptr
move.w   #$6D,-(sp)
trap   #14
lea   12(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD><I>codesize</I> should not exceed the amount of memory reserved by the <B>Dsp_Reserve() </B>call.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Dsp_LoadProg(), Dsp_Reserve()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=dsp_fs><H3>Dsp_FlushSubroutines()</H3>

<P>
<B>VOID Dsp_FlushSubroutines( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dsp_FlushSubroutines()</B> removes all subroutines from the DSP.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>115 (0x73)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is only available if the fifth bit of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$73,-(sp)
trap   #14
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call should only be used when a program requires more memory than is returned by <B>Dsp_Available()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Dsp_Available()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>Dsp_GetProgAbility()</H3>

<P>
<B>WORD Dsp_GetProgAbility( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dsp_GetProgAbility()</B> returns the current ability code for the program currently residing in DSP memory.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>114 (0x72)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is only available if the fifth bit of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$72,-(sp)
trap   #14
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Dsp_GetProgAbility()</B> returns the <B>WORD</B> ability code for the current program loaded in the DSP.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>If you know the defined ability code of the program you wish to use, you can use this call to see if the program already exists on the DSP and avoid reloading it.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Dsp_InqSubrAbility()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3>Dsp_GetWordSize()</H3>

<P>
<B>WORD Dsp_GetWordSize( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dsp_GetWordSize()</B> returns the size of a DSP word in the installed Digital Signal Processor.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>103 (0x67)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is only available if the fifth bit of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$67,-(sp)
trap   #14
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Dsp_GetWordSize()</B> returns the number of bytes per DSP word.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This value is useful with many DSP-related <B>XBIOS</B> calls to provide upward compatibility as the DSP hardware is not guaranteed to remain the same.
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Dsp_Hf0()</H3>

<P>
<B>WORD Dsp_Hf0( <I>flag</I> )</B>
<P>
<B>WORD <I>flag</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>Dsp_Hf0()</B> reads/writes to bit #3 of the HSR.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>119 (0x77)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>This call is only available if the fifth bit of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>flag</I> has three legal values as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >flag</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>HF_CLEAR</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Clear bit #3 of the DSP's HSR.</FONT></TD>
</TR>

<TR><TH></TH><TD><B>HF_SET</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Set bit #3 of the DSP's HSR.</FONT></TD>
</TR>

<TR><TH></TH><TD><B>HF_INQUIRE</B></TD><TD>
<CENTER>
<FONT SIZE=2>-1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Return the current value of bit #3 of the DSP's HSR.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
move.w   flag,-(sp)
move.w   #$77,-(sp)
trap   #14
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3>If <I>flag</I> is <B>HF_INQUIRE</B> (1), <B>Dsp_Hf0()</B> returns the current state of bit #3 of the HSR register.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>Dsp_Hf1()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3>Dsp_Hf1()</H3>

<P>
<B>WORD Dsp_Hf1( <I>flag</I> )</B>
<P>
<B>WORD <I>flag</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>Dsp_Hf1()</B> reads/writes to bit #4 of the HSR.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>120 (0x78)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>This call is only available if the fifth bit of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>flag</I> has three legal values as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >flag</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>HF_CLEAR</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Clear bit #4 of the DSP's HSR.</FONT></TD>
</TR>

<TR><TH></TH><TD><B>HF_SET</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Set bit #4 of the DSP's HSR.</FONT></TD>
</TR>

<TR><TH></TH><TD><B>HF_INQUIRE</B></TD><TD>
<CENTER>
<FONT SIZE=2>-1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Return the current value of bit #4 of the DSP's HSR.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
move.w   flag,-(sp)
move.w   #$78,-(sp)
trap   #14
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3>If <I>flag</I> is <B>HF_INQUIRE</B> (1), <B>Dsp_Hf1()</B> returns the current state of bit #4 of the HSR register.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>Dsp_Hf0()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3>Dsp_Hf2()</H3>

<P>
<B>WORD Dsp_Hf2( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dsp_Hf2()</B> returns the current status of bit #3 of the DSP's HCR.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>121 (0x79)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is only available if the fifth bit of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$79,-(sp)
trap   #14
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Dsp_Hf2()</B> returns the current setting of bit #3 of the HCR register (valid values are 0 or 1).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Dsp_Hf3()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>Dsp_Hf3()</H3>

<P>
<B>WORD Dsp_Hf3( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dsp_Hf3()</B> returns the current status of bit #4 of the DSP's HCR.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>122 (0x7A)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is only available if the fifth bit of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$7A,-(sp)
trap   #14
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Dsp_Hf3()</B> returns the current setting of bit #4 of the HCR register (valid values are 0 or 1).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Dsp_Hf2()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>Dsp_HStat()</H3>

<P>
<B>BYTE Dsp_Hstat( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>Dsp_HStat()</B> returns the value of the DSP's ICR register.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>125 (0x7D)</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>This call is only available if the fifth bit of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
move.w   #$7D,-(sp)
trap   #14
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=5><B>Dsp_Hstat()</B> returns an 8-bit value representing the current state of the DSP's ICR register as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bit</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD><B>ICR_RXDF</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>ISR Receive data register full (RXDF)</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>ICR_TXDE</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>ISR Transmit data register empty (TXDE)</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>ICR_TRDY</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>ISR Transmitter ready (TRDY)</FONT></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD><B>ICR_HF2</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>ISR Host flag 2 (HF2)</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>ICR_HF3</B></TD><TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>ISR Host flag 3 (HF3)</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
-
</CENTER>
</TD><TD>
<CENTER>
5
</CENTER>

</TD><TD><FONT SIZE=2>Reserved</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>ICR_DMA</B></TD><TD>
<CENTER>
<FONT SIZE=2>6</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>ISR DMA Status (DMA)</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>ICR_HREQ</B></TD><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>ISR Host Request (HREQ)</FONT></TD></TR>

</TABLE>

<P>

<HR>

<H3>Dsp_InqSubrAbility()</H3>

<P>
<B>WORD Dsp_InqSubrAbility( <I>ability</I> )</B>
<P>
<B>WORD <I>ability</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dsp_InqSubrAbility()</B> determines if a subroutine with the specified ability code exists in the DSP.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>117 (0x75)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is only available if the fifth bit of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>ability</I> is the ability code you wish to check.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   ability,-(sp)
move.w   #$75,-(sp)
trap   #14
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Dsp_InqSubrAbility()</B> returns a handle to the subroutine if found or 0 if not.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Dsp_RunSubroutine()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<a name=dsp_is2><H3>Dsp_InStream()</H3>

<P>
<B>VOID Dsp_InStream( <I>data_in</I>, <I>block_size</I>, <I>num_blocks</I>,
<I>blocks_done</I> )</B>
<P>
<B>char *<I>data_in</I>;</B>
<P>
<B>LONG <I>block_size</I>;</B>
<P>
<B>LONG <I>num_blocks</I>;</B>
<P>
<B>LONG *<I>blocks_done</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dsp_InStream()</B> passes data to the DSP via an interrupt handler.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>99 (0x63)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is only available if the fifth bit of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>data_in</I> is a pointer to unsigned character data which should be transferred to the DSP. <I>block_size</I> indicates the number of DSP <B>WORD</B>s that will be transferred at each interrupt. <I>num_blocks</I> indicates the number of blocks to transfer.The <B>LONG</B> pointed to by <I>blocks_done</I> will be constantly updated to let the application know the progress of the transfer.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   blocks_done
move.l   num_blocks,-(sp)
move.l   block_size,-(sp)
pea   data_in
move.w   #$63,-(sp)
trap   #14
lea   18(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>No handshaking is performed with this call. If the data you are transmitting is error sensitive, use <B>Dsp_BlkHandShake()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call is suited for transferring small blocks while other blocks are being prepared for transfer. For larger blocks, <B>Dsp_DoBlock() </B>would be more suitable.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Dsp_BlkHandShake(), Dsp_DoBlock()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Dsp_IOStream()</H3>

<P>
<B>VOID Dsp_IOStream( <I>data_in</I>, <I>data_out</I>, <I>block_insize</I>,
<I>block_outsize</I>, <I>num_blocks</I>, <I>blocks_done</I> )</B>
<P>
<B>char *<I>data_in</I>, *<I>data_out</I>;</B>
<P>
<B>LONG <I>block_insize</I>, <I>block_outsize</I>, <I>num_blocks</I>;</B>
<P>
<B>LONG *<I>blocks_done</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dsp_IOStream()</B> uses two interrupt handlers to transmit and receive data from the DSP.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>101 (0x65)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is only available if the fifth bit of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>data_in</I> is a pointer to a buffer in which each output block is placed. <I>data_out</I> is a pointer to a buffer used to receive each data block from the DSP.<I>block_insize</I> and <I>block_outsize</I> represent the size of the blocks to send and receive, respectively, in DSP <B>WORD</B>s. <I>num_blocks</I> is the total number of blocks to transfer.The <B>LONG</B> pointed at by <I>blocks_done</I> is constantly updated to indicate the number of blocks actually transferred.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   blocks_done
move.l   num_blocks,-(sp)
move.l   block_outsize,-(sp)
move.l   block_insize,-(sp)
pea   data_out
pea   data_in
move.w   #$65,-(sp)
trap   #14
lea   26(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>This call makes the assumption that the DSP will be ready to accept a new block as input every time it finishes sending a block back to the host.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>No handshaking is performed with this call. If your data is error-sensitive, you should use <B>Dsp_BlkHandShake()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Dsp_InStream(), Dsp_OutStream()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Dsp_LoadProg()</H3>

<P>
<B>WORD Dsp_LoadProg( <I>file</I>, <I>ability</I>, <I>buf</I>
)</B>
<P>
<B>char *<I>file</I>;</B>
<P>
<B>WORD <I>ability</I>;</B>
<P>
<B>char *<I>buf</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dsp_LoadProg()</B> loads a '.LOD' file from disk, transmits it to the DSP, and executes it.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>108 (0x6C)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is only available if the fifth bit of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>file</I> is a pointer to a <B>NULL</B>-terminated string containing a valid <B>GEMDOS</B> file specification. <I>ability</I> is the unique ability code that will be assigned to this program. <I>buf</I> should point to a temporary buffer where the DSP will place the binary code it generates. The minimum size of the buffer is determined by the following formula:
<PRE>

<CENTER>
3 * ( #program/data words + (3 * #blocks in program))
</CENTER>

</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   buf
move.w   ability,-(sp)
pea   file
move.w   #$6C,-(sp)
trap   #14
lea   12(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Dsp_LoadProg()</B> returns a 0 is successful or -1 otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Before loading you should determine if a program already exists on the DSP with your chosen ability with <B>Dsp_GetProgAbility()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Dsp_LoadSubroutine()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<a name=dsp_ls><H3>Dsp_LoadSubroutine()</H3>

<P>
<B>WORD Dsp_LoadSubroutine( <I>ptr</I>, <I>size</I>, <I>ability</I>
)</B>
<P>
<B>char *<I>ptr</I>;</B>
<P>
<B>LONG <I>size</I>;</B>
<P>
<B>WORD <I>ability</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dsp_LoadSubroutine()</B> transmits subroutine code to the DSP.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>116 (0x74)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is only available if the fifth bit of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>ptr</I> points to a memory buffer which contains DSP binary subroutine code. <I>size</I> is the length of code to transfer (specified in DSP words). <I>ability</I> is the <B>WORD</B> identifier for the unique ability of this subroutine.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   ability,-(sp)
move.l   size,-(sp)
pea   ptr
move.w   #$74,-(sp)
trap   #14
lea   12(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Dsp_LoadSubroutine()</B> returns the handle assigned to the subroutine or 0 if an error occurred.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>DSP subroutines have many restrictions and you should see the previous discussion of the DSP for more information.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Dsp_RunSubroutine(), Dsp_InqSubrAbility()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=dsp_lock2><H3>Dsp_Lock()</H3>

<P>
<B>WORD Dsp_Lock( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dsp_Lock()</B> locks the use of the DSP to the calling application.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>104 (0x68)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is only available if the fifth bit of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$68,-(sp)
trap   #14
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Dsp_Lock()</B> returns a 0 if successful or -1 if the DSP has been locked by another application.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD><B>Dsp_Lock()</B> should be performed before each use of the DSP to prevent other applications from modifying DSP memory or flushing subroutines. A corresponding <B>Dsp_Unlock()</B> should be issued at the end of each usage. You should limit the amount of time the DSP is locked so other applications may utilize it.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Dsp_Unlock()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>Dsp_LodToBinary()</H3>

<P>
<B>LONG Dsp_LodToBinary( <I>file</I>, <I>codeptr</I> )</B>
<P>
<B>char *<I>file</I>,*<I>codeptr</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dsp_LodToBinary()</B> reads a '.LOD' file and converts the ASCII data to binary program code ready to be sent to the DSP via <B>Dsp_ExecProg()</B> or <B>Dsp_ExecBoot()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>111 (0x6F)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is only available if the fifth bit of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>file</I> is a character pointer to a null-terminated <B>GEMDOS</B> file specification. <I>codeptr</I> should point to a large enough buffer to hold the resulting binary program code.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   codeptr
pea   file
move.w   #$6F,-(sp)
trap   #14
lea   10(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Dsp_LodToBinary()</B> returns the size of the resulting program code in DSP words or a negative error code.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Dsp_ExecProg(), Dsp_LoadProg()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Dsp_MultBlocks()</H3>

<P>
<B>VOID Dsp_MultBlocks( <I>numsend</I>, <I>numreceive</I>, <I>sendblks</I>,
<I>receiveblks</I> )</B>
<P>
<B>LONG <I>numsend</I>, <I>numreceive</I>;</B>
<P>
<B>DSPBLOCK *<I>sendblks</I>, *<I>receiveblks</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dsp_MultBlocks()</B> transmit and receive multiple blocks of DSP data of varying size.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>127 (0x7F)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is only available if the fifth bit of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>numsend</I> and <I>numreceive</I> indicate the number of blocks of DSP data to send and receive respectively. <I>sendblks</I> and <I>receiveblks</I> are both pointers to arrays of type <B>DSPBLOCK</B> which contain information for each block. <B>DSPBLOCK</B> is defined as follows:
<PRE>
typedef struct
{
#define BLOCK_LONG 0
#define BLOCK_WORD 1
#define BLOCK_UBYTE 2
 /* 0 = LONGs, 1 = WORDs, 2 = UBYTEs */
 WORD blocktype;

 /* Num elements in block */
 LONG blocksize;

 /* Start address of block */
 VOIDP blockaddr;
} DSPBLOCK;
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   receiveblks
pea   sendblks
move.l   numreceive,-(sp)
move.l   numsend,-(sp)
move.w   #$7F,-(sp)
trap   #14
lea   18(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>No handshaking is performed with this call. To transfer blocks with handshaking use <B>Dsp_BlkHandShake()</B>.
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Dsp_OutStream()</H3>

<P>
<B>VOID Dsp_OutStream( <I>data_out</I>, <I>block_size</I>, <I>num_blocks</I>,
<I>blocks_done</I> )</B>
<P>
<B>char *<I>data_out</I>;</B>
<P>
<B>LONG <I>block_size</I>;</B>
<P>
<B>LONG <I>num_blocks</I>;</B>
<P>
<B>LONG *<I>blocks_done</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dsp_OutStream()</B> transfers data from the DSP to a user-specified buffer using interrupts.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>100 (0x64)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is only available if the fifth bit of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD>This call transfers data from the DSP to the buffer pointed to by <I>data_out</I> via an interrupt handler. <I>block_size</I> specifies the number of DSP <B>WORD</B>s to be transferred and <I>num_blocks</I> specifies the number of blocks to transfer.The <B>LONG</B> pointed to by <I>blocks_done</I> will be constantly updated by the interrupt handler to indicate the number of blocks successfully transferred. The process is complete when <I>blocks_done</I> is equal to <I>num_blocks</I>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   blocks_done
move.l   num_blocks,-(sp)
move.l   block_size,-(sp)
pea   data_out
move.w   #$64,-(sp)
trap   #1
lea   18(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Dsp_DoBlock(), Dsp_MultBlocks(), Dsp_InStream()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Dsp_RemoveInterrupts()</H3>

<P>
<B>VOID Dsp_RemoveInterrupts( <I>mask</I> )</B>
<P>
<B>WORD <I>mask</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>Dsp_RemoveInterrupts()</B> turns off the generation of DSP interrupts.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>102 (0x66)</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>This call is only available if the fifth bit of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=5><I>mask</I> is an <B>WORD</B> bit mask indicating which interrupts to turn off composed of one or both of the following values:
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Mask</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD><B>RTS_OFF</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x01</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Disable DSP Ready to Send Interrupts</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>RTR_OFF</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x02</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Disable DSP Ready to Receive Interrupts</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
move.w   mask,-(sp)
move.w   #$66,-(sp)
trap   #14
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=5>This call is used to terminate interrupts when an interrupt driven block transfer function does not terminate as expected (this will occur when less than the expected number of blocks is returned) and to shut off interrupts installed by <B>Dsp_SetVectors()</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=5><B>Dsp_SetVectors()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=dsp_rua2><H3>Dsp_RequestUniqueAbility()</H3>

<P>
<B>WORD Dsp_RequestUniqueAbility( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dsp_RequestUniqueAbility()</B> generates a random ability code that is currently not in use.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>113 (0x71)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is only available if the fifth bit of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$71,-(sp)
trap   #14
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Dsp_RequestUniqueAbility()</B> returns a unique ability code to assign to a subroutine or program. 
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Using this function allows you to call <B>Dsp_InqSubrAbility()</B> and <B>Dsp_GetProgAbility()</B> to determine if the DSP code your application has already loaded is still present (i.e. has not been flushed by another application).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>DspInqSubrAbility(), Dsp_GetProgAbility()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=dsp_reserve2><H3>Dsp_Reserve()</H3>

<P>
<B>WORD Dsp_Reserve( <I>xreserve</I>, <I>yreserve</I> )</B>
<P>
<B>LONG <I>xreserve</I>, <I>yreserve</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dsp_Reserve()</B> reserves DSP memory for program usage.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>107 (0x6B)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is only available if the fifth bit of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>xreserve</I> and <I>yreserve</I> specify the amount of memory (in DSP words) to reserve for a DSP program in X and Y memory space respectively. <I>xreserve</I> and <I>yreserve</I> must include all program/data space so that subroutines do not overwrite your reserved area.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.l   yreserve,-(sp)
move.l   xreserve,-(sp)
move.w   #$6B,-(sp)
trap   #14
lea   10(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Dsp_Reserve()</B> returns a 0 if the memory was reserved successfully or -1 if not enough DSP memory was available.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>If this call fails you should call <B>Dsp_FlushSubroutines()</B> and then retry it. If it fails a second time, the DSP lacks enough memory space to run your program.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=dsp_rs><H3>Dsp_RunSubroutine()</H3>

<P>
<B>WORD Dsp_RunSubroutine( <I>handle</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dsp_RunSubroutine()</B> begins execution of the specified subroutine.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>118 (0x76)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is only available if the fifth bit of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> is the <B>WORD</B> identifier of the DSP subroutine to engage.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   handle,-(sp)
move.w   #$76,-(sp)
trap   #14
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Dsp_RunSubroutine()</B> returns a 0 if successful or a negative code indicating failure.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Dsp_LoadSubroutine()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3>Dsp_SetVectors()</H3>

<P>
<B>VOID Dsp_SetVectors( <I>receiver</I>, <I>transmitter</I> )</B>
<P>
<B>VOID (*<I>receiver</I>)();</B>
<P>
<B>LONG (*<I>transmitter</I>)();</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>Dsp_SetVectors()</B> sets the location of application interrupt handlers that are called when the DSP is either ready to send or receive data.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>126 (0x7E)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>This call is only available if the fifth bit of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>receiver</I> is the address of an interrupt handler which is called when the DSP is ready to send a DSP word of data or <B>NULLFUNC</B> ( VOID (*)() 0L ) if you do not wish to set this interrupt.Likewise, <I>transmitter</I> is a pointer to an interrupt handler which is called when the DSP is ready to receive a DSP word of data or <B>NULLFUNC</B> if you do not wish to install a <I>transmitter</I> interrupt.Any function installed to handle <I>transmitter</I> interrupts should return a <B>LONG</B> which has one of the following values:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >transmitter</FONT></B></I>
</CENTER>

<P>

<CENTER>
<B><FONT SIZE=2 >Return Value</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>DSPSEND_NOTHING</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x00000000</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Do not send any data to the DSP.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>DSPSEND_ZERO</B></TD><TD>
<CENTER>
<FONT SIZE=2>0xFF000000</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Transmit a DSP word of 0 to the DSP.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
-
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>Any other</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Transmit the low 24 bits to the DSP.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
move.l   #transmitter,-(sp)
move.l   #receiver,-(sp)
move.w   #$7E,-(sp)
trap   #14
lea   10(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=3>Use <B>Dsp_RemoveInterrupts()</B> to turn off interrupts set with this call.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>Dsp_RemoveInterrupts()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Dsp_TriggerHC()</H3>

<P>
<B>VOID Dsp_TriggerHC( <I>vector</I> );</B>
<P>
<B>WORD <I>vector</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dsp_TriggerHC()</B> causes a host command set aside for DSP programs to execute.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>112 (0x70)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is only available if the fifth bit of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>vector</I> specifies the vector to execute.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   vector,-(sp)
move.w   #$70,-(sp)
trap   #14
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>Currently vectors 0x13 and 0x14 are the only vectors available for this purpose. All other vectors are overwritten by the system on program load and are used by the system and subroutines.
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Dsp_Unlock()</H3>

<H3><FONT SIZE=2>VOID Dsp_Unlock( VOID )</FONT></H3>

<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dsp_Unlock()</B> unlocks the sound system from use by a process which locked it previously using <B>Dsp_Lock()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>105 (0x69)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is only available if the fifth bit of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$69,-(sp)
trap   #14
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Dsp_Lock()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>Dsptristate()</H3>

<P>
<B>LONG Dsptristate( <I>dspxmit</I>, <I>dsprec</I> )</B>
<P>
<B>WORD <I>dspxmit</I>, <I>dsprec</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Dsptristate()</B> connects or disconnects the DSP from the connection matrix.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>137 (0x89)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available if '_SND' cookie has bits 3 and 4 set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>dpsxmit</I> and <I>dsprec</I> specify whether data being transmitted and/or recorded into the DSP passes through the connection matrix. A value of <B>DSP_TRISTATE</B> (0) indicates a 'tristate' condition where data is not fed through the matrix. A value of <B>DSP_ENABLE</B> (1) enables the use of the connection matrix.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   dsprec,-(sp)
move.w   dspxmit,-(sp)
move.w   #$89,-(sp)
trap   #14
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Dsptristate()</B> returns 0 if no error occurred or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call is used in conjunction with <B>Devconnect()</B> to link the DSP to the internal sound system.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Devconnect()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>EgetPalette()</H3>

<P>
<B>VOID EgetPalette( <I>start</I>, <I>count</I>, <I>paldata</I>
)</B>
<P>
<B>WORD <I>start</I>, <I>count</I>;</B>
<P>
<B>WORD *<I>paldata</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=6><B>EgetPalette()</B> copies the current TT030 color palette data into a specified buffer..
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=6>85 (0x55)</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=6>This call is available when the high word of the '_VDO' cookie has a value of 2.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=6><I>start</I> gives the index (0-255) of the first color register to copy data into. <I>count</I> specifies the total number of registers to copy. <I>paldata</I> is a pointer to an array where the TT030 palette data will be stored. Each <B>WORD</B> will be formatted as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
<B><FONT SIZE=1 >Bits 15-12</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bits 11-8</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bits 7-4</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bits 3-0</FONT></B>
</CENTER>

</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
Reserved
</CENTER>
</TD>
<TD>
<CENTER>
<FONT SIZE=2>Red</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>Green</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>Blue</FONT>
</CENTER>
</TD>
</TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=6>
<PRE>
pea   paldata
move.w   count,-(sp)
move.w   start,-(sp)
move.w   #$55,-(sp)
trap   #14
lea   10(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=6>This call is machine-dependent to the TT030. It is therefore recommended that <B>vq_color()</B> be used in most instances.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=6>Unlike <B>Setpalette()</B> this call encodes color nibbles from the most signifigant to least signifigant bit (3-2-1-0) as opposed to the compatibilty method of 0-3-2-1.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=6><B>Esetpalette(), vq_color()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>EgetShift()</H3>

<P>
<B>WORD EgetShift( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>EgetShift()</B> returns the current mode of the video shifter.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>81 (0x51)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>This call is available when the high word of the '_VDO' cookie has a value of 2.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
move.w   #$51,-(sp)
trap   #14
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3><B>EgetShift()</B> returns a <B>WORD</B> bit array which is divided as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Mask Name</FONT></B>
</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bit(s)</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>ES_BANK</B></TD><TD>
<CENTER>
<FONT SIZE=2>0-3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>These bits determine the current color bank being used by the TT (in all modes with less than 256 colors).</FONT>The macro <B>ColorBank()</B> as defined below will extract the current bank code.
<PRE>
#define ColorBank(x) ((x) &amp; ES_BANK)
</PRE>

</TD></TR>

<TR><TH></TH><TD>
<CENTER>
-
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>4-7</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Unused</FONT></TD></TR>

<TR><TH></TH><TD><B>ES_MODE</B></TD><TD>
<CENTER>
<FONT SIZE=2>8-10</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>These bits determine the current mode of the TT video shifter as follows:</FONT><U><B> Name Value</B></U>
<P>
<FONT SIZE=2> <B>ST_LOW</B> 0x0000</FONT>
<P>
<FONT SIZE=2> <B>ST_MED</B> 0x0100</FONT>
<P>
<FONT SIZE=2> <B>ST_HIGH</B> 0x0200</FONT>
<P>
<FONT SIZE=2> <B>TT_MED</B> 0x0300</FONT>
<P>
<FONT SIZE=2> <B>TT_HIGH</B> 0x0600</FONT>
<P>
<FONT SIZE=2> <B>TT_LOW</B> 0x0700</FONT>The current shifter mode code can be extracted with the following macro:
<PRE>
#define ScreenMode(x) ((x) &amp; ES_MODE)
</PRE>

</TD></TR>

<TR><TH></TH><TD>
<CENTER>
-
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>11</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Unused</FONT></TD></TR>

<TR><TH></TH><TD><B>ES_GRAY</B></TD><TD>
<CENTER>
<FONT SIZE=2>12</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This bit determines if the TT video shifter is currently in grayscale mode. The following macro can be used to extract this information:</FONT>
<PRE>
#define IsGrayMode(x) ((x) &amp; ES_GRAY)
</PRE>

</TD></TR>

<TR><TH></TH><TD>
<CENTER>
-
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>13-14</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Unused</FONT></TD></TR>

<TR><TH></TH><TD><B>ES_SMEAR</B></TD><TD>
<CENTER>
<FONT SIZE=2>15</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>If this bit is set, the TT video shifter is currently in smear mode. The following macro can be used to extract this information:</FONT>
<PRE>
#define IsSmearMode(x) ((x) &amp; ES_SMEAR)
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>EsetGray(), EsetShift(), EsetSmear(), EsetBank()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>EsetBank()</H3>

<P>
<B>WORD EsetBank( <I>bank</I> )</B>
<P>
<B>WORD <I>bank</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>EsetBank()</B> chooses which of 16 banks of color registers is currently active.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>82 (0x52)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is available when the high word of the '_VDO' cookie has a value of 2.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>bank</I> specifies the index of the color bank to activate. A value of <B>ESB_INQUIRE</B> (1) does not change anything but still returns the current bank.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   bank,-(sp)
move.w   #$52,-(sp)
trap   #14
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>EsetBank()</B> returns the index of the old blank.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>This call is machine-dependent to the TT030.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>EgetShift()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>EsetColor()</H3>

<P>
<B>WORD EsetColor( <I>idx</I>, <I>color</I> )</B>
<P>
<B>WORD <I>idx</I>, <I>color</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=6><B>EsetColor()</B> sets an individual color in the TT030's palette.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=6>83 (0x53)</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=6>This call is available when the high word of the '_VDO' cookie has a value of 2.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=6><I>idx</I> specifies the color index to modify (0-255). <I>color</I> is a TT030 format color <B>WORD</B> bit array divided as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
<B><FONT SIZE=1 >Bits 15-12</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bits 11-8</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bits 7-4</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bits 3-0</FONT></B>
</CENTER>

</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
Reserved
</CENTER>
</TD>
<TD>
<CENTER>
<FONT SIZE=2>Red</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>Green</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>Blue</FONT>
</CENTER>
</TD>
</TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH></TH><TD COLSPAN=6>If <I>color</I> is <B>EC_INQUIRE</B> (1) then the call does not change the register but still returns it value.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=6>
<PRE>
move.w   color,-(sp)
move.w   idx,-(sp)
move.w   #$53,-(sp)
trap   #14
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=6><B>EsetColor()</B> returns the old value of the color register.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=6>This call is machine-dependent to the TT030. It is therefore recommended that <B>vs_color()</B> be used instead for compatibility.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=6>Unlike <B>Setpalette()</B> this call encodes color nibbles from the most signifigant to least signifigant bit (3-2-1-0) as opposed to the compatibilty method of 0-3-2-1.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=6><B>EsetPalette(), vs_color()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>EsetGray()</H3>

<P>
<B>WORD EsetGray( <I>mode</I> )</B>
<P>
<B>WORD <I>mode</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>EsetGray()</B> reads/modifies the TT030's video shifter gray mode bit.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>86 (0x56)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>This call is available when the high word of the '_VDO' cookie has a value of 2.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>mode</I> is defined as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >mode</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>ESG_INQUIRE</B></TD><TD>
<CENTER>
<FONT SIZE=2>-1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Return the gray bit of the video shifter.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>ESG_COLOR</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Set the video shifter to interpret the lower 16 bits of a palette entry as a TT030 color value (RGB 0-15). </FONT>
</TD></TR>

<TR><TH></TH><TD><B>ESG_GRAY</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Set the video shifter to interpret the lower 8 bits of a palette entry as a TT030 gray value (0-255)</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
move.w   mode,-(sp)
move.w   #$56,-(sp)
trap   #14
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3><B>EsetGray()</B> returns the previous value of the video shifter's gray bit.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=3>This call is machine-dependent to the TT030.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>EgetShift()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3>EsetPalette()</H3>

<P>
<B>VOID EsetPalette( <I>start</I>, <I>count</I>, <I>paldata</I>
)</B>
<P>
<B>WORD <I>start</I>,<I>count</I>;</B>
<P>
<B>WORD *<I>paldata</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>EsetPalette()</B> copies TT030 color <B>WORD</B>s from the specified buffer into the TT030 Color Lookup Table (CLUT).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>84 (0x54)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This call is available when the high word of the '_VDO' cookie has a value of 2.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>start</I> specifies the index of the starting color register to copy color data to. <I>count</I> indicates the number of palette <B>WORD</B>s to copy. <I>paldata</I> is a pointer to an array of palette <B>WORD</B>s to copy.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   paldata
move.w   count,-(sp)
move.w   start,-(sp)
move.w   #$54,-(sp)
trap   #14
lea   10(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>This call is machine-dependent to the TT030. It is therefore recommended that <B>vs_color()</B> be used instead for compatibility.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>For the format of the color <B>WORD</B>s, see <B>EgetPalette()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>EgetPalette(), vq_color()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=esetshift2><H3>EsetShift()</H3>

<P>
<B>WORD EsetShift( <I>mode</I> )</B>
<P>
<B>WORD <I>mode</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>EsetShift()</B> reads/modifies the TT030 video shifter.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>80 (0x50)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>This call is available when the high word of the '_VDO' cookie has a value of 2.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>mode</I> is a <B>WORD</B> bit array which defines the new setting of the video shifter as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bit(s)</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD>
<CENTER>
-
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>0-3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>These bits determine the current color bank being used by the TT (in all modes with less than 256 colors).</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
-
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>4-7</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Unused</FONT></TD></TR>

<TR><TH></TH><TD>
<CENTER>
-
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>8-10</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>These bits determine the current mode of the TT video shifter as follows:</FONT><U><B> Name Bit Mask</B></U>
<P>
<FONT SIZE=2> <B>ST_LOW</B> 0x0000</FONT>
<P>
<FONT SIZE=2> <B>ST_MED</B> 0x0100</FONT>
<P>
<FONT SIZE=2> <B>ST_HIGH</B> 0x0200</FONT>
<P>
<FONT SIZE=2> <B>TT_MED</B> 0x0300</FONT>
<P>
<FONT SIZE=2> <B>TT_HIGH</B> 0x0600</FONT>
<P>
<FONT SIZE=2> <B>TT_LOW</B> 0x0700</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
-
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>11</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Unused</FONT></TD></TR>

<TR><TH></TH><TD><B>ES_GRAY</B></TD><TD>
<CENTER>
<FONT SIZE=2>12</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Setting this bit places the TT video shifter in grayscale mode.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
-
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>13-14</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Unused</FONT></TD></TR>

<TR><TH></TH><TD><B>ES_SMEAR</B></TD><TD>
<CENTER>
<FONT SIZE=2>15</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Setting this bit places the TT video shifter in smearsmear mode.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
move.w   mode,-(sp)
move.w   #$50,-(sp)
trap   #14
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3><B>EsetShift()</B> returns the old <I>mode</I> setting of the video shifter.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=3>This call is machine-dependent to the TT030.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>EgetShift(), EsetGray(), EsetSmear(), EsetBank()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>EsetSmear()</H3>

<P>
<B>WORD EsetSmear( <I>mode</I> )</B>
<P>
<B>WORD <I>mode</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=4><B>EsetSmear()</B> reads/modifies the current state of the video shifter's smear mode bit.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=4>87 (0x57)</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=4>This call is available when the high word of the '_VDO' cookie has a value of 2.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=4><I>mode</I> specifies the action of this call as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >mode</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>ESM_INQUIRE</B></TD><TD>
<CENTER>
<FONT SIZE=2>-1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Return the smear bit of the video shifter.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>ESM_NORMAL</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Set the video shifter to process video data normally. </FONT>
</TD></TR>

<TR><TH></TH><TD><B>ESM_SMEAR</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Set the video shifter to repeat the color of the last displayed pixel each time a 0x0000 is read from video memory.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=4>
<PRE>
move.w   mode,-(sp)
move.w   #$57,-(sp)
trap   #14
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=4><B>EsetSmear()</B> returns the prior setting of the video shifter's smear mode bit.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=4><B>Egetshift(), EsetShift()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Flopfmt()</H3>

<P>
<B>WORD Flopfmt( <I>buf</I>, <I>skew</I>, <I>dev</I>, <I>spt</I>,
<I>track</I>, <I>side</I>, <I>intlv</I>, <I>magic</I>, <I>virgin</I>
)</B>
<P>
<B>VOIDP <I>buf</I>;</B>
<P>
<B>WORD *<I>skew</I>;</B>
<P>
<B>WORD <I>dev</I>, <I>spt</I>, <I>track</I>, <I>side</I>, <I>intlv</I>;</B>
<P>
<B>LONG <I>magic</I>;</B>
<P>
<B>WORD <I>virgin</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>Flopfmt()</B> formats a specified track on a floppy disk.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>10 (0x0A)</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>All <B>TOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=5><I>buf</I> is a pointer to a word-aligned buffer large enough to hold one disk track which is used to build a copy of each sector to write. <I>skew</I> should be <B>NULL</B> for non-interleaved sectors or point to a <B>WORD</B> array containing <I>spt</I> entries which specifies the sector interleave order.<I>dev</I> specifies which floppy drive to format ('A:' = <B>FLOP_DRIVEA</B> (0), 'B:' = <B>FLOP_DRIVEB</B> (1)). <I>spt</I> indicates the number of sectors to format. <I>track</I> indicates which track to format.<I>side</I> indicates the side to format. <I>intlv</I> should be <B>FLOP_NOSKEW</B> (1) for consecutive sectors or <B>FLOP_SKEW</B> (-1) to interleave the sectors based on the array pointed to by <I>skew</I>.<I>magic</I> is a fixed magic number which must be <B>FLOP_MAGIC</B> (0x87654321). <I>virgin</I> is the value to assign to uninitialized sector data (should be <B>FLOP_VIRGIN</B> (0xE5E5)). 
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
move.w   virgin,-(sp)
move.l   magic,-(sp)
move.w   intlv,-(sp)
move.w   side,-(sp)
move.w   track,-(sp)
move.w   spt,-(sp)
move.w   dev,-(sp)
pea   skew
pea   buf
move.w   #$0A,-(sp)
trap   #14
lea   26(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=5><B>Flopfmt()</B> returns 0 if the track was formatted successfully or non-zero otherwise. Also, upon exit, <I>buf</I> will be filled in with a <B>WORD</B> array of sectors that failed formatting terminated by an entry of 0. If no errors occurred then the first <B>WORD</B> of <I>buf</I> will be 0.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=5>The steps required to a format a floppy disk are as follows:1. Call <B>Flopfmt()</B> to format the disk as desired.
<P>
2. Call <B>Protobt()</B> to create a prototype boot sector in memory.
<P>
3. Call <B>Flopwr()</B> to write the prototype boot sector to track 0, side 0, sector 1.Interleaved sector formatting is only possible as of <B>TOS</B> 1.2. <I>skew</I> should be set to <B>NULL</B> and <I>intlv</I> should be set to <B>FLOP_NOSKEW</B> under <B>TOS</B> 1.0.Specifying an <I>intlv</I> value of <B>FLOP_SKEW</B> and a <I>skew</I> array equalling { 1, 2, 3, 4, 5, 6, 7, 8, 9&nbsp;} is the same as specifying an <I>intlv</I> value of <B>FLOP_NOSKEW</B>. To accomplish a 9 sector 2:1 interleave you would use a <I>skew</I> array which looked like: { 1, 6, 2, 7, 3, 8, 4, 9, 5&nbsp;}.<a name=fdc>The '_FDC' cookie (if present) contains specific information regarding the installed floppy drives. The lower three bytes of the cookie value contain a three-letter code indicating the manufacturer of the drive (Atari is 0x415443 'ATC'). The high byte determines the capabilities of the highest density floppy drive currently installed as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Value</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD><B>FLOPPY_DSDD</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Standard Density (720K)</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>FLOPPY_DSHD</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>High Density (1.44MB)</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>FLOPPY_DSED</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Extra High Density (2.88MB)</FONT></TD>
</TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH></TH><TD COLSPAN=5>To format a high density diskette, multiple the <I>spt</I> parameter by 2. To format a extra-high density diskette, multiply the <I>spt</I> parameter by 4.This call forces a 'media changed' state on the device which will be returned on the next <B>Mediach()</B> or <B>Rwabs()</B> call.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=5><B>Floprate(), Floprd(), Flopwr()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Floprate()</H3>

<P>
<B>WORD Floprate( <I>dev</I>, <I>rate</I> )</B>
<P>
<B>WORD <I>dev</I>, <I>rate</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>Floprate()</B> sets the seek rate of the specified floppy drive.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>41 (0x29)</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>Available on all <B>TOS</B> versions except 1.00.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=5><I>dev</I> indicates the floppy drive whose seek rate you wish to modify ('A:' = <B>FLOP_DRIVEA</B> (0), 'B:'&nbsp;= <B>FLOP_DRIVEB</B> (1)). <I>rate</I> specifies the seek rate as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >rate</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD><B>FRATE_6</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Set seek rate to 6ms</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>FRATE_12</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Set seek rate to 12ms</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>FRATE_2</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Set seek rate to 2ms</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>FRATE_3</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Set seek rate to 3ms</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH></TH><TD COLSPAN=5>A <I>rate</I> value of <B>FRATE_INQUIRE</B> (1) will inquire the current seek rate without modifying it.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
move.w   rate,-(sp)
move.w   dev,-(sp)
move.w   #$29,-(sp)
trap   #14
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=5><B>Floprate()</B> returns the prior seek rate for the specified drive.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=5><B>TOS</B> version 1.00 can have its seek rates set by setting the system variable (_<I>seekrate </I>(<B>WORD</B> *)0x440 ) to the desired value (as in <I>rate</I>). Note that you can only set the seek rate for <I>both</I> drives in this manner.
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Floprd()</H3>

<P>
<B>WORD Floprd( <I>buf</I>, <I>rsrvd</I>, <I>dev</I>, <I>sector</I>,
<I>track</I>, <I>side</I>, <I>count</I> )</B>
<P>
<B>VOIDP <I>buf</I>;</B>
<P>
<B>LONG <I>rsrvd</I>;</B>
<P>
<B>WORD <I>dev</I>, <I>sector</I>, <I>track</I>, <I>side</I>,
<I>count</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Floprd()</B> reads sectors from a floppy disk.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>8 (0x08)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>TOS</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>buf</I> points to a word-aligned buffer where the data to be read will be stored. <I>rsrvd</I> is currently unused and should be 0. <I>dev</I> specifies the floppy drive to read from ('A:' = <B>FLOP_DRIVEA</B> (0), 'B:' = <B>FLOP_DRIVEB</B> (1)). The function reads <I>count</I> physical sectors starting at sector <I>sector</I>, track <I>track,</I> side <I>side</I>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   count,-(sp)
move.w   side,-(sp)
move.w   track,-(sp)
move.w   sector,-(sp)
move.w   dev,-(sp)
move.l   rsrvd,-(sp)
pea   buf
move.w   #$08,-(sp)
trap   #14
lea   20(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Floprd()</B> returns 0 if the operation was successful or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>This function reads sectors in physical order (not taking interleave into account). Use <B>Rwabs()</B> to read logical sectors.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Flopwr(), Flopfmt(), Flopver(), Rwabs()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Flopver()</H3>

<P>
<B>WORD Flopver( <I>buf</I>, <I>rsrvd</I>, <I>dev</I>, <I>sector</I>,
<I>track</I>, <I>side</I>, <I>count</I> )</B>
<P>
<B>VOIDP <I>buf</I>;</B>
<P>
<B>LONG <I>rsrvd</I>;</B>
<P>
<B>WORD <I>dev</I>, <I>sector</I>, <I>track</I>, <I>side</I>,
<I>count</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Flopver()</B> verifies data on a floppy disk with data in memory.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>19 (0x13)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>TOS</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>buf</I> is a pointer to a word-aligned buffer to compare the sector against. <I>rsrvd</I> is unused and should be 0. <I>dev</I> specifies the drive to verify ('A:' = <B>FLOP_DRIVEA</B> (0), 'B:' = <B>FLOP_DRIVEB</B> (1)). This function verifies <I>count</I> sectors starting at sector <I>sector</I>, track <I>track</I>, side <I>side</I>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   count,-(sp)
move.w   side,-(sp)
move.w   track,-(sp)
move.w   sector,-(sp)
move.w   dev,-(sp)
move.l   rsrvd,-(sp)
pea   buf
move.w   #$13,-(sp)
trap   #14
lea   20(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Flopver()</B> returns 0 if all sectors were successfully verified or a non-zero value otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>This function only verifies sectors in physical order.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>As with <B>Flopfmt()</B>, upon the return of the function, <I>buf</I> is filled in with a <B>WORD</B> array containing a list of any sectors which failed. The array is terminated with a <B>NULL</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Flopwr(), Flopfmt()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3>Flopwr()</H3>

<P>
<B>WORD Flopwr( <I>buf</I>, <I>rsrvd</I>, <I>dev</I>, <I>sector</I>,
<I>track</I>, <I>side</I>, <I>count</I> )</B>
<P>
<B>VOIDP <I>buf</I>;</B>
<P>
<B>LONG <I>rsrvd</I>;</B>
<P>
<B>WORD <I>dev</I>, <I>sector</I>, <I>track</I>, <I>side</I>,
<I>count</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Flopwr()</B> writes sectors to the floppy drive.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>9 (0x09)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>TOS</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>buf</I> is a pointer containing data to write. <I>rsrvd</I> is currently unused and should be set to 0. <I>dev</I> specifies the floppy drive to write to ('A:' = 0,'B:' = 1). This function writes <I>count</I> sectors starting at sector <I>sector</I>, track <I>track</I>, side <I>side</I>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   count,-(sp)
move.w   side,-(sp)
move.w   track,-(sp)
move.w   sector,-(sp)
move.w   dev,-(sp)
move.l   rsrvd,-(sp)
pea   buf
move.w   #$09,-(sp)
trap   #14
lea   20(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Flopwr()</B> returns 0 if the sectors were successfully written or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>This function writes sectors in physical order only (ignoring interleave). Use <B>Rwabs()</B> to write sectors in logical order.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>If this call is used to write to track 0, sector 1, side 0, the device will enter a 'media might have changed' state indicated upon the next <B>Rwabs()</B> or <B>Mediach()</B> call.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Floprd(), Flopfmt(), Flopver(),Rwabs()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=getrez2><H3>Getrez()</H3>

<P>
<B>WORD Getrez( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=8><B>Getrez()</B> returns a machine-dependent code representing the current screen mode/ratio.
</TD></TR>

<TR><TH></TH><TD COLSPAN=8></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=8>4 (0x04)</TD></TR>

<TR><TH></TH><TD COLSPAN=8></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=8>All <B>TOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=8></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=8>
<PRE>
move.w   #$04,-(sp)
trap   #14
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=8></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=8><B>Getrez()</B> returns a value representing the current video display mode. To find the value you will receive back based on current Atari manufactured video hardware, refer to the following chart:
</TD></TR>

<TR><TH></TH><TD COLSPAN=8></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B><FONT SIZE=1 >Colors:</FONT><FONT SIZE=2 >Screen Dimension:</FONT></B>
</TD><TD>
<CENTER>
<B><FONT SIZE=2 >2</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >4</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >16</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >256</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >True Color</FONT></B>
</CENTER>

</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
<B>320x200</B>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>X</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>X</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>X</FONT>
</CENTER>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
<B>320x240</B>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>X</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
<B>320x480</B>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>X</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
<B>640x200</B>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>X</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>X</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>X</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>X</FONT>
</CENTER>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
<B>640x400</B>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>X</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>X</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>X</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>X</FONT>
</CENTER>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
<B>640x480</B>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT><FONT SIZE=1>&#134;</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
<B>1280x960</B>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>6</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>X</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>X</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>X</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>X</FONT>
</CENTER>
</TD></TR>

<TR><TH></TH><TD COLSPAN=8></TD></TR>

<TR><TH></TH><TD COLSPAN=8><FONT SIZE=1>&#134;</FONT> This value varies. TT030 Medium resolution returns a value of 4, however, the Falcon returns a value of 2.
</TD></TR>

<TR><TH></TH><TD COLSPAN=8></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=8>This call is <I>extremely</I> machine-dependent. Dependence on this call will make your program incompatible with third-party video boards and future hardware. Use the values returned by <B>v_opnvwk()</B> to determine screen attributes.
</TD></TR>

<TR><TH></TH><TD COLSPAN=8></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=8>Use of this call in preparing to call <B>v_opnvwk()</B> is acceptable and must be done to specify the correct fonts to load from <B>GDOS</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=8></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=8><B>VsetMode(), Egetshift(), Setscreen()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=gettime2><H3>Gettime()</H3>

<P>
<B>LONG Gettime( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=4><B>Gettime()</B> returns the current IKBD time.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=4>23 (0x17)</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=4>All <B>TOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=4>
<PRE>
move.w   #$17,-(sp)
trap   #14
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=4><B>Gettime()</B> returns a <B>LONG</B> bit array packed with the current IKBD time as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
<B><FONT SIZE=1 >Bits</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0-4
</CENTER>
</TD><TD><FONT SIZE=2>Seconds/2 (0-29)</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
5-10
</CENTER>
</TD>
<TD><FONT SIZE=2>Minute (0-59)</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
11-15
</CENTER>
</TD>
<TD><FONT SIZE=2>Hour (0-23)</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
16-20
</CENTER>
</TD>
<TD><FONT SIZE=2>Day (1-31)</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
21-24
</CENTER>
</TD>
<TD><FONT SIZE=2>Month (1-12)</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
25-31
</CENTER>
</TD>
<TD><FONT SIZE=2>Year-1980 (0-127)</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH></TH><TD COLSPAN=4>The return value can be represented in a C structure as follows:
<PRE>
typedef struct
{
 unsigned year:7;
 unsigned month:4;
 unsigned day:5;
 unsigned hour:5;
 unsigned minute:6;
 unsigned second:5;
} BIOS_TIME;
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=4><B>Settime(), Tgettime(), Tgetdate()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Giaccess()</H3>

<P>
<B>WORD Giaccess( <I>data</I>, <I>register</I> )</B>
<P>
<B>WORD <I>data</I>, <I>register</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=4><B>Giaccess()</B> reads/sets the registers of the FM sound chip and Port A/B peripherals.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=4>28 (0x1C)</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=4>All <B>TOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=4>The lower eight bits of <I>data</I> are written to the register selected by <I>register</I> if the value for <I>register</I> is OR'ed with 0x80 (high bit set). If this bit is not set, <I>data</I> is ignored and the value of the <I>register</I> is returned. <I>register</I> selects the register to read/write to as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH></TH><TD COLSPAN=2><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >register</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD COLSPAN=2><B>PSG_APITCHHIGH</B>
<P>
<B>PSG_BPITCHHIGH</B>
</TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

<P>

<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Set the pitch of the PSG's channel A to the value in registers 0 and 1. Register 0 contains the lower 8 bits of the frequency and the lower 4 bits of register 1 contain the upper 4 bits of the frequency's 12-bit value.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>PSG_BPITCHLOW</B>
<P>
<B>PSG_BPITCHHIGH</B>
</TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

<P>

<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Set the pitch of the PSG's channel B to the value in registers 0 and 1. Register 0 contains the lower 8 bits of the frequency and the lower 4 bits of register 1 contain the upper 4 bits of the frequency's 12-bit value.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>PSG_CPITCHLOW</B>
<P>
<B>PSG_CPITCHHIGH</B>
</TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

<P>

<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Set the pitch of the PSG's channel C to the value in registers 0 and 1. Register 0 contains the lower 8 bits of the frequency and the lower 4 bits of register 1 contain the upper 4 bits of the frequency's 12-bit value.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>PSG_NOISEPITCH</B></TD><TD>
<CENTER>
<FONT SIZE=2>6</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>The lower five bits of this register set the pitch of white noise. The lower the value, the higher the pitch.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>PSG_MODE</B></TD><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This register contains an eight bit map which determines various aspects of sound generation. Setting each bit on causes the following actions:</FONT><U><B>Name Bit Mask Meaning</B></U><B>  </B>
<P>
<B><FONT SIZE=2>PSG_ENABLEA</FONT></B> 0x01 Chnl A tone enable
<P>
<B><FONT SIZE=2>PSG_ENABLEB</FONT></B> 0x02 Chnl B tone enable
<P>
<B><FONT SIZE=2>PSG_ENABLEC</FONT></B> 0x04 Chnl C tone enable<B><FONT SIZE=2>PSG_NOISEA</FONT></B> 0x08 Chnl A white noise on<B><FONT SIZE=2>PSG_NOISEB</FONT></B> 0x10 Chnl B white noise on
<P>
<B><FONT SIZE=2>PSG_NOISEC</FONT></B> 0x20 Chnl C white noise on<B><FONT SIZE=2>PSG_PRTAOUT</FONT></B> 0x40 Port A:  0 = input<FONT SIZE=2>    1 = output</FONT>
<P>
<B><FONT SIZE=2>PSG_PRTBOUT</FONT></B> 0x80 Port B:  0 - input
<P>
<FONT SIZE=2>    1 = output </FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>PSG_AVOLUME</B></TD><TD>
<CENTER>
<FONT SIZE=2>8</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This register controls the volume of channel A. Values from 0-15 are absolute volumes with 0 being the softest and 15 being the loudest. Setting bit 4 causes the PSG to ignore the volume setting and to use the envelope setting in register 13.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>PSG_BVOLUME</B></TD><TD>
<CENTER>
<FONT SIZE=2>9</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This register controls the volume of channel B. Values from 0-15 are absolute volumes with 0 being the softest and 15 being the loudest. Setting bit 4 causes the PSG to ignore the volume setting and to use the envelope setting in register 13.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>PSG_CVOLUME</B></TD><TD>
<CENTER>
<FONT SIZE=2>10</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This register controls the volume of channel C. Values from 0-15 are absolute volumes with 0 being the softest and 15 being the loudest. Setting bit 4 causes the PSG to ignore the volume setting and to use the envelope setting in register 13.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>PSG_FREQLOW</B>
<P>
<B>PSG_FREQHIGH</B>
</TD><TD>
<CENTER>
<FONT SIZE=2>11</FONT>
</CENTER>

<P>

<CENTER>
<FONT SIZE=2>12</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Register 11 contains the low byte and register 12 contains the high byte of the frequency of the waveform specified in register 13. This value may range from 0 to 65535.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>PSG_ENVELOPE</B></TD><TD>
<CENTER>
<FONT SIZE=2>13</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>The lower four bits of the register contain a value which defines the envelope wavefrom of the PSG. The best definition of values is obtained through experimentation.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>PSG_PORTA</B></TD><TD>
<CENTER>
<FONT SIZE=2>14</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This register accesses Port A of the Yamaha PSG. It is recommended that the functions <B>Ongibit()</B> and <B>Offgibit()</B> be used to access this register.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>PSG_PORTB</B></TD><TD>
<CENTER>
<FONT SIZE=2>15</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This register accesses Port B of the Yamaha PSG. This register is currently assigned to the data in/out line of the Centronics Parallel port.</FONT>
</TD></TR>

<TR><TH></TH><TD></TD><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=4>
<PRE>
move.w   register,-(sp)
move.w   data,-(sp)
move.w   #$1C,-(sp)
trap   #14
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=4><B>Giaccess()</B> returns the value of the register in the lower eight bits of the word if <I>data</I> was OR'ed with 0x80.
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Gpio()</H3>

<P>
<B>LONG Gpio( <I>mode</I>, <I>data</I> )</B>
<P>
<B>WORD <I>mode</I>, <I>data</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=4><B>Gpio()</B> reads/writes data over the general purpose pins on the DSP connector.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=4>138 (0x8A)</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=4>Available if '_SND' cookie has bit 3 set.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=4><I>mode</I> specifies the meaning of <I>data</I> and the return value as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >mode</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>GPIO_INQUIRE</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Return the old value.</FONT></TD></TR>

<TR><TH></TH><TD><B>GPIO_READ</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Read the three general purpose pins and return their state in the lower three bits of the returned value. <I>data</I> is ignored.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>GPIO_WRITE</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Write the lower three bits of <I>data</I> to the corresponding DSP pins. The return value is 0.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=4>
<PRE>
move.w   data,-(sp)
move.w   mode,-(sp)
move.w   #$8A,-(sp)
trap   #14
addq.l   #6,sp
</PRE>

</TD></TR>

</TABLE>

<P>

<HR>

<H3>Ikbdws()</H3>

<P>
<B>VOID Ikbdws( <I>len</I>, <I>buf</I> )</B>
<P>
<B>WORD <I>len</I>;</B>
<P>
<B>CHAR *<I>buf</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Ikbdws()</B> writes the contents of a buffer to the intelligent keyboard controller.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>25 (0x19)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>TOS</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD>This function writes <I>len</I> + 1 characters from buffer <I>buf</I> to the IKBD.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   buf
move.w   len,-(sp)
move.w   #$19,-(sp)
trap   #14
addq.l   #8,sp
</PRE>

</TD></TR>

</TABLE>

<P>

<HR>

<H3>Initmous()</H3>

<P>
<B>VOID Initmous( <I>mode</I>, <I>param</I>, <I>vec</I> )</B>
<P>
<B>WORD <I>mode</I>;</B>
<P>
<B>VOIDP <I>param</I>;</B>
<P>
<B>VOID (*<I>vec</I>)();</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>Initmous()</B> determines the method of handling IKBD mouse packets from the system.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>0 (0x00)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>All <B>TOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>mode</I> indicates a IKBD reporting mode and defines the meaning of the other parameters as listed below. <I>hand</I> points to a mouse packet handler which is called when each mouse packet is sent. Register A0 contains the mouse packet address when called.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B><FONT SIZE=1 >Name</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >mode</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>IM_DISABLE</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Disable mouse reporting.</FONT></TD></TR>

<TR><TH></TH><TD><B>IM_RELATIVE</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Enable relative mouse reporting mode. Packets report offsets from the previous mouse position. In this mode, <I>param</I> is a pointer to a structure as follows:</FONT>
<PRE>
struct param
{
 BYTE topmode;
 BYTE buttons;
 BYTE xparam;
 BYTE yparam;
}<I><FONT SIZE=2>topmode</FONT></I> is <B>IM_YBOT</B> (0) to indicate that Y=0 means bottom of the screen. A <I>topmode</I> value of <B>IM_YTOP</B> (1) indicates that Y=0 means the top of the screen.<I><FONT SIZE=2>buttons</FONT></I> is a bit array which affect the way mouse clicks are handled. A value of <B>IM_KEYS</B> (4) causes mouse buttons to generate keycodes rather than mouse packets. A value of <B>IM_PACKETS</B> (3) causes the absolute mouse position to be reported on each button press.<I><FONT SIZE=2>xparam</FONT></I> and <I>yparam</I> specify the number of mouse X/Y increments between position report packets.<FONT SIZE=2>This mode is the default mode of the <B>AES</B> and <B>VDI</B>.</FONT>
</PRE>

</TD></TR>

<TR><TH></TH><TD><B>IM_ABSOLUTE</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Enable absolute mouse reporting mode. Packets report actual screen positions. In this mode, <I>param</I> is a pointer to a structure as follows:</FONT>
<PRE>
struct param
{
 BYTE topmode;
 BYTE buttons;
 BYTE xparam;
 BYTE yparam;
 WORD xmax;
 WORD ymax;
 WORD xinitial;
 WORD yinitial;
}<I><FONT SIZE=2>topmode, buttons, xparam, </FONT></I>and<I> yparam</I> are the same as for mode 2.<I><FONT SIZE=2>xmax</FONT></I> and <I>ymax</I> specify the maximum X and Y positions the mouse should be allowed to move to. <I>xinital</I> and <I>yinitial</I> specify the mouse's initial location.
</PRE>

</TD></TR>

<TR><TH></TH><TD>
<CENTER>
-
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Unused</FONT></TD></TR>

<TR><TH></TH><TD><B>IM_KEYCODE</B></TD><TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Enable mouse keycode mode. Keyboard codes for mouse movements are sent rather than actual mouse packets.</FONT><I>param</I> is handled the same as in mode 1.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
pea   hand
pea   param
move.w   mode,-(sp)
clr.w   -(sp)
trap   #14
lea   12(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=3>Changing the mouse packet handler to anything but relative mode will cause the <B>AES</B> and <B>VDI</B> to stop receiving mouse input.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>Kbdvbase()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<a name=iorecstr><H3>Iorec()</H3>

<P>
<B>IOREC *Iorec( <I>dev</I> )</B>
<P>
<B>WORD <I>dev</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>Iorec()</B> returns the address in memory of system data structures relating to the buffering of input data.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>14 (0x0E)</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>All <B>TOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=5><I>dev</I> specifies the device to return information about as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >dev</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD><B>IO_SERIAL</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Currently mapped serial device (see <B>Bconmap()</B> )</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>IO_KEYBOARD</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Keyboard</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>IO_MIDI</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>MIDI</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
move.w   dev,-(sp)
move.w   #$0E,-(sp)
trap   #14
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=5><B>Iorec()</B> returns the address of an <B>IOREC</B> array with either one element (Keyboard or MIDI) or two elements (RS-232 - 1st = input, 2nd = output). The <B>IOREC</B> structure is defined as follows:
<PRE>
typedef struct
{
<FONT SIZE=2> /* start of buffer */
char *ibuf;

</FONT> /* size of buffer */
<FONT SIZE=2> WORD ibufsize;

</FONT> /* head index mark of buffer */
<FONT SIZE=2> WORD ibufhd;

</FONT> /* tail index mark of buffer */
<FONT SIZE=2> WORD ibuftl;

</FONT> /* low-water mark of buffer */
<FONT SIZE=2> WORD ibuflow;

</FONT> /* high-water mark of buffer */
<FONT SIZE=2> WORD ibufhi;
</FONT>} IOREC;
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=5><B>Bconmap()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3>Jdisint()</H3>

<P>
<B>VOID Jdisint( <I>intno</I> )</B>
<P>
<B>WORD <I>intno</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Jdisint()</B> disables an MFP interrupt.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>26 (0x1A)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>TOS</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>intno</I> specifies the interrupt to disable (see <B>Mfpint()</B> for a list).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   intno,-(sp)
move.w   #$1A,-(sp)
trap   #14
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Jenabint(), Mfpint()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<a name=jenabint2><H3>Jenabint()</H3>

<P>
<B>VOID Jenabint( <I>intno</I> )</B>
<P>
<B>WORD <I>intno</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Jenabint()</B> enables an MFP interrupt.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>27 (0x1B)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>TOS</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>intno</I> specifies the interrupt to enable (see <B>Mfpint()</B> for a list).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   intno,-(sp)
move.w   #$1B,-(sp)
trap   #14
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Jdsint(), Mfpint()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3>Kbdvbase()</H3>

<P>
<B>KBDVECS *Kbdvbase( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Kbdvbase()</B> returns a pointer to a system structure containing a 'jump' table to system vector handlers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>34 (0x22)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>TOS</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$22,-(sp)
trap   #14
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Kbdvbase()</B> returns a pointer to a system structure <B>KBDVECS</B> which is defined as follows:
<PRE>
typedef struct
{
 VOID (*midivec)( UBYTE data ); /* MIDI Input */
 VOID (*vkbderr)( UBYTE data ); /* IKBD Error */
 VOID (*vmiderr)( UBYTE data ); /* MIDI Error */
 VOID (*statvec)(char *buf);  /* IKBD Status */
 VOID (*mousevec)(char *buf);  /* IKBD Mouse */
 VOID (*clockvec)(char *buf);  /* IKBD Clock */
 VOID (*joyvec)(char *buf);  /* IKBD Joystick */
 VOID (*midisys)( VOID );  /* Main MIDI Vector */
 VOID (*ikbdsys)( VOID );  /* Main IKBD Vector */
 char ikbdstate;    /* See below */
} KBDVECS;
<I>midivec</I> is called with the received data byte in d0. If an overflow error occurred on either ACIA, <I>vkbderr</I> or <I>vmiderr</I> will be called, as appropriate by <I>midisys</I> or ikbdsys with the contents of the ACIA data register in d0.<I>statvec</I>, <I>mousevec</I>, <I>clockvec</I>, and <I>joyvec</I> all are called with the address of the packet in register A0.<I>midisys</I> and <I>ikbdsys</I> are called by the MFP ACIA interrupt handler when a character is ready to be read from either the midi or keyboard ports.<I>ikbdstate</I> is set to the number of bytes remaining to be read by the <I>ikbdsys</I> handler from a multiple-byte status packet.
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>If you intercept any of these routines you should either JMP through the old handler or RTS.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Initmous()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>Kbrate()</H3>

<P>
<B>WORD Kbrate( <I>delay</I>, <I>rate</I> )</B>
<P>
<B>WORD <I>delay</I>, <I>rate</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Kbrate()</B> reads/modifies the keyboard repeat/delay rate.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>35 (0x23)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>TOS</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>delay</I> specifies the amount of time (in 50Hz ticks) before a key begins repeating. <I>rate</I> indicates the amount of time between repeats (in 50Hz ticks). A parameter of <B>KB_INQUIRE</B> (1) for either of these values leaves the value unchanged.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   rate,-(sp)
move.w   delay,-(sp)
move.w   #$23,-(sp)
trap   #14
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Kbrate()</B> returns a <B>WORD</B> with the low byte being the old value for <I>rate</I> and the high byte being the old value for <I>delay</I>.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=keytbl2><H3>Keytbl()</H3>

<P>
<B>KEYTAB *Keytbl( <I>normal</I>, <I>shift</I>, <I>caps</I> )</B>
<P>
<B>char *<I>unshift</I>, *<I>shift</I>, *<I>caps</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Keytbl()</B> reads/modifies the internal keyboard mapping tables. 
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>16 (0x10)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>TOS</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>normal</I> is a pointer to an array of 128 <B>CHAR</B>s which can be indexed by a keyboard scancode to return the correct ASCII value for a given unshifted key. <I>shift</I> and <I>caps</I> point to similar array except their values are only utilized when shift and caps-lock respectively are used. Passing a value of <B>KT_NOCHANGE</B> ((char *)-1) will leave the table unchanged.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   caps
pea   shift
pea   normal
move.w   #$10,-(sp)
trap   #14
lea   14(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Keytbl()</B> returns a pointer to a <B>KEYTAB</B> structure defined as follows:
<PRE>
typedef struct
{
 char *unshift;
 char *shift;
 char *caps;
} KEYTAB;The entries in this table each point to the current keyboard lookup table in their category.Entries are indexed with a keyboard scancode to obtain the ASCII value of a key. A value of 0 indicates that no ASCII equivalent exists.
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Bioskeys()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>Locksnd()</H3>

<P>
<B>LONG Locksnd( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Locksnd()</B> prevents other applications from simultaneously attempting to use the sound system.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>128 (0x80)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available if the '_SND' cookie has bit 2 set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$80,-(sp)
trap   #14
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Locksnd()</B> returns 1 if the sound system was successfully locked or <B>SNDLOCKED</B> (-129) if the sound system was already locked.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call should be used prior to any usage of the 16-bit DMA sound system.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Unlocksnd()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>Logbase()</H3>

<P>
<B>VOIDP Logbase( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Logbase()</B> returns a pointer to the base of the logical screen.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>3 (0x03)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>TOS</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$03,-(sp)
trap   #14
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Logbase()</B> returns a pointer to the base of the logical screen.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The logical screen should not be confused with the physical screen. The logical screen is the memory area where the <B>VDI</B> does any drawing. The physical screen is the memory area where the video shifter gets its data from. Normally they are the same; however, keeping the addresses separate facilitates screen flipping.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Physbase()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>Metainit()</H3>

<P>
<B>VOID Metainit( <I>metainfo</I> )</B>
<P>
<B>METAINFO *<I>metainfo</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Metainit()</B> returns information regarding the current version and installed drives of <B>MetaDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>48 (0x30)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>To test for the availability of <B>MetaDOS</B> the following steps must be taken:1. Fill the <B>METAINFO</B> structure with all zeros.
<P>
2. Call <B>Metainit()</B>.
<P>
3. If <I>metainfo.version</I> is <B>NULL</B>, <B>MetaDOS</B> is not installed.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>metainfo</I> is a pointer to a <B>METAINFO</B> structure which is filled in by the call. <B>METAINFO</B> is defined as:
<PRE>
typedef struct
{
 /* Bitmap of drives (Bit 0 = A, 1 = B, etc... */
 ULONG drivemap;

 /* String containing name and version */
 char *version;

 /* Currently unused */
 LONG reserved[2];
} METAINFO;
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   metainfo
move.w   #$30,-(sp)
trap   #14
addq.l   #6,sp
</PRE>

</TD></TR>

</TABLE>

<P>

<HR>

<a name=mfpint><a name=mfpint2><H3>Mfpint()</H3>

<P>
<B>VOID Mfpint( <I>intno</I>, <I>vector</I> )</B>
<P>
<B>WORD <I>intno</I>;</B>
<P>
<B>VOID (*<I>vector</I>)();</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>Mfpint()</B> defines an interrupt handler for an MFP interrupt.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>13 (0x0D)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>All <B>TOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>intno</I> is an index to a vector to replace with <I>vector</I> as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >intno</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Vector</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>MFP_PARALLEL</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Parallel port</FONT></TD></TR>

<TR><TH></TH><TD><B>MFP_DCD</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>RS-232 Data Carrier Detect</FONT></TD></TR>

<TR><TH></TH><TD><B>MFP_CTS</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>RS-232 Clear To Send</FONT></TD></TR>

<TR><TH></TH><TD><B>MFP_BITBLT</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>BitBlt Complete </FONT></TD></TR>

<TR><TH></TH><TD><B>MFP_TIMERD </B>or
<P>
<B>MFP_BAUDRATE</B>
</TD><TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>
</TD><TD><FONT SIZE=2>Timer D (RS-232 baud rate generator)</FONT>
</TD></TR>

<TR><TH></TH><TD><B>MFP_200HZ</B></TD><TD>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Timer C (200Hz system clock)</FONT></TD>
</TR>

<TR><TH></TH><TD><B>MFP_ACIA</B></TD><TD>
<CENTER>
<FONT SIZE=2>6</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Keyboard/MIDI vector</FONT></TD></TR>

<TR><TH></TH><TD><B>MFP_DISK</B></TD><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Floppy/Hard disk vector</FONT></TD></TR>

<TR><TH></TH><TD><B>MFP_TIMERB </B>or
<P>
<B>MFP_HBLANK</B>
</TD><TD>
<CENTER>
<FONT SIZE=2>8</FONT>
</CENTER>
</TD><TD><FONT SIZE=2>Timer B (Horizontal blank)</FONT>
</TD></TR>

<TR><TH></TH><TD><B>MFP_TERR</B></TD><TD>
<CENTER>
<FONT SIZE=2>9</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>RS-232 transmit error</FONT></TD></TR>

<TR><TH></TH><TD><B>MFP_TBE</B></TD><TD>
<CENTER>
<FONT SIZE=2>10</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>RS-232 transmit buffer empty</FONT></TD>
</TR>

<TR><TH></TH><TD><B>MFP_RERR</B></TD><TD>
<CENTER>
<FONT SIZE=2>11</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>RS-232 receive error</FONT></TD></TR>

<TR><TH></TH><TD><B>MFP_RBF</B></TD><TD>
<CENTER>
<FONT SIZE=2>12</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>RS-232 receive buffer full.</FONT></TD>
</TR>

<TR><TH></TH><TD><B>MFP_TIMERA </B>or
<P>
<B>MFP_DMASOUND</B>
</TD><TD>
<CENTER>
<FONT SIZE=2>13</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2>Timer A (DMA sound)</FONT></TD></TR>

<TR><TH></TH><TD><B>MFP_RING</B></TD><TD>
<CENTER>
<FONT SIZE=2>14</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>RS-232 ring indicator</FONT></TD></TR>

<TR><TH></TH><TD><B>MFP_MONODETECT</B></TD><TD>
<CENTER>
<FONT SIZE=2>15</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Mono monitor detect/DMA sound complete</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
pea   vector
move.w   intno,-(sp)
move.w   #$0D,-(sp)
trap   #14
addq.l   #8,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=3>This call does not return the address of the old handler.The only RS-232 vector that may be set on the Falcon030 with this function is the ring indicator.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=3>Newly installed interrupts must be enabled with <B>Jenabint()</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>Jenabint(), Jdisint()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Midiws()</H3>

<P>
<B>VOID Midiws( <I>count</I>, <I>buf</I> )</B>
<P>
<B>WORD <I>count</I>;</B>
<P>
<B>char *<I>buf</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Midiws()</B> outputs a data buffer to the MIDI port.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>12 (0x0C)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>TOS</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>count</I> + 1 characters are written from the buffer pointed to by <I>buf</I>. 
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   buf
move.w   count,-(sp)
move.w   #$0C,-(sp)
trap   #14
addq.l   #8,sp
</PRE>

</TD></TR>

</TABLE>

<P>

<HR>

<H3>NVMaccess()</H3>

<P>
<B>WORD NVMaccess( <I>op</I>, <I>start</I>, <I>count</I>, <I>buffer</I>
)</B>
<P>
<B>WORD <I>op</I>, <I>start</I>, <I>count</I>;</B>
<P>
<B>char *<I>buffer</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>NVMaccess()</B> reads/modifies data in non-volatile (battery backed-up) memory.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>46 (0x2E)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>This function's availability is variable. If it returns 0x2E (its opcode) when called, the function is non-existent and the operation was not carried out.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>op</I> indicates the operation to perform as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >op</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>NVM_READ</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Read <I>count</I> bytes of data starting at offset <I>start</I> and place the data in <I>buffer</I>.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>NVM_WRITE</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Write <I>count</I> bytes of data from <I>buffer</I> starting at offset <I>start</I>.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>NVM_RESET</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Resets and clears all data in non-volatile memory.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
pea   buffer
move.w   count,-(sp)
move.w   start,-(sp)
move.w   op,-(sp)
move.w   #$2E,-(sp)
trap   #14
lea   12(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3><B>NVMaccess()</B> returns 0 if the operation succeeded or a negative error code otherwise.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=3>All of the locations are reserved for use by Atari and none are currently documented.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=3>Currently there is a total of 50 bytes in non-volatile RAM.
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Offgibit()</H3>

<P>
<B>VOID Offgibit( <I>mask</I> )</B>
<P>
<B>WORD <I>mask</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>Offgibit()</B> clears individual bits of the sound chip's Port A.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>29 (0x1D)</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>All <B>TOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=5><I>mask</I> is a bit mask arranged as shown below. For each of the lower eight bits in <I>mask</I> set to 0, that bit will be reset. Other bits (set as 1) will remain unchanged. 
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Mask</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD><B>GI_FLOPPYSIDE</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x01</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Floppy side select</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>GI_FLOPPYA</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x02</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Floppy A select</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>GI_FLOPPYB</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x04</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Floppy B select</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>GI_RTS</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x08</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>RS-232 Request To Send</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>GI_DTR</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x10</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>RS-232 Data Terminal Ready</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>GI_STROBE</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x20</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Centronics strobe</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>GI_GPO</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x40</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>General purpose output (On a Falcon030, this bit controls the state of the internal speaker)</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>GI_SCCPORT</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x80</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>On a Mega STe or TT030, calling <B>Ongibit(&nbsp;</B>0x80&nbsp;<B>)</B> will cause SCC channel A to control the Serial 2 port rather than the LAN. To select the LAN, use <B>Offgibit( </B>0x7F<B> )</B>.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
move.w   mask,-(sp)
move.w   #$1D,-(sp)
trap   #14
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=5><B>Giaccess(), Ongibit()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Ongibit()</H3>

<P>
<B>VOID Ongibit( <I>mask</I> )</B>
<P>
<B>WORD <I>mask</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Ongibit()</B> sets individual bits of the sound chip's assigned Port A.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>30 (0x1E)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>TOS</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>mask</I> is a bit mask arranged as defined in <B>Offgibit()</B>. For each of the lower eight bits in <I>mask</I> set to 1, that bit will be set. Other bits (set as 0) will remain unchanged. 
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   mask,-(sp)
move.w   #$1E,-(sp)
trap   #14
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Giaccess(), Offgibit()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Physbase()</H3>

<P>
<B>VOIDP Physbase( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Physbase()</B> returns the address of the physical base of screen memory.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>2 (0x02)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>TOS</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$02,-(sp)
trap   #14
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Physbase()</B> returns the physical base address of the screen.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The physical base address is the memory area where the video shifter reads its data. The logical address is the memory area where the <B>VDI</B> draws. These are normally the same but are addressed individually to enable screen flipping.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Logbase()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>Protobt()</H3>

<P>
<B>VOID Protobt( <I>buf</I>, <I>serial</I>, <I>type</I>, <I>execflag</I>
)</B>
<P>
<B>VOIDP <I>buf</I>;</B>
<P>
<B>LONG <I>serial</I>;</B>
<P>
<B>WORD <I>type</I>, <I>execflag</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=9><B>Protobt()</B> creates a prototype floppy boot sector in memory for writing to a floppy drive.
</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=9>18 (0x12)</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=9>All <B>TOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=9><I>buf</I> is a 512 byte long buffer where the prototyped buffer will be written. If you are creating an executable boot sector, the memory buffer should contain the code you require. <I>serial</I> can be any of the following values: 
</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH></TH><TD COLSPAN=2><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD COLSPAN=3>
<CENTER>
<I><B><FONT SIZE=2 >serial</FONT></B></I>
</CENTER>

</TD><TD COLSPAN=4><B><FONT SIZE=2 >Meaning</FONT></B>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>SERIAL_NOCHANGE</B></TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>-1</FONT>
</CENTER>

</TD><TD COLSPAN=4><FONT SIZE=2>Don't change the serial number already in memory.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>SERIAL_RANDOM</B></TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>&gt;0x01000000</FONT>
</CENTER>

</TD><TD COLSPAN=4><FONT SIZE=2>Use a random number for the serial number</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
-
</CENTER>
</TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>any other positive number</FONT>
</CENTER>

</TD><TD COLSPAN=4><FONT SIZE=2>Set the serial number to <I>serial</I>.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH></TH><TD COLSPAN=9><I>type</I> defines the type of disk to prototype as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD COLSPAN=3>
<CENTER>
<I><B><FONT SIZE=2 >type</FONT></B></I>
</CENTER>

</TD><TD COLSPAN=2><B><FONT SIZE=2 >Meaning</FONT></B>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2><B>DISK_NOCHANGE</B></TD>
<TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>-1</FONT>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Don't change disk type.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2><B>DISK_SSSD</B></TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>40 Track, Single-Sided (180K)</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2><B>DISK_DSSD</B></TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>40 Track, Double-Sided (360K)</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2><B>DISK_SSDD</B></TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>80 Track, Single-Sided (360K)</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2><B>DISK_DSDD</B></TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>80 Track, Double-Sided (720K)</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2><B>DISK_DSHD</B></TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>High Density (1.44MB)</FONT></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2><B>DISK_DSED</B></TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>

</TD><TD COLSPAN=2><FONT SIZE=2>Extra-High Density (2.88MB)</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH></TH><TD COLSPAN=9><I>execflag</I> specifies the executable status of the boot sector as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=3><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD COLSPAN=3>
<CENTER>
<I><B><FONT SIZE=2 >execflag</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=3><B>EXEC_NOCHANGE</B></TD>
<TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>-1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Don't alter executable status</FONT></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=3><B>EXEC_NO</B></TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Disk is not executable</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=3><B>EXEC_YES</B></TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Disk is executable</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=9>
<PRE>
move.w   execflag,-(sp)
move.w   type,-(sp)
move.l   serial,-(sp)
pea   buf
move.w   #$12,-(sp)
trap   #14
lea   14(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=9><I>type</I> values of <B>DISK_DSHD</B> and <B>DISK_DSED</B> are only available when the high byte of the '_FDC' cookie has a value of <B>FLOPPY_DSHD</B> (1) and <B>FLOPPY_DSED</B> (2) respectively.
</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=9>To create an MS-DOS compatible disk you must set the first three bytes of the prototyped boot sector to 0xE9, 0x00, and 0x4E.
</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=9><B>Flopfmt(), Flopwr()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Prtblk()</H3>

<P>
<B>WORD Prtblk( <I>blk</I> )</B>
<P>
<B>PRTBLK *<I>blk</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Prtblk()</B> accesses the built-in bitmap/text printing code.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>36 (0x24)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>TOS</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>blk</I> is a <B>PRTBLK</B> pointer containing information about the bitmap or text to print. <B>PRTBLK</B> is defined as follows:
<PRE>
typedef struct
{
 VOIDP blkptr;  /* pointer to screen scanline */
 UWORD offset;  /* bit offset of first column */
 UWORD width;  /* width of bitmap in bits */
 UWORD height;  /* height of bitmap in scanlines */
 UWORD left;  /* left print margin (in pixels) */
 UWORD right;  /* right print margin (in pixels) */
 UWORD srcres;  /* same as Getrez() */
 UWORD destres;  /* 0 = draft, 1 = final */
 UWORD *colpal;  /* color palette pointer */
 /*
  * 0 = B/W Atari
  * 1 = Color Atari
  * 2 = Daisy Wheel
  * 3 = B/W Epson
  */
 UWORD type;
 /* 0 = parallel, 1 = serial */
 UWORD port;
 /* halftone mask pointer or NULL to use default */
 char *masks;
} PRTBLK;
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   prtblk
move.w   #$24,-(sp)
trap   #14
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>This call is extremely device dependent. <B>v_bit_image()</B> with <B>GDOS</B> installed should be used instead. Only ST compatible screen resolution bitmaps may be printed with this utility function.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>When printing text, <I>blkptr</I> should point to the text string, <I>width</I> should be the length of the text string, <I>height</I> should be 0, and <I>masks</I> should be <B>NULL</B>. In graphic print mode, <I>masks</I> can be <B>NULL</B> to use the default halftone masks.The system variable <I>_prt_cnt</I> (<B>WORD</B> *)0x4EE should be set to 1 to disable the alt-help key before calling this function. It should be restored to a value of -1 when done.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Scrdump(), SetPrt()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3>Puntaes()</H3>

<P>
<B>VOID Puntaes( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Puntaes()</B> discards the <B>AES</B> (if memory-resident) and restarts the system.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>39 (0x27)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>TOS</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$27,-(sp)
trap   #14
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD>If successful, this function will not return control to the caller.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD><B>Puntaes()</B> is only valid with disk-loaded AES's.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD><B>Puntaes()</B> discards the <B>AES</B> by freeing any memory it allocated, resetting the system variable <I>os_magic</I> (this variable should contain the magic number 0x87654321, however if reset, the <B>AES</B> will not initialize), and rebooting the system.
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Random()</H3>

<P>
<B>LONG Random( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Random()</B> returns a 24 bit random number.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>17 (0x11)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>TOS</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$11,-(sp)
trap   #14
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Random()</B> returns a 24-bit random value in the lower three bytes of the returned <B>LONG</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>The algorithm used provides an exact 50% occurrence of bit 0.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=rsconf2><H3>Rsconf()</H3>

<P>
<B>ULONG Rsconf( <I>speed</I>, <I>flow</I>, <I>ucr</I>, <I>rsr</I>,
<I>tsr</I>, <I>scr</I> )</B>
<P>
<B>WORD <I>speed</I>, <I>flow</I>, <I>ucr</I>, <I>rsr</I>, <I>tsr</I>,
<I>scr</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=13><B>Rsconf()</B> reads/modifies the configuration of the serial device currently mapped to <B>BIOS</B> device #1 (<B>GEMDOS</B> 'aux:').
</TD></TR>

<TR><TH></TH><TD COLSPAN=13></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=13>15 (0x0F)</TD></TR>

<TR><TH></TH><TD COLSPAN=13></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=13>All <B>TOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=13></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=13><I>speed</I> sets the serial device speed as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=13></TD></TR>

<TR><TH></TH><TD COLSPAN=3><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD COLSPAN=2>
<CENTER>
<I><B><FONT SIZE=2 >speed</FONT></B></I>
</CENTER>

</TD><TD COLSPAN=2>
<CENTER>
<B><FONT SIZE=2 >Baud Rate</FONT></B>
</CENTER>

</TD><TD></TD><TD COLSPAN=2><B><FONT SIZE=2 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >speed</FONT></B></I>
</CENTER>

</TD><TD COLSPAN=2>
<CENTER>
<B><FONT SIZE=2 >Baud Rate</FONT></B>
</CENTER>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3><B>BAUD_19200</B></TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>19200</FONT>
</CENTER>

</TD><TD></TD><TD COLSPAN=2><B><FONT SIZE=2>BAUD_600</FONT></B>
</TD><TD>
<CENTER>
<FONT SIZE=2>8</FONT>
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>600</FONT>
</CENTER>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3><B>BAUD_9600</B></TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>9600</FONT>
</CENTER>

</TD><TD></TD><TD COLSPAN=2><B><FONT SIZE=2>BAUD_300</FONT></B>
</TD><TD>
<CENTER>
<FONT SIZE=2>9</FONT>
</CENTER>
</TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>300</FONT>
</CENTER>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3><B>BAUD_4800</B></TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>4800</FONT>
</CENTER>

</TD><TD></TD><TD COLSPAN=2><B><FONT SIZE=2>BAUD_200</FONT></B>
</TD><TD>
<CENTER>
<FONT SIZE=2>10</FONT>
</CENTER>
</TD>
<TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>200</FONT>
</CENTER>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3><B>BAUD_3600</B></TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>3600</FONT>
</CENTER>

</TD><TD></TD><TD COLSPAN=2><B><FONT SIZE=2>BAUD_150</FONT></B>
</TD><TD>
<CENTER>
<FONT SIZE=2>11</FONT>
</CENTER>
</TD>
<TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>150</FONT>
</CENTER>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3><B>BAUD_2400</B></TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

</TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>2400</FONT>
</CENTER>

</TD><TD></TD><TD COLSPAN=2><B><FONT SIZE=2>BAUD_134</FONT></B>
</TD><TD>
<CENTER>
<FONT SIZE=2>12</FONT>
</CENTER>
</TD>
<TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>134</FONT>
</CENTER>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3><B>BAUD_2000</B></TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>

</TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>2000</FONT>
</CENTER>

</TD><TD></TD><TD COLSPAN=2><B><FONT SIZE=2>BAUD_110</FONT></B>
</TD><TD>
<CENTER>
<FONT SIZE=2>13</FONT>
</CENTER>
</TD>
<TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>110</FONT>
</CENTER>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3><B>BAUD_1800</B></TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>6</FONT>
</CENTER>

</TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>1800</FONT>
</CENTER>

</TD><TD></TD><TD COLSPAN=2><B><FONT SIZE=2>BAUD_75</FONT></B>
</TD><TD>
<CENTER>
<FONT SIZE=2>14</FONT>
</CENTER>
</TD>
<TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>75</FONT>
</CENTER>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3><B>BAUD_1200</B></TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>

</TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>1200</FONT>
</CENTER>

</TD><TD></TD><TD COLSPAN=2><B><FONT SIZE=2>BAUD_50</FONT></B>
</TD><TD>
<CENTER>
<FONT SIZE=2>15</FONT>
</CENTER>
</TD>
<TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>50</FONT>
</CENTER>

</TD></TR>

<TR><TH></TH><TD COLSPAN=13></TD></TR>

<TR><TH></TH><TD COLSPAN=13>If <I>speed</I> is set to <B>BAUD_INQUIRE</B> (-2), the last baud rate set will be returned.
<P>
<I>flow</I> selects the flow control method as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=13></TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=3><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD COLSPAN=2>
<CENTER>
<I><B><FONT SIZE=2 >flow</FONT></B></I>
</CENTER>

</TD><TD COLSPAN=6><B><FONT SIZE=2 >Meaning</FONT></B>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=3><B>FLOW_NONE</B></TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD COLSPAN=6><FONT SIZE=2>No flow control</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=3><B>FLOW_SOFT</B></TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD COLSPAN=6><FONT SIZE=2>XON/XOFF flow control (ctrl-s/ctrl-q)</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=3><B>FLOW_HARD</B></TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD COLSPAN=6><FONT SIZE=2>RTS/CTS flow control (hardware)</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=3><B>FLOW_BOTH</B></TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD COLSPAN=6><FONT SIZE=2>Both methods of flow control</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=13></TD></TR>

<TR><TH></TH><TD COLSPAN=13><I>ucr</I>, <I>rsr</I>, and <I>tsr</I> are each status bit arrays governing the serial devices. Each parameter uses only the lower eight bits of the <B>WORD</B>. They are defined as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=13></TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
<B><FONT SIZE=1 >Mask</FONT></B>
</CENTER>

</TD><TD COLSPAN=7><I><B><FONT SIZE=2 >ucr</FONT></B></I>
</TD><TD COLSPAN=4><I><B><FONT SIZE=2 >rsr </FONT></B></I><B><FONT SIZE=2 >and<I><B> tsr</B></I></FONT></B>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
0x01
</CENTER>
</TD>
<TD COLSPAN=7><FONT SIZE=2>Unused</FONT></TD><TD COLSPAN=4><FONT SIZE=2>Receiver enable:</FONT>
<P>
<B><FONT SIZE=2>RS_RECVENABLE</FONT></B>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
0x02
</CENTER>
</TD>
<TD COLSPAN=7><FONT SIZE=2>Enable odd parity</FONT>
<P>
<B><FONT SIZE=2>RS_ODDPARITY</FONT></B> (0x02)
<P>
<B><FONT SIZE=2>RS_EVENPARITY</FONT></B> (0x00)
</TD><TD COLSPAN=4><FONT SIZE=2>Sync strip</FONT>
<P>
<B><FONT SIZE=2>RS_SYNCSTRIP</FONT></B>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
0x04
</CENTER>
</TD>
<TD COLSPAN=7><FONT SIZE=2>Parity enable</FONT>
<P>
<B><FONT SIZE=2>RS_PARITYENABLE</FONT></B>
</TD><TD COLSPAN=4><FONT SIZE=2>Match busy</FONT>
<P>
<B><FONT SIZE=2>RS_MATCHBUSY</FONT></B>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
0x08
</CENTER>
</TD>
<TD COLSPAN=7><FONT SIZE=2>Bits 3-4 of the ucr collectively define the start and stop bit configuration as follows:</FONT>00 = No Start or Stop bits
<P>
<B><FONT SIZE=2>RS_NOSTOP</FONT></B> (0x00)
<P>
<FONT SIZE=2>01 = 1 Start bit, 1 Stop bit</FONT>
<P>
<B><FONT SIZE=2>RS_1STOP</FONT></B> (0x08)
<P>
<FONT SIZE=2>10 = 1 Start bit, 1&#189; Stop bits</FONT>
<P>
<B><FONT SIZE=2>RS_15STOP</FONT></B> (0x10)
<P>
<FONT SIZE=2>11 = 1 Start bit, 2 Stop bits</FONT>
<P>
<B><FONT SIZE=2>RS_2STOP</FONT></B> (0x18)
</TD><TD COLSPAN=4><FONT SIZE=2>Break detect</FONT>
<P>
<B><FONT SIZE=2>RS_BRKDETECT</FONT></B>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
0x10
</CENTER>
</TD>
<TD COLSPAN=7><FONT SIZE=2>See above.</FONT></TD><TD COLSPAN=4><FONT SIZE=2>Frame error</FONT>
<P>
<B><FONT SIZE=2>RS_FRAMEERR</FONT></B>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
0x20
</CENTER>
</TD>
<TD COLSPAN=7><FONT SIZE=2>Bits 5 and 6 together define the number of bits per word as follows:</FONT>00 = 8 bits
<P>
<B><FONT SIZE=2>RS_8BITS </FONT></B>(0x00)
<P>
<FONT SIZE=2>01 = 7 bits</FONT>
<P>
<B><FONT SIZE=2>RS_7BITS</FONT></B> (0x20)
<P>
<FONT SIZE=2>10 = 6 bits</FONT>
<P>
<B><FONT SIZE=2>RS_6BITS </FONT></B>(0x40)
<P>
<FONT SIZE=2>11 = 5 bits</FONT>
<P>
<B><FONT SIZE=2>RS_5BITS</FONT></B> (0x60)
</TD><TD COLSPAN=4><FONT SIZE=2>Parity error</FONT>
<P>
<B><FONT SIZE=2>RS_PARITYERR</FONT></B>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
0x40
</CENTER>
</TD>
<TD COLSPAN=7><FONT SIZE=2>See above.</FONT></TD><TD COLSPAN=4><FONT SIZE=2>Overrun error</FONT>
<P>
<B><FONT SIZE=2>RS_OVERRUNERR</FONT></B>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
0x80
</CENTER>
</TD>
<TD COLSPAN=7><FONT SIZE=2>CLK/16</FONT>
<P>
<B><FONT SIZE=2>RS_CLK16</FONT></B>
</TD><TD COLSPAN=4><FONT SIZE=2>Buffer full</FONT>
<P>
<B><FONT SIZE=2>RS_BUFFULL</FONT></B>
</TD></TR>

<TR><TH></TH><TD COLSPAN=13></TD></TR>

<TR><TH></TH><TD COLSPAN=13><I>scr</I> sets the synchronous character register in which the low byte is used as the character to search for in an underrun error condition.If a <B>RS_INQUIRE</B> (-1) is used for either <I>ucr</I>, <I>rsr</I>, <I>tsr</I>, or <I>scr</I>, then that parameter is read and the register is unmodified.
</TD></TR>

<TR><TH></TH><TD COLSPAN=13></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=13>
<PRE>
move.w   scr,-(sp)
move.w   tsr,-(sp)
move.w   rsr,-(sp)
move.w   ucr,-(sp)
move.w   flow,-(sp)
move.w   speed,-(sp)
move.w   #$0F,-(sp)
trap   #14
lea   14(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=13></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=13><B>Rsconf()</B> returns the last set baud rate if <I>speed</I> is set to <B>RS_LASTBAUD</B> (2). Otherwise, it returns the old settings in a packed <B>LONG</B> with <I>ucr</I> being in the high byte, down to <I>scr</I> being in the low byte.
</TD></TR>

<TR><TH></TH><TD COLSPAN=13></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=13>Bits in the <I>ucr</I>, <I>rsr</I>, <I>tsr</I>, and <I>scr</I> should be set atomically. To correctly change a value, read the old value, mask it as appropriate and then write it back.Baud rates higher than 19,200 bps available with SCC-based serial devices may be set by using the appropriate <B>Fcntl()</B> call under <B>MiNT</B> or by directly programming the SCC chip.
</TD></TR>

<TR><TH></TH><TD COLSPAN=13></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=13>The baud rate inquiry mode (speed = <B>RS_LASTBAUD</B>) does not work at all on <B>TOS</B> versions less than 1.04. <B>TOS</B> version 1.04 requires the patch program TOS14FX2.PRG (available from Atari Corp.) to allow this mode to function. All other <B>TOS</B> versions support the function normally.
</TD></TR>

<TR><TH></TH><TD COLSPAN=13></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=13><B>Bconmap()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3>Scrdmp()</H3>

<P>
<B>VOID Scrdmp( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Scrdmp()</B> starts the built-in hardware screen dump routine.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>20 (0x14)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>TOS</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$14,-(sp)
trap   #14
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD><B>Scrdmp()</B> only dumps ST compatible screen resolutions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This routine is extremely device-dependent. You should use the <B>VDI</B> instead.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Prtblk(), v_hardcopy()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Setbuffer()</H3>

<P>
<B>LONG Setbuffer( <I>mode</I>, <I>begaddr</I>, <I>endaddr</I>
)</B>
<P>
<B>WORD <I>mode</I>;</B>
<P>
<B>VOIDP <I>begaddr</I>;</B>
<P>
<B>VOIDP <I>endaddr</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Setbuffer()</B> sets the starting and ending addresses of the internal play and record buffers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>131 (0x83)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available when bit #2 of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>mode</I> specifies which registers are to be set. A <I>mode</I> value of <B>PLAY</B> (0) sets the play registers, a value of <B>RECORD</B> (1) sets the record registers. <I>begaddr</I> specifies the starting location of the buffer. <I>endaddr</I> specifies the first invalid location for sound data past <I>begaddr</I>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   endaddr
pea   begaddr
move.w   mode,-(sp)
move.w   #$83,-(sp)
trap   #14
lea   12(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Setbuffer()</B> returns a 0 if successful or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Buffoper()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>Setcolor()</H3>

<P>
<B>WORD Setcolor( <I>idx</I>, <I>new</I> )</B>
<P>
<B>WORD <I>idx</I>, <I>new</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=6><B>Setcolor()</B> sets a ST/TT030 color register.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=6>7 (0x07)</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=6>All <B>TOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=6><I>idx</I> specifies the color register to modify (0-16 on an ST, 0-255 on a STe or TT030). <I>new</I> is a bit array specifying the new color as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
<B><FONT SIZE=1 >Bits 15-12</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bits 11-8</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bits 7-4</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bits 3-0</FONT></B>
</CENTER>

</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
Unused
</CENTER>
</TD>
<TD>
<CENTER>
<FONT SIZE=2>Red</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>Green</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>Blue</FONT>
</CENTER>
</TD>
</TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH></TH><TD COLSPAN=6>Each color value has its bits packed in an unusual manner to stay compatible between machines. Bits are ordered 0, 3, 2, 1 with 0 being the least signifigant bit. If <I>new</I> is <B>COL_INQUIRE</B> (-1) then the old color is returned.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=6>
<PRE>
move.w   new,-(sp)
move.w   idx,-(sp)
move.w   #$06,-(sp)
trap   #14
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=6><B>Setcolor()</B> returns the old value of the color register.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=6>This call is extremely device-dependent. <B>vs_color()</B> should be used instead.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=6>The top bit of each color nibble is unused on the original ST machines.
</TD></TR>

<TR><TH></TH><TD COLSPAN=6></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=6><B>VsetRGB(), EsetColor(), Setpalette()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Setinterrupt()</H3>

<P>
<B>LONG Setinterrupt( <I>mode</I>, <I>cause</I> )</B>
<P>
<B>WORD <I>mode</I>, <I>cause</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>Setinterrupt()</B> defines the conditions under which an interrupt is generated by the sound system
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>135 (0x87)</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>Available when bit #2 of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=5><I>mode</I> configures interrupts to occur when the end of a buffer is reached. A value of <B>INT_TIMERA</B> (0) for <I>mode</I> sets Timer A, a value of <B>INT_I7</B> (1) sets the MFP i7 interrupt. <I>cause</I> defines the conditions for the interrupt as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >cause</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD><B>INT_DISABLE</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Disable interrupt</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>INT_PLAY</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Interrupt at end of play buffer</FONT></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD><B>INT_RECORD</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Interrupt at end of record buffer</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>INT_BOTH</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Interrupt at end of both buffers</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
move.w   cause,-(sp)
move.w   mode,-(sp)
move.w   #$87,-(sp)
trap   #14
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=5><B>Setinterrupt()</B> returns 0 if no error occurred or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=5>If either buffer is in repeat mode, these interrupts can be used to double-buffer sounds.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=5><B>Buffoper()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3>Setmode()</H3>

<P>
<B>LONG Setmode( <I>mode</I> )</B>
<P>
<B>WORD <I>mode</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>Setmode()</B> sets the mode of operation for the play and record registers.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>132 (0x84)</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>Available if bit #2 of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=5><I>mode</I> defines the playback and record mode as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >mode</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD><B>MODE_STEREO8</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>8-bit Stereo Mode</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>MODE_STEREO16</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>16-bit Stereo Mode</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>MODE_MONO</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>8-bit Mono Mode</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
move.w   mode,-(sp)
move.w   #$84,sp
trap   #14
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=5><B>Setmode()</B> returns 0 if the operation was successful or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=5>Recording only works in 16-bit stereo mode.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=5><B>Buffoper()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3>Setmontracks()</H3>

<P>
<B>LONG Setmontracks( <I>track</I> )</B>
<P>
<B>WORD <I>track</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Setmontracks()</B> defines which playback track is audible through the internal speaker.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>134 (0x86)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available only when bit #2 of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>track</I> specifies the playback track to monitor (0-3).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   track,-(sp)
move.w   #$86,-(sp)
trap   #14
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Setmontracks()</B> returns a 0 if the operation was successful or non-zero otherwise.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=setpalette><H3>Setpalette()</H3>

<P>
<B>VOID Setpalette( <I>palette</I> )</B>
<P>
<B>WORD *<I>palette</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Setpalette()</B> loads the ST color lookup table with a new palette.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>6 (0x06)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>TOS</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>palette</I> is a pointer to a <B>WORD</B> array containing 16 color encoded <B>WORD</B>s as defined in <B>Setcolor()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   palette
move.w   #$06,-(sp)
trap   #14
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The actual palette data is not copied from the specified array until the next vertical blank interrupt. For this reason, this call should be followed by <B>Vsync()</B> to be sure the array memory is not modified or reallocated prior to the transfer.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Setcolor(), EsetPalette(), VsetRGB(), vs_color()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Setprt()</H3>

<P>
<B>WORD Setprt( <I>new</I> )</B>
<P>
<B>WORD <I>new</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>Setprt()</B> sets the OS's current printer configuration bits.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>33 (0x21)</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>All <B>TOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=5><I>new</I> is a <B>WORD</B> bit array defined as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
<B><FONT SIZE=1 >Mask</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >When clear</FONT></B></TD>
<TD><B><FONT SIZE=2 >When Set</FONT></B></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0x01
</CENTER>
</TD>
<TD><FONT SIZE=2>Dot Matrix</FONT>
<P>
<B><FONT SIZE=2>PRT_DOTMATRIX</FONT></B>
</TD><TD><FONT SIZE=2>Daisy Wheel</FONT>
<P>
<B><FONT SIZE=2>PRT_DAISY</FONT></B>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0x02
</CENTER>
</TD>
<TD><FONT SIZE=2>Monochrome</FONT>
<P>
<B><FONT SIZE=2>PRT_MONO</FONT></B>
</TD><TD><FONT SIZE=2>Color</FONT>
<P>
<B><FONT SIZE=2>PRT_COLOR</FONT></B>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0x04
</CENTER>
</TD>
<TD><FONT SIZE=2>Atari Printer</FONT>
<P>
<B><FONT SIZE=2>PRT_ATARI</FONT></B>
</TD><TD><FONT SIZE=2><a name=epsonprinter>Epson Printer</FONT>
<P>
<B><FONT SIZE=2>PRT_EPSON</FONT></B>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0x08
</CENTER>
</TD>
<TD><FONT SIZE=2>Draft Mode</FONT>
<P>
<B><FONT SIZE=2>PRT_DRAFT</FONT></B>
</TD><TD><FONT SIZE=2>Final Mode</FONT>
<P>
<B><FONT SIZE=2>PRT_FINAL</FONT></B>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0x10
</CENTER>
</TD>
<TD><FONT SIZE=2>Parallel Port</FONT>
<P>
<B><FONT SIZE=2>PRT_PARALLEL</FONT></B>
</TD><TD><FONT SIZE=2>Serial Port</FONT>
<P>
<B><FONT SIZE=2>PRT_SERIAL</FONT></B>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0x20
</CENTER>
</TD>
<TD><FONT SIZE=2>Continuous Feed</FONT>
<P>
<B><FONT SIZE=2>PRT_CONTINUOUS</FONT></B>
</TD><TD><FONT SIZE=2>Single Sheet Feed</FONT>
<P>
<B><FONT SIZE=2>PRT_SINGLE</FONT></B>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
-
</CENTER>
</TD><TD><FONT SIZE=2>Unused</FONT>
</TD><TD><FONT SIZE=2>Unused</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH></TH><TD COLSPAN=5>If <I>new</I> is set to <B>PRT_INQUIRE</B> (1) <B>Setprt()</B> will return the current configuration without modifying the current setup.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
move.w   new,-(sp)
move.w   #$33,-(sp)
trap   #14
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=5><B>Setprt()</B> returns the prior configuration.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=5>This call only affects the internal<a name=ahsd> screen dump code which only operates on ST compatible resolutions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=5><B>Prtblk(), Scrdmp(), v_hardcopy()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=setscreen2><H3>Setscreen()</H3>

<P>
<B>VOID Setscreen( <I>log</I>, <I>phys</I>, <I>mode</I> )</B>
<P>
<B>VOIDP <I>log</I>, <I>phys</I>;</B>
<P>
<B>WORD <I>mode</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Setscreen()</B> changes the base addresses and mode of the current screen.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5 (0x05)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>TOS</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>log</I> is the address for the new logical screen base. <I>phys</I> is the new address for the physical screen base. <I>mode</I> defines the screen mode to switch to (same as <B>Getrez()</B>). If any of these three parameters is set to <B>SCR_NOCHANGE</B> (1) then that value will be left unchanged.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   mode,-(sp)
pea   phys
pea   log
move.w   #$5,-(sp)
trap   #14
lea   12(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>Changing screen modes with this call does not reinitialize the <B>AES</B>. The <B>VDI</B> and <B>VT52</B> emulator are, however, correctly reinitialized. The <B>AES</B> should not be used after changing screen mode with this call until the old screen mode is restored. 
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The Atari ST and Mega ST required that its physical screen memory be on a 256 byte boundary. All other Atari computers only require a <B>WORD</B> boundary.To access the unique video modes of the Falcon030 the call <B>VsetScreen()</B> (which is actually an alternate binding of this call with the same opcode) should be used in place of this call.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>VsetMode(), VsetScreen(), EsetShift()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Settime()</H3>

<P>
<B>VOID Settime( <I>time</I> )</B>
<P>
<B>LONG <I>time</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=4><B>Settime()</B> sets a new <B>IKBD</B> date and time.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=4>22 (0x16)</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=4>All <B>TOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=4><I>time</I> is a <B>LONG</B> bit array defined as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
<B><FONT SIZE=1 >Bits</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0-4
</CENTER>
</TD><TD><FONT SIZE=2>Seconds / 2 (0-29)</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
5-10
</CENTER>
</TD>
<TD><FONT SIZE=2>Minute (0-59)</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
11-15
</CENTER>
</TD>
<TD><FONT SIZE=2>Hour (0-23)</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
16-20
</CENTER>
</TD>
<TD><FONT SIZE=2>Day (1-31)</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
21-24
</CENTER>
</TD>
<TD><FONT SIZE=2>Month (1-12)</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
25-31
</CENTER>
</TD>
<TD><FONT SIZE=2>Year - 1980 (0-127)</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH></TH><TD COLSPAN=4>The value can be represented in a C structure as follows:
<PRE>
typedef struct
{
 unsigned year:7;
 unsigned month:4;
 unsigned day:5;
 unsigned hour:5;
 unsigned minute:6;
 unsigned second:5;
} BIOS_TIME;
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=4>
<PRE>
move.l   time,-(sp)
move.w   #$16,-(sp)
trap   #14
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=4>As of <B>TOS</B> 1.02, this function also updates the <B>GEMDOS</B> time.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=4><B>Gettime(), Tsettime(), Tsetdate()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Settracks()</H3>

<P>
<B>LONG Settracks( <I>playtracks</I>, <I>rectracks</I> )</B>
<P>
<B>WORD <I>playtracks</I>, <I>rectracks</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Setttracks()</B> sets the number of recording and playback tracks.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>133 (0x85)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available only when bit #2 of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>playtracks</I> specifies the number of playback tracks (0-3) and <I>rectracks</I> specifies the number of recording tracks.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   rectracks,-(sp)
move.w   playtracks,-(sp)
move.w   #$85,-(sp)
trap   #14
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Settracks()</B> returns 0 if the operation was successful or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The tracks specified are stereo tracks. When in 8-bit Mono mode, two samples are read at a time.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Setmode(), Setmontracks()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Sndstatus()</H3>

<P>
<B>LONG Sndstatus( <I>reset</I> )</B>
<P>
<B>WORD <I>reset</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=4><B>Sndstatus()</B> can be used to test the error condition of the sound system and to completely reset it.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=4>140 (0x8C)</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=4>Available only when bit #2 of the '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=4><I>reset</I> is a flag indicating whether the sound system should be reset. A value of <B>SND_RESET</B> (1) will reset the sound system.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=4>
<PRE>
move.w   reset,-(sp)
move.w   #$8C,-(sp)
trap   #14
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=4><B>Sndstatus()</B> returns a <B>LONG</B> bit array indicating the current error status of the sound system defined as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
<B><FONT SIZE=1 >Bit(s)</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0-3
</CENTER>
</TD><TD><FONT SIZE=2>These bits form a value indicating the error condition of the sound system as follows:</FONT> <U><B>Name Mask Meaning</B></U>
<P>
<FONT SIZE=2> <B>SND_ERROR</B> 0xF Use to mask error code</FONT> <U><B>Name Value Meaning</B></U>
<P>
<FONT SIZE=2> <B>SND_OK</B> 0 No Error</FONT> <B>SND_BADCONTROL</B> 1 Invalid Control Field
<P>
<FONT SIZE=2> <B>SND_BADSYNC</B> 2 Invalid Sync Format</FONT> <B>SND_BADCLOCK</B> 3 Clock out of range
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
4
</CENTER>
</TD><TD><FONT SIZE=2>If this bit is set, left channel clipping has occurred. Use the mask <B>SND_LEFTCLIP</B> (0x10) to isolate this bit.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
5
</CENTER>
</TD><TD><FONT SIZE=2>If this bit is set, right channel clipping has occurred. Use the mask <B>SND_RIGHTCLIP</B> (0x20) to isolate this bit.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
6-31
</CENTER>
</TD>
<TD><FONT SIZE=2>Unused.</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=4>On reset, the following things happen: DSP is tristated
<P>
 Gain and attentuation are zeroed
<P>
 Old matrix connections are reset
<P>
 ADDERIN is disabled
<P>
 Mode is set to 8-Bit Stereo
<P>
 Play and record tracks are set to 0
<P>
 Monitor track is set to 0
<P>
 Interrupts are disabled
<P>
 Buffer operation is disabled
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Soundcmd()</H3>

<P>
<B>LONG Soundcmd( <I>mode</I>, <I>data</I> )</B>
<P>
<B>WORD <I>mode</I>, <I>data</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>Soundcmd()</B> sets various configuration parameters in the sound system.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>130 (0x82)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>Available only when bit #2 of '_SND' cookie is set.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>mode</I> specifies how <I>data</I> is interpreted as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B><FONT SIZE=1 >Name</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >mode</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD>
<CENTER>
<B>LTATTEN</B>
</CENTER>
</TD>
<TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>
</TD><TD><FONT SIZE=2>Set the left attenuation (increasing attentuation is the same as decreasing volume). <I>data</I> is a bit mask as follows:</FONT>  XXXX XXXX LLLL XXXX<FONT SIZE=2>'L' specifies a valid value between 0 and 15 used to set the attenuation of the left channel in -1.5db increments. The bits represented by 'X' are reserved and should be 0.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>RATTEN</B>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Set the right attentuation. <I>data</I> is a bit mask as follows:</FONT>  XXXX XXXX RRRR XXXX<FONT SIZE=2>'R' specifies a valid value between 0 and 15 used to set the attenuation of the right channel in -1.5db increments. The bits represented by 'X' are reserved and should be 0.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>LTGAIN</B>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Set the left channel gain (boost the input to the ADC). <I>data</I> is a bit mask as follows:</FONT>  XXXX XXXX LLLL XXXX<FONT SIZE=2>'L' specifies a valid value between 0 and 15 used to set the gain of the left channel in 1.5db increments. The bits represented by 'X' are reserved and should be 0.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>RTGAIN</B>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Set the right channel gain (boost the input to the ADC). <I>data</I> is a bit mask as follows:</FONT>  XXXX XXXX RRRR XXXX<FONT SIZE=2>'R' specifies a valid value between 0 and 15 used to set the gain of the right channel in 1.5Db increments. The bits represented by 'X' are reserved and should be 0.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>ADDERIN</B>
</CENTER>
</TD>
<TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>
</TD><TD><FONT SIZE=2>Set the 16 bit ADDER to receive its input from the source(s) specified in <I>data</I>. <I>data</I> is a bit mask where each bit indicates a possible souce. Bit 0 represents the ADC (<B>ADDR_ADC</B>). Bit 1 represents the connection matrix (<B>ADDR_MATRIX</B>). Setting either or both of these bits determines the source of the ADDER.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>ADCINPUT</B>
</CENTER>
</TD>
<TD>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>
</TD><TD><FONT SIZE=2>Set the inputs of the left and right channels of the ADC. <I>data</I> is a bit mask with bit 0 being the right channel: <B>LEFT_MIC</B> (0x00) or <B>LEFT_PSG</B> (0x02) and bit 1 being the left channel: <B>RIGHT_MIC</B> (0x00) or <B>RIGHT_PSG</B> (0x01).</FONT>Setting a bit causes that channel to receive its input from the Yamaha PSG. Clearing a bit causes that channel to receive its input from the microphone.
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>SETPRESCALE</B>
</CENTER>
</TD>
<TD>
<CENTER>
<FONT SIZE=2>6</FONT>
</CENTER>
</TD><TD><FONT SIZE=2>This mode is only valid when <B>Devconnect()</B> is used to set the prescaler to TT030 compatibility mode. In that case, <I>data</I> represents the TT030 compatible prescale value as follows:</FONT><U><B>Name Value Meaning</B></U>
<P>
<B><FONT SIZE=2>CCLK_6K</FONT></B> 0 Divide by 1280 (6.25 MHz)
<P>
<B><FONT SIZE=2>CCLK_12K</FONT></B> 1 Divide by 640 (12.5 Mhz)
<P>
<B><FONT SIZE=2>CCLK_25K</FONT></B> 2 Divide by 320 (25 MHz)
<P>
<B><FONT SIZE=2>CCLK_50K</FONT></B> 3 Divide by 160 (50 MHz) 
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD COLSPAN=3>Setting <I>data</I> to <B>SND_INQUIRE</B> (-1) with any command will cause that command's current value to be returned and the parameter unchanged.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
move.w   data,-(sp)
move.w   mode,-(sp)
move.w   #$82,-(sp)
trap   #14
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3><B>Soundcmd()</B> returns the prior value of the specified command if data is <B>SND_INQUIRE</B> (-1).Using the <B>SETPRESCALE</B> mode to set a frequency of 6.25 MHz (<B>CCLK_6K</B>) will cause the sound system to mute on a Falcon030 as it does not support this sample rate.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=3>On current systems, a bug exists that causes a <I>mode</I> value of <B>LTGAIN</B> to set the gain for both channels.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>Devconnect()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Ssbrk()</H3>

<P>
<B>VOIDP Ssbrk( <I>len</I> )</B>
<P>
<B>WORD <I>len</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Ssbrk()</B> is designed to reserve memory at the top of RAM prior to the initialization of <B>GEMDOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>1 (0x01)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>TOS</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>len</I> is a <B>WORD</B> value specifying the number of bytes to reserve at the top of RAM.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   len,-(sp)
move.w   #$01,-(sp)
trap   #14
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Ssbrk()</B> returns a pointer to the allocated block.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD><B>Ssbrk()</B> was only used on early development systems. Currently the function is unimplemented and does not do anything.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=supexec2><H3>Supexec()</H3>

<P>
<B>LONG Supexec( <I>func</I> )</B>
<P>
<B>LONG (*<I>func</I>)( VOID );</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Supexec()</B> executes a user-defined function in supervisor mode.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>38 (0x26)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>TOS</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>func</I> is the address to a function which will be called in supervisor mode.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   func
move.w   #$26,-(sp)
trap   #14
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Supexec()</B> returns the <B>LONG</B> value returned by the user function.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>Care must be taken when calling the operating system in <a name=supervisormode2>supervisor mode. The <B>AES</B> must not be called while in supervisor mode.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Super()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>Unlocksnd()</H3>

<P>
<B>LONG Unlocksnd( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Unlocksnd()</B> unlocks the sound system so that other applications may utilize it.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>129 (0x81)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>TOS</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$81,-(sp)
trap   #14
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Unlocksnd()</B> returns a 0 if the sound system was successfully unlocked or <B>SNDNOTLOCK</B> (-128) if the sound system wasn't locked prior to the call.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Locksnd()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>VgetMonitor()</H3>

<P>
<B>WORD VgetMonitor( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>VgetMonitor()</B> returns a value which determines the kind of monitor currently being used. Thsi function mis alson sometimes referred to as mon_type () by some compilers.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>89 (0x59)</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>Available if the '_VDO' cookie has a value of 0x00030000 or greater.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
move.w   #$59,-(sp)
trap   #14
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=5><B>VgetMonitor()</B> returns a value describing the monitor currently connected to the system as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Return Value</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Monitor Type</FONT></B>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>MON_MONO</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>ST monochrome monitor</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>MON_COLOR</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>ST color monitor</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>MON_VGA</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>VGA monitor</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>MON_TV</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Television</FONT></TD></TR>

</TABLE>

<P>

<HR>

<H3>VgetRGB()</H3>

<P>
<B>VOID VgetRGB( <I>index</I>, <I>count</I>, <I>rgb</I> )</B>
<P>
<B>WORD <I>index</I>, <I>count</I>;</B>
<P>
<B>RGB *<I>rgb</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>VgetRGB()</B> returns palette information as 24-bit <B>RGB</B> data.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>94 (0x5E)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available if the '_VDO' cookie has a value of 0x00030000 or greater.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>index</I> specifies the beginning color index in the palette to read data from. <I>count</I> specifies the number of palette entries to read. <I>rgb</I> is a pointer to an array of <B>RGB</B>s which will be filled in by the functions. <B>RGB</B> is defined as:
<PRE>
typedef struct
{
 BYTE reserved;
 BYTE red;
 BYTE green;
 BYTE blue;
} RGB;
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   rgb
move.w   count,-(sp)
move.w   index,-(sp)
move.w   #$5E,-(sp)
trap   #14
lea   10(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD><B>VgetRGB()</B> is device-dependent in nature and it is therefore recommended that <B>vq_color()</B> be used instead.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>VsetRGB()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>VgetSize()</H3>

<P>
<B>LONG VgetSize( <I>mode</I> )</B>
<P>
<B>WORD <I>mode</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>VgetSize()</B> returns the size of a screen mode in bytes.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>91 (0x5B)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available if the '_VDO' cookie has a value of 0x00030000 or greater.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>mode</I> is a modecode as defined in <B>VsetMode()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   mode,-(sp)
move.w   #$5B,-(sp)
trap   #14
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>VgetSize()</B> returns the size in bytes of a screen mode of type <I>mode</I>.
</TD></TR>

</TABLE>

<P>

<HR>

<H3>VsetMask()</H3>

<P>
<B>VOID VsetMask( <I>ormask</I>, <I>andmask</I>, <I>overlay</I>
)</B>
<P>
<B>LONG <I>ormask</I>, <I>andmask</I>;</B>
<P>
<B>WORD <I>overlay</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>VsetMask()</B> provides access to 'overlay' mode.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>146 (0x92)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available if the '_VDO' cookie has a value of 0x00030000 or greater.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD>When the <B>VDI</B> processes a <B>vs_color()</B> call. It converts the desired color into a hardware palette register. In 16-bit true-color mode, this is a <B>WORD</B> formatted as follows:
<PRE>

<CENTER>
RRRR RGGG GGXB BBBB
</CENTER>
The 'X' is the system overlay bit. In 24-bit true color a <B>LONG</B> is formatted as follows:

<CENTER>
XXXXXXXX RRRRRRRR GGGGGGGG BBBBBBBB
</CENTER>
<B>VsetMask()</B> sets a logical OR and AND mask which are applied to this register before being stored. The default system value for <I>ormask</I> is 0x00000000 and the default value for <I>andmask</I> is 0xFFFFFFFF.<I>overlay</I> should be <B>OVERLAY_ON</B> (1) to enable overlay mode or <B>OVERLAY_OFF</B> (0) to disable it.
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   overlay,-(sp)
move.l   andmask,-(sp)
move.l   ormask,-(sp)
move.w  #$92,-(sp)
trap  #14
lea  12(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>To make colors defined by the <B>VDI</B> transparent in 16-bit true color with overlay mode enabled, use an <I>andmask</I> value of 0xFFFFFFDF and an <I>ormask</I> value of 0x00000000. To make colors visible, use an <I>andmask</I> of 0x00000000 and an <I>ormask</I> of 0x00000020.
</TD></TR>

</TABLE>

<P>

<HR>

<H3>VsetMode()</H3>

<P>
<B>WORD VsetMode( <I>mode</I> )</B>
<P>
<B>WORD <I>mode</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>VsetMode()</B> places the video shifter into a specific video mode.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>88 (0x58)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>Available if the '_VDO' cookie has a value of 0x00030000 or greater.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>mode</I> is a <B>WORD</B> bit array arranged as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bit(s)</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>BPS1</B> (0x00)
<P>
<B>BPS2 </B>(0x01)
<P>
<B>BPS4 </B>(0x02)
<P>
<B>BPS8 </B>(0x03)
<P>
<B>BPS16 </B>(0x04)
</TD><TD>
<CENTER>
<FONT SIZE=2>0-2</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2>These bits form a value so that 2 ^ X represents the number of bits per pixel.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>COL80 </B>(0x08)
<P>
<B>COL40 </B>(0x00)
</TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>
</TD><TD><FONT SIZE=2>80 Column Flag (if set, 80 columns, otherwise 40)</FONT>
</TD></TR>

<TR><TH></TH><TD><B>VGA </B>(0x10)
<P>
<B>TV </B>(0x00)</TD>
<TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>
</TD><TD><FONT SIZE=2>VGA Flag (if set, VGA mode will be used, otherwise television/monitor mode)</FONT>
</TD></TR>

<TR><TH></TH><TD><B>PAL </B>(0x20)
<P>
<B>NTSC </B>(0x00)</TD>
<TD>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>
</TD><TD><FONT SIZE=2>PAL Flag (if set, PAL will be used, otherwise NTSC)</FONT>
</TD></TR>

<TR><TH></TH><TD><B>OVERSCAN </B>(0x40)</TD><TD>
<CENTER>
<FONT SIZE=2>6</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Overscan Flag (not valid with VGA)</FONT>
</TD></TR>

<TR><TH></TH><TD><B>STMODES </B>(0x80)</TD><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>ST Compatibility Flag</FONT></TD></TR>

<TR><TH></TH><TD><B>VERTFLAG </B>(0x100)</TD><TD>
<CENTER>
<FONT SIZE=2>8</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Vertical Flag (is set, enables interlace mode on a color monitor or double-line mode on a VGA monitor)</FONT>
</TD></TR>

<TR><TH></TH><TD>-</TD><TD>
<CENTER>
<FONT SIZE=2>9-15</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Reserved (set to 0)</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD COLSPAN=3>If <I>mode</I> is <B>VM_INQUIRE</B> (-1) then the current mode code is returned without changing the current settings.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
move.w   mode,-(sp)
move.w   #$58,sp
trap   #14
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3><B>VsetMode()</B> returns the prior video mode.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=3><B>VsetMode()</B> does not reset the video base address, reserve memory, or<B> </B>reinitialize the <B>VDI</B>. To do this, use <B>V</B>s<B>etScreen()</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=3>Some video modes are not legal. 40 column monoplane modes and 80 column VGA true color modes are not supported.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>VsetScreen(), Setscreen()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>VsetRGB()</H3>

<P>
<B>VOID VsetRGB( <I>index</I>, <I>count</I>, <I>rgb</I> )</B>
<P>
<B>WORD <I>index</I>, <I>count</I>;</B>
<P>
<B>RGB *<I>rgb</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>VsetRGB()</B> sets palette registers using 24-bit <B>RGB</B> values.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>93 (0x5D)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available if the '_VDO' cookie has a value of 0x00030000 or greater.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>index</I> specifies the first palette index to modify. <I>count</I> specifies the number of palette entries to modify. <I>rgb</I> is a pointer to an array of <B>RGB</B> elements which will be copied into the palette.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   rgb
move.w   count,-(sp)
move.w   index,-(sp)
move.w   #$5D,-(sp)
trap   #14
lea   10(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call is device-dependent by nature. It is therefore recommended that <B>vs_color()</B> be used instead.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>VgetRGB(), EsetPalette(), Setpalette(), vs_color()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>VsetScreen()</H3>

<P>
<B>VOID VsetScreen( <I>log</I>, <I>phys</I>, <I>mode</I>, <I>modecode</I>
)</B>
<P>
<B>VOIDP <I>log</I>, <I>phys</I>;</B>
<P>
<B>WORD <I>mode</I>, <I>modecode</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>VsetScreen()</B> changes the base addresses and mode of the current screen.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>5 (0x05)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>TOS</B> versions. The ability of this call to utilize the <I>modecode</I> parameter and the memory allocation feature is limited to systems having a '_VDO' cookie with a value of 0x00030000 or greater.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>log</I> is the address for the new logical screen base. <I>phys</I> is the new address for the physical screen base. If either <I>log</I> or <I>phys</I> is <B>NULL</B>, the <B>XBIOS</B> will allocate a new block of memory large enough for the current screen and reset the parameter accordingly. <I>mode</I> defines the screen mode to switch to (same as <B>Getrez()</B>). Setting <I>mode</I> to <B>SCR_MODECODE</B> (3) will cause <I>modecode</I> to be used to set the graphic mode (see <B>VsetMode()</B> for valid values for this parameter), otherwise <I>modecode</I> is ignored. If any of these three parameters is set to <B>SCR_NOCHANGE</B> (1) then that value will be left unchanged.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   modecode,-(sp)
move.w   mode,-(sp)
pea   phys
pea   log
move.w   #$05,-(sp)
trap   #14
lea   14(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>Changing screen modes with this call does not reinitialize the <B>AES</B>. The <B>VDI</B> and <B>VT52</B> emulator are, however, correctly reinitialized. The <B>AES</B> should not be used after changing screen mode with this call until the old screen mode is restored. 
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>TOS 1.00 and 1.02 required that its physical screen memory be on a 256 byte boundary. All other Atari computers only require a <B>WORD</B> boundary.This call is actually a revised binding of <B>Setscreen()</B> developed to allow access to the newly available modecode parameter.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Setscreen(), VsetMode()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>VsetSync()</H3>

<P>
<B>VOID VsetSync( <I>external</I> )</B>
<P>
<B>WORD <I>external</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>VsetSync()</B> sets the external video sync mode.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>90 (0x5A)</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>Available if the '_VDO' cookie has a value of 0x00030000 or greater.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=5><I>external</I> is a <B>WORD</B> bit array defined as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bit</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD><B>VCLK_EXTERNAL</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Use external clock.</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>VCLK_EXTVSYNC</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Use external vertical sync.</FONT></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD><B>VCLK_EXTHSYNC</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Use external horizontal sync.</FONT></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
-
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>3-15</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Reserved (set to 0)</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
move.w   external,-(sp)
move.w   #$5A,-(sp)
trap   #14
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=5>This call only works in Falcon video modes, not in compatibility or any four color modes.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=vsync><H3>Vsync()</H3>

<P>
<B>VOID Vsync( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Vsync()</B> pauses program execution until the next vertical blank interrupt.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>37 (0x25)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>TOS</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$25,-(sp)
trap   #14
addq.l   #2,sp
</PRE>

</TD></TR>

</TABLE>

<P>

<HR>

<a name=waveplay><H3>WavePlay()</H3>

<P>
<B>WORD WavePlay( <I>flags</I>, <I>rate</I>, <I>sptr</I>, <I>slen</I>
)</B>
<P>
<B>WORD <I>flags</I>;</B>
<P>
<B>LONG <I>rate</I>;</B>
<P>
<B>VOIDP <I>sptr</I>;</B>
<P>
<B>LONG <I>slen</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=7><B>WavePlay()</B> provides a easy method for applications to utilize the DMA sound system on the STe, TT030, and Falcon030 and playback user-defined event sound effects.
</TD></TR>

<TR><TH></TH><TD COLSPAN=7></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=7>165 (0xA5)</TD></TR>

<TR><TH></TH><TD COLSPAN=7></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=7>Available only when the 'SAM\0' cookie exists.
</TD></TR>

<TR><TH></TH><TD COLSPAN=7></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=7><I>flags</I> is a bit mask consisting of the following options:
</TD></TR>

<TR><TH></TH><TD COLSPAN=7></TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD COLSPAN=2>
<CENTER>
<B><FONT SIZE=2 >Mask</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2><B>WP_MONO</B></TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>0x00</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>The sound to be played back is monophonic.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2><B>WP_STEREO</B></TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>0x01</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>The sound to be played back is in stereo.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2><B>WP_8BIT</B></TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>0x00</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>The sound to be played back was sampled at 8-bit resolution.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2><B>WP_16BIT</B></TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>0x02</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>The sound to be played back was sampled at 16-bit resolution.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2><B>WP_MACRO</B></TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>0x100</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Play back a user-assigned macro or application global sound effect. This flag is exclusive and modifies the meaning of the other parameters to this call as shown below.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=7></TD></TR>

<TR><TH></TH><TD COLSPAN=7><I>rate</I> specifies the sample rate in Hertz (for example 49170L to play back at 49170 Hz). If <B>WP_MACRO</B> was specified in <I>flags</I>, then this parameter is ignored and should be set to 0L.<I>sptr</I> is a pointer to the sound sample in memory. If <B>WP_MACRO</B> was specified in <I>flags</I> then this parameter should be a <B>LONG</B> containing either the application cookie specified in the .SAA file or the 'SAM\0' cookie to play an application global.<I>slen</I> is the length of the sample in bytes. If <B>WP_MACRO</B> was specified in <I>flags</I> then <I>slen</I> is the macro or application global index as specified in the .SAA file. Valid application global values are as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=7></TD></TR>

<TR><TH></TH><TD COLSPAN=2><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD COLSPAN=2>
<CENTER>
<I><B><FONT SIZE=2 >slen</FONT></B></I>
</CENTER>

</TD><TD COLSPAN=3><B><FONT SIZE=2 >Usage</FONT></B>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>AG_FIND</B></TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD COLSPAN=3><FONT SIZE=2>Call <B>WavePlay()</B> with this value when the user requests display of the 'Find' dialog box.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>AG_REPLACE</B></TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD COLSPAN=3><FONT SIZE=2>Call <B>WavePlay()</B> with this value when the user requests display of the 'Replace' dialog box.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>AG_CUT</B></TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD COLSPAN=3><FONT SIZE=2>Call <B>WavePlay()</B> with this value when the user requests a 'Cut' operation.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>AG_COPY</B></TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD COLSPAN=3><FONT SIZE=2>Call <B>WavePlay()</B> with this value when the user requests a 'Copy' operation.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>AG_PASTE</B></TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

</TD><TD COLSPAN=3><FONT SIZE=2>Call <B>WavePlay()</B> with this value when the user requests a 'Paste' operation.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>AG_DELETE</B></TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>

</TD><TD COLSPAN=3><FONT SIZE=2>Call <B>WavePlay()</B> with this value when the user requests a 'Delete' operation. This should not be called when the user presses the 'Delete' key.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>AG_HELP</B></TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>6</FONT>
</CENTER>

</TD><TD COLSPAN=3><FONT SIZE=2>Call <B>WavePlay()</B> with this value when the user requests display of application 'Help.' This should not be called when the user presses the 'Help' key.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>AG_PRINT</B></TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>

</TD><TD COLSPAN=3><FONT SIZE=2>Call <B>WavePlay()</B> with this value when the user requests display of the 'Print' dialog box.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>AG_SAVE</B></TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>8</FONT>
</CENTER>

</TD><TD COLSPAN=3><FONT SIZE=2>Call <B>WavePlay()</B> with this value when the user requests that the current document be saved. This should not be used for any operation that calls the file selector.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>AG_ERROR</B></TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>9</FONT>
</CENTER>

</TD><TD COLSPAN=3><FONT SIZE=2>Call <B>WavePlay()</B> with this value when the application encounters an error not presented to the user in an alert or error dialog (error dialogs may be assigned sounds).</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>AG_QUIT</B></TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>10</FONT>
</CENTER>

</TD><TD COLSPAN=3><FONT SIZE=2>Call <B>WavePlay()</B> with this value when the user requests that the application exit. Use this global after the user has confirmed a quit with any dialog box that may have been necessary.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=7></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=7>
<PRE>
move.l   slen,-(sp)
pea   sptr
move.l   rate,-(sp)
move.w   flags,-(sp)
move.w   #$A5,-(sp)
trap   #14
lea   16(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=7></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=7><B>WavePlay()</B> returns <B>WP_OK</B> (0) if the call was successful, <B>WP_ERROR</B> (-1) if an error occurred, or <B>WP_NOSOUND</B> (1) to indicate that no sound was played (either because the user had not previously assigned a sound to the given macro or SAM was disabled).
</TD></TR>

<TR><TH></TH><TD COLSPAN=7></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=7>This function is only available when the System Audio Manager TSR (available from Atari Corp. or SDS) is installed. Extended development information is available online the Atari Developer's roundtable on GEnie.Because of previously misdocumented sample rates, the value for rate must be 33880 to play back a sample at 32880 Hz, 20770 to play back a sample at 19668&nbsp;Hz, and 16490 to play back a sample at 16390 Hz.  
</TD></TR>

<TR><TH></TH><TD COLSPAN=7></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=7>Even if an application does not install any custom events in a .SAA file, an application must still provide a .SAA file if it wishes to use application globals so that the SAM configuration accessory allows the user to assign those sounds.A macro is commonly used to access the application global sounds available as follows:
<PRE>
#define WavePlayMacro(a) WavePlay( WP_MACRO, 0L, SAM_COOKIE, a );
</PRE>

</TD></TR>

</TABLE>

<P>
<B></B>
<H3>Xbtimer()</H3>

<P>
<B>VOID Xbtimer( <I>timer</I>, <I>control</I>, <I>data</I>, <I>hand</I>
)</B>
<P>
<B>WORD <I>timer</I>, <I>control</I>, <I>data</I>;</B>
<P>
<B>VOID (*<I>hand</I>)( VOID );</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>Xbtimer()</B> sets an interrupt on the 68901 chip.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>31 (0x1F)</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>All <B>TOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=5><I>timer</I> is a value defining which timer to set as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Timer</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD><B>XB_TIMERA</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Timer A (DMA sound counter)</FONT></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD><B>XB_TIMERB</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Timer B (Hblank counter)</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>XB_TIMERC</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Timer C (200Hz system clock)</FONT></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD><B>XB_TIMERD</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Timer D (RS-232 baud rate generator)</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH></TH><TD COLSPAN=5><I>control</I> is placed into the control register of the timer. <I>data</I> is placed in the data register of the timer. <I>hand</I> is a pointer to the interrupt handler which is called by the interrupt.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
pea   hand
move.w   data,-(sp)
move.w   control,-(sp)
move.w   timer,-(sp)
move.w   #$1F,-(sp)
trap   #14
lea   12(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=5><B>Mfpint(), Jenabint(), Jdisint()</B>
</TD></TR>

</TABLE>

<P>
<B></B>
<hr><center><a href="toc.htm"> Table of Contents | </a><a href="index.htm"> Index </a></center>
</BODY>

</HTML>
