<HTML>

<HEAD>

<TITLE>AES Reference, Master</TITLE>

</HEAD>

<BODY BACKGROUND BGCOLOR=#ffffff>

<H1>AES Function Reference</H1>

<HR>

<H2>Application Services Library</H2>

<HR>

<P>
The <I>Application Services Library</I> provides general use functions
used in locating and working with other resident applications
in addition to providing <B>AES</B> initialization and termination
code. The members of the <I>Application Services Library</I> are:
<P>
 appl_exit()
<P>
 appl_find()
<P>
 appl_getinfo()
<P>
 appl_init()
<P>
 appl_read()
<P>
 appl_search()
<P>
 appl_tplay()
<P>
 appl_trecord()
<P>
 appl_write()
<H3>appl_exit()</H3>

<P>
<B>WORD appl_exit( VOID )</B>
<TABLE>

<TR><TH></TH><TD><B>appl_exit()</B> should be called at the termination of any program initialized with <a name=applinit><B>appl_init()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>19 (0x13)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
return crys_if(0x13);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>appl_exit()</B> returns 0 if an error occurred or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The proper procedure for handling an error from this function is currently undefined.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>appl_init()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>appl_find()</H3>

<P>
<B>WORD appl_find( <I>fname </I>)</B>
<P>
<B>CHAR *<I>fname</I>;</B>
<TABLE>

<TR><TH></TH><TD><B>appl_find()</B> searches the <B>AES</B>'s current process list for a program named <I>fname</I> and, if present, returns the application identifier of the process.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>13 (0x0D)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>fname</I> is a pointer to a null-terminated ASCII string containing a valid <B>GEMDOS</B> filename (not including an extension) padded with blanks to be exactly 8 characters long (not including the <B>NULL</B>). 
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
addrin[0] = fname;

return crys_if(0x0D);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>appl_find()</B> returns the application identifier of the process if it is found or -1 otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Version Notes</B></TH><TD><B>AES</B> versions from 4.0 add several extensions to this call for the benefit of <B>MultiTOS</B> as follows: If the upper word of the <B>CHAR</B> * is 0xFFFF, the lower word is assumed to be the <B>MiNT</B> id and <B>appl_find()</B> will return the <B>AES</B> application identifier.
<P>
 If the upper word of the <B>CHAR</B> * is 0xFFFE, the lower word is assumed to be the <B>AES</B> application identifier and the <B>MiNT</B> id is returned.
<P>
 If the upper word of the <B>CHAR</B> * is 0x0000, the current processes' application identifier is returned.This functionality only exists if the <B>AES</B> version is 4.0 and above and <B>appl_getinfo()</B> indicates that it is available.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>appl_write()</B>, <B>appl_init()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>appl_getinfo()</H3>

<P>
<B>WORD appl_getinfo(<I>ap_gtype</I>, <I>ap_gout1</I>, <I>ap_gout2</I>,
<I>ap_gout3</I>, <I>ap_gout4</I> )</B>
<P>
<B>WORD <I>ap_gtype</I>;</B>
<P>
<B>WORD *<I>ap_gout1</I>, *<I>ap_gout2</I>, *<I>ap_gout3</I>,
*<I>ap_gout4</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>appl_getinfo()</B> returns information about the <B>AES</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>130 (0x82)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>Available as of <B>AES</B> version 4.00.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>ap_gtype</I> specifies the type of information to be returned in the shorts pointed to by <I>ap_gout1</I>, <I>ap_gout2</I>, <I>ap_gout3</I>, and <I>ap_gout4</I> as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Value</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Returns</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>AES_LARGEFONT</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2>AES Large Font Information</FONT></B>
<P>
<I><FONT SIZE=2>ap_gout1</FONT></I> is filled in with the <B>AES</B> font's point size. 
<P>
<I><FONT SIZE=2>ap_gout2</FONT></I> is filled in with the font id.
<P>
<I><FONT SIZE=2>ap_gout3</FONT></I> is a code indicating the type of font:
<P>
<B><FONT SIZE=2><a name=system2><a name=systemfont2> SYSTEM_FONT</FONT></B> (0) is the system font
<P>
<B><FONT SIZE=2> OUTLINE_FONT</FONT></B> (1) is an outline font
<P>
<I><FONT SIZE=2>ap_gout4</FONT></I> is unused.
</TD></TR>

<TR><TH></TH><TD><B>AES_SMALLFONT</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2>AES Large Font Information</FONT></B> 
<P>
<FONT SIZE=2>Same as above for the current small font.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>AES_SYSTEM</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2>AES System Specifics</FONT></B>
<P>
<I><FONT SIZE=2>ap_gout1</FONT></I> is filled in with the resolution number (as would be returned by <B>Getrez()).</B>
<P>
<I><FONT SIZE=2>ap_gout2</FONT></I> is filled in with the number of colors supported by the <B>AES</B> object library.
<P>
<I><FONT SIZE=2>ap_gout3</FONT></I> is 0 if color icons are not supported or 1 if they are.
<P>
<I><FONT SIZE=2>ap_gout4</FONT></I> is 0 to indicate that the extended resource file format is not supported or 1 if it is.
</TD></TR>

<TR><TH></TH><TD><a name=language><B>AES_LANGUAGE</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2>AES Globalization</FONT></B>
<P>
<I><FONT SIZE=2>ap_gout1</FONT></I> is filled in with the current <B>AES</B> language code as follows:<U><B><FONT SIZE=2>Name</FONT></B></U> <U><I><B>ap_gout1</B></I></U> <U><B>Language</B></U><B><FONT SIZE=2>AESLANG_ENGLISH</FONT></B> 0 English
<P>
<B><FONT SIZE=2>AESLANG_GERMAN</FONT></B> 1 German
<P>
<B><FONT SIZE=2>AESLANG_FRENCH</FONT></B> 2 French
<P>
<FONT SIZE=2>- 3 (Reserved)</FONT>
<P>
<B><FONT SIZE=2>AESLANG_SPANISH</FONT></B> 4 Spanish
<P>
<B><FONT SIZE=2>AESLANG_ITALIAN</FONT></B> 5 Italian
<P>
<B><FONT SIZE=2>AESLANG_SWEDISH</FONT></B> 6 Swedish<I><FONT SIZE=2>ap_gout2</FONT></I>, <I>ap_gout3</I>, and <I>ap_gout4</I> are unused.
</TD></TR>

<TR><TH></TH><TD><B>AES_PROCESS</B></TD><TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2>AES Multiple Process Support</FONT></B>
<P>
<I><FONT SIZE=2>ap_gout1</FONT></I> is 0 to indicate the use of non-pre-emptive multitasking and 1 to indicate the use of pre-emptive multitasking.
<P>
<I><FONT SIZE=2>ap_gout2</FONT></I> is 0 if <B>appl_find()</B> cannot convert between <B>MiNT</B> and <B>AES</B> id's and 1 to indicate that it can.
<P>
<I><FONT SIZE=2>ap_gout3</FONT></I> is 0 if <B>appl_search()</B> is not implemented and 1 if it is.
<P>
<I><FONT SIZE=2>ap_gout4</FONT></I> is 0 if <B>rsrc_rcfix()</B> is not implemented and 1 if it is.
</TD></TR>

<TR><TH></TH><TD><B>AES_PCGEM</B></TD><TD>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2>AES PC-GEM Features</FONT></B>
<P>
<I><FONT SIZE=2>ap_gout1</FONT></I> is 0 if <B>objc_xfind()</B> is not implemented and 1 if it is.
<P>
<I><FONT SIZE=2>ap_gout2</FONT></I> is currently reserved.
<P>
<I><FONT SIZE=2>ap_gout3</FONT></I> is 0 if <B>menu_click()</B> is not implemented and 1 if it is.
<P>
<I><FONT SIZE=2>ap_gout4</FONT></I> is 0 if <B>shel_rdef()</B> and <B>shel_wdef()</B> are not implemented and 1 if they are.
</TD></TR>

<TR><TH></TH><TD><B>AES_INQUIRE</B></TD><TD>
<CENTER>
<FONT SIZE=2>6</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2>AES Extended Inquiry Functions</FONT></B>
<P>
<I><FONT SIZE=2>ap_gout1</FONT></I> is 0 if -1 is not a valid <I>ap_id</I> parameter to <B>appl_read()</B> or 1 if it is.
<P>
<I><FONT SIZE=2>ap_gout2</FONT></I> is 0 if -1 is not a valid length parameter to <B>shel_get()</B> or 1 if it is.
<P>
<I><FONT SIZE=2>ap_gout3</FONT></I> is 0 if -1 is not a valid <I>mode</I> parameter to <B>menu_bar()</B> or 1 if it is.
<P>
<I><FONT SIZE=2>ap_gout4</FONT></I> is 0 if <B>MENU_INSTL</B> is not a valid <I>mode</I> parameter to <B>menu_bar()</B> or 1 if it is.
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
-
</CENTER>
</TD><TD>
<CENTER>
7
</CENTER>

</TD><TD><FONT SIZE=2>Currently reserved.</FONT></TD></TR>

<TR><TH></TH><TD><B>AES_MOUSE</B></TD><TD>
<CENTER>
<FONT SIZE=2>8</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2>AES Mouse Support</FONT></B>
<P>
<I><FONT SIZE=2>ap_gout1</FONT></I> is 0 to indicate that <I>mode</I> parameters of 258-260 are not supported by <B>graf_mouse()</B> and 1 if they are.
<P>
<I><FONT SIZE=2>ap_gout2</FONT></I> is 0 to indicate that the application has control over the mouse form and 1 to indicate that the mouse form is maintained by the <B>AES</B> on a per-application basis.
<P>
<I><FONT SIZE=2>ap_gout3</FONT></I> and <I>ap_gout4</I> are currently unused.
</TD></TR>

<TR><TH></TH><TD><B>AES_MENU</B></TD><TD>
<CENTER>
<FONT SIZE=2>9</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2><a name=menustrct>AES Menu Support</FONT></B>
<P>
<I><FONT SIZE=2>ap_gout1</FONT></I> is 0 to indicate that sub-menus are not supported and 1 if <B>MultiTOS</B> style sub-menus are.
<P>
<I><FONT SIZE=2>ap_gout2</FONT></I> is 0 to indicate that popup menus are not supported and 1 if <B>MultiTOS</B> style popup menus are.
<P>
<I><FONT SIZE=2>ap_gout3</FONT></I> is 0 to indicate that scrollable menus are not supported and 1 if <B>MultiTOS</B> style scrollable menus are.
<P>
<I><FONT SIZE=2>ap_gout4</FONT></I> is 0 to indicate that the <B>MN_SELECTED</B> message does not contain object tree information in <I>msg</I>[57] and 1 to indicate that it does. 
</TD></TR>

<TR><TH></TH><TD><B>AES_SHELL</B></TD><TD>
<CENTER>
<FONT SIZE=2>10</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2>AES Shell Support</FONT></B>
<P>
<I><FONT SIZE=2>ap_gout1</FONT></I> &amp; 0x00FF indicates the highest legal value for the <I>mode</I> parameter of <B>shel_write()</B>. <I>ap_gout1</I> &amp; 0xFF00 indicate which extended <B>shel_write()</B> <I>mode</I> bits are supported.
<P>
<I><FONT SIZE=2>ap_gout2</FONT></I> is 0 if <B>shel_write()</B> with a <I>mode</I> parameter of 0 launches an application or 1 if it cancels the previous <B>shel_write()</B>.
<P>
<I><FONT SIZE=2>ap_gout3</FONT></I> is 0 if <B>shel_write()</B> with a <I>mode</I> parameter of 1 launches an application immediately or 1 if it takes effect when the current application exits.
<P>
<I><FONT SIZE=2>ap_gout4</FONT></I> is 0 if ARGV style parameter passing is not supported or 1 if it is.
</TD></TR>

<TR><TH></TH><TD><B>AES_WINDOW</B></TD><TD>
<CENTER>
<FONT SIZE=2>11</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2>AES Window Features</FONT></B>
<P>
<I><FONT SIZE=2>ap_gout1</FONT></I> is a bitmap of extended modes supported by <B>wind_get()</B> and <B>wind_set()</B> (if a bit is set, it is supported) as follows:<FONT SIZE=2> <U><B>Bit <I>mode</I></B></U></FONT>
<P>
<FONT SIZE=2> 0 <B>WF_TOP</B> returns window below the top also.</FONT>
<P>
<FONT SIZE=2> 1 <B>wind_get( WF_NEWDESK</B>, ... <B>)</B> supported.</FONT>
<P>
<FONT SIZE=2> 2 <B>WF_COLOR</B> get/set.</FONT>
<P>
<FONT SIZE=2> 3 <B>WF_DCOLOR</B> get/set.</FONT>
<P>
<FONT SIZE=2> 4 <B>WF_OWNER</B> get/set.</FONT>
<P>
<FONT SIZE=2> 5 <B>WF_BEVENT</B> get/set.</FONT>
<P>
<FONT SIZE=2> 6 <B>WF_BOTTOM</B> set.</FONT>
<P>
<FONT SIZE=2> 7 <B>WF_ICONIFY</B> set.</FONT>
<P>
<FONT SIZE=2> 8 <B>WF_UNICONIFY</B> set.</FONT>
<P>
<FONT SIZE=2> 9-15 Unused</FONT>
<P>
<I><FONT SIZE=2>ap_gout2</FONT></I> is current unused.
<P>
<I><FONT SIZE=2>ap_gout3</FONT></I> is a bitmap of supported window behaviors (if a bit is set, it is supported) as follows:
<P>
<FONT SIZE=2> <U><B>Bit Behaviour</B></U></FONT>
<P>
<FONT SIZE=2> 0 Iconifier gadget present.</FONT>
<P>
<FONT SIZE=2> 1 Bottomer gadget present.</FONT>
<P>
<FONT SIZE=2> 2 shift-click sends window to bottom.</FONT>
<P>
<FONT SIZE=2> 3 "hot" close box supported.</FONT>
<P>
<FONT SIZE=2> 4-15 Unused</FONT>
<P>
<I><FONT SIZE=2>ap_gout4</FONT></I> is currently unused.
</TD></TR>

<TR><TH></TH><TD><B>AES_MESSAGE</B></TD><TD>
<CENTER>
<FONT SIZE=2>12</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2>AES Extended Messages</FONT></B>
<P>
<I><FONT SIZE=2>ap_gout1</FONT></I> is a bitmap of extra messages supported (if a bit is set, it is supported) as follows:<FONT SIZE=2> <U><B>Bit Message</B></U></FONT>
<P>
<FONT SIZE=2> 0 <B>WM_NEWTOP</B> is meaningful.</FONT>
<P>
<FONT SIZE=2> 1 <B>WM_UNTOPPED</B> is sent.</FONT>
<P>
<FONT SIZE=2> 2 <B>WM_ONTOP</B> is sent.</FONT>
<P>
<FONT SIZE=2> 3 <B>AP_TERM</B> is sent.</FONT>
<P>
<FONT SIZE=2> 4 Shutdown and resolution change messages.</FONT>
<P>
<FONT SIZE=2> 5 <B>CH_EXIT</B> is sent.</FONT>
<P>
<FONT SIZE=2> 6 <B>WM_BOTTOMED</B> is sent.</FONT>
<P>
<FONT SIZE=2> 7 <B>WM_ICONIFY</B> is sent.</FONT>
<P>
<FONT SIZE=2> 8 <B>WM_UNICONIFY</B> is sent.</FONT>
<P>
<FONT SIZE=2> 9 <B>WM_ALLICONIFY</B> is sent.</FONT>
<P>
<FONT SIZE=2> 10-15 Unused</FONT>
<P>
<I><FONT SIZE=2>ap_gout2</FONT></I> is a bitmap of extra messages supported. Current all bits are unused.
<P>
<I><FONT SIZE=2>ap_gout3</FONT></I> is a bitmap indicating message behaviour (if a bit is set, the behaviour exists) as follows:
<P>
<FONT SIZE=2> <U><B>Bit Message</B></U></FONT>
<P>
<FONT SIZE=2> 0 <B>WM_ICONIFY</B> message gives coordinates.</FONT>
<P>
<FONT SIZE=2> 1-15 Unused</FONT>
<P>
<I><FONT SIZE=2>ap_gout4</FONT></I> is currently unused.
</TD></TR>

<TR><TH></TH><TD><B>AES_OBJECT</B></TD><TD>
<CENTER>
<FONT SIZE=2>13</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2>AES Extended Objects</FONT></B>
<P>
<FONT SIZE=2>ap_gout1 is 0 if 3D objects are not supported or 1 if they are.</FONT>
<P>
<I><FONT SIZE=2>ap_gout2</FONT></I> is 0 if <B>objc_sysvar()</B> is not present, 1 if <B>MultiTOS</B> v1.01 <B>objc_sysvar()</B> is present, or 2 if extended <B>objc_sysvar()</B> is present.
<P>
<I><FONT SIZE=2>ap_gout3</FONT></I> is 0 if the system font is the only font supported or 1 if <B>GDOS</B> fonts are also supported.
<P>
<I><FONT SIZE=2>ap_gout4</FONT></I> is reserved for OS extensions.
</TD></TR>

<TR><TH></TH><TD><B>AES_FORM</B></TD><TD>
<CENTER>
<FONT SIZE=2>14</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2>AES Form Support</FONT></B>
<P>
<I><FONT SIZE=2>ap_gout1</FONT></I> is 0 if 'flying dialogs' are not supported or 1 if they are.
<P>
<I><FONT SIZE=2>ap_gout2</FONT></I> is 0 if keyboard tables are not supported or 1 if Mag!X style keyboard tables are supported.
<P>
<I><FONT SIZE=2>ap_gout3</FONT></I> is 0 if the last cursor position from <B>objc_edit()</B> is not returned or 1 if it is. 
<P>
<I><FONT SIZE=2>ap_gout4</FONT></I> is currently reserved.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
intin[0] = ap_gtype;

crys_if(0x82);

*ap_gout1 = intout[1];
*ap_gout2 = intout[2];
*ap_gout3 = intout[3];
*ap_gout4 = intout[4];

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3><B>appl_getinfo()</B> returns 1 if an error occurred or 0 otherwise.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Version Notes</B></TH><TD COLSPAN=3>Using an <I>ap_gtype</I> value of 4 and above is only supported as of <B>AES</B> version 4.1.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=3>Many of the <I>ap_gtype</I> return values identify features of <B>TOS</B> not supported by Atari but for the benefit of third-party vendors. You should contact the appropriate third-party for documentation on these functions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>appl_init()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<H3>appl_init()</H3>

<P>
<B>WORD appl_init( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>appl_init()</B> should be the first function called in any application that intends to use <B>GEM</B> calls.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>10 (0x0A)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>All <B>AES</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3>The function as prototyped accepts no parameters, however, all 'C' compilers use this call to set up internal information as well as to update the applications' global array.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
return crys_if(0x0A);
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3><B>appl_init()</B> returns the applications' global identifier if successful or -1 if the AES cannot register the application. If successful, the global identifier should be stored in a global variable for later use.
<P>
Besides the return value, the <B>AES</B> fills in the application's global array (to reference the global array see your programming languages' manual).
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >global[x]</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>_AESversion</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2>AES</FONT></B> version number.</TD></TR>

<TR><TH></TH><TD><B>_AESnumapps</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Number of concurrent applications possible (normally&nbsp;1). <B>MultiTOS</B> will return -1.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>_AESapid</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Application identifier (same as <B>appl_init()</B> return value).</FONT>
</TD></TR>

<TR><TH></TH><TD><B>_AESappglobal</B></TD><TD>
<CENTER>
<FONT SIZE=2>3-4</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2>LONG</FONT></B> global available for use by the application.
</TD></TR>

<TR><TH></TH><TD><B>_AESrscfile</B></TD><TD>
<CENTER>
<FONT SIZE=2>5-6</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Pointer to the base of the resource loaded via <B>rsrc_load()</B>.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
-
</CENTER>
</TD><TD>
<CENTER>
7-12
</CENTER>

</TD><TD><FONT SIZE=2>Reserved</FONT></TD></TR>

<TR><TH></TH><TD><B>_AESmaxchar</B></TD><TD>
<CENTER>
<FONT SIZE=2>13</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Current maximum character used by the <B>AES</B> to do <B>vst_height()</B> prior to writing to the screen. This entry is only present as of <B>AES</B> version 0x0400.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>_AESminchar</B></TD><TD>
<CENTER>
<FONT SIZE=2>14</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Current minimum character used by the <B>AES</B> to do <B>vst_height()</B> prior to writing to the screen. This entry is only present as of <B>AES</B> version 0x0400.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Version Notes</B></TH><TD COLSPAN=3>See above.</TD>
</TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>appl_exit()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<a name=applread><H3>appl_read()</H3>

<P>
<B>WORD appl_read( <I>ap_id</I>, <I>length</I>, <I>message </I>)</B>
<P>
<B>WORD <I>ap_id</I>, <I>length</I>;</B>
<P>
<B>VOIDP <I>message</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>appl_read()</B> is designed to facilitate inter-process communication between processes running under the <B>AES</B>. The call will halt the application until a message of sufficient length is available (see version notes below).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>11 (0x0B)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>ap_id</I> is your application identifier as returned by <B>appl_init()</B>. <I>length</I> is the length (in bytes) of the message to read. <I>message</I> is a pointer to a memory buffer where the incoming message should be copied to.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = ap_id;
intin[1] = length;

addrin[0] = message;

return crys_if(0x0B);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>appl_read()</B> returns 0 if an error occurred or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Version Notes</B></TH><TD>If the <B>AES</B> version is 4.0 or higher and <B>appl_getinfo()</B> indicates that this feature is supported, <I>ap_id</I> takes on an additional meaning. If <B>APR_NOWAIT</B> (-1) is passed instead of <I>ap_id</I>, <B>appl_read()</B> will return immediately if no message is currently waiting. 
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Normally this call is not used. <B>evnt_multi()</B> or <B>evnt_mesag()</B> is used instead for standard message reception. <B>appl_read()</B> is required for reading messages that are long and/or of variable length.
<P>
It is recommended that message lengths in multiples of 16 bytes be used.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>appl_write()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>appl_search()</H3>

<P>
<B>WORD appl_search( <I>mode</I>, <I>fname</I>, <I>type</I>, <I>ap_id
</I>)</B>
<P>
<B>WORD <I>mode</I>;</B>
<P>
<B>CHAR *<I>fname</I>;</B>
<P>
<B>WORD *<I>type</I>,*<I>ap_id</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=9><B>appl_search()</B> provides a method of identifying all of the  currently running processes.
</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=9>18 (0x12)</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=9>Available only in <B>AES</B> versions 4.0 and above when <B>appl_getinfo()</B> indicates its presence.
</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=9><I>mode</I> specifies the search mode as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2><I><B><FONT SIZE=1 >Name</FONT></B></I>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >mode</FONT></B></I>
</CENTER>

</TD><TD COLSPAN=4><B><FONT SIZE=2 >Meaning</FONT></B>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2><B>APP_FIRST</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD COLSPAN=4><FONT SIZE=2>Return the filename of the first process</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2><B>APP_NEXT</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD COLSPAN=4><FONT SIZE=2>Return the filename of subsequent processes</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH></TH><TD COLSPAN=9><I>fname</I> should point to a memory location at least 9 bytes long to hold the 8 character process filename found and the <B>NULL</B> byte. <I>type</I> is a pointer to a <B>WORD</B> into which will be placed the process type as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH COLSPAN=3></TH><TD COLSPAN=3><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >type</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=3></TH><TD COLSPAN=3><B>APP_SYSTEM</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x01</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>System process</FONT></TD></TR>

<TR><TH COLSPAN=3></TH><TD COLSPAN=3><B>APP_APPLICATION</B></TD>
<TD>
<CENTER>
<FONT SIZE=2>0x02</FONT>
</CENTER>
</TD><TD><FONT SIZE=2>Application</FONT>
</TD></TR>

<TR><TH COLSPAN=3></TH><TD COLSPAN=3><B>APP_ACCESSORY</B></TD>
<TD>
<CENTER>
<FONT SIZE=2>0x04</FONT>
</CENTER>
</TD><TD><FONT SIZE=2>Accessory</FONT>
</TD></TR>

<TR><TH COLSPAN=3></TH><TD COLSPAN=3><B>APP_SHELL</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x08</FONT>
</CENTER>

</TD><TD></TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH></TH><TD COLSPAN=9>The <I>type</I> parameter is actually a bit mask so it is possible that a process containing more than one characteristic will appear. The currently running shell process (usually the desktop) will return a value of <B>APP_APPLICATION</B> | <B>APP_SHELL</B> (0x0A).
<P>
<I>ap_id</I> is a pointer to a word into which will be placed the processes' application identifier.
</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=9>
<PRE>
intin[0] = mode;

addrin[0] = fname;
addrin[1] = type;
addrin[2] = ap_id;

return crys_if(0x12);
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=9><B>appl_search()</B> returns 0 if no more applications exist or 1 when more processes exist that meet the search criteria.
</TD></TR>

</TABLE>

<P>

<HR>

<H3>appl_tplay()</H3>

<P>
<B>WORD appl_tplay( <I>mem</I>, <I>num</I>, <I>scale </I>)</B>
<P>
<B>VOIDP <I>mem</I>;</B>
<P>
<B>WORD <I>num</I>, <I>scale</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>appl_tplay()</B> plays back events originally recorded with <B>appl_trecord()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>14 (0x0E)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>mem</I> is a pointer to an array of <B>EVNTREC</B> structures (see <B>appl_trecord()</B>). <I>num</I> indicates the number of <B>EVNTREC</B>'s to play back. 
<P>
<I>scale</I> indicates on a scale of 1 to 10000 how fast the <B>AES</B> will <I>attempt</I> to play back your recording. A value of 100 will play it back at recorded speed. A value of 200 will play the events back at twice the recorded speed, and 50 will play back the events at half of the recorded speed. Other values will respond accordingly.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = num;
intin[1] = scale;

addrin[0] = mem;

return crys_if(0x0E);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>appl_tplay()</B> always returns 1 meaning no error occurred.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>This function does not work correctly on <B>AES</B> versions less than 1.40 without a patch program available from Atari Corp.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>appl_trecord()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>appl_trecord()</H3>

<P>
<B>WORD appl_trecord( <I>mem</I>, <I>num </I>)</B>
<P>
<B>VOIDP <I>mem</I>;</B>
<P>
<B>WORD <I>num</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=4><B>appl_trecord()</B> records <B>AES</B> events for later playback.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=4>15 (0x0F)</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=4>All <B>AES</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=4><I>mem</I> points to an array of <I>num</I> <B>EVNTREC</B> structures into which the <B>AES</B> will record events as indicated here:
<PRE>
typedef struct pEvntrec
{
 WORD ap_event;
 LONG ap_value;
} EVNTREC;<I>ap_event</I> defines the required interpretation of <I>ap_value</I> as follows:
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >ap_event</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Event</FONT></B></TD><TD><I><B><FONT SIZE=2 >ap_value</FONT></B></I>
</TD></TR>

<TR><TH></TH><TD><B>APPEVNT_TIMER</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2><a name=timerevents2>Timer</FONT></TD><TD><FONT SIZE=2>Elapsed Time (in milliseconds)</FONT>
</TD></TR>

<TR><TH></TH><TD><B>APPEVNT_BUTTON</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Button</FONT></TD><TD><FONT SIZE=2>low word = state (1 = down)</FONT>
<P>
<FONT SIZE=2>high word = # of clicks</FONT>
</TD></TR>

<TR><TH></TH><TD><B>APPEVNT_MOUSE</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Mouse</FONT></TD><TD><FONT SIZE=2>low word = X pos</FONT>
<P>
<FONT SIZE=2>high word = Y pos</FONT>
</TD></TR>

<TR><TH></TH><TD><B>APPEVNT_KEYBOARD</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Keyboard</FONT></TD><TD><FONT SIZE=2>bits 0-7: ASCII code</FONT>
<P>
<FONT SIZE=2>bits 8-15: scan code</FONT>
<P>
<FONT SIZE=2>bits 16-31: shift key state</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=4>
<PRE>
intin[0] = num;

addrin[0] = mem;

return crys_if(0x0F);
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=4><B>appl_trecord()</B> returns the number of events actually recorded.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=4>This function does not work correctly on <B>AES</B> versions less than 1.40 without a patch program available from Atari Corp.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=4><B>appl_tplay()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=applwrite><H3>appl_write()</H3>

<P>
<B>WORD appl_write( <I>ap_id</I>, <I>length</I>, <I>msg</I> )</B>
<P>
<B>WORD <I>ap_id</I>, <I>length</I>;</B>
<P>
<B>VOIDP <I>msg</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>appl_write()</B> can be used to send a message to a valid message pipe.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>12 (0x0C)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>ap_id</I> is the application identifier of the process to which you wish to send the message. <I>length</I> specifies the number of bytes present in the message. <I>msg</I> is a pointer to a memory buffer with at least <I>length </I>bytes available.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = ap_id;
intin[1] = length;

addrin[0] = msg;

return crys_if(0x0C);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>appl_write()</B> returns 0 if an error occurred or greater than 0 if the message was sent successfully.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Version Notes</B></TH><TD>As of <B>AES</B> version 1.40, desk accessories may send <B>MN_SELECTED</B> messages to the desktop to trigger desktop functions.
<P>
As of <B>AES</B> version 4.00 you can use <B>shel_write(</B>7,...<B>)</B> to 'broadcast' a message to all processes running with the exception of the <B>AES</B> itself, the desktop, and your own application. See <B>shel_write()</B> for details.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>It is recommended that you always send messages in 16 byte blocks using a <B>WORD</B> array of 8 elements as the <B>AES</B> does.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>appl_read()</B>, <B>shel_write()</B>
</TD></TR>

</TABLE>

<H2>Event Library</H2>

<HR>

<P>
The <I>Event Library</I> consists of a group of system calls which
are used to monitor system messages including mouse clicks, keyboard
usage, menu bar interaction, timer calls, and mouse tracking.
The library consists of the following calls:
<P>
 evnt_button()
<P>
 evnt_dclick()
<P>
 evnt_keybd()
<P>
 evnt_mesag()
<P>
 evnt_mouse()
<P>
 evnt_multi()
<P>
 evnt_timer()
<P>
 evnt_button()
<a name=evntbutton2><H3>evnt_button()</H3>

<P>
<B>WORD evnt_button( <I>clicks</I>, <I>mask</I>, <I>state</I>,
<I>mx</I>, <I>my</I>, <I>button</I>, <I>kstate </I>)</B>
<P>
<B>WORD <I>clicks</I>, <I>mask</I>, <I>state</I>;</B>
<P>
<B>WORD *<I>mx</I>, *<I>my</I>, *<I>button</I>, *<I>kstate</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=9><B>evnt_button()</B> releases control to the operating system until the specified <a name=mbe2>mouse button event has occurred.
</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=9>21 (0x15)</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=9>All <B>AES</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=9><I>clicks</I> specifies the number of mouse-clicks that must occur before returning. <I>mask</I> specifies the mouse buttons to wait for as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
<B><FONT SIZE=1 >Name</FONT></B>
</CENTER>

</TD><TD COLSPAN=3>
<CENTER>
<I><B><FONT SIZE=1 >mask</FONT></B></I>
</CENTER>

</TD><TD COLSPAN=4><B><FONT SIZE=2 >Meaning</FONT></B>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>LEFT_BUTTON</B></TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>0x01</FONT>
</CENTER>

</TD><TD COLSPAN=4><FONT SIZE=2>Left mouse button</FONT></TD>
</TR>

<TR><TH></TH><TD COLSPAN=2><B>RIGHT_BUTTON</B></TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>0x02</FONT>
</CENTER>

</TD><TD COLSPAN=4><FONT SIZE=2>Right mouse button</FONT></TD>
</TR>

<TR><TH></TH><TD COLSPAN=2><B>MIDDLE_BUTTON</B></TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>0x04</FONT>
</CENTER>

</TD><TD COLSPAN=4><FONT SIZE=2>Middle button (this button would be the first button to the left of the rightmost button on the device).</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
-
</CENTER>
</TD><TD COLSPAN=3>
<CENTER>
0x08
</CENTER>

<P>

<CENTER>
.
</CENTER>

<P>

<CENTER>
.
</CENTER>

</TD><TD COLSPAN=4><FONT SIZE=2>Other buttons (0x08 is the mask for the button to the immediate left of the middle button. Masks continue leftwards).</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH></TH><TD COLSPAN=9><I>state</I> specifies the button state that must occur before returning as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=3>
<CENTER>
<I><B><FONT SIZE=1 >mask</FONT></B></I>
</CENTER>

</TD><TD COLSPAN=4><B><FONT SIZE=2 >Meaning</FONT></B>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=3>
<CENTER>
0x00
</CENTER>

</TD><TD COLSPAN=4><FONT SIZE=2>All buttons released</FONT></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=3>
<CENTER>
0x01
</CENTER>

</TD><TD COLSPAN=4><FONT SIZE=2>Left button depressed</FONT></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=3>
<CENTER>
0x02
</CENTER>

</TD><TD COLSPAN=4><FONT SIZE=2>Right button depressed</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=3>
<CENTER>
0x04
</CENTER>

</TD><TD COLSPAN=4><FONT SIZE=2>MIddle button depressed</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=3>
<CENTER>
0x08
</CENTER>

<P>

<CENTER>
.
</CENTER>

<P>

<CENTER>
.
</CENTER>

</TD><TD COLSPAN=4><FONT SIZE=2>etc...</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH></TH><TD COLSPAN=9><I>mx</I> is a pointer to a <B>WORD</B> which upon return will contain the x-position of the mouse pointer at the time of the event. <I>my</I> is a pointer to a <B>WORD</B> which upon return will contain the y-position of the mouse pointer at the time of the event.
<P>
<I>button</I> is a pointer to a <B>WORD</B> which upon return will contain the mouse button state as defined in <I>state</I>.
<P>
<I>kstate</I> is a pointer to a <B>WORD</B> which upon return will contain the current status of the keyboard shift keys. The value is a bit-mask defined as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD COLSPAN=3>
<CENTER>
<B><FONT SIZE=2 >Mask</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Key</FONT></B></TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2>K_RSHIFT</TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>0x01</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Right Shift</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2>K_LSHIFT</TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>0x02</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Left Shift</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2>K_CTRL</TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>0x04</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Control</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD COLSPAN=2>K_ALT</TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>0x08</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Alternate</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=9>
<PRE>
intin[0] = clicks;
intin[1] = mask;
intin[2] = state;

crys_if(0x15);

*mx = intout[1];
*my = intout[2];
*button = intout[3];
*kstate = intout[4];

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=9>Upon exit, <B>evnt_button()</B> returns a <B>WORD</B> indicating the number of times the mouse button state matched <I>state</I>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=9>A previously undocumented feature of this call is accessed by logically OR'ing the <I>mask</I> parameter with 0x100. This causes the call to return when independent buttons are depressed. For example, a <I>mask</I> value of 0x03 will return when both the left and right mouse buttons are depressed. A <I>mask</I> value of 0x103 will cause the call to return when either button is depressed.
</TD></TR>

<TR><TH></TH><TD COLSPAN=9></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=9><B>evnt_multi()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>evnt_dclick()</H3>

<P>
<B>WORD evnt_dclick( <I>new</I>, <I>flag </I>)</B>
<P>
<B>WORD <I>new</I>, <I>flag</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=4><B>evnt_dclick()</B> sets the mouse double-click response rate. This call is global, and thus, affects all applications.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=4>26 (0x1A)</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=4>All <B>AES</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=4>If <I>flag</I> is <B>EDC_INQUIRE</B> (0), <I>new</I> is ignored and the current double-click rate is returned. If <I>flag</I> is <B>EDC_SET</B> (1), <I>new</I> specifies the new double-click rate as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
<I><B><FONT SIZE=1 >flag</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Response</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0
</CENTER>

<P>

<CENTER>
1
</CENTER>

<P>

<CENTER>
2
</CENTER>

<P>

<CENTER>
3
</CENTER>

<P>

<CENTER>
4
</CENTER>

</TD><TD><FONT SIZE=2>Slowest</FONT>
<P>
<FONT SIZE=2>Fastest</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=4>
<PRE>
intin[0] = new;
intin[1] = flag;

return crys_if(0x1A);
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=4><B>evnt_dclick()</B> returns the newly set or current double-click rate based on <I>flag</I>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=4>Because this setting is global for all applications, Atari has strongly recommended that developers use this call <I>only</I> where appropriate (such as in a configuration CPX like the General Setup CPX included with <B>XCONTROL</B>). 
</TD></TR>

</TABLE>

<P>

<HR>

<a name=evntkbd2><H3>evnt_keybd()</H3>

<P>
<B>WORD evnt_keybd( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>evnt_keybd()</B> relinquishes program control to the operating system until a valid keypress is available in the applications' message pipe.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>20 (0x14)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD>None</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
return crys_if(0x14);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>evnt_keybd()</B> returns a 16-bit value containing the ASCII code of the key entered in the lower eight bits and the scan code in the upper 8-bits.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Version Notes</B></TH><TD><B>TOS</B> versions released at or above 2.06 and 3.06 disabled reception of keys 1 through 9 on the numeric keypad when used in conjunction with the alternate key. Users may now enter the full range of ASCII values by holding down alt, typing in the decimal ASCII code, and then releasing the alt key. These keys, therefore, should not be used by applications. The standard numeric keypad is still available.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>evnt_multi()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=evnt_mesag2><H3>evnt_mesag()</H3>

<P>
<B>WORD evnt_mesag( <I>msg </I>)</B>
<P>
<B>WORD *<I>msg</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>evnt_mesag()</B> releases control to the operating system until a valid system message is available in the applications' message pipe.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>23 (0x17)</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>All <B>AES</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=5><I>msg</I> is a pointer to an array of 8 <B>WORD'</B>s to be used as a message buffer.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
addrin[0] = msg

return crys_if(0x17);
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=5>The return value is currently reserved by Atari and currently is defined as 1. The array <I>msg</I> is filed in with the following values:
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Index</FONT></B>
</TD><TD COLSPAN=2><B><FONT SIZE=1 >Description</FONT></B>
</TD><TD><B><FONT SIZE=1 >Possible Values</FONT></B>
</TD><TD><B><FONT SIZE=1 >#</FONT></B></TD></TR>

<TR><TH></TH><TD><I>msg[0]</I></TD><TD COLSPAN=2>Message Type
</TD><TD><B>MN_SELECTED</B>
<P>
<B>WM_REDRAW</B>
<P>
<B>WM_TOPPED</B>
<P>
<B>WM_CLOSED</B>
<P>
<B>WM_FULLED</B>
<P>
<B>WM_ARROWED</B>
<P>
<B>WM_HSLID</B>
<P>
<B>WM_VSLID</B>
<P>
<B>WM_SIZED</B>
<P>
<B>WM_MOVED</B>
<P>
<B>WM_UNTOPPED</B>
<P>
<B>WM_ONTOP</B>
<P>
<B>WM_BOTTOM</B>
<P>
<B>WM_ICONIFY</B>
<P>
<B>WM_UNICONIFY</B>
<P>
<B>WM_ALLICONIFY</B>
<P>
<B>WM_TOOLBAR</B>
<P>
<B>AC_OPEN</B>
<P>
<a name=acclose2><B>AC_CLOSE</B>
<P>
<B>AP_TERM</B>
<P>
<B>AP_TFAIL</B>
<P>
<B>AP_RESCHG</B>
<P>
<B>SHUT_COMPLETED</B>
<P>
<B>RESCH_COMPLETED</B>
<P>
<B>AP_DRAGDROP</B>
<P>
<B>SH_WDRAW</B>
<P>
<B>CH_EXIT</B>
</TD><TD>10
<P>
20
<P>
21
<P>
22
<P>
23
<P>
24
<P>
25
<P>
26
<P>
27
<P>
28
<P>
30
<P>
31
<P>
33
<P>
34
<P>
35
<P>
36
<P>
37
<P>
40
<P>
41
<P>
50
<P>
51
<P>
57
<P>
60
<P>
61
<P>
63
<P>
72
<P>
90
</TD></TR>

<TR><TH></TH><TD><I>msg[1]</I></TD><TD COLSPAN=2>The application identifier of the sending application.
</TD><TD>Any valid <I>ap_id</I>.</TD><TD></TD></TR>

<TR><TH></TH><TD><I>msg[2]</I></TD><TD COLSPAN=2>The length of the message <I>beyond</I> 16 bytes (use <B>appl_read()</B> to read the excess).
</TD><TD>Currently all system messages return 0 in this slot. Only user-defined messages utilize a higher value.
</TD><TD></TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH></TH><TD COLSPAN=5>Each system message can be interpreted as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH></TH><TD COLSPAN=2><B><FONT SIZE=1 ><a name=messageevents>Message</FONT></B>
</TD><TD COLSPAN=3><B><FONT SIZE=1 >Extended Information</FONT></B>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>MN_SELECTED</B></TD><TD COLSPAN=3>A menu item has been selected by the user. <I>msg[3]</I> contains the object number of the menu title and <I>msg[4]</I> contains the object number of the menu item. 
<P>
As of <B>AES</B> version 3.30 (and when indicated by <B>appl_getinfo()</B> ), <I>msg[5]</I> and <I>msg[6]</I> contain the high and low word, respectively, of the object tree of the menu item. <I>msg[7]</I> contains the parent object index of the menu item.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>WM_REDRAW</B></TD><TD COLSPAN=3>This message alerts an application that a portion of the screen needs to be redrawn. <I>msg[3]</I> contains the handle of the window to redraw. <I>msg[4-7]</I> are the x, y, w, and h respectively of the 'dirtied' area.
<P>
When the message is received the window contents should be drawn (or a representative icon if the window is iconified).
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>WM_TOPPED</B></TD><TD COLSPAN=3>This message is sent when an application window which is currently not the top window is clicked on by the user. <I>msg[3]</I> contains the handle of the window. 
<P>
You should use <B>wind_set( </B>msg[3], <B>WF_TOP</B>, 0, 0, 0, 0<B>)</B> to actually cause the window to be topped.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>WM_CLOSED</B></TD><TD COLSPAN=3>This message is sent when the user clicks on a windows' close box. <I>msg[3]</I> contains the handle of the window to close. 
<P>
You should react to this message with <B>wind_close()</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>WM_FULLED</B></TD><TD COLSPAN=3>This message is sent when the user clicks on a windows' full box. If the window is not at full size, the window should be resized using <B>wind_set(</B>handle,<B> WF_CURRXYWH</B>,... to occupy the entire screen minus the menu bar (see <B>wind_get()</B>).
<P>
If the window was previously 'fulled' and has not been resized since, the application should return the window to its previous size.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>WM_ARROWED</B></TD><TD COLSPAN=3>This message is sent to inform an application that one of its slider gadgets has been clicked on.
<P>
A row or column message is sent when a slider arrow is selected. A 'page' message is sent when a darkened area of the scroll bar is clicked. This usually indicates that the application should adjust the window's contents by a larger amount than with the row or column messages.
<P>
<I>msg[3]</I> indicates which action was actually selected as follows:<FONT SIZE=2> <U><B>Name Value Meaning</B></U></FONT>
<P>
<FONT SIZE=2> <B>WA_UPPAGE</B> 0 Page Up</FONT>
<P>
<FONT SIZE=2> <B>WA_DNPAGE</B> 1 Page Down</FONT>
<P>
<FONT SIZE=2> <B>WA_UPLINE</B> 2 Row Up</FONT>
<P>
<FONT SIZE=2> <B>WA_DNLINE</B> 3 Row Down</FONT>
<P>
<FONT SIZE=2> <B>WA_LFPAGE</B> 4 Page Left</FONT>
<P>
<FONT SIZE=2> <B>WA_RTPAGE</B> 5 Page Right</FONT>
<P>
<FONT SIZE=2> <B>WA_LFLINE</B> 6 Column Left</FONT>
<P>
<FONT SIZE=2> <B>WA_RTLINE</B> 7 Column Right</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>WM_HSLID</B></TD><TD COLSPAN=3>This message indicates that the horizontal slider has been moved. <I>msg[3]</I> contains the new slider position ranging from 0 to 1000.
<P>
Note: Slider position is relative and not related to slider size.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>WM_VSLID</B></TD><TD COLSPAN=3>This message indicates that the vertical slider has been moved. <I>msg[3]</I> contains the new slider position ranging from 0 to 1000.
<P>
Note: Slider position is relative and not related to slider size.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>WM_SIZED</B></TD><TD COLSPAN=3>This message occurs when the user drags the window sizing gadget. <I>msg[3] </I>contains the window handle. <I>msg[4-7]</I> indicate the x, y, w, and h respectively of the new window location.
<P>
Use <B>wind_set(</B><I>handle</I>, <B>WF_CURRXYWH</B>,... to actually size the window. 
<P>
<B>WM_SIZED</B> and <B>WM_MOVED</B> usually share common handling code.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>WM_MOVED</B></TD><TD COLSPAN=3>This message occurs when the user moves the window by dragging the windows' title bar. <I>msg[3]</I> contains the handle of the window being moved. <I>msg[4-7]</I> indicate the x, y, w, and h respectively of the new window location. 
<P>
Use <B>wind_set(</B><I>handle</I>, <B>WF_CURRXYWH</B>,... <B>)</B> to actually move the window. 
<P>
<B>WM_MOVED</B> and <B>WM_SIZED</B> usually share common handling code.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>WM_UNTOPPED</B></TD><TD COLSPAN=3>This message is sent when the current window is sent behind one or more windows as the result of another window being topped. <I>msg[3]</I> contains the handle of the window being untopped. 
<P>
The application need take no action. The message is for informational use only.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>WM_ONTOP</B></TD><TD COLSPAN=3>This message is sent when an applications' window is brought to the front on a multitasking <B>AES</B>. <I>msg[3]</I> is the handle of the window being brought to the front.
<P>
This message requires no action, it is for informational purposes only.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>WM_BOTTOMED</B></TD><TD COLSPAN=3>This message is sent when the user shift-clicks on the window's (specified in <I>msg</I>[3]) mover bar to indicate that the window should be sent to the bottom of the window stack by using <B>wind_set()</B> with a parameter of <B>WF_BOTTOM</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>WM_ICONIFY</B></TD><TD COLSPAN=3>This message is sent when the user clicks on the <B>SMALLER</B> window gadget. <I>msg</I>[3] indicates the handle of the window to be iconified. <I>msg</I>[4-7] indicate the x, y, w, and h of the iconified window.
<P>
If the iconified window represents a single window this message should be responded to by using <B>wind_set() </B>with a parameter of  <B>WF_ICONIFY</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>WM_UNICONIFY</B></TD><TD COLSPAN=3>This message is sent when the user double-clicks on an iconified window. <I>msg</I>[3] indicates the handle of the window to be iconified. <I>msg</I>[4-7] indicate the x, y, w, and h of the original window.
<P>
This message should be responded to by using <B>wind_set()</B> with a parameter of <B>WF_UNICONIFY</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>WM_ALLICONIFY</B></TD><TD COLSPAN=3>This message is sent when the user ctrl-clicks on the <B>SMALLER</B> window gadget. <I>msg</I>[3] indicates which window's gadget was clicked. <I>msg</I>[4-7] indicates the position at which the new iconified window should be placed.
<P>
The application should respond to this message by closing all open windows and opening a new iconified window at the position indicated which represents the application.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>WM_TOOLBAR</B></TD><TD COLSPAN=3>This message is sent when a toolbar object is clicked. <I>msg</I>[3] contains the handle of the window containing the toolbar.
<P>
<I>msg</I>[4] contains the object index of the object clicked. <I>msg</I>[5] contains the number of clicks. <I>msg</I>[6] contains the state of the keyboard shift keys at the time of the click (as in <B>evnt_keybd()</B> ).
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><a name=acopen2><B>AC_OPEN</B></TD><TD COLSPAN=3>This message is sent when the user has selected a desk accessory to open. <I>msg[4]</I> contains the application identifier (as returned by <B>appl_init()</B>) of the accessory to open.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>AC_CLOSE</B></TD><TD COLSPAN=3>This message is sent to a desk accessory when the accessory should be closed. <I>msg[3]</I> is the application identifier (as returned by <B>appl_init()</B>) of the accessory to close.
<P>
Do not close any windows your accessory had open, the system will do this for you. Also, do not require any feedback from the user when this is received. Treat this message as a 'Cancel' from the user.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>AP_TERM</B></TD><TD COLSPAN=3>This message is sent when the system requests that the application terminate.  This is usually the result of a <a name=resolutionchange>resolution change but may also occur if another application sends this message to gain total control of the system.
<P>
The application should shut down immediately after closing windows, freeing resources, etc... <I>msg[5]</I> indicates the reason for the shut down as follows:<B><FONT SIZE=2> AP_TERM </FONT></B>(50)   = Just shut down.
<P>
<B><FONT SIZE=2> AP_RESCHG </FONT></B>(57) = Resolution Change.<FONT SIZE=2>If for some reason, your process can not shut down you must inform the <B>AES</B> by sending an <B>AP_TFAIL</B> (51) message by using <B>shel_write()</B> mode 10 (see <B>shel_write()</B>).</FONT>
<P>
<FONT SIZE=2>Note: Desk Accessories wil always be sent <B>AC_CLOSE</B> messages, not <B>AP_TERM</B>.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>AP_TFAIL</B></TD><TD COLSPAN=3>This message should be sent to the system (see <B>shel_write()</B>) when an application has received an <B>AP_TERM</B> (50) message and cannot shut down.
<P>
<I>msg[0] </I>should contain <B>AP_TFAIL</B> and <I>msg[1]</I> should contain the application error code.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>AP_RESCHG</B></TD><TD COLSPAN=3>This message is actually a sub-command and is only found as a possible value in the <B>AP_TERM</B> (50) message (see above).
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>SHUT_COMPLETED</B></TD><TD COLSPAN=3>This message is sent to the application which requested a shutdown when the shutdown is complete and was successful.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>RESCH_COMPLETED</B></TD><TD COLSPAN=3>This message is sent to an application when a resolution change it requested is completed. <I>msg[3]</I> contains 1 if the resolution change was successful and 0 if an error occurred.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>AP_DRAGDROP</B></TD><TD COLSPAN=3>This message indicates that another application wishes to initiate a drap and drop session. <I>msg</I>[3] indicates the handle of the window which had an object dropped on it or -1 if no specific window was targeted.
<P>
<I>msg</I>[4-5] contains the X and Y position of the mouse when the object was 'dropped'. <I>msg</I>[6] indicates the keyboard shift state at the time of the drop (as in <B>evnt_keybd()</B> ).
<P>
<I>msg</I>[7] is a two-byte ASCII packed pipe identifier which gives the file extension of the pipe to open.
<P>
For more information about the drag &amp; drop protocal, see <I>Chapter 2: <B>GEMDOS</B></I>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>SH_WDRAW</B></TD><TD COLSPAN=3>This message is sent to the Desktop to ask it to update an open drive window. <I>msg</I>[3] should contain the drive number to update (0 = A:, 1 = B:) or -1 to update all windows.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>CH_EXIT</B></TD><TD COLSPAN=3>This message is sent when a child process that the application has started, returns. <I>msg[3]</I><B> </B>contains the child's application identifier and <I>msg[4]</I> contains its exit code.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Version Notes</B></TH><TD COLSPAN=5><B>WM_UNTOPPED</B>, <B>WM_ONTOP</B>, <B>AP_TERM</B>, <B>AP_TFAIL</B>, <B>AP_RESCHG</B>, <B>SHUT_COMPLETED</B>,  <B>RESCH_COMPLETED</B>, and <B>CH_EXIT</B> are new as of <B>AES</B> version 4.0.
<P>
<B>WM_BOTTOM</B>, <B>WM_ICONIFY</B>, <B>WM_UNICONIFY</B>, <B>WM_ALLICONIFY</B>, and <B>WM_TOOLBAR</B> are new as of <B>AES</B> version 4.1.
<P>
No lower version <B>AES</B> will send these messages.
<P>
The existence (or acceptance) of these messages should also be checked for by using <B>appl_getinfo()</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=5><B>evnt_multi()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<P>
<a name=evnt_mouse2><B>evnt_mouse()</B>
<P>
<B>WORD evnt_mouse( <I>flag</I>, <I>x</I>, <I>y</I>, <I>w</I>,
<I>h</I>, <I>mx</I>, <I>my</I>, <I>button</I>, <I>kstate </I>)</B>
<P>
<B>WORD <I>flag</I>, <I>x</I>, <I>y</I>, <I>w</I>, <I>h</I>;</B>
<P>
<B>WORD *<I>mx</I>, *<I>mx</I>, *<I>button</I>, *<I>kstate</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>evnt_mouse()</B> releases control to the operating system until the mouse enters or leaves a specified area of the screen .
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>22 (0x16)</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>All <B>AES</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=5><I>flag</I> specifies the event to wait for as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD>Name</TD><TD>
<CENTER>
<FONT SIZE=2>Value</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Meaning</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>MO_ENTER</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Wait for mouse to enter rectangle.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>MO_LEAVE</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Wait for mouse to leave rectangle.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH></TH><TD COLSPAN=5>The rectangle to watch is specified in <I>x</I>, <I>y</I>, <I>w</I>, <I>h</I>. <I>mx </I>and <I>my</I> are <B>WORD</B> pointers which will be filled in with the final position of the mouse. 
<P>
<I>button</I> is a <B>WORD</B> pointer which will be filled in upon return with the final state of the mouse button as defined in <B>evnt_button()</B>. 
<P>
<I>kstate</I> is a <B>WORD</B> pointer which will be filled in upon return with the final state of the keyboard shift keys as defined in <B>evnt_button()</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
intin[0] = flag;
intin[1] = x;
intin[2] = y;
intin[3] = w;
intin[4] = h;

crys_if(0x16);

*mx = intout[1];
*my = intout[2];
*button = intout[3];
*kstate = intout[4];

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=5>The return value of this function is reserved. Currently it always returns 1.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=5>The <B>evnt_multi()</B> function can be used to watch two mouse/rectangle events as opposed to one.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=5><B>evnt_multi()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=evnt_multi2><H3>evnt_multi()</H3>

<P>
<B>WORD evnt_multi( <I>events</I>, <I>bclicks</I>, <I>bmask</I>,
<I>bstate</I>, <I>m1flag</I>, <I>m1x</I>, <I>m1y</I>, <I>m1w</I>,
<I>m1h</I>, <I>m2flag</I>, <I>m2x</I>, <I>m2y</I>, <I>m2w</I>,
<I>m2h</I>, <I>msg</I>, <I>locount</I>, <I>hicount</I>, <I>mx</I>,
<I>my</I>,<i>mb</i>, <I>ks</I>, <I>kc</I>, <I>mc </I>)</B>
<P>
<B>WORD <I>events</I>, <I>bclicks</I>, <I>bmask</I>, <I>bstate</I>,
<I>m1flag</I>, <I>m1x</I>, <I>m1y</I>, <I>m1w</I>, <I>m1h</I>,
<I>m2flag</I>, <I>m2x</I>, <I>m2y</I>, <I>m2w</I>, <I>m2h</I>;</B>
<P>
<B>WORD *<I>msg</I>;</B>
<P>
<B>WORD <I>locount</I>, <I>hicount</I>;</B>
<P>
<B>WORD *<I>mx</I>, *<I>my</I>, *<I>ks</I>, *<I>kc</I>, *<I>mc</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>evnt_multi()</B> suspends the application until a valid message that the application is interested in occurs. This call combines the functionality of <B>evnt_button()</B>, <B>evnt_keybd()</B>, <B>evnt_mesag()</B>, <B>evnt_mouse()</B>, and <B>evnt_timer()</B> into one call.
<P>
This call is usually the cornerstone of all <B>GEM</B> applications that must process system events.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>25 (0x19)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>All <B>AES</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>events</I> is a bit mask which tells the function which events your application is interested in. You should logically 'OR' any of the following values together:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Mask</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Function</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>MU_KEYBD</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x01</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Wait for a user keypress.</FONT></TD></TR>

<TR><TH></TH><TD><B>MU_BUTTON</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x02</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Wait for the specified mouse button state.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>MU_M1</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x04</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Wait for a mouse/rectangle event as specified.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>MU_M2</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x08</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Wait for a mouse/rectangle event as specified.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>MU_MESAG</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x10</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Wait for a message.</FONT></TD></TR>

<TR><TH></TH><TD><B>MU_TIMER</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x20</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Wait the specified amount of time.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD COLSPAN=3>For usage of <I>bclicks</I>, <I>bmask</I>, <I>bstate</I>, <I>mx</I>, <I>my</I>, <I>kc</I>, and <I>ks</I>, you should consult <B>evnt_button()</B>.
<P>
For usage of <I>m1flag</I>, <I>m1x</I>, <I>m1y</I>, <I>m1w</I>, <I>m1h</I>, <I>m2flag</I>, <I>m2x</I>, <I>m2y</I>, <I>m2w</I>, and <I>m2h</I>, consult <B>evnt_mouse()</B>.
<P>
For usage of <I>msg</I>, see <B>evnt_mesag()</B>.
<P>
For usage of <I>locount</I> and <I>hicount</I>, see <B>evnt_timer()</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
intin[0] = events;
intin[1] = bclicks;
intin[2] = bmask;
intin[3] = bstate;
intin[4] = m1flag;
intin[5] = m1x;
intin[6] = m1y;
intin[7] = m1w;
intin[8] = m1h;
intin[9] = m2flag;
intin[10] = m2x;
intin[11] = m2y;
intin[12] = m2w;
intin[13] = m2h;
intin[14] = locount;
intin[15] = hicount;

addrin[0] = msg;

crys_if(0x19);

*mx = intout[1];
*my = intout[2];
*mb = intout[3];
*ks = intout[4];
*kc = intout[5];
*mc = intout[6];

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3>The function returns a bit mask of which events actually happened as in <I>events</I>. This may be one or more events and your application should be prepared to handle each.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Version Notes</B></TH><TD COLSPAN=3>The only facet of <B>evnt_multi()</B> which has changed from <B>AES</B> version 4.0 is that which relates to <B>evnt_mesag()</B>. For further information you should consult that section.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=3>Under <B>TOS</B> 1.0, calling this function from a desk accessory with the <B>MU_TIMER</B> mask and <I>locount</I> and <I>hicount</I> being equal to 0 could hang the system.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>evnt_button(), evnt_keybd(), evnt_mesag(), evnt_mouse(), evnt_timer()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=evnt_timer2><H3>evnt_timer()</H3>

<P>
<B>WORD evnt_timer( <I>locount</I>, <I>hicount </I>)</B>
<P>
<B>WORD <I>locount</I>, <I>hicount</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>evnt_timer()</B> releases control to the operating system until a specified amount of time has passed.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>24 (0x18)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>locount</I> is the low word of a 32-bit time value specified in milliseconds.
<P>
<I>hicount</I> is the high portion of that 32-bit value.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = locount;
intin[1] = hicount;

return crys_if(0x18);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD>The return value is reserved and is currently always 1.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>Under <B>TOS</B> 1.0, calling this function from a desk accessory with a both parameters having a value of 0 will hang the system.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This function should not be relyed on as an accurate clock. The time specified is used as a minimum time value only and the function will return at some point after that duration has passed.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>evnt_multi()</B></TD></TR>

</TABLE>

<H2>Form Library</H2>

<HR>

<P>
The <I>Form Library</I> contains utility functions for the use
and control of dialog boxes, alert boxes, and user input. The
members of the <I>Form Library</I> are:
<P>
 form_alert()
<P>
 form_button()
<P>
 form_center()
<P>
 form_dial()
<P>
 form_do()
<P>
 form_error()
<P>
 form_keybd()
<a name=form_alert2><H3>form_alert()</H3>

<P>
<B>WORD form_alert( <I>default</I>, <I>alertstr </I>)</B>
<P>
<B>WORD <I>default</I>;</B>
<P>
<B>CHAR *<I>alertstr</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=4><B>form_alert()</B> displays a standardized alert box and returns the user's selection.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=4>52 (0x34)</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=4>All <B>AES</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=4><I>default </I>contains the number of the exit button which is to be made default (1-3). <I>alertstr</I> contains a formatted string as follows: "[#][Alert Text][Buttons]".
<P>
<I>#</I> specifies the icon to display in the alert as follows:
<center><br><img src="../graphics/chap673.gif"></center><p>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
<B><FONT SIZE=1 >#</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=1 >Icon Displayed</FONT></B>
</CENTER>

</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
0
</CENTER>
</TD><TD>
<CENTER>
No Icon
</CENTER>

</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
1
</CENTER>
</TD><TD>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
2
</CENTER>
</TD><TD>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
3
</CENTER>
</TD><TD>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
4
</CENTER>
</TD><TD>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
5
</CENTER>
</TD><TD>
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH></TH><TD COLSPAN=4><I>'Alert Text'</I> is a text string of as many as 5 lines composed of up to 30 characters each. Each line is separated by a '|' character. 
<P>
'<I>Buttons'</I> is a text string to define as many as 3 buttons up to 10 characters each. If only one button is used, its text may be as long as 30 characters. Again, each button is separated by a '|' character
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=4>
<PRE>
intin[0] = default;

addrin[0] = alertstr;

return crys_if(0x34);
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=4><B>form_alert()</B> returns a <B>WORD</B> indicating which button was used to exit by the user (A possible value of 1-3).
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Version Notes</B></TH><TD COLSPAN=4>Icons #4-5 are only available as of <B>AES</B> version 4.1.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=4>Several versions of the <B>AES</B> have special quirks related to this function. By following the quidelines below you should avoid any difficulty:1. All <B>AES</B> versions below 1.06 have some difficulty formatting alert strings padded with spaces. If you want your alerts to look right on all <B>AES</B> versions, do not pad any button or line with spaces with the exception below.
<P>
2. Add one space to the end of the longest text line on an alert. This will prevent the right edge from touching the border in some <B>AES</B> versions.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=form_button2><H3>form_button()</H3>

<P>
<B>WORD form_button( <I>tree</I>, <I>obj</I>, <I>clicks</I>, <I>newobj
</I>)</B>
<P>
<B>OBJECT *<I>tree</I>;</B>
<P>
<B>WORD <I>obj</I>, <I>clicks</I>, <I>newobj</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>form_button()</B> is a utility function designed to aid in the creation of a custom <B>form_do()</B> handler.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>56 (0x38)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>tree</I> is a pointer to a valid object tree in memory you wish to process button events for. <I>obj</I> is the object index into <I>tree</I> which was clicked on and which needs to be processed. 
<P>
<I>clicks</I> is the number of times the mouse button was clicked. 
<P>
<I>newobj</I> returns the next object to gain edit focus or 0 if there are no editable objects. If the top bit of <I>newobj</I> is set, this indicates that a <B>TOUCHEXIT</B> object was double-clicked.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = obj;
intin[1] = clicks;

addrin[0] = tree;

crys_if(0x38);

*newobj = intout[1];

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>form_button()</B> returns a 0 if it exits finding an <B>EXIT</B> or <B>TOUCHEXIT</B> object selected or 1 otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>To use this function properly, the application should take the following steps:1. Monitor mouse clicks with <B>evnt_multi()</B> or <B>evnt_button()</B>.
<P>
2. When a click occurs, use <B>objc_find()</B> to determine if the click occurred over the object.
<P>
3. If so, call <B>form_button()</B> with the appropriate values.This function was not originally documented by Atari. You may have to add bindings for this function to some earlier 'C' compilers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>form_do(), form_keybd()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=form_center><H3>form_center()</H3>

<P>
<B>WORD form_center( <I>tree</I>, <I>x</I>, <I>y</I>, <I>w</I>,
<I>h </I>)</B>
<P>
<B>OBJECT *<I>tree</I>;</B>
<P>
<B>WORD *<I>x</I>, *<I>y</I>, *<I>w</I>, *<I>h</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>form_center()</B> is used to modify an object's coordinates so that it will appear in the center of the display screen.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>54 (0x36)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>tree</I> points to a valid <B>OBJECT</B> structure (see discussion of resources) which the application wishes to have centered. <I>x</I>, <I>y</I>, <I>w</I>, and <I>h</I>, return a clipping rectangle suitable for use in <B>objc_draw()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
addrin[0] = tree;

crys_if(0x36);

*x = intout[1];
*y = intout[2];
*w = intout[3];
*h = intout[4];

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD>The return value is currently reserved. Currently it equals 1.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The values that <B>form_center()</B> returns in <I>x</I>, <I>y</I>, <I>w</I>, and <I>h</I>, are not necessarily the same as the object's. These values take into account negative borders, outlining, and shadowing. This is meant to provide a suitable clipping rectangle for <B>objc_draw()</B>
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>objc_draw()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=form_dial><H3>form_dial()</H3>

<P>
<B>WORD form_dial( <I>mode</I>, <I>x1</I>, <I>y1</I>, <I>w1</I>,
<I>h1</I>, <I>x2</I>, <I>y2</I>, <I>w2</I>, <I>h2 </I>)</B>
<P>
<B>WORD <I>mode</I>, <I>x1</I>, <I>y1</I>, <I>w1</I>, <I>h1</I>,
<I>x2</I>, <I>y2</I>, <I>w2</I>, <I>h2</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>form_dial()</B> is used to reserve and release screen space for dialog usage. In addition, it also optionally provides  grow/shrink box effects.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>51 (0x33)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>All <B>AES</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>mode</I> specifies the action to take and the meaning of remaining parameters as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<B><FONT SIZE=2 >#</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Action</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>FMD_START</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This mode reserves the screen space for a dialog. <I>x2</I>, <I>y2</I>, <I>w2</I>, and <I>h2</I>, contain the coordinates of the dialog to be used (usually obtained through <B>form_center()</B>).</FONT>
</TD></TR>

<TR><TH></TH><TD><B>FMD_GROW</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This mode draws an expanding box from the coordinates specified in <I>x1</I>, <I>y1</I>, <I>w1</I>, and <I>h1</I> to the coordinates specified in <I>x2</I>, <I>y2</I>, <I>w2</I>, and <I>h2</I>. This call is optional and is not required to display a dialog.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>FMD_SHRINK</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This mode draws a shrinking box from the coordinates specified in <I>x2</I>, <I>y2</I>, <I>w2</I>, and <I>h2</I> to the coordinates specified in <I>x1</I>, <I>y1</I>, <I>w1</I>, and <I>h1</I>. This call is optional and is not required to display a dialog.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>FMD_FINISH</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This mode releases the screen space for a dialog (previously reserved with mode 0). <I>x2</I>, <I>y2</I>, <I>w2</I>, and <I>h2</I> contain the coordinates of the space to release. One of the side-effects of this call is a <B>WM_REDRAW</B> message sent to any window which the dialog was covering.</FONT>
</TD></TR>

<TR><TH></TH><TD></TD><TD></TD><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
intin[0] = mode;
intin[1] = x1;
intin[2] = y1;
intin[3] = w1;
intin[4] = h1;
intin[5] = x2;
intin[6] = y2;
intin[7] = w2;
intin[8] = h2;

return crys_if(0x33);
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3>The function returns 0 is an error occurred or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Version Notes</B></TH><TD COLSPAN=3>The<B> AES</B> does not currently make use of mode <B>FMD_START</B>. The call should, however, still be executed for upward compatibility.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>graf_growbox()</B>, <B>graf_shrinkbox()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=form_do2><H3>form_do()</H3>

<P>
<B>WORD form_do( <I>tree</I>, <I>editobj </I>)</B>
<P>
<B>OBJECT *<I>tree</I>;</B>
<P>
<B>WORD <I>editobj</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>form_do()</B> provides an automated dialog handling function to the calling application. It suspends program control, handling all radio buttons, selectable objects, etc... until an object with the <B>TOUCHEXIT</B> or <B>EXIT</B> flag is selected.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>50 (0x32)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>tree</I> is a pointer to a valid object tree (see the discussion on objects in this chapter) which contains a dialog with at least one <B>EXIT</B> or <B>TOUCHEXIT</B> button or object. 
<P>
<I>editobj</I> is the object index into tree which specifies the desired initial location of the edit cursor (the object must be flagged as <B>EDITABLE</B>). If the form has no text editable fields, you should use 0.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = editobj;

addrin[0] = tree;

return crys_if(0x32);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>form_do()</B> returns the object index of the <B>EXIT</B> or <B>TOUCHEXIT</B> button which was selected. If the object was double clicked, bit 15 will be set. This means that to obtain the actual object number you should mask off the result with 0x7FFF.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=form_error2><H3>form_error()</H3>

<P>
<B>WORD form_error( <I>error </I>)</B>
<P>
<B>WORD <I>error</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=4><B>form_error()</B> displays a pre-defined error alert box to the user.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=4>53 (0x35)</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=4>All <B>AES</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=4><I>error</I> specifies a <B>MS-DOS</B> error code as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<B><FONT SIZE=2 >GEMDOS Error #</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >error</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Message</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>FERR_FILENOTFOUND</B></TD><TD>
<CENTER>
<FONT SIZE=2>-33</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>
</TD><TD><B><FONT SIZE=2>File Not Found</FONT></B>
<P>
<FONT SIZE=2>The application can not find the folder or file that you tried to access.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>FERR_PATHNOTFOUND</B></TD><TD>
<CENTER>
<FONT SIZE=2>-34</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>
</TD><TD><B><FONT SIZE=2>Path Not Found</FONT></B>
<P>
<FONT SIZE=2>The application cannot find the folder or file that you tried to access.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>FERR_NOHANDLES</B></TD><TD>
<CENTER>
<FONT SIZE=2>-35</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>
</TD><TD><B><FONT SIZE=2>No More File Handles</FONT></B>
<P>
<FONT SIZE=2>The application does not have room to open another document. To make room, close any open document that you do not need.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>FERR_ACCESSDENIED</B></TD><TD>
<CENTER>
<FONT SIZE=2>-36</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>
</TD><TD><B><FONT SIZE=2>Access Denied</FONT></B>
<P>
<FONT SIZE=2>An item with this name already exists in the directory, or this item is set to read-only status.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>FERR_LOWMEM</B></TD><TD>
<CENTER>
<FONT SIZE=2>-39</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>8</FONT>
</CENTER>
</TD><TD><B><FONT SIZE=2>Insufficient Memory</FONT></B>
<P>
<FONT SIZE=2>There is not enough memory for the application you just tried to run.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>FERR_BADENVIRON</B></TD><TD>
<CENTER>
<FONT SIZE=2>-41</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>10</FONT>
</CENTER>
</TD>
<TD><B><FONT SIZE=2>Invalid Environment</FONT></B>
<P>
<FONT SIZE=2>There is not enough memory for the application you just tried to run.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>FERR_BADFORMAT</B></TD><TD>
<CENTER>
<FONT SIZE=2>-42</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>11</FONT>
</CENTER>
</TD>
<TD><B><FONT SIZE=2>Invalid Format</FONT></B>
<P>
<FONT SIZE=2>There is not enough memory for the application you just tried to run.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>FERR_BADDRIVE</B></TD><TD>
<CENTER>
<FONT SIZE=2>-46</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>15</FONT>
</CENTER>
</TD>
<TD><B><FONT SIZE=2>Invalid Drive Specification</FONT></B>
<P>
<FONT SIZE=2>The drive you specified does not exist.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>FERR_DELETEDIR</B></TD><TD>
<CENTER>
<FONT SIZE=2>-47</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>16</FONT>
</CENTER>
</TD>
<TD><B><FONT SIZE=2>Attempt To Delete Working Directory</FONT></B>
<P>
<FONT SIZE=2>You cannot delete the folder in which you are working.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>FERR_NOFILES</B></TD><TD>
<CENTER>
<FONT SIZE=2>-49</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>18</FONT>
</CENTER>
</TD>
<TD><B><FONT SIZE=2>No More Files</FONT></B>
<P>
<FONT SIZE=2>The application can not find the folder or file that you tried to access.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH></TH><TD COLSPAN=4>The <B>GEMDOS</B> error number can be translated into a <B>MS-DOS</B> code by subtracting 31 from the absolute value of the error code.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=4>
<PRE>
intin[0] = error;

return crys_if(0x35);
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=4>The function returns the exit button clicked as in <B>form_alert()</B>. It is, however, insignifigant as all of the error alerts have only one button.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=4>Not every <B>GEMDOS</B> error code has a matching alert box.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=4><B>form_alert()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=form_kbd2><H3>form_keybd()</H3>

<P>
<B>WORD form_keybd( <I>tree</I>, <I>obj</I>, <I>nextobj</I>, <I>kc</I>,
<I>newobj</I>, <I>keyout </I>)</B>
<P>
<B>OBJECT *<I>tree</I>;</B>
<P>
<B>WORD <I>obj</I>, <I>nextobj</I>, <I>kc</I>;</B>
<P>
<B>WORD *<I>newobj</I>, *<I>keyout</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>form_keybd()</B> processes keyboard input for dialog box control. It handles special keys such as return, escape, tab, etc... It is only of real use if you are writing a customized <B>form_do() </B>routine.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>55 (0x37)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>tree</I> points to a valid <B>OBJECT</B> tree containing the dialog you wish to process. <I>obj</I> is the object index of the object which currently has edit focus (0 if none). <I>nextobj</I> is reserved and should be 1.
<P>
<I>kc</I> is the value returned from <B>evnt_keybd()</B> or <B>evnt_multi()</B> which represents the keypresses' scan code and ASCII value.
<P>
<I>newobj</I> is a <B>WORD</B> pointer which is filled in on function exit to be the new object with edit focus unless the return key was pressed with a default object present in which case it equals the object index of the object that was the default.
<P>
<I>keyout</I> is the value ready to be passed on to <B>objc_edit()</B> if no processing was required or 0 if the key was processed and handled by the call.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = obj;
intin[1] = kc;
intin[2] = nextobj;

addrin[0] = tree;

crys_if(0x37);

*newobj = intout[1];
*keyout = intout[2];

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>form_keybd()</B> returns 0 if a default <B>EXIT</B> object was triggered by this call or 1 if the dialog should continue to be processed.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This function was not originally documented by Atari. You may need to add bindings for this function into some older 'C' compilers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>objc_edit()</B>, <B>form_do(), form_button()</B>
</TD></TR>

</TABLE>

<a name=filesel><H2>File Selector Library</H2>

<HR>

<P>
The <I>File Selector Library</I> contains two functions for displaying
the system file selector (or currently installed alternate file
selector) and prompting the user to select a file. The members
of this library are:
<P>
 fsel_exinput()
<P>
 fsel_input()
<H3>fsel_exinput()</H3>

<P>
<B>WORD fsel_exinput( <I>path</I>, <I>file</I>, <I>button</I>,
<I>title </I>)</B>
<P>
<B>CHAR *<I>path</I>, *<I>file</I>;</B>
<P>
<B>WORD *<I>button</I>;</B>
<P>
<B>CHAR *<I>title</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>fsel_exinput()</B> displays the system file selector and offers the user an opportunity to choose a complete <B>GEMDOS</B> path specification.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>91 (0x5B)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available from <B>AES</B> version 1.40.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>path</I> should be a pointer to a character buffer at least 128 bytes long (applications wishing to access CD-ROM's  should allocate at least 200 bytes). On input the buffer should contain a complete <B>GEMDOS</B> path specification including a drive specifier, path string, and wildcard mask as follows: 'drive:\path\mask'. The mask can be any valid <B>GEMDOS</B> wildcard (usually *.*).
<P>
On function exit, <I>path</I> contains final path of the selected file (you will have to strip the mask). 
<P>
<I>file</I> should point to a character buffer 13 bytes long (12 character filename plus <B>NULL</B>). On input its contents will be placed on the filename line of the selector (usually this value can simply be a empty string). On function exit, <I>file</I> contains the filename which the user selected.
<P>
<I>button</I> is a short pointer which upon function exit will contain <B>FSEL_CANCEL&nbsp;</B>(0) if the user selected <B>CANCEL</B> or <B>FSEL_OK&nbsp;</B>(1) if <B>OK</B>. 
<P>
<I>title</I> should be a pointer to a character string up to 30 characters long which contains the title to appear in the file selector (usually indicates which action the user is about to take).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
addrin[0] = path;
addrin[1] = file;
addrin[2] = label;

crys_if(0x5B);

*button = intout[1];

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>fsel_exinput()</B> returns 0 if an error occured and 1 otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Version Notes</B></TH><TD>Some 'C' compilers (Lattice for example) provide a special function which allows <B>fsel_exinput()</B> to be used even on earlier <B>AES</B> versions.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The path parameter to this function should be validated to ensure that the path actually exists prior to calling this function to prevent confusing the user.
<P>
This call should always be used as opposed to <B>fsel_input()</B> when it is available. Otherwise, the user has no reminder as to what function s/he is actually undertaking.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>fsel_input()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=fsel_input2><H3>fsel_input()</H3>

<P>
<B>WORD fsel_input( <I>path</I>, <I>file</I>, <I>button </I>)</B>
<P>
<B>CHAR *<I>path</I>, *<I>file</I>;</B>
<P>
<B>WORD *<I>button</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>fsel_input()</B> displays the system file selector and allows the user to select a valid <B>GEMDOS</B> path and file.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>90 (0x5A)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD>All parameters are consistent with <B>fsel_exinput()</B> with the notable lack of <I>title</I>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
addrin[0] = path;
addrin[1] = file;

crys_if(0x5A);

*button = intout[1];

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>fsel_input()</B> returns a 0 if an error occurred or 1 otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>You should never use this function in place of <a name=fse2><B>fsel_exinput()</B> when <B>fsel_exinput()</B> is available.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>fsel_exinput()</B></TD></TR>

</TABLE>

<P>

<H2>Graphics Library</H2>

<HR>

<P>
The <I>Graphics Library</I> provides applications with a variety
of utility functions which serve to provide common screen effects,
mouse control, and the obtaining of basic screen attributes. The
functions of the <I>Graphics Library </I>are as follows:
<P>
 graf_dragbox()
<P>
 graf_growbox()
<P>
 graf_handle()
<P>
 graf_mkstate()
<P>
 graf_mouse()
<P>
 graf_movebox()
<P>
 graf_rubberbox()
<P>
 graf_shrinkbox()
<P>
 graf_slidebox()
<P>
 graf_watchbox()
<a name=graf_db2><H3>graf_dragbox()</H3>

<P>
<B>WORD graf_dragbox( <I>w</I>, <I>h</I>, <I>sx</I>, <I>sy</I>,
<I>bx</I>, <I>by</I>, <I>bw</I>, <I>bh</I>, <I>endx</I>, <I>endy
</I>)</B>
<P>
<B>WORD <I>w</I>, <I>h</I>, <I>sx</I>, <I>sy</I>, <I>bx</I>, <I>by</I>,
<I>bw</I>, <I>bh</I>;</B>
<P>
<B>WORD *<I>endx</I>, *<I>endy</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>graf_dragbox()</B> allows the user to move a box frame within the constraints of a bounding rectangle. This call is most often used to give the user a visual 'clue' when an object is being moved on screen.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>71 (0x47)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>w</I> and <I>h</I> specify the initial width and height of the box to draw. <I>sx</I> and <I>sy</I> specify the starting <I>x</I> and <I>y</I> screen coordinates. 
<P>
<I>bx</I>, <I>by</I>, <I>bw</I>, and <I>bh</I>, give the coordinates of the bounding rectangle. 
<P>
<I>endx</I> and <I>endy</I> are <B>WORD</B> pointers which, on function exit, will be filled in with the ending x and y position of the box.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = w;
intin[1] = h;
intin[2] = sx;
intin[3] = sy;
intin[4] = bx;
intin[5] = by;
intin[6] = bw;
intin[7] = bh;

crys_if(0x47);

*endx = intout[1];
*endy = intout[2];

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>graf_dragbox()</B> returns a 0 if an error occurred during execution or greater than zero otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call should be made only when the mouse button is depressed. The call returns when the mouse button is released.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>graf_slidebox()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=graf_grow2><H3>graf_growbox()</H3>

<P>
<B>WORD graf_growbox( <I>x1</I>, <I>y1</I>, <I>w1</I>, <I>h1</I>,
<I>x2</I>, <I>y2</I>, <I>w2</I>, <I>h2 </I>)</B>
<P>
<B>WORD <I>x1</I>, <I>y1</I>, <I>w2</I>, <I>h2</I>, <I>x2</I>,
<I>y2</I>, <I>w2</I>, <I>h2</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>graf_growbox()</B> is used to provide a visual 'clue' to a user by animating an outline of a box from one set of coordinates to another.  It is the complement function to <B>graf_shrinkbox()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>73 (0x49)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>x1</I>, <I>y1</I>, <I>w1</I>, and <I>h1</I> are the screen coordinates of the starting rectangle (where the outline will grow from).
<P>
<I>x2</I>, <I>y2</I>, <I>w2</I>, and <I>h2</I> are the screen coordinates of the ending rectangle (where the outline will grow to).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = x1;
intin[1] = y1;
intin[2] = w1;
intin[3] = h1;
intin[4] = x2;
intin[5] = y2;
intin[6] = w2;
intin[7] = h2;

return crys_if(0x49);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>graf_growbox()</B> returns 0 if an error occured or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>There is currently no defined method of handling an error generated by this function.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This function is what is called by <B>GEM</B>'s <B>form_dial(FMD_GROW</B>,...
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>form_dial(), graf_shrinkbox()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=graf_handle2><H3>graf_handle()</H3>

<P>
<B>WORD graf_handle( <I>wcell</I>, <I>hcell</I>, <I>wbox</I>,
<I>hbox </I>);</B>
<P>
<B>WORD *<I>wcell</I>, *<I>hcell</I>, *<I>wbox</I>, *<I>hbox</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>graf_handle()</B> returns important information regarding the physical workstation currently in use by the <B>AES</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>77 (0x4D)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>wcell</I> and <I>hcell</I> are <B>WORD</B> pointers which on function exit will be filled in with the width and height, respectively, of the current system character set.
<P>
<I>wbox</I> and <I>hbox</I> are <B>WORD</B> pointers which on function exit will be filled in with the width and height, respectively, of the minimum bounding box of a <B>BOXCHAR</B> character.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
crys_if(0x4D);

*charw = intout[1];
*charh = intout[2];
*boxw = intout[3];
*boxh = intout[4];

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD>This function returns the <a name=fdc><B>VDI</B> handle for the current physical workstation used by the <B>AES</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>There is currently no defined method of handling an error generated by this function.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The return value of this function is required to open a virtual screen workstation.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>v_opnvwk()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=graf_mkstate2><H3>graf_mkstate()</H3>

<P>
<B>WORD graf_mkstate( <I>mx</I>, <I>my</I>, <I>mb</I>, <I>ks </I>)</B>
<P>
<B>WORD *<I>mx</I>, *<I>my</I>, *<I>mb</I>, *<I>ks</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>graf_mkstate()</B> returns information about the current state of the mouse pointer, buttons, and keyboard shift-key state.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>79 (0x4F)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>mx</I> and my are <B>WORD</B> pointers, which, on function exit will be filled in with the current x and y coordinates of the mouse pointer. <I>mb</I> is a <B>WORD</B> pointer, which, on function exit will be filled in with the current button state of the mouse as defined in <B>evnt_button()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
crys_if(0x4F);

*mx = intout[1];
*my = intout[2];
*mb = intout[3];
*ks = intout[4];

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD>The function return is currently reserved and currently equals 1.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>evnt_button()</B>, <B>vq_mouse()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=graf_mouse2><H3>graf_mouse()</H3>

<P>
<B>WORD graf_mouse( <I>mode</I>, <I>formptr </I>)</B>
<P>
<B>WORD <I>mode</I>;</B>
<P>
<B>VOIDP <I>formptr</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=4><B>graf_mouse()</B> alters the appearance of the mouse form and can be used to hide and display the mouse pointer from the screen.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=4>78 (0x4E)</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=4>All <B>AES</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=4><I>mode</I> is defined as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH></TH><TD><I><B><FONT SIZE=1 >mode</FONT></B></I>
</TD><TD>
<CENTER>
<B><FONT SIZE=2 >#</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
<TD><B><FONT SIZE=2 >Shape</FONT></B></TD></TR>

<TR><TH></TH><TD><B>ARROW</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Change the current mouse cursor shape.</FONT>
</TD><TD></TD></TR>

<TR><TH></TH><TD><B>TEXT_CRSR</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Change the current mouse cursor shape.</FONT>
</TD><TD></TD></TR>

<TR><TH></TH><TD><B>BUSY_BEE</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Change the current mouse cursor shape.</FONT>
</TD><TD></TD></TR>

<TR><TH></TH><TD><B>POINT_HAND</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Change the current mouse cursor shape.</FONT>
</TD><TD></TD></TR>

<TR><TH></TH><TD><B>FLAT_HAND</B></TD><TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Change the current mouse cursor shape.</FONT>
</TD><TD></TD></TR>

<TR><TH></TH><TD><B>THIN_CROSS</B></TD><TD>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Change the current mouse cursor shape.</FONT>
</TD><TD></TD></TR>

<TR><TH></TH><TD><B>THICK_CROSS</B></TD><TD>
<CENTER>
<FONT SIZE=2>6</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Change the current mouse cursor shape.</FONT>
</TD><TD></TD></TR>

<TR><TH></TH><TD><B>OUTLN_CROSS</B></TD><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Change the current mouse cursor shape.</FONT>
</TD><TD></TD></TR>

<TR><TH></TH><TD><B>USER_DEF</B></TD><TD>
<CENTER>
<FONT SIZE=2>255</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Change the current mouse cursor shape.</FONT>
</TD><TD><FONT SIZE=2>Form is defined below.</FONT></TD></TR>

<TR><TH></TH><TD><B>M_OFF</B></TD><TD>
<CENTER>
<FONT SIZE=2>256</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Remove the mouse cursor from the screen.</FONT>
</TD><TD><FONT SIZE=2>No shape change.</FONT></TD></TR>

<TR><TH></TH><TD><B>M_ON</B></TD><TD>
<CENTER>
<FONT SIZE=2>257</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Display the mouse cursor.</FONT></TD><TD><FONT SIZE=2>No shape change.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>M_SAVE</B></TD><TD>
<CENTER>
<FONT SIZE=2>258</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Save the current mouse form in an <B>AES</B> provided buffer. Check <B>appl_getinfo()</B> for the presence of this feature.</FONT>
</TD><TD><FONT SIZE=2>No shape change.</FONT></TD></TR>

<TR><TH></TH><TD><B>M_LAST</B></TD><TD>
<CENTER>
<FONT SIZE=2>259</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Restore the most recently saved mouse form. Check <B>appl_getinfo()</B> for the presence of this feature.</FONT>
</TD><TD><FONT SIZE=2>Changes the shape as indicated.</FONT></TD>
</TR>

<TR><TH></TH><TD><B>M_RESTORE</B></TD><TD>
<CENTER>
<FONT SIZE=2>260</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Restore the mouse form to its last shape. Check <B>appl_getinfo()</B> for the presence of this feature.</FONT>
</TD><TD><FONT SIZE=2>Changes the shape as indicated.</FONT></TD>
</TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH></TH><TD COLSPAN=4>If <I>mode</I> is equal to <B>USER_DEF</B>, <I>formptr</I> must point to a <B>MFORM</B> structure as defined below (if <I>mode</I> is different than <B>USER_DEF</B>, <I>formptr</I> should be <B>NULL</B>):
<PRE>
typedef struct {
 short mf_xhot;
 short mf_yhot;
 short mf_nplanes;
 short mf_fg;
 short mf_bg;
 short mf_mask[16];
 short mf_data[16];
} MFORM;
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=4><I>mf_xhot</I> and <I>mf_yhot</I> are the location of the mouse 'hot-spot'. These values should be in the range 0 to 15 and define what offset into the bitmap is actually the 'point'. 
<P>
<I>mf_nplanes</I> specifies the number of bit-planes used by the mouse pointer. Currently, the value of 1 is the only legal value.
<P>
<I>mf_fg</I> and <I>mf_bg</I> are the mask and data colors of the mouse specified as palette indexes. Usually these values will be 0 and 1 respectively.
<P>
<I>mf_mask</I> is an array of 16 <B>WORD'</B>s which define the mask portion of the mouse form. <I>mf_data</I> is an array of 16 <B>WORD'</B>s which define the data portion of the mouse form.
<P>
As of <B>AES</B> 4.0 and beyond, the <B>AES</B> may not allow a mouse form to change to benefit another application. If it is absolutely necessary for the application to display its mouse form, logically OR the mode parameter with <B>M_FORCE</B> (0x8000) and make the call.
<P>
This will force the <B>AES</B> to change to your mouse form. It should, however, be done within the scope of a <B>wind_update()</B> sequence.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=4>
<PRE>
intin[0] = mode;

addrin[0] = formptr;

return crys_if(0x4E);
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=4><B>graf_mouse()</B> returns a 0 if an error occurred or non-zero  otherwise.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=4>There is currently no defined method of handling an error generated by this function.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=4><B>vsc_form()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<a name=graf_movebox2><H3>graf_movebox()</H3>

<P>
<B>WORD graf_movebox( <I>bw</I>, <I>bh</I>, <I>sx</I>, <I>sy</I>,
<I>ex</I>, <I>ey </I>)</B>
<P>
<B>WORD <I>bw</I>, <I>bh</I>, <I>sx</I>, <I>sy</I>, <I>ex</I>,
<I>ey</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>graf_movebox()</B> animates a moving box between two points on the screen. It is used to give the user a visual 'clue' to an action undertaken by the application.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>72 (0x48)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>bw</I> and <I>bh</I> specify the width and height, respectively, of the box to animate. <I>sx</I> and <I>sy</I> specify the starting coordinates of the box. <I>ex</I> and <I>ey</I> specify the ending coordinates of the box.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = bw;
intin[1] = bh;
intin[2] = sx;
intin[3] = sy;
intin[4] = ex;
intin[5] = ey;

return crys_if(0x48);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD>The return value is 0 if an error occured or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>There is currently no defined method for handling an error generated by this call.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Some older 'C' bindings referred to this call as <B>graf_mbox()</B>. If your compiler still uses this call you should update it.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=rubberbox2><H3>graf_rubberbox()</H3>

<P>
<B>WORD graf_rubberbox( <I>bx</I>, <I>by</I>, <I>minw</I>, <I>minh</I>,
<I>endw</I>, <I>endh </I>)</B>
<P>
<B>WORD <I>bx</I>, <I>by</I>, <I>minw</I>, <I>minh</I>;</B>
<P>
<B>WORD *<I>endw</I>, *<I>endh</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>graf_rubberbox()</B> allows the user to change the size of a box outline with a fixed starting point.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>70 (0x46)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>bx</I> and <I>by</I> define the fixed upper-left corner of the box to stretch or shrink. 
<P>
<I>minw</I> and <I>minh</I> specify the minimum width and height that the rectangle can be shrunk to. 
<P>
<I>endw</I> and <I>endh</I> are <B>WORD</B> pointers which will be filled in with the ending width and height of the box when the mouse button is released. 
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = bx;
intin[1] = by;
intin[2] = minw;
intin[3] = minh;

crys_if(0x46);

*endw = intout[1];
*endh = intout[2];

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>graf_rubberbox()</B> returns 0 if an error occurred or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>There is currently no defined method for handling an error generated by this call.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This function should only be entered when the user has depressed the mouse button as it returns when the mouse button is released.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>graf_dragbox(), graf_slidebox()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=shrinkbox2><H3>graf_shrinkbox()</H3>

<P>
<B>WORD graf_shrinkbox( <I>x1</I>, <I>y1</I>, <I>w1</I>, <I>h1</I>,
<I>x2</I>, <I>y2</I>, <I>w2</I>, <I>h2 </I>)</B>
<P>
<B>WORD <I>x1</I>, <I>y1</I>, <I>w1</I>, <I>h1</I>, <I>x2</I>,
<I>y2</I>, <I>w2</I>, <I>h2</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>graf_shrinkbox()</B> displays an animated box shrinking from one rectangle to another. It should be used to provide the user with a visual 'clue' to an action. It is the complement function to <B>graf_growbox()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>74 (0x4A)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>x1</I>, <I>y1</I>, <I>w1</I>, and <I>h1</I> are the coordinates of the rectangle to shrink to.
<P>
<I>x2</I>, <I>y2</I>, <I>w2</I>, and <I>h2</I> are the coordinates of the rectangle to shrink from.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = x1;
intin[1] = y1;
intin[2] = w1;
intin[3] = h1;
intin[4] = x2;
intin[5] = y2;
intin[6] = w2;
intin[7] = h2;

return crys_if(0x4A);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD>The function returns 0 if an error occurred or non-zero otherwise
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>There is currently no defined method of handling an error from this call.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This function is essentially the same as <B>form_dial(FMD_SHRINK</B>,...
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>form_dial(), graf_growbox()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=slidebox2><H3>graf_slidebox()</H3>

<P>
<B>WORD graf_slidebox( <I>tree</I>, <I>parent</I>, <I>obj</I>,
<I>orient </I>)</B>
<P>
<B>OBJECT *<I>tree</I>;</B>
<P>
<B>WORD <I>parent</I>, <I>obj</I>,<I>orient</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>graf_slidebox()</B> allows the user to slide a child object within the bounds of its parent. It is often used to implement slider controls.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>76 (0x4C)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>tree</I> is pointer to the object tree containing the child and parent objects.
<P>
<I>parent</I> is the object index of an object which bounds the movement of the child. <I>child</I> is the object index of the object which can be moved within the bounds of <I>parent</I>. 
<P>
<I>orient</I> specifies the orientation of the allowed movement. 0 is horizontal (left-right), 1 is vertical (up-down).
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = parent;
intin[1] = child;
intin[2] = orient;

addrin[0] = tree;

return crys_if(0x4C);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD>The function returns a value specifying the relative offset of the child within the parent as a number between 0 and 1000.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call can be used easily with sliders built into <a name=dialogs2>dialogs by making the slider bar a <B>TOUCHEXIT</B> and calling this function when it is clicked. This call should only be made when the mouse button is depressed as it returns when it is released.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>graf_movebox()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>graf_watchbox()</H3>

<P>
<B>WORD graf_watchbox( <I>tree</I>, <I>obj</I>, <I>instate</I>,
<I>outstate </I>)</B>
<P>
<B>OBJECT *<I>tree</I>;</B>
<P>
<B>WORD <I>obj</I>, <I>instate</I>, <I>outstate</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>graf_watchbox()</B> modifies the given state of a specified object depending on whether the pointer is within the bounds of  the object or outside the bounds of the object as long as the left mouse button is held down.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>75 (0x4B)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>tree</I> is a pointer to the <B>ROOT</B> object of the tree which contains the object you wish to watch. <I>obj</I> is the object index of the object to watch.
<P>
<I>instate</I> is the <I>ob_state</I> (see <B>objc_change()</B>) to apply while the mouse is inside of the bounds of the object.
<P>
<I>outstate</I> is the <I>ob_state</I> to apply while the mouse is outside of the bounds of the object.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = 0;
intin[1] = obj;
intin[2] = instate;
intin[3] = outstate;

addrin[0] = tree;

return crys_if(0x4B);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>graf_watchbox()</B> returns a 0 if the mouse button was released outside of the object or a 1 if the button was released inside of the object.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>As this call returns when the mouse button is released, it should only be made when the mouse button is depressed. This call is used internally by <B>form_button()</B> and <B>form_do()</B> and is usually only necessary if you are replacing one of these handlers.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>form_button()</B></TD></TR>

</TABLE>

<H2>Menu Library</H2>

<HR>

<P>
The <I>Menu Library</I> assists in the handling of system menu
bars and <a name=popupmenus2>popup menus. In addition, individual control of menu
items can also be handled through these functions. The members
of the <I>Menu Library</I> are:
<P>
 <a name=menattach>menu_attach()
<P>
 menu_bar()
<P>
 menu_icheck()
<P>
 menu_ienable()
<P>
 menu_istart
<P>
 menu_popup()
<P>
 menu_register()
<P>
 menu_settings()
<P>
 menu_text()
<P>
 menu_tnormal()
<H3>menu_attach()</H3>

<P>
<B>WORD menu_attach( <I>flag</I>, <I>tree</I>, <I>item</I>, <I>mdata
</I>)</B>
<P>
<B>WORD <I>flag</I>;</B>
<P>
<B>OBJECT *<I>tree</I>;</B>
<P>
<B>WORD <I>item</I>;</B>
<P>
<B>MENU *<I>mdata</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=4><B>menu_attach()</B> allows an application to attach, change, or remove a sub-menu. It also allows the application to inquire information regarding a currently defined sub-menu.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=4>37 (0x25)</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=4>This function is only available from <B>AES</B> version 3.30 and above. In <B>AES</B> versions 4.0 and greater, <B>appl_getinfo()</B> should be used to determine its exact functionality.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=4><I>flag</I> indicates the action the application desires as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B><FONT SIZE=1 >#</FONT></B>
</CENTER>

</TD><TD COLSPAN=2><B><FONT SIZE=2 >Define</FONT></B>
</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD>
<CENTER>
0
</CENTER>
</TD><TD COLSPAN=2><B><FONT SIZE=2>ME_INQUIRE</FONT></B>
</TD><TD><FONT SIZE=2>Return information on a sub-menu attached to the menu item designated by <I>tree</I> and <I>item</I> in <I>mdata</I>.</FONT>
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
1
</CENTER>
</TD><TD COLSPAN=2><B><FONT SIZE=2>ME_ATTACH</FONT></B>
</TD><TD><FONT SIZE=2>Attach or change a sub-menu. <I>mdata</I> should be initialized by the application. </FONT>
<P>
<I><FONT SIZE=2>tree</FONT></I> and <I>item</I> should be the <B>OBJECT</B> pointer and index to the menu which is to have the sub-menu attached. If <I>mdata</I> is <B>NULLPTR</B>, any sub-menu attached will be removed.
</TD></TR>

<TR><TH></TH><TD>
<CENTER>
2
</CENTER>
</TD><TD COLSPAN=2><B><FONT SIZE=2>ME_REMOVE</FONT></B>
</TD><TD><FONT SIZE=2>Remove a sub-menu. <I>tree</I> and <I>item</I> should be the <B>OBJECT</B> pointer and index to the menu item which a sub-menu was attached to. <I>mdata</I> should be <B>NULLPTR</B>.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH></TH><TD COLSPAN=4>In all cases except <B>ME_REMOVE</B>, <I>mdata</I> should point to a <B>MENU</B> structure as defined here:

<PRE>
typedef struct
{
 OBJECT *mn_tree;
 WORD  mn_menu;
 WORD  mn_item;
 WORD  mn_scroll;
 WORD  mn_keystate;
} MENU;
</PRE>

</TD><TD></TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH></TH><TD COLSPAN=4>The <B>MENU</B> structure members are defined as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH></TH><TD COLSPAN=2><B><FONT SIZE=1 >Member</FONT></B>
</TD><TD COLSPAN=2><B><FONT SIZE=1 >Meaning</FONT></B>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><I>mn_tree</I></TD><TD COLSPAN=2>Points to the <B>OBJECT</B> tree of the sub-menu.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><I>mn_menu</I></TD><TD COLSPAN=2>Is an index to the parent object of the menu items.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><I>mn_item</I></TD><TD COLSPAN=2>Is the starting menu item.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><I>mn_scroll</I></TD><TD COLSPAN=2>If <B>SCROLL_NO</B> (0), the menu will not scroll. If <B>SCROLL_YES</B> (1), and the number of menu items exceed the menu scroll height, arrows will appear which allow the user to scroll selections.
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><I>mn_keystate</I></TD><TD COLSPAN=2>This member is unused and should be 0 for this call.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=4>
<PRE>
intin[0] = flag;
intin[1] = item;

addrin[0] = tree;
addrin[1] = mdata;

return crys_if(0x25);
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=4><B>menu_attach()</B> returns 0 if an error occurred and the sub-menu could not be attached or 1 if the operation was successful.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Caveats</B></TH><TD COLSPAN=4><B>AES</B> versions supporting <B>menu_attach()</B> less than 4.1 contain a bug which causes the <B>AES</B> to crash when changing or removing a sub-menu attachment.
<P>
At present, if you wish to attach a scrolling menu, the menu items must be <B>G_STRING'</B>s.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=4>If a menu bar having attachments is removed with <B>menu_bar</B>(<B>&nbsp;NULL</B>,<B>&nbsp;MENU_REMOVE</B> ) those attachments are removed by the system and must be reattached with this call if the menu is redisplayed at a later time.
<P>
Several recommendations regarding sub-menus should be adhered to:1. Menu items which will have sub-menus attached to them should be padded with blanks to the end of the menu.
<P>
2. Menu items which will have sub-menus attached to them should not have a keyboard equivalent.
<P>
3. Sub-menus will display faster if a byte-boundary is specified.
<P>
4. Sub-menus will be shifted vertically to align the start object with the main menu item which it is attached to.
<P>
5. Sub-menus will always be adjusted to automatically fit on the screen.
<P>
6. There can be a maximum of 64 sub-menu attachments per process (attaching a sub-menu to more than one menu item counts as only one attachment).
<P>
7. Do not attach a sub-menu to itself.
<P>
8. As a user-interface guideline, there should only be one level of sub-menus, though it is possible to have up to four levels currently.
<P>
9.<B> menu_istart()</B> works only on sub-menus attached with <B>menu_attach()</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=4><B>menu_istart()</B>, <B>menu_settings()</B>, <B>menu_popup()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=menubar2><H3>menu_bar()</H3>

<P>
<B>WORD menu_bar( <I>tree</I>, <I>mode </I>)</B>
<P>
<B>OBJECT *<I>tree</I>;</B>
<P>
<B>WORD <I>mode</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>menu_bar()</B> displays a specialized <B>OBJECT</B> tree on the screen as the application menu. It can also be used to determine the owner of the currently displayed menu bar in a multitasking <B>AES</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>30 (0x1E)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>All <B>AES</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>tree</I> is a pointer to an <B>OBJECT</B> tree which has been formatted for use as a system menu (for more information on the <B>OBJECT</B> format of a menu see the discussion on objects in this chapter).
<P>
<I>mode</I> is a flag indicating the action to take as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >mode</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>MENU_REMOVE</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Erase the menu bar specified in <I>tree</I>.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>MENU_INSTALL</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Display the menu bar specified in <I>tree</I>.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>MENU_INQUIRE</B></TD><TD>
<CENTER>
<FONT SIZE=2>-1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Return the <B>AES</B> application identifier of the process which owns the currently displayed system menu. <I>tree</I> can be set to <B>NULL</B>. The <B>AES</B> version must be greater than 4.0 and <B>appl_getinfo()</B> must indicate that this is feature is supported.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
intin[0] = mode;

addrin[0] = tree;

return crys_if(0x1E);
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3>If <I>mode</I> is <B>MENU_REMOVE</B> (0) or <B>MENU_INSTALL</B> (1), the return value indicates an error condition where &gt;0 means no error and 0 means an error occurred. In inquiry mode (<I>mode</I> = <B>MENU_INQUIRE</B> (-1)), <B>menu_bar()</B> returns the application identified of the process which owns the currently displayed menu bar.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=3>The safest way to redraw an application's menu bar is to redraw it only if you are sure it is currently the active menu bar. In a non-multitasking <B>AES</B>, this is a certainty, however, in a multitasking <B>AES</B> you should first inquire the menu bar's owner within the scope of a <B>wind_update( BEG_UPDATE )</B> call to prevent the system from swapping active menu bars while in the process of redrawing.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>menu_ienable()</B>, <B>menu_icheck()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=menuicheck2><H3>menu_icheck()</H3>

<P>
<B>WORD menu_icheck( <I>tree</I>, <I>obj</I>, <I>check</I> )</B>
<P>
<B>OBJECT *<I>tree</I>;</B>
<P>
<B>WORD <I>obj</I>, <I>check</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>menu_icheck()</B> adds/removes a checkmark in front of a menu item.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>31 (0x1F)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>tree</I> specifies the object tree of the current menu. <I>obj</I> should be the object index of a menu item. If <I>check</I> is <B>UNCHECK</B> (0), no checkmark will be displayed next to this item whereas if <I>check</I> is <B>CHECK</B> (1), a checkmark will be displayed.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = obj;
intin[1] = check;

addrin[0] = obj;

return crys_if(0x1F);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>menu_icheck()</B> returns 0 if an error occurred or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>objc_change()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>menu_ienable()</H3>

<P>
<B>WORD menu_ienable( <I>tree</I>, <I>obj</I>, <I>flag</I> )</B>
<P>
<B>OBJECT *<I>tree</I>;</B>
<P>
<B>WORD <I>obj</I>, <I>flag</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>menu_ienable()</B> enables/disables menu items.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>32 (0x20)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>tree</I> specifies the object tree of the menu to alter. <I>obj</I> is the object index of the menu item to modify. <I>flag</I> should be set to <B>DISABLE</B> (0) to disable the item or <B>ENABLE</B> (1) to enable it.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = obj;
intin[1] = flag;

addrin[0] = tree;

return crys_if(0x20);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>menu_icheck()</B> returns 0 if an error occurred or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>objc_change()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=menuistart2><H3>menu_istart()</H3>

<P>
<B>WORD menu_istart( <I>flag</I>, <I>tree</I>, <I>imenu</I>, <I>item</I>
)</B>
<P>
<B>WORD <I>flag</I>;</B>
<P>
<B>OBJECT *<I>tree</I>;</B>
<P>
<B>WORD <I>imenu</I>, <I>item</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>menu_istart()</B> shifts a sub-menu that is attached to a menu item to align vertically with the specified object in the sub-menu.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>38 (0x26)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This function is only available with <B>AES</B> versions 3.30 and above.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>flag </I>should be set to <B>MIS_SETALIGN</B> (1) to modify the alignment of a sub-menu and its parent menu item. If <I>flag</I> is set to <B>MIS_GETALIGN</B> (0), no modifications will be made, however the sub-menu item index which is currently aligned with its parent menu item is returned.
<P>
<I>tree</I> points to the object tree of the menu to alter. <I>imenu</I> specifies the object within the submenu which will be aligned with menu item <I>item</I>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = flag;
intin[1] = imenu;
intin[2] = item;

addrin[0] = tree;

return crys_if(0x26);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>menu_istart()</B> returns 0 if an error occurred or the positive object index of the sub-menu item which is currently aligned with its parent menu item. 
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Generally, a sub-menu is aligned so that the currently selected sub-menu item is aligned with its parent menu.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>menu_attach()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=menupopup2><H3>menu_popup()</H3>

<P>
<B>WORD menu_popup( <I>menu</I>, <I>xpos</I>, <I>ypos</I>, <I>mdata</I>
)</B>
<P>
<B>MENU *<I>menu</I>;</B>
<P>
<B>WORD <I>xpos</I>, <I>ypos</I>;</B>
<P>
<B>MENU *<I>menu</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>menu_popup()</B> displays a popup menu and returns the user's selection.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>36 (0x24)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This function is only available with <B>AES</B> versions 3.30 and above.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>menu</I> points to a <B>MENU</B> structure (defined under <B>menu_attach()</B>) containing the popup menu. <I>xpos</I> and <I>ypos</I> specify the location at which the upper-left corner of the starting object will be placed.
<P>
If the function returns a value of 1, the <B>MENU</B> structure pointed to by <I>mdata</I> will be filled in with the ending state of the menu (including the object the user selected).
<P>
As of <B>AES</B> version 4.1, if <I>menu.mn_scroll</I> is set to <B>SCROLL_LISTBOX</B> (-1) when this function is called, a <a name=ddlb2>drop-down list box will be displayed instead of a popup menu. 
<P>
Dropdown list boxes will only display a scroll bar if at least eight entries exist. If you want to force the scroll bar to appear, pad the object with empty <B>G_STRING</B> objects with their <B>DISABLED</B> flag set.  
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = xpos;
intin[1] = ypos;

addrin[0] = menu;
addrin[1] = mdata;

return crys_if(0x24);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>menu_popup()</B> returns 0 if an error occurred or 1 if successful.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>menu_attach(), menu_settings()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=menuregister3><H3>menu_register()</H3>

<P>
<B>WORD menu_register( <I>ap_id</I>, <I>title</I> )</B>
<P>
<B>WORD <I>ap_id</I>;</B>
<P>
<B>char *<I>title</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>menu_register()</B> registers desk accessories in the 'Desk' menu and renames <B>MultiTOS</B> applications which appear there.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>35 (0x23)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>ap_id</I> specifies the application identifier of the application to register. <I>title</I> points to a <B>NULL</B>-terminated string containing the title which is to appear in the 'Desk' menu for the accessory or application.
<P>
If <I>ap_id</I> is set to <B>REG_NEWNAME</B> (-1) then the process name given in <I>title</I> will be used as the new process name. The new process name should be exactly eight characters terminated with a <B>NULL</B>. Pad the string with space characters if necessary.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = ap_id;

addrin[0] = title;

return crys_if(0x23);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>menu_register()</B> returns a -1 if an error occurred or the menu identifier otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Version Notes</B></TH><TD>Applications other than desk accessories should not call this function unless they are running under <B>MultiTOS</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Desk accessories should store the return value as this is the value that will be included with future <B>AC_OPEN</B> messages to identify the accessory.
<P>
Applications running under <B>MultiTOS</B> may use this function to provide a more functional title for the 'Desk' menu than the program's filename. 
<P>
Calling <B>menu_register()</B> with a parameter of <B>REG_NEWNAME</B> is used to change the internal process name of the application returned by <B>appl_find()</B> and <B>appl_search()</B>.<B> </B>This is useful if you know another process will attempt to find your application as a specific process name and the user may have renamed your application filename (normally used as the process name).
</TD></TR>

</TABLE>

<P>

<HR>

<a name=menusettings2><H3>menu_settings()</H3>

<P>
<B>WORD menu_settings( <I>flag</I>, <I>set</I> )</B>
<P>
<B>WORD <I>flag</I>;</B>
<P>
<B>MN_SET *<I>set</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>menu_settings()</B> changes the global settings for popup and scrollable menus.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>39 (0x27)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>This function is only available with <B>AES</B> versions 3.30 and above.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD>If <I>flag</I> is 0, current settings are read into the <B>MN_SET</B> structure pointed to by <I>set</I>. If <I>flag</I> is 1, current settings are set from the <B>MN_SET</B> structure pointed to by <I>set</I>. <B>MN_SET</B> is defined as follows:
<PRE>
typedef struct
{
 /* Submenu-display delay in milliseconds */
 LONG display;

 /* Submenu-drag delay in milliseconds */
 LONG drag;

 /* Single-click scroll delay in milliseconds*/
 LONG delay;

 /* Continuous-scroll delay in milliseconds */
 LONG speed;

 /* Menu scroll height (in items) */
 WORD height;
} MN_SET;
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = flag;

addrin[0] = set;

return crys_if(0x27);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>menu_settings()</B> always returns 1.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The defaults set by <B>menu_settings()</B> are global and not local to an application. You should therefore limit your use of this function to system applications like CPX's and so forth.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=menutext><H3>menu_text()</H3>

<P>
<B>WORD menu_text( <I>tree</I>, <I>obj</I>, <I>text</I> )</B>
<P>
<B>OBJECT *<I>tree</I>;</B>
<P>
<B>WORD <I>obj</I>;</B>
<P>
<B>char *<I>text</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>menu_text()</B> changes the text of a menu item.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>34 (0x22)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>tree</I> specifies the object tree of the menu bar. <I>obj</I> specifies the object index of the menu item to change. <I>text</I> points to a <B>NULL</B>-terminated character string containing the new text.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = obj;

addrin[0] = tree;
addrin[1] = text;

return crys_if(0x22);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>menu_text()</B> returns a 0 if an error occurred or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The new menu item text must be no larger than the original menu item text.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=menutnormal><H3>menu_tnormal()</H3>

<P>
<B>WORD menu_tnormal( <I>tree</I>, <I>obj</I>, <I>flag</I> )</B>
<P>
<B>OBJECT *<I>tree</I>;</B>
<P>
<B>WORD <I>obj</I>, <I>flag</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>menu_tnormal()</B> highlights/un-highlights a menu-title.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>33 (0x21)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>tree</I> specifies the object tree of the menu. <I>obj</I> specifies the object index of the title to change. <I>flag</I> should be set to <B>HIGHLIGHT</B> (0) to display the title in reverse (highlighted) or <B>UNHIGHLIGHT</B> (1) to display it normally.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = obj
intin[1] = flag

addrin[1] = tree

return crys_if(0x21);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>menu_tnormal()</B> returns 0 if an error occurred or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call is usually called by an application after a <B>MN_SELECTED</B> message is received and processed to return the menu title to normal.
</TD></TR>

</TABLE>

<H2>Object Library</H2>

<HR>

<P>
The <I>Object Library</I> is responsible for the drawing and manipulation
of <B>AES</B> objects such as boxes, strings, icons, etc. See
earlier in this chapter for a complete discussion of <B>AES</B>
objects. The <I>Object Library</I> includes the following functions:
<P>
 objc_add()
<P>
 objc_change()
<P>
 objc_delete()
<P>
 objc_draw()
<P>
 objc_edit()
<P>
 objc_find()
<P>
 objc_offset()
<P>
 objc_order()
<P>
 objc_sysvar()
<a name=objcadd2><H3>objc_add()</H3>

<P>
<B>WORD objc_add( <I>tree</I>, <I>parent</I>, <I>child</I> )</B>
<P>
<B>OBJECT *<I>tree</I>;</B>
<P>
<B>WORD <I>parent</I>, <I>child</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>objc_add()</B> establishes a child object's relationship to its parent.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>40 (0x28)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>tree</I> specifies the object tree to modify. <I>parent</I> and <I>child</I> specify the parent and child object to update.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = parent;
intin[1] = child;

addrin[0] = tree;

return crys_if(0x28);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>objc_add()</B> returns a 0 if an error occurred or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>In order for this function to work, the object to be added must be already be a member of the <B>OBJECT</B> array. This function simply updates the <I>ob_next,</I> <I>ob_head</I>, and <I>ob_tail</I> structure members of <B>OBJECT</B>s in the object tree. These fields should be initialized to <B>NIL</B> (0) in the child to be added.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>objc_order(), objc_delete()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=objcchange2><H3>objc_change()</H3>

<P>
<B>WORD objc_change( <I>tree</I>, <I>obj</I>, <I>rsvd</I>, <I>ox</I>,
<I>oy</I>, <I>ow</I>, <I>oh</I>, <I>newstate</I>, <I>drawflag</I>
)</B>
<P>
<B>OBJECT *<I>tree</I>;</B>
<P>
<B>WORD <I>obj</I>, <I>rsvd</I>, <I>ox</I>, <I>oy</I>, <I>ow</I>,
<I>oh</I>, <I>newstate</I>, <I>drawflag</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>objc_change()</B> changes the display state of an object.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>47 (0x2F)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>tree</I> specifies the object tree of the object to modify. <I>obj</I> specifies the object to modify. 
<P>
<I>rsvd</I> is reserved and should be 0. 
<P>
<I>ox</I>, <I>oy</I>, <I>ow</I>, and <I>oh</I> specify the clipping rectangle if the object is to be redrawn. 
<P>
<I>newstate</I> specifies the new state of the object (same as <I>ob_state</I>). 
<P>
If <I>drawflag</I> is <B>NO_DRAW</B> (0) the object is not redrawn whereas if <I>drawflag</I> is <B>REDRAW</B> (1) the object is redrawn.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = obj;
intin[1] = rsvd;
intin[2] = ox;
intin[3] = oy;
intin[4] = ow;
intin[5] = oh;
intin[6] = newstate;
intin[7] = drawflag;

addrin[0] = tree;

return crys_if(0x2F);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>objc_change()</B> returns 0 if an error occurred and non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>In general, if not redrawing the object, it is usually quicker to manipulate the object tree directly.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>objc_draw()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=objcdelete2><H3>objc_delete()</H3>

<P>
<B>WORD objc_delete( <I>tree</I>, <I>obj</I> )</B>
<P>
<B>OBJECT *<I>tree</I>;</B>
<P>
<B>WORD <I>obj</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>objc_delete()</B> removes an object from an object tree.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>41 (0x29)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>tree</I> specifies the object tree of the object to delete. <I>obj</I> is the object to be deleted.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = obj;

addrin[0] = tree;

return crys_if(0x29);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>objc_delete()</B> returns 0 if an error occurred or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This function does not move other objects in the tree structure, it simply unlinks the specified object from the object chain by updating the other object's <I>ob_next</I>, <I>ob_head</I>, and <I>ob_tail</I> structure members.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>objc_add()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=objcdraw><H3>objc_draw()</H3>

<P>
<B>WORD objc_draw( <I>tree</I>, <I>obj</I>, <I>depth</I>, <I>ox</I>,
<I>oy</I>, <I>ow</I>, <I>oh</I> )</B>
<P>
<B>OBJECT *<I>tree</I>;</B>
<P>
<B>WORD <I>obj</I>, <I>depth</I>, <I>ox</I>, <I>oy</I>, <I>ow</I>,
<I>oh</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>objc_draw()</B> renders an <B>AES</B> object tree on screen.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>42 (0x2A)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>tree</I> specifies the object tree to draw. <I>obj</I> specifies the object index at which drawing is to begin.
<P>
<I>depth</I> specifies the maximum object depth to draw (a value of 1 searches only first generation objects, a value of 2 searches up to second generation objects, up to a maximum of 7 to search all objects).
<P>
<I>ox</I>, <I>oy</I>, <I>ow</I>, and <I>oh</I> specify an <B>AES</B> style rectangle which defines the clip rectangle to enforce during drawing.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = obj;
intin[1] = depth;
intin[2] = ox;
intin[3] = oy;
intin[4] = ow;
intin[5] = oh;

addrin[0] = tree;

return crys_if(0x2A);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>objc_draw()</B> returns 0 if an error occurred or non-zero otherwise.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=objcedit2><H3>objc_edit()</H3>

<P>
<B>WORD objc_edit( <I>tree</I>, <I>obj</I>, <I>kc</I>, <I>idx</I>,
<I>mode</I> )</B>
<P>
<B>OBJECT *<I>tree</I>;</B>
<P>
<B>WORD <I>obj</I>, <I>kc</I>;</B>
<P>
<B>WORD *<I>idx</I></B>
<P>
<B>WORD <I>mode</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>objc_edit()</B> allows manual control of an editable text field.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>46 (0x2E)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>All <B>AES</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>tree</I> specifies the object tree containing the editable object <I>obj</I> to modify. mode specifies the action of the call and the meaning of the other parameters as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><I><B><FONT SIZE=1 >mode</FONT></B></I>
</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Value</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>ED_START</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Reserved for future use. Do not call.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>ED_INIT</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Display the edit cursor in the object specified. <I>kc</I> is ignored. The <B>WORD</B> pointed to by <I>idx</I> is filled in with the current index of the edit cursor in the field.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>ED_CHAR</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>A key has been pressed that needs special processing. <I>kc</I> contains the keyboard scan code in the high byte and ASCII code in the low byte. <I>idx</I> points to the current index of the text cursor in the field. <I>idx</I> will be updated as a result of this call.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>ED_END</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Turn off the text cursor.</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
intin[0] = obj;
intin[1] = kc;
intin[2] = *idx;
intin[3] = mode;

addrin[0] = tree;

crys_if(0x2E);

*idx = intout[1];
return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3><B>objc_edit()</B> returns 0 if an error occurred or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=3>This function is usually used in conjunction with <B>form_keybd()</B> in a custom <B>form_do()</B> handler.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>form_keybd()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=objcfind2><H3>objc_find()</H3>

<P>
<B>WORD objc_find( <I>tree</I>, <I>obj</I>, <I>depth</I>, <I>ox</I>,
<I>oy</I> )</B>
<P>
<B>OBJECT *<I>tree</I>;</B>
<P>
<B>WORD <I>obj</I>, <I>depth</I>, <I>ox</I>, <I>oy</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>objc_find()</B> determines which object is found at a given  coordinate.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>43 (0x2B)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>tree</I> specifies the object tree containing the objects to search. The search starts from object index <I>obj</I> forward in the object tree. 
<P>
<I>depth</I> specifies the depth in the tree to search (a value of 1 searches only first generation objects, a value of 2 searches up to second generation objects, up to a maximum of 7 to search all objects).
<P>
<I>ox</I> and <I>oy</I> specify the coordinate to search at.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = obj;
intin[1] = depth;
intin[2] = ox;
intin[3] = oy;

addrin[0] = tree;

return crys_if(0x2B);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>objc_find()</B> returns the object index of the object found at coordinates ( <I>ox</I>, <I>oy</I> ) or -1 if no object is found.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=objcoffset2><H3>objc_offset()</H3>

<P>
<B>WORD objc_offset( <I>tree</I>, <I>obj</I>, <I>ox</I>, <I>oy</I>
)</B>
<P>
<B>OBJECT *<I>tree</I>;</B>
<P>
<B>WORD <I>obj</I>;</B>
<P>
<B>WORD *<I>ox</I>, *<I>oy</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>objc_offset()</B> calculates the true screen coordinates of an object.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>44 (0x2C)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>tree</I> specifies the object tree containing <I>obj</I>. The <B>WORD</B>s pointed to by <I>ox</I> and <I>oy</I> will be filled in with the true X and Y screen position of object <I>obj</I>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = obj;

addrin[0] = tree;

crys_if(0x2C);

*ox = intout[1];
*oy = intout[2];

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>objc_offset()</B> returns 0 if an error occurred or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The <I>ob_x</I> and <I>ob_y</I> structure members of objects give an offset from their parent as opposed to true screen location. This call is used to determine a true screen coordinate.
<P>
The values returned by <B>objc_offset()</B> coupled with the <I>ob_width</I> and <I>ob_height</I> members do not take into account negative borders, shadowing, or sculpturing. When redrawing an object you are responsible for using these values to and the object's state to compensate for a correct clipping rectangle.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>objc_draw()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=objcorder2><H3>objc_order()</H3>

<P>
<B>WORD objc_order( <I>tree</I>, <I>obj</I>, <I>pos</I> )</B>
<P>
<B>OBJECT *<I>tree</I>;</B>
<P>
<B>WORD <I>obj</I>, <I>pos</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>objc_order()</B> changes the position of an object relative to other child objects of the same parent.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>45 (0x2D)</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>All <B>AES</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=5><I>tree</I> specifies the object tree of object <I>obj</I> which is to be moved. <I>pos</I> specifies the new position of the object as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
<B><FONT SIZE=1 >Name</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<I><B><FONT SIZE=1 >pos</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD><B>OO_LAST</B></TD><TD>
<CENTER>
<FONT SIZE=2>-1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Make object the last child.</FONT></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD><B>OO_FIRST</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Make object the first child.</FONT></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
-
</CENTER>
</TD><TD>
<CENTER>
1
</CENTER>

</TD><TD><FONT SIZE=2>Make object the second child.</FONT></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD>
<CENTER>
-
</CENTER>
</TD><TD>
<CENTER>
2-
</CENTER>

</TD><TD><FONT SIZE=2>etc...</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
intin[0] = obj;
intin[1] = pos;

addrin[0] = tree;

return crys_if(0x2D);
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=5><B>objc_order()</B> returns 0 if an error occurred or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=5><B>objc_order()</B> does not actually move structure elements in memory. It works by updating the <B>OBJECT</B> tree's <I>ob_head</I>, <I>ob_tail</I>, and <I>ob_next</I> fields to 'move' the <B>OBJECT</B> in the tree hierarchy.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=objcsysvar><H3>objc_sysvar()</H3>

<P>
<B>WORD objc_sysvar( <I>mode</I>, <I>which</I>, <I>in1</I>, <I>in2</I>,
<I>out1</I>, <I>out2</I> )</B>
<P>
<B>WORD <I>mode</I>, <I>which</I>, <I>in1</I>, <I>in2</I>;</B>
<P>
<B>WORD *<I>out1</I>, *<I>out2</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>objc_sysvar()</B> returns/modifies information about the color and placement of 3D object effects.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>48 (0x30)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>Available as of <B>AES</B> version 3.40.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>mode</I> determines whether attributes should be read or modified. A value of <B>SV_INQUIRE</B> (0) will read the current values whereas a value of <B>SV_SET</B> (1) will modify the current values. <I>which</I> determines what attribute you wish to read or modify.
<P>
When reading values, <I>in1</I> and <I>in2</I> are unused. The two return values are placed in the <B>WORD</B>s pointed to by <I>out1</I> and <I>out2</I>. When modifying values, <I>out1</I> and <I>out2</I> are unused. <I>in1</I> and <I>in2</I> specify the new values for the attribute.
<P>
The meanings of the two input/output values referred to as val1 and val2 are as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >which</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Values</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>LK3DIND</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>If val1 is 1, the text of indicator objects does move when selected, otherwise, if 0,  it does not.</FONT>
<P>
<FONT SIZE=2>If val2 is 1, the color of indicator objects does change when selected, otherwise, if 0, it does not.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>LK3DACT</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Same as <B>LK3DIND</B> for activator objects.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>INDBUTCOL</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>val1 specifies the default color for indicator objects. val2 is unused.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>ACTBUTCOL</B></TD><TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>val1 specifies the default color for activator objects. val2 is unused.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>BACKGRCOL</B></TD><TD>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>val1 specifies the default color for background objects. val2 is unused.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>AD3DVAL</B></TD><TD>
<CENTER>
<FONT SIZE=2>6</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>val1 specifies the number of extra pixels on each horizontal side of an indicator or activator object needed to accomodate 3D effects. </FONT>
<P>
<FONT SIZE=2>val2 specifies the number of extra pixels on each vertical side of an indicator or activator object needed to accomodate 3D effects.</FONT>
<P>
<FONT SIZE=2>This setting may only be read, not modified.  </FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
intin[0] = mode;
intin[1] = which;
intin[2] = in1;
intin[3] = in2;

crys_if(0x30);

*out1 = intout[1];
*out2 = intout[2];

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3><B>objc_sysvar()</B> returns 0 if unsuccessful or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=3>Applications should not use <B>objc_sysvar()</B> to change these settings since all changes are global. Only<B> CPX</B>s or Desk Accessories designed to modify these parameters should.
</TD></TR>

</TABLE>

<H2>Resource Library</H2>

<HR>

<P>
The <I>Resource Library</I> is responsibe for the loading/unloading
of resource files and the manipulation of resource objects in
memory. The members of the <I>Resource Library</I> are:
<P>
 rsrc_free()
<P>
 rsrc_gaddr()
<P>
 rsrc_load()
<P>
 rsrc_obfix()
<P>
 rsrc_rcfix()
<P>
 rsrc_saddr()
<a name=rsrcfree><H3>rsrc_free()</H3>

<P>
<B>WORD rsrc_free( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>rsrc_free()</B> releases memory allocated by <B>rsrc_load()</B> for an application's resource.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>111 (0x6F)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
return crys_if(0x6F);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>rsrc_free()</B> returns 0 if an error occurred or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD><B>rsrc_free()</B> should be called before an application which loaded a resource using <B>rsrc_load()</B> exits.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>rsrc_load()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=rsrcgaddr2><H3>rsrc_gaddr()</H3>

<P>
<B>WORD rsrc_gaddr( <I>type</I>, <I>index</I>, <I>addr</I> )</B>
<P>
<B>WORD <I>type</I>, <I>index</I>;</B>
<P>
<B>VOIDPP <I>addr</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>rsrc_gaddr()</B> returns the address of an object loaded with <B>rsrc_load()</B>.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>112 (0x70)</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>All <B>AES</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=5>The pointer pointed to by <I>addr</I> will be filled in with the address of the <I>index</I><FONT SIZE=1>th</FONT> resource object of type <I>type</I>. Valid values for <I>type</I> are as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >type</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Resource Object</FONT></B>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>R_TREE</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Object tree</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>R_OBJECT</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Individual object</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>R_TEDINFO</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2>TEDINFO</FONT></B> structure</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>R_ICONBLK</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2>ICONBLK</FONT></B> structure</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>R_BITBLK</B></TD><TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

</TD><TD><B><FONT SIZE=2>BITBLK</FONT></B> structure</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>R_STRING</B></TD><TD>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Free String data</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>R_IMAGEDATA</B></TD><TD>
<CENTER>
<FONT SIZE=2>6</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Free Image data</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>R_OBSPEC</B></TD><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>ob_spec</FONT></I> field within <B>OBJECT</B>s
</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>R_TEPTEXT</B></TD><TD>
<CENTER>
<FONT SIZE=2>8</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>te_ptext</FONT></I> within <B>TEDINFO</B>s
</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>R_TEPTMPLT</B></TD><TD>
<CENTER>
<FONT SIZE=2>9</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>te_ptmplt</FONT></I> within <B>TEDINFO</B>s
</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>R_TEPVALID</B></TD><TD>
<CENTER>
<FONT SIZE=2>10</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>te_pvalid</FONT></I> within <B>TEDINFO</B>s
</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>R_IBPMASK</B></TD><TD>
<CENTER>
<FONT SIZE=2>11</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>ib_pmask</FONT></I> within <B>ICONBLK</B>s
</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>R_IBPDATA</B></TD><TD>
<CENTER>
<FONT SIZE=2>12</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>ib_pdata</FONT></I> within <B>ICONBLK</B>s
</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>R_IBPTEXT</B></TD><TD>
<CENTER>
<FONT SIZE=2>13</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>ib_ptext</FONT></I> within <B>ICONBLK</B>s
</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>R_BIPDATA</B></TD><TD>
<CENTER>
<FONT SIZE=2>14</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>bi_pdata</FONT></I> within <B>BITBLK</B>s
</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>R_FRSTR</B></TD><TD>
<CENTER>
<FONT SIZE=2>15</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Free string</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>R_FRIMG</B></TD><TD>
<CENTER>
<FONT SIZE=2>16</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Free image</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
intin[0] = type;
intin[1] = index;

crys_if(0x70);

*addr = addrout[0];

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=5><B>rsrc_gaddr()</B> returns a 0 if the address in <I>addr</I> is valid or non-zero if the object did not exist.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=5>This function is most often used to obtain the address of <B>OBJECT</B> trees, 'free' strings, and 'free' images after loading a resource file.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=5><B>rsrc_saddr()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=rsrcload3><H3>rsrc_load()</H3>

<P>
<B>WORD rsrc_load( <I>fname</I> )</B>
<P>
<B>char *<I>fname</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>rsrc_load()</B> loads and allocates memory for the named resource file.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>110 (0x6E)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>fname</I> is a character pointer to a <B>NULL</B>-terminated <B>GEMDOS</B> file specification of the resource to load.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
addrin[0] = fname;

return crys_if(0x6E);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>rsrc_load()</B> returns 1 if successful or zero if an error occurred.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>In addition to loading the resource, all <B>OBJECT</B> coordinates are converted from character based coordinates to screen coordinates.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>rsrc_free()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=rsrcobfix2><H3>rsrc_obfix()</H3>

<P>
<B>WORD rsrc_obfix( <I>tree</I>, <I>obj</I> )</B>
<P>
<B>OBJECT *<I>tree</I>;</B>
<P>
<B>WORD <I>obj</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>rsrc_obfix()</B> converts an object's coordinates from character-based to pixel-based.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>114 (0x72)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>tree</I> specifies the <B>OBJECT</B> tree containing the object <I>obj</I> to convert.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = obj;

addrin[0] = tree;

return crys_if(0x72);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>rsrc_obfix()</B> always returns a 0.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>All objects in '.RSC' files have their coordinates based on character positions rather than screen coordinates to allow an object tree to be shown in any resolution. This function converts those character coordinates to pixel coordinates based on the current screen resolution. 
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>rsrc_load(), rsrc_rcfix()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=rsrcrcfix2><H3>rsrc_rcfix()</H3>

<P>
<B>WORD rsrc_rcfix( <I>rc_header</I> )</B>
<P>
<B>VOID *<I>rc_header</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>rsrc_rcfix()</B> fixes up coordinates and memory pointers of raw resource data in memory. 
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>115 (0x73)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available only in <B>AES</B> versions 4.0 and greater. The presence of this call should also be checked for using <B>appl_getinfo()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>rc_header</I> is a pointer to an Atari Resource Construction Set (or compatible) resource file header in memory.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
addrin[0] = rc_header;

return crys_if(0x73);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>rsrc_rcfix()</B> returns a non-zero if successful or zero otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>If a resource has already been loaded with <B>rsrc_load()</B> it must be freed by <B>rsrc_free()</B> prior to this call. In addition, resources identified with this call must likewise be freed before program termination or another resource file is needed.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>rsrc_obfix()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=rsrcsaddr2><H3>rsrc_saddr()</H3>

<P>
<B>WORD rsrc_saddr( <I>type</I>, <I>index</I>, <I>addr</I> )</B>
<P>
<B>WORD <I>type</I>, <I>index</I>;</B>
<P>
<B>VOID *<I>addr</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>rsrc_saddr()</B> sets the address of a resource element.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>113 (0x71)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>type</I> specifies the type of resource element to set as defined under <B>rsrc_gaddr()</B>. <I>index</I> specifies the index of the element to modify (0 based). <I>addr</I> specifies the actual address that will be placed in the appropriate data structure.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = type;
intin[1] = index;

addrin[0] = addr;

return crys_if(0x71);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>rsrc_saddr()</B> returns 0 if an error occurred or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>In most cases, direct manipulation of the structures involved is quicker and easier than using this call.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>rsrc_gaddr(), rsrc_load()</B>
</TD></TR>

</TABLE>

<H2>Scrap Library</H2>

<HR>

<P>
The <I>Scrap Library</I> is used to maintain the location of the
clipboard directory used for interprocess data exchange. The members
of the <I>Scrap Library</I> are:
<P>
 scrp_read()
<P>
 scrp_write()
<a name=scrpread2><H3>scrp_read()</H3>

<P>
<B>WORD scrp_read( <I>cpath</I> )</B>
<P>
<B>char *<I>cpath</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>scrp_read()</B> returns the location of the current clipboard directory.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>80 (0x50)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>cpath</I> is a pointer to a character buffer of at least 128 bytes into which the clipboard path will be placed.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
addrin[0] = cpath;

return crys_if(0x50);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>scrp_read()</B> returns 0 if the clipboard path had not been set or non-zero if <I>cpath</I> was properly updated.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>The system scrap directory is a global resource. Some programs incorrectly call <B>scrp_write()</B> with a path <I>and</I> filename when only a pathname should be used. The following is an example of a correctly formatted <I>cpath</I> argument:
<PRE>
     C:\CLIPBRD\Unfortunately, not all programs adhere exactly to this standard. For this reason, programs reading this information from <B>scrp_read()</B> should be especially careful that the information returned is parsed correctly. In addition, don't count on a trailing backslash or the existence of a drive specification.
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>If a value of 0 is returned and the application wishes to write a scrap to the clipboard you should follow these steps: Create a folder '\CLIPBRD\' on the root directory of the user's boot drive ('C:' or 'A:').
<P>
 Write your scrap to the directory as 'SCRAP.???' where '???' signifies the type of information contained in the file.
<P>
 Allow other applications to access this information by calling <B>scrp_write()</B> with the new clipboard path. For example "C:\CLIPBRD\".A detailed discussion of the proper clipboard data exchange protocol, including information about a scrap directory semaphore useful with <B>MultiTOS</B>, is given earlier in this chapter.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>scrp_write()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=scrpwrite2><H3>scrp_write()</H3>

<P>
<B>WORD scrp_write( <I>cpath</I> )</B>
<P>
<B>char *<I>cpath</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>scrp_write()</B> sets the location of the clipboard directory.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>81 (0x51)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>cpath</I> points to a <B>NULL</B>-terminated path string containing a valid drive and path specification with a closing backslash. The following is an example of a correctly formatted <I>cpath</I> argument:
<PRE>
     C:\CLIPBRD\
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
addrin[0] = cpath;

return crys_if(0x51);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>scrp_write()</B> returns 0 if an error occurred or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The scrap directory is a global resource. This call should only be used in two circumstances as follows: when used to set the default location of the scrap directory using a CPX or accessory at bootup or by the user's request.
<P>
 when <B>scrp_read()</B> returns an error value and you need to create the clipboard to write information to it.The clipboard data exchange protocol is discussed in greater detail earlier in this chapter.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>scrp_read()</B></TD></TR>

</TABLE>

<H2>Shell Library</H2>

<HR>

<P>
The <I>Shell Library</I> contains several miscellaneous functions
most often used by the <B>GEM</B> <B>Desktop</B> and other 'Desktop-like'
applications. Other applications may, however, need specific functions
of the <I>Shell Library</I> for various tasks. The members of
the <I>Shell Library</I> are:
<P>
 shel_envrn()
<P>
 shel_find()
<P>
 shel_get()
<P>
 shel_put()
<P>
 shel_read()
<P>
 shel_write()
<a name=shelenvrn2><H3>shel_envrn()</H3>

<P>
<B>WORD shel_envrn( <I>value</I>, <I>name</I> )</B>
<P>
<B>char **<I>value</I>; </B>
<P>
<B>char *<I>name</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>shel_envrn()</B> searches the current environment string for a specific variable.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>125 (0x7D)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>value</I> points to a character pointer which will be filled in with the address of the first character in the <a name=envirostring2>environment string following the string given by <I>name</I>. If the string given by <I>name</I> is not found, <I>value</I> will be filled in with <B>NULL</B>. For instance, suppose the current environment looked like this:
<PRE>
PATH=C:\;D:\;E:\A call made to <B>shel_envrn()</B> with <I>name</I> pointing to the string 'PATH=' would set the pointer pointed to by <I>value</I> to the string 'C:\;D:\;E:\' above.
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
addrin[0] = value;
addrin[1] = name;

return crys_if(0x7D);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>shel_envrn()</B> currently always returns 1.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Version Notes</B></TH><TD><B>AES</B> versions prior to 1.4 only accepted semi-colons as separators between multiple 'PATH='arguments. Newer versions accept commas as well.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The character string pointed to by name should include the name of the variable <I>and</I> the equals sign.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=shelfind2><H3>shel_find()</H3>

<P>
<B>WORD shel_find( <I>buf</I> )</B>
<P>
<B>char *<I>buf</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>shel_find()</B> searches for a file along the <B>AES</B>'s current path, any paths specified by the 'PATH' environmental variable, and the calling application's path.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>124 (0x7C)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>buf</I> should point to a character buffer of at least 128 characters and contain the filename of the file to search for on entry. If the function was able to find the file, the buffer pointed to by <I>buf</I> will be filled in with the full pathname of the file upon return.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
addrin[0] = buf;

return crys_if(0x7C);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>shel_find()</B> returns 0 if the file was not found or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>shel_write()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=shelget2><H3>shel_get()</H3>

<P>
<B>WORD shel_get( <I>buf</I>, <I>length</I> )</B>
<P>
<B>char *<I>buf</I>;</B>
<P>
<B>WORD <I>length</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>shel_get()</B> copies the contents of the <B>AES</B>'s <a name=shellbuffer2>shell buffer (normally the 'DESKTOP.INF' or 'NEWDESK.INF' file) into the specified buffer.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>122 (0x7A)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>buf</I> points to a buffer at least <I>length</I> bytes long into which the <B>AES</B> should copy the shell buffer into.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = length;

addrin[0] = buf;

return crys_if(0x7A);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>shel_get()</B> returns 0 if an error occurred or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Version Notes</B></TH><TD><B>AES</B> versions prior to version 1.4 had a shell buffer size of 1024 bytes. Versions 1.4 to 3.0 had a shell buffer size of 4192 bytes.
<P>
In <B>AES</B> versions 4.0 or greater the shell buffer is no longer of a fixed size. When <B>appl_getinfo()</B> indicates that this feature is supported, <I>length</I> can be specified as <B>SHEL_BUFSIZE</B> (-1) to return the size of the current shell buffer.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>shel_put()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=shelput2><H3>shel_put()</H3>

<P>
<B>WORD shel_put( <I>buf</I>, <I>length</I> )</B>
<P>
<B>char *<I>buf</I>;</B>
<P>
<B>WORD <I>length</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>shel_put()</B> copies information into the <B>AES</B>'s shell buffer.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>123 (0x7B)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>buf</I> points to a user memory buffer from which <I>length</I> bytes are to be copied into the shell buffer.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = length;

addrin[0] = buf;

return crys_if(0x7B);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>shel_put()</B> returns 0 if an error occurred or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Version Notes</B></TH><TD>Prior to <B>AES</B> version 4.0 this function would only copy as many bytes as would fit into the current buffer. As of version 4.0, the <B>AES</B> will dynamically allocate more memory as needed (up to 32767 bytes) for the shell buffer.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>The <B>Desktop</B> uses the information in the shell buffer for several purposes. Applications should not use the shell buffer for their own purposes.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>shel_get()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>shel_read()</H3>

<P>
<B>WORD shel_read( <I>name</I>, <I>tail</I> )</B>
<P>
<B>char *<I>name</I>, *<I>tail</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>shel_read()</B> is used to determine the current application's parent and the command tail used to call it.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>120 (0x78)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>name</I> points to a buffer which upon exit will be filled in with the complete file specification of the application which launched the current process.
<P>
<I>tail</I> will likewise be filled in with the initial command line. The first BYTE of the command line indicates the length of the string which actually begins at &amp;<I>tail[1]</I>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
addrin[0] = name;
addrin[1] = tail;

return crys_if(0x78);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>shel_read()</B> returns 0 if an error occurred or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD><B>shel_read()</B> actually returns the arguments to the last <B>shel_write()</B> so if a process was <B>Pexec()</B>'ed, the information returned will be incorrect.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=shelwrite3><H3>shel_write()</H3>

<P>
<B>WORD shel_write( <I>mode</I>, <I>wisgr</I>, <I>wiscr</I>, <I>cmd</I>,
<I>tail</I> )</B>
<P>
<B>WORD <I>mode</I>, <I>wisgr</I>, <I>wiscr</I>;</B>
<P>
<B>char *<I>cmd</I>, *<I>tail</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>shel_write()</B> is a multi-purpose function which handles the manipulation and launching of processes.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>121 (0x79)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>All <B>AES</B> versions. In <B>AES</B> versions 4.0 and above, <B>appl_getinfo()</B> can be used to determine the highest legal value for <I>mode</I> as well as the functionality of extended <I>mode</I> bits.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>mode</I> specifies the meaning of the rest of the parameters as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><I><B><FONT SIZE=1 >Name</FONT></B></I>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >mode</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>SWM_LAUNCH</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Launch a <B>GEM</B> or <B>TOS</B> application or <B>GEM</B> desk accessory depending on the extension of the file. This mode is only available as of <B>AES</B> version 4.0. <I>wisgr</I> is not used in <I>mode</I> <B>SWM_LAUNCH</B> (0). When the lower eight bits of <I>mode</I> are <B>SWM_LAUNCH</B> (0), <B>SWM_LAUNCHNOW</B> (1), or <B>SWM_LAUNCHACC</B> (3), appropriate bits in the upper byte may be set to enter 'extended' mode. The bits in the upper byte are assigned as follows:</FONT>
<P>
<FONT SIZE=2> </FONT><U><B>Name</B> <B>Mask  Meaning</B></U>
<P>
<B><FONT SIZE=2>SW_PSETLIMIT</FONT></B> 0x100  Initial <B>Psetlimit() </B>
<P>
<B><FONT SIZE=2>SW_PRENICE</FONT></B> 0x200  Initial <B>Prenice()</B>
<P>
<B><FONT SIZE=2>SW_DEFDIR</FONT></B> 0x400  Default Directory
<P>
<B><FONT SIZE=2>SW_ENVIRON</FONT></B> 0x800  Environment<FONT SIZE=2>If the upper byte is empty, extended mode is not entered and <I>cmd</I> specifies the filename (to search for the file with <B>shel_find()</B> ) or the complete file specification. Otherwise, if any extended bits are set, <I>cmd</I> points to a structure as shown below.</FONT>
<PRE>
typedef struct _shelw
{
 char *newcmd;
 LONG psetlimit;
 LONG prenice;
 char *defdir;
 char *env;
} SHELW;<I>_shelw.newcmd</I> points to the filename formatted in the manner indicated above.
</PRE>

<P>
If bit 8 (<B>SW_PSETLIMIT</B>) of <I>mode</I> is set, <I>_shelw.psetlimit</I> contains the maximum memory size available to the process.
<P>
If bit 9 of <I>mode</I> is (<B>SW_PRENICE</B>) set, <I>_shelw.prenice</I> contains the process priority of the process to launch. 
<P>
If bit 10 of <I>mode</I> (<B>SW_DEFDIR</B>) is set, <I>_shelw.defdir</I> points to a character string containing the default directory for the application begin launched.
<P>
If bit 11 of <I>mode</I> (<B>SW_ENVIRON</B>) is set, <I>_shelw.env</I> points to a valid environment string for the process.
<P>
<I>tail</I> points to a buffer containing the command tail to pass to the process. If <I>wiscr</I> is set to <B>CL_NORMAL</B> (0), <I>tail</I> is passed normally, otherwise, if <I>wiscr</I> is set to <B>CL_PARSE</B> (1), the <B>AES</B> will parse <I>tail</I> and set up an <B>ARGV</B> environment string.
<P>
<I>modes</I> <B>SWM_LAUNCH</B> (0), <B>SWM_LAUNCHNOW</B> (1), and <B>SWM_LAUNCHACC</B> (3) return the <B>AES</B> id of the started process. If a 0 is returned, then the process was not launched.
<P>
Under <B>MultiTOS</B>, processes are launched concurrently with their parent. An exit code is returned in a <B>CH_EXIT</B> message when the child terminates. See <B>evnt_mesag()</B>.
<P>
In <B>AES</B> versions 4.0 and above, <B>appl_getinfo()</B> should be used to determine the exact result of this call.
</TD></TR>

<TR><TH></TH><TD><B>SWM_LAUNCHNOW</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Launch a <B>GEM</B> or <B>TOS</B> application based on the value of <I>wisgr</I>. If <I>wisgr</I> is <B>TOSAPP</B> (0), the application will be launched as a <B>TOS</B> application, otherwise if <I>wisgr</I> is <B>GEMAPP</B> (1), the application will be launched as a <B>GEM</B> application. For the meaning of other parameters, see mode <B>SWM_LAUNCH</B> (0). The extended bits in mode are only supported by <B>AES</B> versions of at least 4.0.</FONT>
<P>
<FONT SIZE=2>Parent applications which launch children using this mode are suspended under <B>MultiTOS</B>.</FONT>
<P>
<FONT SIZE=2>In <B>AES</B> versions 4.0 and above, <B>appl_getinfo()</B> should be used to determine the exact result of this call.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>SWM_LAUNCHACC</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Launch a <B>GEM</B> desk accessory. For the meaning of other parameters, see mode <B>SWM_LAUNCH</B> (0). This mode is only supported by <B>AES</B> versions of at least 4.0. </FONT>
</TD></TR>

<TR><TH></TH><TD><B>SWM_SHUTDOWN</B></TD><TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Manipulate 'Shutdown' mode. Shutdown mode is usually used prior to a resolution change to cause system processes to terminate. <I>wisgr</I>, <I>cmd</I>, and <I>tail</I> are ignored by this call. The value of <I>wiscr</I> determines the action this call takes as follows:</FONT><U><B>Name</B></U> <U><I><B>wiscr</B></I><B> Meaning</B></U>
<P>
<B><FONT SIZE=2>SD_ABORT</FONT></B> 0 Abort shutdown mode
<P>
<B><FONT SIZE=2>SD_PARTIAL</FONT></B> 1 Partial shutdown mode
<P>
<B><FONT SIZE=2>SD_COMPLETE</FONT></B> 2 Complete shutdown mode<FONT SIZE=2>During a shutdown, processes which have registered themselves as accepting <B>AP_TERM</B> messages will be sent them and all accessories will be sent <B>AC_CLOSE</B> messages. In addition, in complete shutdown mode, <B>AP_TERM</B> messages will also be sent to accessories.</FONT>
<P>
<FONT SIZE=2>Shutdown mode may be aborted but only by the original caller.</FONT>
<P>
<FONT SIZE=2>The status of the shutdown is sent to the calling processes by <B>AES</B> messages. See <B>evnt_mesag()</B>.</FONT>
<P>
<FONT SIZE=2>This mode is only supported by <B>AES</B> versions greater than or equal to 4.0.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>SWM_REZCHANGE</B></TD><TD>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Change screen resolution. <I>wisgr</I> is the work station ID (same as in <B>AES</B> <I>global[13]</I>) of the new resolution. No other parameters are utilized.</FONT>
<P>
<FONT SIZE=2>This mode is only recognized as of <B>AES</B> version 4.0.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>SWM_BROADCAST</B></TD><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Broadcast an <B>AES</B> message to all processes. <I>cmd</I> should point to an 8 <B>WORD</B> message buffer containing the message to send. All other parameters are ignored.</FONT>
<P>
<FONT SIZE=2>This mode is only recognized as of <B>AES</B> version 4.0.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>SWM_ENVIRON</B></TD><TD>
<CENTER>
<FONT SIZE=2>8</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Manipulate the <B>AES</B> environment. If <I>wisgr</I> is <B>ENVIRON_SIZE</B> (0), the current size of the environment string is returned.</FONT>
<P>
<FONT SIZE=2>If <I>wisgr</I> is <B>ENVIRON_CHANGE</B> (1), <I>cmd</I> should point to a environment variable to modify. If <I>cmd</I> points to "TOSEXT=TOS,TTP", that string will be added. Likewise, "TOSEXT=" will remove that environment variable.</FONT>
<P>
<FONT SIZE=2>If <I>wisgr</I> is <B>ENVIRON_COPY</B> (2), the <B>AES</B> will copy as many as <I>wiscr</I> bytes of the current environment string into a buffer pointer to by <I>cmd. </I>The function will return the number of bytes <I>not</I> copied.</FONT>
<P>
<FONT SIZE=2>This mode is only recognized as of <B>AES</B> version 4.0.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>SWM_NEWMSG</B></TD><TD>
<CENTER>
<FONT SIZE=2>9</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Inform the <B>AES</B> of a new message the current application understands. <I>wisgr</I> is a bit mask which specifies which new messages the application understands. Currently only bit 0 (<B>NM_APTERM</B>) has a meaning. Setting this bit when calling this function will inform the <B>AES</B> that the application understands <B>AP_TERM</B> messages. No other parameters are used.</FONT>
<P>
<FONT SIZE=2>This mode is only recognized as of <B>AES</B> version 4.0.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>SWM_AESMSG</B></TD><TD>
<CENTER>
<FONT SIZE=2>10</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Send a message to the <B>AES</B>. <I>cmd</I> points to an 8 <B>WORD</B> message buffer containing the message to send. No other parameters are needed.</FONT>
<P>
<FONT SIZE=2>This mode is only recognized as of <B>AES</B> version 4.0.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
intin[0] = mode;
intin[1] = wisgr;
intin[2] = wiscr;

addrin[0] = cmd;
addrin[1] = tail;

return crys_if(0x79);
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3>The value <B>shel_write()</B> differs depending on the mode which was invoked. See above for details.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Version Notes</B></TH><TD COLSPAN=3>Many new features were added as of <B>AES</B> version 4.0. For details of each, see above.
</TD></TR>

</TABLE>

<P>
<B> </B><FONT SIZE=5 FACE="Arial">Window Library</FONT>
<HR>

<P>
The <I>Window Library</I> is responsible for the displaying and
maintenance of <B>AES</B> windows. The members of the <I>Window
Library</I> are:
<P>
 wind_calc()
<P>
 wind_close()
<P>
 wind_create()
<P>
 wind_delete()
<P>
 wind_find()
<P>
 wind_get()
<P>
 wind_new()
<P>
 wind_open()
<P>
 wind_set()
<P>
 wind_update()
<a name=windcalc2><H3>wind_calc()</H3>

<P>
<B>WORD wind_calc( <I>request</I>, <I>kind</I>, <I>x1</I>, <I>y1</I>,
<I>w1</I>, <I>h1</I>, <I>x2</I>, <I>y2</I>, <I>w2</I>, <I>h2</I>
)</B>
<P>
<B>WORD <I>request</I>, <I>kind</I>, <I>x1</I>, <I>y1</I>, <I>w1</I>,
<I>h1</I>;</B>
<P>
<B>WORD *<I>x2</I>, *<I>y2</I>, *<I>w2</I>, *<I>h2</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>wind_calc()</B> returns size information for a specific window.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>108 (0x6C)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>request</I> specifies the mode of this call.
<P>
If <I>request</I> is <B>WC_BORDER</B> (0), <I>x1</I>, <I>y1</I>, <I>w1</I>, and <I>h1</I> specify the work area of a window of type <I>kind</I>. The call then fills in the <B>WORD</B>s pointed to by <I>x2</I>, <I>y2</I>, <I>w2</I>, and <I>h2</I> with the full extent of the window.
<P>
If request is <B>WC_WORK</B> (1), <I>x1</I>, <I>y1</I>, <I>w1</I>, and <I>h1</I> specify the full extent of a window of type <I>kind</I>. The call fills in the <B>WORD</B>s pointed to by <I>x2</I>, <I>y2</I>, <I>w2</I>, and <I>h2</I> with the work area of the window.
<P>
<I>kind</I> is a bit mask of window 'widgets' present with the window. For a detailed listing of these elements see <B>wind_create()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = request;
intin[1] = kind;
intin[2] = x1;
intin[3] = y1;
intin[4] = w1;
intin[5] = h1;

crys_if(0x6C);

*x2 = intout[1];
*y2 = intout[2];
*w2 = intout[3];
*h2 = intout[4];

return intout[0];
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>wind_calc()</B> returns 0 if an error occurred or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD><B>wind_calc() </B>is unable to calculate correct values when a toolbar is attached to a window. This can be corrected, though, by adjusting the values output by this function with the height of the toolbar.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>wind_create()</B></TD></TR>

</TABLE>

<P>

<HR>

<a name=windclose2><H3>wind_close()</H3>

<P>
<B>WORD wind_close( <I>handle</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>wind_close()</B> removes a window from the display screen.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>102 (0x66)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies the window handle of the window to close.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = handle;

return crys_if(0x66);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>wind_close()</B> returns 0 if an error occurred or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Upon calling <B>wind_close()</B> a redraw message for the portion of the screen changed will be sent to all applications.
<P>
Calling <B>wind_close()</B> does not release the memory allocated to the window structure. <B>wind_delete()</B> must be called to permanently destroy the window and free any memory allocated by the <B>AES</B> for the window. Until <B>wind_delete()</B> is called, the window may be re-opened at any time with <B>wind_open()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>wind_create(), wind_open(), wind_delete()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=windcreate2><H3>wind_create()</H3>

<P>
<B>WORD wind_create( <I>kind</I>, <I>x</I>, <I>y</I>, <I>w</I>,
<I>h</I> )</B>
<P>
<B>WORD <I>kind</I>, <I>x</I>, <I>y</I>, <I>w</I>, <I>h</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>wind_create()</B> initializes a new window structure and allocates any necessary memory.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>100 (0x64)</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>All <B>AES</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=5><I>kind</I> is a bit array whose elements determine the presence of any 'widgets' on the window as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Mask</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD><B>NAME</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x01</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Window has a title bar.</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>CLOSER</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x02</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Window has a close box.</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>FULLER</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x04</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Window has a fuller box.</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>MOVER</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x08</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Window may be moved by the user.</FONT>
</TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>INFO</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x10</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Window has an information line.</FONT></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD><B>SIZER</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x20</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Window has a sizer box.</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>UPARROW</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x40</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Window has an up arrow.</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>DNARROW</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x80</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Window has a down arrow.</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>VSLIDE</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x100</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Window has a vertical slider.</FONT></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD><B>LFARROW</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x200</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Window has a left arrow.</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>RTARROW</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x400</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Window has a right arrow.</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>HSLIDE</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x800</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Window has a horizontal slider.</FONT></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD><B>SMALLER</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x4000</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Window has an iconifier.</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH></TH><TD COLSPAN=5>The parameter kind is created by OR'ing together any desired elements.
<P>
<I>x</I>, <I>y</I>, <I>w</I>, and <I>h</I>, specify the maximum extents of the window. Normally this is the entire screen area minus the menu bar (to find this area use <B>wind_get() </B>with a parameter of <B>WF_WORKXYWH</B> ). The area may be smaller to bound the window to a particular size and location.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
intin[0] = kind;
intin[1] = x;
intin[2] = y;
intin[3] = w;
intin[4] = h;

return crys_if(0x64);
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=5><B>wind_create()</B> returns a window handle if successful or a negative number if it was unable to create the window.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Version Notes</B></TH><TD COLSPAN=5>The <B>SMALLER</B> gadget is only available as of <B>AES</B> version 4.1.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=5>A window is not actually displayed on screen with this call, you need to call <B>wind_open()</B> to do that.
<P>
<B>TOS</B> version 1.00 and 1.02 limited applications to four windows. In <B>TOS</B> version 1.04 that limit was raised to seven. As of <B>MultiTOS</B> the number of open windows is limited only by memory and the capabilities of an application.
<P>
You should ensure that your application calls a <B>wind_delete()</B> for each <B>wind_create()</B>, otherwise memory may not be deallocated when your application exits.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=5><B>wind_open(), wind_close(), wind_delete()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=winddelete2><H3>wind_delete()</H3>

<P>
<B>WORD wind_delete( <I>handle</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>wind_delete()</B> destroys the specified window and releases any memory allocated for it.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>103 (0x67)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies the window handle of the window to destroy.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = handle;

return crys_if(0x67);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>wind_delete()</B> returns 0 if an error occurred or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>A window should by closed with <B>wind_close()</B> before deleting it.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>wind_create(), wind_open(), wind_close(), wind_new()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=windfind2><H3>wind_find()</H3>

<P>
<B>WORD wind_find( <I>x</I>, <I>y</I> )</B>
<P>
<B>WORD <I>x</I>, <I>y</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>wind_find()</B> returns the handle of the window found at the given coordinates.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>106 (0x6A)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>x</I> and <I>y</I> specify the coordinates to search for a window at.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = x;
intin[1] = y;

return crys_if(0x6A);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>wind_find()</B> returns the handle of the uppermost window found at location <I>x</I>, <I>y</I>. If no window is found, the function returns 0 meaning the <B>Desktop</B> window.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This function is useful for tracking the mouse pointer and changing its shape depending upon what window it falls over.
</TD></TR>

</TABLE>

<P>

<HR>

<a name=windget2><H3>wind_get()</H3>

<P>
<B>WORD wind_get( <I>handle</I>, <I>mode</I>, <I>parm1</I>, <I>parm2</I>,
<I>parm3</I>, <I>parm4</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>mode</I>;</B>
<P>
<B>WORD *<I>parm1</I>, *<I>parm2</I>, *<I>parm3</I>, *<I>parm4</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>wind_get()</B> returns various information about a window.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>104 (0x68)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>All <B>AES</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>handle</I> specifies the handle of the window to return information about (0 is the desktop window). <I>mode</I> specifies the information to return and the values placed into the <B>WORD</B>s pointed to by <I>parm1</I>, <I>parm2</I>, <I>parm3</I>, and <I>parm4</I> as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >mode</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>WF_WORKXYWH</B></TD><TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>parm1</FONT></I>, <I>parm2</I>, <I>parm3</I>, and <I>parm4</I> are filled in with the x, y, w, and h of the current coordinates of the window's work area.
</TD></TR>

<TR><TH></TH><TD><B>WF_CURRXYWH</B></TD><TD>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>parm1</FONT></I>, <I>parm2</I>, <I>parm3</I>, and <I>parm4</I> are filled in with the x, y, w, and h of the current coordinates of the full extent of the window.
</TD></TR>

<TR><TH></TH><TD><B>WF_PREVXYWH</B></TD><TD>
<CENTER>
<FONT SIZE=2>6</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>parm1</FONT></I>, <I>parm2</I>, <I>parm3</I>, and <I>parm4</I> are filled in with the x, y, w, and h of the previous coordinates of the full extent of the window prior to the last <B>wind_set()</B> call.
</TD></TR>

<TR><TH></TH><TD><B>WF_FULLXYWH</B></TD><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>parm1</FONT></I>, <I>parm2</I>, <I>parm3</I>, and <I>parm4</I> are filled in with the x, y, w, and h values specified in the <B>wind_create()</B> call.
</TD></TR>

<TR><TH></TH><TD><B>WF_HSLIDE</B></TD><TD>
<CENTER>
<FONT SIZE=2>8</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>parm1</FONT></I> is filled in with the current position of the horizontal slider between 1 and 1000. A value of one indicates that the slider is in its leftmost position.
</TD></TR>

<TR><TH></TH><TD><B>WF_VSLIDE</B></TD><TD>
<CENTER>
<FONT SIZE=2>9</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>parm1</FONT></I> is filled in with the current position of the vertical slider between 1 and 1000. A value of one indicates that the slider is in its uppermost position.
</TD></TR>

<TR><TH></TH><TD><B>WF_TOP</B></TD><TD>
<CENTER>
<FONT SIZE=2>10</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>parm1</FONT></I> is filled in with the window handle of the window currently on top. As of <B>AES</B> version 4.0 (and when appl_getinfo() indicates), <I>parm2</I> is filled in with the owners <B>AES</B> id, and <I>parm3</I> is filled in with the handle of the window directly below it.
</TD></TR>

<TR><TH></TH><TD><B>WF_FIRSTXYWH</B></TD><TD>
<CENTER>
<FONT SIZE=2>11</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>parm1</FONT></I>, <I>parm2</I>, <I>parm3</I>, and <I>parm4</I> are filled in with the x, y, w, and h of the first <B>AES</B> rectangle in the window's rectangle list. If <I>parm3</I> and <I>parm4</I> are both 0, the window is completely covered.
</TD></TR>

<TR><TH></TH><TD><B>WF_NEXTXYWH</B></TD><TD>
<CENTER>
<FONT SIZE=2>12</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>parm1</FONT></I>, <I>parm2</I>, <I>parm3</I>, and <I>parm4</I> are filled in with subsequent <B>AES</B> rectangles for each time this function is called until <I>parm3</I> and <I>parm4</I> are 0 to signify the end of the list.
</TD></TR>

<TR><TH></TH><TD><B>WF_NEWDESK</B></TD><TD>
<CENTER>
<FONT SIZE=2>14</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>As of <B>AES</B> versions 4.0 (and when <B>appl_getinfo()</B> indicates), this <I>mode</I> returns a pointer to the current desktop background <B>OBJECT</B> tree. <I>parm1</I> contains the high <B>WORD</B> of the address and <I>parm2</I> contains the low <B>WORD</B>.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>WF_HSLSIZE</B></TD><TD>
<CENTER>
<FONT SIZE=2>15</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>parm1</FONT></I> contains the size of the current slider relative to the size of the scroll bar as a value from 1 to 1000. A value of 1000 indicates that the slider is at its maximum size.
</TD></TR>

<TR><TH></TH><TD><B>WF_VSLSIZE</B></TD><TD>
<CENTER>
<FONT SIZE=2>16</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>parm1</FONT></I> contains the size of the current slider relative to the size of the scroll bar as a value from 1 to 1000. A value of 1000 indicates that the slider is at its maximum size.
</TD></TR>

<TR><TH></TH><TD><B>WF_SCREEN</B></TD><TD>
<CENTER>
<FONT SIZE=2>17</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This <I>mode</I> returns a pointer to the current <B>AES</B> menu/alert buffer and its size. The pointer's high <B>WORD</B> is returned in <I>parm1</I> and the pointer's low <B>WORD</B> is returned in <I>parm2</I>. The length of the buffer is returned as a <B>LONG</B> with the upper <B>WORD</B> being in <I>parm3</I> and the lower <B>WORD</B> being in <I>parm4</I>. Note that <B>TOS</B> 1.02 returns 0 in <I>w</I> and <I>h</I> by mistake.</FONT>
<P>
<FONT SIZE=2><a name=menubuffer2>The menu/alert buffer is used by the <B>AES</B> to save the screen area hidden by menus and alert boxes. It is not recommended that applications use this area as its usage is not guaranteed in future versions of the OS.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>WF_COLOR</B></TD><TD>
<CENTER>
<FONT SIZE=2>18</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This <I>mode</I> gets the current color of the window widget specified on entry to the function in the <B>WORD</B> pointed to by <I>parm1</I>. Valid window widget indexes are as follows (<B>W_SMALLER</B> is only valid as of <B>AES</B> 4.1):</FONT><U> <I><B>parm1</B></I><B> Value <I>ob_type</I></B></U>
<P>
<FONT SIZE=2> <B>W_BOX </B>0<B> IBOX</B></FONT>
<P>
<B><FONT SIZE=2> W_TITLE </FONT></B>1<B> BOX</B>
<P>
<B><FONT SIZE=2> W_CLOSER </FONT></B>2<B> BOXCHAR</B>
<P>
<B><FONT SIZE=2> W_NAME </FONT></B>3<B> BOXTEXT</B>
<P>
<B><FONT SIZE=2> W_FULLER </FONT></B>4<B> BOXCHAR</B>
<P>
<B><FONT SIZE=2> W_INFO </FONT></B>5<B> BOXTEXT</B>
<P>
<B><FONT SIZE=2> W_DATA </FONT></B>6<B> IBOX</B>
<P>
<B><FONT SIZE=2> W_WORK </FONT></B>7<B> IBOX</B>
<P>
<B><FONT SIZE=2> W_SIZER </FONT></B>8<B> BOXCHAR</B>
<P>
<B><FONT SIZE=2> W_VBAR </FONT></B>9<B> BOX</B>
<P>
<B><FONT SIZE=2> W_UPARROW </FONT></B>10<B> BOXCHAR</B>
<P>
<B><FONT SIZE=2> W_DNARROW </FONT></B>11<B> BOXCHAR</B>
<P>
<B><FONT SIZE=2> W_VSLIDE </FONT></B>12<B> BOX</B>
<P>
<B><FONT SIZE=2> W_VELEV </FONT></B>13<B> BOX</B>
<P>
<B><FONT SIZE=2> W_HBAR </FONT></B>14<B> BOX</B>
<P>
<B><FONT SIZE=2> W_LFARROW </FONT></B>15<B> BOXCHAR</B>
<P>
<B><FONT SIZE=2> W_RTARROW </FONT></B>16<B> BOXCHAR</B>
<P>
<B><FONT SIZE=2> W_HSLIDE </FONT></B>17<B> BOX</B>
<P>
<B><FONT SIZE=2> W_HELEV </FONT></B>18<B> BOX</B>
<P>
<B><FONT SIZE=2> W_SMALLER </FONT></B>19 <B>BOXCHAR</B><FONT SIZE=2>The <I>ob_spec</I> field (containing the color information) used for the object when not selected is returned in the <B>WORD</B> pointed to by <I>parm2</I>. The <I>ob_spec</I> field used for the object when selected is returned in <I>parm3</I>.</FONT>
<P>
<FONT SIZE=2>This <I>mode</I> under <B>wind_get()</B> is only valid as of <B>AES</B> version 3.30. From <B>AES </B>versions 4.0 and above, <B>appl_getinfo()</B> should be used to determine if this mode is supported.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>WF_DCOLOR</B></TD><TD>
<CENTER>
<FONT SIZE=2>19</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This <I>mode</I> gets the default color of newly created windows as with <B>WF_COLOR</B> above. As above, this mode under <B>wind_get()</B> only works as of <B>AES</B> version 3.30.</FONT>
<P>
<FONT SIZE=2>As of <B>AES</B> version 4.1, <B>WF_DCOLOR</B> changes the color of open windows unless they have had their colors explicitly set with <B>WF_COLOR</B>.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>WF_OWNER</B></TD><TD>
<CENTER>
<FONT SIZE=2>20</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>parm1</FONT></I> is filled in with the <B>AES</B> id of the owner of the specified window. <I>parm2</I> is filled in with its open status (0 = closed, 1 = open). <I>parm3</I> is filled in with the handle of the window directly above it (in the window order list) and <I>parm4</I> is filled in with the handle of the window below it (likewise, in the window order list).
<P>
<FONT SIZE=2>This mode is only available as of <B>AES</B> version 4.0 (and when indicated by <B>appl_getinfo()</B>).</FONT>
</TD></TR>

<TR><TH></TH><TD><B>WF_BEVENT</B></TD><TD>
<CENTER>
<FONT SIZE=2>24</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>parm1</FONT></I>, <I>parm2</I>, <I>parm3</I>, <I>parm4</I> are each interpreted as bit arrays whose bits indicate supported window features. Currently only one bit is supported. If bit 0 of the value returned in <I>parm1</I> is 1, that window has been set to be 'un-toppable' and it will never receive <B>WM_TOPPED</B> messages, only button clicks.
<P>
<FONT SIZE=2>This mode is only available as of <B>AES</B> version 4.0 (and when indicated by appl_getinfo() ).</FONT>
</TD></TR>

<TR><TH></TH><TD><B>WF_BOTTOM</B></TD><TD>
<CENTER>
<FONT SIZE=2>25</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>parm1</FONT></I> will be filled in with the handle of the window currently on the bottom of the window list (it may actually be on top if there is only one window). Note also that this does not include the desktop window.
<P>
<FONT SIZE=2>This <I>mode</I> is only available as of <B>AES</B> version 4.0 (and when indicated by <B>appl_getinfo()</B>).</FONT>
</TD></TR>

<TR><TH></TH><TD><B>WF_ICONIFY</B></TD><TD>
<CENTER>
<FONT SIZE=2>26</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>parm1 </FONT></I>will be filled in with 0 if the window is not iconified or non-zero if it is. <I>parm2</I> and <I>parm3</I> contain the width and height of the icon. <I>parm4</I> is unused.
<P>
<FONT SIZE=2>This <I>mode</I> is only available as of <B>AES</B> version 4.1 (and when indicated by appl_getinfo() ).</FONT>
</TD></TR>

<TR><TH></TH><TD><B>WF_UNICONIFY</B></TD><TD>
<CENTER>
<FONT SIZE=2>27</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>parm1, parm2, parm3, </FONT></I>and <I>parm4, </I>are filled in with the x, y, w, and h of the original coordinates of the iconified window.
<P>
<FONT SIZE=2>This <I>mode</I> is only available as of <B>AES</B> version 4.1 (and when indicated by <B>appl_getinfo()</B>).</FONT>
</TD></TR>

<TR><TH></TH><TD><B>WF_TOOLBAR</B></TD><TD>
<CENTER>
<FONT SIZE=2>30</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>parm1 </FONT></I>and <I>parm2</I> contain the high and low <B>WORD</B> respectively of the pointer to the current toolbar object tree (or <B>NULL</B> if none).
<P>
<FONT SIZE=2>This <I>mode</I> is only available as of <B>AES</B> version 4.1.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>WF_FTOOLBAR</B></TD><TD>
<CENTER>
<FONT SIZE=2>31</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>parm1, parm2, parm3, </FONT></I>are<I> parm4, </I>are filled in with the x, y, w, and h, respectively of the first uncovered rectangle of the toolbar region of the window. If <I>parm3 </I>and <I>parm4 </I>are 0, the toolbar is completely covered.
<P>
<FONT SIZE=2>This <I>mode</I> is only available as of <B>AES</B> version 4.1.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>WF_NTOOLBAR</B></TD><TD>
<CENTER>
<FONT SIZE=2>32</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>parm1, parm2, parm3, </FONT></I>and <I>parm4, </I>are filled in with the x, y, w, and h, respectively of subsequent uncovered rectangles of the toolbar region. This mode should be repeated to reveal subsequent rectangles until <I>parm3 </I>and <I>parm4 </I>are found to be 0.
<P>
<FONT SIZE=2>This <I>mode</I> is only available as of <B>AES</B> version 4.1.</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
/* This binding must be different to */
/* accomodate reading WF_COLOR and   */
/* WF_DCOLOR                         */

contrl[0] = 0x68;
contrl[1] = 2;
contrl[2] = 5;
contrl[3] = 0;
contrl[4] = 0;
 
<FONT SIZE=2>intin[0] = handle;
</FONT>intin[1] = mode;

<FONT SIZE=2>if(mode == WF_DCOLOR || mode == WF_COLOR)
</FONT>{
<FONT SIZE=2> intin[2] = *x;
</FONT> contrl[1] = 3;
<FONT SIZE=2>} 

</FONT>aes();

<FONT SIZE=2>*x = intout[1];
</FONT>*y = intout[2];
<FONT SIZE=2>*w = intout[3];
</FONT>*h = intout[4];

<FONT SIZE=2>return intout[0];</FONT>
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3><B>wind_get()</B> returns a 0 if an error occurred or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>wind_set()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<a name=windnew><H3>wind_new()</H3>

<P>
<B>WORD wind_new( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>wind_new()</B> closes and deletes all of the application's windows. In addition, the state of <B>wind_update()</B>, and the mouse pointer hide count is reset.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>109 (0x6D)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>Available as of <B>AES</B> version 0x0140.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
return crys_if(0x6D);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD>The return value is reserved and currently unused
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This function should not be relied upon to clean up after an application. It was designed for parent processes that wish to ensure that a poorly written child process has properly cleaned up after itself.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>wind_delete(), graf_mouse(), wind_update()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=windopen2><H3>wind_open()</H3>

<P>
<B>WORD wind_open( <I>handle</I>, <I>x</I>,<I> y</I>,<I> w</I>,<I>
h</I> )</B>
<P>
<B>WORD <I>handle</I>;</B>
<P>
<B>WORD x, y, w, h;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>wind_open()</B> opens the window specified.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>101 (0x65)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>AES</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>handle</I> specifies the handle of the window to open as returned by <B>wind_create()</B>. <I>x</I>, <I>y</I>, <I>w</I>, and <I>h</I> specify the rectangle into which the rectangle should be displayed.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
intin[0] = handle;
intin[1] = x
intin[2] = y
intin[3] = w
intin[4] = h

return crys_if(0x65);
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>wind_open()</B> returns a 0 if an error occurred or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>This call will also trigger a <B>WM_REDRAW</B> message which encompasses the work area of the window so applications should not initially render the work area, rather, wait for the message.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>wind_close(), wind_create(), wind_delete()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=windset2><H3>wind_set()</H3>

<P>
<B>WORD wind_set( <I>handle</I>, <I>mode</I>, <I>parm1</I>, <I>parm2</I>,
<I>parm3</I>, <I>parm4</I> )</B>
<P>
<B>WORD <I>handle</I>, <I>mode</I>, <I>parm1</I>, <I>parm2</I>,
<I>parm3</I>, <I>parm4</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>wind_set()</B> sets various window attributes.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>105 (0x69)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>All <B>AES</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>handle</I> specifies the window handle of the window to modify. <I>mode</I> specifies the attribute to change and the meanings of <I>parm1</I>, <I>parm2</I>, <I>parm3</I>, and <I>parm4</I> as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >mode</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>WF_NAME</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This <I>mode</I> passes a pointer to a character string containing the new title of the window. <I>parm1 </I>contains the high <B>WORD</B> of the pointer and <I>parm2</I> contains the low <B>WORD</B>.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>WF_INFO</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This <I>mode</I> passes a pointer to a character string containing the new information line of the window. <I>parm1 </I>contains the high <B>WORD</B> of the pointer, <I>parm2</I> contains the low <B>WORD</B>.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>WF_CURRXYWH</B></TD><TD>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>parm1</FONT></I>, <I>parm2</I>, <I>parm3</I>, and <I>parm4</I> specify the x, y, w, and h of the new coordinates of the full extent of the window.
</TD></TR>

<TR><TH></TH><TD><B>WF_HSLIDE</B></TD><TD>
<CENTER>
<FONT SIZE=2>8</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>parm1</FONT></I> specifies the new position of the horizontal slider between 1 and 1000. A value of 1 indicates that the slider is in its leftmost position.
</TD></TR>

<TR><TH></TH><TD><B>WF_VSLIDE</B></TD><TD>
<CENTER>
<FONT SIZE=2>9</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>parm1</FONT></I> specifies the new position of the vertical slider between 1 and 1000. A value of 1 indicates that the slider is in its uppermost position.
</TD></TR>

<TR><TH></TH><TD><B>WF_TOP</B></TD><TD>
<CENTER>
<FONT SIZE=2>10</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>parm1</FONT></I> specifies the window handle of the window to top. Note that if multiple calls of <B>wind_set( WF_TOP</B>, ...<B> )</B> are made without releasing control to the <B>AES</B> (which allows the window to actually be topped), only the most recent window specified will actually change position.
</TD></TR>

<TR><TH></TH><TD><B>WF_NEWDESK</B></TD><TD>
<CENTER>
<FONT SIZE=2>14</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This <I>mode</I> specifies a pointer to an <B>OBJECT</B> tree which is redrawn automatically by the desktop as the background. <I>parm1 </I>contains the high <B>WORD </B>of the pointer and <I>parm2</I> contains the low <B>WORD</B>. To reset the desktop background to the default, specify <I>parm1 </I>and <I>parm2</I> as 0.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>WF_HSLSIZE</B></TD><TD>
<CENTER>
<FONT SIZE=2>15</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>parm1</FONT></I> defines the size of the current slider relative to the size of the scroll bar as a value from 1 to 1000. A value of 1000 indicates that the slider is at its maximum size.
</TD></TR>

<TR><TH></TH><TD><B>WF_VSLSIZE</B></TD><TD>
<CENTER>
<FONT SIZE=2>16</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>parm1</FONT></I> defines the size of the current slider relative to the size of the scroll bar as a value from 1 to 1000. A value of 1000 indicates that the slider is at its maximum size.
</TD></TR>

<TR><TH></TH><TD><B>WF_COLOR</B></TD><TD>
<CENTER>
<FONT SIZE=2>18</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This <I>mode</I> sets the current color of the window widget specified on entry in <I>parm1</I>. Valid window widget indexes are as follows (<B>W_SMALLER </B>is only valid as of <B>AES</B> 4.1):</FONT><U><B> <I>parm1</I> Value <I>ob_type</I></B></U>
<P>
<B><FONT SIZE=2> W_BOX</FONT></B> 0 <B>IBOX</B>
<P>
<B><FONT SIZE=2> W_TITLE</FONT></B> 1 <B>BOX</B>
<P>
<B><FONT SIZE=2> W_CLOSER </FONT></B>2 <B>BOXCHAR</B>
<P>
<B><FONT SIZE=2> W_NAME</FONT></B> 3 <B>BOXTEXT</B>
<P>
<B><FONT SIZE=2> W_FULLER</FONT></B> 4 <B>BOXCHAR</B>
<P>
<B><FONT SIZE=2> W_INFO</FONT></B> 5 <B>BOXTEXT</B>
<P>
<B><FONT SIZE=2> W_DATA</FONT></B> 6 <B>IBOX</B>
<P>
<B><FONT SIZE=2> W_WORK</FONT></B> 7 <B>IBOX</B>
<P>
<B><FONT SIZE=2> W_SIZER</FONT></B> 8 <B>BOXCHAR</B>
<P>
<B><FONT SIZE=2> W_VBAR</FONT></B> 9 <B>BOX</B>
<P>
<B><FONT SIZE=2> W_UPARROW </FONT></B>10 <B>BOXCHAR</B>
<P>
<B><FONT SIZE=2> W_DNARROW </FONT></B>11 <B>BOXCHAR</B>
<P>
<B><FONT SIZE=2> W_VSLIDE</FONT></B> 12 <B>BOX</B>
<P>
<B><FONT SIZE=2> W_VELEV</FONT></B> 13 <B>BOX</B>
<P>
<B><FONT SIZE=2> W_HBAR</FONT></B> 14 <B>BOX</B>
<P>
<B><FONT SIZE=2> W_LFARROW </FONT></B>15 <B>BOXCHAR</B>
<P>
<B><FONT SIZE=2> W_RTARROW</FONT></B> 16 <B>BOXCHAR</B>
<P>
<B><FONT SIZE=2> W_HSLIDE</FONT></B> 17 <B>BOX</B>
<P>
<B><FONT SIZE=2> W_HELEV</FONT></B> 18 <B>BOX</B>
<P>
<B><FONT SIZE=2> W_SMALLER </FONT></B>19 <B>BOXCHAR</B><FONT SIZE=2>The <I>ob_spec</I> field of the object (containing the color information) while the window is on top is defined in <I>parm2</I>. The <I>ob_spec</I> field for the object while the window is not on top is defined in <I>parm3</I>. </FONT>This <I>mode</I> is only valid as of <B>AES</B> version 0x0300.
</TD></TR>

<TR><TH></TH><TD><B>WF_DCOLOR</B></TD><TD>
<CENTER>
<FONT SIZE=2>19</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This <I>mode</I> sets the default color of newly created windows as with <B>WF_COLOR</B> above. This mode only works as of <B>AES</B> version 0x0300. As of <B>AES</B> version 4.1, this mode causes all currently displayed windows which have not had their color explicitly set with <B>WF_COLOR</B> to be changed.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>WF_BEVENT</B></TD><TD>
<CENTER>
<FONT SIZE=2>24</FONT>
</CENTER>

</TD><TD><I><FONT SIZE=2>parm1</FONT></I>, <I>parm2</I>, <I>parm3</I>, and <I>parm4</I> are each interpreted as bit arrays whose bits indicate supported window features. Currently only one bit is supported. If bit 0 (<B>B_UNTOPPABLE</B>) of <I>parm1</I> is set, the window will be set to be 'un-toppable' and it will never receive <B>WM_TOPPED</B> messages, only button clicks.<FONT SIZE=2>This <I>mode</I> is only available as of <B>AES</B> versions 4.0.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>WF_BOTTOM</B></TD><TD>
<CENTER>
<FONT SIZE=2>25</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This <I>mode</I> will place the specified window at the bottom of the window list (if there is more than one window) and top the new window on the top of the list.</FONT>This <I>mode</I> is only available as of <B>AES</B> version 4.0.
</TD></TR>

<TR><TH></TH><TD><B>WF_ICONIFY</B></TD><TD>
<CENTER>
<FONT SIZE=2>26</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This <I>mode</I> iconifies the specified window to the X, Y, width, and height coordinates given in <I>parm1</I>, <I>parm2</I>, <I>parm3,</I> and <I>parm4</I> respectively. Normally, this happens as the result of receiving a <B>WM_ICONIFY</B> message.</FONT>This <I>mode</I> is only available as of <B>AES</B> version 4.1.
</TD></TR>

<TR><TH></TH><TD><B>WF_UNICONIFY</B></TD><TD>
<CENTER>
<FONT SIZE=2>27</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This <I>mode</I> uniconifies the window specified, returning it to its original X, Y, width, and height as specified in <I>parm1</I>, <I>parm2</I>, <I>parm3</I>, and <I>parm4</I> respectively. Normally, this happens as the result of receiving a <B>WM_UNICONIFY</B> message.</FONT>This <I>mode</I> is only available as of <B>AES</B> version 4.1.
</TD></TR>

<TR><TH></TH><TD><B>WF_UNICONIFYXYWH</B></TD><TD>
<CENTER>
<FONT SIZE=2>28</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This mode sets the X, Y, width, and height that will be transmitted to the window with the next <B>WM_UNICONIFY</B> message that targets it. This call is used when a window is opened in an iconified state to give the OS a method of positioning it when it is uniconified.</FONT>This <I>mode</I> is only available as of <B>AES</B> version 4.1.
</TD></TR>

<TR><TH></TH><TD><B>WF_TOOLBAR</B></TD><TD>
<CENTER>
<FONT SIZE=2>30</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This <I>mode</I> attaches a toolbar to the specified window. <I>parm1</I> and <I>parm2</I> contain the high and low <B>WORD</B> of the address of the toolbar <B>OBJECT</B> tree respectively. <I>parm3</I> and <I>parm4</I> are unused.</FONT>Set <I>parm1</I> and <I>parm2</I> to 0 to remove a toolbar.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
intin[0] = handle;
intin[1] = mode;
intin[2] = x;
intin[3] = y;
intin[4] = w;
intin[5] = h;

return crys_if(0x69);
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3><B>wind_set()</B> returns 0 if an error occurred or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>wind_get()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<a name=windupdate2><H3>wind_update()</H3>

<P>
<B>WORD wind_update( <I>mode</I> )</B>
<P>
<B>WORD <I>mode</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>wind_update()</B> manages the screen drawing semaphore.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>107 (0x6B)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>All <B>AES</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>mode</I> specifies an action as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >mode</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>END_UPDATE</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This mode resets the flag set by <B>BEG_UPDATE</B> and should be called as soon as redrawing is complete. This will allow windows to be moved and menus to be dropped down again.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>BEG_UPDATE</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Calling this mode will suspend the process until no drop-down menus are showing and no other process is updating the screen. This will then set a flag which guarantees that the screen will not be updated and windows will not be moved until you reset it with <B>END_UPDATE</B>.</FONT>Generally this call is made whenever a <B>WM_REDRAW</B> message is received to lock the screen semaphore while redrawing.
</TD></TR>

<TR><TH></TH><TD><B>END_MCTRL</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This mode releases control of the mouse to the <B>AES</B> and resumes mouse click message services.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>BEG_MCTRL</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This mode prevents mouse button messages from being sent to applications other than your own. </FONT><B>form_do()</B> makes this call to lock out screen functions. Desk accessories which display a dialog outside of a window must use this function to prevent button clicks from falling through to the desktop. 
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
intin[0] = mode;

return crys_if(0x6B);
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3><B>wind_update()</B> returns 0 if an error occurred or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Version Notes</B></TH><TD COLSPAN=3>As of <B>AES</B> version 4.0, you may logically OR a mask of <B>NO_BLOCK</B> (0x0100) to either <B>BEG_UPDATE</B> or <B>BEG_MCTRL</B>. This mask will prevent the application from blocking if another application currently has control of the screen semaphore. Instead, if another application has control, the function will immediately return with an error value of 0.This method should only be used by timing-sensitive applications such as terminal programs in which a long redraw by another application could cause a timeout.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=3>All <B>wind_update()</B> modes nest. For instance, to release the screen semaphore, the same number of <B>END_UPDATE</B> calls must be received as were <B>BEG_UPDATE</B> calls. It it recommended that you design your application in a manner that avoids nesting these calls. Both the <B>BEG_UPDATE</B> and <B>BEG_MCTRL</B> modes should be used prior to displaying a form or popup to prevent them from being overwritten or clicks to them being sent to other applications.Always wait until <I>after</I> the <B>BEG_UPDATE</B> call to turn off the mouse cursor when updating the screen to be sure you have gained control of the screen.Applications such as slide-show viewers which require the whole screen area (and may need to change screen modes) may call <B>wind_update()</B> with parameters of both <B>BEG_UPDATE</B> and <B>BEG_MCTRL</B> to completely lock out the screen from other applications. The application would still be responsible for saving the screen area, manipulating video modes as necessary, restoring the screen when done, and returning control of the screen to other applications with <B>END_UPDATE</B> and <B>END_MCTRL</B>. 
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=3><B>wind_new()</B></TD>
</TR>

</TABLE>

<P>
<B></B>
<hr><center><a href="toc.htm"> Table of Contents | </a><a href="index.htm"> Index </a></center>
</BODY>

</HTML>
