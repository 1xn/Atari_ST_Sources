<HTML>

<HEAD>

<TITLE>The Atari Compendium: XBIOS</TITLE>


</HEAD>

<BODY BACKGROUND BGCOLOR=#FFFFFF>
<P>
<a name=chap4><B><FONT SIZE=2>- CHAPTER 4 -</FONT></B>
<a name=xbios><H2>XBIOS</H2>

<HR>

<a name=overview><H4><FONT SIZE=4 >Overview</FONT></H4>

<HR>

<P>
The e<B>X</B>tended <B>B</B>asic <B>I</B>nput/<B>O</B>utput <B>S</B>ystem<B>
</B>(<B>XBIOS</B>) is a software sub-system of <B>TOS</B> which
contains functions used to interact with and control Atari computer
hardware. The availability of many of these functions is dependent
on hardware whose presence can be determined by the current <B>TOS</B>
version or by interrogating the system 'cookie jar' (see <I>Chapter
3: <B>BIOS</B></I> for more details).
<P>
Some functions (notably video hardware and storage device related
functions) should only be used by device drivers and system level
software as they represent a non-portable method of hardware interaction
which may be unsupported in future Atari computers.
<P>
As a general rule, <B>GEMDOS</B> and <B>VDI</B> functions should
be used, when possible, rather than <B>XBIOS</B> calls. The <B>GEMDOS</B>
and <B>VDI</B> provide a software abstraction layer which will
make software applications much more compatible across new computer
releases.
<HR>

<a name=video><H4><FONT SIZE=4 ><a name=videocontrol>Video Control</FONT></H4>

<HR>

<P>
The video capabilities of Atari computer systems have varied greatly
since their introduction. Applications which use the <B>VDI</B>
for their video displays will require little if any modifications
to run on new systems. The <B>XBIOS</B> is mostly required for
device drivers and other applications which require more direct
control over the video hardware. When present, the '_VDO' entry
in the system cookie jar will reveal information about the video
hardware present.
<a name=logicalscreen><H5>The Physical/Logical Screen</H5>

<P>
Two separate video display pointers are maintained by the <B>XBIOS</B>
at any time. The <a name=physicalscreen>physical screen address points to the memory
location that the video shifter uses to update the display. This
memory must <I>not</I> be in fast RAM and must be <B>WORD</B>-aligned
(original ST computers expect screen memory to be aligned to a
256-byte boundary).
<P>
<a name=memory>A second video memory pointer points to the 'logical' screen.
This memory area is used by the <B>VDI</B> to output graphics.
Normally, the physical screen address is equal to the logical
screen address meaning that <B>VDI</B> output is shown immediately
on screen. Software (most commonly games) can allocate an additional
memory block and use these two pointers to <a name=pageflipping>page-flip for smooth
animations.
<P>
<a name=determiningthesize><a name=physbase><B>Physbase()</B> and <a name=logbase><B>Logbase()</B> return these ngtwo addresses.
<B>Setscreen()</B> can be used to reset these addresses and change
screen modes. As of <B>TOS</B> 4.0, <B>Setscreen()</B> reinitializes
the <B>VDI</B> screen driver<B> </B>(you must still call <B>vq_extnd()</B>
to update your workstations) but will <I>not</I> reinitialize
the <B>AES</B>. This means that if you change resolution using
<B>Setscreen()</B>, do not use the <B>AES</B> until the screen
is restored to its original resolution. On <B>TOS</B> versions
prior to 4.0, you should not use any <B>GEM</B> calls while the
screen mode is altered.
<P>
The Falcon030 function <a name=vgetsize><B>VgetSize()</B> is a utility function
that will return the number of bytes that must be allocated for
the specified video mode. When not running on a Falcon030, you
will have to calculate this yourself.
<a name=setting><H5>Setting/Determining Screen Resolution</H5>

<P>
<a name=getrez><B>Getrez()</B> was <I>originally</I> a safe method for determining
the current video hardware configuration. As new video modes became
available, though, <B>Getrez()</B> became less and less useful.
Currently, <B>Getrez()</B> should be used for <I>only</I> one
purpose. The formula <B>Getrez()</B> + 2 should be used to select
the <B>VDI</B> physical device ID for the screen so that the proper
screen fonts can be selected. See the description of <B>v_opnvwk()</B>
for more details.
<P>
<a name=resolution>In order to provide true screen independence, you should use the
values returned by the <B>VDI</B> call <B>v_opnvwk()</B> to determining
the screen resolution your application is using. The <B>XBIOS</B>
provides calls that will determine the current video mode but
they are hardware dependent and will probably stop working as
expected as new video hardware is released. 
<P>
The <B>Getrez()</B> call can reliably determine the video mode
of an ST, STe or Mega ST/e. Three calls have since been added
to determine the video mode of the TT030 and Falcon030 computers.
<P>
<a name=egetshift><B>EgetShift() </B>and <a name=esetshift><B>EsetShift()</B> can be used to interrogate
and set the TT030 video mode. <a name=vsetmode><B>VsetMode()</B> can similarly
be used to interrogate and set the Falcon030 video mode. The Falcon030
call <a name=vgetmonitor><B>VgetMonitor()</B> can be used to determine the type of
attached monitor and, therefore, the available video modes.
<P>
TT030 <B>TOS</B> also provides the calls <a name=esetgray><B>EsetGray()</B> and
<a name=esetsmear><B>EsetSmear()</B>. Together, these calls duplicate some of the
functionally contained in <B>EsetShift()</B> but can be used individually
as desired to configure the special <a name=grayscale>gray-scale and <a name=smearmode>smear modes
present in the TT030. 
<P>
<a name=esetshift2><B>EsetShift()</B> and <a name=vsetmode2><B>VsetMode()</B> are designed to change
the video modes of the TT030 and Falcon030 respectively, however,
they do not reinitialize the <B>AES</B> or <B>VDI</B>. It is also
possible to change TT030 and Falcon030 video modes using <B>Setscreen()</B>.
TT030 modes are set by supplying the appropriate resolution code
(see <B>Getrez()</B> for a list of resolution codes). Falcon030
modes are set by adding an extra parameter to the call with a
special resolution code of 3. See the explanation for <a name=setscreen><B>Setscreen()</B>
later in this chapter for details.
<H5>Manipulating the Palette</H5>

<P>
<a name=paletteregisters>Prior to the introduction of the TT, <a name=setcolor><B>Setcolor()</B> and <a name=setpalette><B>Setpalette()</B>
were used to set the 16 available palette entries. <B>Setpalette()</B>
sets the entire palette at once whereas <B>Setcolor()</B> sets
colors at an individual level and can also be used to interrogate
palette entries.
<P>
The ST has 16 palette entries, each supporting any of 512 available
colors. The ST specifies color in components of red, green, and
blue. Intensity settings of 0-7 are valid for each color component.
The following list contains the red, green, and blue values for
the ST's default 16 color palette.
<TABLE BORDER=1>

<TR><TH>
<CENTER>
<B><FONT SIZE=1 >Index</FONT></B>
</CENTER>

</TH><TH>
<CENTER>
<B><FONT SIZE=2 >Color</FONT></B>
</CENTER>

</TH><TH>
<CENTER>
<B><FONT SIZE=2 >Red</FONT></B>
</CENTER>

</TH><TH>
<CENTER>
<B><FONT SIZE=2 >Green</FONT></B>
</CENTER>

</TH><TH>
<CENTER>
<B><FONT SIZE=2 >Blue</FONT></B>
</CENTER>

</TH></TR>

<TR><TD>
<CENTER>
0
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>White</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>
</TD></TR>

<TR><TD>
<CENTER>
1
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>Red</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>
</TD></TR>

<TR><TD>
<CENTER>
2
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>Green</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>
</TD></TR>

<TR><TD>
<CENTER>
3
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>Yellow</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>
</TD></TR>

<TR><TD>
<CENTER>
4
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>Blue</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>
</TD></TR>

<TR><TD>
<CENTER>
5
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>Magenta</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>
</TD></TR>

<TR><TD>
<CENTER>
6
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>Cyan</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>
</TD></TR>

<TR><TD>
<CENTER>
7
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>Light Gray</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>
</TD></TR>

<TR><TD>
<CENTER>
8
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>Dark Gray</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>
</TD></TR>

<TR><TD>
<CENTER>
9
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>Light Red</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>
</TD></TR>

<TR><TD>
<CENTER>
10
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>Light Green</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>
</TD></TR>

<TR><TD>
<CENTER>
11
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>Light Yellow</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>
</TD></TR>

<TR><TD>
<CENTER>
12
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>Light Blue</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>
</TD></TR>

<TR><TD>
<CENTER>
13
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>Light Magenta</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>
</TD></TR>

<TR><TD>
<CENTER>
14
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>Light Cyan</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>
</TD></TR>

<TR><TD>
<CENTER>
15
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>Black</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>
</TD></TR>

</TABLE>

<P>
 
<P>
You might have noticed that these registers are not mapped the
same as <B>VDI</B> color indexes. The <B>VDI</B> re-maps color
requests to its own needs. For a list of these re-mappings, see
the entry for <a name=vr_trnfm><B>vr_trnfm()</B>. It is also possible to build
a remapping table on the fly by plotting one pixel for each <B>VDI</B>
pen on the screen and using the <B>VDI</B> <a name=vgetpixel><B>v_get_pixel()</B>
call on each to return the <B>VDI</B> and hardware register index.
<P>
Each of the sixteen color registers is bitmapped into a <B>WORD</B>
as follows (The first row indicates color, the second is bit significance):
<PRE>

<CENTER>
<FONT SIZE=2>xxxx xRRR xGGG xBBB
</FONT><FONT SIZE=2 FACE="Courier New">xxxx x321 x321 x321
</FONT>
</CENTER>

</PRE>

<P>
The STe series expanded the color depth to four bits instead of
three which expanded the number of available colors from 512 to
4096. This changed the layout of these color <B>WORD</B>s as follows:
<PRE>

<CENTER>
<FONT SIZE=2>xxxx RRRR GGGG BBBB
</FONT><FONT SIZE=2 FACE="Courier New">xxxx 1432 1432 1432
</FONT>
</CENTER>

</PRE>

<P>
This odd <a name=blayout>bit layout allowed for backward compatibility to the
ST series.
<P>
The TT030 supports an expanded palette of 256 entries in 16 banks
containing any of 4096 colors. The first bank of colors is still
supported by <a name=setcolor2><B>Setcolor()</B> and<B><a name=setpalette2> Setpalette()</B>, however
to access the additional 240 colors, 4 additional palette support
calls were added.
<P>
<a name=esetpalette><B>Esetpalette()</B>, <a name=eget><B>Egetpalette()</B>, and <a name=esetcolor><B>Esetcolor()</B>
provide access to these colors in a similar manner to <B>Setpalette()</B>
and <B>Setcolor()</B>. <a name=esetbank><B>Esetbank()</B> switches between the
16 available banks of colors in color modes that support less
than 16 colors. You should note that the TT030 color calls returned
the color <B>WORD</B>s to normal bit ordering as follows:
<PRE>

<CENTER>
<FONT SIZE=2>xxxx RRRR GGGG BBBB
</FONT><FONT SIZE=2 FACE="Courier New">xxxx 4321 4321 4321
</FONT>
</CENTER>

</PRE>

<P>
When using the TT's special gray mode, the lower eight bits of
each hardware register is used as a gray value from 0-255.
<P>
The Falcon030 computer gives up the TT030 calls in favor of a
more portable method of setting the hardware palette (ST calls
will remain as compatible as possible). <a name=vsetrgb><B>VsetRGB()</B> and <a name=vgetrgb><B>VgetRGB()</B>
set color palette entries based on 24-bit true color values. The
<B>XBIOS</B> will scale these values as appropriate for the screen
mode.
<H5>Advanced Video</H5>

<P>
<a name=vsync><B>Vsync()</B> halts all further processing by the application
until a vertical blank interrupt occurs. This interrupt signals
that the video display gun has reached the bottom of the display
and is returning to the top. At this time, a brief period occurs
where updates to the screen will not be immediately apparent to
the user. This time is usually used to present flicker-free animation
and redraws.
<P>
<a name=vsetsync><B>VsetSync()</B> is used to enable external hardware video synchronization
for devices such as <a name=genlock>GENLOCK's. Both the vertical and horizontal
syncronizations may be set independent of each other with this
call.
<P>
<a name=vsetmask><B>VsetMask()</B> provides easy access to the Falcon030's overlay
mode. This call allows you to specify bits which will be added
or removed to future color definitions created with the <B>VDI</B>
call <B>vs_color()</B>. When a GENLOCK hardware device is connected,
pixels with their overlay bit cleared will be replaceable by the
device with external video.
<HR>

<a name=falcon><a name=falcon030soundsystem><H4><FONT SIZE=4 >The Falcon030 Sound System</FONT>
</H4>

<HR>

<P>
<B>XBIOS</B> sound system calls are only present as of the Falcon030
computer (though their presence should always be verified by the
'_SND' cookie). If you want to program digitized audio that<a name=waveplay> plays
on an STe, TT, and Falcon030, see <I>Chapter 5: <B>Hardware</B></I>.
<P>
The Falcon030 sound system consists of four stereo 16-bit DMA
playback and record channels, an onboard <a name=adc>ADC (microphone jack),
<a name=dac>DAC (speaker and headphone jack), connection matrix, and digital
signal processor.
<P>
When your application uses the sound system you should first lock
it with<B> <a name=locksnd>Locksnd()</B>. This ensures that other system processes
don't try to access the sound system simultaneously. <a name=unlocksnd><B>Unlocksnd()</B>
should be used as soon as the sound system is free.
<P>
Each of four possible source devices can be connected to any or
all of the four possible destination devices using the connection
matrix as follows:
<P>
The external input and output are accessible with a specially
designed hardware device connected to the DSP connector.
<a name=matrix><a name=connectionmatrix><H5>The Connection Matrix</H5>

<P>
The sound system call <a name=devconnect><B>Devconnect()</B> connects sound system
components together. You must specify the source device, destination
device(s), source clock, <a name=prescaler>prescaler setting, and <a name=handshaking>handshaking protocol.
<P>
The source clock can be set to either of two internal clocks (25.175
MHz and 32 MHz) or an external clock. The internal DMA sound routines
are only compatible with the 25.175 MHz clock. Other clock sources
are used in conjunction with external hardware devices.
<P>
The prescaler sets the actual sample playback and recording rate.
A value of 0 will cause the sound system to use a STe/ TT030 compatible
prescaler for outputting sound recorded at STe/TT030 frequencies.
One STe/TT030 <a name=settingfrequency>frequency, 6.258 kHz, is not supported on the Falcon030.
You can set the STe/TT030 prescaler with the <a name=soundcmd><B>Soundcmd()</B>
call. Using values other than 0 will set the Falcon030 prescaler
as documented under the <B>Devconnect()</B> call.
<P>
The last parameter you must pass to <B>Devconnect()</B> specifies
whether to enable or disable hardware handshaking. Enabling handshaking
will produce data that is 100% error free but will result in a
variable transfer rate which may negatively affect digital sound.
Handshaking is generally only enabled when the data being transferred
must be transferred without errors (usually compressed audio or
video data).
<a name=recording><H5>Recording/Playing Digital Audio</H5>

<P>
To record or playback an audio sample, use <a name=setbuffer><B>Setbuffer()</B>
to identify the location and length of your playback/recording
buffer. Also, any <a name=devconnect2><B>Devconnect()</B>, <a name=setmode><B>Setmode()</B>, and <a name=soundcmd2><B>Soundcmd()</B>
calls should be made prior to starting your playback/recording
to set the sound hardware to the proper frequency and mode. 
<P>
The Falcon030 <I>only</I> supports the recording of 16-bit stereo
audio. To generate 8-bit samples you must scale the values in
the buffer from <B>WORD</B>s to <B>BYTE</B>s after recording.
<P>
When processing either recording or playback through the DSP,
the command <a name=dsp_tristate><B>Dsptristate()</B> must be used to connect the DSP
to the matrix.
<P>
You may use the function <B>Setinterrupt()</B>, as desired, to
cause a MFP or Timer A interrupt at the end of every frame. This
is most useful when you are playing or recording in repeat mode
and you wish to use multiple buffers.
<P>
<a name=buffptr><B>Buffptr()</B> may be used to determine the current playback
or record buffer pointer as sounds are being played/recorded.
<P>
<a name=selectingtracks><a name=setmontracks><B>Setmontracks()</B> is used to define which track which will
be output over the computer speaker/headphones. <a name=settracks><B>Settracks()</B>
controls which tracks will be used to record/playback data.
<a name=configuringlevels><H5>Configuring Levels</H5>

<P>
The function <B>Soundcmd()</B> has four modes which allow the
setting and interrogation of the current levels of <a name=attenuation>attenuation
and gain. Gain affects input levels. The higher the value for
gain, the louder the microphone input will be. Attenuation affects
output levels. The higher the attenuation setting, the softer
sounds will be output from the computer speaker/headphone jack.
<H5>Other Calls</H5>

<P>
<B><a name=sndstatus>Sndstatus()</B> can be used to tell if a source clock rate
was correctly set or if hardware clipping has occurred on either
channel.
<P>
<a name=gpio><B>Gpio()</B> is used to communicate data over the three general
<a name=pins>purpose pins of the DSP connector.
<HR>

<a name=dsp><H4><FONT SIZE=4 >The DSP</FONT></H4>

<HR>

<P>
The Falcon030 comes standard with a Motorola 56001 digital signal
processor (DSP). Digital signal processors are useful for many
different purposes such as audio/video compression, filtering,
encryption, modulation, and math functions.
<P>
The DSP is able to support both programs and subroutines. Both
must be written in 56001 assembly language (or a language which
outputs 56001 object code). A full treatment of 56001 assembly
language is beyond the scope of this document. Consult the <I>DSP56000/56001
Digital Signal Processor's User Manual</I> published by Motorola,
Inc. for more information.
<P>
The DSP is capable of having many subroutines resident in memory,
however, only one program may be loaded at any time.
<P>
When using the DSP you should call <a name=dsp_lock><B>Dsp_Lock()</B> to prevent
other processes from modifying your setup and to ensure that you
do not modify the work of other processes. Call <a name=dsp_unlock><B>Dsp_Unlock()</B>
when done (the DSP's MR and IPR registers should have been returned
to their original state) to release the DSP semaphore. 
<H5>DSP Memory</H5>

<P>
The Falcon030's DSP contains 96K bytes of RAM for system programs,
user programs, and subroutines. The DSP uses three distinct address
spaces, X, Y, and P. Program memory (P) overlaps both X and Y
memory spaces. Because of this, DSP programs should be careful
when referencing memory. The following is a memory map of the
DSP:
<center><br><img src="../graphics/chap49.gif"></center>
<a name=wordsize><H5>DSP Word Size</H5>

<P>
The 56001 uses a 24-bit <B>WORD</B>. Future Atari computers may
use different DSP's with different <B>WORD</B> sizes. Use the
<a name=dsp_gws><B>Dsp_GetWordSize()</B> call prior to using the DSP to determine
the proper DSP <B>WORD</B> size.
<a name=subroutines><H5>DSP Subroutines</H5>

<P>
Subroutines are usually short programs (no longer than 1024 DSP
<B>WORD</B>s) which transform incoming data. Each subroutine must
be written to be fully relocatable. When writing subroutines,
start instructions at location $0. All addresses in the subroutine
must be relocatable based on the original PC of $0 in order to
function. An alternative to this is to include a stub program
at the start of your subroutine that performs a relocation based
upon the start address assigned by the <B>XBIOS</B> (which is
available in X:HRX at subroutine start).
<P>
Subroutines should store initialized data within its program space.
The memory area from $3f00-$3fff is reserved for use as the BSS
of subroutines. Subroutines must not rely on the BSS's data to
remain constant between subroutine calls.
<P>
Each subroutine must be assigned a unique ability code either
by using one predefined by Atari (none have been published yet)
or by using the <a name=dsp_rua><B>Dsp_RequestUniqueAbility()</B> call. Since
subroutines are only flushed from the DSP when necessary, an application
may be able to use an existing subroutine with the same ability
left by another application by using the <a name=dsp_isa><B>Dsp_InqrSubrAbility()</B>
call.
<P>
Here is a sample of how to load a DSP subroutine with a non-unique
ability code:
<PRE>
if(!DSP_Lock())
{
	ability = <a name=dsp_rua2>DSP_RequestUniqueAbility();
	handle = <a name=dsp_ls>DSP_LoadSubroutine( subptr, length, ability );
	if(!handle)
	{
		<a name=dsp_fs>	DSP_FlushSubroutines();
			handle = DSP_LoadSubroutine( subptr, length, ability );
			if(!handle)
				error("Unable to load DSP subroutine");
	}

	if(handle)
	{
			<a name=dsp_rs>if(!Dsp_RunSubroutine( handle ))
			<a name=dsp_dob2>	DSP_DoBlock( data_in, size_in, data_out, size_out);
			else
				error("Unable to run DSP subroutine!");
	}
}

</PRE>

<H5><FONT SIZE=2><a name=programs>DSP Programs</FONT></H5>

<P>
Only one DSP program may be resident in memory at once. Prior
to loading a DSP program you should ensure enough memory is available
for your program by calling <a name=dsp_available><a name=dsp_a><B>Dsp_Available()</B>. If not enough
memory is available, you may have to flush resident subroutines
to free enough memory.
<P>
After you have found that enough memory is available, you must
reserve it with <a name=dsp_reserve><B>Dsp_Reserve()</B>. This memory will be reserved
until the next <B>Dsp_Reserve()</B> call so you should ensure
that you have called <a name=dsp_lock2><B>Dsp_Lock()</B> to block other processes
from writing over your program.
<P>
Programs can be stored in either binary or ASCII ('.LOD') format.
The function <a name=dsp_ltb><B>Dsp_LodToBinary()</B> can be used to convert this
data. DSP programs in binary form load much faster than those
in the '.LOD' format.
<P>
<a name=dsp_lp><B>Dsp_LoadProg()</B> is used to execute programs stored on disk
in the '.LOD' format. <a name=dsp_ep><B>Dsp_ExecProg()</B> is used to execute
programs stored in memory in binary format.
<P>
As with subroutines, programs are assigned a unique ability code
that can be determined with <a name=dsp_gpa><B>Dsp_GetProgAbility()</B>.
<a name=sdata><H5>Sending Data to the DSP</H5>

<P>
Several functions transfer data to and from DSP programs and subroutines
as follows:
<P>
 <a name=dsp_dob><B>Dsp_DoBlock()</B>
<P>
 <a name=dsp_blk><B>Dsp_BlkHandshake()</B>
<P>
 <a name=dsp_blkunpkd><B>Dsp_BlkUnpacked()</B>
<P>
 <a name=dsp_blkwords><B>Dsp_BlkWords()</B>
<P>
 <a name=dsp_b><B>Dsp_BlkBytes()</B>
<P>
 <a name=dsp_mb><B>Dsp_MultBlocks()</B>
<P>
 <a name=dsp_is><B>Dsp_InStream()</B>
<P>
 <a name=dsp_os><B>Dsp_OutStream()</B>
<P>
You should read the description of each in the function reference
and decide which is best suited for your needs.
<P>
<a name=dsp_sv><B>Dsp_SetVectors()</B> installs special purpose routines that
are called when the DSP sends an interrupt indicating it is ready
to send or receive data. <a name=dsp_rint><B>Dsp_RemoveInterrupts()</B> removes
these routines from the vector table in memory.
<a name=state><H5>DSP State</H5>

<P>
The HFx bits of the HSR register can be read atomically with the
four calls <a name=dsp_hf0><B>Dsp_Hf0()</B>, <a name=dsp_hf1><B>Dsp_Hf1()</B>, <a name=dsp_hf2><B>Dsp_Hf2()</B>,
and <a name=dsp_hf3><B>Dsp_Hf3()</B>. The current value of the <a name=isr>ISR register may
be read with <a name=dsp_hstat><B>Dsp_Hstat()</B>.
<P>
DSP programs may also define special host commands at DSP vectors
$13 and $14 to be triggered by the command <a name=dsp_trigger><B>DSP_TriggerHC()</B>.
<a name=debug><H5>DSP Debugging</H5>

<P>
When full control over the DSP is necessary (such is the case
for specialized debuggers), the command <a name=eb><B>Dsp_ExecBoot()</B>
can be used to download up to 512 DSP <B>WORD</B>s of bootstrap
code. The DSP will be reset before this happens. This call should
only be used by advanced applications as it will cause other DSP
functions to stop working unless those functions are properly
supported.
<HR>

<a name=mode><H4><FONT SIZE=4 ><a name=supervisormode>User/Supervisor Mode</FONT></H4>

<HR>

<P>
The <B>XBIOS</B> call <a name=supexec><B>Supexec()</B> provides access to a special
mode of the 680x0 processor called supervisor mode. Normal programs
always execute in <a name=usermode>user mode. Programs operating in user mode,
however, have less memory access privileges than those operating
in supervisor mode.
<P>
Some special instructions of the 680x0 may only be executed in
supervisor mode. In addition, any memory reads or writes to locations
$0-$7FF or memory-mapped I/O must be made in <a name=supervisormode2>supervisor mode.
<P>
To use <a name=supexec2><B>Supexec()</B>, simply pass it the address of a function
to be called. When writing the function in 'C', you should be
careful to define the function in a way that is safe for your
compiler (see your compiler documentation for details). 
<P>
While in supervisor mode, the <B>AES</B> should never be called.
<HR>

<a name=metados><H4><FONT SIZE=4 >MetaDOS</FONT></H4>

<HR>

<P>
One special <B>XBIOS</B> opcode, <a name=metainit><B>Metainit()</B> was reserved
for a <B>TOS</B> extension called <B>MetaDOS</B>. <B>MetaDOS</B>
was designed to supplement the OS to allow for more than 16 drives
and to provide the extra support needed for <a name=cdrom>CD-ROM drives.  <B>MetaDOS</B>
is no longer officially supported by Atari because of the increased
functionality of <B>MultiTOS</B>.
<P>
<B>MultiTOS</B> allows the use of all 26 drive letters as well
as providing loadable device drivers and file systems. See <I>Chapter
2: <B>GEMDOS</B></I> for more information.
<HR>

<a name=keyboard><H4><FONT SIZE=4 >Keyboard and Mouse Control</FONT>
</H4>

<HR>

<P>
The <B>XBIOS</B> has several functions that provide extended control
over the keyboard and mouse. These functions should be used with
care, however, as the keyboard and mouse are 'global' devices
shared by other processes.
<P>
<a name=initmous><B>Initmous()</B> is used to change the way the keyboard controller
reports mouse movements to the system. Changing this mode will
cause the <B>AES</B> and <B>VDI</B> to be unable to recognize
mouse input.
<P>
<a name=keytbl><B>Keytbl()</B> allows you to read and manipulate the tables which
translate IKBD scan codes into ASCII codes. This is essential
when you want your application to run on Atari machines with foreign
keyboards. Use <B>Keytbl()</B> to return a pointer to the internal
table structure and then convert keycodes into ASCII by looking
codes up in the appropriate table.
<a name=kbdtables><H5>Loadable XBIOS Keyboard Tables</H5>

<P>
<B>TOS</B> versions 5.0 and greater support the loading of external
keyboard tables when the <a name=akp>'_AKP' cookie is present. In this case,
if a file called <a name=keytbltbl>'KEYTBL.TBL' is found in the '\MULTITOS' directory
of the boot drive, it will be loaded upon bootup to provide keyboard
mapping changes. The format of the file is as follows:
<TABLE BORDER=1>

<TR><TH>
<CENTER>
<B>Magic Table Identifier Word</B>
</CENTER>

<P>

<CENTER>
This should be a <B>WORD</B> value of 0x2771.
</CENTER>

</TH></TR>

<TR><TD>
<CENTER>
<B>Unshifted Keyboard Table</B>
</CENTER>
<FONT SIZE=2>This is a 128 byte table of ASCII codes that are generated when no keyboard shift keys are being held down. There is one entry for each possible scan code. </FONT>
</TD></TR>

<TR><TD>
<CENTER>
<B>Shifted Keyboard Table</B>
</CENTER>
<FONT SIZE=2>This is a 128 byte table of ASCII codes that are generated when the shift key is being held down. There is one entry for each possible scan code. </FONT>
</TD></TR>

<TR><TD>
<CENTER>
<B>CAPS-LOCK Keyboard Table</B>
</CENTER>
<FONT SIZE=2>This is a 128 byte table of ASCII codes that are generated when caps-lock is engaged and no shift keys are being held. There is one entry for each possible scan code. </FONT>
</TD></TR>

<TR><TD>
<CENTER>
<B>Alternate-Unshifted Keyboard Table</B>
</CENTER>
<FONT SIZE=2>This is a variable length table consisting of two-byte entries. Each entry consists of a scan code and the ASCII code generated when that scan code occurs while the alternate key (and no other) keyboard shift keys are being held. The list is terminated by a single <B>NULL</B> byte.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
<B>Alternate-Shifted Keyboard Table</B>
</CENTER>
<FONT SIZE=2>This is a variable length table consisting of two-byte entries. Each entry consists of a scan code and the ASCII code generated when that scan code occurs while the alternate key and the shift key is being held. The list is terminated by a single <B>NULL</B> byte.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
<B>Alternate CAPS-LOCK Keyboard Table</B>
</CENTER>
<FONT SIZE=2>This is a variable length table consisting of two-byte entries. Each entry consists of a scan code and the ASCII code generated when that scan code occurs while the alternate key is being held with the caps-lock mode in effect. The list is terminated by a single <B>NULL</B> byte.</FONT>
</TD></TR>

</TABLE>

<P>

<P>
<a name=bioskeys><B>Bioskeys()</B> returns any mapping changes made by <a name=keytbl2><B>Keytbl()</B>
to their original state.
<P>
<a name=configuration>The configuration functions <a name=cursconf><B>Cursconf()</B> and <a name=kbrate><B>Kbrate()</B>
set the cursor blink rate and keyboard repeat rates respectively.
These settings should only be changed by a CPX or other configuration
utility at the user's request as they are global and affect all
applications.
<H5>IKBD Intelligent Keyboard Controller</H5>

<P>
The IKBD Controller is an intelligent hardware device that handles
communications between the computer and the keyboard matrix. The
<B>XBIOS</B> function <a name=ikbdws><B>Ikbdws()</B> can be used to transmit
command strings to the IKBD controller. For further information
about the IKBD, consult <I>Chapter 5: <B>Hardware</B></I>.
<HR>

<a name=disk><H4><FONT SIZE=4 >Disk Functions</FONT></H4>

<HR>

<a name=boot><H5>Boot Sectors</H5>

<P>
Both floppy disks and hard disks share a similar format for boot
sectors as follows:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Name</FONT></B></TH><TH>
<CENTER>
<B><FONT SIZE=2 >Offset</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Contents</FONT></B></TH>
</TR>

<TR><TH><B>BRA</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x0000</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This <B>WORD</B> contains a 680x0 BRA.S instruction to the boot code in this sector if the disk is executable, otherwise it is unused.</FONT>
</TD></TR>

<TR><TH><B>OEM</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x0002</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>These six bytes are reserved for use as any necessary filler information. The disk-based <B>TOS</B> loader program places the string 'Loader' here.</FONT>
</TD></TR>

<TR><TH><B>SERIAL</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x0008</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>The low 24-bits of this <B>LONG</B> represent a unique disk <a name=serialnumber>serial number.</FONT>
</TD></TR>

<TR><TH><B>BPS</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x000B</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This is an Intel format <B>WORD</B> (low byte first) which indicates the number of bytes per sector on the disk.</FONT>
</TD></TR>

<TR><TH><B>SPC</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x000D</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This is a <B>BYTE</B> which indicates the number of sectors per cluster on the disk.</FONT>
</TD></TR>

<TR><TH><B>RES</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x000E</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This is an Intel format <B>WORD</B> which indicates the number of reserved sectors at the beginning of the media (usually one for floppies).</FONT>
</TD></TR>

<TR><TH><B>NFATS</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x0010</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This is a <B>BYTE</B> indicating the number of <a name=fat>File Allocation Table's (FAT's) on the disk.</FONT>
</TD></TR>

<TR><TH><B>NDIRS</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x0011</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This is an Intel format <B>WORD</B> indicating the number of ROOT directory entries.</FONT>
</TD></TR>

<TR><TH><B>NSECTS</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x0013</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This is an Intel format <B>WORD</B> indicating the number of sectors on the disk (including those reserved).</FONT>
</TD></TR>

<TR><TH><B>MEDIA</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x0015</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This <B>BYTE</B> is a media descriptor. Hard disks set this value to 0xF8, otherwise it is unused.</FONT>
</TD></TR>

<TR><TH><B>SPF</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x0016</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This is an Intel format <B>WORD</B> indicating the number of sectors per FAT.</FONT>
</TD></TR>

<TR><TH><B>SPT</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x0018</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This is an Intel format <B>WORD</B> indicating the number of sectors per track.</FONT>
</TD></TR>

<TR><TH><B>NSIDES</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x001A</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This is an Intel format <B>WORD</B> indicating the number of sides on the disk.</FONT>
</TD></TR>

<TR><TH><B>NHID</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x001C</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This is an Intel format <B>WORD</B> indicating the number of hidden sectors on a disk (currently ignored).</FONT>
</TD></TR>

<TR><TH><B>BOOTCODE</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x001E</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This area is used by any executable boot code. The code must be completely relocatable as its loaded position in memory is not guaranteed.</FONT>
</TD></TR>

<TR><TH><B>CHECKSUM</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x01FE</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>The entire boot sector <B>WORD</B> summed with this Motorola format <B>WORD</B> will equal 0x1234 if the boot sector is executable or some other value if not.</FONT>
</TD></TR>

</TABLE>

<P>

<P>
The boot sector may be found on side 0, track 0, sector 1 of each
physical disk.
<a name=floppy><H5>The Floppy Drive</H5>

<P>
The <B>XBIOS</B> provides several functions used for reading,
writing, verifying, and formatting sectors on the hard disk.
<P>
<a name=floprd><B>Floprd()</B> and <a name=flopwr><B>Flopwr()</B> read and write from the floppy
drive at the sector level rather than the file level. For example,
these functions could be used to create executable boot sectors
on a floppy disk. <a name=flopver><B>Flopver()</B> can be used to verify written
sectors against data still in memory.
<P>
Formatting a floppy disk is accomplished with <a name=flopfmt><b>flopfmt()</B>.
After a floppy is completely formatted use the function<B> Protobt()
</B>to create a prototype boot sector (as shown above) which can
then be written to sector #1 to make the disk usable by <B>TOS</B>.
<H5>ASCI and <a name=scsi>SCSI DMA</H5>

<P>
The functions <a name=dmaread><B>DMAread()</B> and <a name=dmawrite><B>DMAwrite()</B> were added
as of <B>TOS</B> 2.00. These functions provide a method of accessing
<a name=asci>ACSI and SCSI devices at the sector level.
<P>
ASCI accesses must not use alternate RAM as a transfer buffer
because they are performing DMA. The TT030 uses handshaking for
SCSI so alternate RAM transfers are safe. SCSI transfers on the
Falcon030 do, however, use DMA so alternate RAM must be avoided.

<P>
If you need to transfer data using these functions to an alternate
RAM buffer, use the special standard memory block pointed to by
the cookie '_FRB' as an intermediary point between the two types
of RAM. You must also use the '_<I>flock</I>' system variable
(at 0x43E) to lock out other attempted uses of this buffer.
<P>
Each physical hard disk drive must contain a boot sector. The
boot sector for hard disk drives is the same as floppies except
for the following locations:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Name</FONT></B></TH><TH>
<CENTER>
<B><FONT SIZE=2 >Offset</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Contents</FONT></B></TH>
</TR>

<TR><TH><I><B>hd_siz</B></I></TH><TD>
<CENTER>
<FONT SIZE=2>0x01C2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This is a Motorola format <B>LONG</B> that indicates the number of physical 512-byte sectors on the device.</FONT>
</TD></TR>

<TR><TH><B>Partition Header #0</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x01C6</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This section contains a 12 <B>BYTE</B> <a name=partitioninformationblock>partition information block for the first logical partition.</FONT>
</TD></TR>

<TR><TH><B>Partition Header #1</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x01D2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This section contains a 12 <B>BYTE</B> partition information block for the second logical partition.</FONT>
</TD></TR>

<TR><TH><B>Partition Header #2</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x1DE</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This section contains a 12 <B>BYTE</B> partition information block for the third logical partition.</FONT>
</TD></TR>

<TR><TH><B>Partition Header #3</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x1EA</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This section contains a 12 <B>BYTE</B> partition information block for the fourth logical partition.</FONT>
</TD></TR>

<TR><TH><I><B>bst_st</B></I></TH><TD>
<CENTER>
<FONT SIZE=2>0x1F6</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This is a Motorola format <B>LONG</B> that indicates the sector offset to the bad sector list (from the beginning of the physical disk).</FONT>
</TD></TR>

<TR><TH><I><B>bst_cnt</B></I></TH><TD>
<CENTER>
<FONT SIZE=2>0x01FA</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This is a Motorola format <B>LONG</B> that indicates the number of 512-byte sectors reserved for the bad sector list.</FONT>
</TD></TR>

</TABLE>

<P>

<P>
The partition information block is defined as follows:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Name</FONT></B></TH><TH>
<CENTER>
<B><FONT SIZE=2 >Offset</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Contents</FONT></B></TH>
</TR>

<TR><TH><I><B>p_flg</B></I></TH><TD>
<CENTER>
<FONT SIZE=2>0x00</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This is a <B>BYTE</B> size bit field indicating the partition state. If bit 0 is set, the partition exists, otherwise it does not. If bit 7 is set, the partition is bootable, otherwise it is not. Bits 1-6 are unused.</FONT>
</TD></TR>

<TR><TH><I><B>p_id</B></I></TH><TD>
<CENTER>
<FONT SIZE=2>0x01</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This is a three <B>BYTE</B> field that indicates the partition type as follows:</FONT> <U><B>Contents Meaning</B></U>
<P>
<FONT SIZE=2> '<B>GEM</B>' Regular Partition (&lt;16MB)</FONT>
<P>
<FONT SIZE=2> '<B>BGM</B>' Big Partition (&gt;=16MB)</FONT>
<P>
<FONT SIZE=2><a name=xgmpartition> '<B>XGM</B>' Extended Partition</FONT>
</TD></TR>

<TR><TH><I><B>p_st</B></I></TH><TD>
<CENTER>
<FONT SIZE=2>0x04</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This is a Motorola format <B>LONG</B> that indicates the start of the partition as an offset specified in 512-byte sectors.</FONT>
</TD></TR>

<TR><TH><I><B>p_size</B></I></TH><TD>
<CENTER>
<FONT SIZE=2>0x08</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This is a Motorola format <B>LONG</B> that indicates the size of the partition in 512-byte sectors.</FONT>
</TD></TR>

</TABLE>

<P>

<P>
<a name=partition>A hard disk may have up to four standard (GEM or BGM) partitions
or three standard and one extended (XGM) partition. The first
partition of a hard disk must be a standard one.
<H5>Extended Partitions</H5>

<P>
The first sector of an extended partition contains a standard
boot sector with hard disk information except that the <I>hd_siz</I>,
<I>bst_st</I>, and <I>bst_cnt</I> fields are unused. At least
one, but no more than two (not necessarily the first two), partition
headers are used. The first partition header is the same as described
above except that <I>p_st</I> describes the offset from the beginning
of the extended partition rather than the beginning of the physical
disk.
<P>
If another partition needs to be linked, the second partition
block should contain 'XGM' in its <I>p_id</I> field and an offset
to the next extended partition in <I>p_st</I>.
<a name=badsector><H5>The Bad Sector List</H5>

<P>
The bad sector list is a group of three-byte entries describing
which physical sectors on the hard disk are unusable. The first
three-byte entry contains the number of bad sectors recorded.
The second three-byte entry is a checksum and when added to the
entire bad sector list bytewise should cause the list to <B>BYTE</B>
sum to 0xA5. If this is not the case then the bad sector list
is considered bad itself.
<HR>

<a name=serial><H4><FONT SIZE=4 ><a name=serialport>The Serial Port</FONT></H4>

<HR>

<P>
Application writers who develop communication programs will need
to use some of the special functions the <B>XBIOS</B> provides
for control of the serial port(s). Older Atari computers support
only one serial port connected by the Multi-Function Peripheral
(MFP) chip.
<P>
The Atari TT030 contains two MFP chips to provide two serial ports
and one Serial Communications Chip <a name=scc>(SCC) which controls two more
serial ports. One of the SCC ports, however, can be switched over
to control a Localtalk compatible network port as follows:
<P>
Switch to Serial 2 Connector:
<PRE>
<a name=ongibit>Ongibit(0x80);

</PRE>

<P>
Switch to <a name=lanconnect>LAN connector:
<PRE>
<a name=offgibit>Offgibit(0x7F);
</PRE>

<P>
The Mega STe is similar to the TT030, however, it has only one
MFP chip to provide one less serial device.
<P>
The Atari Falcon030 uses a SCC chip to drive its single serial
port and networking port. The Falcon030 does contain a MFP chip
but it does not control any of the serial device hardware. The
MFP's ring indicator has, however, been wired across the SCC to
provide compatibility with older applications.
<a name=mapping><H5>Serial Port Mapping</H5>

<P>
<B>BIOS </B>input and output calls to device #1 and<B> XBIOS</B>
calls which configure the serial port always refer to the currently
'mapped' device as set with <B>Bconmap()</B>. The Modem CPX allows
a user to map any installed device as the default. A program which
is aware of the extra ports on newer machines can access them
through their own <B>BIOS</B> device number as follows:
<TABLE BORDER=1>

<TR><TH>
<CENTER>
<B>Device Number</B>
</CENTER>
</TH><TH>
<CENTER>
<B><FONT SIZE=2 >Mega STe</FONT></B>
</CENTER>

</TH><TH COLSPAN=2>
<CENTER>
<B><FONT SIZE=2 >TT030</FONT></B>
</CENTER>

</TH><TH COLSPAN=2>
<CENTER>
<B><FONT SIZE=2 >Falcon030</FONT></B>
</CENTER>

</TH></TR>

<TR><TD>
<CENTER>
1
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>Currently mapped device.</FONT>
</CENTER>

<P>

<CENTER>
<B><FONT SIZE=2>DEV_AUX</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>Currently mapped device.</FONT>
</CENTER>

<P>

<CENTER>
<B><FONT SIZE=2>DEV_AUX</FONT></B>
</CENTER>

</TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>Currently mapped device.</FONT>
</CENTER>

<P>

<CENTER>
<B><FONT SIZE=2>DEV_AUX</FONT></B>
</CENTER>

</TD></TR>

<TR><TD>
<CENTER>
6
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>Modem 1 (ST MFP)</FONT>
</CENTER>

<P>

<CENTER>
<B><FONT SIZE=2>DEV_MEGAMODEM1</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>Modem 1 (ST MFP)</FONT>
</CENTER>

<P>

<CENTER>
<B><FONT SIZE=2>DEV_TTMODEM1</FONT></B>
</CENTER>

</TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>-</FONT>
</CENTER>

</TD></TR>

<TR><TD>
<CENTER>
7
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>Modem 2 (SCC B)</FONT>
</CENTER>

<P>

<CENTER>
<B><FONT SIZE=2>DEV_MEGAMODEM2</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>Modem 2 (SCC B)</FONT>
</CENTER>

<P>

<CENTER>
<B><FONT SIZE=2>DEV_TTMODEM2</FONT></B>
</CENTER>

</TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>Modem (SCC B)</FONT>
</CENTER>

<P>

<CENTER>
<B><FONT SIZE=2>DEV_FALCONMODEM</FONT></B>
</CENTER>

</TD></TR>

<TR><TD>
<CENTER>
8
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>Serial/LAN (SCC A)</FONT>
</CENTER>

<P>

<CENTER>
<B><FONT SIZE=2>DEV_MEGALAN</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>Serial 1 (TT MFP)</FONT>
</CENTER>

<P>

<CENTER>
<B><FONT SIZE=2>DEV_TTSERIAL1</FONT></B>
</CENTER>

</TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>LAN (SCC A)</FONT>
</CENTER>

<P>

<CENTER>
<B><FONT SIZE=2>DEV_FALCONLAN</FONT></B>
</CENTER>

</TD></TR>

<TR><TD>
<CENTER>
9
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>-</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>Serial 2/LAN (SCC A)</FONT>
</CENTER>

<P>

<CENTER>
<B><FONT SIZE=2>DEV_TTLAN</FONT></B>
</CENTER>

</TD><TD COLSPAN=2>
<CENTER>
<FONT SIZE=2>-</FONT>
</CENTER>

</TD></TR>

</TABLE>

<P>

<H5>Configuring the Serial Port</H5>

<P>
<a name=rsconf><B>Rsconf()</B> and <a name=iorecstr><a name=iorec><B>Iorec()</B> set the communication mode
and input/output buffers of the currently mapped serial port.
You should note that while some ports support transfer rates of
greater than 19200 baud, this is the limit of the <a name=rsconf2><B>Rsconf()</B>
call. Other rates must currently be set in hardware (or with the
<B>Fcntl()</B> when <B>MiNT</B> is present).
<a name=interrupts><H5>MFP Interrupts</H5>

<P>
Each MFP chip supports a number of interrupts used by the serial
port and other system needs. The function <a name=mfpint><B>Mfpint()</B> should
be used to set define a function in your application that handles
one of these interrupts. <a name=jenabint><B>Jenabint()</B> and <a name=jdisint><B>Jdisint()</B>
are used to enable/disable these interrupts respectively.
<P>
All MFP interrupt calls only work on ST compatible MFP serial
ports. The RS-232 ring indicator is the only interrupt that has
been wired through the MFP on a Falcon. Because of this, the ring
indicator interrupt is the only RS-232 interrupt that may be changed
with <a name=mfpint2><B>Mfpint()</B> on a Falcon.
<H5>SCC Interrupts</H5>

<P>
The <B>XBIOS</B> functions used for setting MFP interrupts do
not affect the SCC interrupts regardless of the <B>Bconmap()</B>
mapping. Refer to the <a name=memmap>memory map for the location of SCC interrupt
registers.
<HR>

<a name=printer><H4><FONT SIZE=4 >Printer Control</FONT></H4>

<HR>

<P>
The <B>XBIOS</B> contains two functions used for controlling printers.
Both functions are very outdated and should not be relied on in
any ST.
<P>
<a name=scrdmp><B>Scrdmp()</B> triggers the built-in <a name=ahsd>ALT-HELP screen dump code.
<a name=prtblk><B>Prtblk()</B> enables the built-in screen dump routine of the
ST printing only the desired block to an Atari or <a name=epsonprinter>Epson dot-matrix
printer.
<P>
<a name=setprt><B>Setprt()</B> configures the built-in screen dump routine as
to the basic configuration of the attached printer.
<HR>

<a name=xbios><H4><FONT SIZE=4 >Other XBIOS Functions</FONT></H4>

<HR>

<P>
<a name=nvmaccess><B>NVMaccess()</B> accesses the non-volatile RAM present in the
TT, Mega STe, and Falcon030. You should not read or write to this
area as all of its locations are currently reserved.
<P>
The functions <a name=settime><B>Settime()</B> and <a name=gettime><B>Gettime()</B> set the <B>BIOS</B>
time and date. As of <B>TOS</B> 1.02, they also update the <B>GEMDOS</B>
time as well.
<P>
Besides the sound capabilities of the <B>XBIOS</B> when running
on a Falcon, the function <a name=dosound><B>Dosound()</B> generates music on
any Atari computer using the FM sound generator. The function
works at the interrupt level processing a 'sound command list'
you specify. It can be used to reproduce a single tone or a complete
song in as many as three parts of harmony.
<P>
<a name=random><B>Random() </B>generates a pseudo-random number using a built-in
algorithm whose seed comes from the system 60kHz clock.
<P>
<a name=ssbrk><B>Ssbrk()</B> is used by the operating system to reserve system
RAM before <B>GEMDOS</B> is initialized. It should not be used
by application programmers.
<P>
<a name=puntaes><B>Puntaes()</B> is useful only when using a disk-loaded version
of <B>TOS</B>. It clears the OS from RAM and reboots the computer.
<P>
<a name=midiws><B>Midiws()</B> is a similar function to <a name=ikbdws2><B>Ikbdws()</B> in that
it writes to the MIDI controller. It is more useful at transferring
large amounts of MIDI data than <B>Bconout()</B>.
<P>
The <a name=dbmsg><B>Dbmsg()</B> <B>XBIOS</B> call is added by supporting debuggers
as a method of transferring debugging messages between the application
and debugger. The Atari Debugger (DB) currently supports this
interface.
<HR>

<a name=calling><a name=functioncallingprocedure><H4><FONT SIZE=4 >XBIOS Function Calling Procedure</FONT>
</H4>

<HR>

<P>
<B>XBIOS</B> system functions are called via the TRAP #14 exception.
Function arguments are pushed onto the current stack (user or
supervisor) in reverse order followed by the function opcode.
The calling application is responsible for correctly resetting
the stack pointer after the call. 
<P>
The <B>XBIOS</B>, like the <B>BIOS</B> may utilize registers D0-D2
and A0-A2 as scratch registers and their contents should not be
depended upon at the completion of a call. In addition, the function
opcode placed on the stack will be modified. The XBIOS places its return code value in d0.
<P>
The following example for <a name=getrez2><B>Getrez()</B> illustrates calling
the <B>XBIOS</B> from assembly language:
<PRE>
move.w		#$04,-(sp)
trap		#14
addq.l		#6,sp

</PRE>

<P>
A 'C' binding for a generic <B>XBIOS</B> handler would be as follows:
<PRE>
_xbios:
	; Save the return code from the stack
	move.l	(sp)+,trp14ret
	trap		#14
	move.l	trp14ret,-(sp)
	rts

	.bss
trp14ret:
	.ds.l		1		
</PRE>

<P>
The <B>XBIOS</B> is re-entrant to three levels, however there
is no depth checking performed so interrupt handlers should avoid
intense <B>XBIOS</B> usage. In addition, no disk or printer usage
should be attempted from the system timer interrupt, critical
error, or process-terminate handlers. 
<a name=callingfromaninterrupt><H5>Calling the XBIOS from an Interrupt</H5>

<P>
The <B>BIOS</B> and <B>XBIOS</B> are the <I>only</I> two OS sub-systems
which may be called from an interrupt handler. Precisely <I>one</I>
interrupt handler at a time may use the <B>XBIOS</B> as shown
in the following code segment:
<PRE>
savptr			equ		$4A2
savamt			equ		$23*2

myhandler:
			sub.l	#savamt,savptr

			; BIOS calls may be performed here

			add.l	#savamt,savptr

			rte		; (or rts?)
</PRE>

<P>
Certain <B>XBIOS</B> calls are not re-entrant because they call
<B>GEMDOS</B> routines. The <a name=setscreen2><B>Setscreen()</B> function, and any
DSP function which loads data from disk should not be attempted
during an interrupt.
<P>
It is not possible to use this method to call <B>XBIOS</B> functions
during an interrupt when running under <B>MultiTOS</B>.
<p>
<hr><center><a href="toc.htm"> Table of Contents | </a><a href="index.htm"> Index </a></center>
</BODY>

</HTML>
