<HTML>

<HEAD>

<TITLE>BIOS Function Reference</TITLE>


</HEAD>

<BODY BACKGROUND BGCOLOR=#FFFFFF>

<H2>BIOS Function Reference</H2>

<HR>

<a name=bconin><H3>Bconin()</H3>

<P>
<B>LONG Bconin( <I>dev </I>)</B>
<P>
<B>WORD <I>dev</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=7><B>Bconin()</B> retrieves a character (if one is waiting) from the specified device.
</TD></TR>

<TR><TH></TH><TD COLSPAN=7></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=7>2 (0x02)</TD></TR>

<TR><TH></TH><TD COLSPAN=7></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=7>All <B>TOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=7></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=7><I>dev</I> specifies the device to read from as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=7></TD></TR>

<TR><TH></TH><TD COLSPAN=2><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >dev</FONT></B></I>
</CENTER>

</TD><TD COLSPAN=4><B><FONT SIZE=2 >Device</FONT></B>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>DEV_PRINTER</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD COLSPAN=4><FONT SIZE=2>Parallel port</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>DEV_AUX</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD COLSPAN=4><FONT SIZE=2>Auxillary device (normally the RS-232 port, however, <B>TOS</B> versions with <B>Bconmap()</B> can map in other devices to this handle)</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>DEV_CONSOLE</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD COLSPAN=4><FONT SIZE=2>Console device (keyboard)</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>DEV_MIDI</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD COLSPAN=4><FONT SIZE=2>MIDI Port</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>DEV_IKBD</B></TD><TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

</TD><TD COLSPAN=4><FONT SIZE=2>IKBD Controller (not available as an input device)</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>DEV_RAW</B></TD><TD>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>

</TD><TD COLSPAN=4><FONT SIZE=2>Console device (keyboard)</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2>
<CENTER>
<I>See Overview</I>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>6 -</FONT>
</CENTER>
</TD>
<TD COLSPAN=4><FONT SIZE=2>Additional devices (as available)</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=7>
<PRE>
move.w   dev,-(sp)
move.w   #$02,-(sp)
trap   #13
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=7></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=7><B>Bconin()</B> returns a bit array arranged as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=7></TD></TR>

<TR><TH></TH><TD>
<CENTER>
<B>Bits 31-24</B>
</CENTER>
</TD>
<TD COLSPAN=3>
<CENTER>
<B><FONT SIZE=2>Bits 23-16</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2>Bits 15-8</FONT></B>
</CENTER>

</TD><TD>
<CENTER>
<B><FONT SIZE=2>Bits 7-0</FONT></B>
</CENTER>

</TD></TR>

<TR><TH></TH><TD>
<CENTER>
Shift key status (see <B>Kbshift()</B> )
</CENTER>

</TD><TD COLSPAN=3>
<CENTER>
<FONT SIZE=2>Keyboard</FONT>
</CENTER>

<P>

<CENTER>
<FONT SIZE=2>Scan Code</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>Reserved </FONT>
</CENTER>

<P>

<CENTER>
<FONT SIZE=2>(0)</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>ASCII value</FONT>
</CENTER>

</TD></TR>

<TR><TH></TH><TD COLSPAN=7></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=7>The shift key status is only returned if the system variable <I>conterm</I> (char&nbsp;*(0x484) ) has bit 3 set. This is normally disabled.Non-ASCII keys return 0 in bits 7-0.
</TD></TR>

<TR><TH></TH><TD COLSPAN=7></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=7><B>Bconstat(), Cconin(), Cauxin()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=bconout><H3>Bconout()</H3>

<P>
<B>LONG Bconout( <I>dev</I>, <I>ch </I>)</B>
<P>
<B>WORD <I>dev</I>, <I>ch</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=4><B>Bconout()</B> outputs a character to a named device.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=4>3 (0x03)</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=4>All <B>TOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=4><I>dev</I> specifies the output device as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH></TH><TD COLSPAN=2><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >dev</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Device</FONT></B></TD>
</TR>

<TR><TH></TH><TD COLSPAN=2><B>DEV_PRINTER</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Parallel port</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>DEV_AUX</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Auxillary device (see note under <B>Bconin()</B> )</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>DEV_CONSOLE</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Console device (screen)</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>DEV_MIDI</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>MIDI port</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>DEV_IKBD</B></TD><TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Keyboard (IKBD)</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=2><B>DEV_RAW</B></TD><TD>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Raw screen device (control characters and escapes are not processed)</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=2><I>See Overview</I></TD><TD>
<CENTER>
<FONT SIZE=2>6 -</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Additional devices (as available)</FONT>
</TD></TR>

<TR><TH></TH><TD></TD><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=4>
<PRE>
move.w   ch,-(sp)
move.w   dev,-(sp)
move.w   #$03,-(sp)
trap   #13
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=4><B>Bconout()</B> returns 0 if the character was sent successfully or non-zero otherwise.
</TD></TR>

<TR><TH></TH><TD COLSPAN=4></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=4><B>Bconin(), Cconout(), Cauxout(), Cprnout(), Bcostat()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=bconstat><H3>Bconstat()</H3>

<P>
<B>LONG Bconstat( <I>dev </I>)</B>
<P>
<B>WORD <I>dev</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Bconstat()</B> determines whether the specified device is prepared to transmit at least one character.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>1 (0x01)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>TOS</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>dev</I> specifies the device to check as listed under <B>Bconin</B>().
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   dev,-(sp)
move.w   #$01,-(sp)
trap   #13
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Bconstat()</B> returns 0 if no characters are waiting or -1 if characters are waiting to be received.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Bconin(), Cconis(), Cauxis()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Bcostat()</H3>

<P>
<B>LONG Bcostat( <I>dev </I>)</B>
<P>
<B>WORD <I>dev</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Bcostat()</B> determines if the specified device is prepared to receive a character.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>8 (0x08)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>TOS</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>dev</I> specifies the device to poll as listed under <B>Bconout()</B>.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   dev,-(sp)
move.w   #$08,-(sp)
trap   #13
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Bcostat()</B> returns 0 if the device is not ready to receive characters or -1 otherwise.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>A bug in <B>TOS</B> 1.0 existed that caused the IKBD and MIDI device numbers to become swapped when being handled by the <B>Bcostat()</B> call, subsequently returning data for the wrong device. To allow previously written programs to continue operating correctly, this bug has been maintained on purpose in all current versions of <B>TOS</B>. You should therefore specify a value of 3 for the IKBD and 4 for MIDI for this call only.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Bconout(), Cauxos(), Cconos(), Cprnos()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Drvmap()</H3>

<P>
<B>ULONG Drvmap( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Drvmap()</B> returns a list of mounted drives.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>10 (0x0A)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>TOS</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD>None.</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$0A,-(sp)
trap   #13
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Drvmap()</B> returns a <B>ULONG</B> bitmap of mounted drives. For each drive present, its bit is enabled. Drive 'A:' is bit 0, drive 'B:' is bit 1, and so on.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>Single floppy systems will indicate that two drives are available since both drives can actually be addressed. A request for drive 'B:' will simply cause <B>TOS</B> to ask the user to insert 'Disk B' and provide automatic handling routines for all disk swapping.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Dsetdrv()</B></TD></TR>

</TABLE>

<P>

<HR>

<H3>Getbpb()</H3>

<P>
<B>BPB *Getbpb( <I>dev </I>)</B>
<P>
<B>WORD <I>dev</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Getbpb()</B> returns the address of the current <B>BPB</B> (Bios Parameter Block) for a mounted device.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>7 (0x07)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>TOS</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>dev</I> specifies the mounted device ('A:' = 0, 'B:' = 1) .
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   dev,-(sp)
move.w   #$07,-(sp)
trap   #13
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Getbpb()</B> returns a pointer to the device's <B>BPB</B>. The <B>BPB</B> is defined as follows:
<PRE>
typedef struct
{
 WORD recsiz; /* bytes per sector */
 WORD clsiz; /* sectors per cluster */
 WORD clsizb; /* bytes per cluster */
 WORD rdlen; /* sector length of root directory */
 WORD fsiz;  /* sectors per FAT */
 WORD fatrec; /* starting sector of second FAT */
 WORD datrec; /* starting sector of data */
 WORD numcl; /* clusters per disk */
 WORD bflags; /* bit 0=1 - 16 bit FAT, else 12 bit */
} BPB;
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD>A media change <I>must</I> be forced after calling this function prior to making any <B>GEMDOS</B> calls. Failure to do so may cause <B>GEMDOS</B> to become unaware of a disk change causing data loss. Refer to the discussion of forcing a media change earlier in this chapter.
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Getmpb()</H3>

<P>
<B>VOID Getmpb( <I>mpb </I>)</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Getmpb()</B> returns information regarding <B>GEMDOS</B> free and allocated memory blocks.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>0 (0x00)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>TOS</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD><I>mpb</I> is a pointer to a <B>MPB</B> structure which is filled in by the function. The related structures are defined as follows:
<PRE>
typedef struct md
{
 struct md *m_link;  /* pointer to next block */
 VOIDP m_start;   /* pointer to start of block */
 LONG m_length;   /* length of block */
 BASEPAGE *m_own;  /* pointer to basepage of owner */
} MD;

typedef struct mpb
{ 
 MD *mp_mfl;   /* free list */ 
 MD *mp_mal;   /* allocated list */
 MD *mp_rover;   /* roving pointer */
} MPB;
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
pea   mpb
clr.w   -(sp)
trap   #13
addq.l   #6,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Caveats</B></TH><TD><B>MultiTOS</B> uses a very different method of memory management which makes this call useless.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Comments</B></TH><TD>An application should <I>never</I> attempt to modify any of the returned information nor make any assumptions about memory allocation because of this function.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>See Also</B></TH><TD><B>Malloc(), Mfree()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<a name=kbshift2><H3>Kbshift()</H3>

<P>
<B>LONG Kbshift( <I>mode </I>)</B>
<P>
<B>WORD <I>mode</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>Kbshift()</B> allows the user to interrogate or modify the state of the keyboard 'special' keys.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>11 (0x0B)</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>All <B>TOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=5><I>mode</I> is -1 to read the state of the keys or a mask of the following values to change the current state:
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Mask</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD><B>K_RSHIFT</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x01</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Right shift key depressed</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>K_LSHIFT</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x02</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Left shift key depressed</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>K_CTRL</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x04</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Control key depressed</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>K_ALT</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x08</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Alternate key depressed</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>K_CAPSLOCK</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x10</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Caps-lock engaged</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>K_CLRHOME</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x20</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Clr/Home key depressed</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>K_INSERT</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x40</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Insert key depressed</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
move.w   mode,-(sp)
move.w   #$0B,-(sp)
trap   #13
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=5><B>Kbshift()</B> returns the state that the keyboard 'special' keys were in prior to the call.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=5><B>Kbshift()</B> is not a particularly fast call. If you are only interested in reading the state a documented macro follows that replaces <B>Kbshift()</B> and is much faster. Call the kb_init() function, as shown below, before using:
<PRE>
char *p_kbshift;
#define Kbstate()   *p_kbshift

VOID
kb_init(VOID)
{
 /* GetROMSysbase is defined in the BIOS Overview */
 OSHEADER *osheader = GetROMSysbase();

 if ( osheader-&gt;os_version == 0x0100 )
   p_kbshift = (char *)0xe1bL;
 else
   p_kbshift = *(char **)osheader-&gt;p_kbshift;
}
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=5><B>evnt_keybd(), evnt_multi(), Cconin(), Bconin()</B>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=mediach2><H3>Mediach()</H3>

<P>
<B>LONG Mediach( <I>dev </I>)</B>
<P>
<B>WORD <I>dev</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=5><B>Mediach()</B> inquires as to whether the 'media' has been changed since the last disk operation on a removable block device (floppy, removable hard drive, floptical, etc...).
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=5>9 (0x09)</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=5>All <B>TOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=5><I>dev</I> specifies the mounted device number to inquire ('A:' =  0, 'B:' =  1, etc.).
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=5>
<PRE>
move.w   dev,-(sp)
move.w   #$09,-(sp)
trap   #13
addq.l   #4,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=5><B>Mediach()</B> returns one of three values:
</TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Value</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH COLSPAN=2></TH><TD><B>MED_NOCHANGE</B></TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Media has not changed</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>MED_UNKNOWN</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Media may have changed</FONT></TD></TR>

<TR><TH COLSPAN=2></TH><TD><B>MED_CHANGED</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Media has changed</FONT></TD></TR>

<TR><TH></TH><TD COLSPAN=5></TD></TR>

<TR><TH><B>See Also</B></TH><TD COLSPAN=5><B>Getbpb()</B></TD>
</TR>

</TABLE>

<P>

<HR>

<a name=rwabs><H3>Rwabs()</H3>

<P>
<B>LONG Rwabs( <I>mode</I>, <I>buf</I>, <I>count</I>, <I>recno</I>,
<I>dev</I>, <I>lrecno </I>)</B>
<P>
<B>WORD <I>mode</I>;</B>
<P>
<B>VOIDP <I>buf</I>;</B>
<P>
<B>WORD <I>count</I>,<I>recno</I>,<I>dev</I>;</B>
<P>
<B>LONG <I>lrecno</I>;</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>Rwabs()</B> reads and writes sectors to a mounted device.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>4 (0x04)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>All <B>TOS</B> versions. Hard disk access requires the use of a hard disk driver (such as <B>AHDI</B>). The long sector offset version is only available as of <B>AHDI</B> 3.0. <B>AHDI</B> version numbers can be inquired through system variable <I>pun_ptr</I> (see discussion earlier in this chapter).
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>mode</I> is a bit mask which effects the operation to be performed as follows:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<B><FONT SIZE=2 >Bit</FONT></B>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Meaning</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>RW_READ</B>
<P>
or
<P>
<B>RW_WRITE</B>
</TD><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>
</TD><TD><FONT SIZE=2>0 = Read, 1 = Write</FONT>
</TD></TR>

<TR><TH></TH><TD><B>RW_NOMEDIACH</B></TD><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Do not read or modify the media change status.</FONT>
</TD></TR>

<TR><TH></TH><TD><B>RW_NORETRIES</B></TD><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Disable retries</FONT></TD></TR>

<TR><TH></TH><TD><B>RW_NOTRANSLATE</B></TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Do not translate logical sectors into physical sectors (<I>recno</I> specifies physical instead of logical sectors)</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD COLSPAN=3>The read or write operation is performed at address <I>buf</I>. <I>buf</I> must be <I>count</I> * bytes per logical sector in logical mode or <I>count</I> * 512 bytes in physical mode. <I>count</I> specifies how many sectors will be transferred. <I>dev</I> specifies the index of the mounted device. In logical mode, 'C:' is 2, 'D:' is 3, etc... In physical mode, devices 2-9 are the ACSI devices and 10-17 are SCSI devices.<I>recno</I> specifies the first sector to read from. If you need to specify a long offset, set <I>recno</I> to -1 and pass the long value in <I>lrecno</I>. When using a version of the <B>AHDI</B> below 3.0, the parameter <I>lrecno</I> should not be passed.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
/* If running AHDI &lt;3.0 omit first parameter */

move.l   lrecno,-(sp)
move.w   dev,-(sp)
move.w   recno,-(sp)
move.w   count,-(sp)
pea   buf,-(sp)
move.w   mode,-(sp)
move.w   #$04,-(sp)
trap   #13
lea   18(sp),sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3><B>Rwabs()</B> returns<B> E_OK</B> (0) if successful or a negative <B>BIOS</B> error code otherwise.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=3>Some C compilers (Lattice C in particular) have a secondary binding called <B>Lrwabs()</B> used to pass the additional parameter.This function may invoke the critical error handler (<I>etv_critic</I>).
</TD></TR>

</TABLE>

<P>

<HR>

<a name=setexc2><H3>Setexc()</H3>

<P>
<B>(VOIDP)() Setexc( <I>num</I>, <I>newvec </I>)</B>
<P>
<B>WORD <I>num</I>;</B>
<P>
<B>VOID (*<I>newvec</I>)();</B>
<TABLE BORDER=1>

<TR><TH></TH><TD COLSPAN=3><B>Setexc()</B> reads or modifies system exception vectors.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Opcode</B></TH><TD COLSPAN=3>5 (0x05)</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Availability</B></TH><TD COLSPAN=3>All <B>TOS</B> versions.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Parameters</B></TH><TD COLSPAN=3><I>num</I> indicates the vector number you are interested in. To obtain the vector number divide the address of the vector by 4. Some common vectors are:
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH></TH><TD><B><FONT SIZE=1 >Name</FONT></B>
</TD><TD>
<CENTER>
<I><B><FONT SIZE=2 >num</FONT></B></I>
</CENTER>

</TD><TD><B><FONT SIZE=2 >Vector</FONT></B></TD>
</TR>

<TR><TH></TH><TD><B>VEC_BUSERROR</B>
<P>
<a name=adderror><B>VEC_ADDRESSERROR</B>
<P>
<B>VEC_ILLEGALINSTRUCTION</B>
</TD><TD>
<CENTER>
<FONT SIZE=2>0x02 - 0x04</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Bomb errors (Bus, Address, Instruction)</FONT>
</TD></TR>

<TR><TH></TH><TD><B>VEC_GEMDOS</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x21</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Trap #1 (<B>GEMDOS</B>)</FONT></TD></TR>

<TR><TH></TH><TD><B>VEC_GEM</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x22</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Trap #2 (<B>AES/VDI</B>)</FONT></TD></TR>

<TR><TH></TH><TD><B>VEC_BIOS</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x2D</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Trap #13 (<B>BIOS</B>)</FONT></TD></TR>

<TR><TH></TH><TD><B>VEC_XBIOS</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x2E</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Trap #14 (<B>XBIOS</B>)</FONT></TD></TR>

<TR><TH></TH><TD><B>VEC_TIMER</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x100</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>System timer (<I>etv_timer</I>)</FONT></TD>
</TR>

<TR><TH></TH><TD><B>VEC_CRITICALERROR</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x101</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Critical error handler (<I>etv_critic</I>)</FONT>
</TD></TR>

<TR><TH></TH><TD><B>VEC_TERMINATE</B></TD><TD>
<CENTER>
<FONT SIZE=2>0x102</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Process terminate handle (<I>etv_term</I>)</FONT>
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD><TD></TD></TR>

<TR><TH></TH><TD COLSPAN=3><I>newvec</I> should be the address of your new vector handler. Passing a value of <B>VEC_INQUIRE</B> ((VOIDP)-1) will not modify the vector.
</TD><TD></TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD COLSPAN=3>
<PRE>
pea   newvec
move.w   num,-(sp)
move.w   #$05,-(sp)
trap   #13
addq.l   #8,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Return Value</B></TH><TD COLSPAN=3>The original value of the vector is returned by the call.
</TD></TR>

<TR><TH></TH><TD COLSPAN=3></TD></TR>

<TR><TH><B>Comments</B></TH><TD COLSPAN=3>You must reinstate old vector handlers you changed prior to your process exiting.Programs which modify replace system vector code should install themselves following the conventions of the XBRA protocol. For details, consult the overview portion of this chapter.
</TD></TR>

</TABLE>

<P>

<HR>

<H3>Tickcal()</H3>

<P>
<B>LONG Tickcal( VOID )</B>
<TABLE BORDER=1>

<TR><TH></TH><TD><B>Tickcal()</B> returns the system timer calibration.
</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Opcode</B></TH><TD>6 (0x06)</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Availability</B></TH><TD>All <B>TOS</B> versions.</TD>
</TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Parameters</B></TH><TD>None.</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Binding</B></TH><TD>
<PRE>
move.w   #$06,-(sp)
trap   #13
addq.l   #2,sp
</PRE>

</TD></TR>

<TR><TH></TH><TD></TD></TR>

<TR><TH><B>Return Value</B></TH><TD><B>Tickcal()</B> returns a <B>LONG</B> indicating the number of milliseconds between system clock ticks.
</TD></TR>

</TABLE>

<P>
<B></B>
<p>
<hr><center><a href="toc.htm"> Table of Contents | </a><a href="index.htm"> Index </a></center>
</BODY>

</HTML>
