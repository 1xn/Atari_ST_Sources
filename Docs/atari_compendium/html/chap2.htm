<HTML>

<HEAD>

<TITLE>GEMDOS Overview</TITLE>


</HEAD>

<BODY BACKGROUND BGCOLOR=#FFFFFF>

<P>
<a name=chap2><B><FONT SIZE=2>- CHAPTER 2 -</FONT></B>
<a name=gemdos2><H1>GEMDOS</H1>

<HR>

<a name=overview><H4><FONT SIZE=4 >Overview</FONT></H4>

<HR>

<P>
<B>GEMDOS</B> contains functions which comprise the highest level
of <B>TOS</B>. In many cases, <B>GEMDOS</B> devolves into <B>BIOS</B>
calls which handle lower level device access. <B>GEMDOS</B> is
responsible for file, device, process, and high-level input/output
management. The current revision number of <B>GEMDOS</B> is obtained
by calling <a name=sversion><B>Sversion()</B>. You should note that the <B>GEMDOS</B>
<a name=version>version number is independent of the <B>TOS</B> version number
and you should not count on any particular version of <B>GEMDOS</B>
being present based on the <B>TOS</B> version present.
<P>
Much of <B>GEMDOS</B> closely resembles its <a name=cpm>CPM 68k and <a name=msdos>MS-DOS
heritage. In fact, the file system and function calls are mostly
compatible with MS-DOS. MS-DOS format floppy disks are readable
by an Atari computer and vice-versa.
<P>
For the creation of <a name=multitos><B>MultiTOS</B>, <B>GEMDOS</B> was merged
with the <B>MiNT</B> operating environment which derives many
of its calls from the <a name=unix>UNIX operating system.
<HR>

<a name=filesystem><H4><FONT SIZE=4 >The TOS File System</FONT></H4>

<HR>

<P>
<B>GEMDOS</B> is responsible for interaction between applications
and file-based devices. Floppy and hard disk drives as well as
<a name=cdrom>CD-ROM, <a name=wormdrives>WORM, and <a name=modrives>Magneto-Optical drives are all accessed using
<B>GEMDOS</B> calls.
<P>
Prior to the advent of <B>MultiTOS</B>, Atari programmers were
limited to the <B>TOS</B> <a name=filesystem>file system for file storage and manipulation.
With the introduction of <B>MultiTOS</B>, it is now possible for
developers to create custom file systems so that almost any conceivable
disk format becomes accessible.
<P>
As a default, <B>MultiTOS</B> will manage files between the <B>TOS</B>
file system and alternative file systems to maintain backward
compatibility. Applications which wish to support extra file system
features may do so. The <a name=pdomain><B>Pdomain()</B> call may be used to instruct
<B>MultiTOS</B> to stop performing translations on filenames,
etc. Other calls such as <a name=dpathconf><B>Dpathconf()</B> can be used to determine
the requirements of a particular file system.
<P>
The explanation of the file system contained herein will limit
itself to the <B>TOS</B> file system.
<a name=identifiers><H5>Drive Identifiers</H5>

<P>
Each drive connected to an Atari system is given a unique alphabetic
identifier which is used to identify it. Drive 'A' is reserved
for the first available floppy disk drive (usually internal) and
drive 'B' for the second floppy disk drive. If only one floppy
drive exists, two letters will still be reserved and <B>GEMDOS</B>
will treat drive 'B' as a pseudo-drive and request disk swaps
as necessary. This feature is automatically handled by <B>GEMDOS</B>
and is transparent to the application.
<P>
Drives 'C' through 'P' are available for use by hard disk drives.
One letter is assigned per hard drive partition so a multiple-partition
drive will be assigned multiple letters. <B>MultiTOS</B> extends
drive letter assignments to 'Z' drive. Drive 'U' is a special
drive reserved for <B>MultiTOS</B> and is unavailable for assignment.
<P>
The amount of free storage space remaining on a drive along with
a drive's basic configuration can be determined using the <a name=dfree><B>Dfree()</B>
call.
<a name=filenames><H5>GEMDOS Filenames</H5>

<P>
Under <B>GEMDOS</B>, each file located on a device is given a
filename upon its creation which serves to provide identification
for the file. The filename has two parts consisting of a name
<a name=extension>from one to eight characters long and an optional file extension
of up to three characters long. If a file extension exists, the
two components are separated by a period. The extension should
serve to identify the format of the data whereas the name itself
should identify the data itself.
<P>
Filenames may be changed after creation with the function <a name=frename><B>Frename()</B>;
however, under no circumstances may two files with the same filename
reside in the same directory.
<P>
All <B>GEMDOS</B> functions ignore the alphabetic case of file
and pathnames. The following characters are legal filename characters:
<TABLE BORDER=1>

<TR><TD>
<CENTER>
<FONT SIZE=1 >Legal <B>GEMDOS</B> Filename Characters</FONT>
</CENTER>

</TD></TR>

<TR><TD>
<CENTER>
<TT><FONT SIZE=1 FACE="Courier New">A-Z, a-z, 0-9</FONT></TT>
</CENTER>

<P>

<CENTER>
<TT><FONT SIZE=1 FACE="Courier New">! @ # $ % ^ &amp; ( )</FONT></TT>
</CENTER>

<P>

<CENTER>
<TT><FONT SIZE=1 FACE="Courier New">+ - = ~ ` ; ' " ,</FONT></TT>
</CENTER>

<P>

<CENTER>
<TT><FONT SIZE=1 FACE="Courier New">&lt; &gt; | [ ] ( ) _</FONT></TT>
</CENTER>

</TD></TR>

</TABLE>

<P>

<a name=directories><H5>GEMDOS Directories</H5>

<P>
To further organize data, <B>GEMDOS</B> provides file directories
(or folders). Each drive may contain any number of directories
which, in turn, may contain files and additional directories.
This organization creates a tree-like structure of files and folders.
A file's location in this tree is called the <a name=path>path.
<P>
Directory names follow the same format as <B>GEMDOS</B> filenames
with a maximum filename length of 8 characters and an optional
3 character extension. The first directory of a disk which contains
all subdirectories and files is called the root directory.
<P>
The <a name=dcreate><B>Dcreate()</B> and <a name=ddelete><B>Ddelete()</B> system calls are used
to create and delete subdirectories.
<P>
Two special, system-created subdirectories are present in some
directories. A subdirectory with the name '..' (two periods) refers
to the parent of the current directory. The '..' subdirectory
is present in every subdirectory.
<P>
A subdirectory with the name '.' refers to the current directory.
There is a '.' subdirectory in every directory. 
<H5>GEMDOS Path Specifications</H5>

<P>
To access a file, a complete path specification must be composed
of the drive letter, directory name(s), and filename. A file named
'TEST.PRG' located in the 'SYSTEM' directory on drive 'C' would
have a path specification like the following:
<PRE>
C:\SYSTEM\TEST.PRG

</PRE>

<P>
The drive letter is the first character followed by a colon. Each
directory and subdirectory is surrounded by backslashes. If 'TEST.PRG'
were located in the root directory of 'C' the path specification
would be:
<PRE>
C:\TEST.PRG


</PRE>

<P>
<a name=ddrive>The drive letter and colon may be omitted causing <B>GEMDOS</B>
to reference the default drive as follows:
<PRE>
\TEST.PRG

</PRE>

<P>
A filename by itself will be treated as the file in the <a name=default><a name=defaultdirectory>default directory and drive. The current <B>GEMDOS</B> directory and drive
may be found with the functions <a name=dgetpath><B>Dgetpath()</B> and <a name=dgetdrv><B>Dgetdrv()</B>
respectively. They may be changed with the functions <a name=dsetpath><B>Dsetpath()</B>
and <a name=dsetdrv><B>Dsetdrv()</B>.
<a name=wildcards><H5>Wildcards</H5>

<P>
The <B>GEMDOS</B> functions <a name=fsfirst><B>Fsfirst()</B> and <a name=fsnext><B>Fsnext()</B>
are used together to enumerate files of a given path specification.
These two functions allow the use of wildcard characters to expand
their search parameters.
<P>
The '?' character is used to represent exactly one unknown character.
The '*' character is used to represent any number of unknown characters.
The following table gives some examples of the uses of these characters.
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Filename</FONT></B></TH>
<TH><B><FONT SIZE=2 >Found</FONT></B></TH><TH><B><FONT SIZE=2 >Not Found</FONT></B>
</TH></TR>

<TR><TD>*.*</TD><TD><FONT SIZE=2>All files</FONT></TD><TD><FONT SIZE=2>None</FONT>
</TD></TR>

<TR><TD>*.GEM</TD><TD><FONT SIZE=2>TEST.GEM</FONT>
<P>
<FONT SIZE=2>ATARI.GEM</FONT>
</TD><TD><FONT SIZE=2>TEST.G</FONT>
<P>
<FONT SIZE=2>ATARI.IMG</FONT>
</TD></TR>

<TR><TD>A?ARI.?</TD><TD><FONT SIZE=2>ATARI.O</FONT>
<P>
<FONT SIZE=2>ADARI.C</FONT>
</TD><TD><FONT SIZE=2>ADARI.IMG</FONT>
<P>
<FONT SIZE=2>ATARI.GEM</FONT>
</TD></TR>

<TR><TD>ATARI.???</TD><TD><FONT SIZE=2>ATARI.GEM</FONT>
<P>
<FONT SIZE=2>ATARI.IMG</FONT>
</TD><TD><FONT SIZE=2>ATARI.O</FONT>
<P>
<FONT SIZE=2>ATARI.C</FONT>
</TD></TR>

</TABLE>

<P>

<a name=dta><H5>Disk Transfer Address (DTA)</H5>

<P>
When using <B>Fsfirst()</B> and <a name=fsnext2><B>Fsnext()</B> to build a list
of files, <B>TOS</B> uses the Disk Transfer Address (DTA) to store
information about each file found. The format for the DTA structure
is as follows:
<PRE>
typedef struct
{
	BYTE		d_reserved[21];	/* Reserved - Do Not Change */
	<a name=fileattr>BYTE		d_attrib;		/* GEMDOS File Attributes */
	UWORD	d_time;			/* GEMDOS Time */
	UWORD	d_date;			/* GEMDOS Date */
	LONG		d_length;		/* File Length */
	char		d_fname[14];		/* Filename */
} DTA;

</PRE>

<P>
When a process is started, its DTA is located at a point where
it could overlay potentially important system structures. To avoid
overwriting memory a process wishing to use <a name=fsfirst2><B>Fsfirst()</B> and
<B>Fsnext()</B> should allocate space for a new DTA and use <a name=fsetdta><B>Fsetdta()</B>
to instruct the OS to use it. The original location of the DTA
should be saved first, however. Its location can be found with
the call <a name=fgetdta><B>Fgetdta()</B>. At the completion of the operation
the old address should be replaced with <a name=fsetdta2><B>Fsetdta()</B>.
<a name=fileattributes><H5>File Attributes</H5>

<P>
Every <B>TOS</B> file contains several attributes which define
it more specifically. File attributes are specified when a file
is created with <a name=fcreate><B>Fcreate()</B> and can be altered later with
<a name=fattrib><B>Fattrib()</B>.
<P>
The 'read-only' attribute bit is set to prevent modification of
a file. This bit should be set at the user's discretion and not
cleared unless the user explicitly requests it.
<P>
If the 'hidden' attribute is set, the file will not be listed
by the desktop or file selector. These files may still be accessed
in a normal manner but will not be present in an <B>Fsfirst()</B>
or <B>Fsnext()</B> search unless the correct <B>Fsfirst()</B>
bits are present.
<P>
The 'system' attribute is unused by <B>TOS</B> but remains for
MS-DOS compatibility.
<P>
<a name=vol_label>The 'volume label' attribute should be present on a maximum of
one file per drive. The file which has it set should be in the
root directory and have a length of 0. The filename indicates
the volume name of the drive.
<P>
The 'archive' attribute is a special bit managed by <B>TOS</B>
which indicates whether a file has been written to since it was
last backed up. Any time a <B>Fcreate()</B> call creates a file
or <a name=fwrite><B>Fwrite()</B> is used on a file, the Archive bit is set.
This enables file backup applications to know which files have
been modified since the last backup. They are responsible for
clearing this bit when backing up the file.
<a name=time_date_stamp><H5>File Time/Date Stamp</H5>

<P>
When a file is first created a special field in its directory
entry is updated to contain the date and time of creation. <a name=fdatime><B>Fdatime()</B>
can be used to access or modify this information as necessary.
<H5>File Maintenance</H5>

<P>
New files should be created with <B>Fcreate()</B>. When a file
is successfully created a positive file handle is returned by
the call. That handle is what is used to identify the file for
all future operations until the file is closed. After a file is
closed its handle is invalidated.
<P>
Files which are already in existence should be opened with <a name=fopen><B>Fopen()</B>.
As with <B>Fcreate()</B>, this call returns a positive file handle
upon success which is used in all subsequent <B>GEMDOS</B> calls
to reference the file.
<P>
<a name=file_handles>Each process is allocated an OS dependent number of file handles.
If an application attempts to open more files than this limit
allows, the open or create call will fail with an appropriate
error code. File handles may be returned to the system by closing
the open file with <a name=fclose><B>Fclose()</B>.
<P>
<B>Fopen()</B> may be used in read, write, or read/write mode.
In read mode, <a name=fread><B>Fread()</B> may be used to access existing file
contents. In write mode, any original information in the file
is not cleared but the data may be overwritten with <B>Fwrite()</B>.
In read/write mode, either call may be used interchangeably.
<P>
Every file has an associated<a name=fpp> file position pointer. This pointer
is used to determine the location for the next read or write operation.
This pointer is expressed as a positive offset from the beginning
of the file (position 0) which is set upon first creating or opening
a file. The pointer may be read or modified with the function
<a name=fseek><B>Fseek()</B>.
<P>
<a name=deleting>Existing files may be deleted with the <B>GEMDOS</B> call <a name=fdelete><B>Fdelete()</B>.
<a name=record_locking><H5>File/Record Locking</H5>

<P>
File and record locking allow portions or all of a file to be
locked against access from another computer over a network or
another process in the same system.
<P>
All versions of <B>TOS</B> have the ability to support file and
record locking but not all have the feature installed. If the
<a name=flk>'_FLK' cookie is present in the system cookie jar then the <a name=flock><B>Flock()</B>
call is present. This call is used to create locks on individual
sections (usually records) in a file.
<P>
Locking a file in use, when possible, is recommended to prevent
other processes from modifying the file at the same time.
<H5>Special File Handles</H5>

<P>
Several special file handles are available for access through
the standard <B>Fopen()/Fread()/Fwrite()</B> calls. They are as
follows:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Name</FONT></B></TH><TH>
<CENTER>
<B><FONT SIZE=2>Handle</FONT></B>
</CENTER>

</TH><TH>
<CENTER>
<B><FONT SIZE=2>Filename</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2>Device</FONT></B></TH></TR>

<TR><TH><B>GSH_BIOSCON</B></TH><TD>
<CENTER>
<FONT SIZE=2>0xFFFF</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>CON:</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2>Console (screen). Special characters such as the carriage return, etc. are interpreted.</FONT>
</TD></TR>

<TR><TH><B>GSH_BIOSAUX</B></TH><TD>
<CENTER>
<FONT SIZE=2>0xFFFE</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>AUX:</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2>Modem (serial port). This is the ST-compatible port for machines with more than one.</FONT>
</TD></TR>

<TR><TH><B>GSH_BIOSPRN</B></TH><TD>
<CENTER>
<FONT SIZE=2>0xFFFD</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>PRN:</FONT>
</CENTER>
</TD>
<TD><FONT SIZE=2><a name=printerdevice>Printer (attached to the Centronics Parallel port).</FONT>
</TD></TR>

<a name=fmidipipe2><TR><TH><B>GSH_BIOSMIDIIN</B></TH><TD>
<CENTER>
<FONT SIZE=2>0xFFFC</FONT>
</CENTER>

</TD><TD></TD><TD><FONT SIZE=2>Midi In</FONT></TD></TR>

<TR><TH><B>GSH_BIOSMIDIOUT</B></TH><TD>
<CENTER>
<FONT SIZE=2>0xFFFB</FONT>
</CENTER>

</TD><TD></TD><TD><FONT SIZE=2>Midi Out</FONT></TD></TR>

<TR><TH><B>GSH_CONIN</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x00</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>-</FONT>
</CENTER>
</TD><TD><FONT SIZE=2>Standard Input (usually directed to <B>GSH_BIOSCON</B>)</FONT>
</TD></TR>

<TR><TH><B>GSH_CONOUT</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x01</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>-</FONT>
</CENTER>
</TD><TD><FONT SIZE=2>Standard Output (usually directed to <B>GSH_BIOSCON</B>)</FONT>
</TD></TR>

<TR><TH><B>GSH_AUX</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x02</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>-</FONT>
</CENTER>
</TD><TD><FONT SIZE=2>Auxillary (usually directed to <B>GSH_BIOSAUX</B>)</FONT>
</TD></TR>

<TR><TH><B>GSH_PRN</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x03</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>-</FONT>
</CENTER>
</TD><TD><FONT SIZE=2><a name=printerdevice2>Printer (usually directed to <B>GSH_BIOSPRN</B>)</FONT>
</TD></TR>

<TR><TD>None</TD><TD>
<CENTER>
<FONT SIZE=2>0x04</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>-</FONT>
</CENTER>
</TD><TD><FONT SIZE=2>Unused</FONT>
</TD></TR>

<TR><TD>None</TD><TD>
<CENTER>
<FONT SIZE=2>0x05</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>-</FONT>
</CENTER>
</TD><TD><FONT SIZE=2>Unused</FONT>
</TD></TR>

<TR><TD>None</TD><TD>
<CENTER>
<FONT SIZE=2>0x06 and up</FONT>
</CENTER>

</TD><TD>
<CENTER>
<FONT SIZE=2>User-Specified</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>User Process File Handles</FONT></TD></TR>

</TABLE>

<P>

<P>
These files may be treated like any other <B>GEMDOS</B> files
for input/output and locking. Access to these devices is also
provided with <B>GEMDOS</B> character calls (see later in this
chapter).
<a name=redir><H5>File Redirection</H5>

<P>
Input and output to a file may be redirected to an alternate file
handle. For instance you may redirect the console output of a
<B>TOS</B> process to the printer.
<P>
File redirection is handled by the use of the <a name=fforce><B>Fforce()</B>
call. Generally you will want to make a copy of the file handle
with <a name=fdup><B>Fdup()</B> prior to redirecting the file so that it may
be restored to normal operation when complete.
<HR>

<a name=memman><H4><FONT SIZE=4 >Memory Management</FONT></H4>

<HR>

<P>
<a name=memorytypes><a name=memtypes>Atari systems support two kinds of memory. Standard RAM (sometimes
referred to as 'ST RAM') is general purpose RAM that can be used
for any purpose including video and DMA. Current Atari architecture
limits the amount of standard RAM a system may have to 14MB.
<P>
Alternative RAM (sometimes referred to as 'TT RAM') can be accessed
faster than standard RAM but is not suitable for video memory
or DMA transfers.
<P>
The <B>Malloc()</B> and <a name=mxalloc><B>Mxalloc()</B> calls allocate memory
blocks from the system heap. <a name=malloc><B>Malloc()</B> chooses the type
of memory it allocates based on fields in the program header (see
later in this chapter). <B>Mxalloc()</B> allows the application
to choose the memory type at run-time.
<P>
<B>MultiTOS</B> uses <a name=memoryprotection>memory protection to prevent an errant process
from damaging another. It is possible with <B>Mxalloc()</B> to
dynamically set the protection level of an allocated block.
<P>
Memory allocated with either <B>Malloc()</B> or <B>Mxalloc()</B>
may be returned to the system with <a name=mfree><B>Mfree()</B>. Memory allocated
by a process is automatically freed when the process calls <a name=pterm><B>Pterm()</B>.
<HR>

<a name=gdprocess><a name=processes><H4><FONT SIZE=4 >GEMDOS Processes</FONT></H4>

<HR>

<P>
<a name=exfileformat>The <B>GEMDOS</B> call <a name=pexec><B>Pexec()</B> is responsible for launching
executable files. The process which calls <B>Pexec()</B> is called
the parent and the file launched becomes the child. Each process
may have more than one child process. Depending on the mode used
with <B>Pexec()</B>, the child may share data and address space
and/or run concurrently (under <B>MultiTOS</B>) with the parent.
<B>GEMDOS</B> executable files (<B>GEM</B> and <B>TOS</B> applications
or desk accessories) contain the following file header:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Name</FONT></B></TH><TH>
<CENTER>
<B><FONT SIZE=2>Offset</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2>Contents</FONT></B></TH></TR>

<TR><TH><I><B>PRG_magic</B></I></TH><TD>
<CENTER>
<FONT SIZE=2>0x00</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This <B>WORD</B> contains the magic value (0x601A).</FONT>
</TD></TR>

<TR><TH><I><B>PRG_tsize</B></I></TH><TD>
<CENTER>
<FONT SIZE=2>0x02</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This <B>LONG</B> contains the size of the TEXT segment in bytes.</FONT>
</TD></TR>

<TR><TH><I><B>PRG_dsize</B></I></TH><TD>
<CENTER>
<FONT SIZE=2>0x06</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This <B>LONG</B> contains the size of the DATA segment in bytes.</FONT>
</TD></TR>

<TR><TH><I><B>PRG_bsize</B></I></TH><TD>
<CENTER>
<FONT SIZE=2>0x0A</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This <B>LONG</B> contains the size of the <a name=bss>BSS segment in bytes.</FONT>
</TD></TR>

<TR><TH><I><B>PRG_ssize</B></I></TH><TD>
<CENTER>
<FONT SIZE=2>0x0E</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This <B>LONG</B> contains the size of the symbol table in bytes.</FONT>
</TD></TR>

<TR><TH><I><B>PRG_res1</B></I></TH><TD>
<CENTER>
<FONT SIZE=2>0x12</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This <B>LONG</B> is unused and is currently reserved.</FONT>
</TD></TR>

<TR><TH><I><B><a name=prgflags>PRGFLAGS</B></I></TH><TD>
<CENTER>
<FONT SIZE=2>0x16</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This <B>LONG</B> contains flags which define certain process characteristics (as defined below).</FONT>
</TD></TR>

<TR><TH><I><B>ABSFLAG</B></I></TH><TD>
<CENTER>
<FONT SIZE=2>0x1A</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This <B>WORD</B> flag should be non-zero to indicate that the program has no fixups or 0 to indicate it does.</FONT>Since some versions of <B>TOS</B> handle files with this value being non-zero incorrectly, it is better to represent a program having no fixups with 0 here and placing a 0 longword as the fixup offset.
</TD></TR>

<a name=textsegment><TR><TH><B>Text Segment</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x1C</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This area contains the program's TEXT segment. A process is started by JMP'ing to <B>BYTE</B> 0 of this segment with the address of your processes basepage at 4(sp).</FONT>
</TD></TR>

<a name=dataseg><TR><TH><B>Data Segment</B></TH><TD>
<CENTER>
<I><B><FONT SIZE=2>PRG_tsize</FONT></B></I> + 0x1C
</CENTER>

</TD><TD><FONT SIZE=2>This area contains the program's DATA segment (if one exists).</FONT>
</TD></TR>

<TR><TH><B>Symbol Segment</B></TH><TD>
<CENTER>
<I><B><FONT SIZE=2>PRG_tsize</FONT></B></I> + <I><B>PRG_dsize</B></I> + 0x1C
</CENTER>

</TD><TD><FONT SIZE=2>This area contains the program's <a name=symboltable>symbol table (if there is one). The symbol table area is used differently by different compiler vendors. Consult them for the format.</FONT>
</TD></TR>

<TR><TH><B>Fixup Offset</B></TH><TD>
<CENTER>
<I><B><FONT SIZE=2>PRG_tsize</FONT></B></I> + <I><B>PRG_dsize</B></I> + <I><B>PRG_ssize</B></I> + 0x1C
</CENTER>

</TD><TD><FONT SIZE=2>This <B>LONG</B> indicates the first location in the executable (as an offset from the beginning) containing a longword needing a fixup. A 0 means there are no fixups.</FONT>
</TD></TR>

<TR><TH><B>Fixup Information</B></TH><TD>
<CENTER>
<I><B><FONT SIZE=2>PRG_tsize</FONT></B></I> + <I><B>PRG_dsize</B></I> + <I><B>PRG_ssize</B></I> + 0x20
</CENTER>

</TD><TD><FONT SIZE=2>This area contains a stream of <B>BYTE</B>s containing fixup information. Each byte has a significance as follows:</FONT> <U><B>Value Meaning</B></U>
<P>
<FONT SIZE=2> 0 End of list.</FONT>
<P>
<FONT SIZE=2> 1 Advance 254 bytes.</FONT>
<P>
<FONT SIZE=2> 2-254 (even) Advance this many</FONT>
<P>
<FONT SIZE=2>  bytes and fixup the</FONT>
<P>
<FONT SIZE=2>  longword there.</FONT>
</TD></TR>

</TABLE>

<P>

<P>
<I><B>PRGFLAGS</B></I> is a bit field defined as follows:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Definition</FONT></B></TH>
<TH>
<CENTER>
<B><FONT SIZE=2>Bit(s)</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2>Meaning</FONT></B></TH></TR>

<TR><TH><B>PF_FASTLOAD</B></TH><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>If set, clear only the BSS area on program load, otherwise clear the entire heap.</FONT>
</TD></TR>

<TR><TH><B>PF_TTRAMLOAD</B></TH><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>If set, the program may be loaded into alternative RAM, otherwise it must be loaded into standard RAM.</FONT>
</TD></TR>

<TR><TH><B>PF_TTRAMMEM</B></TH><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>If set, the program's <B>Malloc()</B> requests may be satisfied from alternative RAM, otherwise they must be satisfied from standard RAM.</FONT>
</TD></TR>

<TR><TD>-</TD><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Currently unused.</FONT></TD></TR>

<TR><TD>See left.</TD><TD>
<CENTER>
<FONT SIZE=2>4 &amp; 5</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>If these bits are set to 0 (<B>PF_PRIVATE</B>), the processes' entire memory space will be considered private (when memory protection is enabled).</FONT>If these bits are set to 1 (<B>PF_GLOBAL</B>), the processes' entire memory space will be readable and writable by any process (i.e. global).<FONT SIZE=2>If these bits are set to 2 (<B>PF_SUPERVISOR</B>), the processes' entire memory space will only be readable and writable by itself and any other process in <a name=supervisormode>supervisor mode.</FONT>If these bits are set to 3 (<B>PF_READABLE</B>), the processes' entire memory space will be readable by any application but only writable by itself.
</TD></TR>

<TR><TD>-</TD><TD>
<CENTER>
<FONT SIZE=2>6-15</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Currently unused.</FONT></TD></TR>

</TABLE>

<P>

<P>
When a process is started by <B>GEMDOS</B>, it allocates all remaining
memory, loads the process into that memory, and JMP's to the first
byte of the application's TEXT segment with the address of the
program's basepage at 4(sp). An application should use the basepage
information to decide upon the amount of memory it actually needs
and <B>Mshrink()</B> to return the rest to the system. The exception
to this is that desk accessories are only given as much space
as they need (as indicated by their program header) and their
stack space is pre-assigned.
<P>
The following code illustrates the proper way to release system
memory and allocate your stack (most 'C' startup routines do this
for you):

<PRE>
stacksize	=	$2000			; 8K

				.text

_start:
		move.l	4(sp),a0			; Obtain pointer to basepage
		move.l	a0,basepage		; Save a copy
		move.l	$18(a0),a1		; BSS Base address
		adda.l	$1C(a0),a1		; Add BSS size
		adda.l	#stacksize,a1		; Add stack size

		move.l	a1,sp			; Move your stack pointer to
								; your new stack.

		suba.l	basepage,a1		; TPA size
		move.l	a1,-(sp)
		move.l	basepage,-(sp)
		clr.w	-(sp)
		move.w	#$4a,-(sp)		; Mshrink()
		trap		#1
		lea		12(sp),sp		; Fix up stack
								; and fall through to main
_main:
	...

				.bss

basepage:		ds.l		1

				.end

</PRE>

<P>
The <B>GEMDOS</B> <a name=basepage><B>BASEPAGE</B> structure has the following
members:
<TABLE BORDER=1>

<TR><TH><B>Name</B></TH><TH>
<CENTER>
<B><FONT SIZE=2>Offset</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2>Meaning</FONT></B></TH></TR>

<TR><TH><I>p_lowtpa</I></TH><TD>
<CENTER>
<FONT SIZE=2>0x00</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This <B>LONG</B> contains a pointer to the <a name=transientprogramarea>Transient Program Area (TPA).</FONT>
</TD></TR>

<TR><TH><I>p_hitpa</I></TH><TD>
<CENTER>
<FONT SIZE=2>0x04</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This <B>LONG</B> contains a pointer to the top of the TPA + 1.</FONT>
</TD></TR>

<TR><TH><I>p_tbase</I></TH><TD>
<CENTER>
<FONT SIZE=2>0x08</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This <B>LONG</B> contains a pointer to the base of the text segment</FONT>
</TD></TR>

<TR><TH><I>p_tlen</I></TH><TD>
<CENTER>
<FONT SIZE=2>0x0C</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This <B>LONG</B> contains the length of the text segment.</FONT>
</TD></TR>

<TR><TH><I>p_dbase</I></TH><TD>
<CENTER>
<FONT SIZE=2>0x10</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This <B>LONG</B> contains a pointer to the base of the data segment.</FONT>
</TD></TR>

<TR><TH><I>p_dlen</I></TH><TD>
<CENTER>
<FONT SIZE=2>0x14</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This <B>LONG</B> contains the length of the data segment.</FONT>
</TD></TR>

<TR><TH><I>p_bbase</I></TH><TD>
<CENTER>
<FONT SIZE=2>0x18</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This <B>LONG</B> contains a pointer to the base of the BSS segment.</FONT>
</TD></TR>

<TR><TH><I>p_blen</I></TH><TD>
<CENTER>
<FONT SIZE=2>0x1C</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This <B>LONG</B> contains the length of the BSS segment.</FONT>
</TD></TR>

<TR><TH><I>p_dta</I></TH><TD>
<CENTER>
<FONT SIZE=2>0x20</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This <B>LONG</B> contains a pointer to the processes' DTA.</FONT>
</TD></TR>

<TR><TH><I>p_parent</I></TH><TD>
<CENTER>
<FONT SIZE=2>0x24</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This <B>LONG</B> contains a pointer to the processes' parent's basepage.</FONT>
</TD></TR>

<TR><TH><I>p_reserved</I></TH><TD>
<CENTER>
<FONT SIZE=2>0x28</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This <B>LONG</B> is currently unused and is reserved.</FONT>
</TD></TR>

<TR><TH><I>p_env</I></TH><TD>
<CENTER>
<FONT SIZE=2>0x2C</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This <B>LONG</B> contains a pointer to the processes' <a name=enviro_string>environment string.</FONT>
</TD></TR>

<TR><TH><I>p_undef</I></TH><TD>
<CENTER>
<FONT SIZE=2>0x30</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This area contains 80 unused, reserved bytes.</FONT>
</TD></TR>

<TR><TH><I>p_cmdlin</I></TH><TD>
<CENTER>
<FONT SIZE=2>0x80</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This area contains a copy of the 128 byte command line image. </FONT>
</TD></TR>

</TABLE>

<P>

<P>
Processes terminate themselves with either <B>Pterm0()</B>, <B>Pterm()</B>,
or <a name=ptermres><B>Ptermres()</B>. <B>Ptermres()</B> allows a segment of a
file to remain behind in memory after the file itself terminates
(this is mainly useful for TSR utilities).
<H5>The Atari Extended Argument Specification</H5>

<P>
<a name=commandline>When a process calls <B>Pexec()</B> to launch a child, the child
may receive a command line up to 125 characters in length. The
command line does not normally contain information about the process
itself (what goes in <I>argv</I>[0] in 'C'). <a name=argv>The Atari Extended
Argument Specification (ARGV) allows command lines of any length
and correctly passes the child the command that started it. The
ARGV specification works by passing the command tail in the child's
environment rather than in the command line buffer.
<P>
Both the parent and child have responsibilities when wanting to
correctly handle the ARGV specification. If a process wishes to
launch a child with a command line of greater than 125 characters
it should follow these steps:
<P>
1. Allocate a block of memory large enough to hold the existing
environment, the string 'ARGV=' and its terminating <B>NULL</B>,
a string containing the complete path and filename of the child
process and its terminating <B>NULL</B>, and a string containing
the child's command line arguments and its terminating <B>NULL</B>.
<P>
2. Next, copy these elements into the reserved block in the order
given above.
<P>
3. Finally, call <B>Pexec()</B> with this environment string and
a command line containing a length byte of 127 and the first 125
characters of the command line with a terminating <B>NULL</B>.
<P>
For a child to correctly establish that a parent process is using
ARGV it should check for the length byte of 127 and the ARGV variable.
Some parents may assign a value to ARGV (found between the 'ARGV='
and the terminating <B>NULL</B> byte). It should be skipped over
and ignored. If a child detects that its parent is using ARGV,
it then has the responsibility of breaking down the environment
into its components to properly obtain its command line elements.
<P>
<a name=appstart>It should be noted that many compilers include ARGV parsing in
their basic startup stubs. In addition, applications running under
<B>MultiTOS</B> should use the <B>AES</B> call <a name=shel_write><B>shel_write()</B>
as it automatically creates an ARGV environment string.
<HR>

<a name=gdvectors><a name=vectors><H4><FONT SIZE=4 >GEMDOS Vectors</FONT></H4>

<HR>

<P>
<B>GEMDOS</B> reserves eight system interrupt vectors (of which
only three are used) for various system housekeeping. The <B>BIOS</B>
function <B>Setexc()</B> should be used to redirect these vectors
when necessary. The <B>GEMDOS</B> vectors are as follows:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Name</FONT></B></TH><TH>
<CENTER>
<B><FONT SIZE=2 >Setexc()</FONT></B>
</CENTER>

<P>

<CENTER>
<B><FONT SIZE=2 >Vector Number</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Usage</FONT></B></TH></TR>

<TR><TH><B>VEC_TIMER</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x0100</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Timer Tick Vector: This vector is jumped through 50 times per second to maintain the time-of-day clock and accomplish other system housekeeping. A process intercepting this vector does not have to preserve any registers but should jump through the old vector when completed. Heavy use of this vector can severly affect system performance. Return from this handler with RTS.</FONT>
</TD></TR>

<TR><TH><B>VEC_CRITICALERR</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x0101</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Critical Error Handler: This vector is used by the <B>BIOS</B> to service critical alerts (an <B>Rwabs()</B> disk error or media change request). When called, the <B>WORD</B> at 4(sp) is a <B>GEMDOS</B> error number. On return, D0.L should contain 0x0001000 to retry the operation, 0 to ignore the error, or 0xFFFFFFxx to return an error code (xx). D3-D7 and A3-A6 must be preserved by the handler. Return from this handler with RTS.</FONT>
</TD></TR>

<TR><TH><B>VEC_PROCTERM</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x0102</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Process Terminate Vector: This vector is called just prior to the termination of a process ended with ctrl-c. Return from this handler with RTS.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
-
</CENTER>
</TD><TD>
<CENTER>
<FONT SIZE=2>0x103-0x0107</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Currently unused.</FONT></TD></TR>

</TABLE>

<P>

<HR>

<a name=mint><H4><FONT SIZE=4 >MiNT</FONT></H4>

<HR>

<P>
MiNT is Now TOS (<B>MiNT</B>) is the extension to <B>GEMDOS</B>
that allows <B>GEMDOS</B> to multitask under <B>MultiTOS</B>.
<B>MiNT</B> also provides memory protection (on a 68030 or higher)
to protect an errant process from disturbing another.
<H5>Processes</H5>

<P>
<B>MiNT</B> assigns each process a <a name=processidentifier>process identifier and a process
<a name=processpriority>priority value. The identifier is used to distinguish the process
from others in the multitasking environment. <a name=pgetpid><B>Pgetpid()</B>
is used to obtain the <B>MiNT</B> ID of the process and <a name=pgetppid><B>Pgetppid()</B>
can be used to obtain the ID of the processes' parent.
<P>
<B>MiNT</B> also supports networking file systems that support
the concept of user and process group control. The <a name=pgetpgrp><B>Pgetpgrp()</B>,
<a name=psetgrp><B>Psetpgrp()</B>, <a name=pgetuid><B>Pgetuid()</B>, <a name=psetuid><B>Psetuid()</B>, <a name=pgeteuid><B>Pgeteuid()</B>,
and <B>Pseteuid() </B>get and set the process, user, and effective
user ID for a process.
<P>
<B>MiNT</B> has complete control over the amount of time allocated
to individual processes. It is possible, however, to set a process
'delta' value with <a name=pnice><B>Pnice()</B> or <a name=prenice><B>Prenice()</B> which will
be used by <B>MiNT</B> to decide the amount of processor time
a process will get per <a name=timeslice>timeslice. <a name=syield><B>Syield()</B> can be used
to surrender the remaining portion of a timeslice.
<P>
Information about a processes' resource usage can be obtained
by calling <a name=prusage><B>Prusage()</B>. These values can be modified with
<a name=psetlimit><B>Psetlimit()</B>. System configuration capabilities may be obtained
with <a name=sysconf><B>Sysconf()</B>.
<P>
Each process can have a <a name=userdefinedlongword>user-defined longword value assigned to
itself with <a name=pusrval><B>Pusrval()</B>.
<P>
The functions <a name=pwait><B>Pwait()</B>, <a name=pwait3><B>Pwait3()</B>, and <a name=pwaitpid><B>Pwaitpid()</B>
attempt to determine the <a name=exitcodes>exit codes of stopped child processes.
<a name=threads><H5>Threads</H5>

<P>
It is possible under <B>MiNT</B> to split a single process into
'threads'. These threads continue execution independently as unique
processes. The <a name=pfork><B>Pfork()</B> and <a name=pvfork><B>Pvfork()</B> calls are used
to split a process into threads.
<P>
The original process that calls <B>Pfork()</B> or <B>Pvfork()</B>
is considered the parent and the newly created process is considered
the child.
<P>
Child processes created with <B>Pfork()</B> share the TEXT segment
of the parent, however they are given a copy of the DATA and BSS
segments. Both the parent and child execute concurrently.
<P>
Child processes created with <a name=pvfork><B>Pvfork()</B> share the entire
program code and data space including  the processor stack. The
parent process is suspended until the child exits or calls <B>Pexec()</B>'s
mode 200.
<P>
Child processes started with either call may make <B>GEM</B> calls
but a child process started with <a name=pfork2><B>Pfork()</B> must call <B>appl_init()</B>
to force <B>GEM</B> to uniquely recognize it as an independent
process. This is not necessary with <B>Pvfork()</B> because all
program variables are shared.
<P>
The following is a simple example of using a thread in a <B>GEM</B>
application:
<PRE>
VOID
UserSelectedPrint( VOID )
{
	/* Prevent the user from editing buffer being printed. */
	LockBufferFromEdits();
	
	if( Pfork() == 0)
	{
			/* Child enters here */

			appl_init();					/* Required for GEM threads. */

			DisplayPrintingWindow();		/* Do our task. */
			PrintBuffer();

			/* Send an AES message to the parent telling it to unlock buffer. */
			SendCompletedMessageToParent();

			/* Cleanup and exit thread. */
			appl_exit();
			Pterm( 0 );
	}

	/* Parent returns and continues normal execution. */
}

</PRE>

<H5><FONT SIZE=2><a name=filesystemextensions>File System Extensions</FONT></H5>

<P>
<B>MiNT</B> provides several new file and directory manipulation
functions that work with <B>TOS</B> and other loadable file systems.
The <a name=fcntl><a name=fcnt><B>Fcntl()</B> function performs a large number of file-based
tasks many of which apply to special files like <a name=terminaldevice>terminal emulators
and 'U:\' files. <a name=fxattr><B>Fxattr()</B> is used to obtain a file's extended
attributes. Some extended attributes are not relevant to the <B>TOS</B>
file system and will not return meaningful values (see the <I><B>Function
Reference</B></I> for details).
<P>
<a name=fgetchar><B>Fgetchar()</B> and <a name=fputchar><B>Fputchar()</B> can be used to get and
put single characters to a file. <a name=finstat><B>Finstat()</B> and <a name=foutstat><B>Foutstat()</B>
are used to determine the input or output <a name=filestatus>status of a file. <a name=fselect><B>Fselect()</B>
is used to select from a group of file handles those ready to
be read from or written to (often used for pipes).
<P>
<a name=flink><B>Flink()</B>, <a name=fsymlink><B>Fsymlink()</B>, and <a name=freadlink><B>Freadlink()</B> are
used to create hard and symbolic <a name=links>links to another file. Links
are not supported by all file systems (see the entries for these
functions for more details).
<P>
Some file systems may support the concept of <a name=fileownership>file ownership and
<a name=accesspermissions>access permissions (<B>TOS</B> does not). The <a name=fchown><B>Fchown()</B>
and <a name=fchmod><B>Fchmod()</B> calls are used to adjust the ownership flags
and access permissions of a file. <a name=pumask><B>Pumask()</B> can be used
to set the minimum access permissions assigned to each subsequently
created file.
<P>
<a name=fmidipipe><B>Fmidipipe()</B> is used to redirect the file handles used for
MIDI input and output.
<P>
<B>MiNT</B> provides four new functions for <a name=directoryenumeration>directory enumeration
(they provide similar functionality to <B>Fsfirst()</B> and <B>Fsnext()</B>
with a slightly easier interface). <a name=dopendir><B>Dopendir()</B> is used to
open a directory for enumeration. <a name=dreaddir><B>Dreaddir()</B> steps through
each entry in a directory. <a name=drewinddir><a name=drewindir><B>Drewinddir()</B> resets the file
pointer to the beginning of the directory. <a name=dclosedir><B>Dclosedir()</B>
closes a directory.
<P>
<a name=dlock><B>Dlock()</B> allows disk-formatters and other utilities which
require exclusive access to a drive the ability to lock a physical
device from other processes.
<P>
<a name=dgetcwd><B>Dgetcwd()</B> allows a process to obtain the current <B>GEMDOS</B>
working directory for any process in the system (including itself).
<P>
<a name=dcntl><B>Dcntl()</B> performs device and file-system specific operations
(consult the <I><B>Function Reference</B></I> for more details).
<a name=pseudodrives><a name=pseudodrive><H5>Pseudo Drives</H5>

<P>
<B>MiNT</B> creates a pseudo drive 'U:' which provides access
to device drivers, processes, and other system <a name=resources>resources. In addition
to creating a directory on drive U: for each system drive, <B>MiNT</B>
may create any of the following directories at the ROOT of the
drive:
<TABLE BORDER=1>

<TR><TH>
<CENTER>
<B><FONT SIZE=1 >Folder Name</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Contents</FONT></B></TH>
</TR>

<TR><TD>
<CENTER>
\DEV
</CENTER>
</TD><TD><FONT SIZE=2>Loaded devices</FONT>
</TD></TR>

<TR><TD>
<CENTER>
\PIPE
</CENTER>
</TD><TD><a name=fpipe2><FONT SIZE=2><a name=pipes>System pipes</FONT>
</TD></TR>

<TR><TD>
<CENTER>
\PROC
</CENTER>
</TD><TD><FONT SIZE=2>System processes</FONT>
</TD></TR>

<TR><TD>
<CENTER>
\SHM
</CENTER>
</TD><TD><FONT SIZE=2><a name=sharedmemory>Shared memory blocks</FONT>
</TD></TR>

</TABLE>

<P>

<P>
Drive directories on 'U:' act as if they were accessed by their
own drive letter. Folder 'U:\C\' contains the same files and folders
as 'C:\'.
<a name=procdirectory><H5>The 'U:\PROC' Directory</H5>

<P>
Each system process has a file entry in the 'U:\PROC' directory.
The filename given a process in this directory is the basename
for the file (without extension) with an extension consisting
of the <B>MiNT</B> process identifier. The MINIWIN.PRG application
might have an entry named 'MINIWIN.003'.
<P>
The file size listed corresponds to the amount of memory the process
is using. The time and date stamp contains the length of time
the process has been executing as if it were started on Jan. 1st,
1980 at midnight. The file attribute bits tell special information
about a process as follows:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Name</FONT></B></TH><TH>
<CENTER>
<B><FONT SIZE=2 >Attribute Byte</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Meaning</FONT></B></TH>
</TR>

<TR><TH><B>PROC_RUN</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x00</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>The process is currently running.</FONT>
</TD></TR>

<TR><TH><B>PROC_READY</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x01</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>The process is ready to run.</FONT></TD>
</TR>

<TR><TH><B>PROC_TSR</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x02</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>The process is a TSR.</FONT></TD></TR>

<TR><TH><B>PROC_WAITEVENT</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x20</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>The process is waiting for an event.</FONT>
</TD></TR>

<TR><TH><B>PROC_WAITIO</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x21</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>The process is waiting for I/O.</FONT></TD>
</TR>

<TR><TH><B>PROC_EXITED</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x22</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>The process has been exited but not yet released.</FONT>
</TD></TR>

<TR><TH><B>PROC_STOPPED</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x24</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>The process was stopped by a signal.</FONT>
</TD></TR>

</TABLE>

<P>

<a name=loadabledevices><H5>Loadable Devices</H5>

<P>
<B>MiNT</B> contains a number of built-in devices and also supports
loadable device drivers. Current versions of <B>MiNT</B> may contain
any of the following devices:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Device Filename</FONT></B>
</TH><TH><B><FONT SIZE=2 >Device</FONT></B></TH>
</TR>

<TR><TD>CENTR</TD><TD><FONT SIZE=2>Centronics Parallel Port</FONT>
</TD></TR>

<TR><TD>MODEM1</TD><TD><FONT SIZE=2>Modem Port 1</FONT></TD></TR>

<TR><TD>MODEM2</TD><TD><FONT SIZE=2>Modem Port 2</FONT></TD></TR>

<TR><TD><a name=serialdevice>SERIAL1</TD><TD><FONT SIZE=2>Serial Port 1</FONT></TD>
</TR>

<TR><TD>SERIAL2</TD><TD><FONT SIZE=2>Serial Port 2</FONT></TD>
</TR>

<TR><TD>MIDI</TD><TD><FONT SIZE=2>MIDI ports</FONT></TD></TR>

<TR><TD>PRN</TD><TD><FONT SIZE=2>PRN: device (usually the Centronics Parallel Port)</FONT>
</TD></TR>

<TR><TD>AUX</TD><TD><FONT SIZE=2>AUX: device (usually the RS232 Port)</FONT>
</TD></TR>

<TR><TD>CON</TD><TD><FONT SIZE=2>Current Terminal</FONT></TD>
</TR>

<TR><TD>TTY</TD><TD><FONT SIZE=2>Current Terminal (same as CON)</FONT>
</TD></TR>

<TR><TD>STDIN</TD><TD><FONT SIZE=2>Current File Handle 0 (standard input)</FONT>
</TD></TR>

<TR><TD>STDOUT</TD><TD><FONT SIZE=2>Current File Handle 1 (standard output)</FONT>
</TD></TR>

<TR><TD>STDERR</TD><TD><FONT SIZE=2>Current File Handle 2 (standard error)</FONT>
</TD></TR>

<TR><TD>CONSOLE</TD><TD><FONT SIZE=2>Physical Console (keyboard/screen)</FONT>
</TD></TR>

<TR><TD><a name=mousedevice>MOUSE</TD><TD><FONT SIZE=2>Mouse (system use only)</FONT>
</TD></TR>

<TR><TD>NULL</TD><TD><FONT SIZE=2><a name=nulldevice>NULL device</FONT></TD></TR>

<a name=aes><TR><TD>AES_BIOS</TD><TD><B><FONT SIZE=2>AES</FONT></B> <B>BIOS</B> Device (system use only)
</TD></TR>

<TR><TD>AES_MT</TD><TD><B><FONT SIZE=2>AES</FONT></B> Multitasking Device (system use only)
</TD></TR>

</TABLE>

<P>

<P>
Each of these devices is represented by a filename (as shown in
the table above) in the <a name=devdirectory>'U:\DEV\' directory. Using standard <B>GEMDOS</B>
calls (ex: <a name=fread2><B>Fread()</B> and <B>Fwrite()</B>) on these files
yields the same results as accessing the device directly. New
devices, including those directly accessible by the <B>BIOS</B>,
may be added to the system with the <B>Dcntl()</B> call using
a parameter of <B>DEV_INSTALL</B>, <B>DEV_NEWBIOS</B>, or<B> DEV_NEWTTY</B>.
See the <B>Dcntl()</B> call for details.
<P>
<B>MiNT</B> versions 1.08 and above will automatically load device
drivers with an extension of '.XDD' found in the root or '\MULTITOS'
directory. '.XDD' files are special device driver executables
which are responsible for installing one (or more) new devices.
<B>MiNT</B> will load the file and JSR to the first instruction
in the TEXT segment (no parameters are passed). The device driver
executable should not attempt to <a name=mshrink><B>Mshrink()</B> or create a
stack (one has already been created).
<P>
The '.XDD' may then either install its device itself with <B>Dcntl()</B>
and return <B>DEV_SELFINST</B> (1L) in register D0 or return a
pointer to a <B>DEVDRV</B> structure to have the <B>MiNT</B> kernel
install it (the 'U:\DEV\' filename will be the same as the first
eight characters of the '.XDD' file). If for some reason, the
device can not be initialized, 0L should be returned in D0.
<P>
When creating a new <B>MiNT</B> device with <B>Dcntl( DEV_INSTALL</B>,
<I>devname</I>, &amp;<I>dev_descr</I> <B>)</B> the structure <B>dev_descr</B>
contains a pointer to your <B>DEVDRV</B> structure defined as
follows:
<PRE>
typedef struct devdrv
{ 
	LONG (*open)( FILEPTR *f );
	LONG (*write)( FILEPTR *f, char *buf, LONG bytes );
	LONG (*read)( FILEPTR *f, char *buf, LONG bytes );
	LONG (*lseek)( FILEPTR *f, LONG where, LONG whence );
	LONG (*ioctl)( FILEPTR *f, WORD mode, VOIDP buf );
	LONG (*datime)( FILEPTR *f, WORD *timeptr, WORD rwflag );
	LONG (*close)( FILEPTR *f, WORD pid );
	LONG (*select)( FILEPTR *f, LONG proc, WORD mode );
	LONG (*unselect)( FILEPTR *f, LONG proc, WORD mode );
	LONG reserved[3];
} DEVDRV;
</PRE>

<P>
Each of the assigned members of this structure should point to
a valid routine that provides the named operation on the device.
The routine must preserve registers D2-D7 and A2-A7 returning
its completion code in D0. No operating system <B>TRAP</B>s should
be called from within these routines, however, using the vector
tables provided in the <B>kerinfo</B> structure returned from
the <B>Dcntl()</B> call, <B>GEMDOS</B> and <B>BIOS</B> calls may
be used. The specific function that each routine is responsible
for is as follows:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Member</FONT></B></TH><TH><B><FONT SIZE=2 >Meaning</FONT></B>
</TH></TR>

<TR><TH><I>open</I></TH><TD><FONT SIZE=2>This routine is called by the <B>MiNT</B> kernel after a <B>FILEPTR</B> structure has been created for a file determined to be associated with the device. The routine should perform whatever initialization is necessary and exit with a standard <B>GEMDOS</B> completion code.</FONT>This routine is responsible for validating the sharing mode and other file flags to verify that the file may be legally opened and should respond with an appropriate error code if necessary.
</TD></TR>

<TR><TH><I>write</I></TH><TD><FONT SIZE=2>This routine should write <I>bytes</I> number of <B>BYTE</B>s from <I>buf</I> to the file specified in <B>FILEPTR</B>. If the file pointer has the <B>O_APPEND</B> bit set, the kernel will perform an <I>lseek()</I> call to the end of the file prior to calling this function. If the <I>lseek()/write()</I> series of calls does not guarantee that data will be written at the end of a file associated with your device, this function must ensure that the data specified is actually written at the end of the file.</FONT>This function should return with a standard <B>GEMDOS</B> error code or the actual number of <B>BYTE</B>s written to the file when complete.
</TD></TR>

<TR><TH><I>read</I></TH><TD><FONT SIZE=2>This routine should read <I>bytes</I> number of <B>BYTE</B>s from the file specified in <B>FILEPTR</B> and place them in the buffer <I>buf</I>. This function should return with a standard <B>GEMDOS</B> error code or the actual number of bytes read by the routine.</FONT>
</TD></TR>

<TR><TH><I>lseek</I></TH><TD><FONT SIZE=2>This routine should move the file position pointer to the appropriate location in the file as specified by the parameter <I>where</I> in relation to the seek mode <I>whence</I>. Seek modes are the same as with <B>Fseek()</B>. The routine should return a <B>GEMDOS</B> error code or the absolute new position from the start of the file if successful.</FONT>
</TD></TR>

<TR><TH><I>ioctl</I></TH><TD><FONT SIZE=2>This routine is called from the system's perspective as <B>Fcntl()</B> and is used to perform file system/device specific functions. At the very least, your device should support <B>FIONREAD</B>, <B>FIONWRITE</B>, and the file/record locking modes of <B>Fcntl()</B>. The <I>arg</I> parameter of <B>Fcntl()</B> is passed as <I>buf</I>.</FONT>
</TD></TR>

<TR><TH><I>datime</I></TH><TD><FONT SIZE=2>This routine is used to read or modify the date/time attributes of a file. <I>timeptr</I> is a pointer to two <B>LONG</B>s containing the time and date of the file respectively. These <B>LONG</B>s should be used to set the file date and time if <I>rwflag</I> is non-zero or filled in with the file's creation date and time if <I>rwflag</I> is 0.</FONT>This function should return with a standard <B>GEMDOS</B> error code or <B>E_OK</B> (0) if successful.
</TD></TR>

<TR><TH><I>close</I></TH><TD><FONT SIZE=2>This routine is used by the kernel to close an open file. Be aware that if <I>f-&gt;links</I> is non-zero, additional processes still have valid handles to the file. If <I>f-&gt;links</I> is 0 then the file is really being closed. <I>pid</I> specifies the process closing the file and may not necessarily be the same as the process that opened it.</FONT>Device drivers should set the <B>O_LOCK</B> bit on f-&gt;flag when the <B>F_SETLK</B> or <B>F_SETLKW</B> <I>ioctl()</I> call is made. This bit can be tested for when a file is closed and all locks on all files associated with the same physical file owned by process <I>pid</I> should be removed. If the file did not have any locks created on it by process <I>pid,</I> then no locks should be removed.<FONT SIZE=2>This routine should return with a standard <B>GEMDOS</B> error code or <B>E_OK</B> (0) if successful.</FONT>
</TD></TR>

<TR><TH><I>select</I></TH><TD><FONT SIZE=2>This routine is called when a call to <B>Fselect()</B> names a file handled by this device. If <I>mode</I> is <B>O_RDONLY</B> then the select is for reading, otherwise, if <I>mode</I> is <B>O_WRONLY</B> then it is for writing. If the user <a name=fselect2><B>Fselect()</B>'s for both reading and writing then two calls to this function will be made.</FONT>The routine should return 1L if the device is ready for reading or writing (as appropriate) or it should return 0L and arrange to 'wake up' process <I>proc</I> when I/O becomes possible. This is usually accomplished by calling the <I>wakeselect()</I> member function of the kernel structure. Note that the value in <I>proc</I> is not the same as a <B>PID</B> and is actually a pointer to a <B>PROC</B> structure private to the <B>MiNT</B> kernel.
</TD></TR>

<TR><TH><I>unselect</I></TH><TD><FONT SIZE=2>This routine is called when a device waiting for I/O should no longer be waited for. The <I>mode</I> and <I>proc</I> parameters are the same as with <B>select()</B>. As with <B>select()</B>, if neither reading nor writing is to be waited for, two calls to this function will be made. </FONT>This routine should return a standard <B>GEMDOS</B> error code or <B>E_OK</B> (0) if successful.
</TD></TR>

</TABLE>

<P>

<P>
The <B>FILEPTR</B> structure pointed to by a parameter of each
of the above calls is defined as follows:
<PRE>
typedef struct fileptr
{
	WORD 			links;
	UWORD 			flags;
	LONG			pos;
	LONG			devinfo;
	fcookie			fc;
	struct devdrv 	*dev;
	struct fileptr	*next;
} FILEPTR;

</PRE>

<P>
The members of <B>FILEPTR</B> have significance as follows:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Member</FONT></B></TH><TH><B><FONT SIZE=2 >Meaning</FONT></B>
</TH></TR>

<TR><TH><I>links</I></TH><TD><FONT SIZE=2>This member contains a value indicating the number of copies of this file descriptor currently in existence.</FONT>
</TD></TR>

<TR><TH><I>flags</I></TH><TD><FONT SIZE=2>This member contains a bit mask which indicates several attributes (logically OR'ed together) of the file as follows:</FONT><U><B> Name Mask Meaning</B></U>
<P>
<FONT SIZE=2> <B>O_RDONLY</B> 0x0000 File is read-only.</FONT>
<P>
<FONT SIZE=2> <B>O_WRONLY</B> 0x0001 File is write-only.</FONT>
<P>
<FONT SIZE=2> <B>O_RDWR</B> 0x0002 File may be read or written.</FONT>
<P>
<FONT SIZE=2> <B>O_EXEC</B> 0x0003 File was opened to be executed.</FONT>
<P>
<FONT SIZE=2> <B>O_APPEND</B> 0x0008 Writes start at the end of the file.</FONT>
<P>
<FONT SIZE=2> <B>O_COMPAT</B> 0x0000 File-sharing compatibility mode.</FONT>
<P>
<FONT SIZE=2> <B>O_DENYRW</B> 0x0010 Deny read and write access.</FONT>
<P>
<FONT SIZE=2> <B>O_DENYW</B> 0x0020 Deny write access.</FONT>
<P>
<FONT SIZE=2> <B>O_DENYR</B> 0x0030 Deny read access.</FONT>
<P>
<FONT SIZE=2> <B>O_DENYNONE</B> 0x0040 Allow reads and writes.</FONT>
<P>
<FONT SIZE=2> <B>O_NOINHERIT</B> 0x0080 Children cannot use this file.</FONT>
<P>
<FONT SIZE=2> <B>O_NDELAY</B> 0x0100 Device should not block for I/O on this file.</FONT>
<P>
<FONT SIZE=2> <B>O_CREAT</B> 0x0200 File should be created if it doesn't exist.</FONT>
<P>
<FONT SIZE=2> <B>O_TRUNC</B> 0x0400 File should be truncated to 0 <B>BYTE</B>s if it already exists.</FONT>
<P>
<FONT SIZE=2> <B>O_EXCL</B> 0x0800 Open should fail if file already exists.</FONT>
<P>
<FONT SIZE=2> <B>O_TTY</B> 0x2000 File is a terminal.</FONT>
<P>
<FONT SIZE=2> <B>O_HEAD</B> 0x4000 File is a pseudo-terminal "master."</FONT>
<P>
<FONT SIZE=2> <B>O_LOCK</B> 0x8000 File has been locked.</FONT>
</TD></TR>

<TR><TH><I>pos</I></TH><TD><FONT SIZE=2>This field is initialized to 0 when a file is created and should be used by the device driver to store the file position pointer.</FONT>
</TD></TR>

<TR><TH><I>devinfo</I></TH><TD><FONT SIZE=2>This field is reserved for use between the file system and the device driver and may be used as desired. The exception to this is if the file is a TTY, in which case <I>devinfo</I> must be a pointer to a <I>tty</I> structure.</FONT>
</TD></TR>

<TR><TH><I>fc</I></TH><TD><FONT SIZE=2>This is the file cookie for the file as follows:</FONT>
<PRE>
typedef struct f_cookie
{
 FILESYS *fs;
 UWORD  dev;
 UWORD  aux;
 LONG  index;
} fcookie;<I><FONT SIZE=2>fs</FONT></I> is a pointer to the file system structure responsible for this device. <I>dev</I> is a <B>UWORD</B> giving a useful device ID (such as the <B>Rwabs()</B> device number). The meaning of <I>aux</I> is file system dependent. <I>index</I> should be used by file systems to provide a unique means of identifying a file.
</PRE>

</TD></TR>

<TR><TH><I>dev</I></TH><TD><FONT SIZE=2>This is a pointer to the <B>DEVDRV</B> structure of the device driver responsible for this file.</FONT>
</TD></TR>

<TR><TH><I>next</I></TH><TD><FONT SIZE=2>This pointer may be used by device drivers to link copies of duplicate file descriptors to <a name=file_locking>implement file locking or sharing code.</FONT>
</TD></TR>

</TABLE>

<P>

<P>
Upon successful return from the <B>Dcntl()</B> call, a pointer
to a <B>kerinfo</B> structure will be returned. The <B>kerinfo</B>
structure is defined below:
<PRE>
typedef LONG (*Func)();

struct kerinfo
{
	WORD		maj_version;
	WORD		min_version;
	UWORD		default_mode;
	WORD		reserved1;
	
	Func		*bios_tab;
	Func		*dos_tab;

	VOID		(*drvchng)( UWORD dev );

	VOID		(*trace)( char *, ... );
	VOID		(*debug)( char *, ... );
	VOID		(*alert)( char *, ... );
	VOID		(*fatal)( char *, ... );

	VOIDP		(*kmalloc)( LONG size );
	VOID		(*kfree)( VOIDP memptr );
	VOIDP		(*umalloc)( LONG size );
	VOID		(*ufree)( LONG memptr );

	WORD		(*strnicmp)( char *str1, char *str2, WORD maxsrch );
	WORD		(*stricmp)( char *str1, char *str2 );
	char *	(*strlwr)( char *str );
	char *	(*strupr)( char *str );
	WORD		(*sprintf)( char *strbuf, const char *fmtstr, ... );
	
	VOID		(*millis_time)( ULONG ms, WORD *td );
	LONG		(*unixtim)( UWORD time, UWORD date );
	LONG		(*dostim)( LONG unixtime );

	VOID		(*nap)( UWORD n );
	VOID		(*sleep)( WORD que, WORD cond );
	VOID		(*wake)( WORD que, WORD cond );
	VOID		(*wakeselect)( LONG proc );

	WORD		(*denyshare)( FILEPTR *list, FILEPTR *f );
	LOCK *	(*denylock)( LOCK *list, LOCK *new );

	LONG		res2[9];
};
</PRE>

<P>
The members of the <B>kerinfo</B> structure are defined as follows:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Member</FONT></B></TH><TH><B><FONT SIZE=2 >Meaning</FONT></B>
</TH></TR>

<TR><TH><I>maj_version</I></TH><TD><FONT SIZE=2>This <B>WORD</B> contains the kernel version number.</FONT>
</TD></TR>

<TR><TH><I>min_version</I></TH><TD><FONT SIZE=2>This <B>WORD</B> contains the minor kernel version number.</FONT>
</TD></TR>

<TR><TH><I>default_mode</I></TH><TD><FONT SIZE=2>This <B>UWORD</B> contains the default access permissions for a file.</FONT>
</TD></TR>

<TR><TH><I>reserved1</I></TH><TD><FONT SIZE=2>Reserved.</FONT>
</TD></TR>

<TR><TH><I>bios_tab</I></TH><TD><FONT SIZE=2>This is a pointer to the <B>BIOS</B> function jump table. Calling <I>bios_tab</I>[0x00]() is equivalent to calling <B>Getmpb()</B> and is the only safe way from within a device driver or file system.</FONT>
</TD></TR>

<TR><TH><I>dos_tab</I></TH><TD><FONT SIZE=2>This is a pointer to the <B>GEMDOS</B> function jump table. Calling <I>dos_tab</I>[0x3D]() is equivalent to calling <B>Fopen()</B> and is the only safe way from within a device driver or file system.</FONT>
</TD></TR>

<TR><TH><I>drvchng</I></TH><TD><FONT SIZE=2>This function should be called by a device driver if a media change was detected on the device during an operation. The parameter <I>dev</I> is the <B>BIOS</B> device number of the device.</FONT>
</TD></TR>

<TR><TH><I>trace</I></TH><TD><FONT SIZE=2>This function is used to send information messages to the kernel for <a name=debug>debugging purposes.</FONT>
</TD></TR>

<TR><TH><I>debug</I></TH><TD><FONT SIZE=2>This function is used to send error messages to the kernel for debugging purposes.</FONT>
</TD></TR>

<TR><TH><I>alert</I></TH><TD><FONT SIZE=2>This function is used to send serious error <a name=messages>messages to the kernel for debugging purposes.</FONT>
</TD></TR>

<TR><TH><I>fatal</I></TH><TD><FONT SIZE=2>This function is used to send fatal error messages to the kernel for debugging purposes.</FONT>
</TD></TR>

<TR><TH><I>kmalloc</I></TH><TD><FONT SIZE=2>Use this internal heap memory management function to allocate memory.</FONT>
</TD></TR>

<TR><TH><I>kfree</I></TH><TD><FONT SIZE=2>Use this internal heap memory management function to free memory allocated with <I>kmalloc</I>().</FONT>
</TD></TR>

<TR><TH><I>umalloc</I></TH><TD><FONT SIZE=2>Use this internal heap memory management function to allocate memory and attach it to the current process. The memory will be released automatically when the current process exits.</FONT>
</TD></TR>

<TR><TH><I>ufree</I></TH><TD><FONT SIZE=2>Use this internal heap memory management function to allocate memory allocated with <I>ufree</I>().</FONT>
</TD></TR>

<TR><TH><I>strnicmp</I></TH><TD><FONT SIZE=2>This function compares <I>maxsrch</I> characters of <I>str1</I> to <I>str2</I> and returns a negative value if <I>str1</I> is lower than <I>str2</I>, a positive value if <I>str1</I> is higher than <I>str2</I>, or 0 if they are equal.</FONT>
</TD></TR>

<TR><TH><I>stricmp</I></TH><TD><FONT SIZE=2>This function compares two <B>NULL</B> terminated strings, <I>str1</I> to <I>str2,</I> and returns a negative value if <I>str1</I> is lower than <I>str2</I>, a positive value if <I>str1</I> is higher than <I>str2</I>, or 0 if they are equal.</FONT>
</TD></TR>

<TR><TH><I>strlwr</I></TH><TD><FONT SIZE=2>This function converts all alphabetic characters in <I>str</I> to lower case.</FONT>
</TD></TR>

<TR><TH><I>strupr</I></TH><TD><FONT SIZE=2>This function converts all alphabetic characters in <I>str</I> to upper case.</FONT>
</TD></TR>

<TR><TH><I>sprintf</I></TH><TD><FONT SIZE=2>This function is the same as the 'C' library sprintf() function except that it will only convert <B>SPRINTF_MAX</B> characters (defined in TOSDEFS.H).</FONT>
</TD></TR>

<TR><TH><I>millis_time</I></TH><TD><FONT SIZE=2>This function converts the millisecond time value in <I>ms</I> to a <B>GEMDOS</B> time in <I>td</I>[0] and date in <I>td</I>[1].</FONT>
</TD></TR>

<TR><TH><I>unixtim</I></TH><TD><FONT SIZE=2>This function converts a <B>GEMDOS</B> time and date in a UNIX format <B>LONG</B>.</FONT>
</TD></TR>

<TR><TH><I>dostim</I></TH><TD><FONT SIZE=2>This function converts a UNIX format <B>LONG</B> time/date value into a <B>GEMDOS</B> time/date value. The return value contains the time in the upper <B>WORD</B> and the date in the lower <B>WORD</B>.</FONT>
</TD></TR>

<TR><TH><I>nap</I></TH><TD><FONT SIZE=2>This function causes a delay of <I>n</I> milliseconds.</FONT>
</TD></TR>

<TR><TH><I>sleep</I></TH><TD><FONT SIZE=2>This function causes the current process to sleep, placing it on the system que <I>que</I> until condition <I>cond</I> is met.</FONT>
</TD></TR>

<TR><TH><I>wake</I></TH><TD><FONT SIZE=2>This function causes all processes in que <I>que</I>, waiting for condition <I>cond</I>, to be woken.</FONT>
</TD></TR>

<TR><TH><I>wakeselect</I></TH><TD><FONT SIZE=2>This function wakes a process named by the code <I>proc</I> currently doing a select operation.</FONT>
</TD></TR>

<TR><TH><I>denyshare</I></TH><TD><FONT SIZE=2>This function determines whether the sharing mode of <I>f </I>conflicts with any of the files given in the linked list <I>list.</I></FONT>
</TD></TR>

<TR><TH><I>denylock</I></TH><TD><FONT SIZE=2>This function determines whether a new lock <I>new</I> conflicts with any existing lock in the linked list <I>list</I>. The <B>LOCK</B> structure is used internally by the kernel and is defined as follows:</FONT>
<PRE>
typedef struct ilock
{
 <a name=flock2>FLOCK   l;
 struct ilock *next;
 LONG    reserved[4];
} LOCK;<I><FONT SIZE=2>l</FONT></I> is the structure actually containing the lock data (as defined in <a name=fcntl2><B>Fcntl()</B>). <I>next</I> is a pointer to the next <B>LOCK</B> structure in the linked list or <B>NULL</B> if this is the last lock. <I>reserved</I> is a pointer to four <B>LONG</B>s currently reserved.
</PRE>

</TD></TR>

<TR><TH><I>res2</I></TH><TD><FONT SIZE=2>These longwords are reserved for future expansion.</FONT>
</TD></TR>

</TABLE>

<P>

<a name=loadablefilesystems><H5>Loadable File Systems</H5>

<P>
<B>MiNT</B> supports loadable file systems to provide support
for those other than <B>TOS</B> (such as POSIX, HPFS, ISO 9660
<a name=cdrom2>CD-ROM, etc.) The <B>MiNT</B> kernel will automatically load file
system '.XFS' executables found in the \MULTITOS or <a name=root_dir>root directory.
As of <B>MiNT</B> version 1.08, it is also possible to have a
TSR program install a file system with the <a name=dcntl2><B>Dcntl()</B> call.
<P>
When the file system is executed by <B>MiNT</B> (i.e. not via
<B>Dcntl()</B>), <B>MiNT</B> creates an 8K stack and shrinks the
TPA so a call to <a name=mshrink2><B>Mshrink()</B> is not necessary. The first
instruction of the code segment of the file is JSR'ed to with
a pointer to a <B>kerinfo</B> (as defined above) structure at
4(sp). The file system should use this entry point to ensure that
it is running on the minimum version of <B>MiNT</B> needed and
that any other aspects of the system are what is required for
the file system to operate.
<P>
It is not necessary to scan existing drives to determine if they
are compatible with the file system as that is accomplished with
the file system <I>root()</I> function (defined below). If the
file system needs to make <B>MiNT</B> aware of drives that would
not be automatically recognized by the system, it should update
the longword variable _<I>drvbits</I> at location 0x04F2 appropriately.
<P>
<a name=aespb>If the file system was unable to initialize itself or the host
system is incapable of supporting it, the entry stub should return
with a value of 0L in d0. If the file system installs successfully,
it should return a pointer to a <B>FILESYS</B> (defined below)
structure in d0. A file system should never call <a name=pterm2><B>Pterm()</B>
or <a name=ptermres2><B>Ptermres()</B>.
<P>
All file system functions, including the entry stub, must preserve
registers d2-d7 and a2-a7. Any return values should be returned
in d0. Function arguments are passed on the stack. The following
listing defines the <B>FILESYS</B> structure:
<PRE>
typedef struct filesys
{
<a name=fxattr2>	struct filesys		*next;
	LONG				fsflags;
	LONG				(*root)( WORD drv, fcookie *fc );
	LONG				(*lookup)( fcookie *dir, char *name, fcookie *fc );
	LONG				(*creat)( fcookie *dir, char *name, UWORD mode, WORD attrib,
									fcookie *fc );
	DEVDRV			*(*getdev)( fcookie *fc, LONG *devspecial );
	LONG				(*getxattr)( fcookie *file, XATTR *xattr );
	LONG				(*chattr)( fcookie *file, WORD attr );
	LONG				(*chown)( fcookie *file, WORD uid, WORD gid );
	LONG				(*chmode)( fcookie *file, WORD mode );
	LONG				(*mkdir)( fcookie *dir, char *name, UWORD mode );
	LONG				(*rmdir)( fcookie *dir, char *name );
	LONG				(*remove)( fcookie *dir, char *name );
	LONG				(*getname)( fcookie *relto, fcookie *dir, char *pathname );
	LONG				(*rename)( fcookie *olddir, fcookie *oldname,
									fcookie *newdir, fcookie *newname );
	LONG				(*opendir)( DIR *dirh, WORD tosflag );
	LONG				(*readdir)( DIR *dirh, char *name, WORD namelen,
									fcookie *fc );
	LONG				(*rewinddir)( DIR *dirh );
	LONG				(*closedir)( DIR *dirh );
	LONG				(*pathconf)( fcookie *dir, WORD which );
	LONG				(*dfree)( fcookie *dir, long *buf );
	LONG				(*writelabel)( fcookie *dir, char *name );
	LONG				(*readlabel)( fcookie *dir, char *name );
	LONG				(*symlink)( fcookie *dir, char *name, char *to );
	LONG				(*readlink)( fcookie *file, char *buf, short buflen );
	LONG				(*hardlink)( fcookie *fromdir, char *fromname,
									fcookie *todir, char *toname );
	LONG				(*fscntl)( fcookie *dir, char *name, WORD cmd, LONG arg );
	LONG				(*dskchng)( WORD dev );
	LONG				zero;
} FILESYS;
	
</PRE>

<P>
The members of the <B>FILESYS</B> structure are interpreted by
<B>MiNT</B> as follows:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Member</FONT></B></TH><TH><B><FONT SIZE=2 >Meaning</FONT></B>
</TH></TR>

<TR><TH><I>next</I></TH><TD><FONT SIZE=2>This member is a pointer to the next <B>FILESYS</B> structure in the kernel's linked list. It should be left as <B>NULL</B>.</FONT>
</TD></TR>

<TR><TH><I>fsflags</I></TH><TD><FONT SIZE=2>This is a bit mask of flags which define attributes of the file system as follows:</FONT><U><B>Name Mask Meaning</B></U>
<P>
<B><FONT SIZE=2>FS_KNOPARSE </FONT></B>0x01 Kernel shouldn't do directory parsing (common for
<P>
<FONT SIZE=2>  networked file systems).</FONT>
<P>
<B><FONT SIZE=2>FS_CASESENSITIVE </FONT></B>0x02 File system names are case-sensitive (common for
<P>
<FONT SIZE=2>  Unix compatible file systems).</FONT>
<P>
<B><FONT SIZE=2>FS_NOXBIT </FONT></B>0x04 Files capable of being read are capable of being 
<P>
<FONT SIZE=2>  executed (present in most file systems).</FONT>
</TD></TR>

<TR><TH><I>root</I></TH><TD><FONT SIZE=2>This function is called by the kernel to retrieve a file cookie for the root directory of the drive associated with <B>BIOS</B> device <I>dev</I>. When initializing, the kernel will query each file system, in turn, to determine which file system should handle a particular drive. If your file system recognizes the drive specified by <I>dev</I> it should fill in the <B>fcookie</B> structure as appropriate and return <B>E_OK</B>. If the drive is not compatible with your file system, return an appropriate negative <B>GEMDOS</B> error code (usually <B>EDRIVE</B>).</FONT>
</TD></TR>

<TR><TH><I>lookup</I></TH><TD><FONT SIZE=2>This function should translate a file name into a cookie. If the <B>FS_KNOPARSE</B> bit of <I>fsflags</I> is not set, <I>name</I> will be the name of a file in the directory specified by the <B>fcookie</B> <I>dir</I>. If the <B>FS_KNOPARSE</B> bit was set, <I>name</I> will be a path name relative to the specified directory <I>dir</I>.</FONT>If the file is found, the <B>fcookie</B> structure <I>fc</I> should be filled in with appropriate details and either <B>E_OK</B> or <B>EMOUNT</B> (if <I>name</I> is '..' and <I>dir</I> specifies the root directory) should be returned, otherwise an appropriate error code (like <B>EFILNF</B>) should be returned.<FONT SIZE=2>A <I>lookup()</I> call with a <B>NULL</B> <I>name</I> or with a <I>name</I> of '.' should always succeed and return a cookie representing the current directory. When creating a file cookie, <a name=symboliclinks>symbolic links should never be followed.</FONT>
</TD></TR>

<TR><TH><I>creat</I></TH><TD><FONT SIZE=2>This function is used by the kernel to instruct the file system to create a file named <I>name</I> in the directory specified by <I>dir</I> with <I>attrib</I> attributes (as defined by <B>Fattrib()</B>) and <I>mode</I> permissions as follows:</FONT><U><B>Name Mask Permission</B></U><B><FONT SIZE=2>S_IXOTH </FONT></B>0x0001 Execute permission for all others.
<P>
<B><FONT SIZE=2>S_IWOTH </FONT></B>0x0002 Write permission for all others.
<P>
<B><FONT SIZE=2>S_IROTH </FONT></B>0x0004 Read permission for all others.
<P>
<B><FONT SIZE=2>S_IXGRP </FONT></B>0x0008 Execute permission for processes with same group ID.
<P>
<B><FONT SIZE=2>S_IWGRP </FONT></B>0x0010 Write permission for processes with same group ID.
<P>
<B><FONT SIZE=2>S_IRGRP </FONT></B>0x0020 Read permission for processes with same group ID.
<P>
<B><FONT SIZE=2>S_IXUSR </FONT></B>0x0040 Execute permission for processes with same user ID.
<P>
<B><FONT SIZE=2>S_IWUSR </FONT></B>0x0080 Write permission for processes with same user ID.
<P>
<B><FONT SIZE=2>S_IRUSR </FONT></B>0x0100 Read permission for processes with same user ID.
<P>
<B><FONT SIZE=2>S_ISVTX </FONT></B>0x0200 Unused
<P>
<B><FONT SIZE=2>S_ISGID </FONT></B>0x0400 Alter effective group ID when executing this file.
<P>
<B><FONT SIZE=2>S_ISUID </FONT></B>0x0800 Alter effective user ID when executing this file.
<P>
<B><FONT SIZE=2>S_IFCHR </FONT></B>0x2000 File is a <B>BIOS</B> special file.
<P>
<B><FONT SIZE=2>S_IFDIR </FONT></B>0x4000 File is a directory.
<P>
<B><FONT SIZE=2>S_IFREG </FONT></B>0x8000 File is a regular file.
<P>
<B><FONT SIZE=2>S_IFIFO </FONT></B>0xA000 File is a FIFO.
<P>
<B><FONT SIZE=2>S_IMEM </FONT></B>0xC000 File is a memory region.
<P>
<B><FONT SIZE=2>S_IFLNK </FONT></B>0xE000 File is a symbolic link.<FONT SIZE=2>If the file is created successfully, the fcookie structure fc should be filled in to represent the newly created file and <B>E_OK</B> should be returned. On an error, an appropriate <B>GEMDOS</B> error code should be returned.</FONT>
</TD></TR>

<TR><TH><I>getdev</I></TH><TD><FONT SIZE=2>This function is used by the kernel to identify the device driver that should be used to do file I/O on the file named by <I>fc</I>. The function should return a pointer to the device driver and place a user-defined value in the longword pointed to by <I>devspecial</I>. If the function fails, the function should return and place a negative <B>GEMDOS</B> error code in the longword pointed to by <I>devspecial</I>.</FONT>
</TD></TR>

<TR><TH><I>getxattr</I></TH><TD><FONT SIZE=2>This function should fill in the <B>XATTR</B> structure pointed to by <I>xattr</I> with the extended attributes of file <I>fc</I>. If the function succeeds, the routine should return <B>E_OK</B>, otherwise a negative <B>GEMDOS</B> error code should be returned.</FONT>
</TD></TR>

<TR><TH><I>chattr</I></TH><TD><FONT SIZE=2>This function is called by the kernel to instruct the file system to change the attributes of file <I>fc</I> to those in <I>attr</I> (with only the low eight bits being signifigant). The function should return a standard <B>GEMDOS</B> error code on exit. </FONT>
</TD></TR>

<TR><TH><I>chown</I></TH><TD><FONT SIZE=2>This function is called by the kernel to instruct the file system to change the file <I>fc</I>'s group and user ownership to <I>gid</I> and <I>uid</I> respectively. The kernel checks access permissions prior to calling this function so the file system does not have to.</FONT>
</TD></TR>

<TR><TH><I>chmode</I></TH><TD><FONT SIZE=2>This function is called by the kernel to instruct the file system to change the access permissions of file <I>fc</I> to those in <I>mode</I>. The <I>mode</I> parameter passed to this function will never contain anything but access permission information (i.e. no file type information will be contained in <I>mode</I>). The call should return a standard <B>GEMDOS</B> error code on exit.</FONT>
</TD></TR>

<TR><TH><I>mkdir</I></TH><TD><FONT SIZE=2>This function should create a new subdirectory called <I>name</I> in directory <I>dir</I> with access permissions of <I>mode</I>. The file system should ensure that directories such as '.' and '..' are created and that a standard <B>GEMDOS</B> error code is returned.</FONT>
</TD></TR>

<TR><TH><I>rmdir</I></TH><TD><FONT SIZE=2>This function should remove the directory whose name is <I>name</I> and whose cookie is pointed to by <I>dir</I>. This call should allow the removal of symbolic links to directories and return a standard <B>GEMDOS</B> error code.</FONT>
</TD></TR>

<TR><TH><I>remove</I></TH><TD><FONT SIZE=2>This function should delete the file named <I>name</I> that resides in directory <I>dir</I>. If more than one 'hard' link to this file exists, then only this link should be destroyed and the file contents should be left untouched. Symbolic links to file <I>fc</I>, however, should be removed. This function should not allow the deletion of directories and should return with a standard <B>GEMDOS</B> error code.</FONT>
</TD></TR>

<TR><TH><I>getname</I></TH><TD><FONT SIZE=2>This function should fill in the buffer pointed to by <I>pathname</I> with as many as <B>PATH_MAX</B> (128) characters of the path name of directory <I>dir</I> expressed relatively to directory <I>relto</I>. If relto and dir point to the same directory, a <B>NULL</B> string should be returned.</FONT>For example, if <I>relto</I> points to directory "\FOO" and <I>dir</I> points to directory "\FOO\BAR\SUB" then <I>pathname</I> should be filled in with "\BAR\SUB".
</TD></TR>

<TR><TH><I>rename</I></TH><TD><FONT SIZE=2>This function should rename the file <I>oldname</I> which resides in directory <I>olddir</I> to the new name <I>newname</I> which resides in <I>newdir</I>. The file system may choose to support or not support cross-directory renames. The function should return a standard <B>GEMDOS</B> error code. If no renames at all are supported then <B>EINVFN</B> should be returned.</FONT>
</TD></TR>

<TR><TH><I>opendir</I></TH><TD><FONT SIZE=2>This function opens directory <I>dirh</I> for reading. The parameter <I>tosflag</I> is a copy of the <I>flags</I> member of the <B>DIR</B> structure as defined below:</FONT>
<PRE>
typedef struct dirstruct
{
 fcookie fc;   /* Directory cookie */
 UWORD  index;  /* Index of current entry */
 UWORD  flags;  /* TOS_SEARCH (1) or 0 */
 char  fsstuff[60]; /* File system dependent */
} DIR;<FONT SIZE=2>If <I>tosflags</I> (<I>dirstruct.flags</I>) is contains the mask <B>TOS_SEARCH</B> the file system is responsible for parsing the names into something readable by <B>TOS</B> domain applications. The file system should initialize the <I>index</I> and <I>fsstuff</I> members of <I>dirh</I> and return an appropriate <B>GEMDOS</B> error code.</FONT>
</PRE>

</TD></TR>

<TR><TH><I>readdir</I></TH><TD><FONT SIZE=2>This function should read the next filename from directory <I>dirh</I>. The <B>fcookie</B> structure <I>fc</I> should be filled in with the details of this file. If <I>dirh-&gt;flags</I> does not contain the mask <B>TOS_SEARCH</B> then the filename should be copied into the buffer pointed to by <I>name</I>. If <I>dirh-&gt;flags</I> does contain the mask <B>TOS_SEARCH</B> then the first four bytes of <I>name</I> should be treated as a longword and filled in with an index value uniquely identifying the file and the filename should be copied starting at <I>&amp;name[4]</I>.</FONT>In either case, if the filename is longer than <I>namelen</I>, rather than filling in the buffer <I>name</I>, the function should return with <B>ENAMETOOLONG</B>. If this is the last file in the directory, <B>ENMFIL</B> should be returned, otherwise return <B>E_OK</B>.
</TD></TR>

<TR><TH><I>rewinddir</I></TH><TD><FONT SIZE=2>This function should reset the members of <I>dirh</I> so that any internal pointers point at the first file of directory <I>dirh</I>. This function should return a standard <B>GEMDOS</B> error code.</FONT>
</TD></TR>

<TR><TH><I>closedir</I></TH><TD><FONT SIZE=2>This function should clear any allocated memory and clean up any structures used by the search on <I>dirh</I>. This function should return a standard <B>GEMDOS</B> error code.</FONT>
</TD></TR>

<TR><TH><I>pathconf</I></TH><TD><FONT SIZE=2>This function should return information about the directory <I>dir</I> based on mode <I>mode</I>. For <I>mode</I> values and return values, see <a name=dpathconf2><B>Dpathconf()</B>.</FONT>
</TD></TR>

<TR><TH><a name=dfree2><I>dfree</I></TH><TD><FONT SIZE=2>This function should return free space information about the drive directory <I>dir</I> is located on. The format of the buffer pointed to by <I>buf</I> is the same as is used by <B>Dfree()</B>.This function should return a standard <B>GEMDOS</B> error code.</FONT>
</TD></TR>

<TR><TH><I>writelabel</I></TH><TD><FONT SIZE=2>This function is used to change the volume name of a drive which contains the directory <I>dir</I>. The new name <I>name</I> should be used to write (or rename the volume label). If the write is actually an attempt to rename the label and the file system does not support this function then <B>EACCDN</B> should be returned. If the file system does not support the concept of volume labels then <B>EINVFN</B> should be returned. Otherwise, a return value of <B>E_OK</B> is appropriate.</FONT>
</TD></TR>

<TR><TH><I>readlabel</I></TH><TD><FONT SIZE=2>This function should copy the volume label name of the drive on which directory <I>dir</I> is contained in the buffer <I>name</I>. If <I>namelen</I> is less than the size of the volume name, <B>ENAMETOOLONG</B> should be returned. If the concept of volume names is not supported by the file system, <B>EINVFN</B> should be returned. If no volume name was ever created, <B>EFILNF</B> should be returned. Upon successful error of the call, <B>E_OK</B> should be returned.</FONT>
</TD></TR>

<TR><TH><a name=fsymlink2><I>symlink</I></TH><TD><FONT SIZE=2>This function should create a symbolic link in directory <I>dir</I> named <I>name</I>. The symbolic link should contain the <B>NULL</B> terminated string in <I>to</I>. If the file system does not support symbolic links it should return <B>EINVFN</B>, otherwise a standard <B>GEMDOS</B> error code should be returned.</FONT>
</TD></TR>

<TR><TH><I>readlink</I></TH><TD><FONT SIZE=2>This function should copy the contents of symbolic link <I>file</I> into buffer <I>buf</I>. If the length of the contents of the symbolic link is greater than <I>buflen</I>, <B>ENAMETOOLONG</B> should be returned. If the file system does not support symbolic links, <B>EINVFN</B> should be returned. In all other cases, a standard <B>GEMDOS</B> error code should be returned.</FONT>
</TD></TR>

<TR><TH><I>hardlink</I></TH><TD><FONT SIZE=2>This function should create a 'hard' link called <I>toname</I> residing in <I>todir</I> from the file named <I>fromname</I> residing in <I>fromdir</I>. If the file system does not support <a name=hardlinks>hard links, <B>EINVFN</B> should be returned. Otherwise, a standard <B>GEMDOS</B> error code should be returned.</FONT>
</TD></TR>

<TR><TH><I>fscntl</I></TH><TD><FONT SIZE=2>This function performs a file system specific function on a file whose name is <I>name</I> that resides in directory <I>dir</I>. The <I>cmd</I> and <I>arg</I> functions parallel those of <B>Dcntl()</B>. In most cases, this function should simply return <B>EINVFN</B>. If your file system wishes to expose special features to the user through <B>Dcntrl()</B> then your file system should handle them here as it sees fit.</FONT>
</TD></TR>

<TR><TH><I>dskchng</I></TH><TD><FONT SIZE=2>This function is used by the kernel to confirm a 'media change' state reported by <B>Mediach()</B>.<B> </B>If the file system agrees that a media change has taken place, it should invalidate any appropriate buffers, free any allocated memory associated with the device, and return 1. The kernel will then invalidate any open files and relog the drive with the <I>root()</I> functions of each installed file system.</FONT>If a media change has not taken place, simply return a value of 0.
</TD></TR>

<TR><TH><I>zero</I></TH><TD><FONT SIZE=2>This member is reserved for future expansion and must be set to 0L.</FONT>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=commun><H4><FONT SIZE=4 >MiNT <a name=interprocesscommunication>Interprocess Communication</FONT>
</H4>

<HR>

<H5>Pipelines</H5>

<P>
A pipeline is a special file used for data communication in which
the data being read or written is kept in memory. Pipes are created
by <B>Fcreate()</B>'ing a file in the special directory <a name=pipedirectory>'U:\PIPE'.
A process which initially opens a pipe is considered the 'server.'
Processes writing to or reading from the open pipe are called
'clients.' Both servers and clients may read to and write from
the pipe.
<P>
<B>Fcreate()</B>'s <I>attr</I> byte takes on a special meaning
with pipes as follows:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Name</FONT></B></TH><TH>
<CENTER>
<B><FONT SIZE=2 >Bit</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Meaning</FONT></B></TH>
</TR>

<TR><TH><B>FA_UNIDIR</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x01</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>If this bit is set, the pipe will be unidirectional (the server can only write, the client can only read).</FONT>
</TD></TR>

<TR><TH><B>FA_SOFTPIPE</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x02</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Setting this bit causes reads when no one is writing to return <a name=eof><B>EOF</B> and writes when no one is reading to raise the signal <B>SIGPIPE</B>.</FONT>
</TD></TR>

<TR><TH><B>FA_TTY</B></TH><TD>
<CENTER>
<FONT SIZE=2>0x04</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>Setting this bit will make the pipe a pseudo-TTY, i.e. any characters written by the server will be interpreted (ctrl-c will cause a <B>SIGINT</B> signal to be generated to all clients).</FONT>
</TD></TR>

</TABLE>

<P>

<P>
<a name=fpipe><B>Fpipe()</B> can also be used to create pipes quickly with the
<B>MiNT</B> kernel resolving any name conflicts. A pipe is deleted
when all processes that had obtained a handle to it <B>Fclose()</B>
it. 
<P>
A single <a name=processattributes>process may serve as both the client and the server if
it maintains two handles (one obtained from <B>Fopen()</B> and
one from <a name=fcreate2><B>Fcreate()</B> ). In addition, child processes of the
server may inherit the file handle, and thus the server end of
the pipe.
<P>
A special system call, <a name=salert><B>Salert()</B>, sends a string to a pipe
called 'U:\PIPE\ALERT'. If a handler is present that reads from
this pipe, an alert with the text string will be displayed.
<a name=signals><H5>Signals</H5>

<P>
Signals are messages sent to a process that interrupt normal program
flow in a way that may be defined by the receiving application.
Signals are sent to a process with the function <a name=pkill><B>Pkill()</B>.<B>
</B> The call is named <B>Pkill()</B> because the default action
for most signals is the termination of the process. If a process
expects to receive signals it should use <a name=psignal><B>Psignal()</B>, <a name=psigsetmask><B>Psigsetmask()</B>,
<a name=psigblock><B>Psigblock()</B>, or <a name=psigaction><B>Psigaction()</B> to modify that behavior
by installing a handler routine, ignoring the signal, or blocking
the signal completely. 
<P>
Signal handlers should return by executing a 680x0 RTS instruction
or by calling <a name=psigreturn><B>Psigreturn()</B>. Current signals sent and recognized
by <B>MiNT</B> processes are as follows:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Signal</FONT></B></TH><TH>
<CENTER>
<B><FONT SIZE=2 >Number</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Meaning</FONT></B></TH>
</TR>

<TR><TH><B>SIGNULL</B></TH><TD>
<CENTER>
<FONT SIZE=2>0</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This signal is actually a dead signal since it has no effect and is never delivered. Its only purpose is to determine if a child process has exited. A <B>Pkill()</B> call with this signal number will return successfully if the process is still running or fail if not.</FONT>
</TD></TR>

<TR><TH><B>SIGHUP</B></TH><TD>
<CENTER>
<FONT SIZE=2>1</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This signal indicates that the terminal connected to the process is no longer valid. This signal is sent by window managers to processes when the user has closed your window. The default action for this signal is to kill the process.</FONT>
</TD></TR>

<TR><TH><B>SIGINT</B></TH><TD>
<CENTER>
<FONT SIZE=2>2</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This signal indicates that the user has interrupted the process with ctrl-c. The default action for this signal is to kill the process.</FONT>
</TD></TR>

<TR><TH><B>SIGQUIT</B></TH><TD>
<CENTER>
<FONT SIZE=2>3</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This signal is sent when the user presses ctrl-\. The default action for this signal is to kill the process.</FONT>
</TD></TR>

<TR><TH><B>SIGILL</B></TH><TD>
<CENTER>
<FONT SIZE=2>4</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This signal is sent after a 680x0 Illegal Instruction Exception has occurred. The default action for this signal is to kill the process. Catching this signal is unrecommended.</FONT>
</TD></TR>

<TR><TH><B>SIGTRAP</B></TH><TD>
<CENTER>
<FONT SIZE=2>5</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This signal is sent after each instruction is executed when the system is in single-step trace mode. Debuggers should catch this signal, other processes should not.</FONT>
</TD></TR>

<TR><TH><B>SIGABRT</B></TH><TD>
<CENTER>
<FONT SIZE=2>6</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This signal is sent when something has gone wrong internally and the program should be aborted immediately. The default action for this signal is to kill the process. It is unrecommended that you catch this signal.</FONT>
</TD></TR>

<TR><TH><B>SIGPRIV</B></TH><TD>
<CENTER>
<FONT SIZE=2>7</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This signal is sent to a process that attempts to execute an instruction that may only be executed in supervisor mode while in user mode. The default action for this signal is to kill the process.</FONT>
</TD></TR>

<TR><TH><B>SIGFPE</B></TH><TD>
<CENTER>
<FONT SIZE=2>8</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This signal is sent when a division by 0 or floating-point exception occurs. The default action for this signal is to kill the process.</FONT>
</TD></TR>

<TR><TH><B>SIGKILL</B></TH><TD>
<CENTER>
<FONT SIZE=2>9</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This signal forcibly kills the process. There is no way to catch or ignore this signal.</FONT>
</TD></TR>

<TR><TH><B>SIGBUS</B></TH><TD>
<CENTER>
<FONT SIZE=2>10</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This signal is sent when a 680x0 Bus Error Exception occurs. The default action for this signal is to kill the process.</FONT>
</TD></TR>

<TR><TH><B>SIGSEGV</B></TH><TD>
<CENTER>
<FONT SIZE=2>11</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This signal is sent when a 680x0 Address Error Exception occurs. The default action for this signal is to kill the process.</FONT>
</TD></TR>

<TR><TH><B>SIGSYS</B></TH><TD>
<CENTER>
<FONT SIZE=2>12</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This signal is sent when an argument to a system call is bad or out of range and the call doesn't have a way to report errors. For instance, <B>Super(</B>0L<B>)</B> will send this signal when already in supervisor mode. The default action for this signal is to kill the process.</FONT>
</TD></TR>

<TR><TH><B>SIGPIPE</B></TH><TD>
<CENTER>
<FONT SIZE=2>13</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This signal is sent when a pipe you were writing to has no readers. The default action for this signal is to kill the process.</FONT>
</TD></TR>

<TR><TH><B>SIGALRM</B></TH><TD>
<CENTER>
<FONT SIZE=2>14</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This signal is sent when an alarm sent by <a name=talarm><B>Talarm()</B> is triggered. The default action for this signal is to kill the process.</FONT>
</TD></TR>

<TR><TH><B>SIGTERM</B></TH><TD>
<CENTER>
<FONT SIZE=2>15</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This signal indicates a 'polite' request for the process to cleanup &amp; exit. This signal is sent when a process is dragged to the trashcan on the desktop. The default action for this signal is to kill the process.</FONT>
</TD></TR>

<TR><TH><B>SIGSTOP</B></TH><TD>
<CENTER>
<FONT SIZE=2>17</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This signal is sent to a process to suspend it. It cannot be caught, blocked, or ignored. This signal is usually used by debuggers.</FONT>
</TD></TR>

<TR><TH><B>SIGTSTP</B></TH><TD>
<CENTER>
<FONT SIZE=2>18</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This signal is sent when the user presses ctrl-z requesting that the process suspend itself. The default action for this signal is to suspend the process until a <B>SIGCONT</B> signal is caught.</FONT>
</TD></TR>

<TR><TH><B>SIGCONT</B></TH><TD>
<CENTER>
<FONT SIZE=2>19</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This signal is sent to restart a process stopped with <B>SIGSTOP</B> or <B>SIGTSTP</B>. The default action for this signal is to resume the process.</FONT>
</TD></TR>

<TR><TH><B>SIGCHLD</B></TH><TD>
<CENTER>
<FONT SIZE=2>20</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This signal is sent when a child process has exited or has been suspended. As a default, this signal causes no action.</FONT>
</TD></TR>

<TR><TH><B>SIGTTIN</B></TH><TD>
<CENTER>
<FONT SIZE=2>21</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This signal is sent when a process attempts to read from a terminal in a process group other than its own. The default action is to suspend the process.</FONT>
</TD></TR>

<TR><TH><B>SIGTTOU</B></TH><TD>
<CENTER>
<FONT SIZE=2>22</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This signal is sent when a process attempts to write to a terminal in a process group other than its own. The default action is to suspend the process.</FONT>
</TD></TR>

<TR><TH><B>SIGIO</B></TH><TD>
<CENTER>
<FONT SIZE=2>23</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This signal is sent to indicate that I/O is possible on a file descriptor. The default action for this signal is to kill the process.</FONT>
</TD></TR>

<TR><TH><B>SIGXCPU</B></TH><TD>
<CENTER>
<FONT SIZE=2>24</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This signal is sent when the maximum CPU time allocated to a process has been used. This signal will continue to be sent to a process until it exits. The default action for this signal is to kill the process.</FONT>
</TD></TR>

<TR><TH><B>SIGXFSZ</B></TH><TD>
<CENTER>
<FONT SIZE=2>25</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This signal is sent to a process when it attempts to modify a file in a way that causes it to exceed the processes' maximum file size limit. The default action for this signal is to kill the process.</FONT>
</TD></TR>

<TR><TH><B>SIGVTALRM</B></TH><TD>
<CENTER>
<FONT SIZE=2>26</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This signal is sent to a process which has exceed its maximum time limit. The default action for this signal is to kill the process.</FONT>
</TD></TR>

<TR><TH><B>SIGPROF</B></TH><TD>
<CENTER>
<FONT SIZE=2>27</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This signal is sent to a process to indicate that its profiling time has expired. The default action for this signal is to kill the process.</FONT>
</TD></TR>

<TR><TH><B>SIGWINCH</B></TH><TD>
<CENTER>
<FONT SIZE=2>28</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This signal indicates that the size of the window in which your process was running has changed. If the process cares about window size it can use <B>Fcntl()</B> to obtain the new size. The default action for this signal is to do nothing.</FONT>
</TD></TR>

<TR><TH><B>SIGUSR1</B></TH><TD>
<CENTER>
<FONT SIZE=2>29</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This signal is one of two user-defined signals. The default action for this signal is to kill the process.</FONT>
</TD></TR>

<TR><TH><B>SIGUSR2</B></TH><TD>
<CENTER>
<FONT SIZE=2>30</FONT>
</CENTER>

</TD><TD><FONT SIZE=2>This signal is one of two user-defined signals. The default action for this signal is to kill the process.</FONT>
</TD></TR>

</TABLE>

<P>

<H5>Memory Sharing</H5>

<P>
With the enforcement of memory protection under <B>MultiTOS</B>,
the availability of shared memory blocks is important for applications
wishing to share blocks of memory. A shared memory block is opened
by <B>Fcreate()</B>'ing a file in the <a name=shmdirectory>directory 'U:\SHM'. After
that, a memory block allocated with <a name=malloc2><B>Malloc()</B> or <a name=mxalloc2><B>Mxalloc()</B>
may be attached to the file with <B>Fcntl(&nbsp;</B><I>handle</I>,
<I>memptr</I>, <B>SHMSETBLK )</B>.
<P>
Any process which uses <B>Fopen()</B> and <B>Fcntl()</B> with
a parameter of <B>SHMGETBLK</B> can now read that memory as if
it were a disk file. After a process obtains the address of a
shared memory block with <B>SHMGETBLK</B> the memory is guaranteed
to be valid until it calls <B>Mfree()</B> on that block even if
it <B>Fclose()</B>'s the original file handle.
<P>
Note that the address returned by <B>Fcntl()</B> may be different
in different processes. Because of this, data in shared memory
blocks should not contain absolute pointers.
<P>
When a process is finished with a shared memory block, it should
<B>Mfree()</B> the address returned by the <B>Fcntl()</B> call.
A shared memory block is also deleted by the <B>Fdelete()</B>
call if the file is currently unopened by any other processes.
<H5>Other Methods of Communication</H5>

<P>
<a name=psemaphore><B>Psemaphore()</B> can be used to create named flags which can
synchronize the behavior of multiple applications (if adhered
to). <a name=pmsg><B>Pmsg()</B> is used to send simple messages between two
processes.
<HR>

<a name=debug><a name=debugging><H4><FONT SIZE=4 >MiNT Debugging</FONT></H4>

<HR>

<P>
<B>MiNT</B> allows a processes' TEXT, DATA, and BSS space to be
read and written to with standard <B>GEMDOS</B> file commands
by opening the process on 'U:\PROC\' A file named "TEST"
with a <B>MiNT</B> identification of 10 could be opened by specifying
the name as 'U:\PROC\TEST.10' or 'U:\PROC\.10'. Opening a file
to 'U:\PROC\.-1' will open your own process whereas opening a
file to 'U:\PROC\.-2' will open your parent process.
<a name=tracing><H5>Tracing</H5>

<P>
A process may be setup for tracing in a number of ways. A child
process may be started in trace mode by OR'ing 0x8000 with the
<a name=pexec2><B>Pexec()</B> mode number in a <B>Pexec()</B> call. A process
may also trace another process by opening it as described above
and using the <B>Fcntl()</B> call with a parameter of <a name=ptracesflags><B>PTRACESFLAGS</B>.
Processes may start tracing on themselves if their parent is prepared
for it.
<P>
When in trace mode, the process being traced halts and generates
a <B>SIGCHLD</B> signal to its tracer after every instruction
(unless this action is modified). The example below shows how
to obtain the process ID of the stopped child and the signal that
caused the child to stop.
<PRE>
#define WIFSTOPPED(x)		(((int)((x) &amp; 0xFF)==0x7F) &amp;&amp; ((int)(((x)&gt;&gt;8)&amp;0xFF)!=0))
#define WSTOPSIG(x)		((int)(((x)&gt;&gt;8) &amp; 0xFF))

void
HandleSignal( LONG signo )
{
	WORD pid;
	WORD childsignal;
	ULONG r;

	if( signo == SIGCHLD )
	{
			r = <a name=pwait3>Pwait3( 0x2, 0L );
			if( WIFSTOPPED( r ) )
			{
					pid = r &gt;&gt; 16;
					childsignal = WSTOPSIG( r );
			}
	}
}
</PRE>

<P>
After reception of this signal, the child process may be restarted
with <B>Fcntl()</B> using either the <a name=ptracego><B>PTRACEGO</B>, <a name=ptraceflow><B>PTRACEFLOW</B>,
or <a name=ptracestep><B>PTRACESTEP</B> commands. Setting <B>PTRACEFLOW</B> or <B>PTRACESTEP</B>
causes a <B>SIGTRAP</B> signal to be raised on the next program
flow change (ex: BRA or JMP) or the instruction respectively.
<a name=processcontext><H5>Modifying the Process Context</H5>

<P>
A processes' registers may be modified during tracing using the
method as illustrated in the following example:
<PRE>
struct context
{
	LONG		regs[15];		// Registers d0-d7, a0-a6
	LONG		usp;				// User stack pointer
	WORD		sr;				// Status register
	LONG		pc;				// Program counter
	LONG		ssp;				// Supervisor stack pointer
	LONG 		tvec;			// GEMDOS terminate vector
	char		fstate[216];		// Internal FPU state
	LONG		fregs[3*8];		// Registers FP0-FP7
	LONG		fctrl[3]			// Registers FPCR/FPSR/FPIAR

	// More undocumented fields exist here
} c;

void
ModifyContext( LONG handle )
{
<a name=foutstat2>	LONG curprocaddr, ctxtsize;

	Fcntl( handle, &amp;curprocaddr, PPROCADDR );
	Fcntl( handle, &amp;ctxtsize, PCTXTSIZE );

	curprocaddr -= 2 * ctxtsize;

	<a name=fseek2>Fseek( curprocaddr, handle, SEEK_SET );
	Fread( handle, (LONG)sizeof(struct context), &amp;c );

	/* Modify context c here */

	Fseek( curprocaddr, handle, SEEK_SET );
	<a name=fwrite2>Fwrite( handle, (LONG)sizeof(struct context), &amp;c );
}

</PRE>

<H5><FONT SIZE=2><a name=debugging keys>MiNT Debugging Keys</FONT></H5>

<P>
<B>MiNT</B> may be programmed to output special debugging messages
to the debugging device through the use of special system keys.
The supported system keys are shown in the table below:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Key Combination</FONT></B>
</TH><TH><B><FONT SIZE=2 >Meaning</FONT></B></TH>
</TR>

<TR><TH>ctrl-alt-F1</TH><TD><FONT SIZE=2>Increase the system debugging level by one.</FONT>
</TD></TR>

<TR><TH>ctrl-alt-F2</TH><TD><FONT SIZE=2>Decrease the system debugging level by one.</FONT>
</TD></TR>

<TR><TH>ctrl-alt-F3</TH><TD><FONT SIZE=2>Cycle the <B>BIOS</B> output device number used for system debugging messages. This key cycles <B>BIOS</B> devices in the order 1-6-7-8-9-2.</FONT>
</TD></TR>

<TR><TH>ctrl-alt-F4</TH><TD><FONT SIZE=2>Restore debugging output to <a name=cdevice>the console device.</FONT>
</TD></TR>

<TR><TH>ctrl-alt-F5</TH><TD><FONT SIZE=2>Output a memory usage map to the debugging device.</FONT>
</TD></TR>

<TR><TH>ctrl-alt-F6</TH><TD><FONT SIZE=2>Output a list of all system processes to the debugging device.</FONT>
</TD></TR>

<TR><TH>ctrl-alt-F7</TH><TD><FONT SIZE=2>Toggles debug 'logging' off and on. When debug logging is on, a 50-line buffer is maintained which contains recent debugging messages. Each time a new debugging message is output, the entire 50 line buffer is output as well.</FONT>
</TD></TR>

<TR><TH>ctrl-alt-F8</TH><TD><FONT SIZE=2>Outputs the 50-line debug log to the debugging device.</FONT>
</TD></TR>

<TR><TH>ctrl-alt-F9</TH><TD><FONT SIZE=2>Outputs the system memory map to the debugging device. The memory protection flags of each page are shown.</FONT>
</TD></TR>

<TR><TH>ctrl-alt-F10</TH><TD><FONT SIZE=2>Outputs an extended system memory map to the debugging device. The memory protection status, owner's PID, and format of each memory block are output to the debugging device.</FONT>
</TD></TR>

</TABLE>

<P>

<P>
CTRL-ALT-F1 and CTRL-ALT-F2 alter the current system debugging
level. <B>MiNT</B> supports four debugging levels as follows:
<TABLE BORDER=1>

<TR><TH>
<CENTER>
<B><FONT SIZE=1 >Level</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Meaning</FONT></B></TH>
</TR>

<TR><TD>
<CENTER>
0
</CENTER>
</TD><TD><FONT SIZE=2>Only fatal OS errors are reported to the debugging device (this is the default mode).</FONT>
</TD></TR>

<TR><TD>
<CENTER>
1
</CENTER>
</TD><TD><FONT SIZE=2>Processor exceptions are output to the debugging device.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
2
</CENTER>
</TD><TD><FONT SIZE=2>Processor exceptions and failed system calls are output to the debugging device.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
3
</CENTER>
</TD><TD><FONT SIZE=2>Constant <B>MiNT</B> status reports, processor exceptions, and failed system calls are output to the debugging device.</FONT>
</TD></TR>

</TABLE>

<P>

<HR>

<a name=cnf><H4><FONT SIZE=4 ><a name=mintcnffile>The MINT.CNF File</FONT></H4>

<HR>

<P>
<B>MultiTOS</B> looks for an ASCII text  file upon bootup called
'MINT.CNF' which may be used to execute commands or set <B>MiNT</B>
variables. The following table illustrates what commands are recognized
in the 'MINT.CNF' file:
<TABLE BORDER=1>

<TR><TH>
<CENTER>
<B><FONT SIZE=1 >Command</FONT></B>
</CENTER>

</TH><TH><B><FONT SIZE=2 >Example</FONT></B></TH>
<TH><B><FONT SIZE=2 >Meaning</FONT></B></TH></TR>

<TR><TD>
<CENTER>
cd
</CENTER>
</TD><TD><TT><FONT SIZE=2 FACE="Courier New">cd c:\multitos</FONT></TT>
</TD><TD><FONT SIZE=2>Change the <B>GEMDOS</B> working directory.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
echo
</CENTER>
</TD><TD><TT><FONT SIZE=2 FACE="Courier New">echo "Atari Computer Booting..."</FONT></TT>
</TD><TD><FONT SIZE=2>Echo a string to the screen.</FONT></TD>
</TR>

<TR><TD>
<CENTER>
ren
</CENTER>
</TD><TD><TT><FONT SIZE=2 FACE="Courier New">ren c:\test.prg c:\test.app</FONT></TT>
</TD><TD><FONT SIZE=2>Rename a file.</FONT></TD></TR>

<TR><TD>
<CENTER>
sln
</CENTER>
</TD><TD><TT><FONT SIZE=2 FACE="Courier New">sln c:\level1\level2\level3 u:\deep</FONT></TT>
</TD><TD><FONT SIZE=2>Create a symbolic link on drive 'U:'.</FONT>
</TD></TR>

<TR><TD>
<CENTER>
alias
</CENTER>
</TD><TD><TT><FONT SIZE=2 FACE="Courier New">alias x: u:\proc</FONT></TT>
</TD><TD><FONT SIZE=2>Create an alias drive.</FONT></TD></TR>

<TR><TD>
<CENTER>
exec
</CENTER>
</TD><TD><TT><FONT SIZE=2 FACE="Courier New">exec c:\sam.prg</FONT></TT>
</TD><TD><FONT SIZE=2>Execute a program.</FONT></TD></TR>

</TABLE>

<P>

<P>
The following <B>MiNT</B> variables may be set in the 'MINT.CNF'
file:
<TABLE BORDER=1>

<TR><TH><B><FONT SIZE=1 >Variable</FONT></B></TH>
<TH><B><FONT SIZE=2 >Meaning</FONT></B></TH></TR>

<TR><TH><B>INIT</B></TH><TD><FONT SIZE=2>Execute the named <B>TOS</B> program. For example:</FONT>
<CENTER>
<TT><FONT SIZE=2 FACE="Courier New">INIT=c:\multitos\sam.prg</FONT></TT>
</CENTER>

</TD></TR>

<TR><TH><B>GEM</B></TH><TD><FONT SIZE=2>Execute the named <B>GEM</B> program. For example:</FONT>
<CENTER>
<TT><FONT SIZE=2 FACE="Courier New">GEM=c:\multitos\miniwin.app</FONT></TT>
</CENTER>

</TD></TR>

<TR><TH><B>CON</B></TH><TD><FONT SIZE=2>Redirect console input and output to the named file. For example:</FONT>
<CENTER>
<TT><FONT SIZE=2 FACE="Courier New"><a name=modemdevice>CON=u:\dev\modem1</FONT></TT>
</CENTER>

</TD></TR>

<TR><TH><B>PRN</B></TH><TD><FONT SIZE=2>Redirect printer output to the named file. For example:</FONT>
<CENTER>
<TT><FONT SIZE=2 FACE="Courier New">PRN=c:\spool.txt</FONT></TT>
</CENTER>

</TD></TR>

<TR><TH><B>DEBUG_LEVEL</B></TH><TD><FONT SIZE=2>Set the <B>MiNT</B> debugging level (default is 0). For example:</FONT>
<CENTER>
<TT><FONT SIZE=2 FACE="Courier New">DEBUG_LEVEL=1</FONT></TT>
</CENTER>

</TD></TR>

<TR><TH><B>DEBUG_DEVNO</B></TH><TD><FONT SIZE=2>Set the <B>BIOS</B> device number that <B>MiNT</B> will send debugging messages to. For example:</FONT>
<CENTER>
<TT><FONT SIZE=2 FACE="Courier New">DEBUG_DEVNO=1</FONT></TT>
</CENTER>

</TD></TR>

<TR><TH><B>SLICES</B></TH><TD><FONT SIZE=2>Set the number of 20ms time slices given to an application at a time (the default is 2). For example:</FONT>
<CENTER>
<TT><FONT SIZE=2 FACE="Courier New">SLICES=3</FONT></TT>
</CENTER>

</TD></TR>

<TR><TH><B>MAXMEM</B></TH><TD><FONT SIZE=2>Set the maximum amount of memory (in kilobytes) any application can be allocated (the default is unlimited). For example:</FONT>
<CENTER>
<TT><FONT SIZE=2 FACE="Courier New">MAXMEM=8192</FONT></TT>
</CENTER>

</TD></TR>

<TR><TH><B>BIOSBUF</B></TH><TD><FONT SIZE=2>Enable/Disable <B>Bconout()</B> optimizations. The parameter should be 'Y' to enable or 'N' to disable these optimizations. For example:</FONT>
<CENTER>
<TT><FONT SIZE=2 FACE="Courier New">BIOSBUF=Y</FONT></TT>
</CENTER>

</TD></TR>

</TABLE>

<PRE>

</PRE>

<HR>

<a name=character><a name=charfunctions><H4><FONT SIZE=4 >GEMDOS Character Functions</FONT>
</H4>

<HR>

<P>
<B>GEMDOS</B> provides a number of functions to communicate on
a character basis with the default system devices. Because of
irregularities with these calls in some <B>TOS</B> versions, usage
of the <B>BIOS</B> functions is usually recommended instead (the
<B>BIOS</B> does not support redirection, however).
<P>
The <B>GEMDOS</B> character functions are illustrated in the table
below:
<TABLE BORDER=1>

<TR><TD>
<CENTER>
<B>Device:</B>
</CENTER>
</TD><TH>
<CENTER>
<B><FONT SIZE=2 >Input</FONT></B>
</CENTER>

</TH><TH>
<CENTER>
<B><FONT SIZE=2 >Output</FONT></B>
</CENTER>

</TH><TH>
<CENTER>
<B><FONT SIZE=2 >Status</FONT></B>
</CENTER>

</TH></TR>

<TR><TD>
<CENTER>
con:
</CENTER>
</TD><TD><B><FONT SIZE=2><a name=cconin>Cconin()</FONT></B> - Character
<P>
<B><FONT SIZE=2><a name=cnecin>Cnecin()</FONT></B> - No Echo
<P>
<B><FONT SIZE=2><a name=cconrs>Cconrs()</FONT></B> - String
</TD><TD><B><FONT SIZE=2><a name=cconout>Cconout()</FONT></B> - Character
<P>
<B><FONT SIZE=2><a name=cconws>Cconws()</FONT></B> - String
</TD><TD><B><FONT SIZE=2><a name=cconis>Cconis()</FONT></B> - Input
<P>
<B><FONT SIZE=2><a name=cconos>Cconos()</FONT></B> - Output
</TD></TR>

<TR><TD>
<CENTER>
prn:
</CENTER>
</TD><TD><FONT SIZE=2>None</FONT>
</TD><TD><B><FONT SIZE=2><a name=cprnout>cprnout()</FONT></B></TD><TD><B><FONT SIZE=2><a name=cprnos>Cprnos()</FONT></B>
</TD></TR>

<TR><TD>
<CENTER>
aux:
</CENTER>
</TD><TD><B><FONT SIZE=2><a name=cauxin>Cauxin()</FONT></B>
</TD><TD><B><FONT SIZE=2><a name=cauxout>Cauxout()</FONT></B></TD><TD><B><FONT SIZE=2><a name=cauxis>Cauxis()</FONT></B> - Input
<P>
<B><FONT SIZE=2><a name=cauxos>Cauxos()</FONT></B> - Output
</TD></TR>

<TR><TD>
<CENTER>
N/A
</CENTER>
</TD><TD><B><FONT SIZE=2><a name=crawio>Crawio()</FONT></B> and <a name=crawcin><B>Crawcin()</B>
</TD><TD><B><FONT SIZE=2>Crawio()</FONT></B></TD><TD><B><FONT SIZE=2>Cconis()</FONT></B> - Input
<P>
<B><FONT SIZE=2>Cconos()</FONT></B> - Output
</TD></TR>

</TABLE>

<P>

<HR>

<a name=function><a name=date_functions><H4><FONT SIZE=4 >GEMDOS Time & Date Functions</FONT>
</H4>

<HR>

<P>
<B>GEMDOS</B> provides four functions for the manipulation of
time. <a name=tsetdate><B>Tsetdate()</B> and <a name=tsettime><B>Tsettime()</B> set the date and
time respectively. <a name=tgetdate><B>Tgetdate()</B> and <a name=gettime2><a name=tgettime><B>Tgettime()</B> get
the date and time respectively.
<P>
As of <B>TOS</B> 1.02, the <B>GEMDOS</B> <a name=time_functions>time functions also update
the <B>BIOS</B> time.
<HR>

<a name=calling><H4><FONT SIZE=4 >GEMDOS Function Calling Procedure</FONT>
</H4>

<HR>

<P>
<B>GEMDOS</B> system functions are called via the TRAP #1 exception.
Function arguments are pushed onto the current stack in reverse
order followed by the function opcode. The calling application
is responsible for correctly resetting the stack pointer after
the call. 
<P>
<B>GEMDOS</B> may utilize registers D0-D2 and A0-A2 as scratch
registers and their contents should not be depended upon at the
completion of a call. In addition, the function opcode placed
on the stack will be modified.
<P>
The following example for <a name=super><B>Super()</B> illustrates calling <B>GEMDOS</B>
from assembly language:
<PRE>
clr.l		-(sp)
move.w		#$20,-(sp)
trap		#1
addq.l		#4,sp

</PRE>

<P>
'C' compilers often provide a reusable interface to <B>GEMDOS</B>
that allows new <B>GEMDOS</B> calls to be added with a macro as
in the following example:
<PRE>
#define Super( a )	gemdos( 0x20, a )

</PRE>

<P>
<a name=gemdos>The gemdos() function used in the above macro can be written in
assembly language as follows:
<PRE>
			.globl		_gemdos

			.text
_gemdos:
			move.l		(sp)+, t1sav		; Save return address
			trap			#1				; Call GEMDOS
			move.l		t1sav,-(sp)		; Restore return address
			rts

			.bss

t1sav:			ds.l			1				; Return address storage

			.end

</PRE>

<P>
<B>GEMDOS</B> is not guaranteed to be re-entrant and therefore
should not be called from an interrupt handler.
<p>
<hr><center><a href="toc.htm"> Table of Contents | </a><a href="index.htm"> Index </a></center>
</BODY>

</HTML>
